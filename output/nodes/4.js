var jx = Object.defineProperty;
var jg = _ => {
  throw TypeError(_)
};
var Vx = (_, s, m) => s in _ ? jx(_, s, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: m
}) : _[s] = m;
var mr = (_, s, m) => Vx(_, typeof s != "symbol" ? s + "" : s, m),
  Af = (_, s, m) => s.has(_) || jg("Cannot " + m);
var rt = (_, s, m) => (Af(_, s, "read from private field"), m ? m.call(_) : s.get(_)),
  Ir = (_, s, m) => s.has(_) ? jg("Cannot add the same private member more than once") : s instanceof WeakSet ? s.add(_) : s.set(_, m),
  ia = (_, s, m, y) => (Af(_, s, "write to private field"), y ? y.call(_, m) : s.set(_, m), m),
  jr = (_, s, m) => (Af(_, s, "access private method"), m);
import "../chunks/BjnY0gch.js";
import {
  o as An,
  s as ii
} from "../chunks/CWQx_HBc.js";
import {
  a3 as qx,
  b7 as Zx,
  bq as Ux,
  b9 as $x,
  br as Gx,
  b3 as Hx,
  av as ut,
  g as w,
  aw as ce,
  au as yi,
  at as ri,
  p as Br,
  f as Pe,
  d as E,
  r as k,
  s as Z,
  u as ht,
  n as _n,
  t as Ye,
  bi as Ai,
  b as H,
  c as Fr,
  y as Xr,
  v as Lr,
  bn as Nu,
  x as wm,
  z as ll,
  ax as Kt,
  a as Ct,
  aX as Mi,
  aH as Wx,
  aG as Vg,
  aI as Xx,
  aK as Tv,
  bs as cs,
  ay as Ta,
  bt as Sv,
  $ as Yx
} from "../chunks/CU1IDgoR.js";
import {
  s as ye
} from "../chunks/_gR7GQ79.js";
import {
  p as Et,
  i as je,
  r as ir,
  s as Co,
  u as Cv
} from "../chunks/PUQ9h4RA.js";
import {
  h as Kx
} from "../chunks/Cnq544TE.js";
import {
  r as us,
  f as Yi,
  a as zr,
  g as Pv,
  b as or,
  s as kr,
  e as Ic,
  h as Fu,
  c as bo
} from "../chunks/XoNiCaaU.js";
import {
  a as sl,
  k as ju,
  t as Ii
} from "../chunks/flixvMGo.js";
import {
  p as wa
} from "../chunks/CY-W0PWi.js";
import {
  S as Xi,
  a as an,
  t as Vr,
  u as Mt,
  p as Ts,
  g as fa,
  P as Jx,
  y as Qx,
  q as e1,
  v as t1,
  C as qg,
  w as kf,
  x as r1,
  z as n1,
  d as i1,
  A as a1
} from "../chunks/DfZnD8wK.js";
import {
  c as Iv,
  A as sa,
  a as Uf,
  g as Ef,
  p as s1,
  b as o1
} from "../chunks/B7D90iwt.js";
import {
  g as Mv,
  b as l1
} from "../chunks/BMbS-s_c.js";
import {
  h as Av
} from "../chunks/BccsscqH.js";
import {
  b as Xs
} from "../chunks/C6r518T4.js";
import {
  L as c1,
  c as $f,
  D as kv,
  r as u1,
  t as h1,
  b as d1,
  R as p1
} from "../chunks/B-8RLdzV.js";
import {
  g as Ve,
  l as f1
} from "../chunks/etMdSgD_.js";
import {
  c as Tm
} from "../chunks/DEqQoPFz.js";
import {
  d as m1,
  L as Sm,
  p as Cm,
  C as Pm,
  G as Zg,
  c as _1,
  T as Gf
} from "../chunks/DK2E2eHp.js";
import {
  e as ui,
  i as cp
} from "../chunks/PfwISL8s.js";
import {
  c as Im,
  a as Mm,
  b as g1
} from "../chunks/Bxy9xDv7.js";
import {
  P as ls,
  t as Ev
} from "../chunks/BEDA9w4X.js";
import {
  g as Ri,
  a as up,
  c as v1,
  b as y1
} from "../chunks/C_ZglwOZ.js";
import {
  f as ol,
  t as x1
} from "../chunks/zuqj04Bu.js";
import {
  A as b1
} from "../chunks/DYEP3QaH.js";
import {
  A as zv,
  d as vc,
  D as Lv,
  a as hp,
  r as w1,
  f as T1,
  I as Ug,
  e as S1,
  c as C1,
  P as Dv,
  b as P1
} from "../chunks/WrKATlgm.js";
import {
  f as aa,
  s as $d
} from "../chunks/Bg3eUORe.js";
import "../chunks/DN8HxMY9.js";
import {
  i as Rv
} from "../chunks/Ng92Mf6h.js";
import {
  L as Bv
} from "../chunks/BRB-1XdE.js";
import {
  c as vi
} from "../chunks/BxJ6sGYA.js";
import {
  L as I1,
  T as Fv,
  a as M1
} from "../chunks/Co-fci34.js";
import {
  _ as A1
} from "../chunks/Ct1z-RtS.js";
import {
  R as k1
} from "../chunks/Bu9q1Vyr.js";
import {
  W as E1
} from "../chunks/DXRTIcOW.js";
import {
  r as z1
} from "../chunks/-AOtDqAV.js";
(function() {
  try {
    var _ = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    _.SENTRY_RELEASE = {
      id: "db50de114564c1615b532cc812ac881318d7283e"
    }
  } catch {}
})();
try {
  (function() {
    var _ = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      s = new _.Error().stack;
    s && (_._sentryDebugIds = _._sentryDebugIds || {}, _._sentryDebugIds[s] = "001dfcc8-c392-4b1b-91d9-d7782e5362c3", _._sentryDebugIdIdentifier = "sentry-dbid-001dfcc8-c392-4b1b-91d9-d7782e5362c3")
  })()
} catch {}
const L1 = [];

function D1(_, s = !1, m = !1) {
  return Gd(_, new Map, "", L1, null, m)
}

function Gd(_, s, m, y, M = null, z = !1) {
  if (typeof _ == "object" && _ !== null) {
    var T = s.get(_);
    if (T !== void 0) return T;
    if (_ instanceof Map) return new Map(_);
    if (_ instanceof Set) return new Set(_);
    if (qx(_)) {
      var o = Array(_.length);
      s.set(_, o), M !== null && s.set(M, o);
      for (var B = 0; B < _.length; B += 1) {
        var N = _[B];
        B in _ && (o[B] = Gd(N, s, m, y, null, z))
      }
      return o
    }
    if (Zx(_) === Ux) {
      o = {}, s.set(_, o), M !== null && s.set(M, o);
      for (var W in _) o[W] = Gd(_[W], s, m, y, null, z);
      return o
    }
    if (_ instanceof Date) return structuredClone(_);
    if (typeof _.toJSON == "function" && !z) return Gd(_.toJSON(), s, m, y, _)
  }
  if (_ instanceof EventTarget) return _;
  try {
    return structuredClone(_)
  } catch {
    return _
  }
}

function R1() {
  return Symbol($x)
}

function dp(_, s) {
  Gx(window, ["resize"], () => Hx(() => s(window[_])))
}
const B1 = () => "Log in",
  F1 = () => "Entrar",
  O1 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? B1() : F1(),
  N1 = () => "Store",
  j1 = () => "Loja",
  Ov = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? N1() : j1(),
  V1 = () => "Alliance",
  q1 = () => "Aliança",
  pp = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? V1() : q1(),
  Z1 = () => "Leaderboard",
  U1 = () => "Ranking",
  Am = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Z1() : U1(),
  $1 = () => "Unlock",
  G1 = () => "Destravar",
  H1 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? $1() : G1(),
  W1 = () => "Lock",
  X1 = () => "Travar",
  Y1 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? W1() : X1(),
  K1 = () => "Info",
  J1 = () => "Informações",
  Q1 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? K1() : J1(),
  eb = () => "Zoom in",
  tb = () => "Aumentar zoom",
  rb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? eb() : tb(),
  nb = () => "Zoom out",
  ib = () => "Diminuir zoom",
  ab = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? nb() : ib(),
  sb = () => "Previous location",
  ob = () => "Localização anterior",
  lb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? sb() : ob(),
  cb = () => "Offline",
  ub = () => "Offline",
  hb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? cb() : ub(),
  db = () => "Zoom in to see the pixels",
  pb = () => "Amplie para ver os pixels",
  fb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? db() : pb(),
  mb = () => "Phone verification required",
  _b = () => "Verificação de telefone necessária",
  $g = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? mb() : _b(),
  gb = () => "My location",
  vb = () => "Minha localização",
  yb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? gb() : vb(),
  xb = () => "You don't have charges to paint. Wait to recharge.",
  bb = () => "Você não possui tinta para pintar. Aguarde para carrega-las.",
  wb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? xb() : bb(),
  Tb = () => "Map powered by:",
  Sb = () => "Mapa fornecido por:",
  Cb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Tb() : Sb(),
  Pb = () => "OpenMapTiles Data from",
  Ib = () => "OpenMapTiles com dados do",
  Mb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Pb() : Ib(),
  Ab = () => "Feedback and bugs",
  kb = () => "Feedback e bugs",
  Eb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Ab() : kb(),
  zb = () => "Overview",
  Lb = () => "Visão Geral",
  Db = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? zb() : Lb(),
  Rb = () => "How to paint faster",
  Bb = () => "Como pintar mais rápido",
  Fb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Rb() : Bb(),
  Ob = () => "When painting, click on the button",
  Nb = () => "Quando pintar clique no botão",
  jb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Ob() : Nb(),
  Vb = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  qb = () => "no canto superior direito da tela. Isso bloqueará a tela, mas também permitirá pintar movendo o dedo sobre o mapa.",
  Zb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Vb() : qb(),
  Ub = () => "Hold",
  $b = () => "Segure",
  Gb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Ub() : $b(),
  Hb = () => "SPACE",
  Wb = () => "Espaço",
  Xb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Hb() : Wb(),
  Yb = () => "and move your cursor over the map.",
  Kb = () => "e mova seu cursor sobre o mapa.",
  Jb = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Yb() : Kb(),
  Qb = () => "Explore",
  e2 = () => "Explorar",
  t2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Qb() : e2(),
  r2 = () => "Recharge paint charges",
  n2 = () => "Recarga de tinta",
  i2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? r2() : n2(),
  a2 = () => "Items",
  s2 = () => "Itens",
  o2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? a2() : s2(),
  l2 = () => "Get more charges",
  c2 = () => "Recarregue tinta para pintar",
  u2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? l2() : c2(),
  h2 = _ => `+${_.amount} Max. Charges`,
  d2 = _ => `+${_.amount} Tinta máxima`,
  p2 = (_, s = {}) => (s.locale ?? Ve()) === "en" ? h2(_) : d2(_),
  f2 = () => "Increase your maximum paint charges capacity",
  m2 = () => "Aumente sua capacidade máxima de tinta",
  _2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? f2() : m2(),
  g2 = () => "Profile picture",
  v2 = () => "Imagem de perfil",
  y2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? g2() : v2(),
  x2 = () => "Add a new 16x16 profile picture",
  b2 = () => "Adicionar uma nova imagem de perfil 16x16",
  w2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? x2() : b2(),
  T2 = () => "Not enough droplets",
  S2 = () => "Droplets insuficientes",
  fp = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? T2() : S2(),
  C2 = () => "Show profile",
  P2 = () => "Exibir perfil",
  I2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? C2() : P2(),
  M2 = () => "Menu",
  A2 = () => "Menu",
  k2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? M2() : A2(),
  E2 = _ => `Could not install the app: ${_.error}`,
  z2 = _ => `Não pode instalar o app: ${_.error}`,
  L2 = (_, s = {}) => (s.locale ?? Ve()) === "en" ? E2(_) : z2(_),
  D2 = () => "Install App",
  R2 = () => "Instalar App",
  B2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? D2() : R2(),
  F2 = () => "Livestreams",
  O2 = () => "Livestreams",
  N2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? F2() : O2(),
  j2 = () => "Log Out",
  V2 = () => "Log Out",
  q2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? j2() : V2(),
  Z2 = () => "Hide UI",
  U2 = () => "Esconder UI",
  $2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Z2() : U2(),
  G2 = () => "Change picture:",
  H2 = () => "Change picture:",
  W2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? G2() : H2(),
  X2 = () => "Show last painted pixel on alliance",
  Y2 = () => "Mostrar último pixel pintado na aliança",
  K2 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? X2() : Y2(),
  J2 = () => "Delete Account",
  Q2 = () => "Deletar Conta",
  Gg = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? J2() : Q2(),
  ew = () => "Save",
  tw = () => "Salvar",
  rw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? ew() : tw(),
  nw = () => "Are you absolutely sure?",
  iw = () => "Você tem certeza absoluta?",
  aw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? nw() : iw(),
  sw = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  ow = () => "Isso excluirá permanentemente sua conta e todos os dados associados. Esta ação não pode ser desfeita.",
  lw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? sw() : ow(),
  cw = () => "Profile",
  uw = () => "Perfil",
  hw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? cw() : uw(),
  dw = () => "Display your country’s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  pw = () => "Exiba a bandeira do seu país ao lado do seu nome de usuário. Além disso, ao pintar em regiões onde você possui a bandeira correspondente, você recupera 10% das tintas gastas.",
  fw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? dw() : pw(),
  mw = () => "Does not need to be equipped to provide the bonus",
  _w = () => "Não precisa estar equipada para obter o bônus",
  gw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? mw() : _w(),
  vw = () => "Equipped",
  yw = () => "Equipado",
  xw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? vw() : yw(),
  bw = () => "Equip",
  ww = () => "Equipar",
  Tw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? bw() : ww(),
  Sw = () => "Country",
  Cw = () => "País",
  Nv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Sw() : Cw(),
  Pw = () => "No country found.",
  Iw = () => "País não encontrado.",
  Mw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Pw() : Iw(),
  Aw = () => "Welcome to",
  kw = () => "Bem vindo ao",
  Ew = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Aw() : kw(),
  zw = () => "Rules",
  Lw = () => "Regras",
  Dw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? zw() : Lw(),
  Rw = () => "Important",
  Bw = () => "Importante",
  Fw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Rw() : Bw(),
  Ow = () => "🚫 No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  Nw = () => "🚫 Conteúdo inapropriado não permitido (+18, discurso de ódio, links inapropriados, conteúdo altamente sugestivo, ...)",
  jw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Ow() : Nw(),
  Vw = () => "😈 Do not paint over other artworks using random colors or patterns just to mess things up",
  qw = () => "😈 Não desenhe por cima de outras artes usando cores ou padrões aleatórios só para bagunçar",
  Zw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Vw() : qw(),
  Uw = () => "🧑‍🤝‍🧑 Do not paint with more than one account",
  $w = () => "🧑‍🤝‍🧑 Não desenhe com mais de uma conta",
  Gw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Uw() : $w(),
  Hw = () => "🤖 Use of bots is not allowed",
  Ww = () => "🤖 Usar bots não é permitido",
  Xw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Hw() : Ww(),
  Yw = () => "🙅 Disclosing other's personal information is not allowed",
  Kw = () => "🙅 Divulgar informações pessoais dos outros não é permitido",
  Jw = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Yw() : Kw(),
  Qw = () => "✅ Painting over other artworks to complement them or create a new drawing is allowed",
  e5 = () => "✅ Desenhar sobre outras artes para complementar ou criar novas artes é permitido",
  t5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Qw() : e5(),
  r5 = () => "✅ Griefing political party flags or portraits of politicians is allowed",
  n5 = () => "✅ Desenhar sobre bandeiras de partidos e retratos de políticos é permitido",
  i5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? r5() : n5(),
  a5 = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  s5 = () => "A violação destas regras pode levar à suspensão da conta ou à remoção de desenhos.",
  o5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? a5() : s5(),
  l5 = () => "Understood",
  c5 = () => "Entendido",
  u5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? l5() : c5(),
  h5 = () => "Toggle art opacity",
  d5 = () => "Alterar opacidade",
  jv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? h5() : d5(),
  p5 = () => "Paint",
  f5 = () => "Pintar",
  Vv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? p5() : f5(),
  m5 = () => "Select a color",
  _5 = () => "Selecione uma color",
  g5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? m5() : _5(),
  v5 = () => "Select a pixel to erase",
  y5 = () => "Selecione um pixel para apagar",
  x5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? v5() : y5(),
  b5 = () => "Pick a color from the map",
  w5 = () => "Escolha uma cor do mapa",
  T5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? b5() : w5(),
  S5 = () => "Click",
  C5 = () => "Clique",
  P5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? S5() : C5(),
  I5 = () => "SPACE",
  M5 = () => "ESPAÇO",
  A5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? I5() : M5(),
  k5 = () => "or hold",
  E5 = () => "ou segure",
  z5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? k5() : E5(),
  L5 = () => "to paint,",
  D5 = () => "para pintar",
  R5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? L5() : D5(),
  B5 = () => "You can paint more than 1 pixel",
  F5 = () => "Você pode pintar mais de 1 pixel",
  O5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? B5() : F5(),
  N5 = () => "Paint pixel",
  j5 = () => "Pintar pixel",
  V5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? N5() : j5(),
  q5 = () => "Color Picker",
  Z5 = () => "Conta Gotas",
  U5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? q5() : Z5(),
  $5 = () => "+2 max. charge/level",
  G5 = () => "+2 tinta máxima/level",
  H5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? $5() : G5(),
  W5 = () => "Name",
  X5 = () => "Nome",
  Hf = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? W5() : X5(),
  Y5 = () => "Discord Username",
  K5 = () => "Usuário do Discord",
  J5 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Y5() : K5(),
  Q5 = () => "Max. Charges",
  e3 = () => "Tinta máxima",
  Hg = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Q5() : e3(),
  t3 = () => "Paint Charges",
  r3 = () => "Tintas",
  n3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? t3() : r3(),
  i3 = _ => `+${_.amount} Paint Charges`,
  a3 = _ => `+${_.amount} Tintas`,
  s3 = (_, s = {}) => (s.locale ?? Ve()) === "en" ? i3(_) : a3(_),
  o3 = () => "Leave alliance",
  l3 = () => "Sair da aliança",
  c3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? o3() : l3(),
  u3 = () => "Members",
  h3 = () => "Membros",
  qv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? u3() : h3(),
  d3 = () => "Headquarters",
  p3 = () => "Quartel General",
  f3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? d3() : p3(),
  m3 = () => "Not set",
  _3 = () => "Não configurado",
  g3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? m3() : _3(),
  v3 = () => "You are not in an alliance",
  y3 = () => "Você não está em uma aliança",
  x3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? v3() : y3(),
  b3 = () => "Get invited to an alliance",
  w3 = () => "Seja convidado para uma aliança",
  T3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? b3() : w3(),
  S3 = () => "OR",
  C3 = () => "OU",
  P3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? S3() : C3(),
  I3 = () => "Create an alliance",
  M3 = () => "Crie uma aliança",
  A3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? I3() : M3(),
  k3 = () => "Invite link",
  E3 = () => "Link de convite",
  z3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? k3() : E3(),
  L3 = () => "Send the link below to everybody you want to invite to the alliance",
  D3 = () => "Envie o link abaixo para quem você deseja convidar para a aliança",
  R3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? L3() : D3(),
  B3 = () => "Copied",
  F3 = () => "Copiado",
  km = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? B3() : F3(),
  O3 = () => "No description",
  N3 = () => "Sem descrição",
  Zv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? O3() : N3(),
  j3 = () => "Invite",
  V3 = () => "Convite",
  q3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? j3() : V3(),
  Z3 = () => "No pixels painted",
  U3 = () => "Nenhum pixel pintado",
  Em = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Z3() : U3(),
  $3 = () => "Today",
  G3 = () => "Hoje",
  mp = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? $3() : G3(),
  H3 = () => "Week",
  W3 = () => "Semana",
  X3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? H3() : W3(),
  Y3 = () => "Month",
  K3 = () => "Mês",
  J3 = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Y3() : K3(),
  Q3 = () => "All time",
  eT = () => "Geral",
  tT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? Q3() : eT(),
  rT = () => "this week",
  nT = () => "nesta semana",
  zm = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? rT() : nT(),
  iT = () => "this month",
  aT = () => "neste mês",
  Lm = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? iT() : aT(),
  sT = () => "Player",
  oT = () => "Jogador",
  Dm = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? sT() : oT(),
  lT = () => "Last pixel",
  cT = () => "Último pixel",
  uT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? lT() : cT(),
  hT = () => "Create alliance",
  dT = () => "Criar aliança",
  pT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? hT() : dT(),
  fT = () => "Alliance Name",
  mT = () => "Nome da aliança",
  _T = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? fT() : mT(),
  gT = () => "Create",
  vT = () => "Criar",
  yT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? gT() : vT(),
  xT = () => "Give admin",
  bT = () => "Tornar admin",
  wT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? xT() : bT(),
  TT = () => "Ban from alliance",
  ST = () => "Banir da aliança",
  Uv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? TT() : ST(),
  CT = () => "No action",
  PT = () => "Sem opção",
  IT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? CT() : PT(),
  MT = () => "Unban",
  AT = () => "Desbanir",
  kT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? MT() : AT(),
  ET = () => "No banned users",
  zT = () => "Sem usuários banidos",
  LT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? ET() : zT(),
  DT = () => "Update",
  RT = () => "Atualizar",
  BT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? DT() : RT(),
  FT = () => "Error giving admin to user",
  OT = () => "Erro ao tornar usuário admin",
  NT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? FT() : OT(),
  jT = () => "Users",
  VT = () => "Usuários",
  qT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? jT() : VT(),
  ZT = () => "Banned",
  UT = () => "Banido",
  $v = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? ZT() : UT(),
  $T = () => "Regions",
  GT = () => "Regiões",
  HT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? $T() : GT(),
  WT = () => "Countries",
  XT = () => "Países",
  YT = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? WT() : XT(),
  KT = () => "Players",
  JT = () => "Jogadores",
  Gv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? KT() : JT(),
  QT = () => "Alliances",
  eS = () => "Alianças",
  Hv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? QT() : eS(),
  tS = () => "Region",
  rS = () => "Região",
  nS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? tS() : rS(),
  iS = () => "Pixels",
  aS = () => "Pixels",
  _c = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? iS() : aS(),
  sS = () => "Painted",
  oS = () => "Pintados",
  gc = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? sS() : oS(),
  lS = () => "Pixels painted inside the region",
  cS = () => "Pixels pintados dentro da região",
  uS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? lS() : cS(),
  hS = () => "Visit",
  dS = () => "Visitar",
  pS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? hS() : dS(),
  fS = () => "Not painted",
  mS = () => "Não pintado",
  _S = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? fS() : mS(),
  gS = () => "Painted by",
  vS = () => "Pintado por",
  yS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? gS() : vS(),
  xS = () => "Limit reached",
  bS = () => "Limite atingido",
  wS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? xS() : bS(),
  TS = () => "Favorite",
  SS = () => "Favoritar",
  CS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? TS() : SS(),
  PS = () => "Share",
  IS = () => "Compartilhar",
  MS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? PS() : IS(),
  AS = () => "Share place",
  kS = () => "Compartilhar local",
  ES = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? AS() : kS(),
  zS = () => "Mute",
  LS = () => "Mutar",
  DS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? zS() : LS(),
  RS = () => "Unmute",
  BS = () => "Desmutar",
  FS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? RS() : BS(),
  OS = () => "Select the headquarters location",
  NS = () => "Selecione a localização do quartel general",
  jS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? OS() : NS(),
  VS = () => "Pixels painted inside the country",
  qS = () => "Pixels pintados dentro do país",
  ZS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? VS() : qS(),
  US = () => "Username copied to clipboard",
  $S = () => "Usuário copiado",
  GS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? US() : $S(),
  HS = () => "No more charges",
  WS = () => "Acabou a tinta",
  XS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? HS() : WS(),
  YS = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  KS = () => "Não é permitido usar várias contas. Use sua conta principal para pintar.",
  JS = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? YS() : KS(),
  QS = () => "SMS sent to",
  eC = () => "SMS enviado para",
  tC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? QS() : eC(),
  rC = () => "Phone successfully verified",
  nC = () => "Telefone verificado com sucesso",
  iC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? rC() : nC(),
  aC = () => "Not a valid phone number",
  sC = () => "Não é um número válido",
  oC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? aC() : sC(),
  lC = () => "Location unfavorited",
  cC = () => "Localização desfavoritada",
  uC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? lC() : cC(),
  hC = () => "Location favorited",
  dC = () => "Localização favoritada",
  pC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? hC() : dC(),
  fC = () => "Giving admin to user",
  mC = () => "Tornar usuário um admin",
  _C = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? fC() : mC(),
  gC = () => "Profile updated",
  vC = () => "Perfil atualizado",
  yC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? gC() : vC(),
  xC = () => "Account successfully deleted",
  bC = () => "Conta deletada com sucesso",
  wC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? xC() : bC(),
  TC = () => "Logged out",
  SC = () => "Logout feito",
  CC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? TC() : SC(),
  PC = () => "Could not logout. Try refreshing the page.",
  IC = () => "Não foi possível sair da conta. Tente recarregar a página.",
  MC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? PC() : IC(),
  AC = () => "You need to zoom in to select a pixel",
  kC = () => "Dê zoom para selecionar um pixel",
  EC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? AC() : kC(),
  zC = () => "Phone verification",
  LC = () => "Verificação de telefone",
  DC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? zC() : LC(),
  RC = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
  BC = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experiência segura e criativa para todos.",
  FC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? RC() : BC(),
  OC = () => "Send Code",
  NC = () => "Enviar o código",
  jC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? OC() : NC(),
  VC = () => "Input the code",
  qC = () => "Insira o código",
  ZC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? VC() : qC(),
  UC = () => "Sent to",
  $C = () => "Enviar para",
  GC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? UC() : $C(),
  HC = () => "Resend Code",
  WC = () => "Reenviar Código",
  XC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? HC() : WC(),
  YC = () => "Try another number",
  KC = () => "Tentar outro número",
  JC = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? YC() : KC(),
  QC = () => "Edit profile",
  eP = () => "Editar perfil",
  tP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? QC() : eP(),
  rP = () => "Image",
  nP = () => "Imagem",
  iP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? rP() : nP(),
  aP = () => "Download",
  sP = () => "Download",
  oP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? aP() : sP(),
  lP = () => "Image copied to clipboard",
  cP = () => "Imagem copiada para a área de transferência",
  uP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? lP() : cP(),
  hP = () => "My map is lagging",
  dP = () => "Meu mapa está travando",
  pP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? hP() : dP(),
  fP = () => "Verify if",
  mP = () => "Verifique se",
  _P = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? fP() : mP(),
  gP = () => "Use hardware acceleration when available",
  vP = () => "Usar aceleração gráfica quando disponível",
  yP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? gP() : vP(),
  xP = () => "is enabled on",
  bP = () => "está habilitado em",
  wP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? xP() : bP(),
  TP = () => "Follow the instructions to enable hardware acceleration",
  SP = () => "Siga a instrução para habilitar a aceleração de hardware",
  CP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? TP() : SP(),
  PP = () => "Moderation",
  IP = () => "Moderação",
  MP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? PP() : IP(),
  AP = () => "Terms",
  kP = () => "Termos",
  EP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? AP() : kP(),
  zP = () => "Privacy",
  LP = () => "Privacidade",
  DP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? zP() : LP(),
  RP = () => "Refund",
  BP = () => "Reembolso",
  FP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? RP() : BP(),
  OP = () => "Clear area",
  NP = () => "Limpar área",
  jP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? OP() : NP(),
  VP = () => "Select the area's first corner",
  qP = () => "Selecione o primeiro canto da área",
  Wv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? VP() : qP(),
  ZP = () => "Select the area's opposite corner",
  UP = () => "Selecione o canto oposto da área",
  Xv = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? ZP() : UP(),
  $P = () => "Admin",
  GP = () => "Administração",
  HP = (_ = {}, s = {}) => (s.locale ?? Ve()) === "en" ? $P() : GP(),
  Us = 2 * Math.PI * 6378137 / 2;
class hl {
  constructor(s = 256) {
    mr(this, "initialResolution");
    this.tileSize = s, this.initialResolution = 2 * Us / this.tileSize
  }
  latLonToMeters(s, m) {
    const y = m / 180 * Us,
      M = Math.log(Math.tan((90 + s) * Math.PI / 360)) / (Math.PI / 180) * Us / 180;
    return [y, M]
  }
  metersToLatLon(s, m) {
    const y = s / Us * 180;
    let M = m / Us * 180;
    return M = 180 / Math.PI * (2 * Math.atan(Math.exp(M * Math.PI / 180)) - Math.PI / 2), [M, y]
  }
  pixelsToMeters(s, m, y) {
    const M = this.resolution(y),
      z = s * M - Us,
      T = Us - m * M;
    return [z, T]
  }
  pixelsToLatLon(s, m, y) {
    const [M, z] = this.pixelsToMeters(s, m, y);
    return this.metersToLatLon(M, z)
  }
  latLonToPixels(s, m, y) {
    const [M, z] = this.latLonToMeters(s, m);
    return this.metersToPixels(M, z, y)
  }
  latLonToPixelsFloor(s, m, y) {
    const [M, z] = this.latLonToPixels(s, m, y);
    return [Math.floor(M), Math.floor(z)]
  }
  metersToPixels(s, m, y) {
    const M = this.resolution(y),
      z = (s + Us) / M,
      T = (Us - m) / M;
    return [z, T]
  }
  latLonToTile(s, m, y) {
    const [M, z] = this.latLonToMeters(s, m);
    return this.metersToTile(M, z, y)
  }
  metersToTile(s, m, y) {
    const [M, z] = this.metersToPixels(s, m, y);
    return this.pixelsToTile(M, z)
  }
  pixelsToTile(s, m) {
    const y = Math.ceil(s / this.tileSize) - 1,
      M = Math.ceil(m / this.tileSize) - 1;
    return [y, M]
  }
  pixelsToTileLocal(s, m) {
    return {
      tile: this.pixelsToTile(s, m),
      pixel: [Math.floor(s) % this.tileSize, Math.floor(m) % this.tileSize]
    }
  }
  tileBounds(s, m, y) {
    const [M, z] = this.pixelsToMeters(s * this.tileSize, m * this.tileSize, y), [T, o] = this.pixelsToMeters((s + 1) * this.tileSize, (m + 1) * this.tileSize, y);
    return {
      min: [M, z],
      max: [T, o]
    }
  }
  tileBoundsLatLon(s, m, y) {
    const M = this.tileBounds(s, m, y);
    return {
      min: this.metersToLatLon(M.min[0], M.min[1]),
      max: this.metersToLatLon(M.max[0], M.max[1])
    }
  }
  resolution(s) {
    return this.initialResolution / 2 ** s
  }
  latLonToTileAndPixel(s, m, y) {
    const [M, z] = this.latLonToMeters(s, m), [T, o] = this.metersToTile(M, z, y), [B, N] = this.metersToPixels(M, z, y);
    return {
      tile: [T, o],
      pixel: [Math.floor(B) % this.tileSize, Math.floor(N) % this.tileSize]
    }
  }
  pixelBounds(s, m, y) {
    return {
      min: this.pixelsToMeters(s, m, y),
      max: this.pixelsToMeters(s + 1, m + 1, y)
    }
  }
  pixelToBoundsLatLon(s, m, y) {
    const M = this.pixelBounds(s, m, y),
      z = .001885,
      T = (M.max[0] - M.min[0]) * z,
      o = (M.max[1] - M.min[1]) * z;
    return M.min[0] -= T, M.max[0] -= T, M.min[1] -= o, M.max[1] -= o, {
      min: this.metersToLatLon(M.min[0], M.min[1]),
      max: this.metersToLatLon(M.max[0], M.max[1])
    }
  }
  latLonToTileBoundsLatLon(s, m, y) {
    const [M, z] = this.latLonToMeters(s, m), [T, o] = this.metersToTile(M, z, y);
    return this.tileBoundsLatLon(T, o, y)
  }
  latLonToPixelBoundsLatLon(s, m, y) {
    const [M, z] = this.latLonToMeters(s, m), [T, o] = this.metersToPixels(M, z, y);
    return this.pixelToBoundsLatLon(Math.floor(T), Math.floor(o), y)
  }
  latLonToRegionAndPixel(s, m, y, M = Xi.regionSize) {
    const [z, T] = this.latLonToPixelsFloor(s, m, y), o = this.tileSize * M;
    return {
      region: [Math.floor(z / o), Math.floor(T / o)],
      pixel: [z % o, T % o]
    }
  }
}

function Rm(_, s = !0) {
  const {
    min: m,
    max: y
  } = _;
  return s ? [
    [m[1], y[0]],
    [y[1], y[0]],
    [y[1], m[0]],
    [m[1], m[0]]
  ] : [
    [m[0], y[1]],
    [y[0], y[1]],
    [y[0], m[1]],
    [m[0], m[1]]
  ]
}

function Bm(_) {
  return [(_.min[0] + _.max[0]) / 2, (_.min[1] + _.max[1]) / 2]
}
const WP = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  Wg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function XP(_) {
  return Math.floor(Math.random() * _)
}
const Wf = 14.5;
async function YP() {
  const _ = QP();
  if (_) return _;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const m = await new Promise((y, M) => navigator.geolocation.getCurrentPosition(z => y(z), z => M(z)));
      return {
        lat: m.coords.latitude,
        lng: m.coords.longitude,
        zoom: Wf
      }
    }
  } catch (s) {
    console.error(s)
  }
  return {
    ...KP().pos,
    zoom: Wf
  }
}

function KP() {
  const _ = Object.entries(JP),
    s = XP(_.length),
    [m, y] = _[s];
  return {
    city: m,
    pos: y
  }
}
const JP = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  Yv = "location";

function os(_, s) {
  localStorage.setItem(Yv, JSON.stringify({
    ..._,
    zoom: s
  }))
}

function QP() {
  const _ = localStorage.getItem(Yv);
  if (!_) return;
  const s = JSON.parse(_);
  return s.zoom ?? (s.zoom = Wf), s
}
var Gu, Hu;
class eI {
  constructor() {
    Ir(this, Gu, ut(-1));
    Ir(this, Hu, ut([]))
  }
  get idx() {
    return w(rt(this, Gu))
  }
  set idx(s) {
    ce(rt(this, Gu), s, !0)
  }
  get entries() {
    return w(rt(this, Hu))
  }
  set entries(s) {
    ce(rt(this, Hu), s)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(s) {
    const m = this.idx + 1,
      y = this.entries[m];
    y && (this.idx = m, s.flyTo({
      center: y.pos,
      zoom: y.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(s) {
    const m = this.idx - 1,
      y = this.entries[m];
    y && (this.idx = m, s.flyTo({
      center: y.pos,
      zoom: y.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(s) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), s]
  }
}
Gu = new WeakMap, Hu = new WeakMap;
const cl = new eI;

function Fm(_) {
  return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
}
var Hd = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
 */
var tI = Hd.exports,
  Xg;

function rI() {
  return Xg || (Xg = 1, (function(_, s) {
    (function(m, y) {
      _.exports = y()
    })(tI, (function() {
      var m = {},
        y = {};

      function M(T, o, B) {
        if (y[T] = B, T === "index") {
          var N = "var sharedModule = {}; (" + y.shared + ")(sharedModule); (" + y.worker + ")(sharedModule);",
            W = {};
          return y.shared(W), y.index(m, W), typeof window < "u" && m.setWorkerUrl(window.URL.createObjectURL(new Blob([N], {
            type: "text/javascript"
          }))), m
        }
      }
      M("shared", ["exports"], (function(T) {
        function o(n, t, r, a) {
          return new(r || (r = Promise))((function(c, p) {
            function f(C) {
              try {
                x(a.next(C))
              } catch (I) {
                p(I)
              }
            }

            function v(C) {
              try {
                x(a.throw(C))
              } catch (I) {
                p(I)
              }
            }

            function x(C) {
              var I;
              C.done ? c(C.value) : (I = C.value, I instanceof r ? I : new r((function(L) {
                L(I)
              }))).then(f, v)
            }
            x((a = a.apply(n, t || [])).next())
          }))
        }

        function B(n, t) {
          this.x = n, this.y = t
        }

        function N(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var W, K;
        typeof SuppressedError == "function" && SuppressedError, B.prototype = {
          clone() {
            return new B(this.x, this.y)
          },
          add(n) {
            return this.clone()._add(n)
          },
          sub(n) {
            return this.clone()._sub(n)
          },
          multByPoint(n) {
            return this.clone()._multByPoint(n)
          },
          divByPoint(n) {
            return this.clone()._divByPoint(n)
          },
          mult(n) {
            return this.clone()._mult(n)
          },
          div(n) {
            return this.clone()._div(n)
          },
          rotate(n) {
            return this.clone()._rotate(n)
          },
          rotateAround(n, t) {
            return this.clone()._rotateAround(n, t)
          },
          matMult(n) {
            return this.clone()._matMult(n)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(n) {
            return this.x === n.x && this.y === n.y
          },
          dist(n) {
            return Math.sqrt(this.distSqr(n))
          },
          distSqr(n) {
            const t = n.x - this.x,
              r = n.y - this.y;
            return t * t + r * r
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(n) {
            return Math.atan2(this.y - n.y, this.x - n.x)
          },
          angleWith(n) {
            return this.angleWithSep(n.x, n.y)
          },
          angleWithSep(n, t) {
            return Math.atan2(this.x * t - this.y * n, this.x * n + this.y * t)
          },
          _matMult(n) {
            const t = n[2] * this.x + n[3] * this.y;
            return this.x = n[0] * this.x + n[1] * this.y, this.y = t, this
          },
          _add(n) {
            return this.x += n.x, this.y += n.y, this
          },
          _sub(n) {
            return this.x -= n.x, this.y -= n.y, this
          },
          _mult(n) {
            return this.x *= n, this.y *= n, this
          },
          _div(n) {
            return this.x /= n, this.y /= n, this
          },
          _multByPoint(n) {
            return this.x *= n.x, this.y *= n.y, this
          },
          _divByPoint(n) {
            return this.x /= n.x, this.y /= n.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const n = this.y;
            return this.y = this.x, this.x = -n, this
          },
          _rotate(n) {
            const t = Math.cos(n),
              r = Math.sin(n),
              a = r * this.x + t * this.y;
            return this.x = t * this.x - r * this.y, this.y = a, this
          },
          _rotateAround(n, t) {
            const r = Math.cos(n),
              a = Math.sin(n),
              c = t.y + a * (this.x - t.x) + r * (this.y - t.y);
            return this.x = t.x + r * (this.x - t.x) - a * (this.y - t.y), this.y = c, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: B
        }, B.convert = function(n) {
          if (n instanceof B) return n;
          if (Array.isArray(n)) return new B(+n[0], +n[1]);
          if (n.x !== void 0 && n.y !== void 0) return new B(+n.x, +n.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var se = (function() {
            if (K) return W;

            function n(t, r, a, c) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = a, this.p2y = c
            }
            return K = 1, W = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, c = 0; c < 8; c++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < r) return a;
                  var f = this.sampleCurveDerivativeX(a);
                  if (Math.abs(f) < 1e-6) break;
                  a -= p / f
                }
                var v = 0,
                  x = 1;
                for (a = t, c = 0; c < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < r)); c++) t > p ? v = a : x = a, a = .5 * (x - v) + v;
                return a
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, W
          })(),
          X = N(se);
        let me, ge;

        function Ee() {
          return me == null && (me = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), me
        }

        function ze() {
          if (ge == null && (ge = !1, Ee())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let a = 0; a < 25; a++) {
                const c = 4 * a;
                t.fillStyle = `rgb(${c},${c+1},${c+2})`, t.fillRect(a % 5, Math.floor(a / 5), 1, 1)
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let a = 0; a < 100; a++)
                if (a % 4 != 3 && r[a] !== a) {
                  ge = !0;
                  break
                }
            }
          }
          return ge || !1
        }
        var Re = 1e-6,
          Ie = typeof Float32Array < "u" ? Float32Array : Array;

        function Oe() {
          var n = new Ie(9);
          return Ie != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n
        }

        function st(n) {
          return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }

        function nt() {
          var n = new Ie(3);
          return Ie != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n
        }

        function qe(n) {
          return Math.hypot(n[0], n[1], n[2])
        }

        function Ue(n, t, r) {
          var a = new Ie(3);
          return a[0] = n, a[1] = t, a[2] = r, a
        }

        function Je(n, t, r) {
          return n[0] = t[0] + r[0], n[1] = t[1] + r[1], n[2] = t[2] + r[2], n
        }

        function Fe(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n
        }

        function it(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = r[0],
            v = r[1],
            x = r[2];
          return n[0] = c * x - p * v, n[1] = p * f - a * x, n[2] = a * v - c * f, n
        }
        Math.hypot || (Math.hypot = function() {
          for (var n = 0, t = arguments.length; t--;) n += arguments[t] * arguments[t];
          return Math.sqrt(n)
        });
        var tt, $e = qe;

        function Ae(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = t[3];
          return n[0] = r[0] * a + r[4] * c + r[8] * p + r[12] * f, n[1] = r[1] * a + r[5] * c + r[9] * p + r[13] * f, n[2] = r[2] * a + r[6] * c + r[10] * p + r[14] * f, n[3] = r[3] * a + r[7] * c + r[11] * p + r[15] * f, n
        }

        function gt() {
          var n = new Ie(4);
          return Ie != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n
        }

        function Q(n, t, r, a) {
          var c = .5 * Math.PI / 180;
          t *= c, r *= c, a *= c;
          var p = Math.sin(t),
            f = Math.cos(t),
            v = Math.sin(r),
            x = Math.cos(r),
            C = Math.sin(a),
            I = Math.cos(a);
          return n[0] = p * x * I - f * v * C, n[1] = f * v * I + p * x * C, n[2] = f * x * C - p * v * I, n[3] = f * x * I + p * v * C, n
        }

        function re() {
          var n = new Ie(2);
          return Ie != Float32Array && (n[0] = 0, n[1] = 0), n
        }

        function _e(n, t) {
          var r = new Ie(2);
          return r[0] = n, r[1] = t, r
        }
        nt(), tt = new Ie(4), Ie != Float32Array && (tt[0] = 0, tt[1] = 0, tt[2] = 0, tt[3] = 0), nt(), Ue(1, 0, 0), Ue(0, 1, 0), gt(), gt(), Oe(), re();
        const ae = 8192;

        function ke(n, t, r) {
          return t * (ae / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)))
        }

        function Le(n, t) {
          return (n % t + t) % t
        }

        function lt(n, t, r) {
          return n * (1 - r) + t * r
        }

        function We(n) {
          if (n <= 0) return 0;
          if (n >= 1) return 1;
          const t = n * n,
            r = t * n;
          return 4 * (n < .5 ? r : 3 * (n - t) + r - .75)
        }

        function _t(n, t, r, a) {
          const c = new X(n, t, r, a);
          return p => c.solve(p)
        }
        const zt = _t(.25, .1, .25, 1);

        function Dt(n, t, r) {
          return Math.min(r, Math.max(t, n))
        }

        function ot(n, t, r) {
          const a = r - t,
            c = ((n - t) % a + a) % a + t;
          return c === t ? r : c
        }

        function dt(n, ...t) {
          for (const r of t)
            for (const a in r) n[a] = r[a];
          return n
        }
        let vt = 1;

        function ft(n, t, r) {
          const a = {};
          for (const c in n) a[c] = t.call(this, n[c], c, n);
          return a
        }

        function Tt(n, t, r) {
          const a = {};
          for (const c in n) t.call(this, n[c], c, n) && (a[c] = n[c]);
          return a
        }

        function xt(n) {
          return Array.isArray(n) ? n.map(xt) : typeof n == "object" && n ? ft(n, xt) : n
        }
        const pt = {};

        function At(n) {
          pt[n] || (typeof console < "u" && console.warn(n), pt[n] = !0)
        }

        function Wt(n, t, r) {
          return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x)
        }

        function Xt(n) {
          return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope
        }
        let rr = null;

        function er(n) {
          return typeof ImageBitmap < "u" && n instanceof ImageBitmap
        }
        const It = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function ur(n, t, r, a, c) {
          return o(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const p = new VideoFrame(n, {
              timestamp: 0
            });
            try {
              const f = p == null ? void 0 : p.format;
              if (!f || !f.startsWith("BGR") && !f.startsWith("RGB")) throw new Error(`Unrecognized format ${f}`);
              const v = f.startsWith("BGR"),
                x = new Uint8ClampedArray(a * c * 4);
              if (yield p.copyTo(x, (function(C, I, L, F, V) {
                  const q = 4 * Math.max(-I, 0),
                    G = (Math.max(0, L) - L) * F * 4 + q,
                    J = 4 * F,
                    oe = Math.max(0, I),
                    De = Math.max(0, L);
                  return {
                    rect: {
                      x: oe,
                      y: De,
                      width: Math.min(C.width, I + F) - oe,
                      height: Math.min(C.height, L + V) - De
                    },
                    layout: [{
                      offset: G,
                      stride: J
                    }]
                  }
                })(n, t, r, a, c)), v)
                for (let C = 0; C < x.length; C += 4) {
                  const I = x[C];
                  x[C] = x[C + 2], x[C + 2] = I
                }
              return x
            } finally {
              p.close()
            }
          }))
        }
        let yr, Mr;

        function Gr(n, t, r, a) {
          return n.addEventListener(t, r, a), {
            unsubscribe: () => {
              n.removeEventListener(t, r, a)
            }
          }
        }

        function xr(n) {
          return n * Math.PI / 180
        }

        function Sr(n) {
          return n / Math.PI * 180
        }
        const wr = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          gr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          Ar = "AbortError";

        function ue() {
          return new Error(Ar)
        }
        const j = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function U(n) {
          return j.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))]
        }
        const Y = "global-dispatcher";
        class ie extends Error {
          constructor(t, r, a, c) {
            super(`AJAXError: ${r} (${t}): ${a}`), this.status = t, this.statusText = r, this.url = a, this.body = c
          }
        }
        const he = () => Xt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          Te = function(n, t) {
            if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
              const a = U(n.url);
              if (a) return a(n, t);
              if (Xt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                targetMapId: Y
              }, t)
            }
            if (!(/^file:/.test(r = n.url) || /^file:/.test(he()) && !/^\w+:/.test(r))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(a, c) {
                return o(this, void 0, void 0, (function*() {
                  const p = new Request(a.url, {
                    method: a.method || "GET",
                    body: a.body,
                    credentials: a.credentials,
                    headers: a.headers,
                    cache: a.cache,
                    referrer: he(),
                    signal: c.signal
                  });
                  let f, v;
                  a.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                  try {
                    f = yield fetch(p)
                  } catch (C) {
                    throw new ie(0, C.message, a.url, new Blob)
                  }
                  if (!f.ok) {
                    const C = yield f.blob();
                    throw new ie(f.status, f.statusText, a.url, C)
                  }
                  v = a.type === "arrayBuffer" || a.type === "image" ? f.arrayBuffer() : a.type === "json" ? f.json() : f.text();
                  const x = yield v;
                  if (c.signal.aborted) throw ue();
                  return {
                    data: x,
                    cacheControl: f.headers.get("Cache-Control"),
                    expires: f.headers.get("Expires")
                  }
                }))
              })(n, t);
              if (Xt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                mustQueue: !0,
                targetMapId: Y
              }, t)
            }
            var r;
            return (function(a, c) {
              return new Promise(((p, f) => {
                var v;
                const x = new XMLHttpRequest;
                x.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (x.responseType = "arraybuffer");
                for (const C in a.headers) x.setRequestHeader(C, a.headers[C]);
                a.type === "json" && (x.responseType = "text", !((v = a.headers) === null || v === void 0) && v.Accept || x.setRequestHeader("Accept", "application/json")), x.withCredentials = a.credentials === "include", x.onerror = () => {
                  f(new Error(x.statusText))
                }, x.onload = () => {
                  if (!c.signal.aborted)
                    if ((x.status >= 200 && x.status < 300 || x.status === 0) && x.response !== null) {
                      let C = x.response;
                      if (a.type === "json") try {
                        C = JSON.parse(x.response)
                      } catch (I) {
                        return void f(I)
                      }
                      p({
                        data: C,
                        cacheControl: x.getResponseHeader("Cache-Control"),
                        expires: x.getResponseHeader("Expires")
                      })
                    } else {
                      const C = new Blob([x.response], {
                        type: x.getResponseHeader("Content-Type")
                      });
                      f(new ie(x.status, x.statusText, a.url, C))
                    }
                }, c.signal.addEventListener("abort", (() => {
                  x.abort(), f(ue())
                })), x.send(a.body)
              }))
            })(n, t)
          };

        function Me(n) {
          if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0) return !0;
          const t = new URL(n),
            r = window.location;
          return t.protocol === r.protocol && t.host === r.host
        }

        function we(n, t, r) {
          r[n] && r[n].indexOf(t) !== -1 || (r[n] = r[n] || [], r[n].push(t))
        }

        function Ne(n, t, r) {
          if (r && r[n]) {
            const a = r[n].indexOf(t);
            a !== -1 && r[n].splice(a, 1)
          }
        }
        class ct {
          constructor(t, r = {}) {
            dt(this, r), this.type = t
          }
        }
        class Qe extends ct {
          constructor(t, r = {}) {
            super("error", dt({
              error: t
            }, r))
          }
        }
        class kt {
          on(t, r) {
            return this._listeners = this._listeners || {}, we(t, r, this._listeners), {
              unsubscribe: () => {
                this.off(t, r)
              }
            }
          }
          off(t, r) {
            return Ne(t, r, this._listeners), Ne(t, r, this._oneTimeListeners), this
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, we(t, r, this._oneTimeListeners), this) : new Promise((a => this.once(t, a)))
          }
          fire(t, r) {
            typeof t == "string" && (t = new ct(t, r || {}));
            const a = t.type;
            if (this.listens(a)) {
              t.target = this;
              const c = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
              for (const v of c) v.call(this, t);
              const p = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
              for (const v of p) Ne(a, v, this._oneTimeListeners), v.call(this, t);
              const f = this._eventedParent;
              f && (dt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), f.fire(t))
            } else t instanceof Qe && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this
          }
        }
        var xe = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Nt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function Jt(n, t) {
          const r = {};
          for (const a in n) a !== "ref" && (r[a] = n[a]);
          return Nt.forEach((a => {
            a in t && (r[a] = t[a])
          })), r
        }

        function jt(n, t) {
          if (Array.isArray(n)) {
            if (!Array.isArray(t) || n.length !== t.length) return !1;
            for (let r = 0; r < n.length; r++)
              if (!jt(n[r], t[r])) return !1;
            return !0
          }
          if (typeof n == "object" && n !== null && t !== null) {
            if (typeof t != "object" || Object.keys(n).length !== Object.keys(t).length) return !1;
            for (const r in n)
              if (!jt(n[r], t[r])) return !1;
            return !0
          }
          return n === t
        }

        function hr(n, t) {
          n.push(t)
        }

        function $r(n, t, r) {
          hr(r, {
            command: "addSource",
            args: [n, t[n]]
          })
        }

        function en(n, t, r) {
          hr(t, {
            command: "removeSource",
            args: [n]
          }), r[n] = !0
        }

        function tr(n, t, r, a) {
          en(n, r, a), $r(n, t, r)
        }

        function Ht(n, t, r) {
          let a;
          for (a in n[r])
            if (Object.prototype.hasOwnProperty.call(n[r], a) && a !== "data" && !jt(n[r][a], t[r][a])) return !1;
          for (a in t[r])
            if (Object.prototype.hasOwnProperty.call(t[r], a) && a !== "data" && !jt(n[r][a], t[r][a])) return !1;
          return !0
        }

        function Yt(n, t, r, a, c, p) {
          n = n || {}, t = t || {};
          for (const f in n) Object.prototype.hasOwnProperty.call(n, f) && (jt(n[f], t[f]) || r.push({
            command: p,
            args: [a, f, t[f], c]
          }));
          for (const f in t) Object.prototype.hasOwnProperty.call(t, f) && !Object.prototype.hasOwnProperty.call(n, f) && (jt(n[f], t[f]) || r.push({
            command: p,
            args: [a, f, t[f], c]
          }))
        }

        function ar(n) {
          return n.id
        }

        function qr(n, t) {
          return n[t.id] = t, n
        }
        class yt {
          constructor(t, r, a, c) {
            this.message = (t ? `${t}: ` : "") + a, c && (this.identifier = c), r != null && r.__line__ && (this.line = r.__line__)
          }
        }

        function sn(n, ...t) {
          for (const r of t)
            for (const a in r) n[a] = r[a];
          return n
        }
        class Yr extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t
          }
        }
        class kn {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [a, c] of r) this.bindings[a] = c
          }
          concat(t) {
            return new kn(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const bt = {
            kind: "null"
          },
          Xe = {
            kind: "number"
          },
          Lt = {
            kind: "string"
          },
          Vt = {
            kind: "boolean"
          },
          Cr = {
            kind: "color"
          },
          Zr = {
            kind: "projectionDefinition"
          },
          tn = {
            kind: "object"
          },
          br = {
            kind: "value"
          },
          pn = {
            kind: "collator"
          },
          Cn = {
            kind: "formatted"
          },
          Nn = {
            kind: "padding"
          },
          vn = {
            kind: "colorArray"
          },
          Bn = {
            kind: "numberArray"
          },
          lr = {
            kind: "resolvedImage"
          },
          bn = {
            kind: "variableAnchorOffsetCollection"
          };

        function rn(n, t) {
          return {
            kind: "array",
            itemType: n,
            N: t
          }
        }

        function Qr(n) {
          if (n.kind === "array") {
            const t = Qr(n.itemType);
            return typeof n.N == "number" ? `array<${t}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return n.kind
        }
        const _a = [bt, Xe, Lt, Vt, Cr, Zr, Cn, tn, rn(br), Nn, Bn, vn, lr, bn];

        function hi(n, t) {
          if (t.kind === "error") return null;
          if (n.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !hi(n.itemType, t.itemType)) && (typeof n.N != "number" || n.N === t.N)) return null
          } else {
            if (n.kind === t.kind) return null;
            if (n.kind === "value") {
              for (const r of _a)
                if (!hi(r, t)) return null
            }
          }
          return `Expected ${Qr(n)} but found ${Qr(t)} instead.`
        }

        function Ki(n, t) {
          return t.some((r => r.kind === n.kind))
        }

        function Zn(n, t) {
          return t.some((r => r === "null" ? n === null : r === "array" ? Array.isArray(n) : r === "object" ? n && !Array.isArray(n) && typeof n == "object" : r === typeof n))
        }

        function ai(n, t) {
          return n.kind === "array" && t.kind === "array" ? n.itemType.kind === t.itemType.kind && typeof n.N == "number" : n.kind === t.kind
        }
        const qi = .96422,
          Zi = .82521,
          Bi = 4 / 29,
          Fi = 6 / 29,
          Ji = 3 * Fi * Fi,
          wt = Fi * Fi * Fi,
          Gt = Math.PI / 180,
          Dr = 180 / Math.PI;

        function gn(n) {
          return (n %= 360) < 0 && (n += 360), n
        }

        function Fn([n, t, r, a]) {
          let c, p;
          const f = Pn((.2225045 * (n = Wn(n)) + .7168786 * (t = Wn(t)) + .0606169 * (r = Wn(r))) / 1);
          n === t && t === r ? c = p = f : (c = Pn((.4360747 * n + .3850649 * t + .1430804 * r) / qi), p = Pn((.0139322 * n + .0971045 * t + .7141733 * r) / Zi));
          const v = 116 * f - 16;
          return [v < 0 ? 0 : v, 500 * (c - f), 200 * (f - p), a]
        }

        function Wn(n) {
          return n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
        }

        function Pn(n) {
          return n > wt ? Math.pow(n, 1 / 3) : n / Ji + Bi
        }

        function Er([n, t, r, a]) {
          let c = (n + 16) / 116,
            p = isNaN(t) ? c : c + t / 500,
            f = isNaN(r) ? c : c - r / 200;
          return c = 1 * nr(c), p = qi * nr(p), f = Zi * nr(f), [Qi(3.1338561 * p - 1.6168667 * c - .4906146 * f), Qi(-.9787684 * p + 1.9161415 * c + .033454 * f), Qi(.0719453 * p - .2289914 * c + 1.4052427 * f), a]
        }

        function Qi(n) {
          return (n = n <= .00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055) < 0 ? 0 : n > 1 ? 1 : n
        }

        function nr(n) {
          return n > Fi ? n * n * n : Ji * (n - Bi)
        }
        const Ot = Object.hasOwn || function(n, t) {
          return Object.prototype.hasOwnProperty.call(n, t)
        };

        function Wr(n, t) {
          return Ot(n, t) ? n[t] : void 0
        }

        function on(n) {
          return parseInt(n.padEnd(2, n), 16) / 255
        }

        function dn(n, t) {
          return cr(t ? n / 100 : n, 0, 1)
        }

        function cr(n, t, r) {
          return Math.min(Math.max(t, n), r)
        }

        function Tn(n) {
          return !n.some(Number.isNaN)
        }
        const Un = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function En(n, t, r) {
          return n + r * (t - n)
        }

        function fn(n, t, r) {
          return n.map(((a, c) => En(a, t[c], r)))
        }
        class sr {
          constructor(t, r, a, c = 1, p = !0) {
            this.r = t, this.g = r, this.b = a, this.a = c, p || (this.r *= c, this.g *= c, this.b *= c, c || this.overwriteGetter("rgb", [t, r, a, c]))
          }
          static parse(t) {
            if (t instanceof sr) return t;
            if (typeof t != "string") return;
            const r = (function(a) {
              if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const c = Wr(Un, a);
              if (c) {
                const [f, v, x] = c;
                return [f / 255, v / 255, x / 255, 1]
              }
              if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
                const f = a.length < 6 ? 1 : 2;
                let v = 1;
                return [on(a.slice(v, v += f)), on(a.slice(v, v += f)), on(a.slice(v, v += f)), on(a.slice(v, v + f) || "ff")]
              }
              if (a.startsWith("rgb")) {
                const f = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (f) {
                  const [v, x, C, I, L, F, V, q, G, J, oe, De] = f, ve = [I || " ", V || " ", J].join("");
                  if (ve === "  " || ve === "  /" || ve === ",," || ve === ",,,") {
                    const Se = [C, F, G].join(""),
                      He = Se === "%%%" ? 100 : Se === "" ? 255 : 0;
                    if (He) {
                      const at = [cr(+x / He, 0, 1), cr(+L / He, 0, 1), cr(+q / He, 0, 1), oe ? dn(+oe, De) : 1];
                      if (Tn(at)) return at
                    }
                  }
                  return
                }
              }
              const p = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (p) {
                const [f, v, x, C, I, L, F, V, q] = p, G = [x || " ", I || " ", F].join("");
                if (G === "  " || G === "  /" || G === ",," || G === ",,,") {
                  const J = [+v, cr(+C, 0, 100), cr(+L, 0, 100), V ? dn(+V, q) : 1];
                  if (Tn(J)) return (function([oe, De, ve, Se]) {
                    function He(at) {
                      const Pt = (at + oe / 30) % 12,
                        $t = De * Math.min(ve, 1 - ve);
                      return ve - $t * Math.max(-1, Math.min(Pt - 3, 9 - Pt, 1))
                    }
                    return oe = gn(oe), De /= 100, ve /= 100, [He(0), He(8), He(4), Se]
                  })(J)
                }
              }
            })(t);
            return r ? new sr(...r, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: r,
              b: a,
              a: c
            } = this, p = c || 1 / 0;
            return this.overwriteGetter("rgb", [t / p, r / p, a / p, c])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, a, c, p] = Fn(t), f = Math.sqrt(a * a + c * c);
              return [Math.round(1e4 * f) ? gn(Math.atan2(c, a) * Dr) : NaN, f, r, p]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", Fn(this.rgb))
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, {
              value: r
            }), r
          }
          toString() {
            const [t, r, a, c] = this.rgb;
            return `rgba(${[t,r,a].map((p=>Math.round(255*p))).join(",")},${c})`
          }
          static interpolate(t, r, a, c = "rgb") {
            switch (c) {
              case "rgb": {
                const [p, f, v, x] = fn(t.rgb, r.rgb, a);
                return new sr(p, f, v, x, !1)
              }
              case "hcl": {
                const [p, f, v, x] = t.hcl, [C, I, L, F] = r.hcl;
                let V, q;
                if (isNaN(p) || isNaN(C)) isNaN(p) ? isNaN(C) ? V = NaN : (V = C, v !== 1 && v !== 0 || (q = I)) : (V = p, L !== 1 && L !== 0 || (q = f));
                else {
                  let ve = C - p;
                  C > p && ve > 180 ? ve -= 360 : C < p && p - C > 180 && (ve += 360), V = p + a * ve
                }
                const [G, J, oe, De] = (function([ve, Se, He, at]) {
                  return ve = isNaN(ve) ? 0 : ve * Gt, Er([He, Math.cos(ve) * Se, Math.sin(ve) * Se, at])
                })([V, q ?? En(f, I, a), En(v, L, a), En(x, F, a)]);
                return new sr(G, J, oe, De, !1)
              }
              case "lab": {
                const [p, f, v, x] = Er(fn(t.lab, r.lab, a));
                return new sr(p, f, v, x, !1)
              }
            }
          }
        }
        sr.black = new sr(0, 0, 0, 1), sr.white = new sr(1, 1, 1, 1), sr.transparent = new sr(0, 0, 0, 0), sr.red = new sr(1, 0, 0, 1);
        class nn {
          constructor(t, r, a) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, r) {
            return this.collator.compare(t, r)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Xn = ["bottom", "center", "top"];
        class di {
          constructor(t, r, a, c, p, f) {
            this.text = t, this.image = r, this.scale = a, this.fontStack = c, this.textColor = p, this.verticalAlign = f
          }
        }
        class yn {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new yn([new di(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof yn ? t : yn.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class mn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof mn) return t;
            if (typeof t == "number") return new mn([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t)
                if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new mn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            return new mn(fn(t.values, r.values, a))
          }
        }
        class On {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof On) return t;
            if (typeof t == "number") return new On([t]);
            if (Array.isArray(t)) {
              for (const r of t)
                if (typeof r != "number") return;
              return new On(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            return new On(fn(t.values, r.values, a))
          }
        }
        class jn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof jn) return t;
            if (typeof t == "string") {
              const a = sr.parse(t);
              return a ? new jn([a]) : void 0
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const a of t) {
              if (typeof a != "string") return;
              const c = sr.parse(a);
              if (!c) return;
              r.push(c)
            }
            return new jn(r)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a, c = "rgb") {
            const p = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let f = 0; f < t.values.length; f++) p.push(sr.interpolate(t.values[f], r.values[f], a, c));
            return new jn(p)
          }
        }
        class Sn extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const oa = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Vn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Vn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const a = t[r],
                  c = t[r + 1];
                if (typeof a != "string" || !oa.has(a) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number") return
              }
              return new Vn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            const c = t.values,
              p = r.values;
            if (c.length !== p.length) throw new Sn(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const f = [];
            for (let v = 0; v < c.length; v += 2) {
              if (c[v] !== p[v]) throw new Sn(`Cannot interpolate values containing mismatched anchors. from[${v}]: ${c[v]}, to[${v}]: ${p[v]}`);
              f.push(c[v]);
              const [x, C] = c[v + 1], [I, L] = p[v + 1];
              f.push([En(x, I, a), En(C, L, a)])
            }
            return new Vn(f)
          }
        }
        class ki {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new ki({
              name: t,
              available: !1
            }) : null
          }
        }
        class pi {
          constructor(t, r, a) {
            this.from = t, this.to = r, this.transition = a
          }
          static interpolate(t, r, a) {
            return new pi(t, r, a)
          }
          static parse(t) {
            return t instanceof pi ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new pi(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new pi(t.from, t.to, t.transition) : typeof t == "string" ? new pi(t, t, 1) : void 0
          }
        }

        function In(n, t, r, a) {
          return typeof n == "number" && n >= 0 && n <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[n,t,r,a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a=="number"?[n,t,r,a]:[n,t,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Ca(n) {
          if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof pi || n instanceof sr || n instanceof nn || n instanceof yn || n instanceof mn || n instanceof On || n instanceof jn || n instanceof Vn || n instanceof ki) return !0;
          if (Array.isArray(n)) {
            for (const t of n)
              if (!Ca(t)) return !1;
            return !0
          }
          if (typeof n == "object") {
            for (const t in n)
              if (!Ca(n[t])) return !1;
            return !0
          }
          return !1
        }

        function Rr(n) {
          if (n === null) return bt;
          if (typeof n == "string") return Lt;
          if (typeof n == "boolean") return Vt;
          if (typeof n == "number") return Xe;
          if (n instanceof sr) return Cr;
          if (n instanceof pi) return Zr;
          if (n instanceof nn) return pn;
          if (n instanceof yn) return Cn;
          if (n instanceof mn) return Nn;
          if (n instanceof On) return Bn;
          if (n instanceof jn) return vn;
          if (n instanceof Vn) return bn;
          if (n instanceof ki) return lr;
          if (Array.isArray(n)) {
            const t = n.length;
            let r;
            for (const a of n) {
              const c = Rr(a);
              if (r) {
                if (r === c) continue;
                r = br;
                break
              }
              r = c
            }
            return rn(r || br, t)
          }
          return tn
        }

        function Hr(n) {
          const t = typeof n;
          return n === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(n) : n instanceof sr || n instanceof pi || n instanceof yn || n instanceof mn || n instanceof On || n instanceof jn || n instanceof Vn || n instanceof ki ? n.toString() : JSON.stringify(n)
        }
        class la {
          constructor(t, r) {
            this.type = t, this.value = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Ca(t[1])) return r.error("invalid value");
            const a = t[1];
            let c = Rr(a);
            const p = r.expectedType;
            return c.kind !== "array" || c.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (c = p), new la(c, a)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const cn = {
          string: Lt,
          number: Xe,
          boolean: Vt,
          object: tn
        };
        class Oi {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let a, c = 1;
            const p = t[0];
            if (p === "array") {
              let v, x;
              if (t.length > 2) {
                const C = t[1];
                if (typeof C != "string" || !(C in cn) || C === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                v = cn[C], c++
              } else v = br;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                x = t[2], c++
              }
              a = rn(v, x)
            } else {
              if (!cn[p]) throw new Error(`Types doesn't contain name = ${p}`);
              a = cn[p]
            }
            const f = [];
            for (; c < t.length; c++) {
              const v = r.parse(t[c], c, br);
              if (!v) return null;
              f.push(v)
            }
            return new Oi(a, f)
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const a = this.args[r].evaluate(t);
              if (!hi(this.type, Rr(a))) return a;
              if (r === this.args.length - 1) throw new Sn(`Expected value to be of type ${Qr(this.type)}, but found ${Qr(Rr(a))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const Ui = {
          "to-boolean": Vt,
          "to-color": Cr,
          "to-number": Xe,
          "to-string": Lt
        };
        class ga {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const a = t[0];
            if (!Ui[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`);
            if ((a === "to-boolean" || a === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const c = Ui[a],
              p = [];
            for (let f = 1; f < t.length; f++) {
              const v = r.parse(t[f], f, br);
              if (!v) return null;
              p.push(v)
            }
            return new ga(c, p)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, a;
                for (const c of this.args) {
                  if (r = c.evaluate(t), a = null, r instanceof sr) return r;
                  if (typeof r == "string") {
                    const p = t.parseColor(r);
                    if (p) return p
                  } else if (Array.isArray(r) && (a = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : In(r[0], r[1], r[2], r[3]), !a)) return new sr(r[0] / 255, r[1] / 255, r[2] / 255, r[3])
                }
                throw new Sn(a || `Could not parse color from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "padding": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = mn.parse(r);
                  if (c) return c
                }
                throw new Sn(`Could not parse padding from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "numberArray": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = On.parse(r);
                  if (c) return c
                }
                throw new Sn(`Could not parse numberArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "colorArray": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = jn.parse(r);
                  if (c) return c
                }
                throw new Sn(`Could not parse colorArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = Vn.parse(r);
                  if (c) return c
                }
                throw new Sn(`Could not parse variableAnchorOffsetCollection from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "number": {
                let r = null;
                for (const a of this.args) {
                  if (r = a.evaluate(t), r === null) return 0;
                  const c = Number(r);
                  if (!isNaN(c)) return c
                }
                throw new Sn(`Could not convert ${JSON.stringify(r)} to number.`)
              }
              case "formatted":
                return yn.fromString(Hr(this.args[0].evaluate(t)));
              case "resolvedImage":
                return ki.fromString(Hr(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return Hr(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const Ka = ["Unknown", "Point", "LineString", "Polygon"];
        class Ps {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Ka[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = sr.parse(t), this._parseColorCache.set(t, r)), r
          }
        }
        class ds {
          constructor(t, r, a = [], c, p = new kn, f = []) {
            this.registry = t, this.path = a, this.key = a.map((v => `[${v}]`)).join(""), this.scope = p, this.errors = f, this.expectedType = c, this._isConstant = r
          }
          parse(t, r, a, c, p = {}) {
            return r ? this.concat(r, a, c)._parse(t, p) : this._parse(t, p)
          }
          _parse(t, r) {
            function a(c, p, f) {
              return f === "assert" ? new Oi(p, [c]) : f === "coerce" ? new ga(p, [c]) : c
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = t[0];
              if (typeof c != "string") return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const p = this.registry[c];
              if (p) {
                let f = p.parse(t, this);
                if (!f) return null;
                if (this.expectedType) {
                  const v = this.expectedType,
                    x = f.type;
                  if (v.kind !== "string" && v.kind !== "number" && v.kind !== "boolean" && v.kind !== "object" && v.kind !== "array" || x.kind !== "value") {
                    if (v.kind === "projectionDefinition" && ["string", "array"].includes(x.kind) || ["color", "formatted", "resolvedImage"].includes(v.kind) && ["value", "string"].includes(x.kind) || ["padding", "numberArray"].includes(v.kind) && ["value", "number", "array"].includes(x.kind) || v.kind === "colorArray" && ["value", "string", "array"].includes(x.kind) || v.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(x.kind)) f = a(f, v, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(v, x)) return null
                  } else f = a(f, v, r.typeAnnotation || "assert")
                }
                if (!(f instanceof la) && f.type.kind !== "resolvedImage" && this._isConstant(f)) {
                  const v = new Ps;
                  try {
                    f = new la(f.type, f.evaluate(v))
                  } catch (x) {
                    return this.error(x.message), null
                  }
                }
                return f
              }
              return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, r, a) {
            const c = typeof t == "number" ? this.path.concat(t) : this.path,
              p = a ? this.scope.concat(a) : this.scope;
            return new ds(this.registry, this._isConstant, c, r || null, p, this.errors)
          }
          error(t, ...r) {
            const a = `${this.key}${r.map((c=>`[${c}]`)).join("")}`;
            this.errors.push(new Yr(a, t))
          }
          checkSubtype(t, r) {
            const a = hi(t, r);
            return a && this.error(a), a
          }
        }
        class Po {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result)
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const a = [];
            for (let p = 1; p < t.length - 1; p += 2) {
              const f = t[p];
              if (typeof f != "string") return r.error(`Expected string, but found ${typeof f} instead.`, p);
              if (/[^a-zA-Z0-9_]/.test(f)) return r.error("Variable names must contain only alphanumeric characters or '_'.", p);
              const v = r.parse(t[p + 1], p + 1);
              if (!v) return null;
              a.push([f, v])
            }
            const c = r.parse(t[t.length - 1], t.length - 1, r.expectedType, a);
            return c ? new Po(a, c) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class fl {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const a = t[1];
            return r.scope.has(a) ? new fl(a, r.scope.get(a)) : r.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class ml {
          constructor(t, r, a) {
            this.type = t, this.index = r, this.input = a
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, Xe),
              c = r.parse(t[2], 2, rn(r.expectedType || br));
            return a && c ? new ml(c.type.itemType, a, c) : null
          }
          evaluate(t) {
            const r = this.index.evaluate(t),
              a = this.input.evaluate(t);
            if (r < 0) throw new Sn(`Array index out of bounds: ${r} < 0.`);
            if (r >= a.length) throw new Sn(`Array index out of bounds: ${r} > ${a.length-1}.`);
            if (r !== Math.floor(r)) throw new Sn(`Array index must be an integer, but found ${r} instead.`);
            return a[r]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class _l {
          constructor(t, r) {
            this.type = Vt, this.needle = t, this.haystack = r
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, br),
              c = r.parse(t[2], 2, br);
            return a && c ? Ki(a.type, [Vt, Lt, Xe, bt, br]) ? new _l(a, c) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Qr(a.type)} instead`) : null
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!a) return !1;
            if (!Zn(r, ["boolean", "string", "number", "null"])) throw new Sn(`Expected first argument to be of type boolean, string, number or null, but found ${Qr(Rr(r))} instead.`);
            if (!Zn(a, ["string", "array"])) throw new Sn(`Expected second argument to be of type array or string, but found ${Qr(Rr(a))} instead.`);
            return a.indexOf(r) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class Pa {
          constructor(t, r, a) {
            this.type = Xe, this.needle = t, this.haystack = r, this.fromIndex = a
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, br),
              c = r.parse(t[2], 2, br);
            if (!a || !c) return null;
            if (!Ki(a.type, [Vt, Lt, Xe, bt, br])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Qr(a.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, Xe);
              return p ? new Pa(a, c, p) : null
            }
            return new Pa(a, c)
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!Zn(r, ["boolean", "string", "number", "null"])) throw new Sn(`Expected first argument to be of type boolean, string, number or null, but found ${Qr(Rr(r))} instead.`);
            let c;
            if (this.fromIndex && (c = this.fromIndex.evaluate(t)), Zn(a, ["string"])) {
              const p = a.indexOf(r, c);
              return p === -1 ? -1 : [...a.slice(0, p)].length
            }
            if (Zn(a, ["array"])) return a.indexOf(r, c);
            throw new Sn(`Expected second argument to be of type array or string, but found ${Qr(Rr(a))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class xi {
          constructor(t, r, a, c, p, f) {
            this.inputType = t, this.type = r, this.input = a, this.cases = c, this.outputs = p, this.otherwise = f
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let a, c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const p = {},
              f = [];
            for (let C = 2; C < t.length - 1; C += 2) {
              let I = t[C];
              const L = t[C + 1];
              Array.isArray(I) || (I = [I]);
              const F = r.concat(C);
              if (I.length === 0) return F.error("Expected at least one branch label.");
              for (const q of I) {
                if (typeof q != "number" && typeof q != "string") return F.error("Branch labels must be numbers or strings.");
                if (typeof q == "number" && Math.abs(q) > Number.MAX_SAFE_INTEGER) return F.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof q == "number" && Math.floor(q) !== q) return F.error("Numeric branch labels must be integer values.");
                if (a) {
                  if (F.checkSubtype(a, Rr(q))) return null
                } else a = Rr(q);
                if (p[String(q)] !== void 0) return F.error("Branch labels must be unique.");
                p[String(q)] = f.length
              }
              const V = r.parse(L, C, c);
              if (!V) return null;
              c = c || V.type, f.push(V)
            }
            const v = r.parse(t[1], 1, br);
            if (!v) return null;
            const x = r.parse(t[t.length - 1], t.length - 1, c);
            return x ? v.type.kind !== "value" && r.concat(1).checkSubtype(a, v.type) ? null : new xi(a, c, v, p, f, x) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (Rr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Ys {
          constructor(t, r, a) {
            this.type = t, this.branches = r, this.otherwise = a
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let a;
            r.expectedType && r.expectedType.kind !== "value" && (a = r.expectedType);
            const c = [];
            for (let f = 1; f < t.length - 1; f += 2) {
              const v = r.parse(t[f], f, Vt);
              if (!v) return null;
              const x = r.parse(t[f + 1], f + 1, a);
              if (!x) return null;
              c.push([v, x]), a = a || x.type
            }
            const p = r.parse(t[t.length - 1], t.length - 1, a);
            if (!p) return null;
            if (!a) throw new Error("Can't infer output type");
            return new Ys(a, c, p)
          }
          evaluate(t) {
            for (const [r, a] of this.branches)
              if (r.evaluate(t)) return a.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [r, a] of this.branches) t(r), t(a);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Io {
          constructor(t, r, a, c) {
            this.type = t, this.input = r, this.beginIndex = a, this.endIndex = c
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, br),
              c = r.parse(t[2], 2, Xe);
            if (!a || !c) return null;
            if (!Ki(a.type, [rn(br), Lt, br])) return r.error(`Expected first argument to be of type array or string, but found ${Qr(a.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, Xe);
              return p ? new Io(a.type, a, c, p) : null
            }
            return new Io(a.type, a, c)
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              a = this.beginIndex.evaluate(t);
            let c;
            if (this.endIndex && (c = this.endIndex.evaluate(t)), Zn(r, ["string"])) return [...r].slice(a, c).join("");
            if (Zn(r, ["array"])) return r.slice(a, c);
            throw new Sn(`Expected first argument to be of type array or string, but found ${Qr(Rr(r))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function Is(n, t) {
          const r = n.length - 1;
          let a, c, p = 0,
            f = r,
            v = 0;
          for (; p <= f;)
            if (v = Math.floor((p + f) / 2), a = n[v], c = n[v + 1], a <= t) {
              if (v === r || t < c) return v;
              p = v + 1
            } else {
              if (!(a > t)) throw new Sn("Input is not a number.");
              f = v - 1
            } return 0
        }
        class Qn {
          constructor(t, r, a) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [c, p] of a) this.labels.push(c), this.outputs.push(p)
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const a = r.parse(t[1], 1, Xe);
            if (!a) return null;
            const c = [];
            let p = null;
            r.expectedType && r.expectedType.kind !== "value" && (p = r.expectedType);
            for (let f = 1; f < t.length; f += 2) {
              const v = f === 1 ? -1 / 0 : t[f],
                x = t[f + 1],
                C = f,
                I = f + 1;
              if (typeof v != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
              if (c.length && c[c.length - 1][0] >= v) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', C);
              const L = r.parse(x, I, p);
              if (!L) return null;
              p = p || L.type, c.push([v, L])
            }
            return new Qn(p, a, c)
          }
          evaluate(t) {
            const r = this.labels,
              a = this.outputs;
            if (r.length === 1) return a[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return a[0].evaluate(t);
            const p = r.length;
            return c >= r[p - 1] ? a[p - 1].evaluate(t) : a[Is(r, c)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function Rh(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var Mo, kc, vp = (function() {
            if (kc) return Mo;

            function n(t, r, a, c) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = a, this.p2y = c
            }
            return kc = 1, Mo = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, c = 0; c < 8; c++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < r) return a;
                  var f = this.sampleCurveDerivativeX(a);
                  if (Math.abs(f) < 1e-6) break;
                  a -= p / f
                }
                var v = 0,
                  x = 1;
                for (a = t, c = 0; c < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < r)); c++) t > p ? v = a : x = a, a = .5 * (x - v) + v;
                return a
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, Mo
          })(),
          Ks = Rh(vp);
        class Ei {
          constructor(t, r, a, c, p) {
            this.type = t, this.operator = r, this.interpolation = a, this.input = c, this.labels = [], this.outputs = [];
            for (const [f, v] of p) this.labels.push(f), this.outputs.push(v)
          }
          static interpolationFactor(t, r, a, c) {
            let p = 0;
            if (t.name === "exponential") p = Ao(r, t.base, a, c);
            else if (t.name === "linear") p = Ao(r, 1, a, c);
            else if (t.name === "cubic-bezier") {
              const f = t.controlPoints;
              p = new Ks(f[0], f[1], f[2], f[3]).solve(Ao(r, 1, a, c))
            }
            return p
          }
          static parse(t, r) {
            let [a, c, p, ...f] = t;
            if (!Array.isArray(c) || c.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = {
              name: "linear"
            };
            else if (c[0] === "exponential") {
              const C = c[1];
              if (typeof C != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = {
                name: "exponential",
                base: C
              }
            } else {
              if (c[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const C = c.slice(1);
                if (C.length !== 4 || C.some((I => typeof I != "number" || I < 0 || I > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = {
                  name: "cubic-bezier",
                  controlPoints: C
                }
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (p = r.parse(p, 2, Xe), !p) return null;
            const v = [];
            let x = null;
            a !== "interpolate-hcl" && a !== "interpolate-lab" || r.expectedType == vn ? r.expectedType && r.expectedType.kind !== "value" && (x = r.expectedType) : x = Cr;
            for (let C = 0; C < f.length; C += 2) {
              const I = f[C],
                L = f[C + 1],
                F = C + 3,
                V = C + 4;
              if (typeof I != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', F);
              if (v.length && v[v.length - 1][0] >= I) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', F);
              const q = r.parse(L, V, x);
              if (!q) return null;
              x = x || q.type, v.push([I, q])
            }
            return ai(x, Xe) || ai(x, Zr) || ai(x, Cr) || ai(x, Nn) || ai(x, Bn) || ai(x, vn) || ai(x, bn) || ai(x, rn(Xe)) ? new Ei(x, a, c, p, v) : r.error(`Type ${Qr(x)} is not interpolatable.`)
          }
          evaluate(t) {
            const r = this.labels,
              a = this.outputs;
            if (r.length === 1) return a[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return a[0].evaluate(t);
            const p = r.length;
            if (c >= r[p - 1]) return a[p - 1].evaluate(t);
            const f = Is(r, c),
              v = Ei.interpolationFactor(this.interpolation, c, r[f], r[f + 1]),
              x = a[f].evaluate(t),
              C = a[f + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return En(x, C, v);
                  case "color":
                    return sr.interpolate(x, C, v);
                  case "padding":
                    return mn.interpolate(x, C, v);
                  case "colorArray":
                    return jn.interpolate(x, C, v);
                  case "numberArray":
                    return On.interpolate(x, C, v);
                  case "variableAnchorOffsetCollection":
                    return Vn.interpolate(x, C, v);
                  case "array":
                    return fn(x, C, v);
                  case "projectionDefinition":
                    return pi.interpolate(x, C, v)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return sr.interpolate(x, C, v, "hcl");
                  case "colorArray":
                    return jn.interpolate(x, C, v, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return sr.interpolate(x, C, v, "lab");
                  case "colorArray":
                    return jn.interpolate(x, C, v, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function Ao(n, t, r, a) {
          const c = a - r,
            p = n - r;
          return c === 0 ? 0 : t === 1 ? p / c : (Math.pow(t, p) - 1) / (Math.pow(t, c) - 1)
        }
        const Za = {
          color: sr.interpolate,
          number: En,
          padding: mn.interpolate,
          numberArray: On.interpolate,
          colorArray: jn.interpolate,
          variableAnchorOffsetCollection: Vn.interpolate,
          array: fn
        };
        class ko {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let a = null;
            const c = r.expectedType;
            c && c.kind !== "value" && (a = c);
            const p = [];
            for (const v of t.slice(1)) {
              const x = r.parse(v, 1 + p.length, a, void 0, {
                typeAnnotation: "omit"
              });
              if (!x) return null;
              a = a || x.type, p.push(x)
            }
            if (!a) throw new Error("No output type");
            const f = c && p.some((v => hi(c, v.type)));
            return new ko(f ? br : a, p)
          }
          evaluate(t) {
            let r, a = null,
              c = 0;
            for (const p of this.args)
              if (c++, a = p.evaluate(t), a && a instanceof ki && !a.available && (r || (r = a.name), a = null, c === this.args.length && (a = r)), a !== null) break;
            return a
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function Eo(n, t) {
          return n === "==" || n === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function zo(n, t, r, a) {
          return a.compare(t, r) === 0
        }

        function Ni(n, t, r) {
          const a = n !== "==" && n !== "!=";
          return class Kv {
            constructor(p, f, v) {
              this.type = Vt, this.lhs = p, this.rhs = f, this.collator = v, this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value"
            }
            static parse(p, f) {
              if (p.length !== 3 && p.length !== 4) return f.error("Expected two or three arguments.");
              const v = p[0];
              let x = f.parse(p[1], 1, br);
              if (!x) return null;
              if (!Eo(v, x.type)) return f.concat(1).error(`"${v}" comparisons are not supported for type '${Qr(x.type)}'.`);
              let C = f.parse(p[2], 2, br);
              if (!C) return null;
              if (!Eo(v, C.type)) return f.concat(2).error(`"${v}" comparisons are not supported for type '${Qr(C.type)}'.`);
              if (x.type.kind !== C.type.kind && x.type.kind !== "value" && C.type.kind !== "value") return f.error(`Cannot compare types '${Qr(x.type)}' and '${Qr(C.type)}'.`);
              a && (x.type.kind === "value" && C.type.kind !== "value" ? x = new Oi(C.type, [x]) : x.type.kind !== "value" && C.type.kind === "value" && (C = new Oi(x.type, [C])));
              let I = null;
              if (p.length === 4) {
                if (x.type.kind !== "string" && C.type.kind !== "string" && x.type.kind !== "value" && C.type.kind !== "value") return f.error("Cannot use collator to compare non-string types.");
                if (I = f.parse(p[3], 3, pn), !I) return null
              }
              return new Kv(x, C, I)
            }
            evaluate(p) {
              const f = this.lhs.evaluate(p),
                v = this.rhs.evaluate(p);
              if (a && this.hasUntypedArgument) {
                const x = Rr(f),
                  C = Rr(v);
                if (x.kind !== C.kind || x.kind !== "string" && x.kind !== "number") throw new Sn(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${x.kind}, ${C.kind}) instead.`)
              }
              if (this.collator && !a && this.hasUntypedArgument) {
                const x = Rr(f),
                  C = Rr(v);
                if (x.kind !== "string" || C.kind !== "string") return t(p, f, v)
              }
              return this.collator ? r(p, f, v, this.collator.evaluate(p)) : t(p, f, v)
            }
            eachChild(p) {
              p(this.lhs), p(this.rhs), this.collator && p(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const Bh = Ni("==", (function(n, t, r) {
            return t === r
          }), zo),
          gl = Ni("!=", (function(n, t, r) {
            return t !== r
          }), (function(n, t, r, a) {
            return !zo(0, t, r, a)
          })),
          yp = Ni("<", (function(n, t, r) {
            return t < r
          }), (function(n, t, r, a) {
            return a.compare(t, r) < 0
          })),
          Ec = Ni(">", (function(n, t, r) {
            return t > r
          }), (function(n, t, r, a) {
            return a.compare(t, r) > 0
          })),
          xp = Ni("<=", (function(n, t, r) {
            return t <= r
          }), (function(n, t, r, a) {
            return a.compare(t, r) <= 0
          })),
          bp = Ni(">=", (function(n, t, r) {
            return t >= r
          }), (function(n, t, r, a) {
            return a.compare(t, r) >= 0
          }));
        class vl {
          constructor(t, r, a) {
            this.type = pn, this.locale = a, this.caseSensitive = t, this.diacriticSensitive = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const a = t[1];
            if (typeof a != "object" || Array.isArray(a)) return r.error("Collator options argument must be an object.");
            const c = r.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, Vt);
            if (!c) return null;
            const p = r.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, Vt);
            if (!p) return null;
            let f = null;
            return a.locale && (f = r.parse(a.locale, 1, Lt), !f) ? null : new vl(c, p, f)
          }
          evaluate(t) {
            return new nn(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class zc {
          constructor(t, r, a, c, p) {
            this.type = Lt, this.number = t, this.locale = r, this.currency = a, this.minFractionDigits = c, this.maxFractionDigits = p
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const a = r.parse(t[1], 1, Xe);
            if (!a) return null;
            const c = t[2];
            if (typeof c != "object" || Array.isArray(c)) return r.error("NumberFormat options argument must be an object.");
            let p = null;
            if (c.locale && (p = r.parse(c.locale, 1, Lt), !p)) return null;
            let f = null;
            if (c.currency && (f = r.parse(c.currency, 1, Lt), !f)) return null;
            let v = null;
            if (c["min-fraction-digits"] && (v = r.parse(c["min-fraction-digits"], 1, Xe), !v)) return null;
            let x = null;
            return c["max-fraction-digits"] && (x = r.parse(c["max-fraction-digits"], 1, Xe), !x) ? null : new zc(a, p, f, v, x)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class Ms {
          constructor(t) {
            this.type = Cn, this.sections = t
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const a = t[1];
            if (!Array.isArray(a) && typeof a == "object") return r.error("First argument must be an image or text section.");
            const c = [];
            let p = !1;
            for (let f = 1; f <= t.length - 1; ++f) {
              const v = t[f];
              if (p && typeof v == "object" && !Array.isArray(v)) {
                p = !1;
                let x = null;
                if (v["font-scale"] && (x = r.parse(v["font-scale"], 1, Xe), !x)) return null;
                let C = null;
                if (v["text-font"] && (C = r.parse(v["text-font"], 1, rn(Lt)), !C)) return null;
                let I = null;
                if (v["text-color"] && (I = r.parse(v["text-color"], 1, Cr), !I)) return null;
                let L = null;
                if (v["vertical-align"]) {
                  if (typeof v["vertical-align"] == "string" && !Xn.includes(v["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${v["vertical-align"]}' instead.`);
                  if (L = r.parse(v["vertical-align"], 1, Lt), !L) return null
                }
                const F = c[c.length - 1];
                F.scale = x, F.font = C, F.textColor = I, F.verticalAlign = L
              } else {
                const x = r.parse(t[f], 1, br);
                if (!x) return null;
                const C = x.type.kind;
                if (C !== "string" && C !== "value" && C !== "null" && C !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                p = !0, c.push({
                  content: x,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new Ms(c)
          }
          evaluate(t) {
            return new yn(this.sections.map((r => {
              const a = r.content.evaluate(t);
              return Rr(a) === lr ? new di("", a, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new di(Hr(a), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Lc {
          constructor(t) {
            this.type = lr, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const a = r.parse(t[1], 1, Lt);
            return a ? new Lc(a) : r.error("No image name provided.")
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              a = ki.fromString(r);
            return a && t.availableImages && (a.available = t.availableImages.indexOf(r) > -1), a
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class yl {
          constructor(t) {
            this.type = Xe, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1);
            return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Qr(a.type)} instead.`) : new yl(a) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new Sn(`Expected value to be of type string or array, but found ${Qr(Rr(r))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const Ia = 8192;

        function wp(n, t) {
          const r = (180 + n[0]) / 360,
            a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360,
            c = Math.pow(2, t.z);
          return [Math.round(r * c * Ia), Math.round(a * c * Ia)]
        }

        function xl(n, t) {
          const r = Math.pow(2, t.z);
          return [(c = (n[0] / Ia + t.x) / r, 360 * c - 180), (a = (n[1] / Ia + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
          var a, c
        }

        function Lo(n, t) {
          n[0] = Math.min(n[0], t[0]), n[1] = Math.min(n[1], t[1]), n[2] = Math.max(n[2], t[0]), n[3] = Math.max(n[3], t[1])
        }

        function Do(n, t) {
          return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3])
        }

        function Tp(n, t, r) {
          const a = n[0] - t[0],
            c = n[1] - t[1],
            p = n[0] - r[0],
            f = n[1] - r[1];
          return a * f - p * c == 0 && a * p <= 0 && c * f <= 0
        }

        function bl(n, t, r, a) {
          return (c = [a[0] - r[0], a[1] - r[1]])[0] * (p = [t[0] - n[0], t[1] - n[1]])[1] - c[1] * p[0] != 0 && !(!Oh(n, t, r, a) || !Oh(r, a, n, t));
          var c, p
        }

        function Sp(n, t, r) {
          for (const a of r)
            for (let c = 0; c < a.length - 1; ++c)
              if (bl(n, t, a[c], a[c + 1])) return !0;
          return !1
        }

        function As(n, t, r = !1) {
          let a = !1;
          for (const v of t)
            for (let x = 0; x < v.length - 1; x++) {
              if (Tp(n, v[x], v[x + 1])) return r;
              (p = v[x])[1] > (c = n)[1] != (f = v[x + 1])[1] > c[1] && c[0] < (f[0] - p[0]) * (c[1] - p[1]) / (f[1] - p[1]) + p[0] && (a = !a)
            }
          var c, p, f;
          return a
        }

        function Fh(n, t) {
          for (const r of t)
            if (As(n, r)) return !0;
          return !1
        }

        function Dc(n, t) {
          for (const r of n)
            if (!As(r, t)) return !1;
          for (let r = 0; r < n.length - 1; ++r)
            if (Sp(n[r], n[r + 1], t)) return !1;
          return !0
        }

        function Cp(n, t) {
          for (const r of t)
            if (Dc(n, r)) return !0;
          return !1
        }

        function Oh(n, t, r, a) {
          const c = a[0] - r[0],
            p = a[1] - r[1],
            f = (n[0] - r[0]) * p - c * (n[1] - r[1]),
            v = (t[0] - r[0]) * p - c * (t[1] - r[1]);
          return f > 0 && v < 0 || f < 0 && v > 0
        }

        function Rc(n, t, r) {
          const a = [];
          for (let c = 0; c < n.length; c++) {
            const p = [];
            for (let f = 0; f < n[c].length; f++) {
              const v = wp(n[c][f], r);
              Lo(t, v), p.push(v)
            }
            a.push(p)
          }
          return a
        }

        function Nh(n, t, r) {
          const a = [];
          for (let c = 0; c < n.length; c++) {
            const p = Rc(n[c], t, r);
            a.push(p)
          }
          return a
        }

        function wl(n, t, r, a) {
          if (n[0] < r[0] || n[0] > r[2]) {
            const c = .5 * a;
            let p = n[0] - r[0] > c ? -a : r[0] - n[0] > c ? a : 0;
            p === 0 && (p = n[0] - r[2] > c ? -a : r[2] - n[0] > c ? a : 0), n[0] += p
          }
          Lo(t, n)
        }

        function jh(n, t, r, a) {
          const c = Math.pow(2, a.z) * Ia,
            p = [a.x * Ia, a.y * Ia],
            f = [];
          for (const v of n)
            for (const x of v) {
              const C = [x.x + p[0], x.y + p[1]];
              wl(C, t, r, c), f.push(C)
            }
          return f
        }

        function Vh(n, t, r, a) {
          const c = Math.pow(2, a.z) * Ia,
            p = [a.x * Ia, a.y * Ia],
            f = [];
          for (const x of n) {
            const C = [];
            for (const I of x) {
              const L = [I.x + p[0], I.y + p[1]];
              Lo(t, L), C.push(L)
            }
            f.push(C)
          }
          if (t[2] - t[0] <= c / 2) {
            (v = t)[0] = v[1] = 1 / 0, v[2] = v[3] = -1 / 0;
            for (const x of f)
              for (const C of x) wl(C, t, r, c)
          }
          var v;
          return f
        }
        class ks {
          constructor(t, r) {
            this.type = Vt, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Ca(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") {
                const c = [];
                for (const p of a.features) {
                  const {
                    type: f,
                    coordinates: v
                  } = p.geometry;
                  f === "Polygon" && c.push(v), f === "MultiPolygon" && c.push(...v)
                }
                if (c.length) return new ks(a, {
                  type: "MultiPolygon",
                  coordinates: c
                })
              } else if (a.type === "Feature") {
                const c = a.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new ks(a, a.geometry)
              } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new ks(a, a)
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, a) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = r.canonicalID();
                if (a.type === "Polygon") {
                  const v = Rc(a.coordinates, p, f),
                    x = jh(r.geometry(), c, p, f);
                  if (!Do(c, p)) return !1;
                  for (const C of x)
                    if (!As(C, v)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const v = Nh(a.coordinates, p, f),
                    x = jh(r.geometry(), c, p, f);
                  if (!Do(c, p)) return !1;
                  for (const C of x)
                    if (!Fh(C, v)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, a) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = r.canonicalID();
                if (a.type === "Polygon") {
                  const v = Rc(a.coordinates, p, f),
                    x = Vh(r.geometry(), c, p, f);
                  if (!Do(c, p)) return !1;
                  for (const C of x)
                    if (!Dc(C, v)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const v = Nh(a.coordinates, p, f),
                    x = Vh(r.geometry(), c, p, f);
                  if (!Do(c, p)) return !1;
                  for (const C of x)
                    if (!Cp(C, v)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let Bc = class {
          constructor(n = [], t = (r, a) => r < a ? -1 : r > a ? 1 : 0) {
            if (this.data = n, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r)
          }
          push(n) {
            this.data.push(n), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const n = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), n
          }
          peek() {
            return this.data[0]
          }
          _up(n) {
            const {
              data: t,
              compare: r
            } = this, a = t[n];
            for (; n > 0;) {
              const c = n - 1 >> 1,
                p = t[c];
              if (r(a, p) >= 0) break;
              t[n] = p, n = c
            }
            t[n] = a
          }
          _down(n) {
            const {
              data: t,
              compare: r
            } = this, a = this.length >> 1, c = t[n];
            for (; n < a;) {
              let p = 1 + (n << 1);
              const f = p + 1;
              if (f < this.length && r(t[f], t[p]) < 0 && (p = f), r(t[p], c) >= 0) break;
              t[n] = t[p], n = p
            }
            t[n] = c
          }
        };

        function Fc(n, t, r = 0, a = n.length - 1, c = Pp) {
          for (; a > r;) {
            if (a - r > 600) {
              const x = a - r + 1,
                C = t - r + 1,
                I = Math.log(x),
                L = .5 * Math.exp(2 * I / 3),
                F = .5 * Math.sqrt(I * L * (x - L) / x) * (C - x / 2 < 0 ? -1 : 1);
              Fc(n, t, Math.max(r, Math.floor(t - C * L / x + F)), Math.min(a, Math.floor(t + (x - C) * L / x + F)), c)
            }
            const p = n[t];
            let f = r,
              v = a;
            for (Ro(n, r, t), c(n[a], p) > 0 && Ro(n, r, a); f < v;) {
              for (Ro(n, f, v), f++, v--; c(n[f], p) < 0;) f++;
              for (; c(n[v], p) > 0;) v--
            }
            c(n[r], p) === 0 ? Ro(n, r, v) : (v++, Ro(n, v, a)), v <= t && (r = v + 1), t <= v && (a = v - 1)
          }
        }

        function Ro(n, t, r) {
          const a = n[t];
          n[t] = n[r], n[r] = a
        }

        function Pp(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function Bo(n, t) {
          if (n.length <= 1) return [n];
          const r = [];
          let a, c;
          for (const p of n) {
            const f = Ip(p);
            f !== 0 && (p.area = Math.abs(f), c === void 0 && (c = f < 0), c === f < 0 ? (a && r.push(a), a = [p]) : a.push(p))
          }
          if (a && r.push(a), t > 1)
            for (let p = 0; p < r.length; p++) r[p].length <= t || (Fc(r[p], t, 1, r[p].length - 1, qh), r[p] = r[p].slice(0, t));
          return r
        }

        function qh(n, t) {
          return t.area - n.area
        }

        function Ip(n) {
          let t = 0;
          for (let r, a, c = 0, p = n.length, f = p - 1; c < p; f = c++) r = n[c], a = n[f], t += (a.x - r.x) * (r.y + a.y);
          return t
        }
        const Zh = 1 / 298.257223563,
          Uh = Zh * (2 - Zh),
          Oc = Math.PI / 180;
        class Nc {
          constructor(t) {
            const r = 6378.137 * Oc * 1e3,
              a = Math.cos(t * Oc),
              c = 1 / (1 - Uh * (1 - a * a)),
              p = Math.sqrt(c);
            this.kx = r * p * a, this.ky = r * p * c * (1 - Uh)
          }
          distance(t, r) {
            const a = this.wrap(t[0] - r[0]) * this.kx,
              c = (t[1] - r[1]) * this.ky;
            return Math.sqrt(a * a + c * c)
          }
          pointOnLine(t, r) {
            let a, c, p, f, v = 1 / 0;
            for (let x = 0; x < t.length - 1; x++) {
              let C = t[x][0],
                I = t[x][1],
                L = this.wrap(t[x + 1][0] - C) * this.kx,
                F = (t[x + 1][1] - I) * this.ky,
                V = 0;
              L === 0 && F === 0 || (V = (this.wrap(r[0] - C) * this.kx * L + (r[1] - I) * this.ky * F) / (L * L + F * F), V > 1 ? (C = t[x + 1][0], I = t[x + 1][1]) : V > 0 && (C += L / this.kx * V, I += F / this.ky * V)), L = this.wrap(r[0] - C) * this.kx, F = (r[1] - I) * this.ky;
              const q = L * L + F * F;
              q < v && (v = q, a = C, c = I, p = x, f = V)
            }
            return {
              point: [a, c],
              index: p,
              t: Math.max(0, Math.min(1, f))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function $h(n, t) {
          return t[0] - n[0]
        }

        function Tl(n) {
          return n[1] - n[0] + 1
        }

        function Ja(n, t) {
          return n[1] >= n[0] && n[1] < t
        }

        function xn(n, t) {
          if (n[0] > n[1]) return [null, null];
          const r = Tl(n);
          if (t) {
            if (r === 2) return [n, null];
            const c = Math.floor(r / 2);
            return [
              [n[0], n[0] + c],
              [n[0] + c, n[1]]
            ]
          }
          if (r === 1) return [n, null];
          const a = Math.floor(r / 2) - 1;
          return [
            [n[0], n[0] + a],
            [n[0] + a + 1, n[1]]
          ]
        }

        function jc(n, t) {
          if (!Ja(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let a = t[0]; a <= t[1]; ++a) Lo(r, n[a]);
          return r
        }

        function Vc(n) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of n)
            for (const a of r) Lo(t, a);
          return t
        }

        function Gh(n) {
          return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0
        }

        function qc(n, t, r) {
          if (!Gh(n) || !Gh(t)) return NaN;
          let a = 0,
            c = 0;
          return n[2] < t[0] && (a = t[0] - n[2]), n[0] > t[2] && (a = n[0] - t[2]), n[1] > t[3] && (c = n[1] - t[3]), n[3] < t[1] && (c = t[1] - n[3]), r.distance([0, 0], [a, c])
        }

        function Es(n, t, r) {
          const a = r.pointOnLine(t, n);
          return r.distance(n, a.point)
        }

        function Zc(n, t, r, a, c) {
          const p = Math.min(Es(n, [r, a], c), Es(t, [r, a], c)),
            f = Math.min(Es(r, [n, t], c), Es(a, [n, t], c));
          return Math.min(p, f)
        }

        function Mp(n, t, r, a, c) {
          if (!Ja(t, n.length) || !Ja(a, r.length)) return 1 / 0;
          let p = 1 / 0;
          for (let f = t[0]; f < t[1]; ++f) {
            const v = n[f],
              x = n[f + 1];
            for (let C = a[0]; C < a[1]; ++C) {
              const I = r[C],
                L = r[C + 1];
              if (bl(v, x, I, L)) return 0;
              p = Math.min(p, Zc(v, x, I, L, c))
            }
          }
          return p
        }

        function Ap(n, t, r, a, c) {
          if (!Ja(t, n.length) || !Ja(a, r.length)) return NaN;
          let p = 1 / 0;
          for (let f = t[0]; f <= t[1]; ++f)
            for (let v = a[0]; v <= a[1]; ++v)
              if (p = Math.min(p, c.distance(n[f], r[v])), p === 0) return p;
          return p
        }

        function kp(n, t, r) {
          if (As(n, t, !0)) return 0;
          let a = 1 / 0;
          for (const c of t) {
            const p = c[0],
              f = c[c.length - 1];
            if (p !== f && (a = Math.min(a, Es(n, [f, p], r)), a === 0)) return a;
            const v = r.pointOnLine(c, n);
            if (a = Math.min(a, r.distance(n, v.point)), a === 0) return a
          }
          return a
        }

        function Ep(n, t, r, a) {
          if (!Ja(t, n.length)) return NaN;
          for (let p = t[0]; p <= t[1]; ++p)
            if (As(n[p], r, !0)) return 0;
          let c = 1 / 0;
          for (let p = t[0]; p < t[1]; ++p) {
            const f = n[p],
              v = n[p + 1];
            for (const x of r)
              for (let C = 0, I = x.length, L = I - 1; C < I; L = C++) {
                const F = x[L],
                  V = x[C];
                if (bl(f, v, F, V)) return 0;
                c = Math.min(c, Zc(f, v, F, V, a))
              }
          }
          return c
        }

        function Hh(n, t) {
          for (const r of n)
            for (const a of r)
              if (As(a, t, !0)) return !0;
          return !1
        }

        function zp(n, t, r, a = 1 / 0) {
          const c = Vc(n),
            p = Vc(t);
          if (a !== 1 / 0 && qc(c, p, r) >= a) return a;
          if (Do(c, p)) {
            if (Hh(n, t)) return 0
          } else if (Hh(t, n)) return 0;
          let f = 1 / 0;
          for (const v of n)
            for (let x = 0, C = v.length, I = C - 1; x < C; I = x++) {
              const L = v[I],
                F = v[x];
              for (const V of t)
                for (let q = 0, G = V.length, J = G - 1; q < G; J = q++) {
                  const oe = V[J],
                    De = V[q];
                  if (bl(L, F, oe, De)) return 0;
                  f = Math.min(f, Zc(L, F, oe, De, r))
                }
            }
          return f
        }

        function Wh(n, t, r, a, c, p) {
          if (!p) return;
          const f = qc(jc(a, p), c, r);
          f < t && n.push([f, p, [0, 0]])
        }

        function Sl(n, t, r, a, c, p, f) {
          if (!p || !f) return;
          const v = qc(jc(a, p), jc(c, f), r);
          v < t && n.push([v, p, f])
        }

        function Cl(n, t, r, a, c = 1 / 0) {
          let p = Math.min(a.distance(n[0], r[0][0]), c);
          if (p === 0) return p;
          const f = new Bc([
              [0, [0, n.length - 1],
                [0, 0]
              ]
            ], $h),
            v = Vc(r);
          for (; f.length > 0;) {
            const x = f.pop();
            if (x[0] >= p) continue;
            const C = x[1],
              I = t ? 50 : 100;
            if (Tl(C) <= I) {
              if (!Ja(C, n.length)) return NaN;
              if (t) {
                const L = Ep(n, C, r, a);
                if (isNaN(L) || L === 0) return L;
                p = Math.min(p, L)
              } else
                for (let L = C[0]; L <= C[1]; ++L) {
                  const F = kp(n[L], r, a);
                  if (p = Math.min(p, F), p === 0) return 0
                }
            } else {
              const L = xn(C, t);
              Wh(f, p, a, n, v, L[0]), Wh(f, p, a, n, v, L[1])
            }
          }
          return p
        }

        function Pl(n, t, r, a, c, p = 1 / 0) {
          let f = Math.min(p, c.distance(n[0], r[0]));
          if (f === 0) return f;
          const v = new Bc([
            [0, [0, n.length - 1],
              [0, r.length - 1]
            ]
          ], $h);
          for (; v.length > 0;) {
            const x = v.pop();
            if (x[0] >= f) continue;
            const C = x[1],
              I = x[2],
              L = t ? 50 : 100,
              F = a ? 50 : 100;
            if (Tl(C) <= L && Tl(I) <= F) {
              if (!Ja(C, n.length) && Ja(I, r.length)) return NaN;
              let V;
              if (t && a) V = Mp(n, C, r, I, c), f = Math.min(f, V);
              else if (t && !a) {
                const q = n.slice(C[0], C[1] + 1);
                for (let G = I[0]; G <= I[1]; ++G)
                  if (V = Es(r[G], q, c), f = Math.min(f, V), f === 0) return f
              } else if (!t && a) {
                const q = r.slice(I[0], I[1] + 1);
                for (let G = C[0]; G <= C[1]; ++G)
                  if (V = Es(n[G], q, c), f = Math.min(f, V), f === 0) return f
              } else V = Ap(n, C, r, I, c), f = Math.min(f, V)
            } else {
              const V = xn(C, t),
                q = xn(I, a);
              Sl(v, f, c, n, r, V[0], q[0]), Sl(v, f, c, n, r, V[0], q[1]), Sl(v, f, c, n, r, V[1], q[0]), Sl(v, f, c, n, r, V[1], q[1])
            }
          }
          return f
        }

        function Uc(n) {
          return n.type === "MultiPolygon" ? n.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : n.type === "MultiLineString" ? n.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : n.type === "MultiPoint" ? n.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [n]
        }
        class zs {
          constructor(t, r) {
            this.type = Xe, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Ca(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") return new zs(a, a.features.map((c => Uc(c.geometry))).flat());
              if (a.type === "Feature") return new zs(a, Uc(a.geometry));
              if ("type" in a && "coordinates" in a) return new zs(a, Uc(a))
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, a) {
                const c = r.geometry(),
                  p = c.flat().map((x => xl([x.x, x.y], r.canonical)));
                if (c.length === 0) return NaN;
                const f = new Nc(p[0][1]);
                let v = 1 / 0;
                for (const x of a) {
                  switch (x.type) {
                    case "Point":
                      v = Math.min(v, Pl(p, !1, [x.coordinates], !1, f, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Pl(p, !1, x.coordinates, !0, f, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Cl(p, !1, x.coordinates, f, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, a) {
                const c = r.geometry(),
                  p = c.flat().map((x => xl([x.x, x.y], r.canonical)));
                if (c.length === 0) return NaN;
                const f = new Nc(p[0][1]);
                let v = 1 / 0;
                for (const x of a) {
                  switch (x.type) {
                    case "Point":
                      v = Math.min(v, Pl(p, !0, [x.coordinates], !1, f, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Pl(p, !0, x.coordinates, !0, f, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Cl(p, !0, x.coordinates, f, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, a) {
                const c = r.geometry();
                if (c.length === 0 || c[0].length === 0) return NaN;
                const p = Bo(c, 0).map((x => x.map((C => C.map((I => xl([I.x, I.y], r.canonical))))))),
                  f = new Nc(p[0][0][0][1]);
                let v = 1 / 0;
                for (const x of a)
                  for (const C of p) {
                    switch (x.type) {
                      case "Point":
                        v = Math.min(v, Cl([x.coordinates], !1, C, f, v));
                        break;
                      case "LineString":
                        v = Math.min(v, Cl(x.coordinates, !0, C, f, v));
                        break;
                      case "Polygon":
                        v = Math.min(v, zp(C, x.coordinates, f, v))
                    }
                    if (v === 0) return v
                  }
                return v
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Fo {
          constructor(t) {
            this.type = br, this.key = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = t[1];
            return a == null ? r.error("Global state property must be defined.") : typeof a != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Fo(a)
          }
          evaluate(t) {
            var r;
            const a = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return a && Object.keys(a).length !== 0 ? Wr(a, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const Js = {
          "==": Bh,
          "!=": gl,
          ">": Ec,
          "<": yp,
          ">=": bp,
          "<=": xp,
          array: Oi,
          at: ml,
          boolean: Oi,
          case: Ys,
          coalesce: ko,
          collator: vl,
          format: Ms,
          image: Lc,
          in: _l,
          "index-of": Pa,
          interpolate: Ei,
          "interpolate-hcl": Ei,
          "interpolate-lab": Ei,
          length: yl,
          let: Po,
          literal: la,
          match: xi,
          number: Oi,
          "number-format": zc,
          object: Oi,
          slice: Io,
          step: Qn,
          string: Oi,
          "to-boolean": ga,
          "to-color": ga,
          "to-number": ga,
          "to-string": ga,
          var: fl,
          within: ks,
          distance: zs,
          "global-state": Fo
        };
        class va {
          constructor(t, r, a, c) {
            this.name = t, this.type = r, this._evaluate = a, this.args = c
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, r) {
            const a = t[0],
              c = va.definitions[a];
            if (!c) return r.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const p = Array.isArray(c) ? c[0] : c.type,
              f = Array.isArray(c) ? [
                [c[1], c[2]]
              ] : c.overloads,
              v = f.filter((([C]) => !Array.isArray(C) || C.length === t.length - 1));
            let x = null;
            for (const [C, I] of v) {
              x = new ds(r.registry, Il, r.path, null, r.scope);
              const L = [];
              let F = !1;
              for (let V = 1; V < t.length; V++) {
                const q = t[V],
                  G = Array.isArray(C) ? C[V - 1] : C.type,
                  J = x.parse(q, 1 + L.length, G);
                if (!J) {
                  F = !0;
                  break
                }
                L.push(J)
              }
              if (!F)
                if (Array.isArray(C) && C.length !== L.length) x.error(`Expected ${C.length} arguments, but found ${L.length} instead.`);
                else {
                  for (let V = 0; V < L.length; V++) {
                    const q = Array.isArray(C) ? C[V] : C.type,
                      G = L[V];
                    x.concat(V + 1).checkSubtype(q, G.type)
                  }
                  if (x.errors.length === 0) return new va(a, p, I, L)
                }
            }
            if (v.length === 1) r.errors.push(...x.errors);
            else {
              const C = (v.length ? v : f).map((([L]) => {
                  return F = L, Array.isArray(F) ? `(${F.map(Qr).join(", ")})` : `(${Qr(F.type)}...)`;
                  var F
                })).join(" | "),
                I = [];
              for (let L = 1; L < t.length; L++) {
                const F = r.parse(t[L], 1 + I.length);
                if (!F) return null;
                I.push(Qr(F.type))
              }
              r.error(`Expected arguments of type ${C}, but found (${I.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, r) {
            va.definitions = r;
            for (const a in r) t[a] = va
          }
        }

        function Xh(n, [t, r, a, c]) {
          t = t.evaluate(n), r = r.evaluate(n), a = a.evaluate(n);
          const p = c ? c.evaluate(n) : 1,
            f = In(t, r, a, p);
          if (f) throw new Sn(f);
          return new sr(t / 255, r / 255, a / 255, p, !1)
        }

        function Yh(n, t) {
          return n in t
        }

        function $c(n, t) {
          const r = t[n];
          return r === void 0 ? null : r
        }

        function Ls(n) {
          return {
            type: n
          }
        }

        function Il(n) {
          if (n instanceof fl) return Il(n.boundExpression);
          if (n instanceof va && n.name === "error" || n instanceof vl || n instanceof ks || n instanceof zs || n instanceof Fo) return !1;
          const t = n instanceof ga || n instanceof Oi;
          let r = !0;
          return n.eachChild((a => {
            r = t ? r && Il(a) : r && a instanceof la
          })), !!r && Ml(n) && Al(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function Ml(n) {
          if (n instanceof va && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof ks || n instanceof zs) return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !Ml(r) && (t = !1)
          })), t
        }

        function Oo(n) {
          if (n instanceof va && n.name === "feature-state") return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !Oo(r) && (t = !1)
          })), t
        }

        function Al(n, t) {
          if (n instanceof va && t.indexOf(n.name) >= 0) return !1;
          let r = !0;
          return n.eachChild((a => {
            r && !Al(a, t) && (r = !1)
          })), r
        }

        function Kh(n) {
          return {
            result: "success",
            value: n
          }
        }

        function Qs(n) {
          return {
            result: "error",
            value: n
          }
        }

        function ps(n) {
          return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven"
        }

        function Jh(n) {
          return !!n.expression && n.expression.parameters.indexOf("zoom") > -1
        }

        function Gc(n) {
          return !!n.expression && n.expression.interpolated
        }

        function ln(n) {
          return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n
        }

        function No(n) {
          return typeof n == "object" && n !== null && !Array.isArray(n) && Rr(n) === tn
        }

        function Lp(n) {
          return n
        }

        function Qh(n, t) {
          const r = n.stops && typeof n.stops[0][0] == "object",
            a = r || !(r || n.property !== void 0),
            c = n.type || (Gc(t) ? "exponential" : "interval"),
            p = (function(I) {
              switch (I.type) {
                case "color":
                  return sr.parse;
                case "padding":
                  return mn.parse;
                case "numberArray":
                  return On.parse;
                case "colorArray":
                  return jn.parse;
                default:
                  return null
              }
            })(t);
          if (p && ((n = sn({}, n)).stops && (n.stops = n.stops.map((I => [I[0], p(I[1])]))), n.default = p(n.default ? n.default : t.default)), n.colorSpace && (f = n.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab") throw new Error(`Unknown color space: "${n.colorSpace}"`);
          var f;
          const v = (function(I) {
            switch (I) {
              case "exponential":
                return td;
              case "interval":
                return Dp;
              case "categorical":
                return ed;
              case "identity":
                return Rp;
              default:
                throw new Error(`Unknown function type "${I}"`)
            }
          })(c);
          let x, C;
          if (c === "categorical") {
            x = Object.create(null);
            for (const I of n.stops) x[I[0]] = I[1];
            C = typeof n.stops[0][0]
          }
          if (r) {
            const I = {},
              L = [];
            for (let q = 0; q < n.stops.length; q++) {
              const G = n.stops[q],
                J = G[0].zoom;
              I[J] === void 0 && (I[J] = {
                zoom: J,
                type: n.type,
                property: n.property,
                default: n.default,
                stops: []
              }, L.push(J)), I[J].stops.push([G[0].value, G[1]])
            }
            const F = [];
            for (const q of L) F.push([I[q].zoom, Qh(I[q], t)]);
            const V = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: V,
              interpolationFactor: Ei.interpolationFactor.bind(void 0, V),
              zoomStops: F.map((q => q[0])),
              evaluate: ({
                zoom: q
              }, G) => td({
                stops: F,
                base: n.base
              }, t, q).evaluate(q, G)
            }
          }
          if (a) {
            const I = c === "exponential" ? {
              name: "exponential",
              base: n.base !== void 0 ? n.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: I,
              interpolationFactor: Ei.interpolationFactor.bind(void 0, I),
              zoomStops: n.stops.map((L => L[0])),
              evaluate: ({
                zoom: L
              }) => v(n, t, L, x, C)
            }
          }
          return {
            kind: "source",
            evaluate(I, L) {
              const F = L && L.properties ? L.properties[n.property] : void 0;
              return F === void 0 ? fs(n.default, t.default) : v(n, t, F, x, C)
            }
          }
        }

        function fs(n, t, r) {
          return n !== void 0 ? n : t !== void 0 ? t : r !== void 0 ? r : void 0
        }

        function ed(n, t, r, a, c) {
          return fs(typeof r === c ? a[r] : void 0, n.default, t.default)
        }

        function Dp(n, t, r) {
          if (ln(r) !== "number") return fs(n.default, t.default);
          const a = n.stops.length;
          if (a === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[a - 1][0]) return n.stops[a - 1][1];
          const c = Is(n.stops.map((p => p[0])), r);
          return n.stops[c][1]
        }

        function td(n, t, r) {
          const a = n.base !== void 0 ? n.base : 1;
          if (ln(r) !== "number") return fs(n.default, t.default);
          const c = n.stops.length;
          if (c === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[c - 1][0]) return n.stops[c - 1][1];
          const p = Is(n.stops.map((I => I[0])), r),
            f = (function(I, L, F, V) {
              const q = V - F,
                G = I - F;
              return q === 0 ? 0 : L === 1 ? G / q : (Math.pow(L, G) - 1) / (Math.pow(L, q) - 1)
            })(r, a, n.stops[p][0], n.stops[p + 1][0]),
            v = n.stops[p][1],
            x = n.stops[p + 1][1],
            C = Za[t.type] || Lp;
          return typeof v.evaluate == "function" ? {
            evaluate(...I) {
              const L = v.evaluate.apply(void 0, I),
                F = x.evaluate.apply(void 0, I);
              if (L !== void 0 && F !== void 0) return C(L, F, f, n.colorSpace)
            }
          } : C(v, x, f, n.colorSpace)
        }

        function Rp(n, t, r) {
          switch (t.type) {
            case "color":
              r = sr.parse(r);
              break;
            case "formatted":
              r = yn.fromString(r.toString());
              break;
            case "resolvedImage":
              r = ki.fromString(r.toString());
              break;
            case "padding":
              r = mn.parse(r);
              break;
            case "colorArray":
              r = jn.parse(r);
              break;
            case "numberArray":
              r = On.parse(r);
              break;
            default:
              ln(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
          }
          return fs(r, n.default, t.default)
        }
        va.register(Js, {
          error: [{
              kind: "error"
            },
            [Lt], (n, [t]) => {
              throw new Sn(t.evaluate(n))
            }
          ],
          typeof: [Lt, [br], (n, [t]) => Qr(Rr(t.evaluate(n)))],
          "to-rgba": [rn(Xe, 4), [Cr], (n, [t]) => {
            const [r, a, c, p] = t.evaluate(n).rgb;
            return [255 * r, 255 * a, 255 * c, p]
          }],
          rgb: [Cr, [Xe, Xe, Xe], Xh],
          rgba: [Cr, [Xe, Xe, Xe, Xe], Xh],
          has: {
            type: Vt,
            overloads: [
              [
                [Lt], (n, [t]) => Yh(t.evaluate(n), n.properties())
              ],
              [
                [Lt, tn], (n, [t, r]) => Yh(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          get: {
            type: br,
            overloads: [
              [
                [Lt], (n, [t]) => $c(t.evaluate(n), n.properties())
              ],
              [
                [Lt, tn], (n, [t, r]) => $c(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          "feature-state": [br, [Lt], (n, [t]) => $c(t.evaluate(n), n.featureState || {})],
          properties: [tn, [], n => n.properties()],
          "geometry-type": [Lt, [], n => n.geometryType()],
          id: [br, [], n => n.id()],
          zoom: [Xe, [], n => n.globals.zoom],
          "heatmap-density": [Xe, [], n => n.globals.heatmapDensity || 0],
          elevation: [Xe, [], n => n.globals.elevation || 0],
          "line-progress": [Xe, [], n => n.globals.lineProgress || 0],
          accumulated: [br, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated],
          "+": [Xe, Ls(Xe), (n, t) => {
            let r = 0;
            for (const a of t) r += a.evaluate(n);
            return r
          }],
          "*": [Xe, Ls(Xe), (n, t) => {
            let r = 1;
            for (const a of t) r *= a.evaluate(n);
            return r
          }],
          "-": {
            type: Xe,
            overloads: [
              [
                [Xe, Xe], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)
              ],
              [
                [Xe], (n, [t]) => -t.evaluate(n)
              ]
            ]
          },
          "/": [Xe, [Xe, Xe], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)],
          "%": [Xe, [Xe, Xe], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)],
          ln2: [Xe, [], () => Math.LN2],
          pi: [Xe, [], () => Math.PI],
          e: [Xe, [], () => Math.E],
          "^": [Xe, [Xe, Xe], (n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n))],
          sqrt: [Xe, [Xe], (n, [t]) => Math.sqrt(t.evaluate(n))],
          log10: [Xe, [Xe], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10],
          ln: [Xe, [Xe], (n, [t]) => Math.log(t.evaluate(n))],
          log2: [Xe, [Xe], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
          sin: [Xe, [Xe], (n, [t]) => Math.sin(t.evaluate(n))],
          cos: [Xe, [Xe], (n, [t]) => Math.cos(t.evaluate(n))],
          tan: [Xe, [Xe], (n, [t]) => Math.tan(t.evaluate(n))],
          asin: [Xe, [Xe], (n, [t]) => Math.asin(t.evaluate(n))],
          acos: [Xe, [Xe], (n, [t]) => Math.acos(t.evaluate(n))],
          atan: [Xe, [Xe], (n, [t]) => Math.atan(t.evaluate(n))],
          min: [Xe, Ls(Xe), (n, t) => Math.min(...t.map((r => r.evaluate(n))))],
          max: [Xe, Ls(Xe), (n, t) => Math.max(...t.map((r => r.evaluate(n))))],
          abs: [Xe, [Xe], (n, [t]) => Math.abs(t.evaluate(n))],
          round: [Xe, [Xe], (n, [t]) => {
            const r = t.evaluate(n);
            return r < 0 ? -Math.round(-r) : Math.round(r)
          }],
          floor: [Xe, [Xe], (n, [t]) => Math.floor(t.evaluate(n))],
          ceil: [Xe, [Xe], (n, [t]) => Math.ceil(t.evaluate(n))],
          "filter-==": [Vt, [Lt, br], (n, [t, r]) => n.properties()[t.value] === r.value],
          "filter-id-==": [Vt, [br], (n, [t]) => n.id() === t.value],
          "filter-type-==": [Vt, [Lt], (n, [t]) => n.geometryType() === t.value],
          "filter-<": [Vt, [Lt, br], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a < c
          }],
          "filter-id-<": [Vt, [br], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r < a
          }],
          "filter->": [Vt, [Lt, br], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a > c
          }],
          "filter-id->": [Vt, [br], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r > a
          }],
          "filter-<=": [Vt, [Lt, br], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a <= c
          }],
          "filter-id-<=": [Vt, [br], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r <= a
          }],
          "filter->=": [Vt, [Lt, br], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a >= c
          }],
          "filter-id->=": [Vt, [br], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r >= a
          }],
          "filter-has": [Vt, [br], (n, [t]) => t.value in n.properties()],
          "filter-has-id": [Vt, [], n => n.id() !== null && n.id() !== void 0],
          "filter-type-in": [Vt, [rn(Lt)], (n, [t]) => t.value.indexOf(n.geometryType()) >= 0],
          "filter-id-in": [Vt, [rn(br)], (n, [t]) => t.value.indexOf(n.id()) >= 0],
          "filter-in-small": [Vt, [Lt, rn(br)], (n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0],
          "filter-in-large": [Vt, [Lt, rn(br)], (n, [t, r]) => (function(a, c, p, f) {
            for (; p <= f;) {
              const v = p + f >> 1;
              if (c[v] === a) return !0;
              c[v] > a ? f = v - 1 : p = v + 1
            }
            return !1
          })(n.properties()[t.value], r.value, 0, r.value.length - 1)],
          all: {
            type: Vt,
            overloads: [
              [
                [Vt, Vt], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)
              ],
              [Ls(Vt), (n, t) => {
                for (const r of t)
                  if (!r.evaluate(n)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: Vt,
            overloads: [
              [
                [Vt, Vt], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)
              ],
              [Ls(Vt), (n, t) => {
                for (const r of t)
                  if (r.evaluate(n)) return !0;
                return !1
              }]
            ]
          },
          "!": [Vt, [Vt], (n, [t]) => !t.evaluate(n)],
          "is-supported-script": [Vt, [Lt], (n, [t]) => {
            const r = n.globals && n.globals.isSupportedScript;
            return !r || r(t.evaluate(n))
          }],
          upcase: [Lt, [Lt], (n, [t]) => t.evaluate(n).toUpperCase()],
          downcase: [Lt, [Lt], (n, [t]) => t.evaluate(n).toLowerCase()],
          concat: [Lt, Ls(br), (n, t) => t.map((r => Hr(r.evaluate(n)))).join("")],
          "resolved-locale": [Lt, [pn], (n, [t]) => t.evaluate(n).resolvedLocale()]
        });
        class Hc {
          constructor(t, r) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Ps, this._defaultValue = r ? (function(a) {
              if (a.type === "color" && No(a.default)) return new sr(0, 0, 0, 0);
              switch (a.type) {
                case "color":
                  return sr.parse(a.default) || null;
                case "padding":
                  return mn.parse(a.default) || null;
                case "numberArray":
                  return On.parse(a.default) || null;
                case "colorArray":
                  return jn.parse(a.default) || null;
                case "variableAnchorOffsetCollection":
                  return Vn.parse(a.default) || null;
                case "projectionDefinition":
                  return pi.parse(a.default) || null;
                default:
                  return a.default === void 0 ? null : a.default
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, f) {
            return this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = a, this._evaluator.canonical = c, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, r, a, c, p, f) {
            this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = a || null, this._evaluator.canonical = c, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f || null;
            try {
              const v = this.expression.evaluate(this._evaluator);
              if (v == null || typeof v == "number" && v != v) return this._defaultValue;
              if (this._enumValues && !(v in this._enumValues)) throw new Sn(`Expected value to be one of ${Object.keys(this._enumValues).map((x=>JSON.stringify(x))).join(", ")}, but found ${JSON.stringify(v)} instead.`);
              return v
            } catch (v) {
              return this._warningHistory[v.message] || (this._warningHistory[v.message] = !0, typeof console < "u" && console.warn(v.message)), this._defaultValue
            }
          }
        }

        function kl(n) {
          return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in Js
        }

        function jo(n, t) {
          const r = new ds(Js, Il, [], t ? (function(c) {
              const p = {
                color: Cr,
                string: Lt,
                number: Xe,
                enum: Lt,
                boolean: Vt,
                formatted: Cn,
                padding: Nn,
                numberArray: Bn,
                colorArray: vn,
                projectionDefinition: Zr,
                resolvedImage: lr,
                variableAnchorOffsetCollection: bn
              };
              return c.type === "array" ? rn(p[c.value] || br, c.length) : p[c.type]
            })(t) : void 0),
            a = r.parse(n, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return a ? Kh(new Hc(a, t)) : Qs(r.errors)
        }
        class Vo {
          constructor(t, r) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !Oo(r.expression), this.globalStateRefs = Uo(r.expression)
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, f)
          }
          evaluate(t, r, a, c, p, f) {
            return this._styleExpression.evaluate(t, r, a, c, p, f)
          }
        }
        class Wc {
          constructor(t, r, a, c) {
            this.kind = t, this.zoomStops = a, this._styleExpression = r, this.isStateDependent = t !== "camera" && !Oo(r.expression), this.globalStateRefs = Uo(r.expression), this.interpolationType = c
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, f)
          }
          evaluate(t, r, a, c, p, f) {
            return this._styleExpression.evaluate(t, r, a, c, p, f)
          }
          interpolationFactor(t, r, a) {
            return this.interpolationType ? Ei.interpolationFactor(this.interpolationType, t, r, a) : 0
          }
        }

        function rd(n, t) {
          const r = jo(n, t);
          if (r.result === "error") return r;
          const a = r.value.expression,
            c = Ml(a);
          if (!c && !ps(t)) return Qs([new Yr("", "data expressions not supported")]);
          const p = Al(a, ["zoom"]);
          if (!p && !Jh(t)) return Qs([new Yr("", "zoom expressions not supported")]);
          const f = Zo(a);
          return f || p ? f instanceof Yr ? Qs([f]) : f instanceof Ei && !Gc(t) ? Qs([new Yr("", '"interpolate" expressions cannot be used with this property')]) : Kh(f ? new Wc(c ? "camera" : "composite", r.value, f.labels, f instanceof Ei ? f.interpolation : void 0) : new Vo(c ? "constant" : "source", r.value)) : Qs([new Yr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class qo {
          constructor(t, r) {
            this._parameters = t, this._specification = r, sn(this, Qh(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new qo(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function Zo(n) {
          let t = null;
          if (n instanceof Po) t = Zo(n.result);
          else if (n instanceof ko) {
            for (const r of n.args)
              if (t = Zo(r), t) break
          } else(n instanceof Qn || n instanceof Ei) && n.input instanceof va && n.input.name === "zoom" && (t = n);
          return t instanceof Yr || n.eachChild((r => {
            const a = Zo(r);
            a instanceof Yr ? t = a : !t && a ? t = new Yr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new Yr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Uo(n, t = new Set) {
          return n instanceof Fo && t.add(n.key), n.eachChild((r => {
            Uo(r, t)
          })), t
        }

        function El(n) {
          if (n === !0 || n === !1) return !0;
          if (!Array.isArray(n) || n.length === 0) return !1;
          switch (n[0]) {
            case "has":
              return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
            case "in":
              return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
            case "any":
            case "all":
              for (const t of n.slice(1))
                if (!El(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const Xc = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function Ds(n) {
          if (n == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          El(n) || (n = Rs(n));
          const t = jo(n, Xc);
          if (t.result === "error") throw new Error(t.value.map((r => `${r.key}: ${r.message}`)).join(", "));
          return {
            filter: (r, a, c) => t.value.evaluate(r, a, {}, c),
            needGeometry: zl(n),
            getGlobalStateRefs: () => Uo(t.value.expression)
          }
        }

        function Yc(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function zl(n) {
          if (!Array.isArray(n)) return !1;
          if (n[0] === "within" || n[0] === "distance") return !0;
          for (let t = 1; t < n.length; t++)
            if (zl(n[t])) return !0;
          return !1
        }

        function Rs(n) {
          if (!n) return !0;
          const t = n[0];
          return n.length <= 1 ? t !== "any" : t === "==" ? Kc(n[1], n[2], "==") : t === "!=" ? Ll(Kc(n[1], n[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Kc(n[1], n[2], t) : t === "any" ? (r = n.slice(1), ["any"].concat(r.map(Rs))) : t === "all" ? ["all"].concat(n.slice(1).map(Rs)) : t === "none" ? ["all"].concat(n.slice(1).map(Rs).map(Ll)) : t === "in" ? nd(n[1], n.slice(2)) : t === "!in" ? Ll(nd(n[1], n.slice(2))) : t === "has" ? id(n[1]) : t !== "!has" || Ll(id(n[1]));
          var r
        }

        function Kc(n, t, r) {
          switch (n) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, n, t]
          }
        }

        function nd(n, t) {
          if (t.length === 0) return !1;
          switch (n) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", n, ["literal", t.sort(Yc)]] : ["filter-in-small", n, ["literal", t]]
          }
        }

        function id(n) {
          switch (n) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", n]
          }
        }

        function Ll(n) {
          return ["!", n]
        }

        function Jc(n) {
          const t = typeof n;
          if (t === "number" || t === "boolean" || t === "string" || n == null) return JSON.stringify(n);
          if (Array.isArray(n)) {
            let c = "[";
            for (const p of n) c += `${Jc(p)},`;
            return `${c}]`
          }
          const r = Object.keys(n).sort();
          let a = "{";
          for (let c = 0; c < r.length; c++) a += `${JSON.stringify(r[c])}:${Jc(n[r[c]])},`;
          return `${a}}`
        }

        function Bp(n) {
          let t = "";
          for (const r of Nt) t += `/${Jc(n[r])}`;
          return t
        }

        function Qc(n) {
          const t = n.value;
          return t ? [new yt(n.key, t, "constants have been deprecated as of v8")] : []
        }

        function Yn(n) {
          return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
        }

        function Ua(n) {
          if (Array.isArray(n)) return n.map(Ua);
          if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
            const t = {};
            for (const r in n) t[r] = Ua(n[r]);
            return t
          }
          return Yn(n)
        }

        function ya(n) {
          const t = n.key,
            r = n.value,
            a = n.valueSpec || {},
            c = n.objectElementValidators || {},
            p = n.style,
            f = n.styleSpec,
            v = n.validateSpec;
          let x = [];
          const C = ln(r);
          if (C !== "object") return [new yt(t, r, `object expected, ${C} found`)];
          for (const I in r) {
            const L = I.split(".")[0],
              F = Wr(a, L) || a["*"];
            let V;
            if (Wr(c, L)) V = c[L];
            else if (Wr(a, L)) V = v;
            else if (c["*"]) V = c["*"];
            else {
              if (!a["*"]) {
                x.push(new yt(t, r[I], `unknown property "${I}"`));
                continue
              }
              V = v
            }
            x = x.concat(V({
              key: (t && `${t}.`) + I,
              value: r[I],
              valueSpec: F,
              style: p,
              styleSpec: f,
              object: r,
              objectKey: I,
              validateSpec: v
            }, r))
          }
          for (const I in a) c[I] || a[I].required && a[I].default === void 0 && r[I] === void 0 && x.push(new yt(t, r, `missing required property "${I}"`));
          return x
        }

        function Dl(n) {
          const t = n.value,
            r = n.valueSpec,
            a = n.style,
            c = n.styleSpec,
            p = n.key,
            f = n.arrayElementValidator || n.validateSpec;
          if (ln(t) !== "array") return [new yt(p, t, `array expected, ${ln(t)} found`)];
          if (r.length && t.length !== r.length) return [new yt(p, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new yt(p, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let v = {
            type: r.value,
            values: r.values
          };
          c.$version < 7 && (v.function = r.function), ln(r.value) === "object" && (v = r.value);
          let x = [];
          for (let C = 0; C < t.length; C++) x = x.concat(f({
            array: t,
            arrayIndex: C,
            value: t[C],
            valueSpec: v,
            validateSpec: n.validateSpec,
            style: a,
            styleSpec: c,
            key: `${p}[${C}]`
          }));
          return x
        }

        function $o(n) {
          const t = n.key,
            r = n.value,
            a = n.valueSpec;
          let c = ln(r);
          return c === "number" && r != r && (c = "NaN"), c !== "number" ? [new yt(t, r, `number expected, ${c} found`)] : "minimum" in a && r < a.minimum ? [new yt(t, r, `${r} is less than the minimum value ${a.minimum}`)] : "maximum" in a && r > a.maximum ? [new yt(t, r, `${r} is greater than the maximum value ${a.maximum}`)] : []
        }

        function ad(n) {
          const t = n.valueSpec,
            r = Yn(n.value.type);
          let a, c, p, f = {};
          const v = r !== "categorical" && n.value.property === void 0,
            x = !v,
            C = ln(n.value.stops) === "array" && ln(n.value.stops[0]) === "array" && ln(n.value.stops[0][0]) === "object",
            I = ya({
              key: n.key,
              value: n.value,
              valueSpec: n.styleSpec.function,
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: n.styleSpec,
              objectElementValidators: {
                stops: function(V) {
                  if (r === "identity") return [new yt(V.key, V.value, 'identity function may not have a "stops" property')];
                  let q = [];
                  const G = V.value;
                  return q = q.concat(Dl({
                    key: V.key,
                    value: G,
                    valueSpec: V.valueSpec,
                    validateSpec: V.validateSpec,
                    style: V.style,
                    styleSpec: V.styleSpec,
                    arrayElementValidator: L
                  })), ln(G) === "array" && G.length === 0 && q.push(new yt(V.key, G, "array must have at least one stop")), q
                },
                default: function(V) {
                  return V.validateSpec({
                    key: V.key,
                    value: V.value,
                    valueSpec: t,
                    validateSpec: V.validateSpec,
                    style: V.style,
                    styleSpec: V.styleSpec
                  })
                }
              }
            });
          return r === "identity" && v && I.push(new yt(n.key, n.value, 'missing required property "property"')), r === "identity" || n.value.stops || I.push(new yt(n.key, n.value, 'missing required property "stops"')), r === "exponential" && n.valueSpec.expression && !Gc(n.valueSpec) && I.push(new yt(n.key, n.value, "exponential functions not supported")), n.styleSpec.$version >= 8 && (x && !ps(n.valueSpec) ? I.push(new yt(n.key, n.value, "property functions not supported")) : v && !Jh(n.valueSpec) && I.push(new yt(n.key, n.value, "zoom functions not supported"))), r !== "categorical" && !C || n.value.property !== void 0 || I.push(new yt(n.key, n.value, '"property" property is required')), I;

          function L(V) {
            let q = [];
            const G = V.value,
              J = V.key;
            if (ln(G) !== "array") return [new yt(J, G, `array expected, ${ln(G)} found`)];
            if (G.length !== 2) return [new yt(J, G, `array length 2 expected, length ${G.length} found`)];
            if (C) {
              if (ln(G[0]) !== "object") return [new yt(J, G, `object expected, ${ln(G[0])} found`)];
              if (G[0].zoom === void 0) return [new yt(J, G, "object stop key must have zoom")];
              if (G[0].value === void 0) return [new yt(J, G, "object stop key must have value")];
              if (p && p > Yn(G[0].zoom)) return [new yt(J, G[0].zoom, "stop zoom values must appear in ascending order")];
              Yn(G[0].zoom) !== p && (p = Yn(G[0].zoom), c = void 0, f = {}), q = q.concat(ya({
                key: `${J}[0]`,
                value: G[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: V.validateSpec,
                style: V.style,
                styleSpec: V.styleSpec,
                objectElementValidators: {
                  zoom: $o,
                  value: F
                }
              }))
            } else q = q.concat(F({
              key: `${J}[0]`,
              value: G[0],
              validateSpec: V.validateSpec,
              style: V.style,
              styleSpec: V.styleSpec
            }, G));
            return kl(Ua(G[1])) ? q.concat([new yt(`${J}[1]`, G[1], "expressions are not allowed in function stops.")]) : q.concat(V.validateSpec({
              key: `${J}[1]`,
              value: G[1],
              valueSpec: t,
              validateSpec: V.validateSpec,
              style: V.style,
              styleSpec: V.styleSpec
            }))
          }

          function F(V, q) {
            const G = ln(V.value),
              J = Yn(V.value),
              oe = V.value !== null ? V.value : q;
            if (a) {
              if (G !== a) return [new yt(V.key, oe, `${G} stop domain type must match previous stop domain type ${a}`)]
            } else a = G;
            if (G !== "number" && G !== "string" && G !== "boolean") return [new yt(V.key, oe, "stop domain value must be a number, string, or boolean")];
            if (G !== "number" && r !== "categorical") {
              let De = `number expected, ${G} found`;
              return ps(t) && r === void 0 && (De += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new yt(V.key, oe, De)]
            }
            return r !== "categorical" || G !== "number" || isFinite(J) && Math.floor(J) === J ? r !== "categorical" && G === "number" && c !== void 0 && J < c ? [new yt(V.key, oe, "stop domain values must appear in ascending order")] : (c = J, r === "categorical" && J in f ? [new yt(V.key, oe, "stop domain values must be unique")] : (f[J] = !0, [])) : [new yt(V.key, oe, `integer expected, found ${J}`)]
          }
        }

        function Bs(n) {
          const t = (n.expressionContext === "property" ? rd : jo)(Ua(n.value), n.valueSpec);
          if (t.result === "error") return t.value.map((a => new yt(`${n.key}${a.key}`, n.value, a.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (n.expressionContext === "property" && n.propertyKey === "text-font" && !r.outputDefined()) return [new yt(n.key, n.value, `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (n.expressionContext === "property" && n.propertyType === "layout" && !Oo(r)) return [new yt(n.key, n.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (n.expressionContext === "filter" && !Oo(r)) return [new yt(n.key, n.value, '"feature-state" data expressions are not supported with filters.')];
          if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) {
            if (!Al(r, ["zoom", "feature-state"])) return [new yt(n.key, n.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (n.expressionContext === "cluster-initial" && !Ml(r)) return [new yt(n.key, n.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function Rl(n) {
          const t = n.key,
            r = n.value,
            a = ln(r);
          return a !== "string" ? [new yt(t, r, `color expected, ${a} found`)] : sr.parse(String(r)) ? [] : [new yt(t, r, `color expected, "${r}" found`)]
        }

        function Qa(n) {
          const t = n.key,
            r = n.value,
            a = n.valueSpec,
            c = [];
          return Array.isArray(a.values) ? a.values.indexOf(Yn(r)) === -1 && c.push(new yt(t, r, `expected one of [${a.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(a.values).indexOf(Yn(r)) === -1 && c.push(new yt(t, r, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(r)} found`)), c
        }

        function eu(n) {
          return El(Ua(n.value)) ? Bs(sn({}, n, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : sd(n)
        }

        function sd(n) {
          const t = n.value,
            r = n.key;
          if (ln(t) !== "array") return [new yt(r, t, `array expected, ${ln(t)} found`)];
          const a = n.styleSpec;
          let c, p = [];
          if (t.length < 1) return [new yt(r, t, "filter array must have at least 1 element")];
          switch (p = p.concat(Qa({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: a.filter_operator,
              style: n.style,
              styleSpec: n.styleSpec
            })), Yn(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && Yn(t[1]) === "$type" && p.push(new yt(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && p.push(new yt(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (c = ln(t[1]), c !== "string" && p.push(new yt(`${r}[1]`, t[1], `string expected, ${c} found`)));
              for (let f = 2; f < t.length; f++) c = ln(t[f]), Yn(t[1]) === "$type" ? p = p.concat(Qa({
                key: `${r}[${f}]`,
                value: t[f],
                valueSpec: a.geometry_type,
                style: n.style,
                styleSpec: n.styleSpec
              })) : c !== "string" && c !== "number" && c !== "boolean" && p.push(new yt(`${r}[${f}]`, t[f], `string, number, or boolean expected, ${c} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let f = 1; f < t.length; f++) p = p.concat(sd({
                key: `${r}[${f}]`,
                value: t[f],
                style: n.style,
                styleSpec: n.styleSpec
              }));
              break;
            case "has":
            case "!has":
              c = ln(t[1]), t.length !== 2 ? p.push(new yt(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && p.push(new yt(`${r}[1]`, t[1], `string expected, ${c} found`))
          }
          return p
        }

        function od(n, t) {
          const r = n.key,
            a = n.validateSpec,
            c = n.style,
            p = n.styleSpec,
            f = n.value,
            v = n.objectKey,
            x = p[`${t}_${n.layerType}`];
          if (!x) return [];
          const C = v.match(/^(.*)-transition$/);
          if (t === "paint" && C && x[C[1]] && x[C[1]].transition) return a({
            key: r,
            value: f,
            valueSpec: p.transition,
            style: c,
            styleSpec: p
          });
          const I = n.valueSpec || x[v];
          if (!I) return [new yt(r, f, `unknown property "${v}"`)];
          let L;
          if (ln(f) === "string" && ps(I) && !I.tokens && (L = /^{([^}]+)}$/.exec(f))) return [new yt(r, f, `"${v}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(L[1])} }\`.`)];
          const F = [];
          return n.layerType === "symbol" && (v === "text-field" && c && !c.glyphs && F.push(new yt(r, f, 'use of "text-field" requires a style "glyphs" property')), v === "text-font" && No(Ua(f)) && Yn(f.type) === "identity" && F.push(new yt(r, f, '"text-font" does not support identity functions'))), F.concat(a({
            key: n.key,
            value: f,
            valueSpec: I,
            style: c,
            styleSpec: p,
            expressionContext: "property",
            propertyType: t,
            propertyKey: v
          }))
        }

        function ld(n) {
          return od(n, "paint")
        }

        function cd(n) {
          return od(n, "layout")
        }

        function ud(n) {
          let t = [];
          const r = n.value,
            a = n.key,
            c = n.style,
            p = n.styleSpec;
          if (ln(r) !== "object") return [new yt(a, r, `object expected, ${ln(r)} found`)];
          r.type || r.ref || t.push(new yt(a, r, 'either "type" or "ref" is required'));
          let f = Yn(r.type);
          const v = Yn(r.ref);
          if (r.id) {
            const x = Yn(r.id);
            for (let C = 0; C < n.arrayIndex; C++) {
              const I = c.layers[C];
              Yn(I.id) === x && t.push(new yt(a, r.id, `duplicate layer id "${r.id}", previously used at line ${I.id.__line__}`))
            }
          }
          if ("ref" in r) {
            let x;
            ["type", "source", "source-layer", "filter", "layout"].forEach((C => {
              C in r && t.push(new yt(a, r[C], `"${C}" is prohibited for ref layers`))
            })), c.layers.forEach((C => {
              Yn(C.id) === v && (x = C)
            })), x ? x.ref ? t.push(new yt(a, r.ref, "ref cannot reference another ref layer")) : f = Yn(x.type) : t.push(new yt(a, r.ref, `ref layer "${v}" not found`))
          } else if (f !== "background")
            if (r.source) {
              const x = c.sources && c.sources[r.source],
                C = x && Yn(x.type);
              x ? C === "vector" && f === "raster" ? t.push(new yt(a, r.source, `layer "${r.id}" requires a raster source`)) : C !== "raster-dem" && f === "hillshade" || C !== "raster-dem" && f === "color-relief" ? t.push(new yt(a, r.source, `layer "${r.id}" requires a raster-dem source`)) : C === "raster" && f !== "raster" ? t.push(new yt(a, r.source, `layer "${r.id}" requires a vector source`)) : C !== "vector" || r["source-layer"] ? C === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? t.push(new yt(a, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !r.paint || !r.paint["line-gradient"] || C === "geojson" && x.lineMetrics || t.push(new yt(a, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new yt(a, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new yt(a, r.source, `source "${r.source}" not found`))
            } else t.push(new yt(a, r, 'missing required property "source"'));
          return t = t.concat(ya({
            key: a,
            value: r,
            valueSpec: p.layer,
            style: n.style,
            styleSpec: n.styleSpec,
            validateSpec: n.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => n.validateSpec({
                key: `${a}.type`,
                value: r.type,
                valueSpec: p.layer.type,
                style: n.style,
                styleSpec: n.styleSpec,
                validateSpec: n.validateSpec,
                object: r,
                objectKey: "type"
              }),
              filter: eu,
              layout: x => ya({
                layer: r,
                key: x.key,
                value: x.value,
                style: x.style,
                styleSpec: x.styleSpec,
                validateSpec: x.validateSpec,
                objectElementValidators: {
                  "*": C => cd(sn({
                    layerType: f
                  }, C))
                }
              }),
              paint: x => ya({
                layer: r,
                key: x.key,
                value: x.value,
                style: x.style,
                styleSpec: x.styleSpec,
                validateSpec: x.validateSpec,
                objectElementValidators: {
                  "*": C => ld(sn({
                    layerType: f
                  }, C))
                }
              })
            }
          })), t
        }

        function Ma(n) {
          const t = n.value,
            r = n.key,
            a = ln(t);
          return a !== "string" ? [new yt(r, t, `string expected, ${a} found`)] : []
        }
        const eo = {
          promoteId: function({
            key: n,
            value: t
          }) {
            if (ln(t) === "string") return Ma({
              key: n,
              value: t
            });
            {
              const r = [];
              for (const a in t) r.push(...Ma({
                key: `${n}.${a}`,
                value: t[a]
              }));
              return r
            }
          }
        };

        function ea(n) {
          const t = n.value,
            r = n.key,
            a = n.styleSpec,
            c = n.style,
            p = n.validateSpec;
          if (!t.type) return [new yt(r, t, '"type" is required')];
          const f = Yn(t.type);
          let v;
          switch (f) {
            case "vector":
            case "raster":
              return v = ya({
                key: r,
                value: t,
                valueSpec: a[`source_${f.replace("-","_")}`],
                style: n.style,
                styleSpec: a,
                objectElementValidators: eo,
                validateSpec: p
              }), v;
            case "raster-dem":
              return v = (function(x) {
                var C;
                const I = (C = x.sourceName) !== null && C !== void 0 ? C : "",
                  L = x.value,
                  F = x.styleSpec,
                  V = F.source_raster_dem,
                  q = x.style;
                let G = [];
                const J = ln(L);
                if (L === void 0) return G;
                if (J !== "object") return G.push(new yt("source_raster_dem", L, `object expected, ${J} found`)), G;
                const oe = Yn(L.encoding) === "custom",
                  De = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  ve = x.value.encoding ? `"${x.value.encoding}"` : "Default";
                for (const Se in L) !oe && De.includes(Se) ? G.push(new yt(Se, L[Se], `In "${I}": "${Se}" is only valid when "encoding" is set to "custom". ${ve} encoding found`)) : V[Se] ? G = G.concat(x.validateSpec({
                  key: Se,
                  value: L[Se],
                  valueSpec: V[Se],
                  validateSpec: x.validateSpec,
                  style: q,
                  styleSpec: F
                })) : G.push(new yt(Se, L[Se], `unknown property "${Se}"`));
                return G
              })({
                sourceName: r,
                value: t,
                style: n.style,
                styleSpec: a,
                validateSpec: p
              }), v;
            case "geojson":
              if (v = ya({
                  key: r,
                  value: t,
                  valueSpec: a.source_geojson,
                  style: c,
                  styleSpec: a,
                  validateSpec: p,
                  objectElementValidators: eo
                }), t.cluster)
                for (const x in t.clusterProperties) {
                  const [C, I] = t.clusterProperties[x], L = typeof C == "string" ? [C, ["accumulated"],
                    ["get", x]
                  ] : C;
                  v.push(...Bs({
                    key: `${r}.${x}.map`,
                    value: I,
                    expressionContext: "cluster-map"
                  })), v.push(...Bs({
                    key: `${r}.${x}.reduce`,
                    value: L,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return v;
            case "video":
              return ya({
                key: r,
                value: t,
                valueSpec: a.source_video,
                style: c,
                validateSpec: p,
                styleSpec: a
              });
            case "image":
              return ya({
                key: r,
                value: t,
                valueSpec: a.source_image,
                style: c,
                validateSpec: p,
                styleSpec: a
              });
            case "canvas":
              return [new yt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Qa({
                key: `${r}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function to(n) {
          const t = n.value,
            r = n.styleSpec,
            a = r.light,
            c = n.style;
          let p = [];
          const f = ln(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new yt("light", t, `object expected, ${f} found`)]), p;
          for (const v in t) {
            const x = v.match(/^(.*)-transition$/);
            p = p.concat(x && a[x[1]] && a[x[1]].transition ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: r.transition,
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : a[v] ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: a[v],
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : [new yt(v, t[v], `unknown property "${v}"`)])
          }
          return p
        }

        function tu(n) {
          const t = n.value,
            r = n.styleSpec,
            a = r.sky,
            c = n.style,
            p = ln(t);
          if (t === void 0) return [];
          if (p !== "object") return [new yt("sky", t, `object expected, ${p} found`)];
          let f = [];
          for (const v in t) f = f.concat(a[v] ? n.validateSpec({
            key: v,
            value: t[v],
            valueSpec: a[v],
            style: c,
            styleSpec: r
          }) : [new yt(v, t[v], `unknown property "${v}"`)]);
          return f
        }

        function hd(n) {
          const t = n.value,
            r = n.styleSpec,
            a = r.terrain,
            c = n.style;
          let p = [];
          const f = ln(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new yt("terrain", t, `object expected, ${f} found`)]), p;
          for (const v in t) p = p.concat(a[v] ? n.validateSpec({
            key: v,
            value: t[v],
            valueSpec: a[v],
            validateSpec: n.validateSpec,
            style: c,
            styleSpec: r
          }) : [new yt(v, t[v], `unknown property "${v}"`)]);
          return p
        }

        function dd(n) {
          let t = [];
          const r = n.value,
            a = n.key;
          if (Array.isArray(r)) {
            const c = [],
              p = [];
            for (const f in r) r[f].id && c.includes(r[f].id) && t.push(new yt(a, r, `all the sprites' ids must be unique, but ${r[f].id} is duplicated`)), c.push(r[f].id), r[f].url && p.includes(r[f].url) && t.push(new yt(a, r, `all the sprites' URLs must be unique, but ${r[f].url} is duplicated`)), p.push(r[f].url), t = t.concat(ya({
              key: `${a}[${f}]`,
              value: r[f],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: n.validateSpec
            }));
            return t
          }
          return Ma({
            key: a,
            value: r
          })
        }

        function ro(n) {
          return t = n.value, t && t.constructor === Object ? [] : [new yt(n.key, n.value, `object expected, ${ln(n.value)} found`)];
          var t
        }
        const ru = {
          "*": () => [],
          array: Dl,
          boolean: function(n) {
            const t = n.value,
              r = n.key,
              a = ln(t);
            return a !== "boolean" ? [new yt(r, t, `boolean expected, ${a} found`)] : []
          },
          number: $o,
          color: Rl,
          constants: Qc,
          enum: Qa,
          filter: eu,
          function: ad,
          layer: ud,
          object: ya,
          source: ea,
          light: to,
          sky: tu,
          terrain: hd,
          projection: function(n) {
            const t = n.value,
              r = n.styleSpec,
              a = r.projection,
              c = n.style,
              p = ln(t);
            if (t === void 0) return [];
            if (p !== "object") return [new yt("projection", t, `object expected, ${p} found`)];
            let f = [];
            for (const v in t) f = f.concat(a[v] ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: a[v],
              style: c,
              styleSpec: r
            }) : [new yt(v, t[v], `unknown property "${v}"`)]);
            return f
          },
          projectionDefinition: function(n) {
            const t = n.key;
            let r = n.value;
            r = r instanceof String ? r.valueOf() : r;
            const a = ln(r);
            return a !== "array" || (function(c) {
              return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
            })(r) || (function(c) {
              return !!["interpolate", "step", "literal"].includes(c[0])
            })(r) ? ["array", "string"].includes(a) ? [] : [new yt(t, r, `projection expected, invalid type "${a}" found`)] : [new yt(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)]
          },
          string: Ma,
          formatted: function(n) {
            return Ma(n).length === 0 ? [] : Bs(n)
          },
          resolvedImage: function(n) {
            return Ma(n).length === 0 ? [] : Bs(n)
          },
          padding: function(n) {
            const t = n.key,
              r = n.value;
            if (ln(r) === "array") {
              if (r.length < 1 || r.length > 4) return [new yt(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
              const a = {
                type: "number"
              };
              let c = [];
              for (let p = 0; p < r.length; p++) c = c.concat(n.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: n.validateSpec,
                valueSpec: a
              }));
              return c
            }
            return $o({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          numberArray: function(n) {
            const t = n.key,
              r = n.value;
            if (ln(r) === "array") {
              const a = {
                type: "number"
              };
              if (r.length < 1) return [new yt(t, r, "array length at least 1 expected, length 0 found")];
              let c = [];
              for (let p = 0; p < r.length; p++) c = c.concat(n.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: n.validateSpec,
                valueSpec: a
              }));
              return c
            }
            return $o({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          colorArray: function(n) {
            const t = n.key,
              r = n.value;
            if (ln(r) === "array") {
              if (r.length < 1) return [new yt(t, r, "array length at least 1 expected, length 0 found")];
              let a = [];
              for (let c = 0; c < r.length; c++) a = a.concat(Rl({
                key: `${t}[${c}]`,
                value: r[c]
              }));
              return a
            }
            return Rl({
              key: t,
              value: r
            })
          },
          variableAnchorOffsetCollection: function(n) {
            const t = n.key,
              r = n.value,
              a = ln(r),
              c = n.styleSpec;
            if (a !== "array" || r.length < 1 || r.length % 2 != 0) return [new yt(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let p = [];
            for (let f = 0; f < r.length; f += 2) p = p.concat(Qa({
              key: `${t}[${f}]`,
              value: r[f],
              valueSpec: c.layout_symbol["text-anchor"]
            })), p = p.concat(Dl({
              key: `${t}[${f+1}]`,
              value: r[f + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: c
            }));
            return p
          },
          sprite: dd,
          state: ro
        };

        function no(n) {
          const t = n.value,
            r = n.valueSpec,
            a = n.styleSpec;
          return n.validateSpec = no, r.expression && No(Yn(t)) ? ad(n) : r.expression && kl(Ua(t)) ? Bs(n) : r.type && ru[r.type] ? ru[r.type](n) : ya(sn({}, n, {
            valueSpec: r.type ? a[r.type] : r
          }))
        }

        function pd(n) {
          const t = n.value,
            r = n.key,
            a = Ma(n);
          return a.length || (t.indexOf("{fontstack}") === -1 && a.push(new yt(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && a.push(new yt(r, t, '"glyphs" url must include a "{range}" token'))), a
        }

        function ta(n, t = xe) {
          let r = [];
          return r = r.concat(no({
            key: "",
            value: n,
            valueSpec: t.$root,
            styleSpec: t,
            style: n,
            validateSpec: no,
            objectElementValidators: {
              glyphs: pd,
              "*": () => []
            }
          })), n.constants && (r = r.concat(Qc({
            key: "constants",
            value: n.constants
          }))), io(r)
        }

        function Aa(n) {
          return function(t) {
            return n({
              ...t,
              validateSpec: no
            })
          }
        }

        function io(n) {
          return [].concat(n).sort(((t, r) => t.line - r.line))
        }

        function ka(n) {
          return function(...t) {
            return io(n.apply(this, t))
          }
        }
        ta.source = ka(Aa(ea)), ta.sprite = ka(Aa(dd)), ta.glyphs = ka(Aa(pd)), ta.light = ka(Aa(to)), ta.sky = ka(Aa(tu)), ta.terrain = ka(Aa(hd)), ta.state = ka(Aa(ro)), ta.layer = ka(Aa(ud)), ta.filter = ka(Aa(eu)), ta.paintProperty = ka(Aa(ld)), ta.layoutProperty = ka(Aa(cd));
        const ao = ta,
          Fp = ao.light,
          Go = ao.sky,
          Op = ao.paintProperty,
          Np = ao.layoutProperty;

        function Ho(n, t) {
          let r = !1;
          if (t && t.length)
            for (const a of t) n.fire(new Qe(new Error(a.message))), r = !0;
          return r
        }
        class Wo {
          constructor(t, r, a) {
            const c = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const f = new Int32Array(this.arrayBuffer);
              t = f[0], this.d = (r = f[1]) + 2 * (a = f[2]);
              for (let x = 0; x < this.d * this.d; x++) {
                const C = f[3 + x],
                  I = f[3 + x + 1];
                c.push(C === I ? null : f.subarray(C, I))
              }
              const v = f[3 + c.length + 1];
              this.keys = f.subarray(f[3 + c.length], v), this.bboxes = f.subarray(v), this.insert = this._insertReadonly
            } else {
              this.d = r + 2 * a;
              for (let f = 0; f < this.d * this.d; f++) c.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = r, this.extent = t, this.padding = a, this.scale = r / t, this.uid = 0;
            const p = a / r * t;
            this.min = -p, this.max = t + p
          }
          insert(t, r, a, c, p) {
            this._forEachCell(r, a, c, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(p)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, r, a, c, p, f) {
            this.cells[p].push(f)
          }
          query(t, r, a, c, p) {
            const f = this.min,
              v = this.max;
            if (t <= f && r <= f && v <= a && v <= c && !p) return Array.prototype.slice.call(this.keys);
            {
              const x = [];
              return this._forEachCell(t, r, a, c, this._queryCell, x, {}, p), x
            }
          }
          _queryCell(t, r, a, c, p, f, v, x) {
            const C = this.cells[p];
            if (C !== null) {
              const I = this.keys,
                L = this.bboxes;
              for (let F = 0; F < C.length; F++) {
                const V = C[F];
                if (v[V] === void 0) {
                  const q = 4 * V;
                  (x ? x(L[q + 0], L[q + 1], L[q + 2], L[q + 3]) : t <= L[q + 2] && r <= L[q + 3] && a >= L[q + 0] && c >= L[q + 1]) ? (v[V] = !0, f.push(I[V])) : v[V] = !1
                }
              }
            }
          }
          _forEachCell(t, r, a, c, p, f, v, x) {
            const C = this._convertToCellCoord(t),
              I = this._convertToCellCoord(r),
              L = this._convertToCellCoord(a),
              F = this._convertToCellCoord(c);
            for (let V = C; V <= L; V++)
              for (let q = I; q <= F; q++) {
                const G = this.d * q + V;
                if ((!x || x(this._convertFromCellCoord(V), this._convertFromCellCoord(q), this._convertFromCellCoord(V + 1), this._convertFromCellCoord(q + 1))) && p.call(this, t, r, a, c, G, f, v, x)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              r = 3 + this.cells.length + 1 + 1;
            let a = 0;
            for (let f = 0; f < this.cells.length; f++) a += this.cells[f].length;
            const c = new Int32Array(r + a + this.keys.length + this.bboxes.length);
            c[0] = this.extent, c[1] = this.n, c[2] = this.padding;
            let p = r;
            for (let f = 0; f < t.length; f++) {
              const v = t[f];
              c[3 + f] = p, c.set(v, p), p += v.length
            }
            return c[3 + t.length] = p, c.set(this.keys, p), p += this.keys.length, c[3 + t.length + 1] = p, c.set(this.bboxes, p), p += this.bboxes.length, c.buffer
          }
          static serialize(t, r) {
            const a = t.toArrayBuffer();
            return r && r.push(a), {
              buffer: a
            }
          }
          static deserialize(t) {
            return new Wo(t.buffer)
          }
        }
        const Ea = {};

        function Qt(n, t, r = {}) {
          if (Ea[n]) throw new Error(`${n} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: n,
            writeable: !1
          }), Ea[n] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          }
        }
        Qt("Object", Object), Qt("Set", Set), Qt("TransferableGridIndex", Wo), Qt("Color", sr), Qt("Error", Error), Qt("AJAXError", ie), Qt("ResolvedImage", ki), Qt("StylePropertyFunction", qo), Qt("StyleExpression", Hc, {
          omit: ["_evaluator"]
        }), Qt("ZoomDependentExpression", Wc), Qt("ZoomConstantExpression", Vo), Qt("CompoundExpression", va, {
          omit: ["_evaluate"]
        });
        for (const n in Js) Js[n]._classRegistryKey || Qt(`Expression_${n}`, Js[n]);

        function nu(n) {
          return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer")
        }

        function Bl(n) {
          return n.$name || n.constructor._classRegistryKey
        }

        function iu(n) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const r = Bl(t);
            return !(!r || r === "Object")
          })(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || nu(n) || er(n) || ArrayBuffer.isView(n) || n instanceof ImageData)
        }

        function so(n, t) {
          if (iu(n)) return (nu(n) || er(n)) && t && t.push(n), ArrayBuffer.isView(n) && t && t.push(n.buffer), n instanceof ImageData && t && t.push(n.data.buffer), n;
          if (Array.isArray(n)) {
            const p = [];
            for (const f of n) p.push(so(f, t));
            return p
          }
          if (typeof n != "object") throw new Error("can't serialize object of type " + typeof n);
          const r = Bl(n);
          if (!r) throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`);
          if (!Ea[r]) throw new Error(`${r} is not registered.`);
          const {
            klass: a
          } = Ea[r], c = a.serialize ? a.serialize(n, t) : {};
          if (a.serialize) {
            if (t && c === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const p in n) {
              if (!n.hasOwnProperty(p) || Ea[r].omit.indexOf(p) >= 0) continue;
              const f = n[p];
              c[p] = Ea[r].shallow.indexOf(p) >= 0 ? f : so(f, t)
            }
            n instanceof Error && (c.message = n.message)
          }
          if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (c.$name = r), c
        }

        function Fs(n) {
          if (iu(n)) return n;
          if (Array.isArray(n)) return n.map(Fs);
          if (typeof n != "object") throw new Error("can't deserialize object of type " + typeof n);
          const t = Bl(n) || "Object";
          if (!Ea[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: r
          } = Ea[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(n);
          const a = Object.create(r.prototype);
          for (const c of Object.keys(n)) {
            if (c === "$name") continue;
            const p = n[c];
            a[c] = Ea[t].shallow.indexOf(c) >= 0 ? p : Fs(p)
          }
          return a
        }
        class Fl {
          constructor() {
            this.first = !0
          }
          update(t, r) {
            const a = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = a, !0))
          }
        }
        const un = {
          "Latin-1 Supplement": n => n >= 128 && n <= 255,
          "Hangul Jamo": n => n >= 4352 && n <= 4607,
          Khmer: n => n >= 6016 && n <= 6143,
          "General Punctuation": n => n >= 8192 && n <= 8303,
          "Letterlike Symbols": n => n >= 8448 && n <= 8527,
          "Number Forms": n => n >= 8528 && n <= 8591,
          "Miscellaneous Technical": n => n >= 8960 && n <= 9215,
          "Control Pictures": n => n >= 9216 && n <= 9279,
          "Optical Character Recognition": n => n >= 9280 && n <= 9311,
          "Enclosed Alphanumerics": n => n >= 9312 && n <= 9471,
          "Geometric Shapes": n => n >= 9632 && n <= 9727,
          "Miscellaneous Symbols": n => n >= 9728 && n <= 9983,
          "Miscellaneous Symbols and Arrows": n => n >= 11008 && n <= 11263,
          "Ideographic Description Characters": n => n >= 12272 && n <= 12287,
          "CJK Symbols and Punctuation": n => n >= 12288 && n <= 12351,
          Hiragana: n => n >= 12352 && n <= 12447,
          Katakana: n => n >= 12448 && n <= 12543,
          Kanbun: n => n >= 12688 && n <= 12703,
          "CJK Strokes": n => n >= 12736 && n <= 12783,
          "Enclosed CJK Letters and Months": n => n >= 12800 && n <= 13055,
          "CJK Compatibility": n => n >= 13056 && n <= 13311,
          "Yijing Hexagram Symbols": n => n >= 19904 && n <= 19967,
          "CJK Unified Ideographs": n => n >= 19968 && n <= 40959,
          "Hangul Syllables": n => n >= 44032 && n <= 55215,
          "Private Use Area": n => n >= 57344 && n <= 63743,
          "Vertical Forms": n => n >= 65040 && n <= 65055,
          "CJK Compatibility Forms": n => n >= 65072 && n <= 65103,
          "Small Form Variants": n => n >= 65104 && n <= 65135,
          "Halfwidth and Fullwidth Forms": n => n >= 65280 && n <= 65519
        };

        function Ol(n) {
          for (const t of n)
            if (su(t.charCodeAt(0))) return !0;
          return !1
        }

        function jp(n) {
          for (const t of n)
            if (!fd(t.charCodeAt(0))) return !1;
          return !0
        }

        function Nl(n) {
          const t = n.map((r => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source
            } catch {
              return null
            }
          })).filter((r => r));
          return new RegExp(t.join("|"), "u")
        }
        const Vp = Nl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function fd(n) {
          return !Vp.test(String.fromCodePoint(n))
        }
        const au = Nl(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function su(n) {
          return !(n !== 746 && n !== 747 && (n < 4352 || !(un["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || un["CJK Compatibility"](n) || un["CJK Strokes"](n) || !(!un["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || un["Enclosed CJK Letters and Months"](n) || un["Ideographic Description Characters"](n) || un.Kanbun(n) || un.Katakana(n) && n !== 12540 || !(!un["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!un["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || un["Vertical Forms"](n) || un["Yijing Hexagram Symbols"](n) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(n)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(n)) || au.test(String.fromCodePoint(n)))))
        }

        function md(n) {
          return !(su(n) || (function(t) {
            return !!(un["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || un["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || un["Letterlike Symbols"](t) || un["Number Forms"](t) || un["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || un["Control Pictures"](t) && t !== 9251 || un["Optical Character Recognition"](t) || un["Enclosed Alphanumerics"](t) || un["Geometric Shapes"](t) || un["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || un["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || un["CJK Symbols and Punctuation"](t) || un.Katakana(t) || un["Private Use Area"](t) || un["CJK Compatibility Forms"](t) || un["Small Form Variants"](t) || un["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(n))
        }
        const _d = Nl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function ou(n) {
          return _d.test(String.fromCodePoint(n))
        }

        function gd(n, t) {
          return !(!t && ou(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || un.Khmer(n))
        }

        function vd(n) {
          for (const t of n)
            if (ou(t.charCodeAt(0))) return !0;
          return !1
        }
        const za = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(n) {
            this.pluginStatus = n.pluginStatus, this.pluginURL = n.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(n) {
            if (za.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = n.applyArabicShaping, this.processBidirectionalText = n.processBidirectionalText, this.processStyledBidirectionalText = n.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(n, t) {
            return o(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (n.pluginStatus !== "loading") return this.setState(n), n;
              const r = n.pluginURL,
                a = new Promise((p => {
                  this.loadScriptResolve = p
                }));
              t(r);
              const c = new Promise((p => setTimeout((() => p()), this.TIMEOUT)));
              if (yield Promise.race([a, c]), this.isParsed()) {
                const p = {
                  pluginStatus: "loaded",
                  pluginURL: r
                };
                return this.setState(p), p
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            }))
          }
        };
        class $n {
          constructor(t, r) {
            this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new Fl, this.transition = r.transition || {}, this.globalState = r.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Fl, this.transition = {}, this.globalState = {})
          }
          isSupportedScript(t) {
            return (function(r, a) {
              for (const c of r)
                if (!gd(c.charCodeAt(0), a)) return !1;
              return !0
            })(t, za.getRTLTextPluginStatus() === "loaded")
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              r = t - Math.floor(t),
              a = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: r + (1 - r) * a
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - a) * r
            }
          }
        }
        class oo {
          constructor(t, r) {
            this.property = t, this.value = r, this.expression = (function(a, c) {
              if (No(a)) return new qo(a, c);
              if (kl(a)) {
                const p = rd(a, c);
                if (p.result === "error") throw new Error(p.value.map((f => `${f.key}: ${f.message}`)).join(", "));
                return p.value
              } {
                let p = a;
                return c.type === "color" && typeof a == "string" ? p = sr.parse(a) : c.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? c.type !== "numberArray" || typeof a != "number" && !Array.isArray(a) ? c.type !== "colorArray" || typeof a != "string" && !Array.isArray(a) ? c.type === "variableAnchorOffsetCollection" && Array.isArray(a) ? p = Vn.parse(a) : c.type === "projectionDefinition" && typeof a == "string" && (p = pi.parse(a)) : p = jn.parse(a) : p = On.parse(a) : p = mn.parse(a), {
                  globalStateRefs: new Set,
                  kind: "constant",
                  evaluate: () => p
                }
              }
            })(r === void 0 ? t.specification.default : r, t.specification)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, r, a) {
            return this.property.possiblyEvaluate(this, t, r, a)
          }
        }
        class lu {
          constructor(t) {
            this.property = t, this.value = new oo(t, void 0)
          }
          transitioned(t, r) {
            return new cu(this.property, this.value, r, dt({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new cu(this.property, this.value, null, {}, 0)
          }
        }
        class yd {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues)
          }
          getValue(t) {
            return xt(this._values[t].value.value)
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new lu(this._values[t].property)), this._values[t].value = new oo(this._values[t].property, r === null ? void 0 : xt(r))
          }
          getTransition(t) {
            return xt(this._values[t].transition)
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new lu(this._values[t].property)), this._values[t].transition = xt(r) || void 0
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const a = this.getValue(r);
              a !== void 0 && (t[r] = a);
              const c = this.getTransition(r);
              c !== void 0 && (t[`${r}-transition`] = c)
            }
            return t
          }
          transitioned(t, r) {
            const a = new uu(this._properties);
            for (const c of Object.keys(this._values)) a._values[c] = this._values[c].transitioned(t, r._values[c]);
            return a
          }
          untransitioned() {
            const t = new uu(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t
          }
        }
        class cu {
          constructor(t, r, a, c, p) {
            this.property = t, this.value = r, this.begin = p + c.delay || 0, this.end = this.begin + c.duration || 0, t.specification.transition && (c.delay || c.duration) && (this.prior = a)
          }
          possiblyEvaluate(t, r, a) {
            const c = t.now || 0,
              p = this.value.possiblyEvaluate(t, r, a),
              f = this.prior;
            if (f) {
              if (c > this.end) return this.prior = null, p;
              if (this.value.isDataDriven()) return this.prior = null, p;
              if (c < this.begin) return f.possiblyEvaluate(t, r, a);
              {
                const v = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(f.possiblyEvaluate(t, r, a), p, We(v))
              }
            }
            return p
          }
        }
        class uu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, r, a) {
            const c = new jl(this._properties);
            for (const p of Object.keys(this._values)) c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
            return c
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class xd {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues)
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return xt(this._values[t].value)
          }
          setValue(t, r) {
            this._values[t] = new oo(this._values[t].property, r === null ? void 0 : xt(r))
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const a = this.getValue(r);
              a !== void 0 && (t[r] = a)
            }
            return t
          }
          possiblyEvaluate(t, r, a) {
            const c = new jl(this._properties);
            for (const p of Object.keys(this._values)) c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
            return c
          }
        }
        class $a {
          constructor(t, r, a) {
            this.property = t, this.value = r, this.parameters = a
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, r, a, c) {
            return this.property.evaluate(this.value, this.parameters, t, r, a, c)
          }
        }
        class jl {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class vr {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r)
          }
          interpolate(t, r, a) {
            const c = Za[this.specification.type];
            return c ? c(t, r, a) : t
          }
        }
        class Or {
          constructor(t, r) {
            this.specification = t, this.overrides = r
          }
          possiblyEvaluate(t, r, a, c) {
            return new $a(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(r, null, {}, a, c)
            } : t.expression, r)
          }
          interpolate(t, r, a) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new $a(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const c = Za[this.specification.type];
            if (c) {
              const p = c(t.value.value, r.value.value, a);
              return new $a(this, {
                kind: "constant",
                value: p
              }, t.parameters)
            }
            return t
          }
          evaluate(t, r, a, c, p, f) {
            return t.kind === "constant" ? t.value : t.evaluate(r, a, c, p, f)
          }
        }
        class Vl extends Or {
          possiblyEvaluate(t, r, a, c) {
            if (t.value === void 0) return new $a(this, {
              kind: "constant",
              value: void 0
            }, r);
            if (t.expression.kind === "constant") {
              const p = t.expression.evaluate(r, null, {}, a, c),
                f = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p,
                v = this._calculate(f, f, f, r);
              return new $a(this, {
                kind: "constant",
                value: v
              }, r)
            }
            if (t.expression.kind === "camera") {
              const p = this._calculate(t.expression.evaluate({
                zoom: r.zoom - 1
              }), t.expression.evaluate({
                zoom: r.zoom
              }), t.expression.evaluate({
                zoom: r.zoom + 1
              }), r);
              return new $a(this, {
                kind: "constant",
                value: p
              }, r)
            }
            return new $a(this, t.expression, r)
          }
          evaluate(t, r, a, c, p, f) {
            if (t.kind === "source") {
              const v = t.evaluate(r, a, c, p, f);
              return this._calculate(v, v, v, r)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(r.zoom) - 1
            }, a, c), t.evaluate({
              zoom: Math.floor(r.zoom)
            }, a, c), t.evaluate({
              zoom: Math.floor(r.zoom) + 1
            }, a, c), r) : t.value
          }
          _calculate(t, r, a, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: a,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class ms {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, a, c) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const p = t.expression.evaluate(r, null, {}, a, c);
                return this._calculate(p, p, p, r)
              }
              return this._calculate(t.expression.evaluate(new $n(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new $n(Math.floor(r.zoom), r)), t.expression.evaluate(new $n(Math.floor(r.zoom + 1), r)), r)
            }
          }
          _calculate(t, r, a, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: a,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class ql {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, a, c) {
            return !!t.expression.evaluate(r, null, {}, a, c)
          }
          interpolate() {
            return !1
          }
        }
        class $i {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const a = t[r];
              a.specification.overridable && this.overridableProperties.push(r);
              const c = this.defaultPropertyValues[r] = new oo(a, void 0),
                p = this.defaultTransitionablePropertyValues[r] = new lu(a);
              this.defaultTransitioningPropertyValues[r] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = c.possiblyEvaluate({})
            }
          }
        }
        Qt("DataDrivenProperty", Or), Qt("DataConstantProperty", vr), Qt("CrossFadedDataDrivenProperty", Vl), Qt("CrossFadedProperty", ms), Qt("ColorRampProperty", ql);
        const bd = "-transition";
        class xa extends kt {
          constructor(t, r) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Ds(t.filter)), r.layout && (this._unevaluatedLayout = new xd(r.layout)), r.paint)) {
              this._transitionablePaint = new yd(r.paint);
              for (const a in t.paint) this.setPaintProperty(a, t.paint[a], {
                validate: !1
              });
              for (const a in t.layout) this.setLayoutProperty(a, t.layout[a], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new jl(r.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Ds(t)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const r in this._unevaluatedLayout._values) {
                const a = this._unevaluatedLayout._values[r];
                for (const c of a.getGlobalStateRefs()) t.add(c)
              }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t
          }
          setLayoutProperty(t, r, a = {}) {
            r != null && this._validate(Np, `layers.${this.id}.layout.${t}`, t, r, a) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
          }
          getPaintProperty(t) {
            return t.endsWith(bd) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, r, a = {}) {
            if (r != null && this._validate(Op, `layers.${this.id}.paint.${t}`, t, r, a)) return !1;
            if (t.endsWith(bd)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
            {
              const c = this._transitionablePaint._values[t],
                p = c.property.specification["property-type"] === "cross-faded-data-driven",
                f = c.value.isDataDriven(),
                v = c.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const x = this._transitionablePaint._values[t].value;
              return x.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(t, v, x)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, r, a) {
            return !1
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Tt(t, ((r, a) => !(r === void 0 || a === "layout" && !Object.keys(r).length || a === "paint" && !Object.keys(r).length)))
          }
          _validate(t, r, a, c, p = {}) {
            return (!p || p.validate !== !1) && Ho(this, t.call(ao, {
              key: r,
              layerType: this.type,
              objectKey: a,
              value: c,
              styleSpec: xe,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof $a && ps(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0
            }
            return !1
          }
        }
        const qp = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class Xo {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class zn {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function ei(n, t = 1) {
          let r = 0,
            a = 0;
          return {
            members: n.map((c => {
              const p = qp[c.type].BYTES_PER_ELEMENT,
                f = r = Zl(r, Math.max(t, p)),
                v = c.components || 1;
              return a = Math.max(a, p), r += p * v, {
                name: c.name,
                type: c.type,
                components: v,
                offset: f
              }
            })),
            size: Zl(r, Math.max(a, t)),
            alignment: t
          }
        }

        function Zl(n, t) {
          return Math.ceil(n / t) * t
        }
        class lo extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.int16[c + 0] = r, this.int16[c + 1] = a, t
          }
        }
        lo.prototype.bytesPerElement = 4, Qt("StructArrayLayout2i4", lo);
        class co extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.int16[p + 0] = r, this.int16[p + 1] = a, this.int16[p + 2] = c, t
          }
        }
        co.prototype.bytesPerElement = 6, Qt("StructArrayLayout3i6", co);
        class hu extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, a, c)
          }
          emplace(t, r, a, c, p) {
            const f = 4 * t;
            return this.int16[f + 0] = r, this.int16[f + 1] = a, this.int16[f + 2] = c, this.int16[f + 3] = p, t
          }
        }
        hu.prototype.bytesPerElement = 8, Qt("StructArrayLayout4i8", hu);
        class uo extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, v) {
            const x = 6 * t;
            return this.int16[x + 0] = r, this.int16[x + 1] = a, this.int16[x + 2] = c, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = v, t
          }
        }
        uo.prototype.bytesPerElement = 12, Qt("StructArrayLayout2i4i12", uo);
        class Os extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, v) {
            const x = 4 * t,
              C = 8 * t;
            return this.int16[x + 0] = r, this.int16[x + 1] = a, this.uint8[C + 4] = c, this.uint8[C + 5] = p, this.uint8[C + 6] = f, this.uint8[C + 7] = v, t
          }
        }
        Os.prototype.bytesPerElement = 8, Qt("StructArrayLayout2i4ub8", Os);
        class Yo extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.float32[c + 0] = r, this.float32[c + 1] = a, t
          }
        }
        Yo.prototype.bytesPerElement = 8, Qt("StructArrayLayout2f8", Yo);
        class Ul extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, v, x, C, I) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, t, r, a, c, p, f, v, x, C, I)
          }
          emplace(t, r, a, c, p, f, v, x, C, I, L) {
            const F = 10 * t;
            return this.uint16[F + 0] = r, this.uint16[F + 1] = a, this.uint16[F + 2] = c, this.uint16[F + 3] = p, this.uint16[F + 4] = f, this.uint16[F + 5] = v, this.uint16[F + 6] = x, this.uint16[F + 7] = C, this.uint16[F + 8] = I, this.uint16[F + 9] = L, t
          }
        }
        Ul.prototype.bytesPerElement = 20, Qt("StructArrayLayout10ui20", Ul);
        class Ns extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, v, x, C, I, L, F) {
            const V = this.length;
            return this.resize(V + 1), this.emplace(V, t, r, a, c, p, f, v, x, C, I, L, F)
          }
          emplace(t, r, a, c, p, f, v, x, C, I, L, F, V) {
            const q = 12 * t;
            return this.int16[q + 0] = r, this.int16[q + 1] = a, this.int16[q + 2] = c, this.int16[q + 3] = p, this.uint16[q + 4] = f, this.uint16[q + 5] = v, this.uint16[q + 6] = x, this.uint16[q + 7] = C, this.int16[q + 8] = I, this.int16[q + 9] = L, this.int16[q + 10] = F, this.int16[q + 11] = V, t
          }
        }
        Ns.prototype.bytesPerElement = 24, Qt("StructArrayLayout4i4ui4i24", Ns);
        class du extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.float32[p + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = c, t
          }
        }
        du.prototype.bytesPerElement = 12, Qt("StructArrayLayout3f12", du);
        class pu extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t
          }
        }
        pu.prototype.bytesPerElement = 4, Qt("StructArrayLayout1ul4", pu);
        class $l extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, v, x, C) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, r, a, c, p, f, v, x, C)
          }
          emplace(t, r, a, c, p, f, v, x, C, I) {
            const L = 10 * t,
              F = 5 * t;
            return this.int16[L + 0] = r, this.int16[L + 1] = a, this.int16[L + 2] = c, this.int16[L + 3] = p, this.int16[L + 4] = f, this.int16[L + 5] = v, this.uint32[F + 3] = x, this.uint16[L + 8] = C, this.uint16[L + 9] = I, t
          }
        }
        $l.prototype.bytesPerElement = 20, Qt("StructArrayLayout6i1ul2ui20", $l);
        class fu extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, v) {
            const x = 6 * t;
            return this.int16[x + 0] = r, this.int16[x + 1] = a, this.int16[x + 2] = c, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = v, t
          }
        }
        fu.prototype.bytesPerElement = 12, Qt("StructArrayLayout2i2i2i12", fu);
        class h extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, a, c, p)
          }
          emplace(t, r, a, c, p, f) {
            const v = 4 * t,
              x = 8 * t;
            return this.float32[v + 0] = r, this.float32[v + 1] = a, this.float32[v + 2] = c, this.int16[x + 6] = p, this.int16[x + 7] = f, t
          }
        }
        h.prototype.bytesPerElement = 16, Qt("StructArrayLayout2f1f2i16", h);
        class e extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, f)
          }
          emplace(t, r, a, c, p, f, v) {
            const x = 16 * t,
              C = 4 * t,
              I = 8 * t;
            return this.uint8[x + 0] = r, this.uint8[x + 1] = a, this.float32[C + 1] = c, this.float32[C + 2] = p, this.int16[I + 6] = f, this.int16[I + 7] = v, t
          }
        }
        e.prototype.bytesPerElement = 16, Qt("StructArrayLayout2ub2f2i16", e);
        class i extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.uint16[p + 0] = r, this.uint16[p + 1] = a, this.uint16[p + 2] = c, t
          }
        }
        i.prototype.bytesPerElement = 6, Qt("StructArrayLayout3ui6", i);
        class l extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, v, x, C, I, L, F, V, q, G, J, oe) {
            const De = this.length;
            return this.resize(De + 1), this.emplace(De, t, r, a, c, p, f, v, x, C, I, L, F, V, q, G, J, oe)
          }
          emplace(t, r, a, c, p, f, v, x, C, I, L, F, V, q, G, J, oe, De) {
            const ve = 24 * t,
              Se = 12 * t,
              He = 48 * t;
            return this.int16[ve + 0] = r, this.int16[ve + 1] = a, this.uint16[ve + 2] = c, this.uint16[ve + 3] = p, this.uint32[Se + 2] = f, this.uint32[Se + 3] = v, this.uint32[Se + 4] = x, this.uint16[ve + 10] = C, this.uint16[ve + 11] = I, this.uint16[ve + 12] = L, this.float32[Se + 7] = F, this.float32[Se + 8] = V, this.uint8[He + 36] = q, this.uint8[He + 37] = G, this.uint8[He + 38] = J, this.uint32[Se + 10] = oe, this.int16[ve + 22] = De, t
          }
        }
        l.prototype.bytesPerElement = 48, Qt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", l);
        class u extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, f, v, x, C, I, L, F, V, q, G, J, oe, De, ve, Se, He, at, Pt, $t, Bt, Zt, Tr, qt) {
            const Ut = this.length;
            return this.resize(Ut + 1), this.emplace(Ut, t, r, a, c, p, f, v, x, C, I, L, F, V, q, G, J, oe, De, ve, Se, He, at, Pt, $t, Bt, Zt, Tr, qt)
          }
          emplace(t, r, a, c, p, f, v, x, C, I, L, F, V, q, G, J, oe, De, ve, Se, He, at, Pt, $t, Bt, Zt, Tr, qt, Ut) {
            const mt = 32 * t,
              Nr = 16 * t;
            return this.int16[mt + 0] = r, this.int16[mt + 1] = a, this.int16[mt + 2] = c, this.int16[mt + 3] = p, this.int16[mt + 4] = f, this.int16[mt + 5] = v, this.int16[mt + 6] = x, this.int16[mt + 7] = C, this.uint16[mt + 8] = I, this.uint16[mt + 9] = L, this.uint16[mt + 10] = F, this.uint16[mt + 11] = V, this.uint16[mt + 12] = q, this.uint16[mt + 13] = G, this.uint16[mt + 14] = J, this.uint16[mt + 15] = oe, this.uint16[mt + 16] = De, this.uint16[mt + 17] = ve, this.uint16[mt + 18] = Se, this.uint16[mt + 19] = He, this.uint16[mt + 20] = at, this.uint16[mt + 21] = Pt, this.uint16[mt + 22] = $t, this.uint32[Nr + 12] = Bt, this.float32[Nr + 13] = Zt, this.float32[Nr + 14] = Tr, this.uint16[mt + 30] = qt, this.uint16[mt + 31] = Ut, t
          }
        }
        u.prototype.bytesPerElement = 64, Qt("StructArrayLayout8i15ui1ul2f2ui64", u);
        class d extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t
          }
        }
        d.prototype.bytesPerElement = 4, Qt("StructArrayLayout1f4", d);
        class g extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = c, t
          }
        }
        g.prototype.bytesPerElement = 12, Qt("StructArrayLayout1ui2f12", g);
        class b extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[p + 2] = a, this.uint16[p + 3] = c, t
          }
        }
        b.prototype.bytesPerElement = 8, Qt("StructArrayLayout1ul2ui8", b);
        class S extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.uint16[c + 0] = r, this.uint16[c + 1] = a, t
          }
        }
        S.prototype.bytesPerElement = 4, Qt("StructArrayLayout2ui4", S);
        class P extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t
          }
        }
        P.prototype.bytesPerElement = 2, Qt("StructArrayLayout1ui2", P);
        class A extends zn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, a, c)
          }
          emplace(t, r, a, c, p) {
            const f = 4 * t;
            return this.float32[f + 0] = r, this.float32[f + 1] = a, this.float32[f + 2] = c, this.float32[f + 3] = p, t
          }
        }
        A.prototype.bytesPerElement = 16, Qt("StructArrayLayout4f16", A);
        class R extends Xo {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new B(this.anchorPointX, this.anchorPointY)
          }
        }
        R.prototype.size = 20;
        class D extends $l {
          get(t) {
            return new R(this, t)
          }
        }
        Qt("CollisionBoxArray", D);
        class O extends Xo {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        O.prototype.size = 48;
        class $ extends l {
          get(t) {
            return new O(this, t)
          }
        }
        Qt("PlacedSymbolArray", $);
        class te extends Xo {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        te.prototype.size = 64;
        class ee extends u {
          get(t) {
            return new te(this, t)
          }
        }
        Qt("SymbolInstanceArray", ee);
        class ne extends d {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        Qt("GlyphOffsetArray", ne);
        class le extends co {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        Qt("SymbolLineVertexArray", le);
        class fe extends Xo {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        fe.prototype.size = 12;
        class de extends g {
          get(t) {
            return new fe(this, t)
          }
        }
        Qt("TextAnchorOffsetArray", de);
        class be extends Xo {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        be.prototype.size = 8;
        class Ce extends b {
          get(t) {
            return new be(this, t)
          }
        }
        Qt("FeatureIndexArray", Ce);
        class pe extends lo {}
        class Be extends lo {}
        class et extends lo {}
        class Ze extends uo {}
        class Ge extends Os {}
        class Ke extends Yo {}
        class Rt extends Ul {}
        class Ft extends Ns {}
        class St extends du {}
        class pr extends pu {}
        class Jr extends fu {}
        class wn extends e {}
        class Ln extends i {}
        class Mn extends S {}
        const Gn = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Kn
          } = Gn;
        class Kr {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, r, a, c) {
            const p = this.segments[this.segments.length - 1];
            return t > Kr.MAX_VERTEX_ARRAY_LENGTH && At(`Max vertices per segment is ${Kr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Kr.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > Kr.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== c ? this.createNewSegment(r, a, c) : p
          }
          createNewSegment(t, r, a) {
            const c = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return a !== void 0 && (c.sortKey = a), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(c), c
          }
          getOrCreateLatestSegment(t, r, a) {
            return this.prepareSegment(0, t, r, a)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const r in t.vaos) t.vaos[r].destroy()
          }
          static simpleSegment(t, r, a, c) {
            return new Kr([{
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: a,
              primitiveLength: c,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function Dn(n, t) {
          return 256 * (n = Dt(Math.floor(n), 0, 255)) + Dt(Math.floor(t), 0, 255)
        }
        Kr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Qt("SegmentVector", Kr);
        const si = ei([{
          name: "a_pattern_from",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pattern_to",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_from",
          components: 1,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_to",
          components: 1,
          type: "Uint16"
        }]);
        var fi, bi, Gi, La = {
            exports: {}
          },
          _s = {
            exports: {}
          },
          gs = {
            exports: {}
          },
          ho = (function() {
            if (Gi) return La.exports;
            Gi = 1;
            var n = (fi || (fi = 1, _s.exports = function(r, a) {
                var c, p, f, v, x, C, I, L;
                for (p = r.length - (c = 3 & r.length), f = a, x = 3432918353, C = 461845907, L = 0; L < p;) I = 255 & r.charCodeAt(L) | (255 & r.charCodeAt(++L)) << 8 | (255 & r.charCodeAt(++L)) << 16 | (255 & r.charCodeAt(++L)) << 24, ++L, f = 27492 + (65535 & (v = 5 * (65535 & (f = (f ^= I = (65535 & (I = (I = (65535 & I) * x + (((I >>> 16) * x & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * C + (((I >>> 16) * C & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
                switch (I = 0, c) {
                  case 3:
                    I ^= (255 & r.charCodeAt(L + 2)) << 16;
                  case 2:
                    I ^= (255 & r.charCodeAt(L + 1)) << 8;
                  case 1:
                    f ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & r.charCodeAt(L))) * x + (((I >>> 16) * x & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * C + (((I >>> 16) * C & 65535) << 16) & 4294967295
                }
                return f ^= r.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0
              }), _s.exports),
              t = (bi || (bi = 1, gs.exports = function(r, a) {
                for (var c, p = r.length, f = a ^ p, v = 0; p >= 4;) c = 1540483477 * (65535 & (c = 255 & r.charCodeAt(v) | (255 & r.charCodeAt(++v)) << 8 | (255 & r.charCodeAt(++v)) << 16 | (255 & r.charCodeAt(++v)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), p -= 4, ++v;
                switch (p) {
                  case 3:
                    f ^= (255 & r.charCodeAt(v + 2)) << 16;
                  case 2:
                    f ^= (255 & r.charCodeAt(v + 1)) << 8;
                  case 1:
                    f = 1540483477 * (65535 & (f ^= 255 & r.charCodeAt(v))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                }
                return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0
              }), gs.exports);
            return La.exports = n, La.exports.murmur3 = n, La.exports.murmur2 = t, La.exports
          })(),
          po = N(ho);
        class js {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, r, a, c) {
            this.ids.push(Vs(t)), this.positions.push(r, a, c)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = Vs(t);
            let a = 0,
              c = this.ids.length - 1;
            for (; a < c;) {
              const f = a + c >> 1;
              this.ids[f] >= r ? c = f : a = f + 1
            }
            const p = [];
            for (; this.ids[a] === r;) p.push({
              index: this.positions[3 * a],
              start: this.positions[3 * a + 1],
              end: this.positions[3 * a + 2]
            }), a++;
            return p
          }
          static serialize(t, r) {
            const a = new Float64Array(t.ids),
              c = new Uint32Array(t.positions);
            return ra(a, c, 0, a.length - 1), r && r.push(a.buffer, c.buffer), {
              ids: a,
              positions: c
            }
          }
          static deserialize(t) {
            const r = new js;
            return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r
          }
        }

        function Vs(n) {
          const t = +n;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : po(String(n))
        }

        function ra(n, t, r, a) {
          for (; r < a;) {
            const c = n[r + a >> 1];
            let p = r - 1,
              f = a + 1;
            for (;;) {
              do p++; while (n[p] < c);
              do f--; while (n[f] > c);
              if (p >= f) break;
              Da(n, p, f), Da(t, 3 * p, 3 * f), Da(t, 3 * p + 1, 3 * f + 1), Da(t, 3 * p + 2, 3 * f + 2)
            }
            f - r < a - f ? (ra(n, t, r, f), r = f + 1) : (ra(n, t, f + 1, a), a = f)
          }
        }

        function Da(n, t, r) {
          const a = n[t];
          n[t] = n[r], n[r] = a
        }
        Qt("FeaturePositionMap", js);
        class Hi {
          constructor(t, r) {
            this.gl = t.gl, this.location = r
          }
        }
        class vs extends Hi {
          constructor(t, r) {
            super(t, r), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class oi extends Hi {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class mi extends Hi {
          constructor(t, r) {
            super(t, r), this.current = sr.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const ba = new Float32Array(16);

        function li(n) {
          return [Dn(255 * n.r, 255 * n.g), Dn(255 * n.b, 255 * n.a)]
        }
        class Ko {
          constructor(t, r, a) {
            this.value = t, this.uniformNames = r.map((c => `u_${c}`)), this.type = a
          }
          setUniform(t, r, a) {
            t.set(a.constantOr(this.value))
          }
          getBinding(t, r, a) {
            return this.type === "color" ? new mi(t, r) : new vs(t, r)
          }
        }
        class fo {
          constructor(t, r) {
            this.uniformNames = r.map((a => `u_${a}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr
          }
          setUniform(t, r, a, c) {
            const p = c === "u_pattern_to" ? this.patternTo : c === "u_pattern_from" ? this.patternFrom : c === "u_pixel_ratio_to" ? this.pixelRatioTo : c === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            p && t.set(p)
          }
          getBinding(t, r, a) {
            return a.substr(0, 9) === "u_pattern" ? new oi(t, r) : new vs(t, r)
          }
        }
        class es {
          constructor(t, r, a, c) {
            this.expression = t, this.type = a, this.maxValue = 0, this.paintVertexAttributes = r.map((p => ({
              name: `a_${p}`,
              type: "Float32",
              components: a === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new c
          }
          populatePaintArray(t, r, a, c, p) {
            const f = this.paintVertexArray.length,
              v = this.expression.evaluate(new $n(0), r, {}, c, [], p);
            this.paintVertexArray.resize(t), this._setPaintValue(f, t, v)
          }
          updatePaintArray(t, r, a, c) {
            const p = this.expression.evaluate({
              zoom: 0
            }, a, c);
            this._setPaintValue(t, r, p)
          }
          _setPaintValue(t, r, a) {
            if (this.type === "color") {
              const c = li(a);
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, c[0], c[1])
            } else {
              for (let c = t; c < r; c++) this.paintVertexArray.emplace(c, a);
              this.maxValue = Math.max(this.maxValue, Math.abs(a))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Ra {
          constructor(t, r, a, c, p, f) {
            this.expression = t, this.uniformNames = r.map((v => `u_${v}_t`)), this.type = a, this.useIntegerZoom = c, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = r.map((v => ({
              name: `a_${v}`,
              type: "Float32",
              components: a === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new f
          }
          populatePaintArray(t, r, a, c, p) {
            const f = this.expression.evaluate(new $n(this.zoom), r, {}, c, [], p),
              v = this.expression.evaluate(new $n(this.zoom + 1), r, {}, c, [], p),
              x = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(x, t, f, v)
          }
          updatePaintArray(t, r, a, c) {
            const p = this.expression.evaluate({
                zoom: this.zoom
              }, a, c),
              f = this.expression.evaluate({
                zoom: this.zoom + 1
              }, a, c);
            this._setPaintValue(t, r, p, f)
          }
          _setPaintValue(t, r, a, c) {
            if (this.type === "color") {
              const p = li(a),
                f = li(c);
              for (let v = t; v < r; v++) this.paintVertexArray.emplace(v, p[0], p[1], f[0], f[1])
            } else {
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, a, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(c))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, r) {
            const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
              c = Dt(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
            t.set(c)
          }
          getBinding(t, r, a) {
            return new vs(t, r)
          }
        }
        class ys {
          constructor(t, r, a, c, p, f) {
            this.expression = t, this.type = r, this.useIntegerZoom = a, this.zoom = c, this.layerId = f, this.zoomInPaintVertexArray = new p, this.zoomOutPaintVertexArray = new p
          }
          populatePaintArray(t, r, a) {
            const c = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(c, t, r.patterns && r.patterns[this.layerId], a)
          }
          updatePaintArray(t, r, a, c, p) {
            this._setPaintValues(t, r, a.patterns && a.patterns[this.layerId], p)
          }
          _setPaintValues(t, r, a, c) {
            if (!c || !a) return;
            const {
              min: p,
              mid: f,
              max: v
            } = a, x = c[p], C = c[f], I = c[v];
            if (x && C && I)
              for (let L = t; L < r; L++) this.zoomInPaintVertexArray.emplace(L, C.tl[0], C.tl[1], C.br[0], C.br[1], x.tl[0], x.tl[1], x.br[0], x.br[1], C.pixelRatio, x.pixelRatio), this.zoomOutPaintVertexArray.emplace(L, C.tl[0], C.tl[1], C.br[0], C.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], C.pixelRatio, I.pixelRatio)
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, si.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, si.members, this.expression.isStateDependent))
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class wd {
          constructor(t, r, a) {
            this.binders = {}, this._buffers = [];
            const c = [];
            for (const p in t.paint._values) {
              if (!a(p)) continue;
              const f = t.paint.get(p);
              if (!(f instanceof $a && ps(f.property.specification))) continue;
              const v = Td(p, t.type),
                x = f.value,
                C = f.property.specification.type,
                I = f.property.useIntegerZoom,
                L = f.property.specification["property-type"],
                F = L === "cross-faded" || L === "cross-faded-data-driven";
              if (x.kind === "constant") this.binders[p] = F ? new fo(x.value, v) : new Ko(x.value, v, C), c.push(`/u_${p}`);
              else if (x.kind === "source" || F) {
                const V = mu(p, C, "source");
                this.binders[p] = F ? new ys(x, C, I, r, V, t.id) : new es(x, v, C, V), c.push(`/a_${p}`)
              } else {
                const V = mu(p, C, "composite");
                this.binders[p] = new Ra(x, v, C, I, r, V), c.push(`/z_${p}`)
              }
            }
            this.cacheKey = c.sort().join("")
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof es || r instanceof Ra ? r.maxValue : 0
          }
          populatePaintArrays(t, r, a, c, p) {
            for (const f in this.binders) {
              const v = this.binders[f];
              (v instanceof es || v instanceof Ra || v instanceof ys) && v.populatePaintArray(t, r, a, c, p)
            }
          }
          setConstantPatternPositions(t, r) {
            for (const a in this.binders) {
              const c = this.binders[a];
              c instanceof fo && c.setConstantPatternPositions(t, r)
            }
          }
          updatePaintArrays(t, r, a, c, p) {
            let f = !1;
            for (const v in t) {
              const x = r.getPositions(v);
              for (const C of x) {
                const I = a.feature(C.index);
                for (const L in this.binders) {
                  const F = this.binders[L];
                  if ((F instanceof es || F instanceof Ra || F instanceof ys) && F.expression.isStateDependent === !0) {
                    const V = c.paint.get(L);
                    F.expression = V.value, F.updatePaintArray(C.start, C.end, I, t[v], p), f = !0
                  }
                }
              }
            }
            return f
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              (a instanceof Ko || a instanceof fo) && t.push(...a.uniformNames.map((c => `#define HAS_UNIFORM_${c}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (a instanceof es || a instanceof Ra)
                for (let c = 0; c < a.paintVertexAttributes.length; c++) t.push(a.paintVertexAttributes[c].name);
              else if (a instanceof ys)
                for (let c = 0; c < si.members.length; c++) t.push(si.members[c].name)
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (a instanceof Ko || a instanceof fo || a instanceof Ra)
                for (const c of a.uniformNames) t.push(c)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, r) {
            const a = [];
            for (const c in this.binders) {
              const p = this.binders[c];
              if (p instanceof Ko || p instanceof fo || p instanceof Ra) {
                for (const f of p.uniformNames)
                  if (r[f]) {
                    const v = p.getBinding(t, r[f], f);
                    a.push({
                      name: f,
                      property: c,
                      binding: v
                    })
                  }
              }
            }
            return a
          }
          setUniforms(t, r, a, c) {
            for (const {
                name: p,
                property: f,
                binding: v
              }
              of r) this.binders[f].setUniform(v, c, a.get(f), p)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (t && a instanceof ys) {
                const c = t.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
                c && this._buffers.push(c)
              } else(a instanceof es || a instanceof Ra) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const a = this.binders[r];
              (a instanceof es || a instanceof Ra || a instanceof ys) && a.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof es || r instanceof Ra || r instanceof ys) && r.destroy()
            }
          }
        }
        class ca {
          constructor(t, r, a = () => !0) {
            this.programConfigurations = {};
            for (const c of t) this.programConfigurations[c.id] = new wd(c, r, a);
            this.needsUpload = !1, this._featureMap = new js, this._bufferOffset = 0
          }
          populatePaintArrays(t, r, a, c, p, f) {
            for (const v in this.programConfigurations) this.programConfigurations[v].populatePaintArrays(t, r, c, p, f);
            r.id !== void 0 && this._featureMap.add(r.id, a, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, r, a, c) {
            for (const p of a) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, r, p, c) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function Td(n, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function mu(n, t, r) {
          const a = {
              color: {
                source: Yo,
                composite: A
              },
              number: {
                source: d,
                composite: Yo
              }
            },
            c = (function(p) {
              return {
                "line-pattern": {
                  source: Rt,
                  composite: Rt
                },
                "fill-pattern": {
                  source: Rt,
                  composite: Rt
                },
                "fill-extrusion-pattern": {
                  source: Rt,
                  composite: Rt
                }
              } [p]
            })(n);
          return c && c[r] || a[t][r]
        }
        Qt("ConstantBinder", Ko), Qt("CrossFadedConstantBinder", fo), Qt("SourceExpressionBinder", es), Qt("CrossFadedCompositeBinder", ys), Qt("CompositeExpressionBinder", Ra), Qt("ProgramConfiguration", wd, {
          omit: ["_buffers"]
        }), Qt("ProgramConfigurationSet", ca);
        const Gl = Math.pow(2, 14) - 1,
          Hl = -Gl - 1;

        function xs(n) {
          const t = ae / n.extent,
            r = n.loadGeometry();
          for (let a = 0; a < r.length; a++) {
            const c = r[a];
            for (let p = 0; p < c.length; p++) {
              const f = c[p],
                v = Math.round(f.x * t),
                x = Math.round(f.y * t);
              f.x = Dt(v, Hl, Gl), f.y = Dt(x, Hl, Gl), (v < f.x || v > f.x + 1 || x < f.y || x > f.y + 1) && At("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return r
        }

        function ts(n, t) {
          return {
            type: n.type,
            id: n.id,
            properties: n.properties,
            geometry: t ? xs(n) : []
          }
        }
        const s_ = -32768;

        function G0(n, t, r, a, c) {
          n.emplaceBack(s_ + 8 * t + a, s_ + 8 * r + c)
        }
        class Zp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Be, this.indexArray = new Ln, this.segments = new Kr, this.programConfigurations = new ca(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            const c = this.layers[0],
              p = [];
            let f = null,
              v = !1,
              x = c.type === "heatmap";
            if (c.type === "circle") {
              const I = c;
              f = I.layout.get("circle-sort-key"), v = !f.isConstant(), x = x || I.paint.get("circle-pitch-alignment") === "map"
            }
            const C = x ? r.subdivisionGranularity.circle : 1;
            for (const {
                feature: I,
                id: L,
                index: F,
                sourceLayerIndex: V
              }
              of t) {
              const q = this.layers[0]._featureFilter.needGeometry,
                G = ts(I, q);
              if (!this.layers[0]._featureFilter.filter(new $n(this.zoom, {
                  globalState: this.globalState
                }), G, a)) continue;
              const J = v ? f.evaluate(G, {}, a) : void 0,
                oe = {
                  id: L,
                  properties: I.properties,
                  type: I.type,
                  sourceLayerIndex: V,
                  index: F,
                  geometry: q ? G.geometry : xs(I),
                  patterns: {},
                  sortKey: J
                };
              p.push(oe)
            }
            v && p.sort(((I, L) => I.sortKey - L.sortKey));
            for (const I of p) {
              const {
                geometry: L,
                index: F,
                sourceLayerIndex: V
              } = I, q = t[F].feature;
              this.addFeature(I, L, F, a, C), r.featureIndex.insert(q, L, F, V, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Kn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, r, a, c, p = 1) {
            let f;
            switch (p) {
              case 1:
                f = [0, 7];
                break;
              case 3:
                f = [0, 2, 5, 7];
                break;
              case 5:
                f = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                f = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`)
            }
            const v = f.length;
            for (const x of r)
              for (const C of x) {
                const I = C.x,
                  L = C.y;
                if (I < 0 || I >= ae || L < 0 || L >= ae) continue;
                const F = this.segments.prepareSegment(v * v, this.layoutVertexArray, this.indexArray, t.sortKey),
                  V = F.vertexLength;
                for (let q = 0; q < v; q++)
                  for (let G = 0; G < v; G++) G0(this.layoutVertexArray, I, L, f[G], f[q]);
                for (let q = 0; q < v - 1; q++)
                  for (let G = 0; G < v - 1; G++) {
                    const J = V + q * v + G,
                      oe = V + (q + 1) * v + G;
                    this.indexArray.emplaceBack(J, oe + 1, J + 1), this.indexArray.emplaceBack(J, oe, oe + 1)
                  }
                F.vertexLength += v * v, F.primitiveLength += (v - 1) * (v - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {}, c)
          }
        }

        function o_(n, t) {
          for (let r = 0; r < n.length; r++)
            if (Wl(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (Wl(n, t[r])) return !0;
          return !!Up(n, t)
        }

        function H0(n, t, r) {
          return !!Wl(n, t) || !!$p(t, n, r)
        }

        function l_(n, t) {
          if (n.length === 1) return u_(t, n[0]);
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            for (let c = 0; c < a.length; c++)
              if (Wl(n, a[c])) return !0
          }
          for (let r = 0; r < n.length; r++)
            if (u_(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (Up(n, t[r])) return !0;
          return !1
        }

        function W0(n, t, r) {
          if (n.length > 1) {
            if (Up(n, t)) return !0;
            for (let a = 0; a < t.length; a++)
              if ($p(t[a], n, r)) return !0
          }
          for (let a = 0; a < n.length; a++)
            if ($p(n[a], t, r)) return !0;
          return !1
        }

        function Up(n, t) {
          if (n.length === 0 || t.length === 0) return !1;
          for (let r = 0; r < n.length - 1; r++) {
            const a = n[r],
              c = n[r + 1];
            for (let p = 0; p < t.length - 1; p++)
              if (X0(a, c, t[p], t[p + 1])) return !0
          }
          return !1
        }

        function X0(n, t, r, a) {
          return Wt(n, r, a) !== Wt(t, r, a) && Wt(n, t, r) !== Wt(n, t, a)
        }

        function $p(n, t, r) {
          const a = r * r;
          if (t.length === 1) return n.distSqr(t[0]) < a;
          for (let c = 1; c < t.length; c++)
            if (c_(n, t[c - 1], t[c]) < a) return !0;
          return !1
        }

        function c_(n, t, r) {
          const a = t.distSqr(r);
          if (a === 0) return n.distSqr(t);
          const c = ((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / a;
          return n.distSqr(c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t))
        }

        function u_(n, t) {
          let r, a, c, p = !1;
          for (let f = 0; f < n.length; f++) {
            r = n[f];
            for (let v = 0, x = r.length - 1; v < r.length; x = v++) a = r[v], c = r[x], a.y > t.y != c.y > t.y && t.x < (c.x - a.x) * (t.y - a.y) / (c.y - a.y) + a.x && (p = !p)
          }
          return p
        }

        function Wl(n, t) {
          let r = !1;
          for (let a = 0, c = n.length - 1; a < n.length; c = a++) {
            const p = n[a],
              f = n[c];
            p.y > t.y != f.y > t.y && t.x < (f.x - p.x) * (t.y - p.y) / (f.y - p.y) + p.x && (r = !r)
          }
          return r
        }

        function Y0(n, t, r) {
          const a = r[0],
            c = r[2];
          if (n.x < a.x && t.x < a.x || n.x > c.x && t.x > c.x || n.y < a.y && t.y < a.y || n.y > c.y && t.y > c.y) return !1;
          const p = Wt(n, t, r[0]);
          return p !== Wt(n, t, r[1]) || p !== Wt(n, t, r[2]) || p !== Wt(n, t, r[3])
        }

        function _u(n, t, r) {
          const a = t.paint.get(n).value;
          return a.kind === "constant" ? a.value : r.programConfigurations.get(t.id).getMaxValue(n)
        }

        function Sd(n) {
          return Math.sqrt(n[0] * n[0] + n[1] * n[1])
        }

        function Cd(n, t, r, a, c) {
          if (!t[0] && !t[1]) return n;
          const p = B.convert(t)._mult(c);
          r === "viewport" && p._rotate(-a);
          const f = [];
          for (let v = 0; v < n.length; v++) f.push(n[v].sub(p));
          return f
        }
        let h_, d_;
        Qt("CircleBucket", Zp, {
          omit: ["layers"]
        });
        var K0 = {
          get paint() {
            return d_ = d_ || new $i({
              "circle-radius": new Or(xe.paint_circle["circle-radius"]),
              "circle-color": new Or(xe.paint_circle["circle-color"]),
              "circle-blur": new Or(xe.paint_circle["circle-blur"]),
              "circle-opacity": new Or(xe.paint_circle["circle-opacity"]),
              "circle-translate": new vr(xe.paint_circle["circle-translate"]),
              "circle-translate-anchor": new vr(xe.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new vr(xe.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new vr(xe.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new Or(xe.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new Or(xe.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new Or(xe.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return h_ = h_ || new $i({
              "circle-sort-key": new Or(xe.layout_circle["circle-sort-key"])
            })
          }
        };
        class J0 extends xa {
          constructor(t) {
            super(t, K0)
          }
          createBucket(t) {
            return new Zp(t)
          }
          queryRadius(t) {
            const r = t;
            return _u("circle-radius", this, r) + _u("circle-stroke-width", this, r) + Sd(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: f,
            unwrappedTileID: v,
            getElevation: x
          }) {
            const C = Cd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f),
              I = this.paint.get("circle-radius").evaluate(r, a) + this.paint.get("circle-stroke-width").evaluate(r, a),
              L = this.paint.get("circle-pitch-alignment") === "map",
              F = L ? C : (function(q, G, J, oe) {
                return q.map((De => p_(De, G, J, oe)))
              })(C, p, v, x),
              V = L ? I * f : I;
            for (const q of c)
              for (const G of q) {
                const J = L ? G : p_(G, p, v, x);
                let oe = V;
                const De = p.projectTileCoordinates(G.x, G.y, v, x).signedDistanceFromCamera;
                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? oe *= De / p.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (oe *= p.cameraToCenterDistance / De), H0(F, J, oe)) return !0
              }
            return !1
          }
        }

        function p_(n, t, r, a) {
          const c = t.projectTileCoordinates(n.x, n.y, r, a).point;
          return new B((.5 * c.x + .5) * t.width, (.5 * -c.y + .5) * t.height)
        }
        class f_ extends Zp {}
        let m_;
        Qt("HeatmapBucket", f_, {
          omit: ["layers"]
        });
        var Q0 = {
          get paint() {
            return m_ = m_ || new $i({
              "heatmap-radius": new Or(xe.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new Or(xe.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new vr(xe.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new ql(xe.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new vr(xe.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function Gp(n, {
          width: t,
          height: r
        }, a, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== t * r * a) throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t*r*a}`)
          } else c = new Uint8Array(t * r * a);
          return n.width = t, n.height = r, n.data = c, n
        }

        function __(n, {
          width: t,
          height: r
        }, a) {
          if (t === n.width && r === n.height) return;
          const c = Gp({}, {
            width: t,
            height: r
          }, a);
          Hp(n, c, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(n.width, t),
            height: Math.min(n.height, r)
          }, a), n.width = t, n.height = r, n.data = c.data
        }

        function Hp(n, t, r, a, c, p) {
          if (c.width === 0 || c.height === 0) return t;
          if (c.width > n.width || c.height > n.height || r.x > n.width - c.width || r.y > n.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > t.width || c.height > t.height || a.x > t.width - c.width || a.y > t.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const f = n.data,
            v = t.data;
          if (f === v) throw new Error("srcData equals dstData, so image is already copied");
          for (let x = 0; x < c.height; x++) {
            const C = ((r.y + x) * n.width + r.x) * p,
              I = ((a.y + x) * t.width + a.x) * p;
            for (let L = 0; L < c.width * p; L++) v[I + L] = f[C + L]
          }
          return t
        }
        class gu {
          constructor(t, r) {
            Gp(this, t, 1, r)
          }
          resize(t) {
            __(this, t, 1)
          }
          clone() {
            return new gu({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, a, c, p) {
            Hp(t, r, a, c, p, 1)
          }
        }
        class ua {
          constructor(t, r) {
            Gp(this, t, 4, r)
          }
          resize(t) {
            __(this, t, 4)
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new ua({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, a, c, p) {
            Hp(t, r, a, c, p, 4)
          }
          setPixel(t, r, a) {
            const c = 4 * (t * this.width + r);
            this.data[c + 0] = Math.round(255 * a.r / a.a), this.data[c + 1] = Math.round(255 * a.g / a.a), this.data[c + 2] = Math.round(255 * a.b / a.a), this.data[c + 3] = Math.round(255 * a.a)
          }
        }

        function g_(n) {
          const t = {},
            r = n.resolution || 256,
            a = n.clips ? n.clips.length : 1,
            c = n.image || new ua({
              width: r,
              height: a
            });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const p = (f, v, x) => {
            t[n.evaluationKey] = x;
            const C = n.expression.evaluate(t);
            c.setPixel(f / 4 / r, v / 4, C)
          };
          if (n.clips)
            for (let f = 0, v = 0; f < a; ++f, v += 4 * r)
              for (let x = 0, C = 0; x < r; x++, C += 4) {
                const I = x / (r - 1),
                  {
                    start: L,
                    end: F
                  } = n.clips[f];
                p(v, C, L * (1 - I) + F * I)
              } else
                for (let f = 0, v = 0; f < r; f++, v += 4) p(0, v, f / (r - 1));
          return c
        }
        Qt("AlphaImage", gu), Qt("RGBAImage", ua);
        const Wp = "big-fb";
        class ey extends xa {
          createBucket(t) {
            return new f_(t)
          }
          constructor(t) {
            super(t, Q0), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = g_({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(Wp) && this.heatmapFbos.delete(Wp)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            return !1
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let v_;
        var ty = {
          get paint() {
            return v_ = v_ || new $i({
              "hillshade-illumination-direction": new vr(xe.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new vr(xe.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new vr(xe.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new vr(xe.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new vr(xe.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new vr(xe.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new vr(xe.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new vr(xe.paint_hillshade["hillshade-method"])
            })
          }
        };
        class ry extends xa {
          constructor(t) {
            super(t, ty), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              r = this.paint.get("hillshade-illumination-altitude").values,
              a = this.paint.get("hillshade-highlight-color").values,
              c = this.paint.get("hillshade-shadow-color").values;
            const p = Math.max(t.length, r.length, a.length, c.length);
            t = t.concat(Array(p - t.length).fill(t.at(-1))), r = r.concat(Array(p - r.length).fill(r.at(-1))), a = a.concat(Array(p - a.length).fill(a.at(-1))), c = c.concat(Array(p - c.length).fill(c.at(-1)));
            const f = r.map(xr);
            return {
              directionRadians: t.map(xr),
              altitudeRadians: f,
              shadowColor: c,
              highlightColor: a
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let y_;
        var ny = {
          get paint() {
            return y_ = y_ || new $i({
              "color-relief-opacity": new vr(xe["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new ql(xe["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class Xp {
          constructor(t, r, a, c) {
            this.context = t, this.format = a, this.texture = t.gl.createTexture(), this.update(r, c)
          }
          update(t, r, a) {
            const {
              width: c,
              height: p
            } = t, f = !(this.size && this.size[0] === c && this.size[1] === p || a), {
              context: v
            } = this, {
              gl: x
            } = v;
            if (this.useMipmap = !!(r && r.useMipmap), x.bindTexture(x.TEXTURE_2D, this.texture), v.pixelStoreUnpackFlipY.set(!1), v.pixelStoreUnpack.set(1), v.pixelStoreUnpackPremultiplyAlpha.set(this.format === x.RGBA && (!r || r.premultiply !== !1)), f) this.size = [c, p], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || er(t) ? x.texImage2D(x.TEXTURE_2D, 0, this.format, this.format, x.UNSIGNED_BYTE, t) : x.texImage2D(x.TEXTURE_2D, 0, this.format, c, p, 0, this.format, x.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: C,
                y: I
              } = a || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || er(t) ? x.texSubImage2D(x.TEXTURE_2D, 0, C, I, x.RGBA, x.UNSIGNED_BYTE, t) : x.texSubImage2D(x.TEXTURE_2D, 0, C, I, c, p, x.RGBA, x.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && x.generateMipmap(x.TEXTURE_2D), v.pixelStoreUnpackFlipY.setDefault(), v.pixelStoreUnpack.setDefault(), v.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, r, a) {
            const {
              context: c
            } = this, {
              gl: p
            } = c;
            p.bindTexture(p.TEXTURE_2D, this.texture), a !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = p.LINEAR), t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || t), this.filter = t), r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r), this.wrap = r)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class x_ {
          constructor(t, r, a, c = 1, p = 1, f = 1, v = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void At(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const x = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), a) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = c, this.greenFactor = p, this.blueFactor = f, this.baseShift = v;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let C = 0; C < x; C++) this.data[this._idx(-1, C)] = this.data[this._idx(0, C)], this.data[this._idx(x, C)] = this.data[this._idx(x - 1, C)], this.data[this._idx(C, -1)] = this.data[this._idx(C, 0)], this.data[this._idx(C, x)] = this.data[this._idx(C, x - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(x, -1)] = this.data[this._idx(x - 1, 0)], this.data[this._idx(-1, x)] = this.data[this._idx(0, x - 1)], this.data[this._idx(x, x)] = this.data[this._idx(x - 1, x - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let C = 0; C < x; C++)
              for (let I = 0; I < x; I++) {
                const L = this.get(C, I);
                L > this.max && (this.max = L), L < this.min && (this.min = L)
              }
          }
          get(t, r) {
            const a = new Uint8Array(this.data.buffer),
              c = 4 * this._idx(t, r);
            return this.unpack(a[c], a[c + 1], a[c + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1)
          }
          unpack(t, r, a) {
            return t * this.redFactor + r * this.greenFactor + a * this.blueFactor - this.baseShift
          }
          pack(t) {
            return b_(t, this.getUnpackVector())
          }
          getPixels() {
            return new ua({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, r, a) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let c = r * this.dim,
              p = r * this.dim + this.dim,
              f = a * this.dim,
              v = a * this.dim + this.dim;
            switch (r) {
              case -1:
                c = p - 1;
                break;
              case 1:
                p = c + 1
            }
            switch (a) {
              case -1:
                f = v - 1;
                break;
              case 1:
                v = f + 1
            }
            const x = -r * this.dim,
              C = -a * this.dim;
            for (let I = f; I < v; I++)
              for (let L = c; L < p; L++) this.data[this._idx(L, I)] = t.data[this._idx(L + x, I + C)]
          }
        }

        function b_(n, t) {
          const r = t[0],
            a = t[1],
            c = t[2],
            p = t[3],
            f = Math.min(r, a, c),
            v = Math.round((n + p) / f);
          return {
            r: Math.floor(v * f / r) % 256,
            g: Math.floor(v * f / a) % 256,
            b: Math.floor(v * f / c) % 256
          }
        }
        Qt("DEMData", x_);
        class iy extends xa {
          constructor(t) {
            super(t, ny)
          }
          _createColorRamp(t) {
            const r = {
                elevationStops: [],
                colorStops: []
              },
              a = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (a instanceof Vo && a._styleExpression.expression instanceof Ei) {
              this.colorRampExpression = a;
              const f = a._styleExpression.expression;
              r.elevationStops = f.labels, r.colorStops = [];
              for (const v of r.elevationStops) r.colorStops.push(f.evaluate({
                globals: {
                  elevation: v
                }
              }))
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [sr.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const c = {
                elevationStops: [],
                colorStops: []
              },
              p = (r.elevationStops.length - 1) / (t - 1);
            for (let f = 0; f < r.elevationStops.length - .5; f += p) c.elevationStops.push(r.elevationStops[Math.round(f)]), c.colorStops.push(r.colorStops[Math.round(f)]);
            return At(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), c
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, r, a) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const c = this._createColorRamp(r),
              p = new ua({
                width: c.colorStops.length,
                height: 1
              }),
              f = new ua({
                width: c.colorStops.length,
                height: 1
              });
            for (let v = 0; v < c.elevationStops.length; v++) {
              const x = b_(c.elevationStops[v], a);
              f.setPixel(0, v, new sr(x.r / 255, x.g / 255, x.b / 255, 1)), p.setPixel(0, v, c.colorStops[v])
            }
            return this.colorRampTextures = {
              elevationTexture: new Xp(t, f, t.gl.RGBA),
              colorTexture: new Xp(t, p, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const ay = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: sy
          } = ay;

        function Yp(n, t, r) {
          const a = r.patternDependencies;
          let c = !1;
          for (const p of t) {
            const f = p.paint.get(`${n}-pattern`);
            f.isConstant() || (c = !0);
            const v = f.constantOr(null);
            v && (c = !0, a[v.to] = !0, a[v.from] = !0)
          }
          return c
        }

        function Kp(n, t, r, a, c) {
          const p = c.patternDependencies;
          for (const f of t) {
            const v = f.paint.get(`${n}-pattern`).value;
            if (v.kind !== "constant") {
              let x = v.evaluate({
                  zoom: a - 1
                }, r, {}, c.availableImages),
                C = v.evaluate({
                  zoom: a
                }, r, {}, c.availableImages),
                I = v.evaluate({
                  zoom: a + 1
                }, r, {}, c.availableImages);
              x = x && x.name ? x.name : x, C = C && C.name ? C.name : C, I = I && I.name ? I.name : I, p[x] = !0, p[C] = !0, p[I] = !0, r.patterns[f.id] = {
                min: x,
                mid: C,
                max: I
              }
            }
          }
          return r
        }

        function w_(n, t, r, a, c) {
          let p;
          if (c === (function(f, v, x, C) {
              let I = 0;
              for (let L = v, F = x - C; L < x; L += C) I += (f[F] - f[L]) * (f[L + 1] + f[F + 1]), F = L;
              return I
            })(n, t, r, a) > 0)
            for (let f = t; f < r; f += a) p = P_(f / a | 0, n[f], n[f + 1], p);
          else
            for (let f = r - a; f >= t; f -= a) p = P_(f / a | 0, n[f], n[f + 1], p);
          return p && Xl(p, p.next) && (bu(p), p = p.next), p
        }

        function Jo(n, t) {
          if (!n) return n;
          t || (t = n);
          let r, a = n;
          do
            if (r = !1, a.steiner || !Xl(a, a.next) && ni(a.prev, a, a.next) !== 0) a = a.next;
            else {
              if (bu(a), a = t = a.prev, a === a.next) break;
              r = !0
            } while (r || a !== t);
          return t
        }

        function vu(n, t, r, a, c, p, f) {
          if (!n) return;
          !f && p && (function(x, C, I, L) {
            let F = x;
            do F.z === 0 && (F.z = Jp(F.x, F.y, C, I, L)), F.prevZ = F.prev, F.nextZ = F.next, F = F.next; while (F !== x);
            F.prevZ.nextZ = null, F.prevZ = null, (function(V) {
              let q, G = 1;
              do {
                let J, oe = V;
                V = null;
                let De = null;
                for (q = 0; oe;) {
                  q++;
                  let ve = oe,
                    Se = 0;
                  for (let at = 0; at < G && (Se++, ve = ve.nextZ, ve); at++);
                  let He = G;
                  for (; Se > 0 || He > 0 && ve;) Se !== 0 && (He === 0 || !ve || oe.z <= ve.z) ? (J = oe, oe = oe.nextZ, Se--) : (J = ve, ve = ve.nextZ, He--), De ? De.nextZ = J : V = J, J.prevZ = De, De = J;
                  oe = ve
                }
                De.nextZ = null, G *= 2
              } while (q > 1)
            })(F)
          })(n, a, c, p);
          let v = n;
          for (; n.prev !== n.next;) {
            const x = n.prev,
              C = n.next;
            if (p ? ly(n, a, c, p) : oy(n)) t.push(x.i, n.i, C.i), bu(n), n = C.next, v = C.next;
            else if ((n = C) === v) {
              f ? f === 1 ? vu(n = cy(Jo(n), t), t, r, a, c, p, 2) : f === 2 && uy(n, t, r, a, c, p) : vu(Jo(n), t, r, a, c, p, 1);
              break
            }
          }
        }

        function oy(n) {
          const t = n.prev,
            r = n,
            a = n.next;
          if (ni(t, r, a) >= 0) return !1;
          const c = t.x,
            p = r.x,
            f = a.x,
            v = t.y,
            x = r.y,
            C = a.y,
            I = Math.min(c, p, f),
            L = Math.min(v, x, C),
            F = Math.max(c, p, f),
            V = Math.max(v, x, C);
          let q = a.next;
          for (; q !== t;) {
            if (q.x >= I && q.x <= F && q.y >= L && q.y <= V && yu(c, v, p, x, f, C, q.x, q.y) && ni(q.prev, q, q.next) >= 0) return !1;
            q = q.next
          }
          return !0
        }

        function ly(n, t, r, a) {
          const c = n.prev,
            p = n,
            f = n.next;
          if (ni(c, p, f) >= 0) return !1;
          const v = c.x,
            x = p.x,
            C = f.x,
            I = c.y,
            L = p.y,
            F = f.y,
            V = Math.min(v, x, C),
            q = Math.min(I, L, F),
            G = Math.max(v, x, C),
            J = Math.max(I, L, F),
            oe = Jp(V, q, t, r, a),
            De = Jp(G, J, t, r, a);
          let ve = n.prevZ,
            Se = n.nextZ;
          for (; ve && ve.z >= oe && Se && Se.z <= De;) {
            if (ve.x >= V && ve.x <= G && ve.y >= q && ve.y <= J && ve !== c && ve !== f && yu(v, I, x, L, C, F, ve.x, ve.y) && ni(ve.prev, ve, ve.next) >= 0 || (ve = ve.prevZ, Se.x >= V && Se.x <= G && Se.y >= q && Se.y <= J && Se !== c && Se !== f && yu(v, I, x, L, C, F, Se.x, Se.y) && ni(Se.prev, Se, Se.next) >= 0)) return !1;
            Se = Se.nextZ
          }
          for (; ve && ve.z >= oe;) {
            if (ve.x >= V && ve.x <= G && ve.y >= q && ve.y <= J && ve !== c && ve !== f && yu(v, I, x, L, C, F, ve.x, ve.y) && ni(ve.prev, ve, ve.next) >= 0) return !1;
            ve = ve.prevZ
          }
          for (; Se && Se.z <= De;) {
            if (Se.x >= V && Se.x <= G && Se.y >= q && Se.y <= J && Se !== c && Se !== f && yu(v, I, x, L, C, F, Se.x, Se.y) && ni(Se.prev, Se, Se.next) >= 0) return !1;
            Se = Se.nextZ
          }
          return !0
        }

        function cy(n, t) {
          let r = n;
          do {
            const a = r.prev,
              c = r.next.next;
            !Xl(a, c) && S_(a, r, r.next, c) && xu(a, c) && xu(c, a) && (t.push(a.i, r.i, c.i), bu(r), bu(r.next), r = n = c), r = r.next
          } while (r !== n);
          return Jo(r)
        }

        function uy(n, t, r, a, c, p) {
          let f = n;
          do {
            let v = f.next.next;
            for (; v !== f.prev;) {
              if (f.i !== v.i && my(f, v)) {
                let x = C_(f, v);
                return f = Jo(f, f.next), x = Jo(x, x.next), vu(f, t, r, a, c, p, 0), void vu(x, t, r, a, c, p, 0)
              }
              v = v.next
            }
            f = f.next
          } while (f !== n)
        }

        function hy(n, t) {
          let r = n.x - t.x;
          return r === 0 && (r = n.y - t.y, r === 0) && (r = (n.next.y - n.y) / (n.next.x - n.x) - (t.next.y - t.y) / (t.next.x - t.x)), r
        }

        function dy(n, t) {
          const r = (function(c, p) {
            let f = p;
            const v = c.x,
              x = c.y;
            let C, I = -1 / 0;
            if (Xl(c, f)) return f;
            do {
              if (Xl(c, f.next)) return f.next;
              if (x <= f.y && x >= f.next.y && f.next.y !== f.y) {
                const G = f.x + (x - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                if (G <= v && G > I && (I = G, C = f.x < f.next.x ? f : f.next, G === v)) return C
              }
              f = f.next
            } while (f !== p);
            if (!C) return null;
            const L = C,
              F = C.x,
              V = C.y;
            let q = 1 / 0;
            f = C;
            do {
              if (v >= f.x && f.x >= F && v !== f.x && T_(x < V ? v : I, x, F, V, x < V ? I : v, x, f.x, f.y)) {
                const G = Math.abs(x - f.y) / (v - f.x);
                xu(f, c) && (G < q || G === q && (f.x > C.x || f.x === C.x && py(C, f))) && (C = f, q = G)
              }
              f = f.next
            } while (f !== L);
            return C
          })(n, t);
          if (!r) return t;
          const a = C_(r, n);
          return Jo(a, a.next), Jo(r, r.next)
        }

        function py(n, t) {
          return ni(n.prev, n, t.prev) < 0 && ni(t.next, n, n.next) < 0
        }

        function Jp(n, t, r, a, c) {
          return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - r) * c | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - a) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function fy(n) {
          let t = n,
            r = n;
          do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== n);
          return r
        }

        function T_(n, t, r, a, c, p, f, v) {
          return (c - f) * (t - v) >= (n - f) * (p - v) && (n - f) * (a - v) >= (r - f) * (t - v) && (r - f) * (p - v) >= (c - f) * (a - v)
        }

        function yu(n, t, r, a, c, p, f, v) {
          return !(n === f && t === v) && T_(n, t, r, a, c, p, f, v)
        }

        function my(n, t) {
          return n.next.i !== t.i && n.prev.i !== t.i && !(function(r, a) {
            let c = r;
            do {
              if (c.i !== r.i && c.next.i !== r.i && c.i !== a.i && c.next.i !== a.i && S_(c, c.next, r, a)) return !0;
              c = c.next
            } while (c !== r);
            return !1
          })(n, t) && (xu(n, t) && xu(t, n) && (function(r, a) {
            let c = r,
              p = !1;
            const f = (r.x + a.x) / 2,
              v = (r.y + a.y) / 2;
            do c.y > v != c.next.y > v && c.next.y !== c.y && f < (c.next.x - c.x) * (v - c.y) / (c.next.y - c.y) + c.x && (p = !p), c = c.next; while (c !== r);
            return p
          })(n, t) && (ni(n.prev, n, t.prev) || ni(n, t.prev, t)) || Xl(n, t) && ni(n.prev, n, n.next) > 0 && ni(t.prev, t, t.next) > 0)
        }

        function ni(n, t, r) {
          return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y)
        }

        function Xl(n, t) {
          return n.x === t.x && n.y === t.y
        }

        function S_(n, t, r, a) {
          const c = Id(ni(n, t, r)),
            p = Id(ni(n, t, a)),
            f = Id(ni(r, a, n)),
            v = Id(ni(r, a, t));
          return c !== p && f !== v || !(c !== 0 || !Pd(n, r, t)) || !(p !== 0 || !Pd(n, a, t)) || !(f !== 0 || !Pd(r, n, a)) || !(v !== 0 || !Pd(r, t, a))
        }

        function Pd(n, t, r) {
          return t.x <= Math.max(n.x, r.x) && t.x >= Math.min(n.x, r.x) && t.y <= Math.max(n.y, r.y) && t.y >= Math.min(n.y, r.y)
        }

        function Id(n) {
          return n > 0 ? 1 : n < 0 ? -1 : 0
        }

        function xu(n, t) {
          return ni(n.prev, n, n.next) < 0 ? ni(n, t, n.next) >= 0 && ni(n, n.prev, t) >= 0 : ni(n, t, n.prev) < 0 || ni(n, n.next, t) < 0
        }

        function C_(n, t) {
          const r = Qp(n.i, n.x, n.y),
            a = Qp(t.i, t.x, t.y),
            c = n.next,
            p = t.prev;
          return n.next = t, t.prev = n, r.next = c, c.prev = r, a.next = r, r.prev = a, p.next = a, a.prev = p, a
        }

        function P_(n, t, r, a) {
          const c = Qp(n, t, r);
          return a ? (c.next = a.next, c.prev = a, a.next.prev = c, a.next = c) : (c.prev = c, c.next = c), c
        }

        function bu(n) {
          n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
        }

        function Qp(n, t, r) {
          return {
            i: n,
            x: t,
            y: r,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class Yl {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class Md {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        Md.noSubdivision = new Md({
          fill: new Yl(0, 0),
          line: new Yl(0, 0),
          tile: new Yl(0, 0),
          stencil: new Yl(0, 0),
          circle: 1
        }), Qt("SubdivisionGranularityExpression", Yl), Qt("SubdivisionGranularitySetting", Md);
        const Kl = -32768,
          wu = 32767;
        class _y {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = ae / t, this._canonical = r
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const a = 0 | Math.round(t),
              c = 0 | Math.round(r),
              p = this._getKey(a, c);
            if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p);
            const f = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(p, f), this._vertexBuffer.push(a, c), f
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(c, p) {
              const f = [];
              for (let v = 0; v < p.length; v += 3) {
                const x = p[v],
                  C = p[v + 1],
                  I = p[v + 2],
                  L = c[2 * x],
                  F = c[2 * x + 1];
                (c[2 * C] - L) * (c[2 * I + 1] - F) - (c[2 * C + 1] - F) * (c[2 * I] - L) > 0 ? (f.push(x), f.push(I), f.push(C)) : (f.push(x), f.push(C), f.push(I))
              }
              return f
            })(this._vertexBuffer, t);
            const r = [],
              a = t.length;
            for (let c = 0; c < a; c += 3) {
              const p = [t[c + 0], t[c + 1], t[c + 2]],
                f = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
              let v = 1 / 0,
                x = 1 / 0,
                C = -1 / 0,
                I = -1 / 0;
              for (let G = 0; G < 3; G++) {
                const J = f[2 * G],
                  oe = f[2 * G + 1];
                v = Math.min(v, J), C = Math.max(C, J), x = Math.min(x, oe), I = Math.max(I, oe)
              }
              if (v === C || x === I) continue;
              const L = Math.floor(v / this._granularityCellSize),
                F = Math.ceil(C / this._granularityCellSize),
                V = Math.floor(x / this._granularityCellSize),
                q = Math.ceil(I / this._granularityCellSize);
              if (L !== F || V !== q)
                for (let G = V; G < q; G++) {
                  const J = this._scanlineGenerateVertexRingForCellRow(G, f, p);
                  gy(this._vertexBuffer, J, r)
                } else r.push(...p)
            }
            return r
          }
          _scanlineGenerateVertexRingForCellRow(t, r, a) {
            const c = t * this._granularityCellSize,
              p = c + this._granularityCellSize,
              f = [];
            for (let v = 0; v < 3; v++) {
              const x = r[2 * v],
                C = r[2 * v + 1],
                I = r[2 * (v + 1) % 6],
                L = r[(2 * (v + 1) + 1) % 6],
                F = r[2 * (v + 2) % 6],
                V = r[(2 * (v + 2) + 1) % 6],
                q = I - x,
                G = L - C,
                J = q === 0,
                oe = G === 0,
                De = (c - C) / G,
                ve = (p - C) / G,
                Se = Math.min(De, ve),
                He = Math.max(De, ve);
              if (!oe && (Se >= 1 || He <= 0) || oe && (C < c || C > p)) {
                L >= c && L <= p && f.push(a[(v + 1) % 3]);
                continue
              }!oe && Se > 0 && f.push(this._vertexToIndex(x + q * Se, C + G * Se));
              const at = x + q * Math.max(Se, 0),
                Pt = x + q * Math.min(He, 1);
              J || this._generateIntraEdgeVertices(f, x, C, I, L, at, Pt), !oe && He < 1 && f.push(this._vertexToIndex(x + q * He, C + G * He)), (oe || L >= c && L <= p) && f.push(a[(v + 1) % 3]), !oe && (L <= c || L >= p) && this._generateInterEdgeVertices(f, x, C, I, L, F, V, Pt, c, p)
            }
            return f
          }
          _generateIntraEdgeVertices(t, r, a, c, p, f, v) {
            const x = c - r,
              C = p - a,
              I = C === 0,
              L = I ? Math.min(r, c) : Math.min(f, v),
              F = I ? Math.max(r, c) : Math.max(f, v),
              V = Math.floor(L / this._granularityCellSize) + 1,
              q = Math.ceil(F / this._granularityCellSize) - 1;
            if (I ? r < c : f < v)
              for (let G = V; G <= q; G++) {
                const J = G * this._granularityCellSize;
                t.push(this._vertexToIndex(J, a + C * (J - r) / x))
              } else
                for (let G = q; G >= V; G--) {
                  const J = G * this._granularityCellSize;
                  t.push(this._vertexToIndex(J, a + C * (J - r) / x))
                }
          }
          _generateInterEdgeVertices(t, r, a, c, p, f, v, x, C, I) {
            const L = p - a,
              F = f - c,
              V = v - p,
              q = (C - p) / V,
              G = (I - p) / V,
              J = Math.min(q, G),
              oe = Math.max(q, G),
              De = c + F * J;
            let ve = Math.floor(Math.min(De, x) / this._granularityCellSize) + 1,
              Se = Math.ceil(Math.max(De, x) / this._granularityCellSize) - 1,
              He = x < De;
            const at = V === 0;
            if (at && (v === C || v === I)) return;
            if (at || J >= 1 || oe <= 0) {
              const $t = a - v,
                Bt = f + (r - f) * Math.min((C - v) / $t, (I - v) / $t);
              ve = Math.floor(Math.min(Bt, x) / this._granularityCellSize) + 1, Se = Math.ceil(Math.max(Bt, x) / this._granularityCellSize) - 1, He = x < Bt
            }
            const Pt = L > 0 ? I : C;
            if (He)
              for (let $t = ve; $t <= Se; $t++) t.push(this._vertexToIndex($t * this._granularityCellSize, Pt));
            else
              for (let $t = Se; $t >= ve; $t--) t.push(this._vertexToIndex($t * this._granularityCellSize, Pt))
          }
          _generateOutline(t) {
            const r = [];
            for (const a of t) {
              const c = Qo(a, this._granularity, !0),
                p = this._pointArrayToIndices(c),
                f = [];
              for (let v = 1; v < p.length; v++) f.push(p[v - 1]), f.push(p[v]);
              r.push(f)
            }
            return r
          }
          _handlePoles(t) {
            let r = !1,
              a = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)), (r || a) && this._fillPoles(t, r, a)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const a = t[r + 1];
              a === Kl && (t[r + 1] = -32767), a === wu && (t[r + 1] = 32766)
            }
          }
          _generatePoleQuad(t, r, a, c, p, f) {
            c > p != (f === Kl) ? (t.push(r), t.push(a), t.push(this._vertexToIndex(c, f)), t.push(a), t.push(this._vertexToIndex(p, f)), t.push(this._vertexToIndex(c, f))) : (t.push(a), t.push(r), t.push(this._vertexToIndex(c, f)), t.push(this._vertexToIndex(p, f)), t.push(a), t.push(this._vertexToIndex(c, f)))
          }
          _fillPoles(t, r, a) {
            const c = this._vertexBuffer,
              p = ae,
              f = t.length;
            for (let v = 2; v < f; v += 3) {
              const x = t[v - 2],
                C = t[v - 1],
                I = t[v],
                L = c[2 * x],
                F = c[2 * x + 1],
                V = c[2 * C],
                q = c[2 * C + 1],
                G = c[2 * I],
                J = c[2 * I + 1];
              r && (F === 0 && q === 0 && this._generatePoleQuad(t, x, C, L, V, Kl), q === 0 && J === 0 && this._generatePoleQuad(t, C, I, V, G, Kl), J === 0 && F === 0 && this._generatePoleQuad(t, I, x, G, L, Kl)), a && (F === p && q === p && this._generatePoleQuad(t, x, C, L, V, wu), q === p && J === p && this._generatePoleQuad(t, C, I, V, G, wu), J === p && F === p && this._generatePoleQuad(t, I, x, G, L, wu))
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1])
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: a,
              holeIndices: c
            } = (function(v) {
              const x = [],
                C = [];
              for (const I of v)
                if (I.length !== 0) {
                  I !== v[0] && x.push(C.length / 2);
                  for (let L = 0; L < I.length; L++) C.push(I[L].x), C.push(I[L].y)
                } return {
                flattened: C,
                holeIndices: x
              }
            })(t);
            let p;
            this._initializeVertices(a);
            try {
              const v = (function(C, I, L = 2) {
                  const F = I && I.length,
                    V = F ? I[0] * L : C.length;
                  let q = w_(C, 0, V, L, !0);
                  const G = [];
                  if (!q || q.next === q.prev) return G;
                  let J, oe, De;
                  if (F && (q = (function(ve, Se, He, at) {
                      const Pt = [];
                      for (let $t = 0, Bt = Se.length; $t < Bt; $t++) {
                        const Zt = w_(ve, Se[$t] * at, $t < Bt - 1 ? Se[$t + 1] * at : ve.length, at, !1);
                        Zt === Zt.next && (Zt.steiner = !0), Pt.push(fy(Zt))
                      }
                      Pt.sort(hy);
                      for (let $t = 0; $t < Pt.length; $t++) He = dy(Pt[$t], He);
                      return He
                    })(C, I, q, L)), C.length > 80 * L) {
                    J = C[0], oe = C[1];
                    let ve = J,
                      Se = oe;
                    for (let He = L; He < V; He += L) {
                      const at = C[He],
                        Pt = C[He + 1];
                      at < J && (J = at), Pt < oe && (oe = Pt), at > ve && (ve = at), Pt > Se && (Se = Pt)
                    }
                    De = Math.max(ve - J, Se - oe), De = De !== 0 ? 32767 / De : 0
                  }
                  return vu(q, G, L, J, oe, De, 0), G
                })(a, c),
                x = this._convertIndices(a, v);
              p = this._subdivideTrianglesScanline(x)
            } catch (v) {
              console.error(v)
            }
            let f = [];
            return r && (f = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(p), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: p,
              indicesLineList: f
            }
          }
          _convertIndices(t, r) {
            const a = [];
            for (let c = 0; c < r.length; c++) a.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
            return a
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let a = 0; a < t.length; a++) {
              const c = t[a];
              r.push(this._vertexToIndex(c.x, c.y))
            }
            return r
          }
        }

        function I_(n, t, r, a = !0) {
          return new _y(r, t).subdividePolygonInternal(n, a)
        }

        function Qo(n, t, r = !1) {
          if (!n || n.length < 1) return [];
          if (n.length < 2) return [];
          const a = n[0],
            c = n[n.length - 1],
            p = r && (a.x !== c.x || a.y !== c.y);
          if (t < 2) return p ? [...n, n[0]] : [...n];
          const f = Math.floor(ae / t),
            v = [];
          v.push(new B(n[0].x, n[0].y));
          const x = n.length,
            C = p ? x : x - 1;
          for (let I = 0; I < C; I++) {
            const L = n[I],
              F = I < x - 1 ? n[I + 1] : n[0],
              V = L.x,
              q = L.y,
              G = F.x,
              J = F.y,
              oe = V !== G,
              De = q !== J;
            if (!oe && !De) continue;
            const ve = G - V,
              Se = J - q,
              He = Math.abs(ve),
              at = Math.abs(Se);
            let Pt = V,
              $t = q;
            for (;;) {
              const Zt = ve > 0 ? (Math.floor(Pt / f) + 1) * f : (Math.ceil(Pt / f) - 1) * f,
                Tr = Se > 0 ? (Math.floor($t / f) + 1) * f : (Math.ceil($t / f) - 1) * f,
                qt = Math.abs(Pt - Zt),
                Ut = Math.abs($t - Tr),
                mt = Math.abs(Pt - G),
                Nr = Math.abs($t - J),
                Ur = oe ? qt / He : Number.POSITIVE_INFINITY,
                Pr = De ? Ut / at : Number.POSITIVE_INFINITY;
              if ((mt <= qt || !oe) && (Nr <= Ut || !De)) break;
              if (Ur < Pr && oe || !De) {
                Pt = Zt, $t += Se * Ur;
                const fr = new B(Pt, Math.round($t));
                v[v.length - 1].x === fr.x && v[v.length - 1].y === fr.y || v.push(fr)
              } else {
                Pt += ve * Pr, $t = Tr;
                const fr = new B(Math.round(Pt), $t);
                v[v.length - 1].x === fr.x && v[v.length - 1].y === fr.y || v.push(fr)
              }
            }
            const Bt = new B(G, J);
            v[v.length - 1].x === Bt.x && v[v.length - 1].y === Bt.y || v.push(Bt)
          }
          return v
        }

        function gy(n, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let a = 0,
            c = n[2 * t[0]];
          for (let x = 1; x < t.length; x++) {
            const C = n[2 * t[x]];
            C < c && (c = C, a = x)
          }
          const p = t.length;
          let f = a,
            v = (f + 1) % p;
          for (;;) {
            const x = f - 1 >= 0 ? f - 1 : p - 1,
              C = (v + 1) % p,
              I = n[2 * t[x]],
              L = n[2 * t[C]],
              F = n[2 * t[f]],
              V = n[2 * t[f] + 1],
              q = n[2 * t[v] + 1];
            let G = !1;
            if (I < L) G = !0;
            else if (I > L) G = !1;
            else {
              const J = q - V,
                oe = -(n[2 * t[v]] - F),
                De = V < q ? 1 : -1;
              ((I - F) * J + (n[2 * t[x] + 1] - V) * oe) * De > ((L - F) * J + (n[2 * t[C] + 1] - V) * oe) * De && (G = !0)
            }
            if (G) {
              const J = t[x],
                oe = t[f],
                De = t[v];
              J !== oe && J !== De && oe !== De && r.push(De, oe, J), f--, f < 0 && (f = p - 1)
            } else {
              const J = t[C],
                oe = t[f],
                De = t[v];
              J !== oe && J !== De && oe !== De && r.push(De, oe, J), v++, v >= p && (v = 0)
            }
            if (x === C) break
          }
        }

        function M_(n, t, r, a, c, p, f, v, x) {
          const C = c.length / 2,
            I = f && v && x;
          if (C < Kr.MAX_VERTEX_ARRAY_LENGTH) {
            const L = t.prepareSegment(C, r, a),
              F = L.vertexLength;
            for (let G = 0; G < p.length; G += 3) a.emplaceBack(F + p[G], F + p[G + 1], F + p[G + 2]);
            let V, q;
            L.vertexLength += C, L.primitiveLength += p.length / 3, I && (q = f.prepareSegment(C, r, v), V = q.vertexLength, q.vertexLength += C);
            for (let G = 0; G < c.length; G += 2) n(c[G], c[G + 1]);
            if (I)
              for (let G = 0; G < x.length; G++) {
                const J = x[G];
                for (let oe = 1; oe < J.length; oe += 2) v.emplaceBack(V + J[oe - 1], V + J[oe]);
                q.primitiveLength += J.length / 2
              }
          } else(function(L, F, V, q, G, J) {
            const oe = [];
            for (let at = 0; at < q.length / 2; at++) oe.push(-1);
            const De = {
              count: 0
            };
            let ve = 0,
              Se = L.getOrCreateLatestSegment(F, V),
              He = Se.vertexLength;
            for (let at = 2; at < G.length; at += 3) {
              const Pt = G[at - 2],
                $t = G[at - 1],
                Bt = G[at];
              let Zt = oe[Pt] < ve,
                Tr = oe[$t] < ve,
                qt = oe[Bt] < ve;
              Se.vertexLength + ((Zt ? 1 : 0) + (Tr ? 1 : 0) + (qt ? 1 : 0)) > Kr.MAX_VERTEX_ARRAY_LENGTH && (Se = L.createNewSegment(F, V), ve = De.count, Zt = !0, Tr = !0, qt = !0, He = 0);
              const Ut = Tu(oe, q, J, De, Pt, Zt, Se),
                mt = Tu(oe, q, J, De, $t, Tr, Se),
                Nr = Tu(oe, q, J, De, Bt, qt, Se);
              V.emplaceBack(He + Ut - ve, He + mt - ve, He + Nr - ve), Se.primitiveLength++
            }
          })(t, r, a, c, p, n), I && (function(L, F, V, q, G, J) {
            const oe = [];
            for (let at = 0; at < q.length / 2; at++) oe.push(-1);
            const De = {
              count: 0
            };
            let ve = 0,
              Se = L.getOrCreateLatestSegment(F, V),
              He = Se.vertexLength;
            for (let at = 0; at < G.length; at++) {
              const Pt = G[at];
              for (let $t = 1; $t < G[at].length; $t += 2) {
                const Bt = Pt[$t - 1],
                  Zt = Pt[$t];
                let Tr = oe[Bt] < ve,
                  qt = oe[Zt] < ve;
                Se.vertexLength + ((Tr ? 1 : 0) + (qt ? 1 : 0)) > Kr.MAX_VERTEX_ARRAY_LENGTH && (Se = L.createNewSegment(F, V), ve = De.count, Tr = !0, qt = !0, He = 0);
                const Ut = Tu(oe, q, J, De, Bt, Tr, Se),
                  mt = Tu(oe, q, J, De, Zt, qt, Se);
                V.emplaceBack(He + Ut - ve, He + mt - ve), Se.primitiveLength++
              }
            }
          })(f, r, v, c, x, n), t.forceNewSegmentOnNextPrepare(), f == null || f.forceNewSegmentOnNextPrepare()
        }

        function Tu(n, t, r, a, c, p, f) {
          if (p) {
            const v = a.count;
            return r(t[2 * c], t[2 * c + 1]), n[c] = a.count, a.count++, f.vertexLength++, v
          }
          return n[c]
        }
        class ef {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new et, this.indexArray = new Ln, this.indexArray2 = new Mn, this.programConfigurations = new ca(t.layers, t.zoom), this.segments = new Kr, this.segments2 = new Kr, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.hasPattern = Yp("fill", this.layers, r);
            const c = this.layers[0].layout.get("fill-sort-key"),
              p = !c.isConstant(),
              f = [];
            for (const {
                feature: v,
                id: x,
                index: C,
                sourceLayerIndex: I
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                F = ts(v, L);
              if (!this.layers[0]._featureFilter.filter(new $n(this.zoom, {
                  globalState: this.globalState
                }), F, a)) continue;
              const V = p ? c.evaluate(F, {}, a, r.availableImages) : void 0,
                q = {
                  id: x,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: I,
                  index: C,
                  geometry: L ? F.geometry : xs(v),
                  patterns: {},
                  sortKey: V
                };
              f.push(q)
            }
            p && f.sort(((v, x) => v.sortKey - x.sortKey));
            for (const v of f) {
              const {
                geometry: x,
                index: C,
                sourceLayerIndex: I
              } = v;
              if (this.hasPattern) {
                const L = Kp("fill", this.layers, v, this.zoom, r);
                this.patternFeatures.push(L)
              } else this.addFeature(v, x, C, a, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[C].feature, x, C, I, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          addFeatures(t, r, a) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, a, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, sy), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, r, a, c, p, f) {
            for (const v of Bo(r, 500)) {
              const x = I_(v, c, f.fill.getGranularityForZoomLevel(c.z)),
                C = this.layoutVertexArray;
              M_(((I, L) => {
                C.emplaceBack(I, L)
              }), this.segments, this.layoutVertexArray, this.indexArray, x.verticesFlattened, x.indicesTriangles, this.segments2, this.indexArray2, x.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
          }
        }
        let A_, k_;
        Qt("FillBucket", ef, {
          omit: ["layers", "patternFeatures"]
        });
        var vy = {
          get paint() {
            return k_ = k_ || new $i({
              "fill-antialias": new vr(xe.paint_fill["fill-antialias"]),
              "fill-opacity": new Or(xe.paint_fill["fill-opacity"]),
              "fill-color": new Or(xe.paint_fill["fill-color"]),
              "fill-outline-color": new Or(xe.paint_fill["fill-outline-color"]),
              "fill-translate": new vr(xe.paint_fill["fill-translate"]),
              "fill-translate-anchor": new vr(xe.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new Vl(xe.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return A_ = A_ || new $i({
              "fill-sort-key": new Or(xe.layout_fill["fill-sort-key"])
            })
          }
        };
        class yy extends xa {
          constructor(t) {
            super(t, vy)
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const a = this.paint._values["fill-outline-color"];
            a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new ef(t)
          }
          queryRadius() {
            return Sd(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: r,
            transform: a,
            pixelsToTileUnits: c
          }) {
            return l_(Cd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, c), r)
          }
          isTileClipped() {
            return !0
          }
        }
        const xy = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          by = ei([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: wy
          } = xy;
        class Jl {
          constructor(t, r, a, c, p) {
            this.properties = {}, this.extent = a, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = c, this._values = p, t.readFields(Ty, this, r)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos,
              a = [];
            let c, p = 1,
              f = 0,
              v = 0,
              x = 0;
            for (; t.pos < r;) {
              if (f <= 0) {
                const C = t.readVarint();
                p = 7 & C, f = C >> 3
              }
              if (f--, p === 1 || p === 2) v += t.readSVarint(), x += t.readSVarint(), p === 1 && (c && a.push(c), c = []), c && c.push(new B(v, x));
              else {
                if (p !== 7) throw new Error(`unknown command ${p}`);
                c && c.push(c[0].clone())
              }
            }
            return c && a.push(c), a
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let a = 1,
              c = 0,
              p = 0,
              f = 0,
              v = 1 / 0,
              x = -1 / 0,
              C = 1 / 0,
              I = -1 / 0;
            for (; t.pos < r;) {
              if (c <= 0) {
                const L = t.readVarint();
                a = 7 & L, c = L >> 3
              }
              if (c--, a === 1 || a === 2) p += t.readSVarint(), f += t.readSVarint(), p < v && (v = p), p > x && (x = p), f < C && (C = f), f > I && (I = f);
              else if (a !== 7) throw new Error(`unknown command ${a}`)
            }
            return [v, C, x, I]
          }
          toGeoJSON(t, r, a) {
            const c = this.extent * Math.pow(2, a),
              p = this.extent * t,
              f = this.extent * r,
              v = this.loadGeometry();

            function x(F) {
              return [360 * (F.x + p) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (F.y + f) / c) * Math.PI)) - 90]
            }

            function C(F) {
              return F.map(x)
            }
            let I;
            if (this.type === 1) {
              const F = [];
              for (const q of v) F.push(q[0]);
              const V = C(F);
              I = F.length === 1 ? {
                type: "Point",
                coordinates: V[0]
              } : {
                type: "MultiPoint",
                coordinates: V
              }
            } else if (this.type === 2) {
              const F = v.map(C);
              I = F.length === 1 ? {
                type: "LineString",
                coordinates: F[0]
              } : {
                type: "MultiLineString",
                coordinates: F
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const F = (function(q) {
                    const G = q.length;
                    if (G <= 1) return [q];
                    const J = [];
                    let oe, De;
                    for (let ve = 0; ve < G; ve++) {
                      const Se = Sy(q[ve]);
                      Se !== 0 && (De === void 0 && (De = Se < 0), De === Se < 0 ? (oe && J.push(oe), oe = [q[ve]]) : oe && oe.push(q[ve]))
                    }
                    return oe && J.push(oe), J
                  })(v),
                  V = [];
                for (const q of F) V.push(q.map(C));
                I = V.length === 1 ? {
                  type: "Polygon",
                  coordinates: V[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: V
                }
              }
            }
            const L = {
              type: "Feature",
              geometry: I,
              properties: this.properties
            };
            return this.id != null && (L.id = this.id), L
          }
        }

        function Ty(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? (function(a, c) {
            const p = a.readVarint() + a.pos;
            for (; a.pos < p;) {
              const f = c._keys[a.readVarint()],
                v = c._values[a.readVarint()];
              c.properties[f] = v
            }
          })(r, t) : n === 3 ? t.type = r.readVarint() : n === 4 && (t._geometry = r.pos)
        }

        function Sy(n) {
          let t = 0;
          for (let r, a, c = 0, p = n.length, f = p - 1; c < p; f = c++) r = n[c], a = n[f], t += (a.x - r.x) * (r.y + a.y);
          return t
        }
        Jl.types = ["Unknown", "Point", "LineString", "Polygon"];
        class E_ {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Cy, this, r), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new Jl(this._pbf, r, this.extent, this._keys, this._values)
          }
        }

        function Cy(n, t, r) {
          n === 15 ? t.version = r.readVarint() : n === 1 ? t.name = r.readString() : n === 5 ? t.extent = r.readVarint() : n === 2 ? t._features.push(r.pos) : n === 3 ? t._keys.push(r.readString()) : n === 4 && t._values.push((function(a) {
            let c = null;
            const p = a.readVarint() + a.pos;
            for (; a.pos < p;) {
              const f = a.readVarint() >> 3;
              c = f === 1 ? a.readString() : f === 2 ? a.readFloat() : f === 3 ? a.readDouble() : f === 4 ? a.readVarint64() : f === 5 ? a.readVarint() : f === 6 ? a.readSVarint() : f === 7 ? a.readBoolean() : null
            }
            if (c == null) throw new Error("unknown feature value");
            return c
          })(r))
        }
        class z_ {
          constructor(t, r) {
            this.layers = t.readFields(Py, {}, r)
          }
        }

        function Py(n, t, r) {
          if (n === 3) {
            const a = new E_(r, r.readVarint() + r.pos);
            a.length && (t[a.name] = a)
          }
        }
        const tf = Math.pow(2, 13);

        function Su(n, t, r, a, c, p, f, v) {
          n.emplaceBack(t, r, 2 * Math.floor(a * tf) + f, c * tf * 2, p * tf * 2, Math.round(v))
        }
        class rf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ze, this.centroidVertexArray = new pe, this.indexArray = new Ln, this.programConfigurations = new ca(t.layers, t.zoom), this.segments = new Kr, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.features = [], this.hasPattern = Yp("fill-extrusion", this.layers, r);
            for (const {
                feature: c,
                id: p,
                index: f,
                sourceLayerIndex: v
              }
              of t) {
              const x = this.layers[0]._featureFilter.needGeometry,
                C = ts(c, x);
              if (!this.layers[0]._featureFilter.filter(new $n(this.zoom, {
                  globalState: this.globalState
                }), C, a)) continue;
              const I = {
                id: p,
                sourceLayerIndex: v,
                index: f,
                geometry: x ? C.geometry : xs(c),
                properties: c.properties,
                type: c.type,
                patterns: {}
              };
              this.hasPattern ? this.features.push(Kp("fill-extrusion", this.layers, I, this.zoom, r)) : this.addFeature(I, I.geometry, f, a, {}, r.subdivisionGranularity), r.featureIndex.insert(c, I.geometry, f, v, this.index, !0)
            }
          }
          addFeatures(t, r, a) {
            for (const c of this.features) {
              const {
                geometry: p
              } = c;
              this.addFeature(c, p, c.index, r, a, t.subdivisionGranularity)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, wy), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, by.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, r, a, c, p, f) {
            for (const v of Bo(r, 500)) {
              const x = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                C = this.layoutVertexArray.length;
              this.processPolygon(x, c, t, v, f);
              const I = this.layoutVertexArray.length - C,
                L = Math.floor(x.x / x.sampleCount),
                F = Math.floor(x.y / x.sampleCount);
              for (let V = 0; V < I; V++) this.centroidVertexArray.emplaceBack(L, F)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
          }
          processPolygon(t, r, a, c, p) {
            if (c.length < 1 || L_(c[0])) return;
            for (const L of c) L.length !== 0 && Iy(t, L);
            const f = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              v = p.fill.getGranularityForZoomLevel(r.z),
              x = Jl.types[a.type] === "Polygon";
            for (const L of c) {
              if (L.length === 0 || L_(L)) continue;
              const F = Qo(L, v, x);
              this._generateSideFaces(F, f)
            }
            if (!x) return;
            const C = I_(c, r, v, !1),
              I = this.layoutVertexArray;
            M_(((L, F) => {
              Su(I, L, F, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, C.verticesFlattened, C.indicesTriangles)
          }
          _generateSideFaces(t, r) {
            let a = 0;
            for (let c = 1; c < t.length; c++) {
              const p = t[c],
                f = t[c - 1];
              if (My(p, f)) continue;
              r.segment.vertexLength + 4 > Kr.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const v = p.sub(f)._perp()._unit(),
                x = f.dist(p);
              a + x > 32768 && (a = 0), Su(this.layoutVertexArray, p.x, p.y, v.x, v.y, 0, 0, a), Su(this.layoutVertexArray, p.x, p.y, v.x, v.y, 0, 1, a), a += x, Su(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 0, a), Su(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 1, a);
              const C = r.segment.vertexLength;
              this.indexArray.emplaceBack(C, C + 2, C + 1), this.indexArray.emplaceBack(C + 1, C + 2, C + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2
            }
          }
        }

        function Iy(n, t) {
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            r === t.length - 1 && t[0].x === a.x && t[0].y === a.y || (n.x += a.x, n.y += a.y, n.sampleCount++)
          }
        }

        function My(n, t) {
          return n.x === t.x && (n.x < 0 || n.x > ae) || n.y === t.y && (n.y < 0 || n.y > ae)
        }

        function L_(n) {
          return n.every((t => t.x < 0)) || n.every((t => t.x > ae)) || n.every((t => t.y < 0)) || n.every((t => t.y > ae))
        }
        let D_;
        Qt("FillExtrusionBucket", rf, {
          omit: ["layers", "features"]
        });
        var Ay = {
          get paint() {
            return D_ = D_ || new $i({
              "fill-extrusion-opacity": new vr(xe["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new Or(xe["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new vr(xe["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new vr(xe["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new Vl(xe["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new Or(xe["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new Or(xe["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new vr(xe["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class ky extends xa {
          constructor(t) {
            super(t, Ay)
          }
          createBucket(t) {
            return new rf(t)
          }
          queryRadius() {
            return Sd(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: f,
            pixelPosMatrix: v
          }) {
            const x = Cd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f),
              C = this.paint.get("fill-extrusion-height").evaluate(r, a),
              I = this.paint.get("fill-extrusion-base").evaluate(r, a),
              L = (function(V, q) {
                const G = [];
                for (const J of V) {
                  const oe = [J.x, J.y, 0, 1];
                  Ae(oe, oe, q), G.push(new B(oe[0] / oe[3], oe[1] / oe[3]))
                }
                return G
              })(x, v),
              F = (function(V, q, G, J) {
                const oe = [],
                  De = [],
                  ve = J[8] * q,
                  Se = J[9] * q,
                  He = J[10] * q,
                  at = J[11] * q,
                  Pt = J[8] * G,
                  $t = J[9] * G,
                  Bt = J[10] * G,
                  Zt = J[11] * G;
                for (const Tr of V) {
                  const qt = [],
                    Ut = [];
                  for (const mt of Tr) {
                    const Nr = mt.x,
                      Ur = mt.y,
                      Pr = J[0] * Nr + J[4] * Ur + J[12],
                      fr = J[1] * Nr + J[5] * Ur + J[13],
                      hn = J[2] * Nr + J[6] * Ur + J[14],
                      Jn = J[3] * Nr + J[7] * Ur + J[15],
                      _i = hn + He,
                      Vi = Jn + at,
                      Fa = Pr + Pt,
                      ha = fr + $t,
                      zi = hn + Bt,
                      Hn = Jn + Zt,
                      Ti = new B((Pr + ve) / Vi, (fr + Se) / Vi);
                    Ti.z = _i / Vi, qt.push(Ti);
                    const Li = new B(Fa / Hn, ha / Hn);
                    Li.z = zi / Hn, Ut.push(Li)
                  }
                  oe.push(qt), De.push(Ut)
                }
                return [oe, De]
              })(c, I, C, v);
            return (function(V, q, G) {
              let J = 1 / 0;
              l_(G, q) && (J = R_(G, q[0]));
              for (let oe = 0; oe < q.length; oe++) {
                const De = q[oe],
                  ve = V[oe];
                for (let Se = 0; Se < De.length - 1; Se++) {
                  const He = De[Se],
                    at = [He, De[Se + 1], ve[Se + 1], ve[Se], He];
                  o_(G, at) && (J = Math.min(J, R_(G, at)))
                }
              }
              return J !== 1 / 0 && J
            })(F[0], F[1], L)
          }
        }

        function Cu(n, t) {
          return n.x * t.x + n.y * t.y
        }

        function R_(n, t) {
          if (n.length === 1) {
            let r = 0;
            const a = t[r++];
            let c;
            for (; !c || a.equals(c);)
              if (c = t[r++], !c) return 1 / 0;
            for (; r < t.length; r++) {
              const p = t[r],
                f = n[0],
                v = c.sub(a),
                x = p.sub(a),
                C = f.sub(a),
                I = Cu(v, v),
                L = Cu(v, x),
                F = Cu(x, x),
                V = Cu(C, v),
                q = Cu(C, x),
                G = I * F - L * L,
                J = (F * V - L * q) / G,
                oe = (I * q - L * V) / G,
                De = a.z * (1 - J - oe) + c.z * J + p.z * oe;
              if (isFinite(De)) return De
            }
            return 1 / 0
          } {
            let r = 1 / 0;
            for (const a of t) r = Math.min(r, a.z);
            return r
          }
        }
        const Ey = ei([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: zy
          } = Ey,
          Ly = ei([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: Dy
          } = Ly,
          Ry = Math.cos(Math.PI / 180 * 37.5),
          B_ = Math.pow(2, 14) / .5;
        class nf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r => {
              this.gradients[r.id] = {}
            })), this.layoutVertexArray = new Ge, this.layoutVertexArray2 = new Ke, this.indexArray = new Ln, this.programConfigurations = new ca(t.layers, t.zoom), this.segments = new Kr, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.hasPattern = Yp("line", this.layers, r);
            const c = this.layers[0].layout.get("line-sort-key"),
              p = !c.isConstant(),
              f = [];
            for (const {
                feature: v,
                id: x,
                index: C,
                sourceLayerIndex: I
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                F = ts(v, L);
              if (!this.layers[0]._featureFilter.filter(new $n(this.zoom, {
                  globalState: this.globalState
                }), F, a)) continue;
              const V = p ? c.evaluate(F, {}, a) : void 0,
                q = {
                  id: x,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: I,
                  index: C,
                  geometry: L ? F.geometry : xs(v),
                  patterns: {},
                  sortKey: V
                };
              f.push(q)
            }
            p && f.sort(((v, x) => v.sortKey - x.sortKey));
            for (const v of f) {
              const {
                geometry: x,
                index: C,
                sourceLayerIndex: I
              } = v;
              if (this.hasPattern) {
                const L = Kp("line", this.layers, v, this.zoom, r);
                this.patternFeatures.push(L)
              } else this.addFeature(v, x, C, a, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[C].feature, x, C, I, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
          }
          addFeatures(t, r, a) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, a, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Dy)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, zy), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, r, a, c, p, f) {
            const v = this.layers[0].layout,
              x = v.get("line-join").evaluate(t, {}),
              C = v.get("line-cap"),
              I = v.get("line-miter-limit"),
              L = v.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const F of r) this.addLine(F, t, x, C, I, L, c, f);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
          }
          addLine(t, r, a, c, p, f, v, x) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = Qo(t, v ? x.line.getGranularityForZoomLevel(v.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ve = 0; ve < t.length - 1; ve++) this.totalDistance += t[ve].dist(t[ve + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const C = Jl.types[r.type] === "Polygon";
            let I = t.length;
            for (; I >= 2 && t[I - 1].equals(t[I - 2]);) I--;
            let L = 0;
            for (; L < I - 1 && t[L].equals(t[L + 1]);) L++;
            if (I < (C ? 3 : 2)) return;
            a === "bevel" && (p = 1.05);
            const F = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              V = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
            let q, G, J, oe, De;
            this.e1 = this.e2 = -1, C && (q = t[I - 2], De = t[L].sub(q)._unit()._perp());
            for (let ve = L; ve < I; ve++) {
              if (J = ve === I - 1 ? C ? t[L + 1] : void 0 : t[ve + 1], J && t[ve].equals(J)) continue;
              De && (oe = De), q && (G = q), q = t[ve], De = J ? J.sub(q)._unit()._perp() : oe, oe = oe || De;
              let Se = oe.add(De);
              Se.x === 0 && Se.y === 0 || Se._unit();
              const He = oe.x * De.x + oe.y * De.y,
                at = Se.x * De.x + Se.y * De.y,
                Pt = at !== 0 ? 1 / at : 1 / 0,
                $t = 2 * Math.sqrt(2 - 2 * at),
                Bt = at < Ry && G && J,
                Zt = oe.x * De.y - oe.y * De.x > 0;
              if (Bt && ve > L) {
                const Ut = q.dist(G);
                if (Ut > 2 * F) {
                  const mt = q.sub(q.sub(G)._mult(F / Ut)._round());
                  this.updateDistance(G, mt), this.addCurrentVertex(mt, oe, 0, 0, V), G = mt
                }
              }
              const Tr = G && J;
              let qt = Tr ? a : C ? "butt" : c;
              if (Tr && qt === "round" && (Pt < f ? qt = "miter" : Pt <= 2 && (qt = "fakeround")), qt === "miter" && Pt > p && (qt = "bevel"), qt === "bevel" && (Pt > 2 && (qt = "flipbevel"), Pt < p && (qt = "miter")), G && this.updateDistance(G, q), qt === "miter") Se._mult(Pt), this.addCurrentVertex(q, Se, 0, 0, V);
              else if (qt === "flipbevel") {
                if (Pt > 100) Se = De.mult(-1);
                else {
                  const Ut = Pt * oe.add(De).mag() / oe.sub(De).mag();
                  Se._perp()._mult(Ut * (Zt ? -1 : 1))
                }
                this.addCurrentVertex(q, Se, 0, 0, V), this.addCurrentVertex(q, Se.mult(-1), 0, 0, V)
              } else if (qt === "bevel" || qt === "fakeround") {
                const Ut = -Math.sqrt(Pt * Pt - 1),
                  mt = Zt ? Ut : 0,
                  Nr = Zt ? 0 : Ut;
                if (G && this.addCurrentVertex(q, oe, mt, Nr, V), qt === "fakeround") {
                  const Ur = Math.round(180 * $t / Math.PI / 20);
                  for (let Pr = 1; Pr < Ur; Pr++) {
                    let fr = Pr / Ur;
                    if (fr !== .5) {
                      const Jn = fr - .5;
                      fr += fr * Jn * (fr - 1) * ((1.0904 + He * (He * (3.55645 - 1.43519 * He) - 3.2452)) * Jn * Jn + (.848013 + He * (.215638 * He - 1.06021)))
                    }
                    const hn = De.sub(oe)._mult(fr)._add(oe)._unit()._mult(Zt ? -1 : 1);
                    this.addHalfVertex(q, hn.x, hn.y, !1, Zt, 0, V)
                  }
                }
                J && this.addCurrentVertex(q, De, -mt, -Nr, V)
              } else if (qt === "butt") this.addCurrentVertex(q, Se, 0, 0, V);
              else if (qt === "square") {
                const Ut = G ? 1 : -1;
                this.addCurrentVertex(q, Se, Ut, Ut, V)
              } else qt === "round" && (G && (this.addCurrentVertex(q, oe, 0, 0, V), this.addCurrentVertex(q, oe, 1, 1, V, !0)), J && (this.addCurrentVertex(q, De, -1, -1, V, !0), this.addCurrentVertex(q, De, 0, 0, V)));
              if (Bt && ve < I - 1) {
                const Ut = q.dist(J);
                if (Ut > 2 * F) {
                  const mt = q.add(J.sub(q)._mult(F / Ut)._round());
                  this.updateDistance(q, mt), this.addCurrentVertex(mt, De, 0, 0, V), q = mt
                }
              }
            }
          }
          addCurrentVertex(t, r, a, c, p, f = !1) {
            const v = r.y * c - r.x,
              x = -r.y - r.x * c;
            this.addHalfVertex(t, r.x + r.y * a, r.y - r.x * a, f, !1, a, p), this.addHalfVertex(t, v, x, f, !0, -c, p), this.distance > B_ / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, a, c, p, f))
          }
          addHalfVertex({
            x: t,
            y: r
          }, a, c, p, f, v, x) {
            const C = .5 * (this.lineClips ? this.scaledDistance * (B_ - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (r << 1) + (f ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * c) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & C) << 2, C >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const I = x.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2), x.primitiveLength++), f ? this.e2 = I : this.e1 = I
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance()
          }
        }
        let F_, O_;
        Qt("LineBucket", nf, {
          omit: ["layers", "patternFeatures"]
        });
        var N_ = {
          get paint() {
            return O_ = O_ || new $i({
              "line-opacity": new Or(xe.paint_line["line-opacity"]),
              "line-color": new Or(xe.paint_line["line-color"]),
              "line-translate": new vr(xe.paint_line["line-translate"]),
              "line-translate-anchor": new vr(xe.paint_line["line-translate-anchor"]),
              "line-width": new Or(xe.paint_line["line-width"]),
              "line-gap-width": new Or(xe.paint_line["line-gap-width"]),
              "line-offset": new Or(xe.paint_line["line-offset"]),
              "line-blur": new Or(xe.paint_line["line-blur"]),
              "line-dasharray": new ms(xe.paint_line["line-dasharray"]),
              "line-pattern": new Vl(xe.paint_line["line-pattern"]),
              "line-gradient": new ql(xe.paint_line["line-gradient"])
            })
          },
          get layout() {
            return F_ = F_ || new $i({
              "line-cap": new vr(xe.layout_line["line-cap"]),
              "line-join": new Or(xe.layout_line["line-join"]),
              "line-miter-limit": new vr(xe.layout_line["line-miter-limit"]),
              "line-round-limit": new vr(xe.layout_line["line-round-limit"]),
              "line-sort-key": new Or(xe.layout_line["line-sort-key"])
            })
          }
        };
        class By extends Or {
          possiblyEvaluate(t, r) {
            return r = new $n(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition
            }), super.possiblyEvaluate(t, r)
          }
          evaluate(t, r, a, c) {
            return r = dt({}, r, {
              zoom: Math.floor(r.zoom)
            }), super.evaluate(t, r, a, c)
          }
        }
        let Ad;
        class Fy extends xa {
          constructor(t) {
            super(t, N_), this.gradientVersion = 0, Ad || (Ad = new By(N_.paint.properties["line-width"].specification), Ad.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(a) {
                return a._styleExpression !== void 0
              })(r) && r._styleExpression.expression instanceof Qn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = Ad.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new nf(t)
          }
          queryRadius(t) {
            const r = t,
              a = j_(_u("line-width", this, r), _u("line-gap-width", this, r)),
              c = _u("line-offset", this, r);
            return a / 2 + Math.abs(c) + Sd(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: f
          }) {
            const v = Cd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f),
              x = f / 2 * j_(this.paint.get("line-width").evaluate(r, a), this.paint.get("line-gap-width").evaluate(r, a)),
              C = this.paint.get("line-offset").evaluate(r, a);
            return C && (c = (function(I, L) {
              const F = [];
              for (let V = 0; V < I.length; V++) {
                const q = I[V],
                  G = [];
                for (let J = 0; J < q.length; J++) {
                  const oe = q[J - 1],
                    De = q[J],
                    ve = q[J + 1],
                    Se = J === 0 ? new B(0, 0) : De.sub(oe)._unit()._perp(),
                    He = J === q.length - 1 ? new B(0, 0) : ve.sub(De)._unit()._perp(),
                    at = Se._add(He)._unit(),
                    Pt = at.x * He.x + at.y * He.y;
                  Pt !== 0 && at._mult(1 / Pt), G.push(at._mult(L)._add(De))
                }
                F.push(G)
              }
              return F
            })(c, C * f)), (function(I, L, F) {
              for (let V = 0; V < L.length; V++) {
                const q = L[V];
                if (I.length >= 3) {
                  for (let G = 0; G < q.length; G++)
                    if (Wl(I, q[G])) return !0
                }
                if (W0(I, q, F)) return !0
              }
              return !1
            })(v, c, x)
          }
          isTileClipped() {
            return !0
          }
        }

        function j_(n, t) {
          return t > 0 ? t + 2 * n : n
        }
        const Oy = ei([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          Ny = ei([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        ei([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const jy = ei([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        ei([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const V_ = ei([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          Vy = ei([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function qy(n, t, r) {
          return n.sections.forEach((a => {
            a.text = (function(c, p, f) {
              const v = p.layout.get("text-transform").evaluate(f, {});
              return v === "uppercase" ? c = c.toLocaleUpperCase() : v === "lowercase" && (c = c.toLocaleLowerCase()), za.applyArabicShaping && (c = za.applyArabicShaping(c)), c
            })(a.text, t, r)
          })), n
        }
        ei([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), ei([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), ei([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), ei([{
          type: "Float32",
          name: "offsetX"
        }]), ei([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), ei([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const Pu = {
          "!": "︕",
          "#": "＃",
          $: "＄",
          "%": "％",
          "&": "＆",
          "(": "︵",
          ")": "︶",
          "*": "＊",
          "+": "＋",
          ",": "︐",
          "-": "︲",
          ".": "・",
          "/": "／",
          ":": "︓",
          ";": "︔",
          "<": "︿",
          "=": "＝",
          ">": "﹀",
          "?": "︖",
          "@": "＠",
          "[": "﹇",
          "\\": "＼",
          "]": "﹈",
          "^": "＾",
          _: "︳",
          "`": "｀",
          "{": "︷",
          "|": "―",
          "}": "︸",
          "~": "～",
          "¢": "￠",
          "£": "￡",
          "¥": "￥",
          "¦": "￤",
          "¬": "￢",
          "¯": "￣",
          "–": "︲",
          "—": "︱",
          "‘": "﹃",
          "’": "﹄",
          "“": "﹁",
          "”": "﹂",
          "…": "︙",
          "‧": "・",
          "₩": "￦",
          "、": "︑",
          "。": "︒",
          "〈": "︿",
          "〉": "﹀",
          "《": "︽",
          "》": "︾",
          "「": "﹁",
          "」": "﹂",
          "『": "﹃",
          "』": "﹄",
          "【": "︻",
          "】": "︼",
          "〔": "︹",
          "〕": "︺",
          "〖": "︗",
          "〗": "︘",
          "！": "︕",
          "（": "︵",
          "）": "︶",
          "，": "︐",
          "－": "︲",
          "．": "・",
          "：": "︓",
          "；": "︔",
          "＜": "︿",
          "＞": "﹀",
          "？": "︖",
          "［": "﹇",
          "］": "﹈",
          "＿": "︳",
          "｛": "︷",
          "｜": "―",
          "｝": "︸",
          "｟": "︵",
          "｠": "︶",
          "｡": "︒",
          "｢": "﹁",
          "｣": "﹂"
        };
        var wi = 24;
        const af = 4294967296,
          q_ = 1 / af,
          Z_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class sf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, r, a = this.length) {
            for (; this.pos < a;) {
              const c = this.readVarint(),
                p = c >> 3,
                f = this.pos;
              this.type = 7 & c, t(p, r, this), this.pos === f && this.skip(c)
            }
            return r
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * af;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * af;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const r = this.buf;
            let a, c;
            return c = r[this.pos++], a = 127 & c, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 7, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 14, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 21, c < 128 ? a : (c = r[this.pos], a |= (15 & c) << 28, (function(p, f, v) {
              const x = v.buf;
              let C, I;
              if (I = x[v.pos++], C = (112 & I) >> 4, I < 128 || (I = x[v.pos++], C |= (127 & I) << 3, I < 128) || (I = x[v.pos++], C |= (127 & I) << 10, I < 128) || (I = x[v.pos++], C |= (127 & I) << 17, I < 128) || (I = x[v.pos++], C |= (127 & I) << 24, I < 128) || (I = x[v.pos++], C |= (1 & I) << 31, I < 128)) return Ql(p, C, f);
              throw new Error("Expected varint not more than 10 bytes")
            })(a, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              r = this.pos;
            return this.pos = t, t - r >= 12 && Z_ ? Z_.decode(this.buf.subarray(r, t)) : (function(a, c, p) {
              let f = "",
                v = c;
              for (; v < p;) {
                const x = a[v];
                let C, I, L, F = null,
                  V = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
                if (v + V > p) break;
                V === 1 ? x < 128 && (F = x) : V === 2 ? (C = a[v + 1], (192 & C) == 128 && (F = (31 & x) << 6 | 63 & C, F <= 127 && (F = null))) : V === 3 ? (C = a[v + 1], I = a[v + 2], (192 & C) == 128 && (192 & I) == 128 && (F = (15 & x) << 12 | (63 & C) << 6 | 63 & I, (F <= 2047 || F >= 55296 && F <= 57343) && (F = null))) : V === 4 && (C = a[v + 1], I = a[v + 2], L = a[v + 3], (192 & C) == 128 && (192 & I) == 128 && (192 & L) == 128 && (F = (15 & x) << 18 | (63 & C) << 12 | (63 & I) << 6 | 63 & L, (F <= 65535 || F >= 1114112) && (F = null))), F === null ? (F = 65533, V = 1) : F > 65535 && (F -= 65536, f += String.fromCharCode(F >>> 10 & 1023 | 55296), F = 56320 | 1023 & F), f += String.fromCharCode(F), v += V
              }
              return f
            })(this.buf, r, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              r = this.buf.subarray(this.pos, t);
            return this.pos = t, r
          }
          readPackedVarint(t = [], r) {
            const a = this.readPackedEnd();
            for (; this.pos < a;) t.push(this.readVarint(r));
            return t
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r)
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t;) r *= 2;
            if (r !== this.length) {
              const a = new Uint8Array(r);
              a.set(this.buf), this.buf = a, this.dataView = new DataView(a.buffer), this.length = r
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * q_), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * q_), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, a) {
              let c, p;
              if (r >= 0 ? (c = r % 4294967296 | 0, p = r / 4294967296 | 0) : (c = ~(-r % 4294967296), p = ~(-r / 4294967296), 4294967295 ^ c ? c = c + 1 | 0 : (c = 0, p = p + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              a.realloc(10), (function(f, v, x) {
                x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, x.buf[x.pos] = 127 & (f >>>= 7)
              })(c, 0, a), (function(f, v) {
                const x = (7 & f) << 4;
                v.buf[v.pos++] |= x | ((f >>>= 3) ? 128 : 0), f && (v.buf[v.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (v.buf[v.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (v.buf[v.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (v.buf[v.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (v.buf[v.pos++] = 127 & f)))))
              })(p, a)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(c, p, f) {
              for (let v, x, C = 0; C < p.length; C++) {
                if (v = p.charCodeAt(C), v > 55295 && v < 57344) {
                  if (!x) {
                    v > 56319 || C + 1 === p.length ? (c[f++] = 239, c[f++] = 191, c[f++] = 189) : x = v;
                    continue
                  }
                  if (v < 56320) {
                    c[f++] = 239, c[f++] = 191, c[f++] = 189, x = v;
                    continue
                  }
                  v = x - 55296 << 10 | v - 56320 | 65536, x = null
                } else x && (c[f++] = 239, c[f++] = 191, c[f++] = 189, x = null);
                v < 128 ? c[f++] = v : (v < 2048 ? c[f++] = v >> 6 | 192 : (v < 65536 ? c[f++] = v >> 12 | 224 : (c[f++] = v >> 18 | 240, c[f++] = v >> 12 & 63 | 128), c[f++] = v >> 6 & 63 | 128), c[f++] = 63 & v | 128)
              }
              return f
            })(this.buf, t, this.pos);
            const a = this.pos - r;
            a >= 128 && U_(r, a, this), this.pos = r - 1, this.writeVarint(a), this.pos += a
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let a = 0; a < r; a++) this.buf[this.pos++] = t[a]
          }
          writeRawMessage(t, r) {
            this.pos++;
            const a = this.pos;
            t(r, this);
            const c = this.pos - a;
            c >= 128 && U_(a, c, this), this.pos = a - 1, this.writeVarint(c), this.pos += c
          }
          writeMessage(t, r, a) {
            this.writeTag(t, 2), this.writeRawMessage(r, a)
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, Zy, r)
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, Uy, r)
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, Hy, r)
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, $y, r)
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, Gy, r)
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, Wy, r)
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, Xy, r)
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, Yy, r)
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, Ky, r)
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r)
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r)
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r)
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r)
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r)
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r)
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r)
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r)
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r)
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r)
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r)
          }
        }

        function Ql(n, t, r) {
          return r ? 4294967296 * t + (n >>> 0) : 4294967296 * (t >>> 0) + (n >>> 0)
        }

        function U_(n, t, r) {
          const a = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(a);
          for (let c = r.pos - 1; c >= n; c--) r.buf[c + a] = r.buf[c]
        }

        function Zy(n, t) {
          for (let r = 0; r < n.length; r++) t.writeVarint(n[r])
        }

        function Uy(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSVarint(n[r])
        }

        function $y(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFloat(n[r])
        }

        function Gy(n, t) {
          for (let r = 0; r < n.length; r++) t.writeDouble(n[r])
        }

        function Hy(n, t) {
          for (let r = 0; r < n.length; r++) t.writeBoolean(n[r])
        }

        function Wy(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed32(n[r])
        }

        function Xy(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed32(n[r])
        }

        function Yy(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed64(n[r])
        }

        function Ky(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed64(n[r])
        }

        function Jy(n, t, r) {
          n === 1 && r.readMessage(Qy, t)
        }

        function Qy(n, t, r) {
          if (n === 3) {
            const {
              id: a,
              bitmap: c,
              width: p,
              height: f,
              left: v,
              top: x,
              advance: C
            } = r.readMessage(ex, {});
            t.push({
              id: a,
              bitmap: new gu({
                width: p + 6,
                height: f + 6
              }, c),
              metrics: {
                width: p,
                height: f,
                left: v,
                top: x,
                advance: C
              }
            })
          }
        }

        function ex(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? t.bitmap = r.readBytes() : n === 3 ? t.width = r.readVarint() : n === 4 ? t.height = r.readVarint() : n === 5 ? t.left = r.readSVarint() : n === 6 ? t.top = r.readSVarint() : n === 7 && (t.advance = r.readVarint())
        }

        function $_(n) {
          let t = 0,
            r = 0;
          for (const f of n) t += f.w * f.h, r = Math.max(r, f.w);
          n.sort(((f, v) => v.h - f.h));
          const a = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let c = 0,
            p = 0;
          for (const f of n)
            for (let v = a.length - 1; v >= 0; v--) {
              const x = a[v];
              if (!(f.w > x.w || f.h > x.h)) {
                if (f.x = x.x, f.y = x.y, p = Math.max(p, f.y + f.h), c = Math.max(c, f.x + f.w), f.w === x.w && f.h === x.h) {
                  const C = a.pop();
                  C && v < a.length && (a[v] = C)
                } else f.h === x.h ? (x.x += f.w, x.w -= f.w) : f.w === x.w ? (x.y += f.h, x.h -= f.h) : (a.push({
                  x: x.x + f.w,
                  y: x.y,
                  w: x.w - f.w,
                  h: f.h
                }), x.y += f.h, x.h -= f.h);
                break
              }
            }
          return {
            w: c,
            h: p,
            fill: t / (c * p) || 0
          }
        }
        class of {
          constructor(t, {
            pixelRatio: r,
            version: a,
            stretchX: c,
            stretchY: p,
            content: f,
            textFitWidth: v,
            textFitHeight: x
          }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = c, this.stretchY = p, this.content = f, this.version = a, this.textFitWidth = v, this.textFitHeight = x
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class G_ {
          constructor(t, r) {
            const a = {},
              c = {};
            this.haveRenderCallbacks = [];
            const p = [];
            this.addImages(t, a, p), this.addImages(r, c, p);
            const {
              w: f,
              h: v
            } = $_(p), x = new ua({
              width: f || 1,
              height: v || 1
            });
            for (const C in t) {
              const I = t[C],
                L = a[C].paddedRect;
              ua.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: L.x + 1,
                y: L.y + 1
              }, I.data)
            }
            for (const C in r) {
              const I = r[C],
                L = c[C].paddedRect,
                F = L.x + 1,
                V = L.y + 1,
                q = I.data.width,
                G = I.data.height;
              ua.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: F,
                y: V
              }, I.data), ua.copy(I.data, x, {
                x: 0,
                y: G - 1
              }, {
                x: F,
                y: V - 1
              }, {
                width: q,
                height: 1
              }), ua.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: F,
                y: V + G
              }, {
                width: q,
                height: 1
              }), ua.copy(I.data, x, {
                x: q - 1,
                y: 0
              }, {
                x: F - 1,
                y: V
              }, {
                width: 1,
                height: G
              }), ua.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: F + q,
                y: V
              }, {
                width: 1,
                height: G
              })
            }
            this.image = x, this.iconPositions = a, this.patternPositions = c
          }
          addImages(t, r, a) {
            for (const c in t) {
              const p = t[c],
                f = {
                  x: 0,
                  y: 0,
                  w: p.data.width + 2,
                  h: p.data.height + 2
                };
              a.push(f), r[c] = new of(f, p), p.hasRenderCallback && this.haveRenderCallbacks.push(c)
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const a in t.updatedImages) this.patchUpdatedImage(this.iconPositions[a], t.getImage(a), r), this.patchUpdatedImage(this.patternPositions[a], t.getImage(a), r)
          }
          patchUpdatedImage(t, r, a) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [c, p] = t.tl;
            a.update(r.data, void 0, {
              x: c,
              y: p
            })
          }
        }
        var mo;
        Qt("ImagePosition", of), Qt("ImageAtlas", G_), T.ao = void 0, (mo = T.ao || (T.ao = {}))[mo.none = 0] = "none", mo[mo.horizontal = 1] = "horizontal", mo[mo.vertical = 2] = "vertical", mo[mo.horizontalOnly = 3] = "horizontalOnly";
        class Iu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, r, a) {
            const c = new Iu;
            return c.scale = t || 1, c.fontStack = r, c.verticalAlign = a || "bottom", c
          }
          static forImage(t, r) {
            const a = new Iu;
            return a.imageName = t, a.verticalAlign = r || "bottom", a
          }
        }
        class ec {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, r) {
            const a = new ec;
            for (let c = 0; c < t.sections.length; c++) {
              const p = t.sections[c];
              p.image ? a.addImageSection(p) : a.addTextSection(p, r)
            }
            return a
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let a = 0; a < t.length; a++) {
                const c = t.charCodeAt(a + 1) || null,
                  p = t.charCodeAt(a - 1) || null;
                r += c && md(c) && !Pu[t[a + 1]] || p && md(p) && !Pu[t[a - 1]] || !Pu[t[a]] ? t[a] : Pu[t[a]]
              }
              return r
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let a = 0; a < this.text.length && Ed[this.text.charCodeAt(a)]; a++) t++;
            let r = this.text.length;
            for (let a = this.text.length - 1; a >= 0 && a >= t && Ed[this.text.charCodeAt(a)]; a--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r)
          }
          substring(t, r) {
            const a = new ec;
            return a.text = this.text.substring(t, r), a.sectionIndex = this.sectionIndex.slice(t, r), a.sections = this.sections, a
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0)
          }
          getMaxImageSize(t) {
            let r = 0,
              a = 0;
            for (let c = 0; c < this.length(); c++) {
              const p = this.getSection(c);
              if (p.imageName) {
                const f = t[p.imageName];
                if (!f) continue;
                const v = f.displaySize;
                r = Math.max(r, v[0]), a = Math.max(a, v[1])
              }
            }
            return {
              maxImageWidth: r,
              maxImageHeight: a
            }
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(Iu.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const a = this.sections.length - 1;
            for (let c = 0; c < t.text.length; ++c) this.sectionIndex.push(a)
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void At("Can't add FormattedSection with an empty image.");
            const a = this.getNextImageSectionCharCode();
            a ? (this.text += String.fromCharCode(a), this.sections.push(Iu.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : At("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function kd(n, t, r, a, c, p, f, v, x, C, I, L, F, V, q) {
          const G = ec.fromFeature(n, c);
          let J;
          L === T.ao.vertical && G.verticalizePunctuation();
          const {
            processBidirectionalText: oe,
            processStyledBidirectionalText: De
          } = za;
          if (oe && G.sections.length === 1) {
            J = [];
            const He = oe(G.toString(), lf(G, C, p, t, a, V));
            for (const at of He) {
              const Pt = new ec;
              Pt.text = at, Pt.sections = G.sections;
              for (let $t = 0; $t < at.length; $t++) Pt.sectionIndex.push(0);
              J.push(Pt)
            }
          } else if (De) {
            J = [];
            const He = De(G.text, G.sectionIndex, lf(G, C, p, t, a, V));
            for (const at of He) {
              const Pt = new ec;
              Pt.text = at[0], Pt.sectionIndex = at[1], Pt.sections = G.sections, J.push(Pt)
            }
          } else J = (function(He, at) {
            const Pt = [],
              $t = He.text;
            let Bt = 0;
            for (const Zt of at) Pt.push(He.substring(Bt, Zt)), Bt = Zt;
            return Bt < $t.length && Pt.push(He.substring(Bt, $t.length)), Pt
          })(G, lf(G, C, p, t, a, V));
          const ve = [],
            Se = {
              positionedLines: ve,
              text: G.toString(),
              top: I[1],
              bottom: I[1],
              left: I[0],
              right: I[0],
              writingMode: L,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(He, at, Pt, $t, Bt, Zt, Tr, qt, Ut, mt, Nr, Ur) {
            let Pr = 0,
              fr = 0,
              hn = 0,
              Jn = 0;
            const _i = qt === "right" ? 1 : qt === "left" ? 0 : .5,
              Vi = wi / Ur;
            let Fa = 0;
            for (const Hn of Bt) {
              Hn.trim();
              const Ti = Hn.getMaxScale(),
                Li = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              He.positionedLines[Fa] = Li;
              const Di = Li.positionedGlyphs;
              let na = 0;
              if (!Hn.length()) {
                fr += Zt, ++Fa;
                continue
              }
              const Oa = ix($t, Hn, Vi);
              for (let da = 0; da < Hn.length(); da++) {
                const gi = Hn.getSection(da),
                  Ci = Hn.getSectionIndex(da),
                  Pi = Hn.getCharCode(da),
                  ci = ax(Ut, Nr, Pi);
                let qn;
                if (gi.imageName) {
                  if (He.iconsInText = !0, gi.scale = gi.scale * Vi, qn = ox(gi, ci, Ti, Oa, $t), !qn) continue;
                  na = Math.max(na, qn.imageOffset)
                } else if (qn = sx(gi, Pi, ci, Oa, at, Pt), !qn) continue;
                const {
                  rect: rs,
                  metrics: ic,
                  baselineOffset: ns
                } = qn;
                Di.push({
                  glyph: Pi,
                  imageName: gi.imageName,
                  x: Pr,
                  y: fr + ns + -17,
                  vertical: ci,
                  scale: gi.scale,
                  fontStack: gi.fontStack,
                  sectionIndex: Ci,
                  metrics: ic,
                  rect: rs
                }), ci ? (He.verticalizable = !0, Pr += (gi.imageName ? ic.advance : wi) * gi.scale + mt) : Pr += ic.advance * gi.scale + mt
              }
              Di.length !== 0 && (hn = Math.max(Pr - mt, hn), lx(Di, 0, Di.length - 1, _i)), Pr = 0, Li.lineOffset = Math.max(na, (Ti - 1) * wi);
              const Si = Zt * Ti + na;
              fr += Si, Jn = Math.max(Si, Jn), ++Fa
            }
            const {
              horizontalAlign: ha,
              verticalAlign: zi
            } = cf(Tr);
            (function(Hn, Ti, Li, Di, na, Oa, Si, da, gi) {
              const Ci = (Ti - Li) * na;
              let Pi = 0;
              Pi = Oa !== Si ? -da * Di - -17 : -Di * gi * Si + .5 * Si;
              for (const ci of Hn)
                for (const qn of ci.positionedGlyphs) qn.x += Ci, qn.y += Pi
            })(He.positionedLines, _i, ha, zi, hn, Jn, Zt, fr, Bt.length), He.top += -zi * fr, He.bottom = He.top + fr, He.left += -ha * hn, He.right = He.left + hn
          })(Se, t, r, a, J, f, v, x, L, C, F, q), !(function(He) {
            for (const at of He)
              if (at.positionedGlyphs.length !== 0) return !1;
            return !0
          })(ve) && Se
        }
        const Ed = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          tx = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          rx = {
            40: !0
          };

        function H_(n, t, r, a, c, p) {
          if (t.imageName) {
            const f = a[t.imageName];
            return f ? f.displaySize[0] * t.scale * wi / p + c : 0
          } {
            const f = r[t.fontStack],
              v = f && f[n];
            return v ? v.metrics.advance * t.scale + c : 0
          }
        }

        function W_(n, t, r, a) {
          const c = Math.pow(n - t, 2);
          return a ? n < t ? c / 2 : 2 * c : c + Math.abs(r) * r
        }

        function nx(n, t, r) {
          let a = 0;
          return n === 10 && (a -= 1e4), r && (a += 150), n !== 40 && n !== 65288 || (a += 50), t !== 41 && t !== 65289 || (a += 50), a
        }

        function X_(n, t, r, a, c, p) {
          let f = null,
            v = W_(t, r, c, p);
          for (const x of a) {
            const C = W_(t - x.x, r, c, p) + x.badness;
            C <= v && (f = x, v = C)
          }
          return {
            index: n,
            x: t,
            priorBreak: f,
            badness: v
          }
        }

        function Y_(n) {
          return n ? Y_(n.priorBreak).concat(n.index) : []
        }

        function lf(n, t, r, a, c, p) {
          if (!n) return [];
          const f = [],
            v = (function(L, F, V, q, G, J) {
              let oe = 0;
              for (let De = 0; De < L.length(); De++) {
                const ve = L.getSection(De);
                oe += H_(L.getCharCode(De), ve, q, G, F, J)
              }
              return oe / Math.max(1, Math.ceil(oe / V))
            })(n, t, r, a, c, p),
            x = n.text.indexOf("​") >= 0;
          let C = 0;
          for (let L = 0; L < n.length(); L++) {
            const F = n.getSection(L),
              V = n.getCharCode(L);
            if (Ed[V] || (C += H_(V, F, a, c, t, p)), L < n.length() - 1) {
              const q = !((I = V) < 11904) && (!!un["CJK Compatibility Forms"](I) || !!un["CJK Compatibility"](I) || !!un["CJK Strokes"](I) || !!un["CJK Symbols and Punctuation"](I) || !!un["Enclosed CJK Letters and Months"](I) || !!un["Halfwidth and Fullwidth Forms"](I) || !!un["Ideographic Description Characters"](I) || !!un["Vertical Forms"](I) || au.test(String.fromCodePoint(I)));
              (tx[V] || q || F.imageName || L !== n.length() - 2 && rx[n.getCharCode(L + 1)]) && f.push(X_(L + 1, C, v, f, nx(V, n.getCharCode(L + 1), q && x), !1))
            }
          }
          var I;
          return Y_(X_(n.length(), C, v, f, 0, !0))
        }

        function cf(n) {
          let t = .5,
            r = .5;
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (n) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          }
        }

        function ix(n, t, r) {
          const a = t.getMaxScale() * wi,
            {
              maxImageWidth: c,
              maxImageHeight: p
            } = t.getMaxImageSize(n),
            f = Math.max(a, p * r);
          return {
            verticalLineContentWidth: Math.max(a, c * r),
            horizontalLineContentHeight: f
          }
        }

        function K_(n) {
          switch (n) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function ax(n, t, r) {
          return !(n === T.ao.horizontal || !t && !su(r) || t && (Ed[r] || (a = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(a)))));
          var a
        }

        function sx(n, t, r, a, c, p) {
          const f = p[n.fontStack],
            v = (function(C, I, L, F) {
              if (C && C.rect) return C;
              const V = I[L.fontStack],
                q = V && V[F];
              return q ? {
                rect: null,
                metrics: q.metrics
              } : null
            })(f && f[t], c, n, t);
          if (v === null) return null;
          let x;
          if (r) x = a.verticalLineContentWidth - n.scale * wi;
          else {
            const C = K_(n.verticalAlign);
            x = (a.horizontalLineContentHeight - n.scale * wi) * C
          }
          return {
            rect: v.rect,
            metrics: v.metrics,
            baselineOffset: x
          }
        }

        function ox(n, t, r, a, c) {
          const p = c[n.imageName];
          if (!p) return null;
          const f = p.paddedRect,
            v = p.displaySize,
            x = {
              width: v[0],
              height: v[1],
              left: 1,
              top: -3,
              advance: t ? v[1] : v[0]
            };
          let C;
          if (t) C = a.verticalLineContentWidth - v[1] * n.scale;
          else {
            const I = K_(n.verticalAlign);
            C = (a.horizontalLineContentHeight - v[1] * n.scale) * I
          }
          return {
            rect: f,
            metrics: x,
            baselineOffset: C,
            imageOffset: (t ? v[0] : v[1]) * n.scale - wi * r
          }
        }

        function lx(n, t, r, a) {
          if (a === 0) return;
          const c = n[r],
            p = (n[r].x + c.metrics.advance * c.scale) * a;
          for (let f = t; f <= r; f++) n[f].x -= p
        }

        function cx(n, t, r) {
          const {
            horizontalAlign: a,
            verticalAlign: c
          } = cf(r), p = t[0] - n.displaySize[0] * a, f = t[1] - n.displaySize[1] * c;
          return {
            image: n,
            top: f,
            bottom: f + n.displaySize[1],
            left: p,
            right: p + n.displaySize[0]
          }
        }

        function J_(n) {
          var t, r;
          let a = n.left,
            c = n.top,
            p = n.right - a,
            f = n.bottom - c;
          const v = (t = n.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            x = (r = n.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink",
            C = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]);
          if (x === "proportional") {
            if (v === "stretchOnly" && p / f < C || v === "proportional") {
              const I = Math.ceil(f * C);
              a *= I / p, p = I
            }
          } else if (v === "proportional" && x === "stretchOnly" && C !== 0 && p / f > C) {
            const I = Math.ceil(p / C);
            c *= I / f, f = I
          }
          return {
            x1: a,
            y1: c,
            x2: a + p,
            y2: c + f
          }
        }

        function Q_(n, t, r, a, c, p) {
          const f = n.image;
          let v;
          if (f.content) {
            const J = f.content,
              oe = f.pixelRatio || 1;
            v = [J[0] / oe, J[1] / oe, f.displaySize[0] - J[2] / oe, f.displaySize[1] - J[3] / oe]
          }
          const x = t.left * p,
            C = t.right * p;
          let I, L, F, V;
          r === "width" || r === "both" ? (V = c[0] + x - a[3], L = c[0] + C + a[1]) : (V = c[0] + (x + C - f.displaySize[0]) / 2, L = V + f.displaySize[0]);
          const q = t.top * p,
            G = t.bottom * p;
          return r === "height" || r === "both" ? (I = c[1] + q - a[0], F = c[1] + G + a[2]) : (I = c[1] + (q + G - f.displaySize[1]) / 2, F = I + f.displaySize[1]), {
            image: f,
            top: I,
            right: L,
            bottom: F,
            left: V,
            collisionPadding: v
          }
        }
        const qs = 128,
          _o = 32640;

        function eg(n, t) {
          const {
            expression: r
          } = t;
          if (r.kind === "constant") return {
            kind: "constant",
            layoutSize: r.evaluate(new $n(n + 1))
          };
          if (r.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: a,
              interpolationType: c
            } = r;
            let p = 0;
            for (; p < a.length && a[p] <= n;) p++;
            p = Math.max(0, p - 1);
            let f = p;
            for (; f < a.length && a[f] < n + 1;) f++;
            f = Math.min(a.length - 1, f);
            const v = a[p],
              x = a[f];
            return r.kind === "composite" ? {
              kind: "composite",
              minZoom: v,
              maxZoom: x,
              interpolationType: c
            } : {
              kind: "camera",
              minZoom: v,
              maxZoom: x,
              minSize: r.evaluate(new $n(v)),
              maxSize: r.evaluate(new $n(x)),
              interpolationType: c
            }
          }
        }

        function uf(n, t, r) {
          let a = "never";
          const c = n.get(t);
          return c ? a = c : n.get(r) && (a = "always"), a
        }
        const ux = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function zd(n, t, r, a, c, p, f, v, x, C, I, L, F) {
          const V = v ? Math.min(_o, Math.round(v[0])) : 0,
            q = v ? Math.min(_o, Math.round(v[1])) : 0;
          n.emplaceBack(t, r, Math.round(32 * a), Math.round(32 * c), p, f, (V << 1) + (x ? 1 : 0), q, 16 * C, 16 * I, 256 * L, 256 * F)
        }

        function hf(n, t, r) {
          n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r)
        }

        function hx(n) {
          for (const t of n.sections)
            if (vd(t.text)) return !0;
          return !1
        }
        class df {
          constructor(t) {
            this.layoutVertexArray = new Ft, this.indexArray = new Ln, this.programConfigurations = t, this.segments = new Kr, this.dynamicLayoutVertexArray = new St, this.opacityVertexArray = new pr, this.hasVisibleVertices = !1, this.placedSymbolArray = new $
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, r, a, c) {
            this.isEmpty() || (a && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Oy.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Ny.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, ux, !0), this.opacityVertexBuffer.itemSize = 1), (a || c) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Qt("SymbolBuffers", df);
        class pf {
          constructor(t, r, a) {
            this.layoutVertexArray = new t, this.layoutAttributes = r, this.indexArray = new a, this.segments = new Kr, this.collisionVertexArray = new wn
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, jy.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Qt("CollisionBuffers", pf);
        class tc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((f => f.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = eg(this.zoom, r["text-size"]), this.iconSizeData = eg(this.zoom, r["icon-size"]);
            const a = this.layers[0].layout,
              c = a.get("symbol-sort-key"),
              p = a.get("symbol-z-order");
            this.canOverlap = uf(a, "text-overlap", "text-allow-overlap") !== "never" || uf(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !c.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((f => T.ao[f]))), this.stateDependentLayerIds = this.layers.filter((f => f.isStateDependent())).map((f => f.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new df(new ca(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new df(new ca(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new ne, this.lineVertexArray = new le, this.symbolInstances = new ee, this.textAnchorOffsets = new de
          }
          calculateGlyphDependencies(t, r, a, c, p) {
            for (let f = 0; f < t.length; f++)
              if (r[t.charCodeAt(f)] = !0, (a || c) && p) {
                const v = Pu[t.charAt(f)];
                v && (r[v.charCodeAt(0)] = !0)
              }
          }
          populate(t, r, a) {
            const c = this.layers[0],
              p = c.layout,
              f = p.get("text-font"),
              v = p.get("text-field"),
              x = p.get("icon-image"),
              C = (v.value.kind !== "constant" || v.value.value instanceof yn && !v.value.value.isEmpty() || v.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0),
              I = x.value.kind !== "constant" || !!x.value.value || Object.keys(x.parameters).length > 0,
              L = p.get("symbol-sort-key");
            if (this.features = [], !C && !I) return;
            const F = r.iconDependencies,
              V = r.glyphDependencies,
              q = r.availableImages,
              G = new $n(this.zoom, {
                globalState: this.globalState
              });
            for (const {
                feature: J,
                id: oe,
                index: De,
                sourceLayerIndex: ve
              }
              of t) {
              const Se = c._featureFilter.needGeometry,
                He = ts(J, Se);
              if (!c._featureFilter.filter(G, He, a)) continue;
              let at, Pt;
              if (Se || (He.geometry = xs(J)), C) {
                const Bt = c.getValueAndResolveTokens("text-field", He, a, q),
                  Zt = yn.factory(Bt),
                  Tr = this.hasRTLText = this.hasRTLText || hx(Zt);
                (!Tr || za.getRTLTextPluginStatus() === "unavailable" || Tr && za.isParsed()) && (at = qy(Zt, c, He))
              }
              if (I) {
                const Bt = c.getValueAndResolveTokens("icon-image", He, a, q);
                Pt = Bt instanceof ki ? Bt : ki.fromString(Bt)
              }
              if (!at && !Pt) continue;
              const $t = this.sortFeaturesByKey ? L.evaluate(He, {}, a) : void 0;
              if (this.features.push({
                  id: oe,
                  text: at,
                  icon: Pt,
                  index: De,
                  sourceLayerIndex: ve,
                  geometry: He.geometry,
                  properties: J.properties,
                  type: Jl.types[J.type],
                  sortKey: $t
                }), Pt && (F[Pt.name] = !0), at) {
                const Bt = f.evaluate(He, {}, a).join(","),
                  Zt = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(T.ao.vertical) >= 0;
                for (const Tr of at.sections)
                  if (Tr.image) F[Tr.image.name] = !0;
                  else {
                    const qt = Ol(at.toString()),
                      Ut = Tr.fontStack || Bt,
                      mt = V[Ut] = V[Ut] || {};
                    this.calculateGlyphDependencies(Tr.text, mt, Zt, this.allowVerticalPlacement, qt)
                  }
              }
            }
            p.get("symbol-placement") === "line" && (this.features = (function(J) {
              const oe = {},
                De = {},
                ve = [];
              let Se = 0;

              function He(Bt) {
                ve.push(J[Bt]), Se++
              }

              function at(Bt, Zt, Tr) {
                const qt = De[Bt];
                return delete De[Bt], De[Zt] = qt, ve[qt].geometry[0].pop(), ve[qt].geometry[0] = ve[qt].geometry[0].concat(Tr[0]), qt
              }

              function Pt(Bt, Zt, Tr) {
                const qt = oe[Zt];
                return delete oe[Zt], oe[Bt] = qt, ve[qt].geometry[0].shift(), ve[qt].geometry[0] = Tr[0].concat(ve[qt].geometry[0]), qt
              }

              function $t(Bt, Zt, Tr) {
                const qt = Tr ? Zt[0][Zt[0].length - 1] : Zt[0][0];
                return `${Bt}:${qt.x}:${qt.y}`
              }
              for (let Bt = 0; Bt < J.length; Bt++) {
                const Zt = J[Bt],
                  Tr = Zt.geometry,
                  qt = Zt.text ? Zt.text.toString() : null;
                if (!qt) {
                  He(Bt);
                  continue
                }
                const Ut = $t(qt, Tr),
                  mt = $t(qt, Tr, !0);
                if (Ut in De && mt in oe && De[Ut] !== oe[mt]) {
                  const Nr = Pt(Ut, mt, Tr),
                    Ur = at(Ut, mt, ve[Nr].geometry);
                  delete oe[Ut], delete De[mt], De[$t(qt, ve[Ur].geometry, !0)] = Ur, ve[Nr].geometry = null
                } else Ut in De ? at(Ut, mt, Tr) : mt in oe ? Pt(Ut, mt, Tr) : (He(Bt), oe[Ut] = Se - 1, De[mt] = Se - 1)
              }
              return ve.filter((Bt => Bt.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((J, oe) => J.sortKey - oe.sortKey))
          }
          update(t, r, a) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, a), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, a))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, r) {
            const a = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let c = t.dist(r[t.segment + 1]),
                p = t.dist(r[t.segment]);
              const f = {};
              for (let v = t.segment + 1; v < r.length; v++) f[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: c
              }, v < r.length - 1 && (c += r[v + 1].dist(r[v]));
              for (let v = t.segment || 0; v >= 0; v--) f[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: p
              }, v > 0 && (p += r[v - 1].dist(r[v]));
              for (let v = 0; v < r.length; v++) {
                const x = f[v];
                this.lineVertexArray.emplaceBack(x.x, x.y, x.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: a,
              lineLength: this.lineVertexArray.length - a
            }
          }
          addSymbols(t, r, a, c, p, f, v, x, C, I, L, F) {
            const V = t.indexArray,
              q = t.layoutVertexArray,
              G = t.segments.prepareSegment(4 * r.length, q, V, this.canOverlap ? f.sortKey : void 0),
              J = this.glyphOffsetArray.length,
              oe = G.vertexLength,
              De = this.allowVerticalPlacement && v === T.ao.vertical ? Math.PI / 2 : 0,
              ve = f.text && f.text.sections;
            for (let Se = 0; Se < r.length; Se++) {
              const {
                tl: He,
                tr: at,
                bl: Pt,
                br: $t,
                tex: Bt,
                pixelOffsetTL: Zt,
                pixelOffsetBR: Tr,
                minFontScaleX: qt,
                minFontScaleY: Ut,
                glyphOffset: mt,
                isSDF: Nr,
                sectionIndex: Ur
              } = r[Se], Pr = G.vertexLength, fr = mt[1];
              zd(q, x.x, x.y, He.x, fr + He.y, Bt.x, Bt.y, a, Nr, Zt.x, Zt.y, qt, Ut), zd(q, x.x, x.y, at.x, fr + at.y, Bt.x + Bt.w, Bt.y, a, Nr, Tr.x, Zt.y, qt, Ut), zd(q, x.x, x.y, Pt.x, fr + Pt.y, Bt.x, Bt.y + Bt.h, a, Nr, Zt.x, Tr.y, qt, Ut), zd(q, x.x, x.y, $t.x, fr + $t.y, Bt.x + Bt.w, Bt.y + Bt.h, a, Nr, Tr.x, Tr.y, qt, Ut), hf(t.dynamicLayoutVertexArray, x, De), V.emplaceBack(Pr, Pr + 2, Pr + 1), V.emplaceBack(Pr + 1, Pr + 2, Pr + 3), G.vertexLength += 4, G.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(mt[0]), Se !== r.length - 1 && Ur === r[Se + 1].sectionIndex || t.programConfigurations.populatePaintArrays(q.length, f, f.index, {}, F, ve && ve[Ur])
            }
            t.placedSymbolArray.emplaceBack(x.x, x.y, J, this.glyphOffsetArray.length - J, oe, C, I, x.segment, a ? a[0] : 0, a ? a[1] : 0, c[0], c[1], v, 0, !1, 0, L)
          }
          _addCollisionDebugVertex(t, r, a, c, p, f) {
            return r.emplaceBack(0, 0), t.emplaceBack(a.x, a.y, c, p, Math.round(f.x), Math.round(f.y))
          }
          addCollisionDebugVertices(t, r, a, c, p, f, v) {
            const x = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray),
              C = x.vertexLength,
              I = p.layoutVertexArray,
              L = p.collisionVertexArray,
              F = v.anchorX,
              V = v.anchorY;
            this._addCollisionDebugVertex(I, L, f, F, V, new B(t, r)), this._addCollisionDebugVertex(I, L, f, F, V, new B(a, r)), this._addCollisionDebugVertex(I, L, f, F, V, new B(a, c)), this._addCollisionDebugVertex(I, L, f, F, V, new B(t, c)), x.vertexLength += 4;
            const q = p.indexArray;
            q.emplaceBack(C, C + 1), q.emplaceBack(C + 1, C + 2), q.emplaceBack(C + 2, C + 3), q.emplaceBack(C + 3, C), x.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, r, a, c) {
            for (let p = t; p < r; p++) {
              const f = this.collisionBoxArray.get(p);
              this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, c ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, a)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new pf(Jr, V_.members, Mn), this.iconCollisionBox = new pf(Jr, V_.members, Mn);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, a, c, p, f, v, x, C) {
            const I = {};
            for (let L = r; L < a; L++) {
              const F = t.get(L);
              I.textBox = {
                x1: F.x1,
                y1: F.y1,
                x2: F.x2,
                y2: F.y2,
                anchorPointX: F.anchorPointX,
                anchorPointY: F.anchorPointY
              }, I.textFeatureIndex = F.featureIndex;
              break
            }
            for (let L = c; L < p; L++) {
              const F = t.get(L);
              I.verticalTextBox = {
                x1: F.x1,
                y1: F.y1,
                x2: F.x2,
                y2: F.y2,
                anchorPointX: F.anchorPointX,
                anchorPointY: F.anchorPointY
              }, I.verticalTextFeatureIndex = F.featureIndex;
              break
            }
            for (let L = f; L < v; L++) {
              const F = t.get(L);
              I.iconBox = {
                x1: F.x1,
                y1: F.y1,
                x2: F.x2,
                y2: F.y2,
                anchorPointX: F.anchorPointX,
                anchorPointY: F.anchorPointY
              }, I.iconFeatureIndex = F.featureIndex;
              break
            }
            for (let L = x; L < C; L++) {
              const F = t.get(L);
              I.verticalIconBox = {
                x1: F.x1,
                y1: F.y1,
                x2: F.x2,
                y2: F.y2,
                anchorPointX: F.anchorPointX,
                anchorPointY: F.anchorPointY
              }, I.verticalIconFeatureIndex = F.featureIndex;
              break
            }
            return I
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const a = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, r) {
            const a = t.placedSymbolArray.get(r),
              c = a.vertexStartIndex + 4 * a.numGlyphs;
            for (let p = a.vertexStartIndex; p < c; p += 4) t.indexArray.emplaceBack(p, p + 2, p + 1), t.indexArray.emplaceBack(p + 1, p + 2, p + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t),
              a = Math.cos(t),
              c = [],
              p = [],
              f = [];
            for (let v = 0; v < this.symbolInstances.length; ++v) {
              f.push(v);
              const x = this.symbolInstances.get(v);
              c.push(0 | Math.round(r * x.anchorX + a * x.anchorY)), p.push(x.featureIndex)
            }
            return f.sort(((v, x) => c[v] - c[x] || p[x] - p[v])), f
          }
          addToSortKeyRanges(t, r) {
            const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            a && a.sortKey === r ? a.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: r,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const a = this.symbolInstances.get(r);
                this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(((c, p, f) => {
                  c >= 0 && f.indexOf(c) === p && this.addIndicesForPlacedSymbol(this.text, c)
                })), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let tg, rg;
        Qt("SymbolBucket", tc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), tc.MAX_GLYPHS = 65535, tc.addDynamicAttributes = hf;
        var ff = {
          get paint() {
            return rg = rg || new $i({
              "icon-opacity": new Or(xe.paint_symbol["icon-opacity"]),
              "icon-color": new Or(xe.paint_symbol["icon-color"]),
              "icon-halo-color": new Or(xe.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new Or(xe.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new Or(xe.paint_symbol["icon-halo-blur"]),
              "icon-translate": new vr(xe.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new vr(xe.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new Or(xe.paint_symbol["text-opacity"]),
              "text-color": new Or(xe.paint_symbol["text-color"], {
                runtimeType: Cr,
                getOverride: n => n.textColor,
                hasOverride: n => !!n.textColor
              }),
              "text-halo-color": new Or(xe.paint_symbol["text-halo-color"]),
              "text-halo-width": new Or(xe.paint_symbol["text-halo-width"]),
              "text-halo-blur": new Or(xe.paint_symbol["text-halo-blur"]),
              "text-translate": new vr(xe.paint_symbol["text-translate"]),
              "text-translate-anchor": new vr(xe.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return tg = tg || new $i({
              "symbol-placement": new vr(xe.layout_symbol["symbol-placement"]),
              "symbol-spacing": new vr(xe.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new vr(xe.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new Or(xe.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new vr(xe.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new vr(xe.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new vr(xe.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new vr(xe.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new vr(xe.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new vr(xe.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new Or(xe.layout_symbol["icon-size"]),
              "icon-text-fit": new vr(xe.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new vr(xe.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new Or(xe.layout_symbol["icon-image"]),
              "icon-rotate": new Or(xe.layout_symbol["icon-rotate"]),
              "icon-padding": new Or(xe.layout_symbol["icon-padding"]),
              "icon-keep-upright": new vr(xe.layout_symbol["icon-keep-upright"]),
              "icon-offset": new Or(xe.layout_symbol["icon-offset"]),
              "icon-anchor": new Or(xe.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new vr(xe.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new vr(xe.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new vr(xe.layout_symbol["text-rotation-alignment"]),
              "text-field": new Or(xe.layout_symbol["text-field"]),
              "text-font": new Or(xe.layout_symbol["text-font"]),
              "text-size": new Or(xe.layout_symbol["text-size"]),
              "text-max-width": new Or(xe.layout_symbol["text-max-width"]),
              "text-line-height": new vr(xe.layout_symbol["text-line-height"]),
              "text-letter-spacing": new Or(xe.layout_symbol["text-letter-spacing"]),
              "text-justify": new Or(xe.layout_symbol["text-justify"]),
              "text-radial-offset": new Or(xe.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new vr(xe.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new Or(xe.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new Or(xe.layout_symbol["text-anchor"]),
              "text-max-angle": new vr(xe.layout_symbol["text-max-angle"]),
              "text-writing-mode": new vr(xe.layout_symbol["text-writing-mode"]),
              "text-rotate": new Or(xe.layout_symbol["text-rotate"]),
              "text-padding": new vr(xe.layout_symbol["text-padding"]),
              "text-keep-upright": new vr(xe.layout_symbol["text-keep-upright"]),
              "text-transform": new Or(xe.layout_symbol["text-transform"]),
              "text-offset": new Or(xe.layout_symbol["text-offset"]),
              "text-allow-overlap": new vr(xe.layout_symbol["text-allow-overlap"]),
              "text-overlap": new vr(xe.layout_symbol["text-overlap"]),
              "text-ignore-placement": new vr(xe.layout_symbol["text-ignore-placement"]),
              "text-optional": new vr(xe.layout_symbol["text-optional"])
            })
          }
        };
        class ng {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : bt, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Qt("FormatSectionOverride", ng, {
          omit: ["defaultValue"]
        });
        class Ld extends xa {
          constructor(t) {
            super(t, ff)
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const a = this.layout.get("text-writing-mode");
              if (a) {
                const c = [];
                for (const p of a) c.indexOf(p) < 0 && c.push(p);
                this.layout._values["text-writing-mode"] = c
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, r, a, c) {
            const p = this.layout.get(t).evaluate(r, {}, a, c),
              f = this._unevaluatedLayout._values[t];
            return f.isDataDriven() || kl(f.value) || !p ? p : (function(v, x) {
              return x.replace(/{([^{}]+)}/g, ((C, I) => v && I in v ? String(v[I]) : ""))
            })(r.properties, p)
          }
          createBucket(t) {
            return new tc(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of ff.paint.overridableProperties) {
              if (!Ld.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t),
                a = new ng(r),
                c = new Hc(a, r.property.specification);
              let p = null;
              p = r.value.kind === "constant" || r.value.kind === "source" ? new Vo("source", c) : new Wc("composite", c, r.value.zoomStops), this.paint._values[t] = new $a(r.property, p, r.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, a) {
            return !(!this.layout || r.isDataDriven() || a.isDataDriven()) && Ld.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, r) {
            const a = t.get("text-field"),
              c = ff.paint.properties[r];
            let p = !1;
            const f = v => {
              for (const x of v)
                if (c.overrides && c.overrides.hasOverride(x)) return void(p = !0)
            };
            if (a.value.kind === "constant" && a.value.value instanceof yn) f(a.value.value.sections);
            else if (a.value.kind === "source") {
              const v = C => {
                  p || (C instanceof la && Rr(C.value) === Cn ? f(C.value.sections) : C instanceof Ms ? f(C.sections) : C.eachChild(v))
                },
                x = a.value;
              x._styleExpression && v(x._styleExpression.expression)
            }
            return p
          }
        }
        let ig;
        var dx = {
          get paint() {
            return ig = ig || new $i({
              "background-color": new vr(xe.paint_background["background-color"]),
              "background-pattern": new ms(xe.paint_background["background-pattern"]),
              "background-opacity": new vr(xe.paint_background["background-opacity"])
            })
          }
        };
        class px extends xa {
          constructor(t) {
            super(t, dx)
          }
        }
        let ag;
        var fx = {
          get paint() {
            return ag = ag || new $i({
              "raster-opacity": new vr(xe.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new vr(xe.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new vr(xe.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new vr(xe.paint_raster["raster-brightness-max"]),
              "raster-saturation": new vr(xe.paint_raster["raster-saturation"]),
              "raster-contrast": new vr(xe.paint_raster["raster-contrast"]),
              "raster-resampling": new vr(xe.paint_raster["raster-resampling"]),
              "raster-fade-duration": new vr(xe.paint_raster["raster-fade-duration"])
            })
          }
        };
        class mx extends xa {
          constructor(t) {
            super(t, fx)
          }
        }
        class _x extends xa {
          constructor(t) {
            super(t, {}), this.onAdd = r => {
              this.implementation.onAdd && this.implementation.onAdd(r, r.painter.context.gl)
            }, this.onRemove = r => {
              this.implementation.onRemove && this.implementation.onRemove(r, r.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class gx {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const vx = {
            once: !0
          },
          mf = 63710088e-1;
        class go {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new go(ot(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const r = Math.PI / 180,
              a = this.lat * r,
              c = t.lat * r,
              p = Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.cos(c) * Math.cos((t.lng - this.lng) * r);
            return mf * Math.acos(Math.min(p, 1))
          }
          static convert(t) {
            if (t instanceof go) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new go(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new go(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const sg = 2 * Math.PI * mf;

        function og(n) {
          return sg * Math.cos(n * Math.PI / 180)
        }

        function lg(n) {
          return (180 + n) / 360
        }

        function cg(n) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
        }

        function ug(n, t) {
          return n / og(t)
        }

        function _f(n) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
        }

        function hg(n, t) {
          return n * og(_f(t))
        }
        class Mu {
          constructor(t, r, a = 0) {
            this.x = +t, this.y = +r, this.z = +a
          }
          static fromLngLat(t, r = 0) {
            const a = go.convert(t);
            return new Mu(lg(a.lng), cg(a.lat), ug(r, a.lat))
          }
          toLngLat() {
            return new go(360 * this.x - 180, _f(this.y))
          }
          toAltitude() {
            return hg(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / sg * (t = _f(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function dg(n, t, r) {
          var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [n * a - 2 * Math.PI * 6378137 / 2, t * a - 2 * Math.PI * 6378137 / 2]
        }
        class gf {
          constructor(t, r, a) {
            if (!(function(c, p, f) {
                return !(c < 0 || c > 25 || f < 0 || f >= Math.pow(2, c) || p < 0 || p >= Math.pow(2, c))
              })(t, r, a)) throw new Error(`x=${r}, y=${a}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = a, this.key = rc(0, t, t, r, a)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, r, a) {
            const c = (f = this.y, v = this.z, x = dg(256 * (p = this.x), 256 * (f = Math.pow(2, v) - f - 1), v), C = dg(256 * (p + 1), 256 * (f + 1), v), x[0] + "," + x[1] + "," + C[0] + "," + C[1]);
            var p, f, v, x, C;
            const I = (function(L, F, V) {
              let q, G = "";
              for (let J = L; J > 0; J--) q = 1 << J - 1, G += (F & q ? 1 : 0) + (V & q ? 2 : 0);
              return G
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, c)
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new B((t.x * r - this.x) * ae, (t.y * r - this.y) * ae)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class pg {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = rc(t, r.z, r.z, r.x, r.y)
          }
        }
        class Ba {
          constructor(t, r, a, c, p) {
            if (this.terrainRttPosMatrix32f = null, t < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${a}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new gf(a, +c, +p), this.key = rc(r, t, a, c, p)
          }
          clone() {
            return new Ba(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new Ba(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ba(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r)
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const a = this.canonical.z - t;
            return t > this.canonical.z ? rc(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : rc(this.wrap * +r, t, t, this.canonical.x >> a, this.canonical.y >> a)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return !1;
            const r = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Ba(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1,
              a = 2 * this.canonical.x,
              c = 2 * this.canonical.y;
            return [new Ba(r, this.wrap, r, a, c), new Ba(r, this.wrap, r, a + 1, c), new Ba(r, this.wrap, r, a, c + 1), new Ba(r, this.wrap, r, a + 1, c + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new Ba(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new Ba(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new pg(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new Mu(t.x - this.wrap, t.y))
          }
        }

        function rc(n, t, r, a, c) {
          (n *= 2) < 0 && (n = -1 * n - 1);
          const p = 1 << r;
          return (p * p * n + p * c + a).toString(36) + r.toString(36) + t.toString(36)
        }

        function Au(n, t) {
          return t ? n.properties[t] : n.id
        }
        Qt("CanonicalTileID", gf), Qt("OverscaledTileID", Ba, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class el {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const r = new el;
            return r.extend(t(new B(this.minX, this.minY))), r.extend(t(new B(this.maxX, this.minY))), r.extend(t(new B(this.minX, this.maxY))), r.extend(t(new B(this.maxX, this.maxY))), r
          }
          static fromPoints(t) {
            const r = new el;
            for (const a of t) r.extend(a);
            return r
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class fg {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const a = t[r];
              this._stringToNumber[a] = r, this._numberToString[r] = a
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class mg {
          constructor(t, r, a, c, p) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = a, t._y = c, this.properties = t.properties, this.id = p
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t
          }
        }
        class _g {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Wo(ae, 16, 0), this.grid3D = new Wo(ae, 16, 0), this.featureIndexArray = new Ce, this.promoteId = r
          }
          insert(t, r, a, c, p, f) {
            const v = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(a, c, p);
            const x = f ? this.grid3D : this.grid;
            for (let C = 0; C < r.length; C++) {
              const I = r[C],
                L = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let F = 0; F < I.length; F++) {
                const V = I[F];
                L[0] = Math.min(L[0], V.x), L[1] = Math.min(L[1], V.y), L[2] = Math.max(L[2], V.x), L[3] = Math.max(L[3], V.y)
              }
              L[0] < ae && L[1] < ae && L[2] >= 0 && L[3] >= 0 && x.insert(v, L[0], L[1], L[2], L[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new z_(new sf(this.rawTileData)).layers, this.sourceLayerCoder = new fg(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, r, a, c) {
            this.loadVTLayers();
            const p = t.params,
              f = ae / t.tileSize / t.scale,
              v = Ds(p.filter),
              x = t.queryGeometry,
              C = t.queryPadding * f,
              I = el.fromPoints(x),
              L = this.grid.query(I.minX - C, I.minY - C, I.maxX + C, I.maxY + C),
              F = el.fromPoints(t.cameraQueryGeometry).expandBy(C),
              V = this.grid3D.query(F.minX, F.minY, F.maxX, F.maxY, ((J, oe, De, ve) => (function(Se, He, at, Pt, $t) {
                for (const Zt of Se)
                  if (He <= Zt.x && at <= Zt.y && Pt >= Zt.x && $t >= Zt.y) return !0;
                const Bt = [new B(He, at), new B(He, $t), new B(Pt, $t), new B(Pt, at)];
                if (Se.length > 2) {
                  for (const Zt of Bt)
                    if (Wl(Se, Zt)) return !0
                }
                for (let Zt = 0; Zt < Se.length - 1; Zt++)
                  if (Y0(Se[Zt], Se[Zt + 1], Bt)) return !0;
                return !1
              })(t.cameraQueryGeometry, J - C, oe - C, De + C, ve + C)));
            for (const J of V) L.push(J);
            L.sort(yx);
            const q = {};
            let G;
            for (let J = 0; J < L.length; J++) {
              const oe = L[J];
              if (oe === G) continue;
              G = oe;
              const De = this.featureIndexArray.get(oe);
              let ve = null;
              this.loadMatchingFeature(q, De.bucketIndex, De.sourceLayerIndex, De.featureIndex, v, p.layers, p.availableImages, r, a, c, ((Se, He, at) => (ve || (ve = xs(Se)), He.queryIntersectsFeature({
                queryGeometry: x,
                feature: Se,
                featureState: at,
                geometry: ve,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: f,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return q
          }
          loadMatchingFeature(t, r, a, c, p, f, v, x, C, I, L) {
            const F = this.bucketLayerIDs[r];
            if (f && !F.some((J => f.has(J)))) return;
            const V = this.sourceLayerCoder.decode(a),
              q = this.vtLayers[V].feature(c);
            if (p.needGeometry) {
              const J = ts(q, !0);
              if (!p.filter(new $n(this.tileID.overscaledZ), J, this.tileID.canonical)) return
            } else if (!p.filter(new $n(this.tileID.overscaledZ), q)) return;
            const G = this.getId(q, V);
            for (let J = 0; J < F.length; J++) {
              const oe = F[J];
              if (f && !f.has(oe)) continue;
              const De = x[oe];
              if (!De) continue;
              let ve = {};
              G && I && (ve = I.getState(De.sourceLayer || "_geojsonTileLayer", G));
              const Se = dt({}, C[oe]);
              Se.paint = gg(Se.paint, De.paint, q, ve, v), Se.layout = gg(Se.layout, De.layout, q, ve, v);
              const He = !L || L(q, De, ve);
              if (!He) continue;
              const at = new mg(q, this.z, this.x, this.y, G);
              at.layer = Se;
              let Pt = t[oe];
              Pt === void 0 && (Pt = t[oe] = []), Pt.push({
                featureIndex: c,
                feature: at,
                intersectionZ: He
              })
            }
          }
          lookupSymbolFeatures(t, r, a, c, p, f, v, x) {
            const C = {};
            this.loadVTLayers();
            const I = Ds(p);
            for (const L of t) this.loadMatchingFeature(C, a, c, L, I, f, v, x, r);
            return C
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs)
              for (const a of r)
                if (t === a) return !0;
            return !1
          }
          getId(t, r) {
            var a;
            let c = t.id;
            return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof c == "boolean" && (c = Number(c)), c === void 0 && (!((a = t.properties) === null || a === void 0) && a.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))), c
          }
        }

        function gg(n, t, r, a, c) {
          return ft(n, ((p, f) => {
            const v = t instanceof jl ? t.get(f) : null;
            return v && v.evaluate ? v.evaluate(r, a, c) : v
          }))
        }

        function yx(n, t) {
          return t - n
        }

        function vg(n, t, r, a, c) {
          const p = [];
          for (let f = 0; f < n.length; f++) {
            const v = n[f];
            let x;
            for (let C = 0; C < v.length - 1; C++) {
              let I = v[C],
                L = v[C + 1];
              I.x < t && L.x < t || (I.x < t ? I = new B(t, I.y + (t - I.x) / (L.x - I.x) * (L.y - I.y))._round() : L.x < t && (L = new B(t, I.y + (t - I.x) / (L.x - I.x) * (L.y - I.y))._round()), I.y < r && L.y < r || (I.y < r ? I = new B(I.x + (r - I.y) / (L.y - I.y) * (L.x - I.x), r)._round() : L.y < r && (L = new B(I.x + (r - I.y) / (L.y - I.y) * (L.x - I.x), r)._round()), I.x >= a && L.x >= a || (I.x >= a ? I = new B(a, I.y + (a - I.x) / (L.x - I.x) * (L.y - I.y))._round() : L.x >= a && (L = new B(a, I.y + (a - I.x) / (L.x - I.x) * (L.y - I.y))._round()), I.y >= c && L.y >= c || (I.y >= c ? I = new B(I.x + (c - I.y) / (L.y - I.y) * (L.x - I.x), c)._round() : L.y >= c && (L = new B(I.x + (c - I.y) / (L.y - I.y) * (L.x - I.x), c)._round()), x && I.equals(x[x.length - 1]) || (x = [I], p.push(x)), x.push(L)))))
            }
          }
          return p
        }
        Qt("FeatureIndex", _g, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class vo extends B {
          constructor(t, r, a, c) {
            super(t, r), this.angle = a, c !== void 0 && (this.segment = c)
          }
          clone() {
            return new vo(this.x, this.y, this.angle, this.segment)
          }
        }

        function yg(n, t, r, a, c) {
          if (t.segment === void 0 || r === 0) return !0;
          let p = t,
            f = t.segment + 1,
            v = 0;
          for (; v > -r / 2;) {
            if (f--, f < 0) return !1;
            v -= n[f].dist(p), p = n[f]
          }
          v += n[f].dist(n[f + 1]), f++;
          const x = [];
          let C = 0;
          for (; v < r / 2;) {
            const I = n[f],
              L = n[f + 1];
            if (!L) return !1;
            let F = n[f - 1].angleTo(I) - I.angleTo(L);
            for (F = Math.abs((F + 3 * Math.PI) % (2 * Math.PI) - Math.PI), x.push({
                distance: v,
                angleDelta: F
              }), C += F; v - x[0].distance > a;) C -= x.shift().angleDelta;
            if (C > c) return !1;
            f++, v += I.dist(L)
          }
          return !0
        }

        function xg(n) {
          let t = 0;
          for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
          return t
        }

        function bg(n, t, r) {
          return n ? .6 * t * r : 0
        }

        function wg(n, t) {
          return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0)
        }

        function xx(n, t, r, a, c, p) {
          const f = bg(r, c, p),
            v = wg(r, a) * p;
          let x = 0;
          const C = xg(n) / 2;
          for (let I = 0; I < n.length - 1; I++) {
            const L = n[I],
              F = n[I + 1],
              V = L.dist(F);
            if (x + V > C) {
              const q = (C - x) / V,
                G = Za.number(L.x, F.x, q),
                J = Za.number(L.y, F.y, q),
                oe = new vo(G, J, F.angleTo(L), I);
              return oe._round(), !f || yg(n, oe, v, f, t) ? oe : void 0
            }
            x += V
          }
        }

        function bx(n, t, r, a, c, p, f, v, x) {
          const C = bg(a, p, f),
            I = wg(a, c),
            L = I * f,
            F = n[0].x === 0 || n[0].x === x || n[0].y === 0 || n[0].y === x;
          return t - L < t / 4 && (t = L + t / 4), Tg(n, F ? t / 2 * v % t : (I / 2 + 2 * p) * f * v % t, t, C, r, L, F, !1, x)
        }

        function Tg(n, t, r, a, c, p, f, v, x) {
          const C = p / 2,
            I = xg(n);
          let L = 0,
            F = t - r,
            V = [];
          for (let q = 0; q < n.length - 1; q++) {
            const G = n[q],
              J = n[q + 1],
              oe = G.dist(J),
              De = J.angleTo(G);
            for (; F + r < L + oe;) {
              F += r;
              const ve = (F - L) / oe,
                Se = Za.number(G.x, J.x, ve),
                He = Za.number(G.y, J.y, ve);
              if (Se >= 0 && Se < x && He >= 0 && He < x && F - C >= 0 && F + C <= I) {
                const at = new vo(Se, He, De, q);
                at._round(), a && !yg(n, at, p, a, c) || V.push(at)
              }
            }
            L += oe
          }
          return v || V.length || f || (V = Tg(n, L / 2, r, a, c, p, f, !0, x)), V
        }

        function Sg(n, t, r, a) {
          const c = [],
            p = n.image,
            f = p.pixelRatio,
            v = p.paddedRect.w - 2,
            x = p.paddedRect.h - 2;
          let C = {
            x1: n.left,
            y1: n.top,
            x2: n.right,
            y2: n.bottom
          };
          const I = p.stretchX || [
              [0, v]
            ],
            L = p.stretchY || [
              [0, x]
            ],
            F = (mt, Nr) => mt + Nr[1] - Nr[0],
            V = I.reduce(F, 0),
            q = L.reduce(F, 0),
            G = v - V,
            J = x - q;
          let oe = 0,
            De = V,
            ve = 0,
            Se = q,
            He = 0,
            at = G,
            Pt = 0,
            $t = J;
          if (p.content && a) {
            const mt = p.content,
              Nr = mt[2] - mt[0],
              Ur = mt[3] - mt[1];
            (p.textFitWidth || p.textFitHeight) && (C = J_(n)), oe = Dd(I, 0, mt[0]), ve = Dd(L, 0, mt[1]), De = Dd(I, mt[0], mt[2]), Se = Dd(L, mt[1], mt[3]), He = mt[0] - oe, Pt = mt[1] - ve, at = Nr - De, $t = Ur - Se
          }
          const Bt = C.x1,
            Zt = C.y1,
            Tr = C.x2 - Bt,
            qt = C.y2 - Zt,
            Ut = (mt, Nr, Ur, Pr) => {
              const fr = Rd(mt.stretch - oe, De, Tr, Bt),
                hn = Bd(mt.fixed - He, at, mt.stretch, V),
                Jn = Rd(Nr.stretch - ve, Se, qt, Zt),
                _i = Bd(Nr.fixed - Pt, $t, Nr.stretch, q),
                Vi = Rd(Ur.stretch - oe, De, Tr, Bt),
                Fa = Bd(Ur.fixed - He, at, Ur.stretch, V),
                ha = Rd(Pr.stretch - ve, Se, qt, Zt),
                zi = Bd(Pr.fixed - Pt, $t, Pr.stretch, q),
                Hn = new B(fr, Jn),
                Ti = new B(Vi, Jn),
                Li = new B(Vi, ha),
                Di = new B(fr, ha),
                na = new B(hn / f, _i / f),
                Oa = new B(Fa / f, zi / f),
                Si = t * Math.PI / 180;
              if (Si) {
                const Ci = Math.sin(Si),
                  Pi = Math.cos(Si),
                  ci = [Pi, -Ci, Ci, Pi];
                Hn._matMult(ci), Ti._matMult(ci), Di._matMult(ci), Li._matMult(ci)
              }
              const da = mt.stretch + mt.fixed,
                gi = Nr.stretch + Nr.fixed;
              return {
                tl: Hn,
                tr: Ti,
                bl: Di,
                br: Li,
                tex: {
                  x: p.paddedRect.x + 1 + da,
                  y: p.paddedRect.y + 1 + gi,
                  w: Ur.stretch + Ur.fixed - da,
                  h: Pr.stretch + Pr.fixed - gi
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: na,
                pixelOffsetBR: Oa,
                minFontScaleX: at / f / Tr,
                minFontScaleY: $t / f / qt,
                isSDF: r
              }
            };
          if (a && (p.stretchX || p.stretchY)) {
            const mt = Cg(I, G, V),
              Nr = Cg(L, J, q);
            for (let Ur = 0; Ur < mt.length - 1; Ur++) {
              const Pr = mt[Ur],
                fr = mt[Ur + 1];
              for (let hn = 0; hn < Nr.length - 1; hn++) c.push(Ut(Pr, Nr[hn], fr, Nr[hn + 1]))
            }
          } else c.push(Ut({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: v + 1
          }, {
            fixed: 0,
            stretch: x + 1
          }));
          return c
        }

        function Dd(n, t, r) {
          let a = 0;
          for (const c of n) a += Math.max(t, Math.min(r, c[1])) - Math.max(t, Math.min(r, c[0]));
          return a
        }

        function Cg(n, t, r) {
          const a = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [c, p] of n) {
            const f = a[a.length - 1];
            a.push({
              fixed: c - f.stretch,
              stretch: f.stretch
            }), a.push({
              fixed: c - f.stretch,
              stretch: f.stretch + (p - c)
            })
          }
          return a.push({
            fixed: t + 1,
            stretch: r
          }), a
        }

        function Rd(n, t, r, a) {
          return n / t * r + a
        }

        function Bd(n, t, r, a) {
          return n - t * r / a
        }
        Qt("Anchor", vo);
        class Fd {
          constructor(t, r, a, c, p, f, v, x, C, I) {
            var L;
            if (this.boxStartIndex = t.length, C) {
              let F = f.top,
                V = f.bottom;
              const q = f.collisionPadding;
              q && (F -= q[1], V += q[3]);
              let G = V - F;
              G > 0 && (G = Math.max(10, G), this.circleDiameter = G)
            } else {
              const F = !((L = f.image) === null || L === void 0) && L.content && (f.image.textFitWidth || f.image.textFitHeight) ? J_(f) : {
                x1: f.left,
                y1: f.top,
                x2: f.right,
                y2: f.bottom
              };
              F.y1 = F.y1 * v - x[0], F.y2 = F.y2 * v + x[2], F.x1 = F.x1 * v - x[3], F.x2 = F.x2 * v + x[1];
              const V = f.collisionPadding;
              if (V && (F.x1 -= V[0] * v, F.y1 -= V[1] * v, F.x2 += V[2] * v, F.y2 += V[3] * v), I) {
                const q = new B(F.x1, F.y1),
                  G = new B(F.x2, F.y1),
                  J = new B(F.x1, F.y2),
                  oe = new B(F.x2, F.y2),
                  De = I * Math.PI / 180;
                q._rotate(De), G._rotate(De), J._rotate(De), oe._rotate(De), F.x1 = Math.min(q.x, G.x, J.x, oe.x), F.x2 = Math.max(q.x, G.x, J.x, oe.x), F.y1 = Math.min(q.y, G.y, J.y, oe.y), F.y2 = Math.max(q.y, G.y, J.y, oe.y)
              }
              t.emplaceBack(r.x, r.y, F.x1, F.y1, F.x2, F.y2, a, c, p)
            }
            this.boxEndIndex = t.length
          }
        }
        class wx {
          constructor(t = [], r = (a, c) => a < c ? -1 : a > c ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: r,
              compare: a
            } = this, c = r[t];
            for (; t > 0;) {
              const p = t - 1 >> 1,
                f = r[p];
              if (a(c, f) >= 0) break;
              r[t] = f, t = p
            }
            r[t] = c
          }
          _down(t) {
            const {
              data: r,
              compare: a
            } = this, c = this.length >> 1, p = r[t];
            for (; t < c;) {
              let f = 1 + (t << 1);
              const v = f + 1;
              if (v < this.length && a(r[v], r[f]) < 0 && (f = v), a(r[f], p) >= 0) break;
              r[t] = r[f], t = f
            }
            r[t] = p
          }
        }

        function Tx(n, t = 1, r = !1) {
          const a = el.fromPoints(n[0]),
            c = Math.min(a.width(), a.height());
          let p = c / 2;
          const f = new wx([], Sx),
            {
              minX: v,
              minY: x,
              maxX: C,
              maxY: I
            } = a;
          if (c === 0) return new B(v, x);
          for (let V = v; V < C; V += c)
            for (let q = x; q < I; q += c) f.push(new nc(V + p, q + p, p, n));
          let L = (function(V) {
              let q = 0,
                G = 0,
                J = 0;
              const oe = V[0];
              for (let De = 0, ve = oe.length, Se = ve - 1; De < ve; Se = De++) {
                const He = oe[De],
                  at = oe[Se],
                  Pt = He.x * at.y - at.x * He.y;
                G += (He.x + at.x) * Pt, J += (He.y + at.y) * Pt, q += 3 * Pt
              }
              return new nc(G / q, J / q, 0, V)
            })(n),
            F = f.length;
          for (; f.length;) {
            const V = f.pop();
            (V.d > L.d || !L.d) && (L = V, r && console.log("found best %d after %d probes", Math.round(1e4 * V.d) / 1e4, F)), V.max - L.d <= t || (p = V.h / 2, f.push(new nc(V.p.x - p, V.p.y - p, p, n)), f.push(new nc(V.p.x + p, V.p.y - p, p, n)), f.push(new nc(V.p.x - p, V.p.y + p, p, n)), f.push(new nc(V.p.x + p, V.p.y + p, p, n)), F += 4)
          }
          return r && (console.log(`num probes: ${F}`), console.log(`best distance: ${L.d}`)), L.p
        }

        function Sx(n, t) {
          return t.max - n.max
        }

        function nc(n, t, r, a) {
          this.p = new B(n, t), this.h = r, this.d = (function(c, p) {
            let f = !1,
              v = 1 / 0;
            for (let x = 0; x < p.length; x++) {
              const C = p[x];
              for (let I = 0, L = C.length, F = L - 1; I < L; F = I++) {
                const V = C[I],
                  q = C[F];
                V.y > c.y != q.y > c.y && c.x < (q.x - V.x) * (c.y - V.y) / (q.y - V.y) + V.x && (f = !f), v = Math.min(v, c_(c, V, q))
              }
            }
            return (f ? 1 : -1) * Math.sqrt(v)
          })(this.p, a), this.max = this.d + this.h * Math.SQRT2
        }
        var ji;
        T.aE = void 0, (ji = T.aE || (T.aE = {}))[ji.center = 1] = "center", ji[ji.left = 2] = "left", ji[ji.right = 3] = "right", ji[ji.top = 4] = "top", ji[ji.bottom = 5] = "bottom", ji[ji["top-left"] = 6] = "top-left", ji[ji["top-right"] = 7] = "top-right", ji[ji["bottom-left"] = 8] = "bottom-left", ji[ji["bottom-right"] = 9] = "bottom-right";
        const vf = Number.POSITIVE_INFINITY;

        function Pg(n, t) {
          return t[1] !== vf ? (function(r, a, c) {
            let p = 0,
              f = 0;
            switch (a = Math.abs(a), c = Math.abs(c), r) {
              case "top-right":
              case "top-left":
              case "top":
                f = c - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                f = 7 - c
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                p = -a;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                p = a
            }
            return [p, f]
          })(n, t[0], t[1]) : (function(r, a) {
            let c = 0,
              p = 0;
            a < 0 && (a = 0);
            const f = a / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                p = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                p = 7 - f;
                break;
              case "bottom":
                p = 7 - a;
                break;
              case "top":
                p = a - 7
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                c = -f;
                break;
              case "top-left":
              case "bottom-left":
                c = f;
                break;
              case "left":
                c = a;
                break;
              case "right":
                c = -a
            }
            return [c, p]
          })(n, t[0])
        }

        function Ig(n, t, r) {
          var a;
          const c = n.layout,
            p = (a = c.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(t, {}, r);
          if (p) {
            const v = p.values,
              x = [];
            for (let C = 0; C < v.length; C += 2) {
              const I = x[C] = v[C],
                L = v[C + 1].map((F => F * wi));
              I.startsWith("top") ? L[1] -= 7 : I.startsWith("bottom") && (L[1] += 7), x[C + 1] = L
            }
            return new Vn(x)
          }
          const f = c.get("text-variable-anchor");
          if (f) {
            let v;
            v = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, r) * wi, vf] : c.get("text-offset").evaluate(t, {}, r).map((C => C * wi));
            const x = [];
            for (const C of f) x.push(C, Pg(C, v));
            return new Vn(x)
          }
          return null
        }

        function yf(n) {
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function Cx(n, t, r, a, c, p, f, v, x, C, I, L) {
          let F = p.textMaxSize.evaluate(t, {});
          F === void 0 && (F = f);
          const V = n.layers[0].layout,
            q = V.get("icon-offset").evaluate(t, {}, I),
            G = Ag(r.horizontal),
            J = f / 24,
            oe = n.tilePixelRatio * J,
            De = n.tilePixelRatio * F / 24,
            ve = n.tilePixelRatio * v,
            Se = n.tilePixelRatio * V.get("symbol-spacing"),
            He = V.get("text-padding") * n.tilePixelRatio,
            at = (function(Ur, Pr, fr, hn = 1) {
              const Jn = Ur.get("icon-padding").evaluate(Pr, {}, fr),
                _i = Jn && Jn.values;
              return [_i[0] * hn, _i[1] * hn, _i[2] * hn, _i[3] * hn]
            })(V, t, I, n.tilePixelRatio),
            Pt = V.get("text-max-angle") / 180 * Math.PI,
            $t = V.get("text-rotation-alignment") !== "viewport" && V.get("symbol-placement") !== "point",
            Bt = V.get("icon-rotation-alignment") === "map" && V.get("symbol-placement") !== "point",
            Zt = V.get("symbol-placement"),
            Tr = Se / 2,
            qt = V.get("icon-text-fit");
          let Ut;
          a && qt !== "none" && (n.allowVerticalPlacement && r.vertical && (Ut = Q_(a, r.vertical, qt, V.get("icon-text-fit-padding"), q, J)), G && (a = Q_(a, G, qt, V.get("icon-text-fit-padding"), q, J)));
          const mt = I ? L.line.getGranularityForZoomLevel(I.z) : 1,
            Nr = (Ur, Pr) => {
              Pr.x < 0 || Pr.x >= ae || Pr.y < 0 || Pr.y >= ae || (function(fr, hn, Jn, _i, Vi, Fa, ha, zi, Hn, Ti, Li, Di, na, Oa, Si, da, gi, Ci, Pi, ci, qn, rs, ic, ns, Mx) {
                const ac = fr.addToLineVertexArray(hn, Jn);
                let tl, sc, oc, lc, Lg = 0,
                  Dg = 0,
                  Rg = 0,
                  Bg = 0,
                  If = -1,
                  Mf = -1;
                const Zs = {};
                let Fg = po("");
                if (fr.allowVerticalPlacement && _i.vertical) {
                  const Wi = zi.layout.get("text-rotate").evaluate(qn, {}, ns) + 90;
                  oc = new Fd(Hn, hn, Ti, Li, Di, _i.vertical, na, Oa, Si, Wi), ha && (lc = new Fd(Hn, hn, Ti, Li, Di, ha, gi, Ci, Si, Wi))
                }
                if (Vi) {
                  const Wi = zi.layout.get("icon-rotate").evaluate(qn, {}),
                    Na = zi.layout.get("icon-text-fit") !== "none",
                    rl = Sg(Vi, Wi, ic, Na),
                    as = ha ? Sg(ha, Wi, ic, Na) : void 0;
                  sc = new Fd(Hn, hn, Ti, Li, Di, Vi, gi, Ci, !1, Wi), Lg = 4 * rl.length;
                  const nl = fr.iconSizeData;
                  let bs = null;
                  nl.kind === "source" ? (bs = [qs * zi.layout.get("icon-size").evaluate(qn, {})], bs[0] > _o && At(`${fr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : nl.kind === "composite" && (bs = [qs * rs.compositeIconSizes[0].evaluate(qn, {}, ns), qs * rs.compositeIconSizes[1].evaluate(qn, {}, ns)], (bs[0] > _o || bs[1] > _o) && At(`${fr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), fr.addSymbols(fr.icon, rl, bs, ci, Pi, qn, T.ao.none, hn, ac.lineStartIndex, ac.lineLength, -1, ns), If = fr.icon.placedSymbolArray.length - 1, as && (Dg = 4 * as.length, fr.addSymbols(fr.icon, as, bs, ci, Pi, qn, T.ao.vertical, hn, ac.lineStartIndex, ac.lineLength, -1, ns), Mf = fr.icon.placedSymbolArray.length - 1)
                }
                const Og = Object.keys(_i.horizontal);
                for (const Wi of Og) {
                  const Na = _i.horizontal[Wi];
                  if (!tl) {
                    Fg = po(Na.text);
                    const as = zi.layout.get("text-rotate").evaluate(qn, {}, ns);
                    tl = new Fd(Hn, hn, Ti, Li, Di, Na, na, Oa, Si, as)
                  }
                  const rl = Na.positionedLines.length === 1;
                  if (Rg += Mg(fr, hn, Na, Fa, zi, Si, qn, da, ac, _i.vertical ? T.ao.horizontal : T.ao.horizontalOnly, rl ? Og : [Wi], Zs, If, rs, ns), rl) break
                }
                _i.vertical && (Bg += Mg(fr, hn, _i.vertical, Fa, zi, Si, qn, da, ac, T.ao.vertical, ["vertical"], Zs, Mf, rs, ns));
                const Ax = tl ? tl.boxStartIndex : fr.collisionBoxArray.length,
                  kx = tl ? tl.boxEndIndex : fr.collisionBoxArray.length,
                  Ex = oc ? oc.boxStartIndex : fr.collisionBoxArray.length,
                  zx = oc ? oc.boxEndIndex : fr.collisionBoxArray.length,
                  Lx = sc ? sc.boxStartIndex : fr.collisionBoxArray.length,
                  Dx = sc ? sc.boxEndIndex : fr.collisionBoxArray.length,
                  Rx = lc ? lc.boxStartIndex : fr.collisionBoxArray.length,
                  Bx = lc ? lc.boxEndIndex : fr.collisionBoxArray.length;
                let is = -1;
                const Nd = (Wi, Na) => Wi && Wi.circleDiameter ? Math.max(Wi.circleDiameter, Na) : Na;
                is = Nd(tl, is), is = Nd(oc, is), is = Nd(sc, is), is = Nd(lc, is);
                const Ng = is > -1 ? 1 : 0;
                Ng && (is *= Mx / wi), fr.glyphOffsetArray.length >= tc.MAX_GLYPHS && At("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), qn.sortKey !== void 0 && fr.addToSortKeyRanges(fr.symbolInstances.length, qn.sortKey);
                const Fx = Ig(zi, qn, ns),
                  [Ox, Nx] = (function(Wi, Na) {
                    const rl = Wi.length,
                      as = Na == null ? void 0 : Na.values;
                    if ((as == null ? void 0 : as.length) > 0)
                      for (let nl = 0; nl < as.length; nl += 2) {
                        const bs = as[nl + 1];
                        Wi.emplaceBack(T.aE[as[nl]], bs[0], bs[1])
                      }
                    return [rl, Wi.length]
                  })(fr.textAnchorOffsets, Fx);
                fr.symbolInstances.emplaceBack(hn.x, hn.y, Zs.right >= 0 ? Zs.right : -1, Zs.center >= 0 ? Zs.center : -1, Zs.left >= 0 ? Zs.left : -1, Zs.vertical || -1, If, Mf, Fg, Ax, kx, Ex, zx, Lx, Dx, Rx, Bx, Ti, Rg, Bg, Lg, Dg, Ng, 0, na, is, Ox, Nx)
              })(n, Pr, Ur, r, a, c, Ut, n.layers[0], n.collisionBoxArray, t.index, t.sourceLayerIndex, n.index, oe, [He, He, He, He], $t, x, ve, at, Bt, q, t, p, C, I, f)
            };
          if (Zt === "line")
            for (const Ur of vg(t.geometry, 0, 0, ae, ae)) {
              const Pr = Qo(Ur, mt),
                fr = bx(Pr, Se, Pt, r.vertical || G, a, 24, De, n.overscaling, ae);
              for (const hn of fr) G && Px(n, G.text, Tr, hn) || Nr(Pr, hn)
            } else if (Zt === "line-center") {
              for (const Ur of t.geometry)
                if (Ur.length > 1) {
                  const Pr = Qo(Ur, mt),
                    fr = xx(Pr, Pt, r.vertical || G, a, 24, De);
                  fr && Nr(Pr, fr)
                }
            } else if (t.type === "Polygon")
            for (const Ur of Bo(t.geometry, 0)) {
              const Pr = Tx(Ur, 16);
              Nr(Qo(Ur[0], mt, !0), new vo(Pr.x, Pr.y, 0))
            } else if (t.type === "LineString")
              for (const Ur of t.geometry) {
                const Pr = Qo(Ur, mt);
                Nr(Pr, new vo(Pr[0].x, Pr[0].y, 0))
              } else if (t.type === "Point")
                for (const Ur of t.geometry)
                  for (const Pr of Ur) Nr([Pr], new vo(Pr.x, Pr.y, 0))
        }

        function Mg(n, t, r, a, c, p, f, v, x, C, I, L, F, V, q) {
          const G = (function(De, ve, Se, He, at, Pt, $t, Bt) {
              const Zt = He.layout.get("text-rotate").evaluate(Pt, {}) * Math.PI / 180,
                Tr = [];
              for (const qt of ve.positionedLines)
                for (const Ut of qt.positionedGlyphs) {
                  if (!Ut.rect) continue;
                  const mt = Ut.rect || {};
                  let Nr = 4,
                    Ur = !0,
                    Pr = 1,
                    fr = 0;
                  const hn = (at || Bt) && Ut.vertical,
                    Jn = Ut.metrics.advance * Ut.scale / 2;
                  if (Bt && ve.verticalizable && (fr = qt.lineOffset / 2 - (Ut.imageName ? -(wi - Ut.metrics.width * Ut.scale) / 2 : (Ut.scale - 1) * wi)), Ut.imageName) {
                    const Ci = $t[Ut.imageName];
                    Ur = Ci.sdf, Pr = Ci.pixelRatio, Nr = 1 / Pr
                  }
                  const _i = at ? [Ut.x + Jn, Ut.y] : [0, 0];
                  let Vi = at ? [0, 0] : [Ut.x + Jn + Se[0], Ut.y + Se[1] - fr],
                    Fa = [0, 0];
                  hn && (Fa = Vi, Vi = [0, 0]);
                  const ha = Ut.metrics.isDoubleResolution ? 2 : 1,
                    zi = (Ut.metrics.left - Nr) * Ut.scale - Jn + Vi[0],
                    Hn = (-Ut.metrics.top - Nr) * Ut.scale + Vi[1],
                    Ti = zi + mt.w / ha * Ut.scale / Pr,
                    Li = Hn + mt.h / ha * Ut.scale / Pr,
                    Di = new B(zi, Hn),
                    na = new B(Ti, Hn),
                    Oa = new B(zi, Li),
                    Si = new B(Ti, Li);
                  if (hn) {
                    const Ci = new B(-Jn, Jn - -17),
                      Pi = -Math.PI / 2,
                      ci = 12 - Jn,
                      qn = new B(22 - ci, -(Ut.imageName ? ci : 0)),
                      rs = new B(...Fa);
                    Di._rotateAround(Pi, Ci)._add(qn)._add(rs), na._rotateAround(Pi, Ci)._add(qn)._add(rs), Oa._rotateAround(Pi, Ci)._add(qn)._add(rs), Si._rotateAround(Pi, Ci)._add(qn)._add(rs)
                  }
                  if (Zt) {
                    const Ci = Math.sin(Zt),
                      Pi = Math.cos(Zt),
                      ci = [Pi, -Ci, Ci, Pi];
                    Di._matMult(ci), na._matMult(ci), Oa._matMult(ci), Si._matMult(ci)
                  }
                  const da = new B(0, 0),
                    gi = new B(0, 0);
                  Tr.push({
                    tl: Di,
                    tr: na,
                    bl: Oa,
                    br: Si,
                    tex: mt,
                    writingMode: ve.writingMode,
                    glyphOffset: _i,
                    sectionIndex: Ut.sectionIndex,
                    isSDF: Ur,
                    pixelOffsetTL: da,
                    pixelOffsetBR: gi,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return Tr
            })(0, r, v, c, p, f, a, n.allowVerticalPlacement),
            J = n.textSizeData;
          let oe = null;
          J.kind === "source" ? (oe = [qs * c.layout.get("text-size").evaluate(f, {})], oe[0] > _o && At(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : J.kind === "composite" && (oe = [qs * V.compositeTextSizes[0].evaluate(f, {}, q), qs * V.compositeTextSizes[1].evaluate(f, {}, q)], (oe[0] > _o || oe[1] > _o) && At(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), n.addSymbols(n.text, G, oe, v, p, f, C, t, x.lineStartIndex, x.lineLength, F, q);
          for (const De of I) L[De] = n.text.placedSymbolArray.length - 1;
          return 4 * G.length
        }

        function Ag(n) {
          for (const t in n) return n[t];
          return null
        }

        function Px(n, t, r, a) {
          const c = n.compareText;
          if (t in c) {
            const p = c[t];
            for (let f = p.length - 1; f >= 0; f--)
              if (a.dist(p[f]) < r) return !0
          } else c[t] = [];
          return c[t].push(a), !1
        }
        const kg = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class xf {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, a] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = a >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const p = kg[15 & a];
            if (!p) throw new Error("Unrecognized array type.");
            const [f] = new Uint16Array(t, 2, 1), [v] = new Uint32Array(t, 4, 1);
            return new xf(v, f, p, t)
          }
          constructor(t, r = 64, a = Float64Array, c) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = a, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const p = kg.indexOf(this.ArrayType),
              f = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              v = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              x = (8 - v % 8) % 8;
            if (p < 0) throw new Error(`Unexpected typed array class: ${a}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + x, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + v + x), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + x, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, r) {
            const a = this._pos >> 1;
            return this.ids[a] = a, this.coords[this._pos++] = t, this.coords[this._pos++] = r, a
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return bf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, r, a, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: p,
              coords: f,
              nodeSize: v
            } = this, x = [0, p.length - 1, 0], C = [];
            for (; x.length;) {
              const I = x.pop() || 0,
                L = x.pop() || 0,
                F = x.pop() || 0;
              if (L - F <= v) {
                for (let J = F; J <= L; J++) {
                  const oe = f[2 * J],
                    De = f[2 * J + 1];
                  oe >= t && oe <= a && De >= r && De <= c && C.push(p[J])
                }
                continue
              }
              const V = F + L >> 1,
                q = f[2 * V],
                G = f[2 * V + 1];
              q >= t && q <= a && G >= r && G <= c && C.push(p[V]), (I === 0 ? t <= q : r <= G) && (x.push(F), x.push(V - 1), x.push(1 - I)), (I === 0 ? a >= q : c >= G) && (x.push(V + 1), x.push(L), x.push(1 - I))
            }
            return C
          }
          within(t, r, a) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: c,
              coords: p,
              nodeSize: f
            } = this, v = [0, c.length - 1, 0], x = [], C = a * a;
            for (; v.length;) {
              const I = v.pop() || 0,
                L = v.pop() || 0,
                F = v.pop() || 0;
              if (L - F <= f) {
                for (let J = F; J <= L; J++) zg(p[2 * J], p[2 * J + 1], t, r) <= C && x.push(c[J]);
                continue
              }
              const V = F + L >> 1,
                q = p[2 * V],
                G = p[2 * V + 1];
              zg(q, G, t, r) <= C && x.push(c[V]), (I === 0 ? t - a <= q : r - a <= G) && (v.push(F), v.push(V - 1), v.push(1 - I)), (I === 0 ? t + a >= q : r + a >= G) && (v.push(V + 1), v.push(L), v.push(1 - I))
            }
            return x
          }
        }

        function bf(n, t, r, a, c, p) {
          if (c - a <= r) return;
          const f = a + c >> 1;
          Eg(n, t, f, a, c, p), bf(n, t, r, a, f - 1, 1 - p), bf(n, t, r, f + 1, c, 1 - p)
        }

        function Eg(n, t, r, a, c, p) {
          for (; c > a;) {
            if (c - a > 600) {
              const C = c - a + 1,
                I = r - a + 1,
                L = Math.log(C),
                F = .5 * Math.exp(2 * L / 3),
                V = .5 * Math.sqrt(L * F * (C - F) / C) * (I - C / 2 < 0 ? -1 : 1);
              Eg(n, t, r, Math.max(a, Math.floor(r - I * F / C + V)), Math.min(c, Math.floor(r + (C - I) * F / C + V)), p)
            }
            const f = t[2 * r + p];
            let v = a,
              x = c;
            for (ku(n, t, a, r), t[2 * c + p] > f && ku(n, t, a, c); v < x;) {
              for (ku(n, t, v, x), v++, x--; t[2 * v + p] < f;) v++;
              for (; t[2 * x + p] > f;) x--
            }
            t[2 * a + p] === f ? ku(n, t, a, x) : (x++, ku(n, t, x, c)), x <= r && (a = x + 1), r <= x && (c = x - 1)
          }
        }

        function ku(n, t, r, a) {
          wf(n, r, a), wf(t, 2 * r, 2 * a), wf(t, 2 * r + 1, 2 * a + 1)
        }

        function wf(n, t, r) {
          const a = n[t];
          n[t] = n[r], n[r] = a
        }

        function zg(n, t, r, a) {
          const c = n - r,
            p = t - a;
          return c * c + p * p
        }
        var Tf;
        T.cx = void 0, (Tf = T.cx || (T.cx = {})).create = "create", Tf.load = "load", Tf.fullLoad = "fullLoad";
        let Od = null,
          Eu = [];
        const Sf = 1e3 / 60,
          Cf = "loadTime",
          Pf = "fullLoadTime",
          Ix = {
            mark(n) {
              performance.mark(n)
            },
            frame(n) {
              const t = n;
              Od != null && Eu.push(t - Od), Od = t
            },
            clearMetrics() {
              Od = null, Eu = [], performance.clearMeasures(Cf), performance.clearMeasures(Pf);
              for (const n in T.cx) performance.clearMarks(T.cx[n])
            },
            getPerformanceMetrics() {
              performance.measure(Cf, T.cx.create, T.cx.load), performance.measure(Pf, T.cx.create, T.cx.fullLoad);
              const n = performance.getEntriesByName(Cf)[0].duration,
                t = performance.getEntriesByName(Pf)[0].duration,
                r = Eu.length,
                a = 1 / (Eu.reduce(((p, f) => p + f), 0) / r / 1e3),
                c = Eu.filter((p => p > Sf)).reduce(((p, f) => p + (f - Sf) / Sf), 0);
              return {
                loadTime: n,
                fullLoadTime: t,
                fps: a,
                percentDroppedFrames: c / (r + c) * 100,
                totalFrames: r
              }
            }
          };
        T.$ = ae, T.A = Ie, T.B = function([n, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, {
            x: n * Math.cos(t) * Math.sin(r),
            y: n * Math.sin(t) * Math.sin(r),
            z: n * Math.cos(r)
          }
        }, T.C = Za, T.D = vr, T.E = kt, T.F = $n, T.G = Go, T.H = function(n) {
          if (rr == null) {
            const t = n.navigator ? n.navigator.userAgent : null;
            rr = !!n.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return rr
        }, T.I = of, T.J = class {
          constructor(n, t) {
            this.target = n, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new gx((() => this.process())), this.subscription = Gr(this.target, "message", (r => this.receive(r)), !1), this.globalScope = Xt(self) ? n : window
          }
          registerMessageHandler(n, t) {
            this.messageHandlers[n] = t
          }
          sendAsync(n, t) {
            return new Promise(((r, a) => {
              const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                p = t ? Gr(t.signal, "abort", (() => {
                  p == null || p.unsubscribe(), delete this.resolveRejects[c];
                  const x = {
                    id: c,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: n.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(x)
                }), vx) : null;
              this.resolveRejects[c] = {
                resolve: x => {
                  p == null || p.unsubscribe(), r(x)
                },
                reject: x => {
                  p == null || p.unsubscribe(), a(x)
                }
              };
              const f = [],
                v = Object.assign(Object.assign({}, n), {
                  id: c,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: so(n.data, f)
                });
              this.target.postMessage(v, {
                transfer: f
              })
            }))
          }
          receive(n) {
            const t = n.data,
              r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const a = this.abortControllers[r];
                return delete this.abortControllers[r], void(a && a.abort())
              }
              if (Xt(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const n = this.taskQueue.shift(),
              t = this.tasks[n];
            delete this.tasks[n], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(n, t)
          }
          processTask(n, t) {
            return o(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const c = this.resolveRejects[n];
                return delete this.resolveRejects[n], c ? void(t.error ? c.reject(Fs(t.error)) : c.resolve(Fs(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(n, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = Fs(t.data),
                a = new AbortController;
              this.abortControllers[n] = a;
              try {
                const c = yield this.messageHandlers[t.type](t.sourceMapId, r, a);
                this.completeTask(n, null, c)
              } catch (c) {
                this.completeTask(n, c)
              }
            }))
          }
          completeTask(n, t, r) {
            const a = [];
            delete this.abortControllers[n];
            const c = {
              id: n,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? so(t) : null,
              data: so(r, a)
            };
            this.target.postMessage(c, {
              transfer: a
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, T.K = Y, T.L = function() {
          var n = new Ie(16);
          return Ie != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n
        }, T.M = function(n, t, r) {
          var a, c, p, f, v, x, C, I, L, F, V, q, G = r[0],
            J = r[1],
            oe = r[2];
          return t === n ? (n[12] = t[0] * G + t[4] * J + t[8] * oe + t[12], n[13] = t[1] * G + t[5] * J + t[9] * oe + t[13], n[14] = t[2] * G + t[6] * J + t[10] * oe + t[14], n[15] = t[3] * G + t[7] * J + t[11] * oe + t[15]) : (c = t[1], p = t[2], f = t[3], v = t[4], x = t[5], C = t[6], I = t[7], L = t[8], F = t[9], V = t[10], q = t[11], n[0] = a = t[0], n[1] = c, n[2] = p, n[3] = f, n[4] = v, n[5] = x, n[6] = C, n[7] = I, n[8] = L, n[9] = F, n[10] = V, n[11] = q, n[12] = a * G + v * J + L * oe + t[12], n[13] = c * G + x * J + F * oe + t[13], n[14] = p * G + C * J + V * oe + t[14], n[15] = f * G + I * J + q * oe + t[15]), n
        }, T.N = function(n, t, r) {
          var a = r[0],
            c = r[1],
            p = r[2];
          return n[0] = t[0] * a, n[1] = t[1] * a, n[2] = t[2] * a, n[3] = t[3] * a, n[4] = t[4] * c, n[5] = t[5] * c, n[6] = t[6] * c, n[7] = t[7] * c, n[8] = t[8] * p, n[9] = t[9] * p, n[10] = t[10] * p, n[11] = t[11] * p, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, T.O = function(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = t[3],
            v = t[4],
            x = t[5],
            C = t[6],
            I = t[7],
            L = t[8],
            F = t[9],
            V = t[10],
            q = t[11],
            G = t[12],
            J = t[13],
            oe = t[14],
            De = t[15],
            ve = r[0],
            Se = r[1],
            He = r[2],
            at = r[3];
          return n[0] = ve * a + Se * v + He * L + at * G, n[1] = ve * c + Se * x + He * F + at * J, n[2] = ve * p + Se * C + He * V + at * oe, n[3] = ve * f + Se * I + He * q + at * De, n[4] = (ve = r[4]) * a + (Se = r[5]) * v + (He = r[6]) * L + (at = r[7]) * G, n[5] = ve * c + Se * x + He * F + at * J, n[6] = ve * p + Se * C + He * V + at * oe, n[7] = ve * f + Se * I + He * q + at * De, n[8] = (ve = r[8]) * a + (Se = r[9]) * v + (He = r[10]) * L + (at = r[11]) * G, n[9] = ve * c + Se * x + He * F + at * J, n[10] = ve * p + Se * C + He * V + at * oe, n[11] = ve * f + Se * I + He * q + at * De, n[12] = (ve = r[12]) * a + (Se = r[13]) * v + (He = r[14]) * L + (at = r[15]) * G, n[13] = ve * c + Se * x + He * F + at * J, n[14] = ve * p + Se * C + He * V + at * oe, n[15] = ve * f + Se * I + He * q + at * De, n
        }, T.P = B, T.Q = function(n, t) {
          const r = {};
          for (let a = 0; a < t.length; a++) {
            const c = t[a];
            c in n && (r[c] = n[c])
          }
          return r
        }, T.R = ua, T.S = go, T.T = Xp, T.U = cg, T.V = lg, T.W = Ee, T.X = ze, T.Y = ur, T.Z = Ba, T._ = o, T.a = j, T.a$ = $e, T.a0 = function(n, t) {
          var r, a, c, p;
          if (!n) return t ?? {};
          if (!t) return n;
          const f = Object.assign({}, n);
          if (t.removeAll && (f.removeAll = !0), t.remove) {
            const v = new Set(f.remove ? f.remove.concat(t.remove) : t.remove);
            f.remove = Array.from(v.values())
          }
          if (t.add) {
            const v = f.add ? f.add.concat(t.add) : t.add,
              x = new Map(v.map((C => [C.id, C])));
            f.add = Array.from(x.values())
          }
          if (t.update) {
            const v = new Map((r = f.update) === null || r === void 0 ? void 0 : r.map((x => [x.id, x])));
            for (const x of t.update) {
              const C = (a = v.get(x.id)) !== null && a !== void 0 ? a : {
                id: x.id
              };
              x.newGeometry && (C.newGeometry = x.newGeometry), x.addOrUpdateProperties && (C.addOrUpdateProperties = ((c = C.addOrUpdateProperties) !== null && c !== void 0 ? c : []).concat(x.addOrUpdateProperties)), x.removeProperties && (C.removeProperties = ((p = C.removeProperties) !== null && p !== void 0 ? p : []).concat(x.removeProperties)), x.removeAllProperties && (C.removeAllProperties = !0), v.set(x.id, C)
            }
            f.update = Array.from(v.values())
          }
          return f
        }, T.a1 = Mu, T.a2 = el, T.a3 = 25, T.a4 = gf, T.a5 = n => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((r => {
            t.onloadstart = () => {
              r(t)
            };
            for (const a of n) {
              const c = window.document.createElement("source");
              Me(a) || (t.crossOrigin = "Anonymous"), c.src = a, t.appendChild(c)
            }
          }))
        }, T.a6 = yt, T.a7 = function() {
          return vt++
        }, T.a8 = D, T.a9 = tc, T.aA = function(n) {
          let t = 1 / 0,
            r = 1 / 0,
            a = -1 / 0,
            c = -1 / 0;
          for (const p of n) t = Math.min(t, p.x), r = Math.min(r, p.y), a = Math.max(a, p.x), c = Math.max(c, p.y);
          return [t, r, a, c]
        }, T.aB = wi, T.aC = ke, T.aD = function(n, t, r, a, c = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const p = c ? a === "map" ? -n.bearingInRadians : 0 : a === "viewport" ? n.bearingInRadians : 0;
          if (p) {
            const f = Math.sin(p),
              v = Math.cos(p);
            r = [r[0] * v - r[1] * f, r[0] * f + r[1] * v]
          }
          return [c ? r[0] : ke(t, r[0], n.zoom), c ? r[1] : ke(t, r[1], n.zoom)]
        }, T.aF = uf, T.aG = yf, T.aH = cf, T.aI = xf, T.aJ = ei, T.aK = Md, T.aL = pe, T.aM = Kr, T.aN = Ln, T.aO = ot, T.aP = Sr, T.aQ = hg, T.aR = Fe, T.aS = Je, T.aT = function(n) {
          var t = new Ie(3);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t
        }, T.aU = function(n, t, r) {
          return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], n
        }, T.aV = function(n, t) {
          var r = t[0],
            a = t[1],
            c = t[2],
            p = r * r + a * a + c * c;
          return p > 0 && (p = 1 / Math.sqrt(p)), n[0] = t[0] * p, n[1] = t[1] * p, n[2] = t[2] * p, n
        }, T.aW = it, T.aX = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]
        }, T.aY = function(n, t, r) {
          return n[0] = t[0] * r[0], n[1] = t[1] * r[1], n[2] = t[2] * r[2], n[3] = t[3] * r[3], n
        }, T.aZ = qe, T.a_ = function(n, t, r) {
          const a = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return a === 0 ? null : (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / a
        }, T.aa = Ds, T.ab = ts, T.ac = mg, T.ad = function(n) {
          const t = {};
          if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, a, c, p) => {
              const f = c || p;
              return t[a] = !f || f.toLowerCase(), ""
            })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r
          }
          return t
        }, T.ae = xr, T.af = function(n) {
          return Math.pow(2, n)
        }, T.ag = st, T.ah = Dt, T.ai = 85.051129, T.aj = ug, T.ak = function(n) {
          return Math.log(n) / Math.LN2
        }, T.al = function(n) {
          var t = n[0],
            r = n[1];
          return t * t + r * r
        }, T.am = function(n, t) {
          const r = [];
          for (const a in n) a in t || r.push(a);
          return r
        }, T.an = function(n, t) {
          let r = 0,
            a = 0;
          if (n.kind === "constant") a = n.layoutSize;
          else if (n.kind !== "source") {
            const {
              interpolationType: c,
              minZoom: p,
              maxZoom: f
            } = n, v = c ? Dt(Ei.interpolationFactor(c, t, p, f), 0, 1) : 0;
            n.kind === "camera" ? a = Za.number(n.minSize, n.maxSize, v) : r = v
          }
          return {
            uSizeT: r,
            uSize: a
          }
        }, T.ap = function(n, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: a,
          upperSize: c
        }) {
          return n.kind === "source" ? a / qs : n.kind === "composite" ? Za.number(a / qs, c / qs, r) : t
        }, T.aq = function(n, t) {
          var r = t[0],
            a = t[1],
            c = t[2],
            p = t[3],
            f = t[4],
            v = t[5],
            x = t[6],
            C = t[7],
            I = t[8],
            L = t[9],
            F = t[10],
            V = t[11],
            q = t[12],
            G = t[13],
            J = t[14],
            oe = t[15],
            De = r * v - a * f,
            ve = r * x - c * f,
            Se = r * C - p * f,
            He = a * x - c * v,
            at = a * C - p * v,
            Pt = c * C - p * x,
            $t = I * G - L * q,
            Bt = I * J - F * q,
            Zt = I * oe - V * q,
            Tr = L * J - F * G,
            qt = L * oe - V * G,
            Ut = F * oe - V * J,
            mt = De * Ut - ve * qt + Se * Tr + He * Zt - at * Bt + Pt * $t;
          return mt ? (n[0] = (v * Ut - x * qt + C * Tr) * (mt = 1 / mt), n[1] = (c * qt - a * Ut - p * Tr) * mt, n[2] = (G * Pt - J * at + oe * He) * mt, n[3] = (F * at - L * Pt - V * He) * mt, n[4] = (x * Zt - f * Ut - C * Bt) * mt, n[5] = (r * Ut - c * Zt + p * Bt) * mt, n[6] = (J * Se - q * Pt - oe * ve) * mt, n[7] = (I * Pt - F * Se + V * ve) * mt, n[8] = (f * qt - v * Zt + C * $t) * mt, n[9] = (a * Zt - r * qt - p * $t) * mt, n[10] = (q * at - G * Se + oe * De) * mt, n[11] = (L * Se - I * at - V * De) * mt, n[12] = (v * Bt - f * Tr - x * $t) * mt, n[13] = (r * Tr - a * Bt + c * $t) * mt, n[14] = (G * ve - q * He - J * De) * mt, n[15] = (I * He - L * ve + F * De) * mt, n) : null
        }, T.ar = re, T.as = function(n) {
          return Math.hypot(n[0], n[1])
        }, T.at = function(n) {
          return n[0] = 0, n[1] = 0, n
        }, T.au = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n
        }, T.av = hf, T.aw = Ae, T.ax = function(n, t, r, a) {
          const c = t.y - n.y,
            p = t.x - n.x,
            f = a.y - r.y,
            v = a.x - r.x,
            x = f * p - v * c;
          if (x === 0) return null;
          const C = (v * (n.y - r.y) - f * (n.x - r.x)) / x;
          return new B(n.x + C * p, n.y + C * c)
        }, T.ay = vg, T.az = o_, T.b = er, T.b$ = class extends h {}, T.b0 = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[3] = t[3] * r, n
        }, T.b1 = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3]
        }, T.b2 = pg, T.b3 = rc, T.b4 = function(n, t, r, a, c) {
          var p, f = 1 / Math.tan(t / 2);
          return n[0] = f / r, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = f, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, c != null && c !== 1 / 0 ? (n[10] = (c + a) * (p = 1 / (a - c)), n[14] = 2 * c * a * p) : (n[10] = -1, n[14] = -2 * a), n
        }, T.b5 = function(n) {
          var t = new Ie(16);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
        }, T.b6 = function(n, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[0],
            f = t[1],
            v = t[2],
            x = t[3],
            C = t[4],
            I = t[5],
            L = t[6],
            F = t[7];
          return t !== n && (n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = p * c + C * a, n[1] = f * c + I * a, n[2] = v * c + L * a, n[3] = x * c + F * a, n[4] = C * c - p * a, n[5] = I * c - f * a, n[6] = L * c - v * a, n[7] = F * c - x * a, n
        }, T.b7 = function(n, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[4],
            f = t[5],
            v = t[6],
            x = t[7],
            C = t[8],
            I = t[9],
            L = t[10],
            F = t[11];
          return t !== n && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[4] = p * c + C * a, n[5] = f * c + I * a, n[6] = v * c + L * a, n[7] = x * c + F * a, n[8] = C * c - p * a, n[9] = I * c - f * a, n[10] = L * c - v * a, n[11] = F * c - x * a, n
        }, T.b8 = function() {
          const n = new Float32Array(16);
          return st(n), n
        }, T.b9 = function() {
          const n = new Float64Array(16);
          return st(n), n
        }, T.bA = function(n, t) {
          const r = Le(n, 360),
            a = Le(t, 360),
            c = a - r,
            p = a > r ? c - 360 : c + 360;
          return Math.abs(c) < Math.abs(p) ? c : p
        }, T.bB = function(n) {
          return n[0] = 0, n[1] = 0, n[2] = 0, n
        }, T.bC = function(n, t, r, a) {
          const c = Math.sqrt(n * n + t * t),
            p = Math.sqrt(r * r + a * a);
          n /= c, t /= c, r /= p, a /= p;
          const f = Math.acos(n * r + t * a);
          return -t * r + n * a > 0 ? f : -f
        }, T.bD = function(n, t) {
          const r = Le(n, 2 * Math.PI),
            a = Le(t, 2 * Math.PI);
          return Math.min(Math.abs(r - a), Math.abs(r - a + 2 * Math.PI), Math.abs(r - a - 2 * Math.PI))
        }, T.bE = function() {
          const n = {},
            t = xe.$version;
          for (const r in xe.$root) {
            const a = xe.$root[r];
            if (a.required) {
              let c = null;
              c = r === "version" ? t : a.type === "array" ? [] : {}, c != null && (n[r] = c)
            }
          }
          return n
        }, T.bF = Fl, T.bG = he, T.bH = function n(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let a = 0; a < t.length; a++)
              if (!n(t[a], r[a])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
            for (const a in t)
              if (!n(t[a], r[a])) return !1;
            return !0
          }
          return t === r
        }, T.bI = function(n) {
          n = n.slice();
          const t = Object.create(null);
          for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
          for (let r = 0; r < n.length; r++) "ref" in n[r] && (n[r] = Jt(n[r], t[n[r].ref]));
          return n
        }, T.bJ = function(n) {
          if (n.type === "custom") return new _x(n);
          switch (n.type) {
            case "background":
              return new px(n);
            case "circle":
              return new J0(n);
            case "color-relief":
              return new iy(n);
            case "fill":
              return new yy(n);
            case "fill-extrusion":
              return new ky(n);
            case "heatmap":
              return new ey(n);
            case "hillshade":
              return new ry(n);
            case "line":
              return new Fy(n);
            case "raster":
              return new mx(n);
            case "symbol":
              return new Ld(n)
          }
        }, T.bK = xt, T.bL = function(n, t) {
          if (!n) return [{
            command: "setStyle",
            args: [t]
          }];
          let r = [];
          try {
            if (!jt(n.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            jt(n.center, t.center) || r.push({
              command: "setCenter",
              args: [t.center]
            }), jt(n.state, t.state) || r.push({
              command: "setGlobalState",
              args: [t.state]
            }), jt(n.centerAltitude, t.centerAltitude) || r.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), jt(n.zoom, t.zoom) || r.push({
              command: "setZoom",
              args: [t.zoom]
            }), jt(n.bearing, t.bearing) || r.push({
              command: "setBearing",
              args: [t.bearing]
            }), jt(n.pitch, t.pitch) || r.push({
              command: "setPitch",
              args: [t.pitch]
            }), jt(n.roll, t.roll) || r.push({
              command: "setRoll",
              args: [t.roll]
            }), jt(n.sprite, t.sprite) || r.push({
              command: "setSprite",
              args: [t.sprite]
            }), jt(n.glyphs, t.glyphs) || r.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), jt(n.transition, t.transition) || r.push({
              command: "setTransition",
              args: [t.transition]
            }), jt(n.light, t.light) || r.push({
              command: "setLight",
              args: [t.light]
            }), jt(n.terrain, t.terrain) || r.push({
              command: "setTerrain",
              args: [t.terrain]
            }), jt(n.sky, t.sky) || r.push({
              command: "setSky",
              args: [t.sky]
            }), jt(n.projection, t.projection) || r.push({
              command: "setProjection",
              args: [t.projection]
            });
            const a = {},
              c = [];
            (function(f, v, x, C) {
              let I;
              for (I in v = v || {}, f = f || {}) Object.prototype.hasOwnProperty.call(f, I) && (Object.prototype.hasOwnProperty.call(v, I) || en(I, x, C));
              for (I in v) Object.prototype.hasOwnProperty.call(v, I) && (Object.prototype.hasOwnProperty.call(f, I) ? jt(f[I], v[I]) || (f[I].type === "geojson" && v[I].type === "geojson" && Ht(f, v, I) ? hr(x, {
                command: "setGeoJSONSourceData",
                args: [I, v[I].data]
              }) : tr(I, v, x, C)) : $r(I, v, x))
            })(n.sources, t.sources, c, a);
            const p = [];
            n.layers && n.layers.forEach((f => {
              "source" in f && a[f.source] ? r.push({
                command: "removeLayer",
                args: [f.id]
              }) : p.push(f)
            })), r = r.concat(c), (function(f, v, x) {
              v = v || [];
              const C = (f = f || []).map(ar),
                I = v.map(ar),
                L = f.reduce(qr, {}),
                F = v.reduce(qr, {}),
                V = C.slice(),
                q = Object.create(null);
              let G, J, oe, De, ve;
              for (let Se = 0, He = 0; Se < C.length; Se++) G = C[Se], Object.prototype.hasOwnProperty.call(F, G) ? He++ : (hr(x, {
                command: "removeLayer",
                args: [G]
              }), V.splice(V.indexOf(G, He), 1));
              for (let Se = 0, He = 0; Se < I.length; Se++) G = I[I.length - 1 - Se], V[V.length - 1 - Se] !== G && (Object.prototype.hasOwnProperty.call(L, G) ? (hr(x, {
                command: "removeLayer",
                args: [G]
              }), V.splice(V.lastIndexOf(G, V.length - He), 1)) : He++, De = V[V.length - Se], hr(x, {
                command: "addLayer",
                args: [F[G], De]
              }), V.splice(V.length - Se, 0, G), q[G] = !0);
              for (let Se = 0; Se < I.length; Se++)
                if (G = I[Se], J = L[G], oe = F[G], !q[G] && !jt(J, oe))
                  if (jt(J.source, oe.source) && jt(J["source-layer"], oe["source-layer"]) && jt(J.type, oe.type)) {
                    for (ve in Yt(J.layout, oe.layout, x, G, null, "setLayoutProperty"), Yt(J.paint, oe.paint, x, G, null, "setPaintProperty"), jt(J.filter, oe.filter) || hr(x, {
                        command: "setFilter",
                        args: [G, oe.filter]
                      }), jt(J.minzoom, oe.minzoom) && jt(J.maxzoom, oe.maxzoom) || hr(x, {
                        command: "setLayerZoomRange",
                        args: [G, oe.minzoom, oe.maxzoom]
                      }), J) Object.prototype.hasOwnProperty.call(J, ve) && ve !== "layout" && ve !== "paint" && ve !== "filter" && ve !== "metadata" && ve !== "minzoom" && ve !== "maxzoom" && (ve.indexOf("paint.") === 0 ? Yt(J[ve], oe[ve], x, G, ve.slice(6), "setPaintProperty") : jt(J[ve], oe[ve]) || hr(x, {
                      command: "setLayerProperty",
                      args: [G, ve, oe[ve]]
                    }));
                    for (ve in oe) Object.prototype.hasOwnProperty.call(oe, ve) && !Object.prototype.hasOwnProperty.call(J, ve) && ve !== "layout" && ve !== "paint" && ve !== "filter" && ve !== "metadata" && ve !== "minzoom" && ve !== "maxzoom" && (ve.indexOf("paint.") === 0 ? Yt(J[ve], oe[ve], x, G, ve.slice(6), "setPaintProperty") : jt(J[ve], oe[ve]) || hr(x, {
                      command: "setLayerProperty",
                      args: [G, ve, oe[ve]]
                    }))
                  } else hr(x, {
                    command: "removeLayer",
                    args: [G]
                  }), De = V[V.lastIndexOf(G) + 1], hr(x, {
                    command: "addLayer",
                    args: [oe, De]
                  })
            })(p, t.layers, r)
          } catch (a) {
            console.warn("Unable to compute style diff:", a), r = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return r
        }, T.bM = function(n) {
          const t = [],
            r = n.id;
          return r === void 0 && t.push({
            message: `layers.${r}: missing required property "id"`
          }), n.render === void 0 && t.push({
            message: `layers.${r}: missing required method "render"`
          }), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, T.bN = ft, T.bO = Tt, T.bP = class extends Hi {
          constructor(n, t) {
            super(n, t), this.current = 0
          }
          set(n) {
            this.current !== n && (this.current = n, this.gl.uniform1i(this.location, n))
          }
        }, T.bQ = mi, T.bR = class extends Hi {
          constructor(n, t) {
            super(n, t), this.current = ba
          }
          set(n) {
            if (n[12] !== this.current[12] || n[0] !== this.current[0]) return this.current = n, void this.gl.uniformMatrix4fv(this.location, !1, n);
            for (let t = 1; t < 16; t++)
              if (n[t] !== this.current[t]) {
                this.current = n, this.gl.uniformMatrix4fv(this.location, !1, n);
                break
              }
          }
        }, T.bS = oi, T.bT = class extends Hi {
          constructor(n, t) {
            super(n, t), this.current = [0, 0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n, this.gl.uniform3f(this.location, n[0], n[1], n[2]))
          }
        }, T.bU = class extends Hi {
          constructor(n, t) {
            super(n, t), this.current = [0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n, this.gl.uniform2f(this.location, n[0], n[1]))
          }
        }, T.bV = Oe, T.bW = function(n, t) {
          var r = Math.sin(t),
            a = Math.cos(t);
          return n[0] = a, n[1] = r, n[2] = 0, n[3] = -r, n[4] = a, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n
        }, T.bX = function(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2];
          return n[0] = a * r[0] + c * r[3] + p * r[6], n[1] = a * r[1] + c * r[4] + p * r[7], n[2] = a * r[2] + c * r[5] + p * r[8], n
        }, T.bY = function(n, t, r, a, c, p, f) {
          var v = 1 / (t - r),
            x = 1 / (a - c),
            C = 1 / (p - f);
          return n[0] = -2 * v, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * x, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * C, n[11] = 0, n[12] = (t + r) * v, n[13] = (c + a) * x, n[14] = (f + p) * C, n[15] = 1, n
        }, T.bZ = class extends Hi {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(4 * n.length);
              for (let r = 0; r < n.length; r++) t[4 * r] = n[r].r, t[4 * r + 1] = n[r].g, t[4 * r + 2] = n[r].b, t[4 * r + 3] = n[r].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, T.b_ = class extends Hi {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(n);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, T.ba = function() {
          return new Float64Array(16)
        }, T.bb = function(n, t, r) {
          const a = new Float64Array(4);
          return Q(a, n, t - 90, r), a
        }, T.bc = function(n, t, r, a) {
          var c, p, f, v, x, C = t[0],
            I = t[1],
            L = t[2],
            F = t[3],
            V = r[0],
            q = r[1],
            G = r[2],
            J = r[3];
          return (p = C * V + I * q + L * G + F * J) < 0 && (p = -p, V = -V, q = -q, G = -G, J = -J), 1 - p > Re ? (c = Math.acos(p), f = Math.sin(c), v = Math.sin((1 - a) * c) / f, x = Math.sin(a * c) / f) : (v = 1 - a, x = a), n[0] = v * C + x * V, n[1] = v * I + x * q, n[2] = v * L + x * G, n[3] = v * F + x * J, n
        }, T.bd = function(n) {
          const t = new Float64Array(9);
          var r, a, c, p, f, v, x, C, I, L, F, V, q, G, J, oe, De, ve;
          L = (c = (a = n)[0]) * (x = c + c), F = (p = a[1]) * x, q = (f = a[2]) * x, G = f * (C = p + p), oe = (v = a[3]) * x, De = v * C, ve = v * (I = f + f), (r = t)[0] = 1 - (V = p * C) - (J = f * I), r[3] = F - ve, r[6] = q + De, r[1] = F + ve, r[4] = 1 - L - J, r[7] = G - oe, r[2] = q - De, r[5] = G + oe, r[8] = 1 - L - V;
          const Se = Sr(-Math.asin(Dt(t[2], -1, 1)));
          let He, at;
          return Math.hypot(t[5], t[8]) < .001 ? (He = 0, at = -Sr(Math.atan2(t[3], t[4]))) : (He = Sr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), at = Sr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: He,
            pitch: Se + 90,
            bearing: at
          }
        }, T.be = function(n, t) {
          return n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing
        }, T.bf = sr, T.bg = vs, T.bh = Kl, T.bi = wu, T.bj = Yl, T.bk = lt, T.bl = We, T.bm = pi, T.bn = function(n, t, r, a, c) {
          return lt(a, c, Dt((n - t) / (r - t), 0, 1))
        }, T.bo = Le, T.bp = function() {
          return new Float64Array(3)
        }, T.bq = function(n, t, r, a) {
          return n[0] = t[0] + r[0] * a, n[1] = t[1] + r[1] * a, n[2] = t[2] + r[2] * a, n
        }, T.br = Q, T.bs = function(n, t, r) {
          var a = r[0],
            c = r[1],
            p = r[2],
            f = t[0],
            v = t[1],
            x = t[2],
            C = c * x - p * v,
            I = p * f - a * x,
            L = a * v - c * f,
            F = c * L - p * I,
            V = p * C - a * L,
            q = a * I - c * C,
            G = 2 * r[3];
          return I *= G, L *= G, V *= 2, q *= 2, n[0] = f + (C *= G) + (F *= 2), n[1] = v + I + V, n[2] = x + L + q, n
        }, T.bt = function(n, t, r) {
          const a = (c = [n[0], n[1], n[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((I = c[8]) * (f = c[4]) - (v = c[5]) * (C = c[7])) + c[1] * (-I * (p = c[3]) + v * (x = c[6])) + c[2] * (C * p - f * x);
          var c, p, f, v, x, C, I;
          if (a === 0) return null;
          const L = it([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
            F = it([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]),
            V = it([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]),
            q = Fe([], L, -n[3]);
          return Je(q, q, Fe([], F, -t[3])), Je(q, q, Fe([], V, -r[3])), Fe(q, q, 1 / a), q
        }, T.bu = mf, T.bv = function() {
          return new Float64Array(4)
        }, T.bw = function(n, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[0] * Math.cos(a) - c[1] * Math.sin(a), p[1] = c[0] * Math.sin(a) + c[1] * Math.cos(a), p[2] = c[2], n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n
        }, T.bx = function(n, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[0], p[1] = c[1] * Math.cos(a) - c[2] * Math.sin(a), p[2] = c[1] * Math.sin(a) + c[2] * Math.cos(a), n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n
        }, T.by = function(n, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[2] * Math.sin(a) + c[0] * Math.cos(a), p[1] = c[1], p[2] = c[2] * Math.cos(a) - c[0] * Math.sin(a), n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n
        }, T.bz = function(n, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[0],
            f = t[1],
            v = t[2],
            x = t[3],
            C = t[8],
            I = t[9],
            L = t[10],
            F = t[11];
          return t !== n && (n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = p * c - C * a, n[1] = f * c - I * a, n[2] = v * c - L * a, n[3] = x * c - F * a, n[8] = p * a + C * c, n[9] = f * a + I * c, n[10] = v * a + L * c, n[11] = x * a + F * c, n
        }, T.c = ue, T.c0 = Vy, T.c1 = class extends i {}, T.c2 = Wp, T.c3 = function(n) {
          return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
        }, T.c4 = g_, T.c5 = function(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            f = r[3] * a + r[7] * c + r[11] * p + r[15];
          return n[0] = (r[0] * a + r[4] * c + r[8] * p + r[12]) / (f = f || 1), n[1] = (r[1] * a + r[5] * c + r[9] * p + r[13]) / f, n[2] = (r[2] * a + r[6] * c + r[10] * p + r[14]) / f, n
        }, T.c6 = class extends hu {}, T.c7 = class extends P {}, T.c8 = function(n, t) {
          return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15]
        }, T.c9 = function(n, t) {
          var r = n[0],
            a = n[1],
            c = n[2],
            p = n[3],
            f = n[4],
            v = n[5],
            x = n[6],
            C = n[7],
            I = n[8],
            L = n[9],
            F = n[10],
            V = n[11],
            q = n[12],
            G = n[13],
            J = n[14],
            oe = n[15],
            De = t[0],
            ve = t[1],
            Se = t[2],
            He = t[3],
            at = t[4],
            Pt = t[5],
            $t = t[6],
            Bt = t[7],
            Zt = t[8],
            Tr = t[9],
            qt = t[10],
            Ut = t[11],
            mt = t[12],
            Nr = t[13],
            Ur = t[14],
            Pr = t[15];
          return Math.abs(r - De) <= Re * Math.max(1, Math.abs(r), Math.abs(De)) && Math.abs(a - ve) <= Re * Math.max(1, Math.abs(a), Math.abs(ve)) && Math.abs(c - Se) <= Re * Math.max(1, Math.abs(c), Math.abs(Se)) && Math.abs(p - He) <= Re * Math.max(1, Math.abs(p), Math.abs(He)) && Math.abs(f - at) <= Re * Math.max(1, Math.abs(f), Math.abs(at)) && Math.abs(v - Pt) <= Re * Math.max(1, Math.abs(v), Math.abs(Pt)) && Math.abs(x - $t) <= Re * Math.max(1, Math.abs(x), Math.abs($t)) && Math.abs(C - Bt) <= Re * Math.max(1, Math.abs(C), Math.abs(Bt)) && Math.abs(I - Zt) <= Re * Math.max(1, Math.abs(I), Math.abs(Zt)) && Math.abs(L - Tr) <= Re * Math.max(1, Math.abs(L), Math.abs(Tr)) && Math.abs(F - qt) <= Re * Math.max(1, Math.abs(F), Math.abs(qt)) && Math.abs(V - Ut) <= Re * Math.max(1, Math.abs(V), Math.abs(Ut)) && Math.abs(q - mt) <= Re * Math.max(1, Math.abs(q), Math.abs(mt)) && Math.abs(G - Nr) <= Re * Math.max(1, Math.abs(G), Math.abs(Nr)) && Math.abs(J - Ur) <= Re * Math.max(1, Math.abs(J), Math.abs(Ur)) && Math.abs(oe - Pr) <= Re * Math.max(1, Math.abs(oe), Math.abs(Pr))
        }, T.cA = function(n, t) {
          j.REGISTERED_PROTOCOLS[n] = t
        }, T.cB = function(n) {
          delete j.REGISTERED_PROTOCOLS[n]
        }, T.cC = function(n, t) {
          const r = {};
          for (let c = 0; c < n.length; c++) {
            const p = t && t[n[c].id] || Bp(n[c]);
            t && (t[n[c].id] = p);
            let f = r[p];
            f || (f = r[p] = []), f.push(n[c])
          }
          const a = [];
          for (const c in r) a.push(r[c]);
          return a
        }, T.cD = Qt, T.cE = fg, T.cF = _g, T.cG = G_, T.cH = function(n) {
          n.bucket.createArrays(), n.bucket.tilePixelRatio = ae / (512 * n.bucket.overscaling), n.bucket.compareText = {}, n.bucket.iconsNeedLinear = !1;
          const t = n.bucket.layers[0],
            r = t.layout,
            a = t._unevaluatedLayout._values,
            c = {
              layoutIconSize: a["icon-size"].possiblyEvaluate(new $n(n.bucket.zoom + 1), n.canonical),
              layoutTextSize: a["text-size"].possiblyEvaluate(new $n(n.bucket.zoom + 1), n.canonical),
              textMaxSize: a["text-size"].possiblyEvaluate(new $n(18))
            };
          if (n.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: C,
              maxZoom: I
            } = n.bucket.textSizeData;
            c.compositeTextSizes = [a["text-size"].possiblyEvaluate(new $n(C), n.canonical), a["text-size"].possiblyEvaluate(new $n(I), n.canonical)]
          }
          if (n.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: C,
              maxZoom: I
            } = n.bucket.iconSizeData;
            c.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new $n(C), n.canonical), a["icon-size"].possiblyEvaluate(new $n(I), n.canonical)]
          }
          const p = r.get("text-line-height") * wi,
            f = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point",
            v = r.get("text-keep-upright"),
            x = r.get("text-size");
          for (const C of n.bucket.features) {
            const I = r.get("text-font").evaluate(C, {}, n.canonical).join(","),
              L = x.evaluate(C, {}, n.canonical),
              F = c.layoutTextSize.evaluate(C, {}, n.canonical),
              V = c.layoutIconSize.evaluate(C, {}, n.canonical),
              q = {
                horizontal: {},
                vertical: void 0
              },
              G = C.text;
            let J, oe = [0, 0];
            if (G) {
              const Se = G.toString(),
                He = r.get("text-letter-spacing").evaluate(C, {}, n.canonical) * wi,
                at = jp(Se) ? He : 0,
                Pt = r.get("text-anchor").evaluate(C, {}, n.canonical),
                $t = Ig(t, C, n.canonical);
              if (!$t) {
                const qt = r.get("text-radial-offset").evaluate(C, {}, n.canonical);
                oe = qt ? Pg(Pt, [qt * wi, vf]) : r.get("text-offset").evaluate(C, {}, n.canonical).map((Ut => Ut * wi))
              }
              let Bt = f ? "center" : r.get("text-justify").evaluate(C, {}, n.canonical);
              const Zt = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(C, {}, n.canonical) * wi : 1 / 0,
                Tr = () => {
                  n.bucket.allowVerticalPlacement && Ol(Se) && (q.vertical = kd(G, n.glyphMap, n.glyphPositions, n.imagePositions, I, Zt, p, Pt, "left", at, oe, T.ao.vertical, !0, F, L))
                };
              if (!f && $t) {
                const qt = new Set;
                if (Bt === "auto")
                  for (let mt = 0; mt < $t.values.length; mt += 2) qt.add(yf($t.values[mt]));
                else qt.add(Bt);
                let Ut = !1;
                for (const mt of qt)
                  if (!q.horizontal[mt])
                    if (Ut) q.horizontal[mt] = q.horizontal[0];
                    else {
                      const Nr = kd(G, n.glyphMap, n.glyphPositions, n.imagePositions, I, Zt, p, "center", mt, at, oe, T.ao.horizontal, !1, F, L);
                      Nr && (q.horizontal[mt] = Nr, Ut = Nr.positionedLines.length === 1)
                    } Tr()
              } else {
                Bt === "auto" && (Bt = yf(Pt));
                const qt = kd(G, n.glyphMap, n.glyphPositions, n.imagePositions, I, Zt, p, Pt, Bt, at, oe, T.ao.horizontal, !1, F, L);
                qt && (q.horizontal[Bt] = qt), Tr(), Ol(Se) && f && v && (q.vertical = kd(G, n.glyphMap, n.glyphPositions, n.imagePositions, I, Zt, p, Pt, Bt, at, oe, T.ao.vertical, !1, F, L))
              }
            }
            let De = !1;
            if (C.icon && C.icon.name) {
              const Se = n.imageMap[C.icon.name];
              Se && (J = cx(n.imagePositions[C.icon.name], r.get("icon-offset").evaluate(C, {}, n.canonical), r.get("icon-anchor").evaluate(C, {}, n.canonical)), De = !!Se.sdf, n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = De : n.bucket.sdfIcons !== De && At("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Se.pixelRatio !== n.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = !0))
            }
            const ve = Ag(q.horizontal) || q.vertical;
            n.bucket.iconsInText = !!ve && ve.iconsInText, (ve || J) && Cx(n.bucket, C, q, J, n.imageMap, c, F, V, oe, De, n.canonical, n.subdivisionGranularity)
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers()
        }, T.cI = nf, T.cJ = ef, T.cK = rf, T.cL = z_, T.cM = sf, T.cN = class {
          constructor(n) {
            this._marks = {
              start: [n.url, "start"].join("#"),
              end: [n.url, "end"].join("#"),
              measure: n.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let n = performance.getEntriesByName(this._marks.measure);
            return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), n = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), n
          }
        }, T.cO = function(n, t, r, a, c) {
          return o(this, void 0, void 0, (function*() {
            if (ze()) try {
              return yield ur(n, t, r, a, c)
            } catch {}
            return (function(p, f, v, x, C) {
              const I = p.width,
                L = p.height;
              yr && Mr || (yr = new OffscreenCanvas(I, L), Mr = yr.getContext("2d", {
                willReadFrequently: !0
              })), yr.width = I, yr.height = L, Mr.drawImage(p, 0, 0, I, L);
              const F = Mr.getImageData(f, v, x, C);
              return Mr.clearRect(0, 0, I, L), F.data
            })(n, t, r, a, c)
          }))
        }, T.cP = x_, T.cQ = N, T.cR = E_, T.cS = Jl, T.cT = jo, T.cU = function(n, t) {
          const r = new Map;
          if (n != null)
            if (n.type === "Feature") r.set(Au(n, t), n);
            else
              for (const a of n.features) r.set(Au(a, t), a);
          return r
        }, T.cV = function(n, t) {
          if (n == null) return !0;
          if (n.type === "Feature") return Au(n, t) != null;
          if (n.type === "FeatureCollection") {
            const r = new Set;
            for (const a of n.features) {
              const c = Au(a, t);
              if (c == null || r.has(c)) return !1;
              r.add(c)
            }
            return !0
          }
          return !1
        }, T.cW = function(n, t, r) {
          var a, c, p, f;
          if (t.removeAll && n.clear(), t.remove)
            for (const v of t.remove) n.delete(v);
          if (t.add)
            for (const v of t.add) {
              const x = Au(v, r);
              x != null && n.set(x, v)
            }
          if (t.update)
            for (const v of t.update) {
              let x = n.get(v.id);
              if (x == null) continue;
              const C = !v.removeAllProperties && (((a = v.removeProperties) === null || a === void 0 ? void 0 : a.length) > 0 || ((c = v.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
              if ((v.newGeometry || v.removeAllProperties || C) && (x = Object.assign({}, x), n.set(v.id, x), C && (x.properties = Object.assign({}, x.properties))), v.newGeometry && (x.geometry = v.newGeometry), v.removeAllProperties) x.properties = {};
              else if (((p = v.removeProperties) === null || p === void 0 ? void 0 : p.length) > 0)
                for (const I of v.removeProperties) Object.prototype.hasOwnProperty.call(x.properties, I) && delete x.properties[I];
              if (((f = v.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0)
                for (const {
                    key: I,
                    value: L
                  }
                  of v.addOrUpdateProperties) x.properties[I] = L
            }
        }, T.cX = za, T.ca = function(n, t) {
          return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, T.cb = n => n.type === "symbol", T.cc = n => n.type === "circle", T.cd = n => n.type === "heatmap", T.ce = n => n.type === "line", T.cf = n => n.type === "fill", T.cg = n => n.type === "fill-extrusion", T.ch = n => n.type === "hillshade", T.ci = n => n.type === "color-relief", T.cj = n => n.type === "raster", T.ck = n => n.type === "background", T.cl = n => n.type === "custom", T.cm = _t, T.cn = function(n, t, r) {
          const a = _e(t.x - r.x, t.y - r.y),
            c = _e(n.x - r.x, n.y - r.y);
          var p, f;
          return Sr(Math.atan2(a[0] * c[1] - a[1] * c[0], (p = a)[0] * (f = c)[0] + p[1] * f[1]))
        }, T.co = zt, T.cp = function(n, t) {
          return gr[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
        }, T.cq = function(n, t) {
          return wr[t] && "touches" in n
        }, T.cr = function(n) {
          return wr[n] || gr[n]
        }, T.cs = function(n, t, r) {
          var a = t[0],
            c = t[1];
          return n[0] = r[0] * a + r[4] * c + r[12], n[1] = r[1] * a + r[5] * c + r[13], n
        }, T.ct = function(n, t) {
          const {
            x: r,
            y: a
          } = Mu.fromLngLat(t);
          return !(n < 0 || n > 25 || a < 0 || a >= 1 || r < 0 || r >= 1)
        }, T.cu = function(n, t) {
          return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = t[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = t[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }, T.cv = class extends co {}, T.cw = Ix, T.cy = function(n) {
          return n.message === Ar
        }, T.cz = ie, T.d = Me, T.e = dt, T.f = n => o(void 0, void 0, void 0, (function*() {
          if (n.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), T.g = U, T.h = n => new Promise(((t, r) => {
          const a = new Image;
          a.onload = () => {
            t(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame((() => {
              a.src = It
            }))
          }, a.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const c = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          a.src = n.byteLength ? URL.createObjectURL(c) : It
        })), T.i = Xt, T.j = (n, t) => Te(dt(n, {
          type: "json"
        }), t), T.k = Qe, T.l = ct, T.m = Te, T.n = (n, t) => Te(dt(n, {
          type: "arrayBuffer"
        }), t), T.o = function(n) {
          return new sf(n).readFields(Jy, [])
        }, T.p = $_, T.q = gu, T.r = $i, T.s = Gr, T.t = yd, T.u = un, T.v = xe, T.w = At, T.x = Fp, T.y = Ho, T.z = ao
      })), M("worker", ["./shared"], (function(T) {
        class o {
          constructor(j) {
            this.keyCache = {}, j && this.replace(j)
          }
          replace(j) {
            this._layerConfigs = {}, this._layers = {}, this.update(j, [])
          }
          update(j, U) {
            for (const ie of j) {
              this._layerConfigs[ie.id] = ie;
              const he = this._layers[ie.id] = T.bJ(ie);
              he._featureFilter = T.aa(he.filter), this.keyCache[ie.id] && delete this.keyCache[ie.id]
            }
            for (const ie of U) delete this.keyCache[ie], delete this._layerConfigs[ie], delete this._layers[ie];
            this.familiesBySource = {};
            const Y = T.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const ie of Y) {
              const he = ie.map((Qe => this._layers[Qe.id])),
                Te = he[0];
              if (Te.visibility === "none") continue;
              const Me = Te.source || "";
              let we = this.familiesBySource[Me];
              we || (we = this.familiesBySource[Me] = {});
              const Ne = Te.sourceLayer || "_geojsonTileLayer";
              let ct = we[Ne];
              ct || (ct = we[Ne] = []), ct.push(he)
            }
          }
        }
        class B {
          constructor(j) {
            const U = {},
              Y = [];
            for (const Me in j) {
              const we = j[Me],
                Ne = U[Me] = {};
              for (const ct in we) {
                const Qe = we[+ct];
                if (!Qe || Qe.bitmap.width === 0 || Qe.bitmap.height === 0) continue;
                const kt = {
                  x: 0,
                  y: 0,
                  w: Qe.bitmap.width + 2,
                  h: Qe.bitmap.height + 2
                };
                Y.push(kt), Ne[ct] = {
                  rect: kt,
                  metrics: Qe.metrics
                }
              }
            }
            const {
              w: ie,
              h: he
            } = T.p(Y), Te = new T.q({
              width: ie || 1,
              height: he || 1
            });
            for (const Me in j) {
              const we = j[Me];
              for (const Ne in we) {
                const ct = we[+Ne];
                if (!ct || ct.bitmap.width === 0 || ct.bitmap.height === 0) continue;
                const Qe = U[Me][Ne].rect;
                T.q.copy(ct.bitmap, Te, {
                  x: 0,
                  y: 0
                }, {
                  x: Qe.x + 1,
                  y: Qe.y + 1
                }, ct.bitmap)
              }
            }
            this.image = Te, this.positions = U
          }
        }
        T.cD("GlyphAtlas", B);
        class N {
          constructor(j) {
            this.tileID = new T.Z(j.tileID.overscaledZ, j.tileID.wrap, j.tileID.canonical.z, j.tileID.canonical.x, j.tileID.canonical.y), this.uid = j.uid, this.zoom = j.zoom, this.pixelRatio = j.pixelRatio, this.tileSize = j.tileSize, this.source = j.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = j.showCollisionBoxes, this.collectResourceTiming = !!j.collectResourceTiming, this.returnDependencies = !!j.returnDependencies, this.promoteId = j.promoteId, this.inFlightDependencies = [], this.globalState = j.globalState
          }
          parse(j, U, Y, ie, he) {
            return T._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = j, this.collisionBoxArray = new T.a8;
              const Te = new T.cE(Object.keys(j.layers).sort()),
                Me = new T.cF(this.tileID, this.promoteId);
              Me.bucketLayerIDs = [];
              const we = {},
                Ne = {
                  featureIndex: Me,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  availableImages: Y,
                  subdivisionGranularity: he
                },
                ct = U.familiesBySource[this.source];
              for (const Yt in ct) {
                const ar = j.layers[Yt];
                if (!ar) continue;
                ar.version === 1 && T.w(`Vector tile source "${this.source}" layer "${Yt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const qr = Te.encode(Yt),
                  yt = [];
                for (let sn = 0; sn < ar.length; sn++) {
                  const Yr = ar.feature(sn),
                    kn = Me.getId(Yr, Yt);
                  yt.push({
                    feature: Yr,
                    id: kn,
                    index: sn,
                    sourceLayerIndex: qr
                  })
                }
                for (const sn of ct[Yt]) {
                  const Yr = sn[0];
                  Yr.source !== this.source && T.w(`layer.source = ${Yr.source} does not equal this.source = ${this.source}`), Yr.minzoom && this.zoom < Math.floor(Yr.minzoom) || Yr.maxzoom && this.zoom >= Yr.maxzoom || Yr.visibility !== "none" && (W(sn, this.zoom, Y), (we[Yr.id] = Yr.createBucket({
                    index: Me.bucketLayerIDs.length,
                    layers: sn,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: qr,
                    sourceID: this.source,
                    globalState: this.globalState
                  })).populate(yt, Ne, this.tileID.canonical), Me.bucketLayerIDs.push(sn.map((kn => kn.id))))
                }
              }
              const Qe = T.bN(Ne.glyphDependencies, (Yt => Object.keys(Yt).map(Number)));
              this.inFlightDependencies.forEach((Yt => Yt == null ? void 0 : Yt.abort())), this.inFlightDependencies = [];
              let kt = Promise.resolve({});
              if (Object.keys(Qe).length) {
                const Yt = new AbortController;
                this.inFlightDependencies.push(Yt), kt = ie.sendAsync({
                  type: "GG",
                  data: {
                    stacks: Qe,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, Yt)
              }
              const xe = Object.keys(Ne.iconDependencies);
              let Nt = Promise.resolve({});
              if (xe.length) {
                const Yt = new AbortController;
                this.inFlightDependencies.push(Yt), Nt = ie.sendAsync({
                  type: "GI",
                  data: {
                    icons: xe,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, Yt)
              }
              const Jt = Object.keys(Ne.patternDependencies);
              let jt = Promise.resolve({});
              if (Jt.length) {
                const Yt = new AbortController;
                this.inFlightDependencies.push(Yt), jt = ie.sendAsync({
                  type: "GI",
                  data: {
                    icons: Jt,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, Yt)
              }
              const [hr, $r, en] = yield Promise.all([kt, Nt, jt]), tr = new B(hr), Ht = new T.cG($r, en);
              for (const Yt in we) {
                const ar = we[Yt];
                ar instanceof T.a9 ? (W(ar.layers, this.zoom, Y), T.cH({
                  bucket: ar,
                  glyphMap: hr,
                  glyphPositions: tr.positions,
                  imageMap: $r,
                  imagePositions: Ht.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Ne.subdivisionGranularity
                })) : ar.hasPattern && (ar instanceof T.cI || ar instanceof T.cJ || ar instanceof T.cK) && (W(ar.layers, this.zoom, Y), ar.addFeatures(Ne, this.tileID.canonical, Ht.patternPositions))
              }
              return this.status = "done", {
                buckets: Object.values(we).filter((Yt => !Yt.isEmpty())),
                featureIndex: Me,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: tr.image,
                imageAtlas: Ht,
                glyphMap: this.returnDependencies ? hr : null,
                iconMap: this.returnDependencies ? $r : null,
                glyphPositions: this.returnDependencies ? tr.positions : null
              }
            }))
          }
        }

        function W(ue, j, U) {
          const Y = new T.F(j);
          for (const ie of ue) ie.recalculate(Y, U)
        }
        class K {
          constructor(j, U, Y) {
            this.actor = j, this.layerIndex = U, this.availableImages = Y, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(j, U) {
            return T._(this, void 0, void 0, (function*() {
              const Y = yield T.n(j.request, U);
              try {
                return {
                  vectorTile: new T.cL(new T.cM(Y.data)),
                  rawData: Y.data,
                  cacheControl: Y.cacheControl,
                  expires: Y.expires
                }
              } catch (ie) {
                const he = new Uint8Array(Y.data);
                let Te = `Unable to parse the tile at ${j.request.url}, `;
                throw Te += he[0] === 31 && he[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ie.message}`, new Error(Te)
              }
            }))
          }
          loadTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const U = j.uid,
                Y = !!(j && j.request && j.request.collectResourceTiming) && new T.cN(j.request),
                ie = new N(j);
              this.loading[U] = ie;
              const he = new AbortController;
              ie.abort = he;
              try {
                const Te = yield this.loadVectorTile(j, he);
                if (delete this.loading[U], !Te) return null;
                const Me = Te.rawData,
                  we = {};
                Te.expires && (we.expires = Te.expires), Te.cacheControl && (we.cacheControl = Te.cacheControl);
                const Ne = {};
                if (Y) {
                  const Qe = Y.finish();
                  Qe && (Ne.resourceTiming = JSON.parse(JSON.stringify(Qe)))
                }
                ie.vectorTile = Te.vectorTile;
                const ct = ie.parse(Te.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity);
                this.loaded[U] = ie, this.fetching[U] = {
                  rawTileData: Me,
                  cacheControl: we,
                  resourceTiming: Ne
                };
                try {
                  const Qe = yield ct;
                  return T.e({
                    rawTileData: Me.slice(0)
                  }, Qe, we, Ne)
                } finally {
                  delete this.fetching[U]
                }
              } catch (Te) {
                throw delete this.loading[U], ie.status = "done", this.loaded[U] = ie, Te
              }
            }))
          }
          reloadTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const U = j.uid;
              if (!this.loaded || !this.loaded[U]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const Y = this.loaded[U];
              if (Y.showCollisionBoxes = j.showCollisionBoxes, Y.globalState = j.globalState, Y.status === "parsing") {
                const ie = yield Y.parse(Y.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity);
                let he;
                if (this.fetching[U]) {
                  const {
                    rawTileData: Te,
                    cacheControl: Me,
                    resourceTiming: we
                  } = this.fetching[U];
                  delete this.fetching[U], he = T.e({
                    rawTileData: Te.slice(0)
                  }, ie, Me, we)
                } else he = ie;
                return he
              }
              if (Y.status === "done" && Y.vectorTile) return Y.parse(Y.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity)
            }))
          }
          abortTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const U = this.loading,
                Y = j.uid;
              U && U[Y] && U[Y].abort && (U[Y].abort.abort(), delete U[Y])
            }))
          }
          removeTile(j) {
            return T._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[j.uid] && delete this.loaded[j.uid]
            }))
          }
        }
        class se {
          constructor() {
            this.loaded = {}
          }
          loadTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const {
                uid: U,
                encoding: Y,
                rawImageData: ie,
                redFactor: he,
                greenFactor: Te,
                blueFactor: Me,
                baseShift: we
              } = j, Ne = ie.width + 2, ct = ie.height + 2, Qe = T.b(ie) ? new T.R({
                width: Ne,
                height: ct
              }, yield T.cO(ie, -1, -1, Ne, ct)) : ie, kt = new T.cP(U, Qe, Y, he, Te, Me, we);
              return this.loaded = this.loaded || {}, this.loaded[U] = kt, kt
            }))
          }
          removeTile(j) {
            const U = this.loaded,
              Y = j.uid;
            U && U[Y] && delete U[Y]
          }
        }
        var X, me, ge = (function() {
            if (me) return X;

            function ue(U, Y) {
              if (U.length !== 0) {
                j(U[0], Y);
                for (var ie = 1; ie < U.length; ie++) j(U[ie], !Y)
              }
            }

            function j(U, Y) {
              for (var ie = 0, he = 0, Te = 0, Me = U.length, we = Me - 1; Te < Me; we = Te++) {
                var Ne = (U[Te][0] - U[we][0]) * (U[we][1] + U[Te][1]),
                  ct = ie + Ne;
                he += Math.abs(ie) >= Math.abs(Ne) ? ie - ct + Ne : Ne - ct + ie, ie = ct
              }
              ie + he >= 0 != !!Y && U.reverse()
            }
            return me = 1, X = function U(Y, ie) {
              var he, Te = Y && Y.type;
              if (Te === "FeatureCollection")
                for (he = 0; he < Y.features.length; he++) U(Y.features[he], ie);
              else if (Te === "GeometryCollection")
                for (he = 0; he < Y.geometries.length; he++) U(Y.geometries[he], ie);
              else if (Te === "Feature") U(Y.geometry, ie);
              else if (Te === "Polygon") ue(Y.coordinates, ie);
              else if (Te === "MultiPolygon")
                for (he = 0; he < Y.coordinates.length; he++) ue(Y.coordinates[he], ie);
              return Y
            }
          })(),
          Ee = T.cQ(ge);
        class ze extends T.cS {
          constructor(j, U) {
            super(new T.cM, 0, U, [], []), this.feature = j, this.type = j.type, this.properties = j.tags ? j.tags : {}, "id" in j && (typeof j.id == "string" ? this.id = parseInt(j.id, 10) : typeof j.id != "number" || isNaN(j.id) || (this.id = j.id))
          }
          loadGeometry() {
            const j = [],
              U = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const Y of U) {
              const ie = [];
              for (const he of Y) ie.push(new T.P(he[0], he[1]));
              j.push(ie)
            }
            return j
          }
        }
        class Re extends T.cR {
          constructor(j, U) {
            super(new T.cM), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = U ? U.version : 1, this.extent = U ? U.extent : 4096, this.length = j.length, this.features = j
          }
          feature(j) {
            return new ze(this.features[j], this.extent)
          }
        }

        function Ie(ue, j) {
          j.writeVarintField(15, ue.version || 1), j.writeStringField(1, ue.name || ""), j.writeVarintField(5, ue.extent || 4096);
          const U = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let he = 0; he < ue.length; he++) U.feature = ue.feature(he), j.writeMessage(2, Oe, U);
          const Y = U.keys;
          for (const he of Y) j.writeStringField(3, he);
          const ie = U.values;
          for (const he of ie) j.writeMessage(4, Je, he)
        }

        function Oe(ue, j) {
          if (!ue.feature) return;
          const U = ue.feature;
          U.id !== void 0 && j.writeVarintField(1, U.id), j.writeMessage(2, st, ue), j.writeVarintField(3, U.type), j.writeMessage(4, Ue, U)
        }

        function st(ue, j) {
          var U;
          for (const Y in (U = ue.feature) == null ? void 0 : U.properties) {
            let ie = ue.feature.properties[Y],
              he = ue.keycache[Y];
            if (ie === null) continue;
            he === void 0 && (ue.keys.push(Y), he = ue.keys.length - 1, ue.keycache[Y] = he), j.writeVarint(he), typeof ie != "string" && typeof ie != "boolean" && typeof ie != "number" && (ie = JSON.stringify(ie));
            const Te = typeof ie + ":" + ie;
            let Me = ue.valuecache[Te];
            Me === void 0 && (ue.values.push(ie), Me = ue.values.length - 1, ue.valuecache[Te] = Me), j.writeVarint(Me)
          }
        }

        function nt(ue, j) {
          return (j << 3) + (7 & ue)
        }

        function qe(ue) {
          return ue << 1 ^ ue >> 31
        }

        function Ue(ue, j) {
          const U = ue.loadGeometry(),
            Y = ue.type;
          let ie = 0,
            he = 0;
          for (const Te of U) {
            let Me = 1;
            Y === 1 && (Me = Te.length), j.writeVarint(nt(1, Me));
            const we = Y === 3 ? Te.length - 1 : Te.length;
            for (let Ne = 0; Ne < we; Ne++) {
              Ne === 1 && Y !== 1 && j.writeVarint(nt(2, we - 1));
              const ct = Te[Ne].x - ie,
                Qe = Te[Ne].y - he;
              j.writeVarint(qe(ct)), j.writeVarint(qe(Qe)), ie += ct, he += Qe
            }
            ue.type === 3 && j.writeVarint(nt(7, 1))
          }
        }

        function Je(ue, j) {
          const U = typeof ue;
          U === "string" ? j.writeStringField(1, ue) : U === "boolean" ? j.writeBooleanField(7, ue) : U === "number" && (ue % 1 != 0 ? j.writeDoubleField(3, ue) : ue < 0 ? j.writeSVarintField(6, ue) : j.writeVarintField(5, ue))
        }
        const Fe = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: ue => ue
          },
          it = Math.fround || (tt = new Float32Array(1), ue => (tt[0] = +ue, tt[0]));
        var tt;
        class $e {
          constructor(j) {
            this.options = Object.assign(Object.create(Fe), j), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(j) {
            const {
              log: U,
              minZoom: Y,
              maxZoom: ie
            } = this.options;
            U && console.time("total time");
            const he = `prepare ${j.length} points`;
            U && console.time(he), this.points = j;
            const Te = [];
            for (let we = 0; we < j.length; we++) {
              const Ne = j[we];
              if (!Ne.geometry) continue;
              const [ct, Qe] = Ne.geometry.coordinates, kt = it(Q(ct)), xe = it(re(Qe));
              Te.push(kt, xe, 1 / 0, we, -1, 1), this.options.reduce && Te.push(0)
            }
            let Me = this.trees[ie + 1] = this._createTree(Te);
            U && console.timeEnd(he);
            for (let we = ie; we >= Y; we--) {
              const Ne = +Date.now();
              Me = this.trees[we] = this._createTree(this._cluster(Me, we)), U && console.log("z%d: %d clusters in %dms", we, Me.numItems, +Date.now() - Ne)
            }
            return U && console.timeEnd("total time"), this
          }
          getClusters(j, U) {
            let Y = ((j[0] + 180) % 360 + 360) % 360 - 180;
            const ie = Math.max(-90, Math.min(90, j[1]));
            let he = j[2] === 180 ? 180 : ((j[2] + 180) % 360 + 360) % 360 - 180;
            const Te = Math.max(-90, Math.min(90, j[3]));
            if (j[2] - j[0] >= 360) Y = -180, he = 180;
            else if (Y > he) {
              const Qe = this.getClusters([Y, ie, 180, Te], U),
                kt = this.getClusters([-180, ie, he, Te], U);
              return Qe.concat(kt)
            }
            const Me = this.trees[this._limitZoom(U)],
              we = Me.range(Q(Y), re(Te), Q(he), re(ie)),
              Ne = Me.data,
              ct = [];
            for (const Qe of we) {
              const kt = this.stride * Qe;
              ct.push(Ne[kt + 5] > 1 ? Ae(Ne, kt, this.clusterProps) : this.points[Ne[kt + 3]])
            }
            return ct
          }
          getChildren(j) {
            const U = this._getOriginId(j),
              Y = this._getOriginZoom(j),
              ie = "No cluster with the specified id.",
              he = this.trees[Y];
            if (!he) throw new Error(ie);
            const Te = he.data;
            if (U * this.stride >= Te.length) throw new Error(ie);
            const Me = this.options.radius / (this.options.extent * Math.pow(2, Y - 1)),
              we = he.within(Te[U * this.stride], Te[U * this.stride + 1], Me),
              Ne = [];
            for (const ct of we) {
              const Qe = ct * this.stride;
              Te[Qe + 4] === j && Ne.push(Te[Qe + 5] > 1 ? Ae(Te, Qe, this.clusterProps) : this.points[Te[Qe + 3]])
            }
            if (Ne.length === 0) throw new Error(ie);
            return Ne
          }
          getLeaves(j, U, Y) {
            const ie = [];
            return this._appendLeaves(ie, j, U = U || 10, Y = Y || 0, 0), ie
          }
          getTile(j, U, Y) {
            const ie = this.trees[this._limitZoom(j)],
              he = Math.pow(2, j),
              {
                extent: Te,
                radius: Me
              } = this.options,
              we = Me / Te,
              Ne = (Y - we) / he,
              ct = (Y + 1 + we) / he,
              Qe = {
                features: []
              };
            return this._addTileFeatures(ie.range((U - we) / he, Ne, (U + 1 + we) / he, ct), ie.data, U, Y, he, Qe), U === 0 && this._addTileFeatures(ie.range(1 - we / he, Ne, 1, ct), ie.data, he, Y, he, Qe), U === he - 1 && this._addTileFeatures(ie.range(0, Ne, we / he, ct), ie.data, -1, Y, he, Qe), Qe.features.length ? Qe : null
          }
          getClusterExpansionZoom(j) {
            let U = this._getOriginZoom(j) - 1;
            for (; U <= this.options.maxZoom;) {
              const Y = this.getChildren(j);
              if (U++, Y.length !== 1) break;
              j = Y[0].properties.cluster_id
            }
            return U
          }
          _appendLeaves(j, U, Y, ie, he) {
            const Te = this.getChildren(U);
            for (const Me of Te) {
              const we = Me.properties;
              if (we && we.cluster ? he + we.point_count <= ie ? he += we.point_count : he = this._appendLeaves(j, we.cluster_id, Y, ie, he) : he < ie ? he++ : j.push(Me), j.length === Y) break
            }
            return he
          }
          _createTree(j) {
            const U = new T.aI(j.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let Y = 0; Y < j.length; Y += this.stride) U.add(j[Y], j[Y + 1]);
            return U.finish(), U.data = j, U
          }
          _addTileFeatures(j, U, Y, ie, he, Te) {
            for (const Me of j) {
              const we = Me * this.stride,
                Ne = U[we + 5] > 1;
              let ct, Qe, kt;
              if (Ne) ct = gt(U, we, this.clusterProps), Qe = U[we], kt = U[we + 1];
              else {
                const Jt = this.points[U[we + 3]];
                ct = Jt.properties;
                const [jt, hr] = Jt.geometry.coordinates;
                Qe = Q(jt), kt = re(hr)
              }
              const xe = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (Qe * he - Y)), Math.round(this.options.extent * (kt * he - ie))]
                ],
                tags: ct
              };
              let Nt;
              Nt = Ne || this.options.generateId ? U[we + 3] : this.points[U[we + 3]].id, Nt !== void 0 && (xe.id = Nt), Te.features.push(xe)
            }
          }
          _limitZoom(j) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+j), this.options.maxZoom + 1))
          }
          _cluster(j, U) {
            const {
              radius: Y,
              extent: ie,
              reduce: he,
              minPoints: Te
            } = this.options, Me = Y / (ie * Math.pow(2, U)), we = j.data, Ne = [], ct = this.stride;
            for (let Qe = 0; Qe < we.length; Qe += ct) {
              if (we[Qe + 2] <= U) continue;
              we[Qe + 2] = U;
              const kt = we[Qe],
                xe = we[Qe + 1],
                Nt = j.within(we[Qe], we[Qe + 1], Me),
                Jt = we[Qe + 5];
              let jt = Jt;
              for (const hr of Nt) {
                const $r = hr * ct;
                we[$r + 2] > U && (jt += we[$r + 5])
              }
              if (jt > Jt && jt >= Te) {
                let hr, $r = kt * Jt,
                  en = xe * Jt,
                  tr = -1;
                const Ht = (Qe / ct << 5) + (U + 1) + this.points.length;
                for (const Yt of Nt) {
                  const ar = Yt * ct;
                  if (we[ar + 2] <= U) continue;
                  we[ar + 2] = U;
                  const qr = we[ar + 5];
                  $r += we[ar] * qr, en += we[ar + 1] * qr, we[ar + 4] = Ht, he && (hr || (hr = this._map(we, Qe, !0), tr = this.clusterProps.length, this.clusterProps.push(hr)), he(hr, this._map(we, ar)))
                }
                we[Qe + 4] = Ht, Ne.push($r / jt, en / jt, 1 / 0, Ht, -1, jt), he && Ne.push(tr)
              } else {
                for (let hr = 0; hr < ct; hr++) Ne.push(we[Qe + hr]);
                if (jt > 1)
                  for (const hr of Nt) {
                    const $r = hr * ct;
                    if (!(we[$r + 2] <= U)) {
                      we[$r + 2] = U;
                      for (let en = 0; en < ct; en++) Ne.push(we[$r + en])
                    }
                  }
              }
            }
            return Ne
          }
          _getOriginId(j) {
            return j - this.points.length >> 5
          }
          _getOriginZoom(j) {
            return (j - this.points.length) % 32
          }
          _map(j, U, Y) {
            if (j[U + 5] > 1) {
              const Te = this.clusterProps[j[U + 6]];
              return Y ? Object.assign({}, Te) : Te
            }
            const ie = this.points[j[U + 3]].properties,
              he = this.options.map(ie);
            return Y && he === ie ? Object.assign({}, he) : he
          }
        }

        function Ae(ue, j, U) {
          return {
            type: "Feature",
            id: ue[j + 3],
            properties: gt(ue, j, U),
            geometry: {
              type: "Point",
              coordinates: [(Y = ue[j], 360 * (Y - .5)), _e(ue[j + 1])]
            }
          };
          var Y
        }

        function gt(ue, j, U) {
          const Y = ue[j + 5],
            ie = Y >= 1e4 ? `${Math.round(Y/1e3)}k` : Y >= 1e3 ? Math.round(Y / 100) / 10 + "k" : Y,
            he = ue[j + 6],
            Te = he === -1 ? {} : Object.assign({}, U[he]);
          return Object.assign(Te, {
            cluster: !0,
            cluster_id: ue[j + 3],
            point_count: Y,
            point_count_abbreviated: ie
          })
        }

        function Q(ue) {
          return ue / 360 + .5
        }

        function re(ue) {
          const j = Math.sin(ue * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + j) / (1 - j)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function _e(ue) {
          const j = (180 - 360 * ue) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(j)) / Math.PI - 90
        }

        function ae(ue, j, U, Y) {
          let ie = Y;
          const he = j + (U - j >> 1);
          let Te, Me = U - j;
          const we = ue[j],
            Ne = ue[j + 1],
            ct = ue[U],
            Qe = ue[U + 1];
          for (let kt = j + 3; kt < U; kt += 3) {
            const xe = ke(ue[kt], ue[kt + 1], we, Ne, ct, Qe);
            if (xe > ie) Te = kt, ie = xe;
            else if (xe === ie) {
              const Nt = Math.abs(kt - he);
              Nt < Me && (Te = kt, Me = Nt)
            }
          }
          ie > Y && (Te - j > 3 && ae(ue, j, Te, Y), ue[Te + 2] = ie, U - Te > 3 && ae(ue, Te, U, Y))
        }

        function ke(ue, j, U, Y, ie, he) {
          let Te = ie - U,
            Me = he - Y;
          if (Te !== 0 || Me !== 0) {
            const we = ((ue - U) * Te + (j - Y) * Me) / (Te * Te + Me * Me);
            we > 1 ? (U = ie, Y = he) : we > 0 && (U += Te * we, Y += Me * we)
          }
          return Te = ue - U, Me = j - Y, Te * Te + Me * Me
        }

        function Le(ue, j, U, Y) {
          const ie = {
            id: ue ?? null,
            type: j,
            geometry: U,
            tags: Y,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (j === "Point" || j === "MultiPoint" || j === "LineString") lt(ie, U);
          else if (j === "Polygon") lt(ie, U[0]);
          else if (j === "MultiLineString")
            for (const he of U) lt(ie, he);
          else if (j === "MultiPolygon")
            for (const he of U) lt(ie, he[0]);
          return ie
        }

        function lt(ue, j) {
          for (let U = 0; U < j.length; U += 3) ue.minX = Math.min(ue.minX, j[U]), ue.minY = Math.min(ue.minY, j[U + 1]), ue.maxX = Math.max(ue.maxX, j[U]), ue.maxY = Math.max(ue.maxY, j[U + 1])
        }

        function We(ue, j, U, Y) {
          if (!j.geometry) return;
          const ie = j.geometry.coordinates;
          if (ie && ie.length === 0) return;
          const he = j.geometry.type,
            Te = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2);
          let Me = [],
            we = j.id;
          if (U.promoteId ? we = j.properties[U.promoteId] : U.generateId && (we = Y || 0), he === "Point") _t(ie, Me);
          else if (he === "MultiPoint")
            for (const Ne of ie) _t(Ne, Me);
          else if (he === "LineString") zt(ie, Me, Te, !1);
          else if (he === "MultiLineString") {
            if (U.lineMetrics) {
              for (const Ne of ie) Me = [], zt(Ne, Me, Te, !1), ue.push(Le(we, "LineString", Me, j.properties));
              return
            }
            Dt(ie, Me, Te, !1)
          } else if (he === "Polygon") Dt(ie, Me, Te, !0);
          else {
            if (he !== "MultiPolygon") {
              if (he === "GeometryCollection") {
                for (const Ne of j.geometry.geometries) We(ue, {
                  id: we,
                  geometry: Ne,
                  properties: j.properties
                }, U, Y);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Ne of ie) {
              const ct = [];
              Dt(Ne, ct, Te, !0), Me.push(ct)
            }
          }
          ue.push(Le(we, he, Me, j.properties))
        }

        function _t(ue, j) {
          j.push(ot(ue[0]), dt(ue[1]), 0)
        }

        function zt(ue, j, U, Y) {
          let ie, he, Te = 0;
          for (let we = 0; we < ue.length; we++) {
            const Ne = ot(ue[we][0]),
              ct = dt(ue[we][1]);
            j.push(Ne, ct, 0), we > 0 && (Te += Y ? (ie * ct - Ne * he) / 2 : Math.sqrt(Math.pow(Ne - ie, 2) + Math.pow(ct - he, 2))), ie = Ne, he = ct
          }
          const Me = j.length - 3;
          j[2] = 1, ae(j, 0, Me, U), j[Me + 2] = 1, j.size = Math.abs(Te), j.start = 0, j.end = j.size
        }

        function Dt(ue, j, U, Y) {
          for (let ie = 0; ie < ue.length; ie++) {
            const he = [];
            zt(ue[ie], he, U, Y), j.push(he)
          }
        }

        function ot(ue) {
          return ue / 360 + .5
        }

        function dt(ue) {
          const j = Math.sin(ue * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + j) / (1 - j)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function vt(ue, j, U, Y, ie, he, Te, Me) {
          if (Y /= j, he >= (U /= j) && Te < Y) return ue;
          if (Te < U || he >= Y) return null;
          const we = [];
          for (const Ne of ue) {
            const ct = Ne.geometry;
            let Qe = Ne.type;
            const kt = ie === 0 ? Ne.minX : Ne.minY,
              xe = ie === 0 ? Ne.maxX : Ne.maxY;
            if (kt >= U && xe < Y) {
              we.push(Ne);
              continue
            }
            if (xe < U || kt >= Y) continue;
            let Nt = [];
            if (Qe === "Point" || Qe === "MultiPoint") ft(ct, Nt, U, Y, ie);
            else if (Qe === "LineString") Tt(ct, Nt, U, Y, ie, !1, Me.lineMetrics);
            else if (Qe === "MultiLineString") pt(ct, Nt, U, Y, ie, !1);
            else if (Qe === "Polygon") pt(ct, Nt, U, Y, ie, !0);
            else if (Qe === "MultiPolygon")
              for (const Jt of ct) {
                const jt = [];
                pt(Jt, jt, U, Y, ie, !0), jt.length && Nt.push(jt)
              }
            if (Nt.length) {
              if (Me.lineMetrics && Qe === "LineString") {
                for (const Jt of Nt) we.push(Le(Ne.id, Qe, Jt, Ne.tags));
                continue
              }
              Qe !== "LineString" && Qe !== "MultiLineString" || (Nt.length === 1 ? (Qe = "LineString", Nt = Nt[0]) : Qe = "MultiLineString"), Qe !== "Point" && Qe !== "MultiPoint" || (Qe = Nt.length === 3 ? "Point" : "MultiPoint"), we.push(Le(Ne.id, Qe, Nt, Ne.tags))
            }
          }
          return we.length ? we : null
        }

        function ft(ue, j, U, Y, ie) {
          for (let he = 0; he < ue.length; he += 3) {
            const Te = ue[he + ie];
            Te >= U && Te <= Y && At(j, ue[he], ue[he + 1], ue[he + 2])
          }
        }

        function Tt(ue, j, U, Y, ie, he, Te) {
          let Me = xt(ue);
          const we = ie === 0 ? Wt : Xt;
          let Ne, ct, Qe = ue.start;
          for (let jt = 0; jt < ue.length - 3; jt += 3) {
            const hr = ue[jt],
              $r = ue[jt + 1],
              en = ue[jt + 2],
              tr = ue[jt + 3],
              Ht = ue[jt + 4],
              Yt = ie === 0 ? hr : $r,
              ar = ie === 0 ? tr : Ht;
            let qr = !1;
            Te && (Ne = Math.sqrt(Math.pow(hr - tr, 2) + Math.pow($r - Ht, 2))), Yt < U ? ar > U && (ct = we(Me, hr, $r, tr, Ht, U), Te && (Me.start = Qe + Ne * ct)) : Yt > Y ? ar < Y && (ct = we(Me, hr, $r, tr, Ht, Y), Te && (Me.start = Qe + Ne * ct)) : At(Me, hr, $r, en), ar < U && Yt >= U && (ct = we(Me, hr, $r, tr, Ht, U), qr = !0), ar > Y && Yt <= Y && (ct = we(Me, hr, $r, tr, Ht, Y), qr = !0), !he && qr && (Te && (Me.end = Qe + Ne * ct), j.push(Me), Me = xt(ue)), Te && (Qe += Ne)
          }
          let kt = ue.length - 3;
          const xe = ue[kt],
            Nt = ue[kt + 1],
            Jt = ie === 0 ? xe : Nt;
          Jt >= U && Jt <= Y && At(Me, xe, Nt, ue[kt + 2]), kt = Me.length - 3, he && kt >= 3 && (Me[kt] !== Me[0] || Me[kt + 1] !== Me[1]) && At(Me, Me[0], Me[1], Me[2]), Me.length && j.push(Me)
        }

        function xt(ue) {
          const j = [];
          return j.size = ue.size, j.start = ue.start, j.end = ue.end, j
        }

        function pt(ue, j, U, Y, ie, he) {
          for (const Te of ue) Tt(Te, j, U, Y, ie, he, !1)
        }

        function At(ue, j, U, Y) {
          ue.push(j, U, Y)
        }

        function Wt(ue, j, U, Y, ie, he) {
          const Te = (he - j) / (Y - j);
          return At(ue, he, U + (ie - U) * Te, 1), Te
        }

        function Xt(ue, j, U, Y, ie, he) {
          const Te = (he - U) / (ie - U);
          return At(ue, j + (Y - j) * Te, he, 1), Te
        }

        function rr(ue, j) {
          const U = [];
          for (let Y = 0; Y < ue.length; Y++) {
            const ie = ue[Y],
              he = ie.type;
            let Te;
            if (he === "Point" || he === "MultiPoint" || he === "LineString") Te = er(ie.geometry, j);
            else if (he === "MultiLineString" || he === "Polygon") {
              Te = [];
              for (const Me of ie.geometry) Te.push(er(Me, j))
            } else if (he === "MultiPolygon") {
              Te = [];
              for (const Me of ie.geometry) {
                const we = [];
                for (const Ne of Me) we.push(er(Ne, j));
                Te.push(we)
              }
            }
            U.push(Le(ie.id, he, Te, ie.tags))
          }
          return U
        }

        function er(ue, j) {
          const U = [];
          U.size = ue.size, ue.start !== void 0 && (U.start = ue.start, U.end = ue.end);
          for (let Y = 0; Y < ue.length; Y += 3) U.push(ue[Y] + j, ue[Y + 1], ue[Y + 2]);
          return U
        }

        function It(ue, j) {
          if (ue.transformed) return ue;
          const U = 1 << ue.z,
            Y = ue.x,
            ie = ue.y;
          for (const he of ue.features) {
            const Te = he.geometry,
              Me = he.type;
            if (he.geometry = [], Me === 1)
              for (let we = 0; we < Te.length; we += 2) he.geometry.push(ur(Te[we], Te[we + 1], j, U, Y, ie));
            else
              for (let we = 0; we < Te.length; we++) {
                const Ne = [];
                for (let ct = 0; ct < Te[we].length; ct += 2) Ne.push(ur(Te[we][ct], Te[we][ct + 1], j, U, Y, ie));
                he.geometry.push(Ne)
              }
          }
          return ue.transformed = !0, ue
        }

        function ur(ue, j, U, Y, ie, he) {
          return [Math.round(U * (ue * Y - ie)), Math.round(U * (j * Y - he))]
        }

        function yr(ue, j, U, Y, ie) {
          const he = j === ie.maxZoom ? 0 : ie.tolerance / ((1 << j) * ie.extent),
            Te = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: ue.length,
              source: null,
              x: U,
              y: Y,
              z: j,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const Me of ue) Mr(Te, Me, he, ie);
          return Te
        }

        function Mr(ue, j, U, Y) {
          const ie = j.geometry,
            he = j.type,
            Te = [];
          if (ue.minX = Math.min(ue.minX, j.minX), ue.minY = Math.min(ue.minY, j.minY), ue.maxX = Math.max(ue.maxX, j.maxX), ue.maxY = Math.max(ue.maxY, j.maxY), he === "Point" || he === "MultiPoint")
            for (let Me = 0; Me < ie.length; Me += 3) Te.push(ie[Me], ie[Me + 1]), ue.numPoints++, ue.numSimplified++;
          else if (he === "LineString") Gr(Te, ie, ue, U, !1, !1);
          else if (he === "MultiLineString" || he === "Polygon")
            for (let Me = 0; Me < ie.length; Me++) Gr(Te, ie[Me], ue, U, he === "Polygon", Me === 0);
          else if (he === "MultiPolygon")
            for (let Me = 0; Me < ie.length; Me++) {
              const we = ie[Me];
              for (let Ne = 0; Ne < we.length; Ne++) Gr(Te, we[Ne], ue, U, !0, Ne === 0)
            }
          if (Te.length) {
            let Me = j.tags || null;
            if (he === "LineString" && Y.lineMetrics) {
              Me = {};
              for (const Ne in j.tags) Me[Ne] = j.tags[Ne];
              Me.mapbox_clip_start = ie.start / ie.size, Me.mapbox_clip_end = ie.end / ie.size
            }
            const we = {
              geometry: Te,
              type: he === "Polygon" || he === "MultiPolygon" ? 3 : he === "LineString" || he === "MultiLineString" ? 2 : 1,
              tags: Me
            };
            j.id !== null && (we.id = j.id), ue.features.push(we)
          }
        }

        function Gr(ue, j, U, Y, ie, he) {
          const Te = Y * Y;
          if (Y > 0 && j.size < (ie ? Te : Y)) return void(U.numPoints += j.length / 3);
          const Me = [];
          for (let we = 0; we < j.length; we += 3)(Y === 0 || j[we + 2] > Te) && (U.numSimplified++, Me.push(j[we], j[we + 1])), U.numPoints++;
          ie && (function(we, Ne) {
            let ct = 0;
            for (let Qe = 0, kt = we.length, xe = kt - 2; Qe < kt; xe = Qe, Qe += 2) ct += (we[Qe] - we[xe]) * (we[Qe + 1] + we[xe + 1]);
            if (ct > 0 === Ne)
              for (let Qe = 0, kt = we.length; Qe < kt / 2; Qe += 2) {
                const xe = we[Qe],
                  Nt = we[Qe + 1];
                we[Qe] = we[kt - 2 - Qe], we[Qe + 1] = we[kt - 1 - Qe], we[kt - 2 - Qe] = xe, we[kt - 1 - Qe] = Nt
              }
          })(Me, he), ue.push(Me)
        }
        const xr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Sr {
          constructor(j, U) {
            const Y = (U = this.options = (function(he, Te) {
              for (const Me in Te) he[Me] = Te[Me];
              return he
            })(Object.create(xr), U)).debug;
            if (Y && console.time("preprocess data"), U.maxZoom < 0 || U.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (U.promoteId && U.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let ie = (function(he, Te) {
              const Me = [];
              if (he.type === "FeatureCollection")
                for (let we = 0; we < he.features.length; we++) We(Me, he.features[we], Te, we);
              else We(Me, he.type === "Feature" ? he : {
                geometry: he
              }, Te);
              return Me
            })(j, U);
            this.tiles = {}, this.tileCoords = [], Y && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", U.indexMaxZoom, U.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ie = (function(he, Te) {
              const Me = Te.buffer / Te.extent;
              let we = he;
              const Ne = vt(he, 1, -1 - Me, Me, 0, -1, 2, Te),
                ct = vt(he, 1, 1 - Me, 2 + Me, 0, -1, 2, Te);
              return (Ne || ct) && (we = vt(he, 1, -Me, 1 + Me, 0, -1, 2, Te) || [], Ne && (we = rr(Ne, 1).concat(we)), ct && (we = we.concat(rr(ct, -1)))), we
            })(ie, U), ie.length && this.splitTile(ie, 0, 0, 0), Y && (ie.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(j, U, Y, ie, he, Te, Me) {
            const we = [j, U, Y, ie],
              Ne = this.options,
              ct = Ne.debug;
            for (; we.length;) {
              ie = we.pop(), Y = we.pop(), U = we.pop(), j = we.pop();
              const Qe = 1 << U,
                kt = wr(U, Y, ie);
              let xe = this.tiles[kt];
              if (!xe && (ct > 1 && console.time("creation"), xe = this.tiles[kt] = yr(j, U, Y, ie, Ne), this.tileCoords.push({
                  z: U,
                  x: Y,
                  y: ie
                }), ct)) {
                ct > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", U, Y, ie, xe.numFeatures, xe.numPoints, xe.numSimplified), console.timeEnd("creation"));
                const qr = `z${U}`;
                this.stats[qr] = (this.stats[qr] || 0) + 1, this.total++
              }
              if (xe.source = j, he == null) {
                if (U === Ne.indexMaxZoom || xe.numPoints <= Ne.indexMaxPoints) continue
              } else {
                if (U === Ne.maxZoom || U === he) continue;
                if (he != null) {
                  const qr = he - U;
                  if (Y !== Te >> qr || ie !== Me >> qr) continue
                }
              }
              if (xe.source = null, j.length === 0) continue;
              ct > 1 && console.time("clipping");
              const Nt = .5 * Ne.buffer / Ne.extent,
                Jt = .5 - Nt,
                jt = .5 + Nt,
                hr = 1 + Nt;
              let $r = null,
                en = null,
                tr = null,
                Ht = null,
                Yt = vt(j, Qe, Y - Nt, Y + jt, 0, xe.minX, xe.maxX, Ne),
                ar = vt(j, Qe, Y + Jt, Y + hr, 0, xe.minX, xe.maxX, Ne);
              j = null, Yt && ($r = vt(Yt, Qe, ie - Nt, ie + jt, 1, xe.minY, xe.maxY, Ne), en = vt(Yt, Qe, ie + Jt, ie + hr, 1, xe.minY, xe.maxY, Ne), Yt = null), ar && (tr = vt(ar, Qe, ie - Nt, ie + jt, 1, xe.minY, xe.maxY, Ne), Ht = vt(ar, Qe, ie + Jt, ie + hr, 1, xe.minY, xe.maxY, Ne), ar = null), ct > 1 && console.timeEnd("clipping"), we.push($r || [], U + 1, 2 * Y, 2 * ie), we.push(en || [], U + 1, 2 * Y, 2 * ie + 1), we.push(tr || [], U + 1, 2 * Y + 1, 2 * ie), we.push(Ht || [], U + 1, 2 * Y + 1, 2 * ie + 1)
            }
          }
          getTile(j, U, Y) {
            j = +j, U = +U, Y = +Y;
            const ie = this.options,
              {
                extent: he,
                debug: Te
              } = ie;
            if (j < 0 || j > 24) return null;
            const Me = 1 << j,
              we = wr(j, U = U + Me & Me - 1, Y);
            if (this.tiles[we]) return It(this.tiles[we], he);
            Te > 1 && console.log("drilling down to z%d-%d-%d", j, U, Y);
            let Ne, ct = j,
              Qe = U,
              kt = Y;
            for (; !Ne && ct > 0;) ct--, Qe >>= 1, kt >>= 1, Ne = this.tiles[wr(ct, Qe, kt)];
            return Ne && Ne.source ? (Te > 1 && (console.log("found parent tile z%d-%d-%d", ct, Qe, kt), console.time("drilling down")), this.splitTile(Ne.source, ct, Qe, kt, j, U, Y), Te > 1 && console.timeEnd("drilling down"), this.tiles[we] ? It(this.tiles[we], he) : null) : null
          }
        }

        function wr(ue, j, U) {
          return 32 * ((1 << ue) * U + j) + ue
        }
        class gr extends K {
          constructor() {
            super(...arguments), this._dataUpdateable = new Map
          }
          loadVectorTile(j, U) {
            return T._(this, void 0, void 0, (function*() {
              const Y = j.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const ie = this._geoJSONIndex.getTile(Y.z, Y.x, Y.y);
              if (!ie) return null;
              const he = new Re(ie.features, {
                version: 2,
                extent: T.$
              });
              let Te = (function(Me) {
                const we = new T.cM;
                return (function(Ne, ct) {
                  for (const Qe in Ne.layers) ct.writeMessage(3, Ie, Ne.layers[Qe])
                })(Me, we), we.finish()
              })(he);
              return Te.byteOffset === 0 && Te.byteLength === Te.buffer.byteLength || (Te = new Uint8Array(Te)), {
                vectorTile: he,
                rawData: Te.buffer
              }
            }))
          }
          loadData(j) {
            return T._(this, void 0, void 0, (function*() {
              var U;
              (U = this._pendingRequest) === null || U === void 0 || U.abort();
              const Y = !!(j && j.request && j.request.collectResourceTiming) && new T.cN(j.request);
              this._pendingRequest = new AbortController;
              try {
                this._pendingData = this.loadAndProcessGeoJSON(j, this._pendingRequest);
                const ie = yield this._pendingData;
                this._geoJSONIndex = j.cluster ? new $e((function({
                  superclusterOptions: Te,
                  clusterProperties: Me
                }) {
                  if (!Me || !Te) return Te;
                  const we = {},
                    Ne = {},
                    ct = {
                      accumulated: null,
                      zoom: 0
                    },
                    Qe = {
                      properties: null
                    },
                    kt = Object.keys(Me);
                  for (const xe of kt) {
                    const [Nt, Jt] = Me[xe], jt = T.cT(Jt), hr = T.cT(typeof Nt == "string" ? [Nt, ["accumulated"],
                      ["get", xe]
                    ] : Nt);
                    we[xe] = jt.value, Ne[xe] = hr.value
                  }
                  return Te.map = xe => {
                    Qe.properties = xe;
                    const Nt = {};
                    for (const Jt of kt) Nt[Jt] = we[Jt].evaluate(ct, Qe);
                    return Nt
                  }, Te.reduce = (xe, Nt) => {
                    Qe.properties = Nt;
                    for (const Jt of kt) ct.accumulated = xe[Jt], xe[Jt] = Ne[Jt].evaluate(ct, Qe)
                  }, Te
                })(j)).load(ie.features) : (function(Te, Me) {
                  return new Sr(Te, Me)
                })(ie, j.geojsonVtOptions), this.loaded = {};
                const he = {
                  data: ie
                };
                if (Y) {
                  const Te = Y.finish();
                  Te && (he.resourceTiming = {}, he.resourceTiming[j.source] = JSON.parse(JSON.stringify(Te)))
                }
                return he
              } catch (ie) {
                if (delete this._pendingRequest, T.cy(ie)) return {
                  abandoned: !0
                };
                throw ie
              }
            }))
          }
          getData() {
            return T._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(j) {
            const U = this.loaded;
            return U && U[j.uid] ? super.reloadTile(j) : this.loadTile(j)
          }
          loadAndProcessGeoJSON(j, U) {
            return T._(this, void 0, void 0, (function*() {
              let Y = yield this.loadGeoJSON(j, U);
              if (delete this._pendingRequest, typeof Y != "object") throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`);
              if (Ee(Y, !0), j.filter) {
                const ie = T.cT(j.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (ie.result === "error") throw new Error(ie.value.map((Te => `${Te.key}: ${Te.message}`)).join(", "));
                Y = {
                  type: "FeatureCollection",
                  features: Y.features.filter((Te => ie.value.evaluate({
                    zoom: 0
                  }, Te)))
                }
              }
              return Y
            }))
          }
          loadGeoJSON(j, U) {
            return T._(this, void 0, void 0, (function*() {
              const {
                promoteId: Y
              } = j;
              if (j.request) {
                const ie = yield T.j(j.request, U);
                return this._dataUpdateable = T.cV(ie.data, Y) ? T.cU(ie.data, Y) : void 0, ie.data
              }
              if (typeof j.data == "string") try {
                const ie = JSON.parse(j.data);
                return this._dataUpdateable = T.cV(ie, Y) ? T.cU(ie, Y) : void 0, ie
              } catch {
                throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`)
              }
              if (!j.dataDiff) throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${j.source}`);
              return T.cW(this._dataUpdateable, j.dataDiff, Y), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(j) {
            return T._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(j) {
            return this._geoJSONIndex.getClusterExpansionZoom(j.clusterId)
          }
          getClusterChildren(j) {
            return this._geoJSONIndex.getChildren(j.clusterId)
          }
          getClusterLeaves(j) {
            return this._geoJSONIndex.getLeaves(j.clusterId, j.limit, j.offset)
          }
        }
        class Ar {
          constructor(j) {
            this.self = j, this.actor = new T.J(j), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (U, Y) => {
              if (this.externalWorkerSourceTypes[U]) throw new Error(`Worker source with name "${U}" already registered.`);
              this.externalWorkerSourceTypes[U] = Y
            }, this.self.addProtocol = T.cA, this.self.removeProtocol = T.cB, this.self.registerRTLTextPlugin = U => {
              T.cX.setMethods(U)
            }, this.actor.registerMessageHandler("LDT", ((U, Y) => this._getDEMWorkerSource(U, Y.source).loadTile(Y))), this.actor.registerMessageHandler("RDT", ((U, Y) => T._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(U, Y.source).removeTile(Y)
            })))), this.actor.registerMessageHandler("GCEZ", ((U, Y) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Y.type, Y.source).getClusterExpansionZoom(Y)
            })))), this.actor.registerMessageHandler("GCC", ((U, Y) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Y.type, Y.source).getClusterChildren(Y)
            })))), this.actor.registerMessageHandler("GCL", ((U, Y) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Y.type, Y.source).getClusterLeaves(Y)
            })))), this.actor.registerMessageHandler("LD", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).loadData(Y))), this.actor.registerMessageHandler("GD", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).getData())), this.actor.registerMessageHandler("LT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).loadTile(Y))), this.actor.registerMessageHandler("RT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).reloadTile(Y))), this.actor.registerMessageHandler("AT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).abortTile(Y))), this.actor.registerMessageHandler("RMT", ((U, Y) => this._getWorkerSource(U, Y.type, Y.source).removeTile(Y))), this.actor.registerMessageHandler("RS", ((U, Y) => T._(this, void 0, void 0, (function*() {
              if (!this.workerSources[U] || !this.workerSources[U][Y.type] || !this.workerSources[U][Y.type][Y.source]) return;
              const ie = this.workerSources[U][Y.type][Y.source];
              delete this.workerSources[U][Y.type][Y.source], ie.removeSource !== void 0 && ie.removeSource(Y)
            })))), this.actor.registerMessageHandler("RM", (U => T._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[U], delete this.availableImages[U], delete this.workerSources[U], delete this.demWorkerSources[U]
            })))), this.actor.registerMessageHandler("SR", ((U, Y) => T._(this, void 0, void 0, (function*() {
              this.referrer = Y
            })))), this.actor.registerMessageHandler("SRPS", ((U, Y) => this._syncRTLPluginState(U, Y))), this.actor.registerMessageHandler("IS", ((U, Y) => T._(this, void 0, void 0, (function*() {
              this.self.importScripts(Y)
            })))), this.actor.registerMessageHandler("SI", ((U, Y) => this._setImages(U, Y))), this.actor.registerMessageHandler("UL", ((U, Y) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).update(Y.layers, Y.removedIds)
            })))), this.actor.registerMessageHandler("SL", ((U, Y) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).replace(Y)
            }))))
          }
          _setImages(j, U) {
            return T._(this, void 0, void 0, (function*() {
              this.availableImages[j] = U;
              for (const Y in this.workerSources[j]) {
                const ie = this.workerSources[j][Y];
                for (const he in ie) ie[he].availableImages = U
              }
            }))
          }
          _syncRTLPluginState(j, U) {
            return T._(this, void 0, void 0, (function*() {
              return yield T.cX.syncState(U, this.self.importScripts)
            }))
          }
          _getAvailableImages(j) {
            let U = this.availableImages[j];
            return U || (U = []), U
          }
          _getLayerIndex(j) {
            let U = this.layerIndexes[j];
            return U || (U = this.layerIndexes[j] = new o), U
          }
          _getWorkerSource(j, U, Y) {
            if (this.workerSources[j] || (this.workerSources[j] = {}), this.workerSources[j][U] || (this.workerSources[j][U] = {}), !this.workerSources[j][U][Y]) {
              const ie = {
                sendAsync: (he, Te) => (he.targetMapId = j, this.actor.sendAsync(he, Te))
              };
              switch (U) {
                case "vector":
                  this.workerSources[j][U][Y] = new K(ie, this._getLayerIndex(j), this._getAvailableImages(j));
                  break;
                case "geojson":
                  this.workerSources[j][U][Y] = new gr(ie, this._getLayerIndex(j), this._getAvailableImages(j));
                  break;
                default:
                  this.workerSources[j][U][Y] = new this.externalWorkerSourceTypes[U](ie, this._getLayerIndex(j), this._getAvailableImages(j))
              }
            }
            return this.workerSources[j][U][Y]
          }
          _getDEMWorkerSource(j, U) {
            return this.demWorkerSources[j] || (this.demWorkerSources[j] = {}), this.demWorkerSources[j][U] || (this.demWorkerSources[j][U] = new se), this.demWorkerSources[j][U]
          }
        }
        return T.i(self) && (self.worker = new Ar(self)), Ar
      })), M("index", ["exports", "./shared"], (function(T, o) {
        var B = "5.6.2";

        function N() {
          var h = new o.A(4);
          return o.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h
        }
        let W, K;
        const se = {
          now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
          frame(h, e, i) {
            const l = requestAnimationFrame((d => {
                u(), e(d)
              })),
              {
                unsubscribe: u
              } = o.s(h.signal, "abort", (() => {
                u(), cancelAnimationFrame(l), i(o.c())
              }), !1)
          },
          frameAsync(h) {
            return new Promise(((e, i) => {
              this.frame(h, e, i)
            }))
          },
          getImageData(h, e = 0) {
            return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
          },
          getImageCanvasContext(h) {
            const e = window.document.createElement("canvas"),
              i = e.getContext("2d", {
                willReadFrequently: !0
              });
            if (!i) throw new Error("failed to create canvas 2d context");
            return e.width = h.width, e.height = h.height, i.drawImage(h, 0, 0, h.width, h.height), i
          },
          resolveURL: h => (W || (W = document.createElement("a")), W.href = h, W.href),
          hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
          get prefersReducedMotion() {
            return !!matchMedia && (K == null && (K = matchMedia("(prefers-reduced-motion: reduce)")), K.matches)
          }
        };
        class X {
          static testProp(e) {
            if (!X.docStyle) return e[0];
            for (let i = 0; i < e.length; i++)
              if (e[i] in X.docStyle) return e[i];
            return e[0]
          }
          static create(e, i, l) {
            const u = window.document.createElement(e);
            return i !== void 0 && (u.className = i), l && l.appendChild(u), u
          }
          static createNS(e, i) {
            return window.document.createElementNS(e, i)
          }
          static disableDrag() {
            X.docStyle && X.selectProp && (X.userSelect = X.docStyle[X.selectProp], X.docStyle[X.selectProp] = "none")
          }
          static enableDrag() {
            X.docStyle && X.selectProp && (X.docStyle[X.selectProp] = X.userSelect)
          }
          static setTransform(e, i) {
            e.style[X.transformProp] = i
          }
          static addEventListener(e, i, l, u = {}) {
            e.addEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static removeEventListener(e, i, l, u = {}) {
            e.removeEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", X.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", X.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", X.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const i = e.getBoundingClientRect();
            return {
              x: i.width / e.offsetWidth || 1,
              y: i.height / e.offsetHeight || 1,
              boundingClientRect: i
            }
          }
          static getPoint(e, i, l) {
            const u = i.boundingClientRect;
            return new o.P((l.clientX - u.left) / i.x - e.clientLeft, (l.clientY - u.top) / i.y - e.clientTop)
          }
          static mousePos(e, i) {
            const l = X.getScale(e);
            return X.getPoint(e, l, i)
          }
          static touchPos(e, i) {
            const l = [],
              u = X.getScale(e);
            for (let d = 0; d < i.length; d++) l.push(X.getPoint(e, u, i[d]));
            return l
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              l = i.querySelectorAll("script");
            for (const u of l) u.remove();
            return X.clean(i), i.innerHTML
          }
          static isPossiblyDangerous(e, i) {
            const l = i.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !l.includes("javascript:") && !l.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const i = e.children;
            for (const l of i) X.removeAttributes(l), X.clean(l)
          }
          static removeAttributes(e) {
            for (const {
                name: i,
                value: l
              }
              of e.attributes) X.isPossiblyDangerous(i, l) && e.removeAttribute(i)
          }
        }
        X.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, X.selectProp = X.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), X.transformProp = X.testProp(["transform", "WebkitTransform"]);
        const me = {
          supported: !1,
          testSupport: function(h) {
            !ze && Ee && (Re ? Ie(h) : ge = h)
          }
        };
        let ge, Ee, ze = !1,
          Re = !1;

        function Ie(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, Ee), h.isContextLost()) return;
            me.supported = !0
          } catch {}
          h.deleteTexture(e), ze = !0
        }
        var Oe;
        typeof document < "u" && (Ee = document.createElement("img"), Ee.onload = () => {
          ge && Ie(ge), ge = null, Re = !0
        }, Ee.onerror = () => {
          ze = !0, ge = null
        }, Ee.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(h) {
          let e, i, l, u;
          h.resetRequestQueue = () => {
            e = [], i = 0, l = 0, u = {}
          }, h.addThrottleControl = S => {
            const P = l++;
            return u[P] = S, P
          }, h.removeThrottleControl = S => {
            delete u[S], g()
          }, h.getImage = (S, P, A = !0) => new Promise(((R, D) => {
            me.supported && (S.headers || (S.headers = {}), S.headers.accept = "image/webp,*/*"), o.e(S, {
              type: "image"
            }), e.push({
              abortController: P,
              requestParameters: S,
              supportImageRefresh: A,
              state: "queued",
              onError: O => {
                D(O)
              },
              onSuccess: O => {
                R(O)
              }
            }), g()
          }));
          const d = S => o._(this, void 0, void 0, (function*() {
              S.state = "running";
              const {
                requestParameters: P,
                supportImageRefresh: A,
                onError: R,
                onSuccess: D,
                abortController: O
              } = S, $ = A === !1 && !o.i(self) && !o.g(P.url) && (!P.headers || Object.keys(P.headers).reduce(((ne, le) => ne && le === "accept"), !0));
              i++;
              const te = $ ? b(P, O) : o.m(P, O);
              try {
                const ne = yield te;
                delete S.abortController, S.state = "completed", ne.data instanceof HTMLImageElement || o.b(ne.data) ? D(ne) : ne.data && D({
                  data: yield(ee = ne.data, typeof createImageBitmap == "function" ? o.f(ee) : o.h(ee)),
                  cacheControl: ne.cacheControl,
                  expires: ne.expires
                })
              } catch (ne) {
                delete S.abortController, R(ne)
              } finally {
                i--, g()
              }
              var ee
            })),
            g = () => {
              const S = (() => {
                for (const P of Object.keys(u))
                  if (u[P]()) return !0;
                return !1
              })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let P = i; P < S && e.length > 0; P++) {
                const A = e.shift();
                A.abortController.signal.aborted ? P-- : d(A)
              }
            },
            b = (S, P) => new Promise(((A, R) => {
              const D = new Image,
                O = S.url,
                $ = S.credentials;
              $ && $ === "include" ? D.crossOrigin = "use-credentials" : ($ && $ === "same-origin" || !o.d(O)) && (D.crossOrigin = "anonymous"), P.signal.addEventListener("abort", (() => {
                D.src = "", R(o.c())
              })), D.fetchPriority = "high", D.onload = () => {
                D.onerror = D.onload = null, A({
                  data: D
                })
              }, D.onerror = () => {
                D.onerror = D.onload = null, P.signal.aborted || R(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, D.src = O
            }))
        })(Oe || (Oe = {})), Oe.resetRequestQueue();
        class st {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, i) {
            return this._transformRequestFn && this._transformRequestFn(e, i) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function nt(h) {
          const e = [];
          if (typeof h == "string") e.push({
            id: "default",
            url: h
          });
          else if (h && h.length > 0) {
            const i = [];
            for (const {
                id: l,
                url: u
              }
              of h) {
              const d = `${l}${u}`;
              i.indexOf(d) === -1 && (i.push(d), e.push({
                id: l,
                url: u
              }))
            }
          }
          return e
        }

        function qe(h, e, i) {
          try {
            const l = new URL(h);
            return l.pathname += `${e}${i}`, l.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function Ue(h) {
          const {
            userImage: e
          } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class Je extends o.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: i,
                  promiseResolve: l
                }
                of this.requestors) l(this._getImagesForIds(i));
              this.requestors = []
            }
          }
          getImage(e) {
            const i = this.images[e];
            if (i && !i.data && i.spriteData) {
              const l = i.spriteData;
              i.data = new o.R({
                width: l.width,
                height: l.height
              }, l.context.getImageData(l.x, l.y, l.width, l.height).data), i.spriteData = null
            }
            return i
          }
          addImage(e, i) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, i) && (this.images[e] = i)
          }
          _validate(e, i) {
            let l = !0;
            const u = i.data || i.spriteData;
            return this._validateStretch(i.stretchX, u && u.width) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchX" value`))), l = !1), this._validateStretch(i.stretchY, u && u.height) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchY" value`))), l = !1), this._validateContent(i.content, i) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "content" value`))), l = !1), l
          }
          _validateStretch(e, i) {
            if (!e) return !0;
            let l = 0;
            for (const u of e) {
              if (u[0] < l || u[1] < u[0] || i < u[1]) return !1;
              l = u[1]
            }
            return !0
          }
          _validateContent(e, i) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const l = i.spriteData,
              u = l && l.width || i.data.width,
              d = l && l.height || i.data.height;
            return !(e[0] < 0 || u < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || u < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, i, l = !0) {
            const u = this.getImage(e);
            if (l && (u.data.width !== i.data.width || u.data.height !== i.data.height)) throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${i.data.width}x${i.data.height}).`);
            i.version = u.version + 1, this.images[e] = i, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const i = this.images[e];
            delete this.images[e], delete this.patterns[e], i.userImage && i.userImage.onRemove && i.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((i, l) => {
              let u = !0;
              if (!this.isLoaded())
                for (const d of e) this.images[d] || (u = !1);
              this.isLoaded() || u ? i(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: i
              })
            }))
          }
          _getImagesForIds(e) {
            const i = {};
            for (const l of e) {
              let u = this.getImage(l);
              u || (this.fire(new o.l("styleimagemissing", {
                id: l
              })), u = this.getImage(l)), u ? i[l] = {
                data: u.data.clone(),
                pixelRatio: u.pixelRatio,
                sdf: u.sdf,
                version: u.version,
                stretchX: u.stretchX,
                stretchY: u.stretchY,
                content: u.content,
                textFitWidth: u.textFitWidth,
                textFitHeight: u.textFitHeight,
                hasRenderCallback: !!(u.userImage && u.userImage.render)
              } : o.w(`Image "${l}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return i
          }
          getPixelSize() {
            const {
              width: e,
              height: i
            } = this.atlasImage;
            return {
              width: e,
              height: i
            }
          }
          getPattern(e) {
            const i = this.patterns[e],
              l = this.getImage(e);
            if (!l) return null;
            if (i && i.position.version === l.version) return i.position;
            if (i) i.position.version = l.version;
            else {
              const u = {
                  w: l.data.width + 2,
                  h: l.data.height + 2,
                  x: 0,
                  y: 0
                },
                d = new o.I(u, l);
              this.patterns[e] = {
                bin: u,
                position: d
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const i = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.T(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const d in this.patterns) e.push(this.patterns[d].bin);
            const {
              w: i,
              h: l
            } = o.p(e), u = this.atlasImage;
            u.resize({
              width: i || 1,
              height: l || 1
            });
            for (const d in this.patterns) {
              const {
                bin: g
              } = this.patterns[d], b = g.x + 1, S = g.y + 1, P = this.getImage(d).data, A = P.width, R = P.height;
              o.R.copy(P, u, {
                x: 0,
                y: 0
              }, {
                x: b,
                y: S
              }, {
                width: A,
                height: R
              }), o.R.copy(P, u, {
                x: 0,
                y: R - 1
              }, {
                x: b,
                y: S - 1
              }, {
                width: A,
                height: 1
              }), o.R.copy(P, u, {
                x: 0,
                y: 0
              }, {
                x: b,
                y: S + R
              }, {
                width: A,
                height: 1
              }), o.R.copy(P, u, {
                x: A - 1,
                y: 0
              }, {
                x: b - 1,
                y: S
              }, {
                width: 1,
                height: R
              }), o.R.copy(P, u, {
                x: 0,
                y: 0
              }, {
                x: b + A,
                y: S
              }, {
                width: 1,
                height: R
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const i of e) {
              if (this.callbackDispatchedThisFrame[i]) continue;
              this.callbackDispatchedThisFrame[i] = !0;
              const l = this.getImage(i);
              l || o.w(`Image with ID: "${i}" was not found`), Ue(l) && this.updateImage(i, l)
            }
          }
        }
        const Fe = 1e20;

        function it(h, e, i, l, u, d, g, b, S) {
          for (let P = e; P < e + l; P++) tt(h, i * d + P, d, u, g, b, S);
          for (let P = i; P < i + u; P++) tt(h, P * d + e, 1, l, g, b, S)
        }

        function tt(h, e, i, l, u, d, g) {
          d[0] = 0, g[0] = -Fe, g[1] = Fe, u[0] = h[e];
          for (let b = 1, S = 0, P = 0; b < l; b++) {
            u[b] = h[e + b * i];
            const A = b * b;
            do {
              const R = d[S];
              P = (u[b] - u[R] + A - R * R) / (b - R) / 2
            } while (P <= g[S] && --S > -1);
            S++, d[S] = b, g[S] = P, g[S + 1] = Fe
          }
          for (let b = 0, S = 0; b < l; b++) {
            for (; g[S + 1] < b;) S++;
            const P = d[S],
              A = b - P;
            h[e + b * i] = u[P] + A * A
          }
        }
        class $e {
          constructor(e, i) {
            this.requestManager = e, this.localIdeographFontFamily = i, this.entries = {}
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return o._(this, void 0, void 0, (function*() {
              const i = [];
              for (const d in e)
                for (const g of e[d]) i.push(this._getAndCacheGlyphsPromise(d, g));
              const l = yield Promise.all(i), u = {};
              for (const {
                  stack: d,
                  id: g,
                  glyph: b
                }
                of l) u[d] || (u[d] = {}), u[d][g] = b && {
                id: b.id,
                bitmap: b.bitmap.clone(),
                metrics: b.metrics
              };
              return u
            }))
          }
          _getAndCacheGlyphsPromise(e, i) {
            return o._(this, void 0, void 0, (function*() {
              let l = this.entries[e];
              l || (l = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let u = l.glyphs[i];
              if (u !== void 0) return {
                stack: e,
                id: i,
                glyph: u
              };
              if (u = this._tinySDF(l, e, i), u) return l.glyphs[i] = u, {
                stack: e,
                id: i,
                glyph: u
              };
              const d = Math.floor(i / 256);
              if (256 * d > 65535) throw new Error("glyphs > 65535 not supported");
              if (l.ranges[d]) return {
                stack: e,
                id: i,
                glyph: u
              };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!l.requests[d]) {
                const b = $e.loadGlyphRange(e, d, this.url, this.requestManager);
                l.requests[d] = b
              }
              const g = yield l.requests[d];
              for (const b in g) this._doesCharSupportLocalGlyph(+b) || (l.glyphs[+b] = g[+b]);
              return l.ranges[d] = !0, {
                stack: e,
                id: i,
                glyph: g[i] || null
              }
            }))
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || o.u["CJK Unified Ideographs"](e) || o.u["Hangul Syllables"](e) || o.u.Hiragana(e) || o.u.Katakana(e) || o.u["CJK Symbols and Punctuation"](e) || o.u["Halfwidth and Fullwidth Forms"](e))
          }
          _tinySDF(e, i, l) {
            const u = this.localIdeographFontFamily;
            if (!u || !this._doesCharSupportLocalGlyph(l)) return;
            let d = e.tinySDF;
            if (!d) {
              let b = "400";
              /bold/i.test(i) ? b = "900" : /medium/i.test(i) ? b = "500" : /light/i.test(i) && (b = "200"), d = e.tinySDF = new $e.TinySDF({
                fontSize: 48,
                buffer: 6,
                radius: 16,
                cutoff: .25,
                fontFamily: u,
                fontWeight: b
              })
            }
            const g = d.draw(String.fromCharCode(l));
            return {
              id: l,
              bitmap: new o.q({
                width: g.width || 60,
                height: g.height || 60
              }, g.data),
              metrics: {
                width: g.glyphWidth / 2 || 24,
                height: g.glyphHeight / 2 || 24,
                left: g.glyphLeft / 2 + .5 || 0,
                top: g.glyphTop / 2 - 27.5 || -8,
                advance: g.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
        }
        $e.loadGlyphRange = function(h, e, i, l) {
          return o._(this, void 0, void 0, (function*() {
            const u = 256 * e,
              d = u + 255,
              g = l.transformRequest(i.replace("{fontstack}", h).replace("{range}", `${u}-${d}`), "Glyphs"),
              b = yield o.n(g, new AbortController);
            if (!b || !b.data) throw new Error(`Could not load glyph range. range: ${e}, ${u}-${d}`);
            const S = {};
            for (const P of o.o(b.data)) S[P.id] = P;
            return S
          }))
        }, $e.TinySDF = class {
          constructor({
            fontSize: h = 24,
            buffer: e = 3,
            radius: i = 8,
            cutoff: l = .25,
            fontFamily: u = "sans-serif",
            fontWeight: d = "normal",
            fontStyle: g = "normal",
            lang: b = null
          } = {}) {
            this.buffer = e, this.cutoff = l, this.radius = i, this.lang = b;
            const S = this.size = h + 4 * e,
              P = this._createCanvas(S),
              A = this.ctx = P.getContext("2d", {
                willReadFrequently: !0
              });
            A.font = `${g} ${d} ${h}px ${u}`, A.textBaseline = "alphabetic", A.textAlign = "left", A.fillStyle = "black", this.gridOuter = new Float64Array(S * S), this.gridInner = new Float64Array(S * S), this.f = new Float64Array(S), this.z = new Float64Array(S + 1), this.v = new Uint16Array(S)
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e
          }
          draw(h) {
            const {
              width: e,
              actualBoundingBoxAscent: i,
              actualBoundingBoxDescent: l,
              actualBoundingBoxLeft: u,
              actualBoundingBoxRight: d
            } = this.ctx.measureText(h), g = Math.ceil(i), b = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - u))), S = Math.min(this.size - this.buffer, g + Math.ceil(l)), P = b + 2 * this.buffer, A = S + 2 * this.buffer, R = Math.max(P * A, 0), D = new Uint8ClampedArray(R), O = {
              data: D,
              width: P,
              height: A,
              glyphWidth: b,
              glyphHeight: S,
              glyphTop: g,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (b === 0 || S === 0) return O;
            const {
              ctx: $,
              buffer: te,
              gridInner: ee,
              gridOuter: ne
            } = this;
            this.lang && ($.lang = this.lang), $.clearRect(te, te, b, S), $.fillText(h, te, te + g);
            const le = $.getImageData(te, te, b, S);
            ne.fill(Fe, 0, R), ee.fill(0, 0, R);
            for (let fe = 0; fe < S; fe++)
              for (let de = 0; de < b; de++) {
                const be = le.data[4 * (fe * b + de) + 3] / 255;
                if (be === 0) continue;
                const Ce = (fe + te) * P + de + te;
                if (be === 1) ne[Ce] = 0, ee[Ce] = Fe;
                else {
                  const pe = .5 - be;
                  ne[Ce] = pe > 0 ? pe * pe : 0, ee[Ce] = pe < 0 ? pe * pe : 0
                }
              }
            it(ne, 0, 0, P, A, P, this.f, this.v, this.z), it(ee, te, te, b, S, P, this.f, this.v, this.z);
            for (let fe = 0; fe < R; fe++) {
              const de = Math.sqrt(ne[fe]) - Math.sqrt(ee[fe]);
              D[fe] = Math.round(255 - 255 * (de / this.radius + this.cutoff))
            }
            return O
          }
        };
        class Ae {
          constructor() {
            this.specification = o.v.light.position
          }
          possiblyEvaluate(e, i) {
            return o.B(e.expression.evaluate(i))
          }
          interpolate(e, i, l) {
            return {
              x: o.C.number(e.x, i.x, l),
              y: o.C.number(e.y, i.y, l),
              z: o.C.number(e.z, i.z, l)
            }
          }
        }
        let gt;
        class Q extends o.E {
          constructor(e) {
            super(), gt = gt || new o.r({
              anchor: new o.D(o.v.light.anchor),
              position: new Ae,
              color: new o.D(o.v.light.color),
              intensity: new o.D(o.v.light.intensity)
            }), this._transitionable = new o.t(gt), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, i = {}) {
            if (!this._validate(o.x, e, i))
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l) {
            return (!l || l.validate !== !1) && o.y(this, e.call(o.z, {
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: o.v
            }))
          }
        }
        const re = new o.r({
          "sky-color": new o.D(o.v.sky["sky-color"]),
          "horizon-color": new o.D(o.v.sky["horizon-color"]),
          "fog-color": new o.D(o.v.sky["fog-color"]),
          "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]),
          "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]),
          "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"])
        });
        class _e extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(re), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0))
          }
          setSky(e, i = {}) {
            if (!this._validate(o.G, e, i)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l = {}) {
            return (l == null ? void 0 : l.validate) !== !1 && o.y(this, e.call(o.z, o.e({
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: o.v
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class ae {
          constructor(e, i) {
            this.width = e, this.height = i, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, i) {
            const l = e.join(",") + String(i);
            return this.dashEntry[l] || (this.dashEntry[l] = this.addDash(e, i)), this.dashEntry[l]
          }
          getDashRanges(e, i, l) {
            const u = [];
            let d = e.length % 2 == 1 ? -e[e.length - 1] * l : 0,
              g = e[0] * l,
              b = !0;
            u.push({
              left: d,
              right: g,
              isDash: b,
              zeroLength: e[0] === 0
            });
            let S = e[0];
            for (let P = 1; P < e.length; P++) {
              b = !b;
              const A = e[P];
              d = S * l, S += A, g = S * l, u.push({
                left: d,
                right: g,
                isDash: b,
                zeroLength: A === 0
              })
            }
            return u
          }
          addRoundDash(e, i, l) {
            const u = i / 2;
            for (let d = -l; d <= l; d++) {
              const g = this.width * (this.nextRow + l + d);
              let b = 0,
                S = e[b];
              for (let P = 0; P < this.width; P++) {
                P / S.right > 1 && (S = e[++b]);
                const A = Math.abs(P - S.left),
                  R = Math.abs(P - S.right),
                  D = Math.min(A, R);
                let O;
                const $ = d / l * (u + 1);
                if (S.isDash) {
                  const te = u - Math.abs($);
                  O = Math.sqrt(D * D + te * te)
                } else O = u - Math.sqrt(D * D + $ * $);
                this.data[g + P] = Math.max(0, Math.min(255, O + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let b = e.length - 1; b >= 0; --b) {
              const S = e[b],
                P = e[b + 1];
              S.zeroLength ? e.splice(b, 1) : P && P.isDash === S.isDash && (P.left = S.left, e.splice(b, 1))
            }
            const i = e[0],
              l = e[e.length - 1];
            i.isDash === l.isDash && (i.left = l.left - this.width, l.right = i.right + this.width);
            const u = this.width * this.nextRow;
            let d = 0,
              g = e[d];
            for (let b = 0; b < this.width; b++) {
              b / g.right > 1 && (g = e[++d]);
              const S = Math.abs(b - g.left),
                P = Math.abs(b - g.right),
                A = Math.min(S, P);
              this.data[u + b] = Math.max(0, Math.min(255, (g.isDash ? A : -A) + 128))
            }
          }
          addDash(e, i) {
            const l = i ? 7 : 0,
              u = 2 * l + 1;
            if (this.nextRow + u > this.height) return o.w("LineAtlas out of space"), null;
            let d = 0;
            for (let b = 0; b < e.length; b++) d += e[b];
            if (d !== 0) {
              const b = this.width / d,
                S = this.getDashRanges(e, this.width, b);
              i ? this.addRoundDash(S, b, l) : this.addRegularDash(S)
            }
            const g = {
              y: (this.nextRow + l + .5) / this.height,
              height: 2 * l / this.height,
              width: d
            };
            return this.nextRow += u, this.dirty = !0, g
          }
          bind(e) {
            const i = e.gl;
            this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data))
          }
        }
        const ke = "maplibre_preloaded_worker_pool";
        class Le {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Le.workerCount;) this.workers.push(new Worker(o.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((i => {
              i.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[ke]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const lt = Math.floor(se.hardwareConcurrency / 2);
        let We, _t;

        function zt() {
          return We || (We = new Le), We
        }
        Le.workerCount = o.H(globalThis) ? Math.max(Math.min(lt, 3), 1) : 1;
        class Dt {
          constructor(e, i) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i;
            const l = this.workerPool.acquire(i);
            for (let u = 0; u < l.length; u++) {
              const d = new o.J(l[u], i);
              d.name = `Worker ${u}`, this.actors.push(d)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, i) {
            const l = [];
            for (const u of this.actors) l.push(u.sendAsync({
              type: e,
              data: i
            }));
            return Promise.all(l)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((i => {
              i.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, i) {
            for (const l of this.actors) l.registerMessageHandler(e, i)
          }
        }

        function ot() {
          return _t || (_t = new Dt(zt(), o.K), _t.registerMessageHandler("GR", ((h, e, i) => o.m(e, i)))), _t
        }

        function dt(h, e) {
          const i = o.L();
          return o.M(i, i, [1, 1, 0]), o.N(i, i, [.5 * h.width, .5 * h.height, 1]), h.calculatePosMatrix ? o.O(i, i, h.calculatePosMatrix(e.toUnwrapped())) : i
        }

        function vt(h, e, i, l, u, d, g) {
          var b;
          const S = (function(D, O, $) {
              if (D)
                for (const te of D) {
                  const ee = O[te];
                  if (ee && ee.source === $ && ee.type === "fill-extrusion") return !0
                } else
                  for (const te in O) {
                    const ee = O[te];
                    if (ee.source === $ && ee.type === "fill-extrusion") return !0
                  }
              return !1
            })((b = u == null ? void 0 : u.layers) !== null && b !== void 0 ? b : null, e, h.id),
            P = d.maxPitchScaleFactor(),
            A = h.tilesIn(l, P, S);
          A.sort(ft);
          const R = [];
          for (const D of A) R.push({
            wrappedTileID: D.tileID.wrapped().key,
            queryResults: D.tile.queryRenderedFeatures(e, i, h._state, D.queryGeometry, D.cameraQueryGeometry, D.scale, u, d, P, dt(h.transform, D.tileID), g ? (O, $) => g(D.tileID, O, $) : void 0)
          });
          return (function(D, O) {
            for (const $ in D)
              for (const te of D[$]) Tt(te, O);
            return D
          })((function(D) {
            const O = {},
              $ = {};
            for (const te of D) {
              const ee = te.queryResults,
                ne = te.wrappedTileID,
                le = $[ne] = $[ne] || {};
              for (const fe in ee) {
                const de = ee[fe],
                  be = le[fe] = le[fe] || {},
                  Ce = O[fe] = O[fe] || [];
                for (const pe of de) be[pe.featureIndex] || (be[pe.featureIndex] = !0, Ce.push(pe))
              }
            }
            return O
          })(R), h)
        }

        function ft(h, e) {
          const i = h.tileID,
            l = e.tileID;
          return i.overscaledZ - l.overscaledZ || i.canonical.y - l.canonical.y || i.wrap - l.wrap || i.canonical.x - l.canonical.x
        }

        function Tt(h, e) {
          const i = h.feature,
            l = e.getFeatureState(i.layer["source-layer"], i.id);
          i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = l
        }

        function xt(h, e, i) {
          return o._(this, void 0, void 0, (function*() {
            let l = h;
            if (h.url ? l = (yield o.j(e.transformRequest(h.url, "Source"), i)).data : yield se.frameAsync(i), !l) return null;
            const u = o.Q(o.e(l, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in l && l.vector_layers && (u.vectorLayerIds = l.vector_layers.map((d => d.id))), u
          }))
        }
        class pt {
          constructor(e, i) {
            e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this
          }
          extend(e) {
            const i = this._sw,
              l = this._ne;
            let u, d;
            if (e instanceof o.S) u = e, d = e;
            else {
              if (!(e instanceof pt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(pt.convert(e)) : this.extend(o.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(o.S.convert(e)) : this;
              if (u = e._sw, d = e._ne, !u || !d) return this
            }
            return i || l ? (i.lng = Math.min(u.lng, i.lng), i.lat = Math.min(u.lat, i.lat), l.lng = Math.max(d.lng, l.lng), l.lat = Math.max(d.lat, l.lat)) : (this._sw = new o.S(u.lng, u.lat), this._ne = new o.S(d.lng, d.lat)), this
          }
          getCenter() {
            return new o.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new o.S(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new o.S(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: i,
              lat: l
            } = o.S.convert(e);
            let u = this._sw.lng <= i && i <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (u = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= l && l <= this._ne.lat && u
          }
          static convert(e) {
            return e instanceof pt ? e : e && new pt(e)
          }
          static fromLngLat(e, i = 0) {
            const l = 360 * i / 40075017,
              u = l / Math.cos(Math.PI / 180 * e.lat);
            return new pt(new o.S(e.lng - u, e.lat - l), new o.S(e.lng + u, e.lat + l))
          }
          adjustAntiMeridian() {
            const e = new o.S(this._sw.lng, this._sw.lat),
              i = new o.S(this._ne.lng, this._ne.lat);
            return new pt(e, e.lng > i.lng ? new o.S(i.lng + 360, i.lat) : i)
          }
        }
        class At {
          constructor(e, i, l) {
            this.bounds = pt.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = l || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const i = Math.pow(2, e.z),
              l = Math.floor(o.V(this.bounds.getWest()) * i),
              u = Math.floor(o.U(this.bounds.getNorth()) * i),
              d = Math.ceil(o.V(this.bounds.getEast()) * i),
              g = Math.ceil(o.U(this.bounds.getSouth()) * i);
            return e.x >= l && e.x < d && e.y >= u && e.y < g
          }
        }
        class Wt extends o.E {
          constructor(e, i, l, u) {
            if (super(), this.id = e, this.dispatcher = l, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.Q(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({
                type: "vector"
              }, i), this._collectResourceTiming = i.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(u)
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield xt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (o.e(this, e), e.bounds && (this.tileBounds = new At(e.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new o.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return o.e({}, this._options)
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = {
                  request: this.map._requestManager.transformRequest(i, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                  globalState: this.map.getGlobalState()
                };
              l.request.collectResourceTiming = this._collectResourceTiming;
              let u = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((d, g) => {
                  e.reloadPromise = {
                    resolve: d,
                    reject: g
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), u = "LT";
              e.abortController = new AbortController;
              try {
                const d = yield e.actor.sendAsync({
                  type: u,
                  data: l
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, d)
              } catch (d) {
                if (delete e.abortController, e.aborted) return;
                if (d && d.status !== 404) throw d;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, i) {
            if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), i && this.map._refreshExpiredTiles && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), e.reloadPromise) {
              const l = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(l.resolve).catch(l.reject)
            }
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class Xt extends o.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.dispatcher = l, this.setEventedParent(u), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({
              type: "raster"
            }, i), o.e(this, o.Q(i, ["url", "scheme", "tileSize"]))
          }
          load() {
            return o._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const i = yield xt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, i && (o.e(this, i), i.bounds && (this.tileBounds = new At(i.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (i) {
                this._tileJSONRequest = null, this.fire(new o.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return o.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const l = yield Oe.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (l && l.data) {
                  this.map._refreshExpiredTiles && (l.cacheControl || l.expires) && e.setExpiryData({
                    cacheControl: l.cacheControl,
                    expires: l.expires
                  });
                  const u = this.map.painter.context,
                    d = u.gl,
                    g = l.data;
                  e.texture = this.map.painter.getTileTexture(g.width), e.texture ? e.texture.update(g, {
                    useMipmap: !0
                  }) : (e.texture = new o.T(u, g, d.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (l) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (l) throw e.state = "errored", l
              }
            }))
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class rr extends Xt {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({
              type: "raster-dem"
            }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = this.map._requestManager.transformRequest(i, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const u = yield Oe.getImage(l, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (u && u.data) {
                  const d = u.data;
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                    cacheControl: u.cacheControl,
                    expires: u.expires
                  });
                  const g = o.b(d) && o.W() ? d : yield this.readImageNow(d), b = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: g,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const S = yield e.actor.sendAsync({
                      type: "LDT",
                      data: b
                    });
                    e.dem = S, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u
              }
            }))
          }
          readImageNow(e) {
            return o._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && o.X()) {
                const i = e.width + 2,
                  l = e.height + 2;
                try {
                  return new o.R({
                    width: i,
                    height: l
                  }, yield o.Y(e, -1, -1, i, l))
                } catch {}
              }
              return se.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const i = e.canonical,
              l = Math.pow(2, i.z),
              u = (i.x - 1 + l) % l,
              d = i.x === 0 ? e.wrap - 1 : e.wrap,
              g = (i.x + 1 + l) % l,
              b = i.x + 1 === l ? e.wrap + 1 : e.wrap,
              S = {};
            return S[new o.Z(e.overscaledZ, d, i.z, u, i.y).key] = {
              backfilled: !1
            }, S[new o.Z(e.overscaledZ, b, i.z, g, i.y).key] = {
              backfilled: !1
            }, i.y > 0 && (S[new o.Z(e.overscaledZ, d, i.z, u, i.y - 1).key] = {
              backfilled: !1
            }, S[new o.Z(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {
              backfilled: !1
            }, S[new o.Z(e.overscaledZ, b, i.z, g, i.y - 1).key] = {
              backfilled: !1
            }), i.y + 1 < l && (S[new o.Z(e.overscaledZ, d, i.z, u, i.y + 1).key] = {
              backfilled: !1
            }, S[new o.Z(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {
              backfilled: !1
            }, S[new o.Z(e.overscaledZ, b, i.z, g, i.y + 1).key] = {
              backfilled: !1
            }), S
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }
        class er extends o.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: i.data
            }, this.actor = l.getActor(), this.setEventedParent(u), this._data = i.data, this._options = o.e({}, i), this._collectResourceTiming = i.collectResourceTiming, i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = o.e({
              source: this.id,
              cluster: i.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128),
                tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : .375),
                extent: o.$,
                maxZoom: this.maxzoom,
                lineMetrics: i.lineMetrics || !1,
                generateId: i.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
                minPoints: Math.max(2, i.clusterMinPoints || 2),
                extent: o.$,
                radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                log: !1,
                generateId: i.generateId || !1
              },
              clusterProperties: i.clusterProperties,
              filter: i.filter
            }, i.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _pixelsToTileUnits(e) {
            return e * (o.$ / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const i = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${i}"`), i
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = o.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return o._(this, void 0, void 0, (function*() {
              const e = o.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map((i => i.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0)
          }
          getBounds() {
            return o._(this, void 0, void 0, (function*() {
              const e = new pt,
                i = yield this.getData();
              let l;
              switch (i.type) {
                case "FeatureCollection":
                  l = i.features.map((u => this.getCoordinatesFromGeometry(u.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  l = this.getCoordinatesFromGeometry(i.geometry);
                  break;
                default:
                  l = this.getCoordinatesFromGeometry(i)
              }
              if (l.length == 0) return e;
              for (let u = 0; u < l.length - 1; u += 2) e.extend([l[u], l[u + 1]]);
              return e
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, i, l) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: i,
                offset: l
              }
            })
          }
          _updateWorkerData() {
            return o._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              const {
                data: e,
                diff: i
              } = this._pendingWorkerUpdate;
              if (!e && !i) return void o.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const l = o.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (l.request = this.map._requestManager.transformRequest(se.resolveURL(e), "Source"), l.request.collectResourceTiming = this._collectResourceTiming) : l.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : i && (l.dataDiff = i, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new o.l("dataloading", {
                dataType: "source"
              }));
              try {
                const u = yield this.actor.sendAsync({
                  type: "LD",
                  data: l
                });
                if (this._isUpdatingWorker = !1, this._removed || u.abandoned) return void this.fire(new o.l("dataabort", {
                  dataType: "source"
                }));
                this._data = u.data;
                let d = null;
                u.resourceTiming && u.resourceTiming[this.id] && (d = u.resourceTiming[this.id].slice(0));
                const g = {
                  dataType: "source"
                };
                this._collectResourceTiming && d && d.length > 0 && o.e(g, {
                  resourceTiming: d
                }), this.fire(new o.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "metadata"
                }))), this.fire(new o.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "content"
                })))
              } catch (u) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new o.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new o.k(u))
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData()
              }
            }))
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const i = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const l = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                globalState: this.map.getGlobalState()
              };
              e.abortController = new AbortController;
              const u = yield this.actor.sendAsync({
                type: i,
                data: l
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(u, this.map.painter, i === "RT")
            }))
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return o.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class It extends o.E {
          constructor(e, i, l, u) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = l, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(u), this.options = i
          }
          load(e) {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const i = yield Oe.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, i && i.data && (this.image = i.data, e && (this.coordinates = e), this._finishLoading())
              } catch (i) {
                this._request = null, this._loaded = !0, this.fire(new o.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const i = e.map(o.a1.fromLngLat);
            var l;
            return this.tileID = (function(u) {
              const d = o.a2.fromPoints(u),
                g = d.width(),
                b = d.height(),
                S = Math.max(g, b),
                P = Math.max(0, Math.floor(-Math.log(S) / Math.LN2)),
                A = Math.pow(2, P);
              return new o.a4(P, Math.floor((d.minX + d.maxX) / 2 * A), Math.floor((d.minY + d.maxY) / 2 * A))
            })(i), this.terrainTileRanges = this._getOverlappingTileRanges(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map((u => this.tileID.getTilePoint(u)._round())), this.flippedWindingOrder = ((l = this.tileCoords)[1].x - l[0].x) * (l[2].y - l[0].y) - (l[1].y - l[0].y) * (l[2].x - l[0].x) < 0, this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture || (this.texture = new o.T(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const d = this.tiles[u];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, l = !0)
            }
            l && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: i,
              minY: l,
              maxX: u,
              maxY: d
            } = o.a2.fromPoints(e), g = {};
            for (let b = 0; b <= o.a3; b++) {
              const S = Math.pow(2, b),
                P = Math.floor(i * S),
                A = Math.floor(l * S),
                R = Math.floor(u * S),
                D = Math.floor(d * S);
              g[b] = {
                minTileX: P,
                minTileY: A,
                maxTileX: R,
                maxTileY: D
              }
            }
            return g
          }
        }
        class ur extends It {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.roundZoom = !0, this.type = "video", this.options = i
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, "Source").url);
              try {
                const i = yield o.a5(this.urls);
                if (this._loaded = !0, !i) return;
                this.video = i, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (i) {
                this.fire(new o.k(i))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const i = this.video.seekable;
              e < i.start(0) || e > i.end(0) ? this.fire(new o.k(new o.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const d = this.tiles[u];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, l = !0)
            }
            l && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class yr extends It {
          constructor(e, i, l, u) {
            super(e, i, l, u), i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some((d => !Array.isArray(d) || d.length !== 2 || d.some((g => typeof g != "number")))) || this.fire(new o.k(new o.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && typeof i.animate != "boolean" && this.fire(new o.k(new o.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = i.animate === void 0 || i.animate
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const i = this.map.painter.context,
              l = i.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new o.T(i, this.canvas, l.RGBA, {
              premultiply: !0
            });
            let u = !1;
            for (const d in this.tiles) {
              const g = this.tiles[d];
              g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, u = !0)
            }
            u && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const Mr = {},
          Gr = h => {
            switch (h) {
              case "geojson":
                return er;
              case "image":
                return It;
              case "raster":
                return Xt;
              case "raster-dem":
                return rr;
              case "vector":
                return Wt;
              case "video":
                return ur;
              case "canvas":
                return yr
            }
            return Mr[h]
          },
          xr = "RTLPluginLoaded";
        class Sr extends o.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = ot()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((i => {
              throw this.status = "error", i
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return o._(this, arguments, void 0, (function*(i, l = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = se.resolveURL(i), !this.url) throw new Error(`requested url ${i} is invalid`);
              if (this.status === "unavailable") {
                if (!l) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return o._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new o.l(xr))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let wr = null;

        function gr() {
          return wr || (wr = new Sr), wr
        }
        class Ar {
          constructor(e, i) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = o.a7(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          registerFadeDuration(e) {
            const i = e + this.timeAdded;
            i < this.fadeEndTime || (this.fadeEndTime = i)
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, i, l) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(u, d) {
                const g = {};
                if (!d) return g;
                for (const b of u) {
                  const S = b.layerIds.map((P => d.getLayer(P))).filter(Boolean);
                  if (S.length !== 0) {
                    b.layers = S, b.stateDependentLayerIds && (b.stateDependentLayers = b.stateDependentLayerIds.map((P => S.filter((A => A.id === P))[0])));
                    for (const P of S) g[P.id] = b
                  }
                }
                return g
              })(e.buckets, i == null ? void 0 : i.style), this.hasSymbolBuckets = !1;
              for (const u in this.buckets) {
                const d = this.buckets[u];
                if (d instanceof o.a9) {
                  if (this.hasSymbolBuckets = !0, !l) break;
                  d.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const u in this.buckets) {
                  const d = this.buckets[u];
                  if (d instanceof o.a9 && d.hasRTLText) {
                    this.hasRTLText = !0, gr().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const u in this.buckets) {
                const d = this.buckets[u];
                this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(u).queryRadius(d))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage)
            } else this.collisionBoxArray = new o.a8
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const l in this.buckets) {
              const u = this.buckets[l];
              u.uploadPending() && u.upload(e)
            }
            const i = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, i, l, u, d, g, b, S, P, A, R) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: u,
              cameraQueryGeometry: d,
              scale: g,
              tileSize: this.tileSize,
              pixelPosMatrix: A,
              transform: S,
              params: b,
              queryPadding: this.queryPadding * P,
              getElevation: R
            }, e, i, l) : {}
          }
          querySourceFeatures(e, i) {
            const l = this.latestFeatureIndex;
            if (!l || !l.rawTileData) return;
            const u = l.loadVTLayers(),
              d = i && i.sourceLayer ? i.sourceLayer : "",
              g = u._geojsonTileLayer || u[d];
            if (!g) return;
            const b = o.aa(i && i.filter),
              {
                z: S,
                x: P,
                y: A
              } = this.tileID.canonical,
              R = {
                z: S,
                x: P,
                y: A
              };
            for (let D = 0; D < g.length; D++) {
              const O = g.feature(D);
              if (b.needGeometry) {
                const ee = o.ab(O, !0);
                if (!b.filter(new o.F(this.tileID.overscaledZ), ee, this.tileID.canonical)) continue
              } else if (!b.filter(new o.F(this.tileID.overscaledZ), O)) continue;
              const $ = l.getId(O, d),
                te = new o.ac(O, S, P, A, $);
              te.tile = R, e.push(te)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const i = this.expirationTime;
            if (e.cacheControl) {
              const l = o.ad(e.cacheControl);
              l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const l = Date.now();
              let u = !1;
              if (this.expirationTime > l) u = !1;
              else if (i)
                if (this.expirationTime < i) u = !0;
                else {
                  const d = this.expirationTime - i;
                  d ? this.expirationTime = l + Math.max(d, 3e4) : u = !0
                }
              else u = !0;
              u ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, i) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const l = this.latestFeatureIndex.loadVTLayers();
            for (const u in this.buckets) {
              if (!i.style.hasLayer(u)) continue;
              const d = this.buckets[u],
                g = d.layers[0].sourceLayer || "_geojsonTileLayer",
                b = l[g],
                S = e[g];
              if (!b || !S || Object.keys(S).length === 0) continue;
              d.update(S, b, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const P = i && i.style && i.style.getLayer(u);
              P && (this.queryPadding = Math.max(this.queryPadding, P.queryRadius(d)))
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < se.now()
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = se.now() + e
          }
          setDependencies(e, i) {
            const l = {};
            for (const u of i) l[u] = !0;
            this.dependencies[e] = l
          }
          hasDependency(e, i) {
            for (const l of e) {
              const u = this.dependencies[l];
              if (u) {
                for (const d of i)
                  if (u[d]) return !0
              }
            }
            return !1
          }
        }
        class ue {
          constructor(e, i) {
            this.max = e, this.onRemove = i, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
            return this.data = {}, this.order = [], this
          }
          add(e, i, l) {
            const u = e.wrapped().key;
            this.data[u] === void 0 && (this.data[u] = []);
            const d = {
              value: i,
              timeout: void 0
            };
            if (l !== void 0 && (d.timeout = setTimeout((() => {
                this.remove(e, d)
              }), l)), this.data[u].push(d), this.order.push(u), this.order.length > this.max) {
              const g = this._getAndRemoveByKey(this.order[0]);
              g && this.onRemove(g)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const i = this.data[e].shift();
            return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value
          }
          getByKey(e) {
            const i = this.data[e];
            return i ? i[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, i) {
            if (!this.has(e)) return this;
            const l = e.wrapped().key,
              u = i === void 0 ? 0 : this.data[l].indexOf(i),
              d = this.data[l][u];
            return this.data[l].splice(u, 1), d.timeout && clearTimeout(d.timeout), this.data[l].length === 0 && delete this.data[l], this.onRemove(d.value), this.order.splice(this.order.indexOf(l), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const i = this._getAndRemoveByKey(this.order[0]);
              i && this.onRemove(i)
            }
            return this
          }
          filter(e) {
            const i = [];
            for (const l in this.data)
              for (const u of this.data[l]) e(u.value) || i.push(u);
            for (const l of i) this.remove(l.value.tileID, l)
          }
        }
        class j {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, i, l) {
            const u = String(i);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][u] = this.stateChanges[e][u] || {}, o.e(this.stateChanges[e][u], l), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const d in this.state[e]) d !== u && (this.deletedStates[e][d] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][u] === null) {
              this.deletedStates[e][u] = {};
              for (const d in this.state[e][u]) l[d] || (this.deletedStates[e][u][d] = null)
            } else
              for (const d in l) this.deletedStates[e] && this.deletedStates[e][u] && this.deletedStates[e][u][d] === null && delete this.deletedStates[e][u][d]
          }
          removeFeatureState(e, i, l) {
            if (this.deletedStates[e] === null) return;
            const u = String(i);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, l && i !== void 0) this.deletedStates[e][u] !== null && (this.deletedStates[e][u] = this.deletedStates[e][u] || {}, this.deletedStates[e][u][l] = null);
            else if (i !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][u])
                for (l in this.deletedStates[e][u] = {}, this.stateChanges[e][u]) this.deletedStates[e][u][l] = null;
              else this.deletedStates[e][u] = null;
            else this.deletedStates[e] = null
          }
          getState(e, i) {
            const l = String(i),
              u = o.e({}, (this.state[e] || {})[l], (this.stateChanges[e] || {})[l]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const d = this.deletedStates[e][i];
              if (d === null) return {};
              for (const g in d) delete u[g]
            }
            return u
          }
          initializeTileState(e, i) {
            e.setFeatureState(this.state, i)
          }
          coalesceChanges(e, i) {
            const l = {};
            for (const u in this.stateChanges) {
              this.state[u] = this.state[u] || {};
              const d = {};
              for (const g in this.stateChanges[u]) this.state[u][g] || (this.state[u][g] = {}), o.e(this.state[u][g], this.stateChanges[u][g]), d[g] = this.state[u][g];
              l[u] = d
            }
            for (const u in this.deletedStates) {
              this.state[u] = this.state[u] || {};
              const d = {};
              if (this.deletedStates[u] === null)
                for (const g in this.state[u]) d[g] = {}, this.state[u][g] = {};
              else
                for (const g in this.deletedStates[u]) {
                  if (this.deletedStates[u][g] === null) this.state[u][g] = {};
                  else
                    for (const b of Object.keys(this.deletedStates[u][g])) delete this.state[u][g][b];
                  d[g] = this.state[u][g]
                }
              l[u] = l[u] || {}, o.e(l[u], d)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
              for (const u in e) e[u].setFeatureState(l, i)
          }
        }
        const U = 89.25;

        function Y(h, e) {
          const i = o.ah(e.lat, -o.ai, o.ai);
          return new o.P(o.V(e.lng) * h, o.U(i) * h)
        }

        function ie(h, e) {
          return new o.a1(e.x / h, e.y / h).toLngLat()
        }

        function he(h) {
          return h.cameraToCenterDistance * Math.min(.85 * Math.tan(o.ae(90 - h.pitch)), Math.tan(o.ae(U - h.pitch)))
        }

        function Te(h, e) {
          const i = h.canonical,
            l = e / o.af(i.z),
            u = i.x + Math.pow(2, i.z) * h.wrap,
            d = o.ag(new Float64Array(16));
          return o.M(d, d, [u * l, i.y * l, 0]), o.N(d, d, [l / o.$, l / o.$, 1]), d
        }

        function Me(h, e, i, l, u) {
          const d = o.a1.fromLngLat(h, e),
            g = u * o.aj(1, h.lat),
            b = g * Math.cos(o.ae(i)),
            S = Math.sqrt(g * g - b * b),
            P = S * Math.sin(o.ae(-l)),
            A = S * Math.cos(o.ae(-l));
          return new o.a1(d.x + P, d.y + A, d.z + b)
        }

        function we(h, e, i) {
          const l = e.intersectsFrustum(h);
          if (!i || l === 0) return l;
          const u = e.intersectsPlane(i);
          return u === 0 ? 0 : l === 2 && u === 2 ? 2 : 1
        }

        function Ne(h, e, i) {
          let l = 0;
          const u = (i - e) / 10;
          for (let d = 0; d < 10; d++) l += u * Math.pow(Math.cos(e + (d + .5) / 10 * (i - e)), h);
          return l
        }

        function ct(h, e) {
          return function(i, l, u, d, g) {
            const b = 2 * ((h - 1) / o.ak(Math.cos(o.ae(U - g)) / Math.cos(o.ae(U))) - 1),
              S = Math.acos(u / d),
              P = 2 * Ne(b - 1, 0, o.ae(g / 2)),
              A = Math.min(o.ae(U), S + o.ae(g / 2)),
              R = Ne(b - 1, Math.min(A, S - o.ae(g / 2)), A),
              D = Math.atan(l / u),
              O = Math.hypot(l, u);
            let $ = i;
            return $ += o.ak(d / O / Math.max(.5, Math.cos(o.ae(g / 2)))), $ += b * o.ak(Math.cos(D)) / 2, $ -= o.ak(Math.max(1, R / P / e)) / 2, $
          }
        }
        const Qe = ct(9.314, 3);

        function kt(h, e) {
          const i = (e.roundZoom ? Math.round : Math.floor)(h.zoom + o.ak(h.tileSize / e.tileSize));
          return Math.max(0, i)
        }

        function xe(h, e) {
          const i = h.getCameraFrustum(),
            l = h.getClippingPlane(),
            u = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
            d = o.a1.fromLngLat(h.center, h.elevation);
          u.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const g = h.getCoveringTilesDetailsProvider(),
            b = g.allowVariableZoom(h, e),
            S = kt(h, e),
            P = e.minzoom || 0,
            A = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
            R = Math.min(Math.max(0, S), A),
            D = Math.pow(2, R),
            O = [D * u.x, D * u.y, 0],
            $ = [D * d.x, D * d.y, 0],
            te = Math.hypot(d.x - u.x, d.y - u.y),
            ee = Math.abs(d.z - u.z),
            ne = Math.hypot(te, ee),
            le = be => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: be,
              fullyVisible: !1
            }),
            fe = [],
            de = [];
          if (h.renderWorldCopies && g.allowWorldCopies())
            for (let be = 1; be <= 3; be++) fe.push(le(-be)), fe.push(le(be));
          for (fe.push(le(0)); fe.length > 0;) {
            const be = fe.pop(),
              Ce = be.x,
              pe = be.y;
            let Be = be.fullyVisible;
            const et = {
                x: Ce,
                y: pe,
                z: be.zoom
              },
              Ze = g.getTileBoundingVolume(et, be.wrap, h.elevation, e);
            if (!Be) {
              const Ft = we(i, Ze, l);
              if (Ft === 0) continue;
              Be = Ft === 2
            }
            const Ge = g.distanceToTile2d(u.x, u.y, et, Ze);
            let Ke = S;
            b && (Ke = (e.calculateTileZoom || Qe)(h.zoom + o.ak(h.tileSize / e.tileSize), Ge, ee, ne, h.fov)), Ke = (e.roundZoom ? Math.round : Math.floor)(Ke), Ke = Math.max(0, Ke);
            const Rt = Math.min(Ke, A);
            if (be.wrap = g.getWrap(d, et, be.wrap), be.zoom >= Rt) {
              if (be.zoom < P) continue;
              const Ft = R - be.zoom,
                St = O[0] - .5 - (Ce << Ft),
                pr = O[1] - .5 - (pe << Ft),
                Jr = e.reparseOverscaled ? Math.max(be.zoom, Ke) : be.zoom;
              de.push({
                tileID: new o.Z(be.zoom === A ? Jr : be.zoom, be.wrap, be.zoom, Ce, pe),
                distanceSq: o.al([$[0] - .5 - Ce, $[1] - .5 - pe]),
                tileDistanceToCamera: Math.sqrt(St * St + pr * pr)
              })
            } else
              for (let Ft = 0; Ft < 4; Ft++) fe.push({
                zoom: be.zoom + 1,
                x: (Ce << 1) + Ft % 2,
                y: (pe << 1) + (Ft >> 1),
                wrap: be.wrap,
                fullyVisible: Be
              })
          }
          return de.sort(((be, Ce) => be.distanceSq - Ce.distanceSq)).map((be => be.tileID))
        }
        const Nt = o.a2.fromPoints([new o.P(0, 0), new o.P(o.$, o.$)]);
        class Jt extends o.E {
          constructor(e, i, l) {
            super(), this.id = e, this.dispatcher = l, this.on("data", (u => this._dataHandler(u))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((u, d, g, b) => {
              const S = new(Gr(d.type))(u, d, g, b);
              if (S.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${S.id}`);
              return S
            })(e, i, l, this), this._tiles = {}, this._cache = new ue(0, (u => this._unloadTile(u))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new j, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const i = this._tiles[e];
              if (i.state !== "loaded" && i.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, i, l) {
            return o._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, i, l)
              } catch (u) {
                e.state = "errored", u.status !== 404 ? this._source.fire(new o.k(u, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new o.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const i in this._tiles) {
              const l = this._tiles[i];
              l.upload(e), l.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(jt).map((e => e.key))
          }
          getRenderableIds(e) {
            const i = [];
            for (const l in this._tiles) this._isIdRenderable(l, e) && i.push(this._tiles[l]);
            return e ? i.sort(((l, u) => {
              const d = l.tileID,
                g = u.tileID,
                b = new o.P(d.canonical.x, d.canonical.y)._rotate(-this.transform.bearingInRadians),
                S = new o.P(g.canonical.x, g.canonical.y)._rotate(-this.transform.bearingInRadians);
              return d.overscaledZ - g.overscaledZ || S.y - b.y || S.x - b.x
            })).map((l => l.tileID.key)) : i.map((l => l.tileID)).sort(jt).map((l => l.key))
          }
          hasRenderableParent(e) {
            const i = this.findLoadedParent(e, 0);
            return !!i && this._isIdRenderable(i.tileID.key)
          }
          _isIdRenderable(e, i) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (i || !this._tiles[e].holdingForFade())
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const i in this._tiles) e ? this._reloadTile(i, "expired") : this._tiles[i].state !== "errored" && this._reloadTile(i, "reloading")
            }
          }
          _reloadTile(e, i) {
            return o._(this, void 0, void 0, (function*() {
              const l = this._tiles[e];
              l && (l.state !== "loading" && (l.state = i), yield this._loadTile(l, e, i))
            }))
          }
          _tileLoaded(e, i, l) {
            e.timeAdded = se.now(), l === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new o.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const i = this.getRenderableIds();
            for (let u = 0; u < i.length; u++) {
              const d = i[u];
              if (e.neighboringTiles && e.neighboringTiles[d]) {
                const g = this.getTileByID(d);
                l(e, g), l(g, e)
              }
            }

            function l(u, d) {
              u.needsHillshadePrepare = !0, u.needsTerrainPrepare = !0;
              let g = d.tileID.canonical.x - u.tileID.canonical.x;
              const b = d.tileID.canonical.y - u.tileID.canonical.y,
                S = Math.pow(2, u.tileID.canonical.z),
                P = d.tileID.key;
              g === 0 && b === 0 || Math.abs(b) > 1 || (Math.abs(g) > 1 && (Math.abs(g + S) === 1 ? g += S : Math.abs(g - S) === 1 && (g -= S)), d.dem && u.dem && (u.dem.backfillBorder(d.dem, g, b), u.neighboringTiles && u.neighboringTiles[P] && (u.neighboringTiles[P].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, i, l, u) {
            for (const d in this._tiles) {
              let g = this._tiles[d];
              if (u[d] || !g.hasData() || g.tileID.overscaledZ <= i || g.tileID.overscaledZ > l) continue;
              let b = g.tileID;
              for (; g && g.tileID.overscaledZ > i + 1;) {
                const P = g.tileID.scaledTo(g.tileID.overscaledZ - 1);
                g = this._tiles[P.key], g && g.hasData() && (b = P)
              }
              let S = b;
              for (; S.overscaledZ > i;)
                if (S = S.scaledTo(S.overscaledZ - 1), e[S.key] || e[S.canonical.key]) {
                  u[b.key] = b;
                  break
                }
            }
          }
          findLoadedParent(e, i) {
            if (e.key in this._loadedParentTiles) {
              const l = this._loadedParentTiles[e.key];
              return l && l.tileID.overscaledZ >= i ? l : null
            }
            for (let l = e.overscaledZ - 1; l >= i; l--) {
              const u = e.scaledTo(l),
                d = this._getLoadedTile(u);
              if (d) return d
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e)
          }
          _getLoadedTile(e) {
            const i = this._tiles[e.key];
            return i && i.hasData() ? i : this._cache.getByKey(e.wrapped().key)
          }
          updateCacheSize(e) {
            const i = Math.ceil(e.width / this._source.tileSize) + 1,
              l = Math.ceil(e.height / this._source.tileSize) + 1,
              u = Math.floor(i * l * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
            this._cache.setMaxSize(d)
          }
          handleWrapJump(e) {
            const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, i) {
              const l = {};
              for (const u in this._tiles) {
                const d = this._tiles[u];
                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + i), l[d.tileID.key] = d
              }
              this._tiles = l;
              for (const u in this._timers) clearTimeout(this._timers[u]), delete this._timers[u];
              for (const u in this._tiles) this._setTileReloadTimer(u, this._tiles[u])
            }
          }
          _updateCoveredAndRetainedTiles(e, i, l, u, d, g) {
            const b = {},
              S = {},
              P = Object.keys(e),
              A = se.now();
            for (const R of P) {
              const D = e[R],
                O = this._tiles[R];
              if (!O || O.fadeEndTime !== 0 && O.fadeEndTime <= A) continue;
              const $ = this.findLoadedParent(D, i),
                te = this.findLoadedSibling(D),
                ee = $ || te || null;
              ee && (this._addTile(ee.tileID), b[ee.tileID.key] = ee.tileID), S[R] = D
            }
            this._retainLoadedChildren(S, u, l, e);
            for (const R in b) e[R] || (this._coveredTiles[R] = !0, e[R] = b[R]);
            if (g) {
              const R = {},
                D = {};
              for (const O of d) this._tiles[O.key].hasData() ? R[O.key] = O : D[O.key] = O;
              for (const O in D) {
                const $ = D[O].children(this._source.maxzoom);
                this._tiles[$[0].key] && this._tiles[$[1].key] && this._tiles[$[2].key] && this._tiles[$[3].key] && (R[$[0].key] = e[$[0].key] = $[0], R[$[1].key] = e[$[1].key] = $[1], R[$[2].key] = e[$[2].key] = $[2], R[$[3].key] = e[$[3].key] = $[3], delete D[O])
              }
              for (const O in D) {
                const $ = D[O],
                  te = this.findLoadedParent($, this._source.minzoom),
                  ee = this.findLoadedSibling($),
                  ne = te || ee || null;
                if (ne) {
                  R[ne.tileID.key] = e[ne.tileID.key] = ne.tileID;
                  for (const le in R) R[le].isChildOf(ne.tileID) && delete R[le]
                }
              }
              for (const O in this._tiles) R[O] || (this._coveredTiles[O] = !0)
            }
          }
          update(e, i) {
            if (!this._sourceLoaded || this._paused) return;
            let l;
            this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? l = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((A => new o.Z(A.canonical.z, A.wrap, A.canonical.z, A.canonical.x, A.canonical.y))) : (l = xe(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: i,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (l = l.filter((A => this._source.hasTile(A))))) : l = [];
            const u = kt(e, this._source),
              d = Math.max(u - Jt.maxOverzooming, this._source.minzoom),
              g = Math.max(u + Jt.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const A = {};
              for (const R of l)
                if (R.canonical.z > this._source.minzoom) {
                  const D = R.scaledTo(R.canonical.z - 1);
                  A[D.key] = D;
                  const O = R.scaledTo(Math.max(this._source.minzoom, Math.min(R.canonical.z, 5)));
                  A[O.key] = O
                } l = l.concat(Object.values(A))
            }
            const b = l.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, b && this.fire(new o.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const S = this._updateRetainedTiles(l, u);
            hr(this._source.type) && this._updateCoveredAndRetainedTiles(S, d, g, u, l, i);
            for (const A in S) this._tiles[A].clearFadeHold();
            const P = o.am(this._tiles, S);
            for (const A of P) {
              const R = this._tiles[A];
              R.hasSymbolBuckets && !R.holdingForFade() ? R.setHoldDuration(this.map._fadeDuration) : R.hasSymbolBuckets && !R.symbolFadeFinished() || this._removeTile(A)
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache()
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, i) {
            var l;
            const u = {},
              d = {},
              g = Math.max(i - Jt.maxOverzooming, this._source.minzoom),
              b = Math.max(i + Jt.maxUnderzooming, this._source.minzoom),
              S = {};
            for (const P of e) {
              const A = this._addTile(P);
              u[P.key] = P, A.hasData() || i < this._source.maxzoom && (S[P.key] = P)
            }
            this._retainLoadedChildren(S, i, b, u);
            for (const P of e) {
              let A = this._tiles[P.key];
              if (A.hasData()) continue;
              if (i + 1 > this._source.maxzoom) {
                const D = P.children(this._source.maxzoom)[0],
                  O = this.getTile(D);
                if (O && O.hasData()) {
                  u[D.key] = D;
                  continue
                }
              } else {
                const D = P.children(this._source.maxzoom);
                if (u[D[0].key] && u[D[1].key] && u[D[2].key] && u[D[3].key]) continue
              }
              let R = A.wasRequested();
              for (let D = P.overscaledZ - 1; D >= g; --D) {
                const O = P.scaledTo(D);
                if (d[O.key]) break;
                if (d[O.key] = !0, A = this.getTile(O), !A && R && (A = this._addTile(O)), A) {
                  const $ = A.hasData();
                  if (($ || !(!((l = this.map) === null || l === void 0) && l.cancelPendingTileRequestsWhileZooming) || R) && (u[O.key] = O), R = A.wasRequested(), $) break
                }
              }
            }
            return u
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const i = [];
              let l, u = this._tiles[e].tileID;
              for (; u.overscaledZ > 0;) {
                if (u.key in this._loadedParentTiles) {
                  l = this._loadedParentTiles[u.key];
                  break
                }
                i.push(u.key);
                const d = u.scaledTo(u.overscaledZ - 1);
                if (l = this._getLoadedTile(d), l) break;
                u = d
              }
              for (const d of i) this._loadedParentTiles[d] = l
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const i = this._tiles[e].tileID,
                l = this._getLoadedTile(i);
              this._loadedSiblingTiles[i.key] = l
            }
          }
          _addTile(e) {
            let i = this._tiles[e.key];
            if (i) return i;
            i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));
            const l = i;
            return i || (i = new Ar(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, l || this._source.fire(new o.l("dataloading", {
              tile: i,
              coord: i.tileID,
              dataType: "source"
            })), i
          }
          _setTileReloadTimer(e, i) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const l = i.getExpiryTimeout();
            l && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), l))
          }
          refreshTiles(e) {
            for (const i in this._tiles)(this._isIdRenderable(i) || this._tiles[i].state == "errored") && e.some((l => l.equals(this._tiles[i].tileID.canonical))) && this._reloadTile(i, "expired")
          }
          _removeTile(e) {
            const i = this._tiles[e];
            i && (i.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i))))
          }
          _dataHandler(e) {
            const i = e.sourceDataType;
            e.dataType === "source" && i === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && i === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, i, l) {
            const u = [],
              d = this.transform;
            if (!d) return u;
            const g = d.getCoveringTilesDetailsProvider().allowWorldCopies(),
              b = l ? d.getCameraQueryGeometry(e) : e,
              S = O => d.screenPointToMercatorCoordinate(O, this.terrain),
              P = this.transformBbox(e, S, !g),
              A = this.transformBbox(b, S, !g),
              R = this.getIds(),
              D = o.a2.fromPoints(A);
            for (let O = 0; O < R.length; O++) {
              const $ = this._tiles[R[O]];
              if ($.holdingForFade()) continue;
              const te = g ? [$.tileID] : [$.tileID.unwrapTo(-1), $.tileID.unwrapTo(0)],
                ee = Math.pow(2, d.zoom - $.tileID.overscaledZ),
                ne = i * $.queryPadding * o.$ / $.tileSize / ee;
              for (const le of te) {
                const fe = D.map((de => le.getTilePoint(new o.a1(de.x, de.y))));
                if (fe.expandBy(ne), fe.intersects(Nt)) {
                  const de = P.map((Ce => le.getTilePoint(Ce))),
                    be = A.map((Ce => le.getTilePoint(Ce)));
                  u.push({
                    tile: $,
                    tileID: g ? le : le.unwrapTo(0),
                    queryGeometry: de,
                    cameraQueryGeometry: be,
                    scale: ee
                  })
                }
              }
            }
            return u
          }
          transformBbox(e, i, l) {
            let u = e.map(i);
            if (l) {
              const d = o.a2.fromPoints(e);
              d.shrinkBy(.001 * Math.min(d.width(), d.height()));
              const g = d.map(i);
              o.a2.fromPoints(u).covers(g) || (u = u.map((b => b.x > .5 ? new o.a1(b.x - 1, b.y, b.z) : b)))
            }
            return u
          }
          getVisibleCoordinates(e) {
            const i = this.getRenderableIds(e).map((l => this._tiles[l].tileID));
            return this.transform && this.transform.populateCache(i), i
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (hr(this._source.type)) {
              const e = se.now();
              for (const i in this._tiles)
                if (this._tiles[i].fadeEndTime >= e) return !0
            }
            return !1
          }
          setFeatureState(e, i, l) {
            this._state.updateState(e = e || "_geojsonTileLayer", i, l)
          }
          removeFeatureState(e, i, l) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, l)
          }
          getFeatureState(e, i) {
            return this._state.getState(e = e || "_geojsonTileLayer", i)
          }
          setDependencies(e, i, l) {
            const u = this._tiles[e];
            u && u.setDependencies(i, l)
          }
          reloadTilesForDependencies(e, i) {
            for (const l in this._tiles) this._tiles[l].hasDependency(e, i) && this._reloadTile(l, "reloading");
            this._cache.filter((l => !l.hasDependency(e, i)))
          }
        }

        function jt(h, e) {
          const i = Math.abs(2 * h.wrap) - +(h.wrap < 0),
            l = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || l - i || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
        }

        function hr(h) {
          return h === "raster" || h === "image" || h === "video"
        }
        Jt.maxOverzooming = 10, Jt.maxUnderzooming = 3;
        class $r {
          constructor(e, i) {
            this.reset(e, i)
          }
          reset(e, i) {
            this.points = e || [], this._distances = [0];
            for (let l = 1; l < this.points.length; l++) this._distances[l] = this._distances[l - 1] + this.points[l].dist(this.points[l - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(i || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = o.ah(e, 0, 1);
            let i = 1,
              l = this._distances[i];
            const u = e * this.paddedLength + this.padding;
            for (; l < u && i < this._distances.length;) l = this._distances[++i];
            const d = i - 1,
              g = this._distances[d],
              b = l - g,
              S = b > 0 ? (u - g) / b : 0;
            return this.points[d].mult(1 - S).add(this.points[i].mult(S))
          }
        }

        function en(h, e) {
          let i = !0;
          return h === "always" || h !== "never" && e !== "never" || (i = !1), i
        }
        class tr {
          constructor(e, i, l) {
            const u = this.boxCells = [],
              d = this.circleCells = [];
            this.xCellCount = Math.ceil(e / l), this.yCellCount = Math.ceil(i / l);
            for (let g = 0; g < this.xCellCount * this.yCellCount; g++) u.push([]), d.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = i, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / i, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, i, l, u, d) {
            this._forEachCell(i, l, u, d, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(u), this.bboxes.push(d)
          }
          insertCircle(e, i, l, u) {
            this._forEachCell(i - u, l - u, i + u, l + u, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(i), this.circles.push(l), this.circles.push(u)
          }
          _insertBoxCell(e, i, l, u, d, g) {
            this.boxCells[d].push(g)
          }
          _insertCircleCell(e, i, l, u, d, g) {
            this.circleCells[d].push(g)
          }
          _query(e, i, l, u, d, g, b) {
            if (l < 0 || e > this.width || u < 0 || i > this.height) return [];
            const S = [];
            if (e <= 0 && i <= 0 && this.width <= l && this.height <= u) {
              if (d) return [{
                key: null,
                x1: e,
                y1: i,
                x2: l,
                y2: u
              }];
              for (let P = 0; P < this.boxKeys.length; P++) S.push({
                key: this.boxKeys[P],
                x1: this.bboxes[4 * P],
                y1: this.bboxes[4 * P + 1],
                x2: this.bboxes[4 * P + 2],
                y2: this.bboxes[4 * P + 3]
              });
              for (let P = 0; P < this.circleKeys.length; P++) {
                const A = this.circles[3 * P],
                  R = this.circles[3 * P + 1],
                  D = this.circles[3 * P + 2];
                S.push({
                  key: this.circleKeys[P],
                  x1: A - D,
                  y1: R - D,
                  x2: A + D,
                  y2: R + D
                })
              }
            } else this._forEachCell(e, i, l, u, this._queryCell, S, {
              hitTest: d,
              overlapMode: g,
              seenUids: {
                box: {},
                circle: {}
              }
            }, b);
            return S
          }
          query(e, i, l, u) {
            return this._query(e, i, l, u, !1, null)
          }
          hitTest(e, i, l, u, d, g) {
            return this._query(e, i, l, u, !0, d, g).length > 0
          }
          hitTestCircle(e, i, l, u, d) {
            const g = e - l,
              b = e + l,
              S = i - l,
              P = i + l;
            if (b < 0 || g > this.width || P < 0 || S > this.height) return !1;
            const A = [];
            return this._forEachCell(g, S, b, P, this._queryCellCircle, A, {
              hitTest: !0,
              overlapMode: u,
              circle: {
                x: e,
                y: i,
                radius: l
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, d), A.length > 0
          }
          _queryCell(e, i, l, u, d, g, b, S) {
            const {
              seenUids: P,
              hitTest: A,
              overlapMode: R
            } = b, D = this.boxCells[d];
            if (D !== null) {
              const $ = this.bboxes;
              for (const te of D)
                if (!P.box[te]) {
                  P.box[te] = !0;
                  const ee = 4 * te,
                    ne = this.boxKeys[te];
                  if (e <= $[ee + 2] && i <= $[ee + 3] && l >= $[ee + 0] && u >= $[ee + 1] && (!S || S(ne)) && (!A || !en(R, ne.overlapMode)) && (g.push({
                      key: ne,
                      x1: $[ee],
                      y1: $[ee + 1],
                      x2: $[ee + 2],
                      y2: $[ee + 3]
                    }), A)) return !0
                }
            }
            const O = this.circleCells[d];
            if (O !== null) {
              const $ = this.circles;
              for (const te of O)
                if (!P.circle[te]) {
                  P.circle[te] = !0;
                  const ee = 3 * te,
                    ne = this.circleKeys[te];
                  if (this._circleAndRectCollide($[ee], $[ee + 1], $[ee + 2], e, i, l, u) && (!S || S(ne)) && (!A || !en(R, ne.overlapMode))) {
                    const le = $[ee],
                      fe = $[ee + 1],
                      de = $[ee + 2];
                    if (g.push({
                        key: ne,
                        x1: le - de,
                        y1: fe - de,
                        x2: le + de,
                        y2: fe + de
                      }), A) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, i, l, u, d, g, b, S) {
            const {
              circle: P,
              seenUids: A,
              overlapMode: R
            } = b, D = this.boxCells[d];
            if (D !== null) {
              const $ = this.bboxes;
              for (const te of D)
                if (!A.box[te]) {
                  A.box[te] = !0;
                  const ee = 4 * te,
                    ne = this.boxKeys[te];
                  if (this._circleAndRectCollide(P.x, P.y, P.radius, $[ee + 0], $[ee + 1], $[ee + 2], $[ee + 3]) && (!S || S(ne)) && !en(R, ne.overlapMode)) return g.push(!0), !0
                }
            }
            const O = this.circleCells[d];
            if (O !== null) {
              const $ = this.circles;
              for (const te of O)
                if (!A.circle[te]) {
                  A.circle[te] = !0;
                  const ee = 3 * te,
                    ne = this.circleKeys[te];
                  if (this._circlesCollide($[ee], $[ee + 1], $[ee + 2], P.x, P.y, P.radius) && (!S || S(ne)) && !en(R, ne.overlapMode)) return g.push(!0), !0
                }
            }
          }
          _forEachCell(e, i, l, u, d, g, b, S) {
            const P = this._convertToXCellCoord(e),
              A = this._convertToYCellCoord(i),
              R = this._convertToXCellCoord(l),
              D = this._convertToYCellCoord(u);
            for (let O = P; O <= R; O++)
              for (let $ = A; $ <= D; $++)
                if (d.call(this, e, i, l, u, this.xCellCount * $ + O, g, b, S)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, i, l, u, d, g) {
            const b = u - e,
              S = d - i,
              P = l + g;
            return P * P > b * b + S * S
          }
          _circleAndRectCollide(e, i, l, u, d, g, b) {
            const S = (g - u) / 2,
              P = Math.abs(e - (u + S));
            if (P > S + l) return !1;
            const A = (b - d) / 2,
              R = Math.abs(i - (d + A));
            if (R > A + l) return !1;
            if (P <= S || R <= A) return !0;
            const D = P - S,
              O = R - A;
            return D * D + O * O <= l * l
          }
        }

        function Ht(h, e, i) {
          const l = o.L();
          if (!h) {
            const {
              vecSouth: R,
              vecEast: D
            } = ar(e), O = N();
            O[0] = D[0], O[1] = D[1], O[2] = R[0], O[3] = R[1], u = O, (A = (g = (d = O)[0]) * (P = d[3]) - (S = d[2]) * (b = d[1])) && (u[0] = P * (A = 1 / A), u[1] = -b * A, u[2] = -S * A, u[3] = g * A), l[0] = O[0], l[1] = O[1], l[4] = O[2], l[5] = O[3]
          }
          var u, d, g, b, S, P, A;
          return o.N(l, l, [1 / i, 1 / i, 1]), l
        }

        function Yt(h, e, i, l) {
          if (h) {
            const u = o.L();
            if (!e) {
              const {
                vecSouth: d,
                vecEast: g
              } = ar(i);
              u[0] = g[0], u[1] = g[1], u[4] = d[0], u[5] = d[1]
            }
            return o.N(u, u, [l, l, 1]), u
          }
          return i.pixelsToClipSpaceMatrix
        }

        function ar(h) {
          const e = Math.cos(h.rollInRadians),
            i = Math.sin(h.rollInRadians),
            l = Math.cos(h.pitchInRadians),
            u = Math.cos(h.bearingInRadians),
            d = Math.sin(h.bearingInRadians),
            g = o.ar();
          g[0] = -u * l * i - d * e, g[1] = -d * l * i + u * e;
          const b = o.as(g);
          b < 1e-9 ? o.at(g) : o.au(g, g, 1 / b);
          const S = o.ar();
          S[0] = u * l * e - d * i, S[1] = d * l * e + u * i;
          const P = o.as(S);
          return P < 1e-9 ? o.at(S) : o.au(S, S, 1 / P), {
            vecEast: S,
            vecSouth: g
          }
        }

        function qr(h, e, i, l) {
          let u;
          l ? (u = [h, e, l(h, e), 1], o.aw(u, u, i)) : (u = [h, e, 0, 1], Bn(u, u, i));
          const d = u[3];
          return {
            point: new o.P(u[0] / d, u[1] / d),
            signedDistanceFromCamera: d,
            isOccluded: !1
          }
        }

        function yt(h, e) {
          return .5 + h / e * .5
        }

        function sn(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
        }

        function Yr(h, e, i, l, u, d, g, b, S, P, A, R, D) {
          const O = i ? h.textSizeData : h.iconSizeData,
            $ = o.an(O, e.transform.zoom),
            te = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            ee = i ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          ee.clear();
          const ne = h.lineVertexArray,
            le = i ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
            fe = e.transform.width / e.transform.height;
          let de = !1;
          for (let be = 0; be < le.length; be++) {
            const Ce = le.get(be);
            if (Ce.hidden || Ce.writingMode === o.ao.vertical && !de) {
              vn(Ce.numGlyphs, ee);
              continue
            }
            de = !1;
            const pe = new o.P(Ce.anchorX, Ce.anchorY),
              Be = {
                getElevation: D,
                pitchedLabelPlaneMatrix: l,
                lineVertexArray: ne,
                pitchWithMap: d,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: pe,
                unwrappedTileID: S,
                width: P,
                height: A,
                translation: R
              },
              et = tn(Ce.anchorX, Ce.anchorY, Be);
            if (!sn(et.point, te)) {
              vn(Ce.numGlyphs, ee);
              continue
            }
            const Ze = yt(e.transform.cameraToCenterDistance, et.signedDistanceFromCamera),
              Ge = o.ap(O, $, Ce),
              Ke = d ? Ge * e.transform.getPitchedTextCorrection(Ce.anchorX, Ce.anchorY, S) / Ze : Ge * Ze,
              Rt = Xe({
                projectionContext: Be,
                pitchedLabelPlaneMatrixInverse: u,
                symbol: Ce,
                fontSize: Ke,
                flip: !1,
                keepUpright: g,
                glyphOffsetArray: h.glyphOffsetArray,
                dynamicLayoutVertexArray: ee,
                aspectRatio: fe,
                rotateToLine: b
              });
            de = Rt.useVertical, (Rt.notEnoughRoom || de || Rt.needsFlipping && Xe({
              projectionContext: Be,
              pitchedLabelPlaneMatrixInverse: u,
              symbol: Ce,
              fontSize: Ke,
              flip: !0,
              keepUpright: g,
              glyphOffsetArray: h.glyphOffsetArray,
              dynamicLayoutVertexArray: ee,
              aspectRatio: fe,
              rotateToLine: b
            }).notEnoughRoom) && vn(Ce.numGlyphs, ee)
          }
          i ? h.text.dynamicLayoutVertexBuffer.updateData(ee) : h.icon.dynamicLayoutVertexBuffer.updateData(ee)
        }

        function kn(h, e, i, l, u, d, g, b) {
          const S = d.glyphStartIndex + d.numGlyphs,
            P = d.lineStartIndex,
            A = d.lineStartIndex + d.lineLength,
            R = e.getoffsetX(d.glyphStartIndex),
            D = e.getoffsetX(S - 1),
            O = Cn(h * R, i, l, u, d.segment, P, A, b, g);
          if (!O) return null;
          const $ = Cn(h * D, i, l, u, d.segment, P, A, b, g);
          return $ ? b.projectionCache.anyProjectionOccluded ? null : {
            first: O,
            last: $
          } : null
        }

        function bt(h, e, i, l) {
          return h === o.ao.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * l ? {
            useVertical: !0
          } : (h === o.ao.vertical ? e.y < i.y : e.x > i.x) ? {
            needsFlipping: !0
          } : null
        }

        function Xe(h) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: i,
            symbol: l,
            fontSize: u,
            flip: d,
            keepUpright: g,
            glyphOffsetArray: b,
            dynamicLayoutVertexArray: S,
            aspectRatio: P,
            rotateToLine: A
          } = h, R = u / 24, D = l.lineOffsetX * R, O = l.lineOffsetY * R;
          let $;
          if (l.numGlyphs > 1) {
            const te = l.glyphStartIndex + l.numGlyphs,
              ee = l.lineStartIndex,
              ne = l.lineStartIndex + l.lineLength,
              le = kn(R, b, D, O, d, l, A, e);
            if (!le) return {
              notEnoughRoom: !0
            };
            const fe = Zr(le.first.point.x, le.first.point.y, e, i),
              de = Zr(le.last.point.x, le.last.point.y, e, i);
            if (g && !d) {
              const be = bt(l.writingMode, fe, de, P);
              if (be) return be
            }
            $ = [le.first];
            for (let be = l.glyphStartIndex + 1; be < te - 1; be++) {
              const Ce = Cn(R * b.getoffsetX(be), D, O, d, l.segment, ee, ne, e, A);
              if (!Ce) return {
                notEnoughRoom: !0
              };
              $.push(Ce)
            }
            $.push(le.last)
          } else {
            if (g && !d) {
              const ee = Cr(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                ne = l.lineStartIndex + l.segment + 1,
                le = new o.P(e.lineVertexArray.getx(ne), e.lineVertexArray.gety(ne)),
                fe = Cr(le.x, le.y, e),
                de = fe.signedDistanceFromCamera > 0 ? fe.point : Lt(e.tileAnchorPoint, le, ee, 1, e),
                be = Zr(ee.x, ee.y, e, i),
                Ce = Zr(de.x, de.y, e, i),
                pe = bt(l.writingMode, be, Ce, P);
              if (pe) return pe
            }
            const te = Cn(R * b.getoffsetX(l.glyphStartIndex), D, O, d, l.segment, l.lineStartIndex, l.lineStartIndex + l.lineLength, e, A);
            if (!te || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            $ = [te]
          }
          for (const te of $) o.av(S, te.point, te.angle);
          return {}
        }

        function Lt(h, e, i, l, u) {
          const d = h.add(h.sub(e)._unit()),
            g = Cr(d.x, d.y, u).point,
            b = i.sub(g);
          return i.add(b._mult(l / b.mag()))
        }

        function Vt(h, e, i) {
          const l = e.projectionCache;
          if (l.projections[h]) return l.projections[h];
          const u = new o.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)),
            d = Cr(u.x, u.y, e);
          if (d.signedDistanceFromCamera > 0) return l.projections[h] = d.point, l.anyProjectionOccluded = l.anyProjectionOccluded || d.isOccluded, d.point;
          const g = h - i.direction;
          return Lt(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new o.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), u, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e)
        }

        function Cr(h, e, i) {
          const l = h + i.translation[0],
            u = e + i.translation[1];
          let d;
          return i.pitchWithMap ? (d = qr(l, u, i.pitchedLabelPlaneMatrix, i.getElevation), d.isOccluded = !1) : (d = i.transform.projectTileCoordinates(l, u, i.unwrappedTileID, i.getElevation), d.point.x = (.5 * d.point.x + .5) * i.width, d.point.y = (.5 * -d.point.y + .5) * i.height), d
        }

        function Zr(h, e, i, l) {
          if (i.pitchWithMap) {
            const u = [h, e, 0, 1];
            return o.aw(u, u, l), i.transform.projectTileCoordinates(u[0] / u[3], u[1] / u[3], i.unwrappedTileID, i.getElevation).point
          }
          return {
            x: h / i.width * 2 - 1,
            y: 1 - e / i.height * 2
          }
        }

        function tn(h, e, i) {
          return i.transform.projectTileCoordinates(h, e, i.unwrappedTileID, i.getElevation)
        }

        function br(h, e, i) {
          return h._unit()._perp()._mult(e * i)
        }

        function pn(h, e, i, l, u, d, g, b, S) {
          if (b.projectionCache.offsets[h]) return b.projectionCache.offsets[h];
          const P = i.add(e);
          if (h + S.direction < l || h + S.direction >= u) return b.projectionCache.offsets[h] = P, P;
          const A = Vt(h + S.direction, b, S),
            R = br(A.sub(i), g, S.direction),
            D = i.add(R),
            O = A.add(R);
          return b.projectionCache.offsets[h] = o.ax(d, P, D, O) || P, b.projectionCache.offsets[h]
        }

        function Cn(h, e, i, l, u, d, g, b, S) {
          const P = l ? h - e : h + e;
          let A = P > 0 ? 1 : -1,
            R = 0;
          l && (A *= -1, R = Math.PI), A < 0 && (R += Math.PI);
          let D, O = A > 0 ? d + u : d + u + 1;
          b.projectionCache.cachedAnchorPoint ? D = b.projectionCache.cachedAnchorPoint : (D = Cr(b.tileAnchorPoint.x, b.tileAnchorPoint.y, b).point, b.projectionCache.cachedAnchorPoint = D);
          let $, te, ee = D,
            ne = D,
            le = 0,
            fe = 0;
          const de = Math.abs(P),
            be = [];
          let Ce;
          for (; le + fe <= de;) {
            if (O += A, O < d || O >= g) return null;
            le += fe, ne = ee, te = $;
            const et = {
              absOffsetX: de,
              direction: A,
              distanceFromAnchor: le,
              previousVertex: ne
            };
            if (ee = Vt(O, b, et), i === 0) be.push(ne), Ce = ee.sub(ne);
            else {
              let Ze;
              const Ge = ee.sub(ne);
              Ze = Ge.mag() === 0 ? br(Vt(O + A, b, et).sub(ee), i, A) : br(Ge, i, A), te || (te = ne.add(Ze)), $ = pn(O, Ze, ee, d, g, te, i, b, et), be.push(te), Ce = $.sub(te)
            }
            fe = Ce.mag()
          }
          const pe = Ce._mult((de - le) / fe)._add(te || ne),
            Be = R + Math.atan2(ee.y - ne.y, ee.x - ne.x);
          return be.push(pe), {
            point: pe,
            angle: S ? Be : 0,
            path: be
          }
        }
        const Nn = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function vn(h, e) {
          for (let i = 0; i < h; i++) {
            const l = e.length;
            e.resize(l + 4), e.float32.set(Nn, 3 * l)
          }
        }

        function Bn(h, e, i) {
          const l = e[0],
            u = e[1];
          return h[0] = i[0] * l + i[4] * u + i[12], h[1] = i[1] * l + i[5] * u + i[13], h[3] = i[3] * l + i[7] * u + i[15], h
        }
        const lr = 100;
        class bn {
          constructor(e, i = new tr(e.width + 200, e.height + 200, 25), l = new tr(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = i, this.ignoredGrid = l, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + lr, this.screenBottomBoundary = e.height + lr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, i, l, u, d, g, b, S, P, A, R, D) {
            const O = this.projectAndGetPerspectiveRatio(e.anchorPointX + S[0], e.anchorPointY + S[1], d, A, D),
              $ = l * O.perspectiveRatio;
            let te;
            if (g || b) te = this._projectCollisionBox(e, $, u, d, g, b, S, O, A, R, D);
            else {
              const Ce = O.x + (R ? R.x * $ : 0),
                pe = O.y + (R ? R.y * $ : 0);
              te = {
                allPointsOccluded: !1,
                box: [Ce + e.x1 * $, pe + e.y1 * $, Ce + e.x2 * $, pe + e.y2 * $]
              }
            }
            const [ee, ne, le, fe] = te.box, de = g ? te.allPointsOccluded : O.isOccluded;
            let be = de;
            return be || (be = O.perspectiveRatio < this.perspectiveRatioCutoff), be || (be = !this.isInsideGrid(ee, ne, le, fe)), be || i !== "always" && this.grid.hitTest(ee, ne, le, fe, i, P) ? {
              box: [ee, ne, le, fe],
              placeable: !1,
              offscreen: !1,
              occluded: de
            } : {
              box: [ee, ne, le, fe],
              placeable: !0,
              offscreen: this.isOffscreen(ee, ne, le, fe),
              occluded: de
            }
          }
          placeCollisionCircles(e, i, l, u, d, g, b, S, P, A, R, D, O, $) {
            const te = [],
              ee = new o.P(i.anchorX, i.anchorY),
              ne = this.getPerspectiveRatio(ee.x, ee.y, g, $),
              le = (P ? d * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, g) / ne : d * ne) / o.aB,
              fe = {
                getElevation: $,
                pitchedLabelPlaneMatrix: b,
                lineVertexArray: l,
                pitchWithMap: P,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: ee,
                unwrappedTileID: g,
                width: this.transform.width,
                height: this.transform.height,
                translation: O
              },
              de = kn(le, u, i.lineOffsetX * le, i.lineOffsetY * le, !1, i, !1, fe);
            let be = !1,
              Ce = !1,
              pe = !0;
            if (de) {
              const Be = .5 * R * ne + D,
                et = new o.P(-100, -100),
                Ze = new o.P(this.screenRightBoundary, this.screenBottomBoundary),
                Ge = new $r,
                Ke = de.first,
                Rt = de.last;
              let Ft = [];
              for (let Jr = Ke.path.length - 1; Jr >= 1; Jr--) Ft.push(Ke.path[Jr]);
              for (let Jr = 1; Jr < Rt.path.length; Jr++) Ft.push(Rt.path[Jr]);
              const St = 2.5 * Be;
              if (P) {
                const Jr = this.projectPathToScreenSpace(Ft, fe);
                Ft = Jr.some((wn => wn.signedDistanceFromCamera <= 0)) ? [] : Jr.map((wn => wn.point))
              }
              let pr = [];
              if (Ft.length > 0) {
                const Jr = Ft[0].clone(),
                  wn = Ft[0].clone();
                for (let Ln = 1; Ln < Ft.length; Ln++) Jr.x = Math.min(Jr.x, Ft[Ln].x), Jr.y = Math.min(Jr.y, Ft[Ln].y), wn.x = Math.max(wn.x, Ft[Ln].x), wn.y = Math.max(wn.y, Ft[Ln].y);
                pr = Jr.x >= et.x && wn.x <= Ze.x && Jr.y >= et.y && wn.y <= Ze.y ? [Ft] : wn.x < et.x || Jr.x > Ze.x || wn.y < et.y || Jr.y > Ze.y ? [] : o.ay([Ft], et.x, et.y, Ze.x, Ze.y)
              }
              for (const Jr of pr) {
                Ge.reset(Jr, .25 * Be);
                let wn = 0;
                wn = Ge.length <= .5 * Be ? 1 : Math.ceil(Ge.paddedLength / St) + 1;
                for (let Ln = 0; Ln < wn; Ln++) {
                  const Mn = Ln / Math.max(wn - 1, 1),
                    Gn = Ge.lerp(Mn),
                    Kn = Gn.x + lr,
                    Kr = Gn.y + lr;
                  te.push(Kn, Kr, Be, 0);
                  const Dn = Kn - Be,
                    si = Kr - Be,
                    fi = Kn + Be,
                    bi = Kr + Be;
                  if (pe = pe && this.isOffscreen(Dn, si, fi, bi), Ce = Ce || this.isInsideGrid(Dn, si, fi, bi), e !== "always" && this.grid.hitTestCircle(Kn, Kr, Be, e, A) && (be = !0, !S)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: be
                  }
                }
              }
            }
            return {
              circles: !S && be || !Ce || ne < this.perspectiveRatioCutoff ? [] : te,
              offscreen: pe,
              collisionDetected: be
            }
          }
          projectPathToScreenSpace(e, i) {
            const l = (function(u, d) {
              const g = o.L();
              return o.aq(g, d.pitchedLabelPlaneMatrix), u.map((b => {
                const S = qr(b.x, b.y, g, d.getElevation),
                  P = d.transform.projectTileCoordinates(S.point.x, S.point.y, d.unwrappedTileID, d.getElevation);
                return P.point.x = (.5 * P.point.x + .5) * d.width, P.point.y = (.5 * -P.point.y + .5) * d.height, P
              }))
            })(e, i);
            return (function(u) {
              let d = 0,
                g = 0,
                b = 0,
                S = 0;
              for (let P = 0; P < u.length; P++) u[P].isOccluded ? (b = P + 1, S = 0) : (S++, S > g && (g = S, d = b));
              return u.slice(d, d + g)
            })(l)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const i = [],
              l = new o.a2;
            for (const R of e) {
              const D = new o.P(R.x + lr, R.y + lr);
              l.extend(D), i.push(D)
            }
            const {
              minX: u,
              minY: d,
              maxX: g,
              maxY: b
            } = l, S = this.grid.query(u, d, g, b).concat(this.ignoredGrid.query(u, d, g, b)), P = {}, A = {};
            for (const R of S) {
              const D = R.key;
              if (P[D.bucketInstanceId] === void 0 && (P[D.bucketInstanceId] = {}), P[D.bucketInstanceId][D.featureIndex]) continue;
              const O = [new o.P(R.x1, R.y1), new o.P(R.x2, R.y1), new o.P(R.x2, R.y2), new o.P(R.x1, R.y2)];
              o.az(i, O) && (P[D.bucketInstanceId][D.featureIndex] = !0, A[D.bucketInstanceId] === void 0 && (A[D.bucketInstanceId] = []), A[D.bucketInstanceId].push(D.featureIndex))
            }
            return A
          }
          insertCollisionBox(e, i, l, u, d, g) {
            (l ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: u,
              featureIndex: d,
              collisionGroupID: g,
              overlapMode: i
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, i, l, u, d, g) {
            const b = l ? this.ignoredGrid : this.grid,
              S = {
                bucketInstanceId: u,
                featureIndex: d,
                collisionGroupID: g,
                overlapMode: i
              };
            for (let P = 0; P < e.length; P += 4) b.insertCircle(S, e[P], e[P + 1], e[P + 2])
          }
          projectAndGetPerspectiveRatio(e, i, l, u, d) {
            if (d) {
              let g;
              u ? (g = [e, i, u(e, i), 1], o.aw(g, g, d)) : (g = [e, i, 0, 1], Bn(g, g, d));
              const b = g[3];
              return {
                x: (g[0] / b + 1) / 2 * this.transform.width + lr,
                y: (-g[1] / b + 1) / 2 * this.transform.height + lr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / b * .5,
                isOccluded: !1,
                signedDistanceFromCamera: b
              }
            } {
              const g = this.transform.projectTileCoordinates(e, i, l, u);
              return {
                x: (g.point.x + 1) / 2 * this.transform.width + lr,
                y: (1 - g.point.y) / 2 * this.transform.height + lr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * .5,
                isOccluded: g.isOccluded,
                signedDistanceFromCamera: g.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, i, l, u) {
            const d = this.transform.projectTileCoordinates(e, i, l, u);
            return .5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * .5
          }
          isOffscreen(e, i, l, u) {
            return l < lr || e >= this.screenRightBoundary || u < lr || i > this.screenBottomBoundary
          }
          isInsideGrid(e, i, l, u) {
            return l >= 0 && e < this.gridRightBoundary && u >= 0 && i < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = o.ag([]);
            return o.M(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, i, l, u, d, g, b, S, P, A, R) {
            let D = 1,
              O = 0,
              $ = 0,
              te = 1;
            const ee = e.anchorPointX + b[0],
              ne = e.anchorPointY + b[1];
            if (g && !d) {
              const Ft = this.projectAndGetPerspectiveRatio(ee + 1, ne, u, P, R),
                St = Ft.x - S.x,
                pr = Math.atan((Ft.y - S.y) / St) + (St < 0 ? Math.PI : 0),
                Jr = Math.sin(pr),
                wn = Math.cos(pr);
              D = wn, O = Jr, $ = -Jr, te = wn
            } else if (!g && d) {
              const Ft = ar(this.transform);
              D = Ft.vecEast[0], O = Ft.vecEast[1], $ = Ft.vecSouth[0], te = Ft.vecSouth[1]
            }
            let le = S.x,
              fe = S.y,
              de = i;
            d && (le = ee, fe = ne, de = Math.pow(2, -(this.transform.zoom - l.overscaledZ)), de *= this.transform.getPitchedTextCorrection(ee, ne, u), A || (de *= o.ah(.5 + S.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), A && (le += D * A.x * de + $ * A.y * de, fe += O * A.x * de + te * A.y * de);
            const be = e.x1 * de,
              Ce = e.x2 * de,
              pe = (be + Ce) / 2,
              Be = e.y1 * de,
              et = e.y2 * de,
              Ze = (Be + et) / 2,
              Ge = [{
                offsetX: be,
                offsetY: Be
              }, {
                offsetX: pe,
                offsetY: Be
              }, {
                offsetX: Ce,
                offsetY: Be
              }, {
                offsetX: Ce,
                offsetY: Ze
              }, {
                offsetX: Ce,
                offsetY: et
              }, {
                offsetX: pe,
                offsetY: et
              }, {
                offsetX: be,
                offsetY: et
              }, {
                offsetX: be,
                offsetY: Ze
              }];
            let Ke = [];
            for (const {
                offsetX: Ft,
                offsetY: St
              }
              of Ge) Ke.push(new o.P(le + D * Ft + $ * St, fe + O * Ft + te * St));
            let Rt = !1;
            if (d) {
              const Ft = Ke.map((St => this.projectAndGetPerspectiveRatio(St.x, St.y, u, P, R)));
              Rt = Ft.some((St => !St.isOccluded)), Ke = Ft.map((St => new o.P(St.x, St.y)))
            } else Rt = !0;
            return {
              box: o.aA(Ke),
              allPointsOccluded: !Rt
            }
          }
        }
        class rn {
          constructor(e, i, l, u) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : u && l ? 1 : 0, this.placed = l
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class Qr {
          constructor(e, i, l, u, d) {
            this.text = new rn(e ? e.text : null, i, l, d), this.icon = new rn(e ? e.icon : null, i, u, d)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class _a {
          constructor(e, i, l) {
            this.text = e, this.icon = i, this.skipFade = l
          }
        }
        class hi {
          constructor(e, i, l, u, d) {
            this.bucketInstanceId = e, this.featureIndex = i, this.sourceLayerIndex = l, this.bucketIndex = u, this.tileID = d
          }
        }
        class Ki {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const i = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: i,
                predicate: l => l.collisionGroupID === i
              }
            }
            return this.collisionGroups[e]
          }
        }

        function Zn(h, e, i, l, u) {
          const {
            horizontalAlign: d,
            verticalAlign: g
          } = o.aH(h);
          return new o.P(-(d - .5) * e + l[0] * u, -(g - .5) * i + l[1] * u)
        }
        class ai {
          constructor(e, i, l, u, d) {
            this.transform = e.clone(), this.terrain = i, this.collisionIndex = new bn(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new Ki(u), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const i = this.terrain;
            return i ? (l, u) => i.getElevation(e, l, u) : null
          }
          getBucketParts(e, i, l, u) {
            const d = l.getBucket(i),
              g = l.latestFeatureIndex;
            if (!d || !g || i.id !== d.layerIds[0]) return;
            const b = l.collisionBoxArray,
              S = d.layers[0].layout,
              P = d.layers[0].paint,
              A = Math.pow(2, this.transform.zoom - l.tileID.overscaledZ),
              R = l.tileSize / o.$,
              D = l.tileID.toUnwrapped(),
              O = S.get("text-rotation-alignment") === "map",
              $ = o.aC(l, 1, this.transform.zoom),
              te = o.aD(this.collisionIndex.transform, l, P.get("text-translate"), P.get("text-translate-anchor")),
              ee = o.aD(this.collisionIndex.transform, l, P.get("icon-translate"), P.get("icon-translate-anchor")),
              ne = Ht(O, this.transform, $);
            this.retainedQueryData[d.bucketInstanceId] = new hi(d.bucketInstanceId, g, d.sourceLayerIndex, d.index, l.tileID);
            const le = {
              bucket: d,
              layout: S,
              translationText: te,
              translationIcon: ee,
              unwrappedTileID: D,
              pitchedLabelPlaneMatrix: ne,
              scale: A,
              textPixelRatio: R,
              holdingForFade: l.holdingForFade(),
              collisionBoxArray: b,
              partiallyEvaluatedTextSize: o.an(d.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(d.sourceID)
            };
            if (u)
              for (const fe of d.sortKeyRanges) {
                const {
                  sortKey: de,
                  symbolInstanceStart: be,
                  symbolInstanceEnd: Ce
                } = fe;
                e.push({
                  sortKey: de,
                  symbolInstanceStart: be,
                  symbolInstanceEnd: Ce,
                  parameters: le
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: d.symbolInstances.length,
                parameters: le
              })
          }
          attemptAnchorPlacement(e, i, l, u, d, g, b, S, P, A, R, D, O, $, te, ee, ne, le, fe, de) {
            const be = o.aE[e.textAnchor],
              Ce = [e.textOffset0, e.textOffset1],
              pe = Zn(be, l, u, Ce, d),
              Be = this.collisionIndex.placeCollisionBox(i, D, S, P, A, b, g, ee, R.predicate, fe, pe, de);
            if ((!le || this.collisionIndex.placeCollisionBox(le, D, S, P, A, b, g, ne, R.predicate, fe, pe, de).placeable) && Be.placeable) {
              let et;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[O.crossTileID] && this.prevPlacement.placements[O.crossTileID] && this.prevPlacement.placements[O.crossTileID].text && (et = this.prevPlacement.variableOffsets[O.crossTileID].anchor), O.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[O.crossTileID] = {
                textOffset: Ce,
                width: l,
                height: u,
                anchor: be,
                textBoxScale: d,
                prevAnchor: et
              }, this.markUsedJustification($, be, O, te), $.allowVerticalPlacement && (this.markUsedOrientation($, te, O), this.placedOrientations[O.crossTileID] = te), {
                shift: pe,
                placedGlyphBoxes: Be
              }
            }
          }
          placeLayerBucketPart(e, i, l) {
            const {
              bucket: u,
              layout: d,
              translationText: g,
              translationIcon: b,
              unwrappedTileID: S,
              pitchedLabelPlaneMatrix: P,
              textPixelRatio: A,
              holdingForFade: R,
              collisionBoxArray: D,
              partiallyEvaluatedTextSize: O,
              collisionGroup: $
            } = e.parameters, te = d.get("text-optional"), ee = d.get("icon-optional"), ne = o.aF(d, "text-overlap", "text-allow-overlap"), le = ne === "always", fe = o.aF(d, "icon-overlap", "icon-allow-overlap"), de = fe === "always", be = d.get("text-rotation-alignment") === "map", Ce = d.get("text-pitch-alignment") === "map", pe = d.get("icon-text-fit") !== "none", Be = d.get("symbol-z-order") === "viewport-y", et = le && (de || !u.hasIconData() || ee), Ze = de && (le || !u.hasTextData() || te);
            !u.collisionArrays && D && u.deserializeCollisionBoxes(D);
            const Ge = this.retainedQueryData[u.bucketInstanceId].tileID,
              Ke = this._getTerrainElevationFunc(Ge),
              Rt = this.transform.getFastPathSimpleProjectionMatrix(Ge),
              Ft = (St, pr, Jr) => {
                var wn, Ln;
                if (i[St.crossTileID]) return;
                if (R) return void(this.placements[St.crossTileID] = new _a(!1, !1, !1));
                let Mn = !1,
                  Gn = !1,
                  Kn = !0,
                  Kr = null,
                  Dn = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  si = {
                    placeable: !1
                  },
                  fi = null,
                  bi = null,
                  Gi = null,
                  La = 0,
                  _s = 0,
                  gs = 0;
                pr.textFeatureIndex ? La = pr.textFeatureIndex : St.useRuntimeCollisionCircles && (La = St.featureIndex), pr.verticalTextFeatureIndex && (_s = pr.verticalTextFeatureIndex);
                const ho = pr.textBox;
                if (ho) {
                  const ra = oi => {
                      let mi = o.ao.horizontal;
                      if (u.allowVerticalPlacement && !oi && this.prevPlacement) {
                        const ba = this.prevPlacement.placedOrientations[St.crossTileID];
                        ba && (this.placedOrientations[St.crossTileID] = ba, mi = ba, this.markUsedOrientation(u, mi, St))
                      }
                      return mi
                    },
                    Da = (oi, mi) => {
                      if (u.allowVerticalPlacement && St.numVerticalGlyphVertices > 0 && pr.verticalTextBox) {
                        for (const ba of u.writingModes)
                          if (ba === o.ao.vertical ? (Dn = mi(), si = Dn) : Dn = oi(), Dn && Dn.placeable) break
                      } else Dn = oi()
                    },
                    Hi = St.textAnchorOffsetStartIndex,
                    vs = St.textAnchorOffsetEndIndex;
                  if (vs === Hi) {
                    const oi = (mi, ba) => {
                      const li = this.collisionIndex.placeCollisionBox(mi, ne, A, Ge, S, Ce, be, g, $.predicate, Ke, void 0, Rt);
                      return li && li.placeable && (this.markUsedOrientation(u, ba, St), this.placedOrientations[St.crossTileID] = ba), li
                    };
                    Da((() => oi(ho, o.ao.horizontal)), (() => {
                      const mi = pr.verticalTextBox;
                      return u.allowVerticalPlacement && St.numVerticalGlyphVertices > 0 && mi ? oi(mi, o.ao.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), ra(Dn && Dn.placeable)
                  } else {
                    let oi = o.aE[(Ln = (wn = this.prevPlacement) === null || wn === void 0 ? void 0 : wn.variableOffsets[St.crossTileID]) === null || Ln === void 0 ? void 0 : Ln.anchor];
                    const mi = (li, Ko, fo) => {
                      const es = li.x2 - li.x1,
                        Ra = li.y2 - li.y1,
                        ys = St.textBoxScale,
                        wd = pe && fe === "never" ? Ko : null;
                      let ca = null,
                        Td = ne === "never" ? 1 : 2,
                        mu = "never";
                      oi && Td++;
                      for (let Gl = 0; Gl < Td; Gl++) {
                        for (let Hl = Hi; Hl < vs; Hl++) {
                          const xs = u.textAnchorOffsets.get(Hl);
                          if (oi && xs.textAnchor !== oi) continue;
                          const ts = this.attemptAnchorPlacement(xs, li, es, Ra, ys, be, Ce, A, Ge, S, $, mu, St, u, fo, g, b, wd, Ke);
                          if (ts && (ca = ts.placedGlyphBoxes, ca && ca.placeable)) return Mn = !0, Kr = ts.shift, ca
                        }
                        oi ? oi = null : mu = ne
                      }
                      return l && !ca && (ca = {
                        box: this.collisionIndex.placeCollisionBox(ho, "always", A, Ge, S, Ce, be, g, $.predicate, Ke, void 0, Rt).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), ca
                    };
                    Da((() => mi(ho, pr.iconBox, o.ao.horizontal)), (() => {
                      const li = pr.verticalTextBox;
                      return u.allowVerticalPlacement && (!Dn || !Dn.placeable) && St.numVerticalGlyphVertices > 0 && li ? mi(li, pr.verticalIconBox, o.ao.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), Dn && (Mn = Dn.placeable, Kn = Dn.offscreen);
                    const ba = ra(Dn && Dn.placeable);
                    if (!Mn && this.prevPlacement) {
                      const li = this.prevPlacement.variableOffsets[St.crossTileID];
                      li && (this.variableOffsets[St.crossTileID] = li, this.markUsedJustification(u, li.anchor, St, ba))
                    }
                  }
                }
                if (fi = Dn, Mn = fi && fi.placeable, Kn = fi && fi.offscreen, St.useRuntimeCollisionCircles) {
                  const ra = u.text.placedSymbolArray.get(St.centerJustifiedTextSymbolIndex),
                    Da = o.ap(u.textSizeData, O, ra),
                    Hi = d.get("text-padding");
                  bi = this.collisionIndex.placeCollisionCircles(ne, ra, u.lineVertexArray, u.glyphOffsetArray, Da, S, P, l, Ce, $.predicate, St.collisionCircleDiameter, Hi, g, Ke), bi.circles.length && bi.collisionDetected && !l && o.w("Collisions detected, but collision boxes are not shown"), Mn = le || bi.circles.length > 0 && !bi.collisionDetected, Kn = Kn && bi.offscreen
                }
                if (pr.iconFeatureIndex && (gs = pr.iconFeatureIndex), pr.iconBox) {
                  const ra = Da => this.collisionIndex.placeCollisionBox(Da, fe, A, Ge, S, Ce, be, b, $.predicate, Ke, pe && Kr ? Kr : void 0, Rt);
                  si && si.placeable && pr.verticalIconBox ? (Gi = ra(pr.verticalIconBox), Gn = Gi.placeable) : (Gi = ra(pr.iconBox), Gn = Gi.placeable), Kn = Kn && Gi.offscreen
                }
                const po = te || St.numHorizontalGlyphVertices === 0 && St.numVerticalGlyphVertices === 0,
                  js = ee || St.numIconVertices === 0;
                po || js ? js ? po || (Gn = Gn && Mn) : Mn = Gn && Mn : Gn = Mn = Gn && Mn;
                const Vs = Gn && Gi.placeable;
                if (Mn && fi.placeable && this.collisionIndex.insertCollisionBox(fi.box, ne, d.get("text-ignore-placement"), u.bucketInstanceId, si && si.placeable && _s ? _s : La, $.ID), Vs && this.collisionIndex.insertCollisionBox(Gi.box, fe, d.get("icon-ignore-placement"), u.bucketInstanceId, gs, $.ID), bi && Mn && this.collisionIndex.insertCollisionCircles(bi.circles, ne, d.get("text-ignore-placement"), u.bucketInstanceId, La, $.ID), l && this.storeCollisionData(u.bucketInstanceId, Jr, pr, fi, Gi, bi), St.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (u.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[St.crossTileID] = new _a((Mn || et) && !(fi != null && fi.occluded), (Gn || Ze) && !(Gi != null && Gi.occluded), Kn || u.justReloaded), i[St.crossTileID] = !0
              };
            if (Be) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const St = u.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let pr = St.length - 1; pr >= 0; --pr) {
                const Jr = St[pr];
                Ft(u.symbolInstances.get(Jr), u.collisionArrays[Jr], Jr)
              }
            } else
              for (let St = e.symbolInstanceStart; St < e.symbolInstanceEnd; St++) Ft(u.symbolInstances.get(St), u.collisionArrays[St], St);
            u.justReloaded = !1
          }
          storeCollisionData(e, i, l, u, d, g) {
            if (l.textBox || l.iconBox) {
              let b, S;
              this.collisionBoxArrays.has(e) ? b = this.collisionBoxArrays.get(e) : (b = new Map, this.collisionBoxArrays.set(e, b)), b.has(i) ? S = b.get(i) : (S = {
                text: null,
                icon: null
              }, b.set(i, S)), l.textBox && (S.text = u.box), l.iconBox && (S.icon = d.box)
            }
            if (g) {
              let b = this.collisionCircleArrays[e];
              b === void 0 && (b = this.collisionCircleArrays[e] = []);
              for (let S = 0; S < g.circles.length; S += 4) b.push(g.circles[S + 0] - lr), b.push(g.circles[S + 1] - lr), b.push(g.circles[S + 2]), b.push(g.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, i, l, u) {
            let d;
            d = u === o.ao.vertical ? l.verticalPlacedTextSymbolIndex : {
              left: l.leftJustifiedTextSymbolIndex,
              center: l.centerJustifiedTextSymbolIndex,
              right: l.rightJustifiedTextSymbolIndex
            } [o.aG(i)];
            const g = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex, l.verticalPlacedTextSymbolIndex];
            for (const b of g) b >= 0 && (e.text.placedSymbolArray.get(b).crossTileID = d >= 0 && b !== d ? 0 : l.crossTileID)
          }
          markUsedOrientation(e, i, l) {
            const u = i === o.ao.horizontal || i === o.ao.horizontalOnly ? i : 0,
              d = i === o.ao.vertical ? i : 0,
              g = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex];
            for (const b of g) e.text.placedSymbolArray.get(b).placedOrientation = u;
            l.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(l.verticalPlacedTextSymbolIndex).placedOrientation = d)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const i = this.prevPlacement;
            let l = !1;
            this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
            const u = i ? i.symbolFadeChange(e) : 1,
              d = i ? i.opacities : {},
              g = i ? i.variableOffsets : {},
              b = i ? i.placedOrientations : {};
            for (const S in this.placements) {
              const P = this.placements[S],
                A = d[S];
              A ? (this.opacities[S] = new Qr(A, u, P.text, P.icon), l = l || P.text !== A.text.placed || P.icon !== A.icon.placed) : (this.opacities[S] = new Qr(null, u, P.text, P.icon, P.skipFade), l = l || P.text || P.icon)
            }
            for (const S in d) {
              const P = d[S];
              if (!this.opacities[S]) {
                const A = new Qr(P, u, !1, !1);
                A.isHidden() || (this.opacities[S] = A, l = l || P.text.placed || P.icon.placed)
              }
            }
            for (const S in g) this.variableOffsets[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.variableOffsets[S] = g[S]);
            for (const S in b) this.placedOrientations[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.placedOrientations[S] = b[S]);
            if (i && i.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            l ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, i) {
            const l = {};
            for (const u of i) {
              const d = u.getBucket(e);
              d && u.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, u.tileID, l, u.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, i, l, u) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const d = e.layers[0],
              g = d.layout,
              b = new Qr(null, 0, !1, !1, !0),
              S = g.get("text-allow-overlap"),
              P = g.get("icon-allow-overlap"),
              A = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              R = g.get("text-rotation-alignment") === "map",
              D = g.get("text-pitch-alignment") === "map",
              O = g.get("icon-text-fit") !== "none",
              $ = new Qr(null, 0, S && (P || !e.hasIconData() || g.get("icon-optional")), P && (S || !e.hasTextData() || g.get("text-optional")), !0);
            !e.collisionArrays && u && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(u);
            const te = (ne, le, fe) => {
                for (let de = 0; de < le / 4; de++) ne.opacityVertexArray.emplaceBack(fe);
                ne.hasVisibleVertices = ne.hasVisibleVertices || fe !== Fn
              },
              ee = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ne = 0; ne < e.symbolInstances.length; ne++) {
              const le = e.symbolInstances.get(ne),
                {
                  numHorizontalGlyphVertices: fe,
                  numVerticalGlyphVertices: de,
                  crossTileID: be
                } = le;
              let Ce = this.opacities[be];
              l[be] ? Ce = b : Ce || (Ce = $, this.opacities[be] = Ce), l[be] = !0;
              const pe = le.numIconVertices > 0,
                Be = this.placedOrientations[le.crossTileID],
                et = Be === o.ao.vertical,
                Ze = Be === o.ao.horizontal || Be === o.ao.horizontalOnly;
              if (fe > 0 || de > 0) {
                const Ke = gn(Ce.text);
                te(e.text, fe, et ? Fn : Ke), te(e.text, de, Ze ? Fn : Ke);
                const Rt = Ce.text.isHidden();
                [le.rightJustifiedTextSymbolIndex, le.centerJustifiedTextSymbolIndex, le.leftJustifiedTextSymbolIndex].forEach((pr => {
                  pr >= 0 && (e.text.placedSymbolArray.get(pr).hidden = Rt || et ? 1 : 0)
                })), le.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(le.verticalPlacedTextSymbolIndex).hidden = Rt || Ze ? 1 : 0);
                const Ft = this.variableOffsets[le.crossTileID];
                Ft && this.markUsedJustification(e, Ft.anchor, le, Be);
                const St = this.placedOrientations[le.crossTileID];
                St && (this.markUsedJustification(e, "left", le, St), this.markUsedOrientation(e, St, le))
              }
              if (pe) {
                const Ke = gn(Ce.icon),
                  Rt = !(O && le.verticalPlacedIconSymbolIndex && et);
                le.placedIconSymbolIndex >= 0 && (te(e.icon, le.numIconVertices, Rt ? Ke : Fn), e.icon.placedSymbolArray.get(le.placedIconSymbolIndex).hidden = Ce.icon.isHidden()), le.verticalPlacedIconSymbolIndex >= 0 && (te(e.icon, le.numVerticalIconVertices, Rt ? Fn : Ke), e.icon.placedSymbolArray.get(le.verticalPlacedIconSymbolIndex).hidden = Ce.icon.isHidden())
              }
              const Ge = ee && ee.has(ne) ? ee.get(ne) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Ke = e.collisionArrays[ne];
                if (Ke) {
                  let Rt = new o.P(0, 0);
                  if (Ke.textBox || Ke.verticalTextBox) {
                    let Ft = !0;
                    if (A) {
                      const St = this.variableOffsets[be];
                      St ? (Rt = Zn(St.anchor, St.width, St.height, St.textOffset, St.textBoxScale), R && Rt._rotate(D ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Ft = !1
                    }
                    if (Ke.textBox || Ke.verticalTextBox) {
                      let St;
                      Ke.textBox && (St = et), Ke.verticalTextBox && (St = Ze), qi(e.textCollisionBox.collisionVertexArray, Ce.text.placed, !Ft || St, Ge.text, Rt.x, Rt.y)
                    }
                  }
                  if (Ke.iconBox || Ke.verticalIconBox) {
                    const Ft = !!(!Ze && Ke.verticalIconBox);
                    let St;
                    Ke.iconBox && (St = Ft), Ke.verticalIconBox && (St = !Ft), qi(e.iconCollisionBox.collisionVertexArray, Ce.icon.placed, St, Ge.icon, O ? Rt.x : 0, O ? Rt.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, i) {
            const l = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
            return this.zoomAtLastRecencyCheck = i, this.commitTime + this.fadeDuration * l > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function qi(h, e, i, l, u, d) {
          l && l.length !== 0 || (l = [0, 0, 0, 0]);
          const g = l[0] - lr,
            b = l[1] - lr,
            S = l[2] - lr,
            P = l[3] - lr;
          h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, b), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, S, b), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, S, P), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, P)
        }
        const Zi = Math.pow(2, 25),
          Bi = Math.pow(2, 24),
          Fi = Math.pow(2, 17),
          Ji = Math.pow(2, 16),
          wt = Math.pow(2, 9),
          Gt = Math.pow(2, 8),
          Dr = Math.pow(2, 1);

        function gn(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0,
            i = Math.floor(127 * h.opacity);
          return i * Zi + e * Bi + i * Fi + e * Ji + i * wt + e * Gt + i * Dr + e
        }
        const Fn = 0;
        class Wn {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, i, l, u, d) {
            const g = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (i.getBucketParts(g, u, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, d()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort(((b, S) => b.sortKey - S.sortKey))); this._currentPartIndex < g.length;)
              if (i.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, l), this._currentPartIndex++, d()) return !0;
            return !1
          }
        }
        class Pn {
          constructor(e, i, l, u, d, g, b, S) {
            this.placement = new ai(e, i, g, b, S), this._currentPlacementIndex = l.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = d, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, i, l) {
            const u = se.now(),
              d = () => !this._forceFullPlacement && se.now() - u > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const g = i[e[this._currentPlacementIndex]],
                b = this.placement.collisionIndex.transform.zoom;
              if (g.type === "symbol" && (!g.minzoom || g.minzoom <= b) && (!g.maxzoom || g.maxzoom > b)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Wn(g)), this._inProgressLayer.continuePlacement(l[g.source], this.placement, this._showCollisionBoxes, g, d)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Er = 512 / o.$ / 2;
        class Qi {
          constructor(e, i, l) {
            this.tileID = e, this.bucketInstanceId = l, this._symbolsByKey = {};
            const u = new Map;
            for (let d = 0; d < i.length; d++) {
              const g = i.get(d),
                b = g.key,
                S = u.get(b);
              S ? S.push(g) : u.set(b, [g])
            }
            for (const [d, g] of u) {
              const b = {
                positions: g.map((S => ({
                  x: Math.floor(S.anchorX * Er),
                  y: Math.floor(S.anchorY * Er)
                }))),
                crossTileIDs: g.map((S => S.crossTileID))
              };
              if (b.positions.length > 128) {
                const S = new o.aI(b.positions.length, 16, Uint16Array);
                for (const {
                    x: P,
                    y: A
                  }
                  of b.positions) S.add(P, A);
                S.finish(), delete b.positions, b.index = S
              }
              this._symbolsByKey[d] = b
            }
          }
          getScaledCoordinates(e, i) {
            const {
              x: l,
              y: u,
              z: d
            } = this.tileID.canonical, {
              x: g,
              y: b,
              z: S
            } = i.canonical, P = Er / Math.pow(2, S - d), A = (b * o.$ + e.anchorY) * P, R = u * o.$ * Er;
            return {
              x: Math.floor((g * o.$ + e.anchorX) * P - l * o.$ * Er),
              y: Math.floor(A - R)
            }
          }
          findMatches(e, i, l) {
            const u = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
            for (let d = 0; d < e.length; d++) {
              const g = e.get(d);
              if (g.crossTileID) continue;
              const b = this._symbolsByKey[g.key];
              if (!b) continue;
              const S = this.getScaledCoordinates(g, i);
              if (b.index) {
                const P = b.index.range(S.x - u, S.y - u, S.x + u, S.y + u).sort();
                for (const A of P) {
                  const R = b.crossTileIDs[A];
                  if (!l[R]) {
                    l[R] = !0, g.crossTileID = R;
                    break
                  }
                }
              } else if (b.positions)
                for (let P = 0; P < b.positions.length; P++) {
                  const A = b.positions[P],
                    R = b.crossTileIDs[P];
                  if (Math.abs(A.x - S.x) <= u && Math.abs(A.y - S.y) <= u && !l[R]) {
                    l[R] = !0, g.crossTileID = R;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class nr {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class Ot {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const i = Math.round((e - this.lng) / 360);
            if (i !== 0)
              for (const l in this.indexes) {
                const u = this.indexes[l],
                  d = {};
                for (const g in u) {
                  const b = u[g];
                  b.tileID = b.tileID.unwrapTo(b.tileID.wrap + i), d[b.tileID.key] = b
                }
                this.indexes[l] = d
              }
            this.lng = e
          }
          addBucket(e, i, l) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let d = 0; d < i.symbolInstances.length; d++) i.symbolInstances.get(d).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const u = this.usedCrossTileIDs[e.overscaledZ];
            for (const d in this.indexes) {
              const g = this.indexes[d];
              if (Number(d) > e.overscaledZ)
                for (const b in g) {
                  const S = g[b];
                  S.tileID.isChildOf(e) && S.findMatches(i.symbolInstances, e, u)
                } else {
                  const b = g[e.scaledTo(Number(d)).key];
                  b && b.findMatches(i.symbolInstances, e, u)
                }
            }
            for (let d = 0; d < i.symbolInstances.length; d++) {
              const g = i.symbolInstances.get(d);
              g.crossTileID || (g.crossTileID = l.generate(), u[g.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Qi(e, i.symbolInstances, i.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, i) {
            for (const l of i.getCrossTileIDsLists())
              for (const u of l) delete this.usedCrossTileIDs[e][u]
          }
          removeStaleBuckets(e) {
            let i = !1;
            for (const l in this.indexes) {
              const u = this.indexes[l];
              for (const d in u) e[u[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(l, u[d]), delete u[d], i = !0)
            }
            return i
          }
        }
        class Wr {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new nr, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, i, l) {
            let u = this.layerIndexes[e.id];
            u === void 0 && (u = this.layerIndexes[e.id] = new Ot);
            let d = !1;
            const g = {};
            u.handleWrapJump(l);
            for (const b of i) {
              const S = b.getBucket(e);
              S && e.id === S.layerIds[0] && (S.bucketInstanceId || (S.bucketInstanceId = ++this.maxBucketInstanceId), u.addBucket(b.tileID, S, this.crossTileIDs) && (d = !0), g[S.bucketInstanceId] = !0)
            }
            return u.removeStaleBuckets(g) && (d = !0), d
          }
          pruneUnusedLayers(e) {
            const i = {};
            e.forEach((l => {
              i[l] = !0
            }));
            for (const l in this.layerIndexes) i[l] || delete this.layerIndexes[l]
          }
        }
        var on = "void main() {fragColor=vec4(1.0);}";
        const dn = {
          prelude: cr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: cr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: cr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: cr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: cr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: cr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: cr(on, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: cr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: cr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: cr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: cr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: cr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: cr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: cr(on, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: cr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: cr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: cr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: cr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: cr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: cr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: cr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: cr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: cr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: cr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: cr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: cr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
          raster: cr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: cr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: cr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: cr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: cr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: cr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: cr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: cr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: cr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: cr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function cr(h, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            l = e.match(/in ([\w]+) ([\w]+)/g),
            u = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            g = d ? d.concat(u) : u,
            b = {};
          return {
            fragmentSource: h = h.replace(i, ((S, P, A, R, D) => (b[D] = !0, P === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
in ${A} ${R} ${D};
#else
uniform ${A} ${R} u_${D};
#endif
` : `
#ifdef HAS_UNIFORM_u_${D}
    ${A} ${R} ${D} = u_${D};
#endif
`))),
            vertexSource: e = e.replace(i, ((S, P, A, R, D) => {
              const O = R === "float" ? "vec2" : "vec4",
                $ = D.match(/color/) ? "color" : O;
              return b[D] ? P === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
in ${A} ${O} a_${D};
out ${A} ${R} ${D};
#else
uniform ${A} ${R} u_${D};
#endif
` : $ === "vec4" ? `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = a_${D};
#else
    ${A} ${R} ${D} = u_${D};
#endif
` : `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = unpack_mix_${$}(a_${D}, u_${D}_t);
#else
    ${A} ${R} ${D} = u_${D};
#endif
` : P === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
in ${A} ${O} a_${D};
#else
uniform ${A} ${R} u_${D};
#endif
` : $ === "vec4" ? `
#ifndef HAS_UNIFORM_u_${D}
    ${A} ${R} ${D} = a_${D};
#else
    ${A} ${R} ${D} = u_${D};
#endif
` : `
#ifndef HAS_UNIFORM_u_${D}
    ${A} ${R} ${D} = unpack_mix_${$}(a_${D}, u_${D}_t);
#else
    ${A} ${R} ${D} = u_${D};
#endif
`
            })),
            staticAttributes: l,
            staticUniforms: g
          }
        }
        class Tn {
          constructor(e, i, l) {
            this.vertexBuffer = e, this.indexBuffer = i, this.segments = l
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var Un = o.aJ([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const En = "#define PROJECTION_MERCATOR",
          fn = "mercator";
        class sr {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return fn
          }
          get shaderDefine() {
            return En
          }
          get shaderPreludeCode() {
            return dn.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return dn.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return o.aK.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, i, l, u, d) {
            if (this._cachedMesh) return this._cachedMesh;
            const g = new o.aL;
            g.emplaceBack(0, 0), g.emplaceBack(o.$, 0), g.emplaceBack(0, o.$), g.emplaceBack(o.$, o.$);
            const b = e.createVertexBuffer(g, Un.members),
              S = o.aM.simpleSegment(0, 0, 4, 2),
              P = new o.aN;
            P.emplaceBack(1, 0, 2), P.emplaceBack(1, 2, 3);
            const A = e.createIndexBuffer(P);
            return this._cachedMesh = new Tn(b, A, S), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class nn {
          constructor(e = 0, i = 0, l = 0, u = 0) {
            if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(l) || l < 0 || isNaN(u) || u < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = i, this.left = l, this.right = u
          }
          interpolate(e, i, l) {
            return i.top != null && e.top != null && (this.top = o.C.number(e.top, i.top, l)), i.bottom != null && e.bottom != null && (this.bottom = o.C.number(e.bottom, i.bottom, l)), i.left != null && e.left != null && (this.left = o.C.number(e.left, i.left, l)), i.right != null && e.right != null && (this.right = o.C.number(e.right, i.right, l)), this
          }
          getCenter(e, i) {
            const l = o.ah((this.left + e - this.right) / 2, 0, e),
              u = o.ah((this.top + i - this.bottom) / 2, 0, i);
            return new o.P(l, u)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new nn(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function Xn(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const i = e.lng - h.center.lng;
          e.lng += i > 180 ? -360 : i < -180 ? 360 : 0
        }

        function di(h) {
          return Math.max(0, Math.floor(h))
        }
        class yn {
          constructor(e, i, l, u, d, g) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = g === void 0 || !!g, this._minZoom = i || 0, this._maxZoom = l || 22, this._minPitch = u ?? 0, this._maxPitch = d ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new o.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = di(this._zoom), this._scale = o.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new nn, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, i, l) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = di(this._zoom), this._scale = o.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new nn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !l && e.autoCalculateNearFarZ, i && this._constrain(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new o.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const i = o.aO(e, -180, 180) * Math.PI / 180;
            var l, u, d, g, b, S, P, A, R;
            this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = N(), l = this._rotationMatrix, d = -this._bearingInRadians, g = (u = this._rotationMatrix)[0], b = u[1], S = u[2], P = u[3], A = Math.sin(d), R = Math.cos(d), l[0] = g * R + S * A, l[1] = b * R + P * A, l[2] = g * -A + S * R, l[3] = b * -A + P * R)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const i = o.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const i = e / 180 * Math.PI;
            this._rollInRadians !== i && (this._unmodified = !1, this._rollInRadians = i, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return o.aP(this._fovInRadians)
          }
          setFov(e) {
            e = o.ah(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = o.ae(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const i = this.getConstrained(this._center, e).zoom;
            this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = o.af(i), this._constrain(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, i) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = i, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, i, l) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, i, l), this._constrain(), this._calcMatrices()
          }
          resize(e, i, l = !0) {
            this._width = e, this._height = i, l && this._constrain(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new pt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-o.ai, o.ai])
          }
          getConstrained(e, i) {
            return this._callbacks.getConstrained(e, i)
          }
          getCameraQueryGeometry(e, i) {
            if (i.length === 1) return [i[0], e];
            {
              const {
                minX: l,
                minY: u,
                maxX: d,
                maxY: g
              } = o.a2.fromPoints(i).extend(e);
              return [new o.P(l, u), new o.P(d, u), new o.P(d, g), new o.P(l, g), new o.P(l, u)]
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: i,
                zoom: l
              } = this.getConstrained(this.center, this.zoom);
            this.setCenter(i), this.setZoom(l), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = o.ag(new Float64Array(16));
              o.N(e, e, [this._width / 2, -this._height / 2, 1]), o.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = o.ag(new Float64Array(16)), o.N(e, e, [1, -1, 1]), o.M(e, e, [-1, -1, 0]), o.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            const d = l !== void 0 ? l : this.bearing,
              g = u = u !== void 0 ? u : this.pitch,
              b = o.a1.fromLngLat(e, i),
              S = -Math.cos(o.ae(g)),
              P = Math.sin(o.ae(g)),
              A = P * Math.sin(o.ae(d)),
              R = -P * Math.cos(o.ae(d));
            let D = this.elevation;
            const O = i - D;
            let $;
            S * O >= 0 || Math.abs(S) < .1 ? ($ = 1e4, D = i + $ * S) : $ = -O / S;
            let te, ee, ne = o.aQ(1, b.y),
              le = 0;
            do {
              if (le += 1, le > 10) break;
              ee = $ / ne, te = new o.a1(b.x + A * ee, b.y + R * ee), ne = 1 / te.meterInMercatorCoordinateUnits()
            } while (Math.abs($ - ee * ne) > 1e-12);
            return {
              center: te.toLngLat(),
              elevation: D,
              zoom: o.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / ee / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const i = o.aj(1, this.center.lat) * this.worldSize,
              l = this.cameraToCenterDistance / i,
              u = o.a1.fromLngLat(this.center, this.elevation),
              d = Me(this.center, this.elevation, this.pitch, this.bearing, l);
            this._elevation = e;
            const g = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), o.aQ(d.z, u.y), this.bearing, this.pitch);
            this._elevation = g.elevation, this._center = g.center, this.setZoom(g.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new o.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = o.aj(1, this.center.lat) * this.worldSize;
            return Me(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / i, e.canonical.y / i, 1 / i / o.$, 1 / i / o.$]
          }
        }
        class mn {
          constructor(e, i) {
            this.min = e, this.max = i, this.center = o.aR([], o.aS([], this.min, this.max), .5)
          }
          quadrant(e) {
            const i = [e % 2 == 0, e < 2],
              l = o.aT(this.min),
              u = o.aT(this.max);
            for (let d = 0; d < i.length; d++) l[d] = i[d] ? this.min[d] : this.center[d], u[d] = i[d] ? this.center[d] : this.max[d];
            return u[2] = this.max[2], new mn(l, u)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let i = !0;
            for (let l = 0; l < e.planes.length; l++) {
              const u = this.intersectsPlane(e.planes[l]);
              if (u === 0) return 0;
              u === 1 && (i = !1)
            }
            return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let i = e[3],
              l = e[3];
            for (let u = 0; u < 3; u++) e[u] > 0 ? (i += e[u] * this.min[u], l += e[u] * this.max[u]) : (l += e[u] * this.min[u], i += e[u] * this.max[u]);
            return i >= 0 ? 2 : l < 0 ? 0 : 1
          }
        }
        class On {
          distanceToTile2d(e, i, l, u) {
            const d = u.distanceX([e, i]),
              g = u.distanceY([e, i]);
            return Math.hypot(d, g)
          }
          getWrap(e, i, l) {
            return l
          }
          getTileBoundingVolume(e, i, l, u) {
            var d, g;
            let b = 0,
              S = 0;
            if (u != null && u.terrain) {
              const A = new o.Z(e.z, i, e.z, e.x, e.y),
                R = u.terrain.getMinMaxElevation(A);
              b = (d = R.minElevation) !== null && d !== void 0 ? d : Math.min(0, l), S = (g = R.maxElevation) !== null && g !== void 0 ? g : Math.max(0, l)
            }
            const P = 1 << e.z;
            return new mn([i + e.x / P, e.y / P, b], [i + (e.x + 1) / P, (e.y + 1) / P, S])
          }
          allowVariableZoom(e, i) {
            const l = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              u = o.ah(78.5 - l / 2, 0, 60);
            return !!i.terrain || e.pitch > u
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class jn {
          constructor(e, i, l) {
            this.points = e, this.planes = i, this.aabb = l
          }
          static fromInvProjectionMatrix(e, i = 1, l = 0, u, d) {
            const g = d ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              b = Math.pow(2, l),
              S = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((D => (function(O, $, te, ee) {
                const ne = o.aw([], O, $),
                  le = 1 / ne[3] / te * ee;
                return o.aY(ne, ne, [le, le, 1 / ne[3], le])
              })(D, e, i, b)));
            u && (function(D, O, $, te) {
              const ee = te ? 4 : 0,
                ne = te ? 0 : 4;
              let le = 0;
              const fe = [],
                de = [];
              for (let pe = 0; pe < 4; pe++) {
                const Be = o.aU([], D[pe + ne], D[pe + ee]),
                  et = o.aZ(Be);
                o.aR(Be, Be, 1 / et), fe.push(et), de.push(Be)
              }
              for (let pe = 0; pe < 4; pe++) {
                const Be = o.a_(D[pe + ee], de[pe], $);
                le = Be !== null && Be >= 0 ? Math.max(le, Be) : Math.max(le, fe[pe])
              }
              const be = (function(pe, Be) {
                  const et = o.aU([], pe[Be[0]], pe[Be[1]]),
                    Ze = o.aU([], pe[Be[2]], pe[Be[1]]),
                    Ge = [0, 0, 0, 0];
                  return o.aV(Ge, o.aW([], et, Ze)), Ge[3] = -o.aX(Ge, pe[Be[0]]), Ge
                })(D, O),
                Ce = (function(pe, Be) {
                  const et = o.a$(pe),
                    Ze = o.b0([], pe, 1 / et),
                    Ge = o.aU([], Be, o.aR([], Ze, o.aX(Be, Ze))),
                    Ke = o.a$(Ge);
                  if (Ke > 0) {
                    const Rt = Math.sqrt(1 - Ze[3] * Ze[3]),
                      Ft = o.aR([], Ze, -Ze[3]),
                      St = o.aS([], Ft, o.aR([], Ge, Rt / Ke));
                    return o.b1(Be, St)
                  }
                  return null
                })($, be);
              if (Ce !== null) {
                const pe = Ce / o.aX(de[0], be);
                le = Math.min(le, pe)
              }
              for (let pe = 0; pe < 4; pe++) {
                const Be = Math.min(le, fe[pe]);
                D[pe + ne] = [D[pe + ee][0] + de[pe][0] * Be, D[pe + ee][1] + de[pe][1] * Be, D[pe + ee][2] + de[pe][2] * Be, 1]
              }
            })(S, g[0], u, d);
            const P = g.map((D => {
                const O = o.aU([], S[D[0]], S[D[1]]),
                  $ = o.aU([], S[D[2]], S[D[1]]),
                  te = o.aV([], o.aW([], O, $)),
                  ee = -o.aX(te, S[D[1]]);
                return te.concat(ee)
              })),
              A = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              R = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const D of S)
              for (let O = 0; O < 3; O++) A[O] = Math.min(A[O], D[O]), R[O] = Math.max(R[O], D[O]);
            return new jn(S, P, new mn(A, R))
          }
        }
        class Sn {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, i) {}
          constructor(e, i, l, u, d) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this._helper = new yn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (g, b) => this.getConstrained(g, b)
            }, e, i, l, u, d), this._coveringTilesDetailsProvider = new On
          }
          clone() {
            const e = new Sn;
            return e.apply(this), e
          }
          apply(e, i, l) {
            this._helper.apply(e, i, l)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const i = [new o.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const l = this.screenPointToMercatorCoordinate(new o.P(0, 0)),
                u = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, 0)),
                d = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, this._helper._height)),
                g = this.screenPointToMercatorCoordinate(new o.P(0, this._helper._height)),
                b = Math.floor(Math.min(l.x, u.x, d.x, g.x)),
                S = Math.floor(Math.max(l.x, u.x, d.x, g.x)),
                P = 1;
              for (let A = b - P; A <= S + P; A++) A !== 0 && i.push(new o.b2(A, e))
            }
            return i
          }
          getCameraFrustum() {
            return jn.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const i = this.screenPointToLocation(this.centerPoint, e),
              l = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(l)
          }
          setLocationAtPoint(e, i) {
            const l = o.aj(this.elevation, this.center.lat),
              u = this.screenPointToMercatorCoordinateAtZ(i, l),
              d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, l),
              g = o.a1.fromLngLat(e),
              b = new o.a1(g.x - (u.x - d.x), g.y - (u.y - d.y));
            this.setCenter(b == null ? void 0 : b.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, i) {
            return i ? this.coordinatePoint(o.a1.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a1.fromLngLat(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l != null) return l
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, i) {
            const l = i || 0,
              u = [e.x, e.y, 0, 1],
              d = [e.x, e.y, 1, 1];
            o.aw(u, u, this._pixelMatrixInverse), o.aw(d, d, this._pixelMatrixInverse);
            const g = u[3],
              b = d[3],
              S = u[1] / g,
              P = d[1] / b,
              A = u[2] / g,
              R = d[2] / b,
              D = A === R ? 0 : (l - A) / (R - A);
            return new o.a1(o.C.number(u[0] / g, d[0] / b, D) / this.worldSize, o.C.number(S, P, D) / this.worldSize, l)
          }
          coordinatePoint(e, i = 0, l = this._pixelMatrix) {
            const u = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
            return o.aw(u, u, l), new o.P(u[0] / u[3], u[1] / u[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - he(this));
            return new pt().extend(this.screenPointToLocation(new o.P(0, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new o.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, i) {
            return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - he(this)
          }
          calculatePosMatrix(e, i = !1, l) {
            var u;
            const d = (u = e.key) !== null && u !== void 0 ? u : o.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              g = i ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (g.has(d)) {
              const P = g.get(d);
              return l ? P.f32 : P.f64
            }
            const b = Te(e, this.worldSize);
            o.O(b, i ? this._alignedProjMatrix : this._viewProjMatrix, b);
            const S = {
              f64: b,
              f32: new Float32Array(b)
            };
            return g.set(d, S), l ? S.f32 : S.f64
          }
          calculateFogMatrix(e) {
            const i = e.key,
              l = this._fogMatrixCacheF32;
            if (l.has(i)) return l.get(i);
            const u = Te(e, this.worldSize);
            return o.O(u, this._fogMatrix, u), l.set(i, new Float32Array(u)), l.get(i)
          }
          getConstrained(e, i) {
            i = o.ah(+i, this.minZoom, this.maxZoom);
            const l = {
              center: new o.S(e.lng, e.lat),
              zoom: i
            };
            let u = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && u === null) {
              const fe = 179.9999999999;
              u = [-fe, fe]
            }
            const d = this.tileSize * o.af(l.zoom);
            let g = 0,
              b = d,
              S = 0,
              P = d,
              A = 0,
              R = 0;
            const {
              x: D,
              y: O
            } = this.size;
            if (this._helper._latRange) {
              const fe = this._helper._latRange;
              g = o.U(fe[1]) * d, b = o.U(fe[0]) * d, b - g < O && (A = O / (b - g))
            }
            u && (S = o.aO(o.V(u[0]) * d, 0, d), P = o.aO(o.V(u[1]) * d, 0, d), P < S && (P += d), P - S < D && (R = D / (P - S)));
            const {
              x: $,
              y: te
            } = Y(d, e);
            let ee, ne;
            const le = Math.max(R || 0, A || 0);
            if (le) {
              const fe = new o.P(R ? (P + S) / 2 : $, A ? (b + g) / 2 : te);
              return l.center = ie(d, fe).wrap(), l.zoom += o.ak(le), l
            }
            if (this._helper._latRange) {
              const fe = O / 2;
              te - fe < g && (ne = g + fe), te + fe > b && (ne = b - fe)
            }
            if (u) {
              const fe = (S + P) / 2;
              let de = $;
              this._helper._renderWorldCopies && (de = o.aO($, fe - d / 2, fe + d / 2));
              const be = D / 2;
              de - be < S && (ee = S + be), de + be > P && (ee = P - be)
            }
            if (ee !== void 0 || ne !== void 0) {
              const fe = new o.P(ee ?? $, ne ?? te);
              l.center = ie(d, fe).wrap()
            }
            return l
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          _calculateNearFarZIfNeeded(e, i, l) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const u = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              d = e - u * this._helper._pixelPerMeter / Math.cos(i),
              g = u < 0 ? d : e,
              b = Math.PI / 2 + this.pitchInRadians,
              S = o.ae(this.fov) * (Math.abs(Math.cos(o.ae(this.roll))) * this.height + Math.abs(Math.sin(o.ae(this.roll))) * this.width) / this.height * (.5 + l.y / this.height),
              P = Math.sin(S) * g / Math.sin(o.ah(Math.PI - b - S, .01, Math.PI - .01)),
              A = he(this),
              R = Math.atan(A / this._helper.cameraToCenterDistance),
              D = o.ae(.75),
              O = R > D ? 2 * R * (.5 + l.y / (2 * A)) : D,
              $ = Math.sin(O) * g / Math.sin(o.ah(Math.PI - b - O, .01, Math.PI - .01)),
              te = Math.min(P, $);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * te + g), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              i = Y(this.worldSize, this.center),
              l = i.x,
              u = i.y;
            this._helper._pixelPerMeter = o.aj(1, this.center.lat) * this.worldSize;
            const d = o.ae(Math.min(this.pitch, U)),
              g = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
            let b;
            this._calculateNearFarZIfNeeded(g, d, e), b = new Float64Array(16), o.b4(b, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), o.aq(this._invProjMatrix, b), b[8] = 2 * -e.x / this._helper._width, b[9] = 2 * e.y / this._helper._height, this._projectionMatrix = o.b5(b), o.N(b, b, [1, -1, 1]), o.M(b, b, [0, 0, -this._helper.cameraToCenterDistance]), o.b6(b, b, -this.rollInRadians), o.b7(b, b, this.pitchInRadians), o.b6(b, b, -this.bearingInRadians), o.M(b, b, [-l, -u, 0]), this._mercatorMatrix = o.N([], b, [this.worldSize, this.worldSize, this.worldSize]), o.N(b, b, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, b), o.M(b, b, [0, 0, -this.elevation]), this._viewProjMatrix = b, this._invViewProjMatrix = o.aq([], b);
            const S = [0, 0, -1, 1];
            o.aw(S, S, this._invViewProjMatrix), this._cameraPosition = [S[0] / S[3], S[1] / S[3], S[2] / S[3]], this._fogMatrix = new Float64Array(16), o.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, g, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), o.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), o.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), o.M(this._fogMatrix, this._fogMatrix, [-l, -u, 0]), o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, b);
            const P = this._helper._width % 2 / 2,
              A = this._helper._height % 2 / 2,
              R = Math.cos(this.bearingInRadians),
              D = Math.sin(-this.bearingInRadians),
              O = l - Math.round(l) + R * P + D * A,
              $ = u - Math.round(u) + R * A + D * P,
              te = new Float64Array(b);
            if (o.M(te, te, [O > .5 ? O - 1 : O, $ > .5 ? $ - 1 : $, 0]), this._alignedProjMatrix = te, b = o.aq(new Float64Array(16), this._pixelMatrix), !b) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = b, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new o.P(0, 0)),
              i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return o.aw(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = o.aj(1, this.center.lat) * this.worldSize;
            return Me(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, i) {
            const l = o.a1.fromLngLat(e),
              u = [l.x * this.worldSize, l.y * this.worldSize, i, 1];
            return o.aw(u, u, this._viewProjMatrix), u[2] / u[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              aligned: l,
              applyTerrainMatrix: u
            } = e, d = this._helper.getMercatorTileCoordinates(i), g = i ? this.calculatePosMatrix(i, l, !0) : null;
            let b;
            return b = i && i.terrainRttPosMatrix32f && u ? i.terrainRttPosMatrix32f : g || o.b8(), {
              mainMatrix: b,
              tileMercatorCoords: d,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: b
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, i, l) {
            return 1
          }
          transformLightDirection(e) {
            return o.aT(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, i, l, u) {
            const d = this.calculatePosMatrix(l);
            let g;
            u ? (g = [e, i, u(e, i), 1], o.aw(g, g, d)) : (g = [e, i, 0, 1], Bn(g, g, d));
            const b = g[3];
            return {
              point: new o.P(g[0] / b, g[1] / b),
              signedDistanceFromCamera: b,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const i of e) this.calculatePosMatrix(i)
          }
          getMatrixForModel(e, i) {
            const l = o.a1.fromLngLat(e, i),
              u = l.meterInMercatorCoordinateUnits(),
              d = o.b9();
            return o.M(d, d, [l.x, l.y, l.z]), o.b6(d, d, Math.PI), o.b7(d, d, Math.PI / 2), o.N(d, d, [-u, u, u]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = new o.Z(0, 0, 0, 0, 0),
              l = this.getProjectionData({
                overscaledTileID: i,
                applyGlobeMatrix: e
              }),
              u = Te(i, this.worldSize);
            o.O(u, this._viewProjMatrix, u), l.tileMercatorCoords = [0, 0, 1, 1];
            const d = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter],
              g = o.ba();
            return o.N(g, u, d), l.fallbackMatrix = g, l.mainMatrix = g, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function oa() {
          o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function Vn(h) {
          if (h.useSlerp)
            if (h.k < 1) {
              const e = o.bb(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing),
                i = o.bb(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing),
                l = new Float64Array(4);
              o.bc(l, e, i, h.k);
              const u = o.bd(l);
              h.tr.setRoll(u.roll), h.tr.setPitch(u.pitch), h.tr.setBearing(u.bearing)
            } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(o.C.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(o.C.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(o.C.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
        }

        function ki(h, e, i, l, u) {
          const d = u.padding,
            g = Y(u.worldSize, i.getNorthWest()),
            b = Y(u.worldSize, i.getNorthEast()),
            S = Y(u.worldSize, i.getSouthEast()),
            P = Y(u.worldSize, i.getSouthWest()),
            A = o.ae(-l),
            R = g.rotate(A),
            D = b.rotate(A),
            O = S.rotate(A),
            $ = P.rotate(A),
            te = new o.P(Math.max(R.x, D.x, $.x, O.x), Math.max(R.y, D.y, $.y, O.y)),
            ee = new o.P(Math.min(R.x, D.x, $.x, O.x), Math.min(R.y, D.y, $.y, O.y)),
            ne = te.sub(ee),
            le = (u.width - (d.left + d.right + e.left + e.right)) / ne.x,
            fe = (u.height - (d.top + d.bottom + e.top + e.bottom)) / ne.y;
          if (fe < 0 || le < 0) return void oa();
          const de = Math.min(o.ak(u.scale * Math.min(le, fe)), h.maxZoom),
            be = o.P.convert(h.offset),
            Ce = new o.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(o.ae(l)),
            pe = be.add(Ce).mult(u.scale / o.af(de));
          return {
            center: ie(u.worldSize, g.add(S).div(2).sub(pe)),
            zoom: de,
            bearing: l
          }
        }
        class pi {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, i) {
            return {
              easingOffset: e,
              easingCenter: i.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta), e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, i, l) {
            e.around.distSqr(i.centerPoint) < .01 || i.setLocationAtPoint(l, e.around)
          }
          cameraForBoxAndBearing(e, i, l, u, d) {
            return ki(e, i, l, u, d)
          }
          handleJumpToCenterZoom(e, i) {
            e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), i.center !== void 0 && e.setCenter(o.S.convert(i.center))
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.padding,
              d = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              g = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              b = i.zoom !== void 0,
              S = !e.isPaddingEqual(i.padding);
            let P = !1;
            const A = b ? +i.zoom : e.zoom;
            let R = e.centerPoint.add(i.offsetAsPoint);
            const D = e.screenPointToLocation(R),
              {
                center: O,
                zoom: $
              } = e.getConstrained(o.S.convert(i.center || D), A ?? l);
            Xn(e, O);
            const te = Y(e.worldSize, D),
              ee = Y(e.worldSize, O).sub(te),
              ne = o.af($ - l);
            return P = $ !== l, {
              easeFunc: le => {
                if (P && e.setZoom(o.C.number(l, $, le)), o.be(d, g) || Vn({
                    startEulerAngles: d,
                    endEulerAngles: g,
                    tr: e,
                    k: le,
                    useSlerp: d.roll != g.roll
                  }), S && (e.interpolatePadding(u, i.padding, le), R = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const fe = o.af(e.zoom - l),
                    de = $ > l ? Math.min(2, ne) : Math.max(.5, ne),
                    be = Math.pow(de, 1 - le),
                    Ce = ie(e.worldSize, te.add(ee.mult(le * be)).mult(fe));
                  e.setLocationAtPoint(e.renderWorldCopies ? Ce.wrap() : Ce, R)
                }
              },
              isZooming: P,
              elevationCenter: O
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.zoom,
              d = e.getConstrained(o.S.convert(i.center || i.locationAtOffset), l ? +i.zoom : u),
              g = d.center,
              b = d.zoom;
            Xn(e, g);
            const S = Y(e.worldSize, i.locationAtOffset),
              P = Y(e.worldSize, g).sub(S),
              A = P.mag(),
              R = o.af(b - u);
            let D;
            if (i.minZoom !== void 0) {
              const O = Math.min(+i.minZoom, u, b),
                $ = e.getConstrained(g, O).zoom;
              D = o.af($ - u)
            }
            return {
              easeFunc: (O, $, te, ee) => {
                e.setZoom(O === 1 ? b : u + o.ak($));
                const ne = O === 1 ? g : ie(e.worldSize, S.add(P.mult(te)).mult($));
                e.setLocationAtPoint(e.renderWorldCopies ? ne.wrap() : ne, ee)
              },
              scaleOfZoom: R,
              targetCenter: g,
              scaleOfMinZoom: D,
              pixelPathLength: A
            }
          }
        }
        class In {
          constructor(e, i, l) {
            this.blendFunction = e, this.blendColor = i, this.mask = l
          }
        }
        In.Replace = [1, 0], In.disabled = new In(In.Replace, o.bf.transparent, [!1, !1, !1, !1]), In.unblended = new In(In.Replace, o.bf.transparent, [!0, !0, !0, !0]), In.alphaBlended = new In([1, 771], o.bf.transparent, [!0, !0, !0, !0]);
        const Ca = 2305;
        class Rr {
          constructor(e, i, l) {
            this.enable = e, this.mode = i, this.frontFace = l
          }
        }
        Rr.disabled = new Rr(!1, 1029, Ca), Rr.backCCW = new Rr(!0, 1029, Ca), Rr.frontCCW = new Rr(!0, 1028, Ca);
        class Hr {
          constructor(e, i, l) {
            this.func = e, this.mask = i, this.range = l
          }
        }
        Hr.ReadOnly = !1, Hr.ReadWrite = !0, Hr.disabled = new Hr(519, Hr.ReadOnly, [0, 1]);
        const la = 7680;
        class cn {
          constructor(e, i, l, u, d, g) {
            this.test = e, this.ref = i, this.mask = l, this.fail = u, this.depthFail = d, this.pass = g
          }
        }
        cn.disabled = new cn({
          func: 519,
          mask: 0
        }, 0, 0, la, la, la);
        const Oi = new WeakMap;

        function Ui(h) {
          var e;
          if (Oi.has(h)) return Oi.get(h);
          {
            const i = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Oi.set(h, i), i
          }
        }
        class ga {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const i = e.context,
              l = i.gl;
            this._texFormat = l.RGBA, this._texType = l.UNSIGNED_BYTE;
            const u = new o.aL;
            u.emplaceBack(-1, -1), u.emplaceBack(2, -1), u.emplaceBack(-1, 2);
            const d = new o.aN;
            d.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Tn(i.createVertexBuffer(u, Un.members), i.createIndexBuffer(d), o.aM.simpleSegment(0, 0, u.length, d.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(l.TEXTURE1);
            const g = l.createTexture();
            l.bindTexture(l.TEXTURE_2D, g), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST), l.texImage2D(l.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(g), Ui(l) && (this._pbo = l.createBuffer(), l.bindBuffer(l.PIXEL_PACK_BUFFER, this._pbo), l.bufferData(l.PIXEL_PACK_BUFFER, 4, l.STREAM_READ), l.bindBuffer(l.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, i) {
            const l = this._updateCount;
            return this._readbackQueue ? l >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : l >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              i = e.gl;
            e.activeTexture.set(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, i) {
            const l = this._cachedRenderContext.context,
              u = l.gl;
            if (this._bindFramebuffer(), l.viewport.set([0, 0, this._texWidth, this._texHeight]), l.clear({
                color: o.bf.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(l, u.TRIANGLES, Hr.disabled, cn.disabled, In.unblended, Rr.disabled, ((d, g) => ({
                u_input: d,
                u_output_expected: g
              }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Ui(u)) {
              u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.readBuffer(u.COLOR_ATTACHMENT0), u.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
              const d = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
              u.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: d
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Ui(e)) {
              const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i === e.WAIT_FAILED) return o.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (i === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = ga._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let i = 0;
            return i += e[0] / 256, i += e[1] / 65536, i += e[2] / 16777216, e[3] < 127 && (i = -i), i / 128
          }
        }
        const Ka = o.$ / 128;

        function Ps(h, e) {
          const i = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
            l = i + (h.generateBorders ? 2 : 0),
            u = i + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0),
            d = l + 1,
            g = u + 1,
            b = h.generateBorders ? -1 : 0,
            S = h.generateBorders || h.extendToNorthPole ? -1 : 0,
            P = i + (h.generateBorders ? 1 : 0),
            A = i + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
            R = d * g,
            D = l * u * 6,
            O = d * g > 65536;
          if (O && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const $ = O || e === "32bit",
            te = new Int16Array(2 * R);
          let ee = 0;
          for (let fe = S; fe <= A; fe++)
            for (let de = b; de <= P; de++) {
              let be = de / i * o.$;
              de === -1 && (be = -Ka), de === i + 1 && (be = o.$ + Ka);
              let Ce = fe / i * o.$;
              fe === -1 && (Ce = h.extendToNorthPole ? o.bh : -Ka), fe === i + 1 && (Ce = h.extendToSouthPole ? o.bi : o.$ + Ka), te[ee++] = be, te[ee++] = Ce
            }
          const ne = $ ? new Uint32Array(D) : new Uint16Array(D);
          let le = 0;
          for (let fe = 0; fe < u; fe++)
            for (let de = 0; de < l; de++) {
              const be = de + 1 + fe * d,
                Ce = de + (fe + 1) * d,
                pe = de + 1 + (fe + 1) * d;
              ne[le++] = de + fe * d, ne[le++] = Ce, ne[le++] = be, ne[le++] = be, ne[le++] = Ce, ne[le++] = pe
            }
          return {
            vertices: te.buffer.slice(0),
            indices: ne.buffer.slice(0),
            uses32bitIndices: $
          }
        }
        const ds = new o.aK({
          fill: new o.bj(128, 2),
          line: new o.bj(512, 0),
          tile: new o.bj(128, 32),
          stencil: new o.bj(128, 1),
          circle: 3
        });
        class Po {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return dn.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return dn.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return ds
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new ga(e));
            const i = o.U(this._errorQueryLatitudeDegrees),
              l = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - .5 * Math.PI,
              u = this._errorMeasurement.updateErrorLoop(i, l),
              d = se.now();
            u !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = u, this._errorMeasurementLastChangeTime = d);
            const g = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = o.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bl(g))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, i, l, u, d) {
            const g = (d === "stencil" ? ds.stencil : ds.tile).getGranularityForZoomLevel(i.z);
            return this._getMesh(e, {
              granularity: g,
              generateBorders: l,
              extendToNorthPole: i.y === 0 && u,
              extendToSouthPole: i.y === (1 << i.z) - 1 && u
            })
          }
          _getMesh(e, i) {
            const l = this._getMeshKey(i);
            if (l in this._tileMeshCache) return this._tileMeshCache[l];
            const u = (function(d, g) {
              const b = Ps(g, "16bit"),
                S = o.aL.deserialize({
                  arrayBuffer: b.vertices,
                  length: b.vertices.byteLength / 2 / 2
                }),
                P = o.aN.deserialize({
                  arrayBuffer: b.indices,
                  length: b.indices.byteLength / 2 / 3
                });
              return new Tn(d.createVertexBuffer(S, Un.members), d.createIndexBuffer(P), o.aM.simpleSegment(0, 0, S.length, P.length))
            })(e, i);
            return this._tileMeshCache[l] = u, u
          }
          recalculate(e) {}
          hasTransition() {
            const e = se.now();
            let i = !1;
            return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery, i
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const fl = new o.r({
          type: new o.D(o.v.projection.type)
        });
        class ml extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(fl), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0)), this._mercatorProjection = new sr, this._verticalPerspectiveProjection = new Po
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof o.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, i, l, u, d) {
            return this.currentProjection.getMeshFromTileID(e, i, l, u, d)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function _l(h) {
          const e = Ys(h.worldSize, h.center.lat);
          return 2 * Math.PI * e
        }

        function Pa(h, e, i, l, u) {
          const d = 1 / (1 << u),
            g = e / o.$ * d + l * d,
            b = o.bo((h / o.$ * d + i * d) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            S = 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI,
            P = Math.cos(S),
            A = new Float64Array(3);
          return A[0] = Math.sin(b) * P, A[1] = Math.sin(S), A[2] = Math.cos(b) * P, A
        }

        function xi(h) {
          return (function(e, i) {
            const l = Math.cos(i),
              u = new Float64Array(3);
            return u[0] = Math.sin(e) * l, u[1] = Math.sin(i), u[2] = Math.cos(e) * l, u
          })(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
        }

        function Ys(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function Io(h) {
          const e = Math.asin(h[1]) / Math.PI * 180,
            i = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (i > 1e-6) {
            const l = h[0] / i,
              u = Math.acos(h[2] / i),
              d = (l > 0 ? u : -u) / Math.PI * 180;
            return new o.S(o.aO(d, -180, 180), e)
          }
          return new o.S(0, e)
        }

        function Is(h) {
          return Math.cos(h * Math.PI / 180)
        }

        function Qn(h, e) {
          const i = Is(h),
            l = Is(e);
          return o.ak(l / i)
        }

        function Rh(h, e) {
          const i = h.rotate(e.bearingInRadians),
            l = e.zoom + Qn(e.center.lat, 0),
            u = o.bk(1 / Is(e.center.lat), 1 / Is(Math.min(Math.abs(e.center.lat), 60)), o.bn(l, 7, 3, 0, 1)),
            d = 360 / _l({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new o.S(e.center.lng - i.x * d * u, o.ah(e.center.lat + i.y * d, -o.ai, o.ai))
        }

        function Mo(h) {
          const e = .5 * h,
            i = Math.sin(e),
            l = Math.cos(e);
          return Math.log(i + l) - Math.log(l - i)
        }

        function kc(h, e, i, l) {
          const u = h.lat + i * l;
          if (Math.abs(i) > 1) {
            const d = (Math.sign(h.lat + i) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180,
              g = Math.abs(h.lat + i) * Math.PI / 180,
              b = Mo(d + l * (g - d)),
              S = Mo(d),
              P = Mo(g);
            return new o.S(h.lng + e * ((b - S) / (P - S)), u)
          }
          return new o.S(h.lng + e * l, u)
        }
        class vp {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, i, l, u) {
            const d = `${e.z}_${e.x}_${e.y}_${u!=null&&u.terrain?"t":""}`,
              g = this._cache.get(d);
            if (g) return g;
            const b = this._cachePrevious.get(d);
            if (b) return this._cache.set(d, b), b;
            const S = this._boundingVolumeFactory(e, i, l, u);
            return this._cache.set(d, S), this._hadAnyChanges = !0, S
          }
        }
        class Ks {
          constructor(e, i, l, u) {
            this.min = l, this.max = u, this.points = e, this.planes = i
          }
          static fromAabb(e, i) {
            const l = [];
            for (let u = 0; u < 8; u++) l.push([1 & ~u ? e[0] : i[0], (u >> 1 & 1) == 1 ? i[1] : e[1], (u >> 2 & 1) == 1 ? i[2] : e[2]]);
            return new Ks(l, [
              [-1, 0, 0, i[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, i[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, i[2]],
              [0, 0, 1, -e[2]]
            ], e, i)
          }
          static fromCenterSizeAngles(e, i, l) {
            const u = o.br([], l[0], l[1], l[2]),
              d = o.bs([], [i[0], 0, 0], u),
              g = o.bs([], [0, i[1], 0], u),
              b = o.bs([], [0, 0, i[2]], u),
              S = [...e],
              P = [...e];
            for (let R = 0; R < 8; R++)
              for (let D = 0; D < 3; D++) {
                const O = e[D] + d[D] * (1 & ~R ? -1 : 1) + g[D] * ((R >> 1 & 1) == 1 ? 1 : -1) + b[D] * ((R >> 2 & 1) == 1 ? 1 : -1);
                S[D] = Math.min(S[D], O), P[D] = Math.max(P[D], O)
              }
            const A = [];
            for (let R = 0; R < 8; R++) {
              const D = [...e];
              o.aS(D, D, o.aR([], d, 1 & ~R ? -1 : 1)), o.aS(D, D, o.aR([], g, (R >> 1 & 1) == 1 ? 1 : -1)), o.aS(D, D, o.aR([], b, (R >> 2 & 1) == 1 ? 1 : -1)), A.push(D)
            }
            return new Ks(A, [
              [...d, -o.aX(d, A[0])],
              [...g, -o.aX(g, A[0])],
              [...b, -o.aX(b, A[0])],
              [-d[0], -d[1], -d[2], -o.aX(d, A[7])],
              [-g[0], -g[1], -g[2], -o.aX(g, A[7])],
              [-b[0], -b[1], -b[2], -o.aX(b, A[7])]
            ], S, P)
          }
          intersectsFrustum(e) {
            let i = !0;
            const l = this.points.length,
              u = this.planes.length,
              d = e.planes.length,
              g = e.points.length;
            for (let b = 0; b < d; b++) {
              const S = e.planes[b];
              let P = 0;
              for (let A = 0; A < l; A++) {
                const R = this.points[A];
                S[0] * R[0] + S[1] * R[1] + S[2] * R[2] + S[3] >= 0 && P++
              }
              if (P === 0) return 0;
              P < l && (i = !1)
            }
            if (i) return 2;
            for (let b = 0; b < u; b++) {
              const S = this.planes[b];
              let P = 0;
              for (let A = 0; A < g; A++) {
                const R = e.points[A];
                S[0] * R[0] + S[1] * R[1] + S[2] * R[2] + S[3] >= 0 && P++
              }
              if (P === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const i = this.points.length;
            let l = 0;
            for (let u = 0; u < i; u++) {
              const d = this.points[u];
              e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && l++
            }
            return l === i ? 2 : l === 0 ? 0 : 1
          }
        }

        function Ei(h, e, i) {
          const l = h - e;
          return l < 0 ? -l : Math.max(0, l - i)
        }

        function Ao(h, e, i, l, u) {
          const d = h - i;
          let g;
          return g = d < 0 ? Math.min(-d, 1 + d - u) : d > 1 ? Math.min(Math.max(d - u, 0), 1 - d) : 0, Math.max(g, Ei(e, l, u))
        }
        class Za {
          constructor() {
            this._boundingVolumeCache = new vp(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, i, l, u) {
            const d = 1 << l.z,
              g = 1 / d,
              b = l.x / d,
              S = l.y / d;
            let P = 2;
            return P = Math.min(P, Ao(e, i, b, S, g)), P = Math.min(P, Ao(e, i, b + .5, -S - g, g)), P = Math.min(P, Ao(e, i, b + .5, 2 - S - g, g)), P
          }
          getWrap(e, i, l) {
            const u = 1 << i.z,
              d = 1 / u,
              g = i.x / u,
              b = Ei(e.x, g, d),
              S = Ei(e.x, g - 1, d),
              P = Ei(e.x, g + 1, d),
              A = Math.min(b, S, P);
            return A === P ? 1 : A === S ? -1 : 0
          }
          allowVariableZoom(e, i) {
            return kt(e, i) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, i, l, u) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, i, l, u)
          }
          _computeTileBoundingVolume(e, i, l, u) {
            var d, g;
            let b = 0,
              S = 0;
            if (u != null && u.terrain) {
              const P = new o.Z(e.z, i, e.z, e.x, e.y),
                A = u.terrain.getMinMaxElevation(P);
              b = (d = A.minElevation) !== null && d !== void 0 ? d : Math.min(0, l), S = (g = A.maxElevation) !== null && g !== void 0 ? g : Math.max(0, l)
            }
            if (b /= o.bu, S /= o.bu, b += 1, S += 1, e.z <= 0) return Ks.fromAabb([-S, -S, -S], [S, S, S]);
            if (e.z === 1) return Ks.fromAabb([e.x === 0 ? -S : 0, e.y === 0 ? 0 : -S, -S], [e.x === 0 ? 0 : S, e.y === 0 ? S : 0, S]);
            {
              const P = [Pa(0, 0, e.x, e.y, e.z), Pa(o.$, 0, e.x, e.y, e.z), Pa(o.$, o.$, e.x, e.y, e.z), Pa(0, o.$, e.x, e.y, e.z)],
                A = [];
              for (const Ge of P) A.push(o.aR([], Ge, S));
              if (S !== b)
                for (const Ge of P) A.push(o.aR([], Ge, b));
              e.y === 0 && A.push([0, 1, 0]), e.y === (1 << e.z) - 1 && A.push([0, -1, 0]);
              const R = [1, 1, 1],
                D = [-1, -1, -1];
              for (const Ge of A)
                for (let Ke = 0; Ke < 3; Ke++) R[Ke] = Math.min(R[Ke], Ge[Ke]), D[Ke] = Math.max(D[Ke], Ge[Ke]);
              const O = Pa(o.$ / 2, o.$ / 2, e.x, e.y, e.z),
                $ = o.aW([], [0, 1, 0], O);
              o.aV($, $);
              const te = o.aW([], O, $);
              o.aV(te, te);
              const ee = o.aW([], P[2], P[1]);
              o.aV(ee, ee);
              const ne = o.aW([], P[0], P[3]);
              o.aV(ne, ne), A.push(o.aR([], O, S)), e.y >= (1 << e.z) / 2 && A.push(o.aR([], Pa(o.$ / 2, 0, e.x, e.y, e.z), S)), e.y < (1 << e.z) / 2 && A.push(o.aR([], Pa(o.$ / 2, o.$, e.x, e.y, e.z), S));
              const le = ko(O, A),
                fe = ko(te, A),
                de = [-O[0], -O[1], -O[2], le.max],
                be = [O[0], O[1], O[2], -le.min],
                Ce = [-te[0], -te[1], -te[2], fe.max],
                pe = [te[0], te[1], te[2], -fe.min],
                Be = [...ee, 0],
                et = [...ne, 0],
                Ze = [];
              return e.y === 0 ? Ze.push(o.bt(et, Be, de), o.bt(et, Be, be)) : Ze.push(o.bt(Ce, Be, de), o.bt(Ce, Be, be), o.bt(Ce, et, de), o.bt(Ce, et, be)), e.y === (1 << e.z) - 1 ? Ze.push(o.bt(et, Be, de), o.bt(et, Be, be)) : Ze.push(o.bt(pe, Be, de), o.bt(pe, Be, be), o.bt(pe, et, de), o.bt(pe, et, be)), new Ks(Ze, [de, be, Ce, pe, Be, et], R, D)
            }
          }
        }

        function ko(h, e) {
          let i = 1 / 0,
            l = -1 / 0;
          for (const u of e) {
            const d = o.aX(h, u);
            i = Math.min(i, d), l = Math.max(l, d)
          }
          return {
            min: i,
            max: l
          }
        }
        class Eo {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i) {
            this._helper.resize(e, i)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor() {
            this._cachedClippingPlane = o.bv(), this._projectionMatrix = o.b9(), this._globeViewProjMatrix32f = o.b8(), this._globeViewProjMatrixNoCorrection = o.b9(), this._globeViewProjMatrixNoCorrectionInverted = o.b9(), this._globeProjMatrixInverted = o.b9(), this._cameraPosition = o.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new yn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, i) => this.getConstrained(e, i)
            }), this._coveringTilesDetailsProvider = new Za
          }
          clone() {
            const e = new Eo;
            return e.apply(this), e
          }
          apply(e, i) {
            this._globeLatitudeErrorCorrectionRadians = i || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = o.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              applyGlobeMatrix: l
            } = e, u = this._helper.getMercatorTileCoordinates(i);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: u,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: l ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const i = this.pitchInRadians,
              l = this.cameraToCenterDistance / e,
              u = Math.sin(i) * l,
              d = Math.cos(i) * l + 1,
              g = 1 / Math.sqrt(u * u + d * d) * 1;
            let b = -u,
              S = d;
            const P = Math.sqrt(b * b + S * S);
            b /= P, S /= P;
            const A = [0, b, S];
            o.bw(A, A, [0, 0, 0], -this.bearingInRadians), o.bx(A, A, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), o.by(A, A, [0, 0, 0], this.center.lng * Math.PI / 180);
            const R = 1 / o.aZ(A);
            return o.aR(A, A, R), [...A, -g * R]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(xi(e))
          }
          transformLightDirection(e) {
            const i = this._helper._center.lng * Math.PI / 180,
              l = this._helper._center.lat * Math.PI / 180,
              u = Math.cos(l),
              d = [Math.sin(i) * u, Math.sin(l), Math.cos(i) * u],
              g = [d[2], 0, -d[0]],
              b = [0, 0, 0];
            o.aW(b, g, d), o.aV(g, g), o.aV(b, b);
            const S = [0, 0, 0];
            return o.aV(S, [g[0] * e[0] + b[0] * e[1] + d[0] * e[2], g[1] * e[0] + b[1] * e[1] + d[1] * e[2], g[2] * e[0] + b[2] * e[1] + d[2] * e[2]]), S
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = (function(b, S, P) {
                const A = 1 / (1 << P.z);
                return new o.a1(b / o.$ * A + P.x * A, S / o.$ * A + P.y * A)
              })(e, i, l.canonical),
              d = (g = u.y, [o.bo(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI]);
            var g;
            return this.getCircleRadiusCorrection() / Math.cos(d[1])
          }
          projectTileCoordinates(e, i, l, u) {
            const d = l.canonical,
              g = Pa(e, i, d.x, d.y, d.z),
              b = 1 + (u ? u(e, i) : 0) / o.bu,
              S = [g[0] * b, g[1] * b, g[2] * b, 1];
            o.aw(S, S, this._globeViewProjMatrixNoCorrection);
            const P = this._cachedClippingPlane,
              A = P[0] * g[0] + P[1] * g[1] + P[2] * g[2] + P[3] < 0;
            return {
              point: new o.P(S[0] / S[3], S[1] / S[3]),
              signedDistanceFromCamera: S[3],
              isOccluded: A
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Ys(this.worldSize, this.center.lat),
              i = o.ba(),
              l = o.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), o.b4(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const u = this.centerOffset;
            i[8] = 2 * -u.x / this._helper._width, i[9] = 2 * u.y / this._helper._height, this._projectionMatrix = o.b5(i), this._globeProjMatrixInverted = o.ba(), o.aq(this._globeProjMatrixInverted, i), o.M(i, i, [0, 0, -this.cameraToCenterDistance]), o.b6(i, i, this.rollInRadians), o.b7(i, i, -this.pitchInRadians), o.b6(i, i, this.bearingInRadians), o.M(i, i, [0, 0, -e]);
            const d = o.bp();
            d[0] = e, d[1] = e, d[2] = e, o.b7(l, i, this.center.lat * Math.PI / 180), o.bz(l, l, -this.center.lng * Math.PI / 180), o.N(l, l, d), this._globeViewProjMatrixNoCorrection = l, o.b7(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), o.bz(i, i, -this.center.lng * Math.PI / 180), o.N(i, i, d), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = o.ba(), o.aq(this._globeViewProjMatrixNoCorrectionInverted, l);
            const g = o.bp();
            this._cameraPosition = o.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, o.bw(this._cameraPosition, this._cameraPosition, g, -this.rollInRadians), o.bx(this._cameraPosition, this._cameraPosition, g, this.pitchInRadians), o.bw(this._cameraPosition, this._cameraPosition, g, -this.bearingInRadians), o.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), o.bx(this._cameraPosition, this._cameraPosition, g, -this.center.lat * Math.PI / 180), o.by(this._cameraPosition, this._cameraPosition, g, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const b = o.b5(this._globeViewProjMatrixNoCorrectionInverted);
            o.N(b, b, [1, 1, -1]), this._cachedFrustum = jn.fromInvProjectionMatrix(b, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            o.w("calculateFogMatrix is not supported on globe projection.");
            const i = o.ba();
            return o.ag(i), i
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new o.b2(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && o.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const l = xi(e);
            o.aR(l, l, 1 + i / o.bu);
            const u = o.bv();
            return o.aw(u, [l[0], l[1], l[2], 1], this._globeViewProjMatrixNoCorrection), u[2] / u[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              i = .5 * this.height,
              l = [new o.P(0, 0), new o.P(e, 0), new o.P(this.width, 0), new o.P(this.width, i), new o.P(this.width, this.height), new o.P(e, this.height), new o.P(0, this.height), new o.P(0, i)],
              u = [];
            for (const R of l) u.push(this.unprojectScreenPoint(R));
            let d = 0,
              g = 0,
              b = 0,
              S = 0;
            const P = this.center;
            for (const R of u) {
              const D = o.bA(P.lng, R.lng),
                O = o.bA(P.lat, R.lat);
              D < g && (g = D), D > d && (d = D), O < S && (S = O), O > b && (b = O)
            }
            const A = [P.lng + g, P.lat + S, P.lng + d, P.lat + b];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (A[3] = 90, A[0] = -180, A[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (A[1] = -90, A[0] = -180, A[2] = 180), new pt(A)
          }
          getConstrained(e, i) {
            const l = o.ah(e.lat, -o.ai, o.ai),
              u = o.ah(+i, this.minZoom + Qn(0, l), this.maxZoom);
            return {
              center: new o.S(e.lng, l),
              zoom: u
            }
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            const l = xi(this.unprojectScreenPoint(i)),
              u = xi(e),
              d = o.bp();
            o.bB(d);
            const g = o.bp();
            o.by(g, l, d, -this.center.lng * Math.PI / 180), o.bx(g, g, d, this.center.lat * Math.PI / 180);
            const b = u[0] * u[0] + u[2] * u[2],
              S = g[0] * g[0];
            if (b < S) return;
            const P = Math.sqrt(b - S),
              A = -P,
              R = o.bC(u[0], u[2], g[0], P),
              D = o.bC(u[0], u[2], g[0], A),
              O = o.bp();
            o.by(O, u, d, -R);
            const $ = o.bC(O[1], O[2], g[1], g[2]),
              te = o.bp();
            o.by(te, u, d, -D);
            const ee = o.bC(te[1], te[2], g[1], g[2]),
              ne = .5 * Math.PI,
              le = $ >= -ne && $ <= ne,
              fe = ee >= -ne && ee <= ne;
            let de, be;
            if (le && fe) {
              const et = this.center.lng * Math.PI / 180,
                Ze = this.center.lat * Math.PI / 180;
              o.bD(R, et) + o.bD($, Ze) < o.bD(D, et) + o.bD(ee, Ze) ? (de = R, be = $) : (de = D, be = ee)
            } else if (le) de = R, be = $;
            else {
              if (!fe) return;
              de = D, be = ee
            }
            const Ce = de / Math.PI * 180,
              pe = be / Math.PI * 180,
              Be = this.center.lat;
            this.setCenter(new o.S(Ce, o.ah(pe, -90, 90))), this.setZoom(this.zoom + Qn(Be, this.center.lat))
          }
          locationToScreenPoint(e, i) {
            const l = xi(e);
            if (i) {
              const u = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
              o.aR(l, l, 1 + u / o.bu)
            }
            return this._projectSurfacePointToScreen(l)
          }
          _projectSurfacePointToScreen(e) {
            const i = o.bv();
            return o.aw(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new o.P((.5 * i[0] + .5) * this.width, (.5 * -i[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l) return l
            }
            return o.a1.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          isPointOnMapSurface(e, i) {
            const l = this._cameraPosition,
              u = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(l, u)
          }
          getRayDirectionFromPixel(e) {
            const i = o.bv();
            i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, o.aw(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3];
            const l = o.bp();
            l[0] = i[0] - this._cameraPosition[0], l[1] = i[1] - this._cameraPosition[1], l[2] = i[2] - this._cameraPosition[2];
            const u = o.bp();
            return o.aV(u, l), u
          }
          isSurfacePointVisible(e) {
            const i = this._cachedClippingPlane;
            return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const i = o.bv();
            return o.aw(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1
          }
          rayPlanetIntersection(e, i) {
            const l = o.aX(e, i),
              u = o.bp(),
              d = o.bp();
            o.aR(d, i, l), o.aU(u, e, d);
            const g = 1 - o.aX(u, u);
            if (g < 0) return null;
            const b = o.aX(e, e) - 1,
              S = -l + (l < 0 ? 1 : -1) * Math.sqrt(g),
              P = b / S,
              A = S;
            return {
              tMin: Math.min(P, A),
              tMax: Math.max(P, A)
            }
          }
          unprojectScreenPoint(e) {
            const i = this._cameraPosition,
              l = this.getRayDirectionFromPixel(e),
              u = this.rayPlanetIntersection(i, l);
            if (u) {
              const A = o.bp();
              o.aS(A, i, [l[0] * u.tMin, l[1] * u.tMin, l[2] * u.tMin]);
              const R = o.bp();
              return o.aV(R, A), Io(R)
            }
            const d = this._cachedClippingPlane,
              g = d[0] * l[0] + d[1] * l[1] + d[2] * l[2],
              b = -o.b1(d, i) / g,
              S = o.bp();
            if (b > 0) o.aS(S, i, [l[0] * b, l[1] * b, l[2] * b]);
            else {
              const A = o.bp();
              o.aS(A, i, [2 * l[0], 2 * l[1], 2 * l[2]]);
              const R = o.b1(this._cachedClippingPlane, A);
              o.aU(S, A, [this._cachedClippingPlane[0] * R, this._cachedClippingPlane[1] * R, this._cachedClippingPlane[2] * R])
            }
            const P = (function(A) {
              const R = o.bp();
              return R[0] = A[0] * -A[3], R[1] = A[1] * -A[3], R[2] = A[2] * -A[3], {
                center: R,
                radius: Math.sqrt(1 - A[3] * A[3])
              }
            })(d);
            return Io((function(A, R, D) {
              const O = o.bp();
              o.aU(O, D, A);
              const $ = o.bp();
              return o.bq($, A, O, R / o.a$(O)), $
            })(P.center, P.radius, S))
          }
          getMatrixForModel(e, i) {
            const l = o.S.convert(e),
              u = 1 / o.bu,
              d = o.b9();
            return o.bz(d, d, l.lng / 180 * Math.PI), o.b7(d, d, -l.lat / 180 * Math.PI), o.M(d, d, [0, 0, 1 + i / o.bu]), o.b7(d, d, .5 * Math.PI), o.N(d, d, [u, u, u]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this.getProjectionData({
              overscaledTileID: new o.Z(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return i.tileMercatorCoords = [0, 0, 1, 1], i
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class zo {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, i) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = i, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new yn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, i) => this.getConstrained(e, i)
            }), this._globeness = 1, this._mercatorTransform = new Sn, this._verticalPerspectiveTransform = new Eo
          }
          clone() {
            const e = new zo;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const i = this._mercatorTransform.getProjectionData(e),
              l = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? l.mainMatrix : i.mainMatrix,
              clippingPlane: l.clippingPlane,
              tileMercatorCoords: l.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: i.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return o.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return o.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = this._mercatorTransform.getPitchedTextCorrection(e, i, l),
              d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, l);
            return o.bk(u, d, this._globeness)
          }
          projectTileCoordinates(e, i, l, u) {
            return this.currentTransform.projectTileCoordinates(e, i, l, u)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            return this.currentTransform.lngLatToCameraDepth(e, i)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          getConstrained(e, i) {
            return this.currentTransform.getConstrained(e, i)
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, i), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, i), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, i) {
            return this.currentTransform.locationToScreenPoint(e, i)
          }
          screenPointToMercatorCoordinate(e, i) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, i)
          }
          screenPointToLocation(e, i) {
            return this.currentTransform.screenPointToLocation(e, i)
          }
          isPointOnMapSurface(e, i) {
            return this.currentTransform.isPointOnMapSurface(e, i)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, i) {
            return this.currentTransform.getMatrixForModel(e, i)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return i;
            const l = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return l.fallbackMatrix = i.mainMatrix, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Ni {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, i) {
            const l = Rh(e, i);
            return Math.abs(l.lng - i.center.lng) > 180 && (l.lng = i.center.lng + 179.5 * Math.sign(l.lng - i.center.lng)), {
              easingCenter: l,
              easingOffset: new o.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            const l = e.around,
              u = i.screenPointToLocation(l);
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta);
            const d = i.zoom;
            e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
            const g = i.zoom - d;
            if (g === 0) return;
            const b = o.bA(i.center.lng, u.lng),
              S = b / (Math.abs(b / 180) + 1),
              P = o.bA(i.center.lat, u.lat),
              A = i.getRayDirectionFromPixel(l),
              R = i.cameraPosition,
              D = -1 * o.aX(R, A),
              O = o.bp();
            o.aS(O, R, [A[0] * D, A[1] * D, A[2] * D]);
            const $ = o.aZ(O) - 1,
              te = Math.exp(.5 * -Math.max($ - .3, 0)),
              ee = Ys(i.worldSize, i.center.lat) / Math.min(i.width, i.height),
              ne = o.bn(ee, .9, .5, 1, .25),
              le = (1 - o.af(-g)) * Math.min(te, ne),
              fe = i.center.lat,
              de = i.zoom,
              be = new o.S(i.center.lng + S * le, o.ah(i.center.lat + P * le, -o.ai, o.ai));
            i.setLocationAtPoint(u, l);
            const Ce = i.center,
              pe = o.bn(Math.abs(b), 45, 85, 0, 1),
              Be = o.bn(ee, .75, .35, 0, 1),
              et = Math.pow(Math.max(pe, Be), .25),
              Ze = o.bA(Ce.lng, be.lng),
              Ge = o.bA(Ce.lat, be.lat);
            i.setCenter(new o.S(Ce.lng + Ze * et, Ce.lat + Ge * et).wrap()), i.setZoom(de + Qn(fe, i.center.lat))
          }
          handleMapControlsPan(e, i, l) {
            if (!e.panDelta) return;
            const u = i.center.lat,
              d = i.zoom;
            i.setCenter(Rh(e.panDelta, i).wrap()), i.setZoom(d + Qn(u, i.center.lat))
          }
          cameraForBoxAndBearing(e, i, l, u, d) {
            const g = ki(e, i, l, u, d),
              b = i.left / d.width * 2 - 1,
              S = (d.width - i.right) / d.width * 2 - 1,
              P = i.top / d.height * -2 + 1,
              A = (d.height - i.bottom) / d.height * -2 + 1,
              R = o.bA(l.getWest(), l.getEast()) < 0,
              D = R ? l.getEast() : l.getWest(),
              O = R ? l.getWest() : l.getEast(),
              $ = Math.max(l.getNorth(), l.getSouth()),
              te = Math.min(l.getNorth(), l.getSouth()),
              ee = D + .5 * o.bA(D, O),
              ne = $ + .5 * o.bA($, te),
              le = d.clone();
            le.setCenter(g.center), le.setBearing(g.bearing), le.setPitch(0), le.setRoll(0), le.setZoom(g.zoom);
            const fe = le.modelViewProjectionMatrix,
              de = [xi(l.getNorthWest()), xi(l.getNorthEast()), xi(l.getSouthWest()), xi(l.getSouthEast()), xi(new o.S(O, ne)), xi(new o.S(D, ne)), xi(new o.S(ee, $)), xi(new o.S(ee, te))],
              be = xi(g.center);
            let Ce = Number.POSITIVE_INFINITY;
            for (const pe of de) b < 0 && (Ce = Ni.getLesserNonNegativeNonNull(Ce, Ni.solveVectorScale(pe, be, fe, "x", b))), S > 0 && (Ce = Ni.getLesserNonNegativeNonNull(Ce, Ni.solveVectorScale(pe, be, fe, "x", S))), P > 0 && (Ce = Ni.getLesserNonNegativeNonNull(Ce, Ni.solveVectorScale(pe, be, fe, "y", P))), A < 0 && (Ce = Ni.getLesserNonNegativeNonNull(Ce, Ni.solveVectorScale(pe, be, fe, "y", A)));
            if (Number.isFinite(Ce) && Ce !== 0) return g.zoom = le.zoom + o.ak(Ce), g;
            oa()
          }
          handleJumpToCenterZoom(e, i) {
            const l = e.center.lat,
              u = e.getConstrained(i.center ? o.S.convert(i.center) : e.center, e.zoom).center;
            e.setCenter(u.wrap());
            const d = i.zoom !== void 0 ? +i.zoom : e.zoom + Qn(l, u.lat);
            e.zoom !== d && e.setZoom(d)
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.center,
              d = e.padding,
              g = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              b = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              S = i.zoom !== void 0,
              P = !e.isPaddingEqual(i.padding);
            let A = !1;
            const R = i.center ? o.S.convert(i.center) : u,
              D = e.getConstrained(R, l).center;
            Xn(e, D);
            const O = e.clone();
            O.setCenter(D), O.setZoom(S ? +i.zoom : l + Qn(u.lat, R.lat)), O.setBearing(i.bearing);
            const $ = new o.P(o.ah(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), o.ah(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            O.setLocationAtPoint(D, $);
            const te = (i.offset && i.offsetAsPoint.mag()) > 0 ? O.center : D,
              ee = S ? +i.zoom : l + Qn(u.lat, te.lat),
              ne = l + Qn(u.lat, 0),
              le = ee + Qn(te.lat, 0),
              fe = o.bA(u.lng, te.lng),
              de = o.bA(u.lat, te.lat),
              be = o.af(le - ne);
            return A = ee !== l, {
              easeFunc: Ce => {
                if (o.be(g, b) || Vn({
                    startEulerAngles: g,
                    endEulerAngles: b,
                    tr: e,
                    k: Ce,
                    useSlerp: g.roll != b.roll
                  }), P && e.interpolatePadding(d, i.padding, Ce), i.around) o.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const pe = le > ne ? Math.min(2, be) : Math.max(.5, be),
                    Be = Math.pow(pe, 1 - Ce),
                    et = kc(u, fe, de, Ce * Be);
                  e.setCenter(et.wrap())
                }
                if (A) {
                  const pe = o.C.number(ne, le, Ce) + Qn(0, e.center.lat);
                  e.setZoom(pe)
                }
              },
              isZooming: A,
              elevationCenter: te
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.center,
              d = e.zoom,
              g = e.padding,
              b = !e.isPaddingEqual(i.padding),
              S = e.getConstrained(o.S.convert(i.center || i.locationAtOffset), d).center,
              P = l ? +i.zoom : e.zoom + Qn(e.center.lat, S.lat),
              A = e.clone();
            A.setCenter(S), A.setZoom(P), A.setBearing(i.bearing);
            const R = new o.P(o.ah(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), o.ah(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            A.setLocationAtPoint(S, R);
            const D = A.center;
            Xn(e, D);
            const O = (function(de, be, Ce) {
                const pe = xi(be),
                  Be = xi(Ce),
                  et = o.aX(pe, Be),
                  Ze = Math.acos(et),
                  Ge = _l(de);
                return Ze / (2 * Math.PI) * Ge
              })(e, u, D),
              $ = d + Qn(u.lat, 0),
              te = P + Qn(D.lat, 0),
              ee = o.af(te - $);
            let ne;
            if (typeof i.minZoom == "number") {
              const de = +i.minZoom + Qn(D.lat, 0),
                be = Math.min(de, $, te) + Qn(0, D.lat),
                Ce = e.getConstrained(D, be).zoom + Qn(D.lat, 0);
              ne = o.af(Ce - $)
            }
            const le = o.bA(u.lng, D.lng),
              fe = o.bA(u.lat, D.lat);
            return {
              easeFunc: (de, be, Ce, pe) => {
                const Be = kc(u, le, fe, Ce);
                b && e.interpolatePadding(g, i.padding, de);
                const et = de === 1 ? D : Be;
                e.setCenter(et.wrap());
                const Ze = $ + o.ak(be);
                e.setZoom(de === 1 ? P : Ze + Qn(0, et.lat))
              },
              scaleOfZoom: ee,
              targetCenter: D,
              scaleOfMinZoom: ne,
              pixelPathLength: O
            }
          }
          static solveVectorScale(e, i, l, u, d) {
            const g = u === "x" ? [l[0], l[4], l[8], l[12]] : [l[1], l[5], l[9], l[13]],
              b = [l[3], l[7], l[11], l[15]],
              S = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
              P = e[0] * b[0] + e[1] * b[1] + e[2] * b[2],
              A = i[0] * g[0] + i[1] * g[1] + i[2] * g[2],
              R = i[0] * b[0] + i[1] * b[1] + i[2] * b[2];
            return A + d * P === S + d * R || b[3] * (S - A) + g[3] * (R - P) + S * R == A * P ? null : (A + g[3] - d * R - d * b[3]) / (A - S - d * R + d * P)
          }
          static getLesserNonNegativeNonNull(e, i) {
            return i !== null && i >= 0 && i < e ? i : e
          }
        }
        class Bh {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new pi, this._verticalPerspectiveCameraHelper = new Ni
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, i) {
            return this.currentHelper.handlePanInertia(e, i)
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i)
          }
          handleMapControlsPan(e, i, l) {
            this.currentHelper.handleMapControlsPan(e, i, l)
          }
          cameraForBoxAndBearing(e, i, l, u, d) {
            return this.currentHelper.cameraForBoxAndBearing(e, i, l, u, d)
          }
          handleJumpToCenterZoom(e, i) {
            this.currentHelper.handleJumpToCenterZoom(e, i)
          }
          handleEaseTo(e, i) {
            return this.currentHelper.handleEaseTo(e, i)
          }
          handleFlyTo(e, i) {
            return this.currentHelper.handleFlyTo(e, i)
          }
        }
        const gl = (h, e) => o.y(h, e && e.filter((i => i.identifier !== "source.canvas"))),
          yp = o.bE();
        class Ec extends o.E {
          constructor(e, i = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const l in this.sourceCaches) {
                const u = this.sourceCaches[l].getSource().type;
                u !== "vector" && u !== "geojson" || this.sourceCaches[l].reload()
              }
            }, this.map = e, this.dispatcher = new Dt(zt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((l, u) => this.getGlyphs(l, u))), this.dispatcher.registerMessageHandler("GI", ((l, u) => this.getImages(l, u))), this.imageManager = new Je, this.imageManager.setEventedParent(this), this.glyphManager = new $e(e._requestManager, i.localIdeographFontFamily), this.lineAtlas = new ae(256, 512), this.crossTileSymbolIndex = new Wr, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.bF, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", o.bG()), gr().on(xr, this._rtlPluginLoaded), this.on("data", (l => {
              if (l.dataType !== "source" || l.sourceDataType !== "metadata") return;
              const u = this.sourceCaches[l.sourceId];
              if (!u) return;
              const d = u.getSource();
              if (d && d.vectorLayerIds)
                for (const g in this._layers) {
                  const b = this._layers[g];
                  b.source === d.id && this._validateLayer(b)
                }
            }))
          }
          setGlobalStateProperty(e, i) {
            var l, u, d;
            this._checkLoaded();
            const g = i === null ? (d = (u = (l = this.stylesheet.state) === null || l === void 0 ? void 0 : l[e]) === null || u === void 0 ? void 0 : u.default) !== null && d !== void 0 ? d : null : i;
            if (o.bH(g, this._globalState[e])) return this;
            this._globalState[e] = g;
            const b = this._findGlobalStateAffectedSources([e]);
            for (const S in this.sourceCaches) b.has(S) && (this._reloadSource(S), this._changed = !0)
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const i = [];
            for (const u in e) !o.bH(this._globalState[u], e[u].default) && (i.push(u), this._globalState[u] = e[u].default);
            const l = this._findGlobalStateAffectedSources(i);
            for (const u in this.sourceCaches) l.has(u) && (this._reloadSource(u), this._changed = !0)
          }
          _findGlobalStateAffectedSources(e) {
            if (e.length === 0) return new Set;
            const i = new Set;
            for (const l in this._layers) {
              const u = this._layers[l],
                d = u.getLayoutAffectingGlobalStateRefs();
              for (const g of e) d.has(g) && i.add(u.source)
            }
            return i
          }
          loadURL(e, i = {}, l) {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), i.validate = typeof i.validate != "boolean" || i.validate;
            const u = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const d = this._loadStyleRequest;
            o.j(u, this._loadStyleRequest).then((g => {
              this._loadStyleRequest = null, this._load(g.data, i, l)
            })).catch((g => {
              this._loadStyleRequest = null, g && !d.signal.aborted && this.fire(new o.k(g))
            }))
          }
          loadJSON(e, i = {}, l) {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, se.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, i.validate = i.validate !== !1, this._load(e, i, l)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), this._load(yp, {
              validate: !1
            })
          }
          _load(e, i, l) {
            var u, d, g;
            const b = i.transformStyle ? i.transformStyle(l, e) : e;
            if (!i.validate || !gl(this, o.z(b))) {
              this._loaded = !0, this.stylesheet = b;
              for (const S in b.sources) this.addSource(S, b.sources[S], {
                validate: !1
              });
              b.sprite ? this._loadSprite(b.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(b.glyphs), this._createLayers(), this.light = new Q(this.stylesheet.light), this._setProjectionInternal(((u = this.stylesheet.projection) === null || u === void 0 ? void 0 : u.type) || "mercator"), this.sky = new _e(this.stylesheet.sky), this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null), this.setGlobalState((g = this.stylesheet.state) !== null && g !== void 0 ? g : null), this.fire(new o.l("data", {
                dataType: "style"
              })), this.fire(new o.l("style.load"))
            }
          }
          _createLayers() {
            const e = o.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e), this._order = e.map((i => i.id)), this._layers = {}, this._serializedLayers = null;
            for (const i of e) {
              const l = o.bJ(i);
              l.setEventedParent(this, {
                layer: {
                  id: i.id
                }
              }), this._layers[i.id] = l
            }
          }
          _loadSprite(e, i = !1, l = void 0) {
            let u;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(d, g, b, S) {
              return o._(this, void 0, void 0, (function*() {
                const P = nt(d),
                  A = b > 1 ? "@2x" : "",
                  R = {},
                  D = {};
                for (const {
                    id: O,
                    url: $
                  }
                  of P) {
                  const te = g.transformRequest(qe($, A, ".json"), "SpriteJSON");
                  R[O] = o.j(te, S);
                  const ee = g.transformRequest(qe($, A, ".png"), "SpriteImage");
                  D[O] = Oe.getImage(ee, S)
                }
                return yield Promise.all([...Object.values(R), ...Object.values(D)]), (function(O, $) {
                  return o._(this, void 0, void 0, (function*() {
                    const te = {};
                    for (const ee in O) {
                      te[ee] = {};
                      const ne = se.getImageCanvasContext((yield $[ee]).data),
                        le = (yield O[ee]).data;
                      for (const fe in le) {
                        const {
                          width: de,
                          height: be,
                          x: Ce,
                          y: pe,
                          sdf: Be,
                          pixelRatio: et,
                          stretchX: Ze,
                          stretchY: Ge,
                          content: Ke,
                          textFitWidth: Rt,
                          textFitHeight: Ft
                        } = le[fe];
                        te[ee][fe] = {
                          data: null,
                          pixelRatio: et,
                          sdf: Be,
                          stretchX: Ze,
                          stretchY: Ge,
                          content: Ke,
                          textFitWidth: Rt,
                          textFitHeight: Ft,
                          spriteData: {
                            width: de,
                            height: be,
                            x: Ce,
                            y: pe,
                            context: ne
                          }
                        }
                      }
                    }
                    return te
                  }))
                })(R, D)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((d => {
              if (this._spriteRequest = null, d)
                for (const g in d) {
                  this._spritesImagesIds[g] = [];
                  const b = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((S => !(S in d))) : [];
                  for (const S of b) this.imageManager.removeImage(S), this._changedImages[S] = !0;
                  for (const S in d[g]) {
                    const P = g === "default" ? S : `${g}:${S}`;
                    this._spritesImagesIds[g].push(P), P in this.imageManager.images ? this.imageManager.updateImage(P, d[g][S], !1) : this.imageManager.addImage(P, d[g][S]), i && (this._changedImages[P] = !0)
                  }
                }
            })).catch((d => {
              this._spriteRequest = null, u = d, this.fire(new o.k(u))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
                dataType: "style"
              })), l && l(u)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const i = this.sourceCaches[e.source];
            if (!i) return;
            const l = e.sourceLayer;
            if (!l) return;
            const u = i.getSource();
            (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(l) === -1) && this.fire(new o.k(new Error(`Source layer "${l}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches)
              if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, i = !1) {
            const l = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(i ? o.bK(l) : l);
            const u = [];
            for (const d of e)
              if (l[d]) {
                const g = i ? o.bK(l[d]) : l[d];
                u.push(g)
              } return u
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const i = Object.keys(this._layers);
            for (const l of i) {
              const u = this._layers[l];
              u.type !== "custom" && (e[l] = u.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, i, l;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((l = this.projection) === null || l === void 0) && l.hasTransition()) return !0;
            for (const u in this.sourceCaches)
              if (this.sourceCaches[u].hasTransition()) return !0;
            for (const u in this._layers)
              if (this._layers[u].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const i = this._changed;
            if (i) {
              const u = Object.keys(this._updatedLayers),
                d = Object.keys(this._removedLayers);
              (u.length || d.length) && this._updateWorkerLayers(u, d);
              for (const g in this._updatedSources) {
                const b = this._updatedSources[g];
                if (b === "reload") this._reloadSource(g);
                else {
                  if (b !== "clear") throw new Error(`Invalid action ${b}`);
                  this._clearSource(g)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const l = {};
            for (const u in this.sourceCaches) {
              const d = this.sourceCaches[u];
              l[u] = d.used, d.used = !1
            }
            for (const u of this._order) {
              const d = this._layers[u];
              d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0)
            }
            for (const u in l) {
              const d = this.sourceCaches[u];
              !!l[u] != !!d.used && d.fire(new o.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: u
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, i) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: i
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, i = {}) {
            var l;
            this._checkLoaded();
            const u = this.serialize();
            if (e = i.transformStyle ? i.transformStyle(u, e) : e, ((l = i.validate) === null || l === void 0 || l) && gl(this, o.z(e))) return !1;
            (e = o.bK(e)).layers = o.bI(e.layers);
            const d = o.bL(u, e),
              g = this._getOperationsToPerform(d);
            if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
            if (g.operations.length === 0) return !1;
            for (const b of g.operations) b();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const i = [],
              l = [];
            for (const u of e) switch (u.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                i.push((() => this.addLayer.apply(this, u.args)));
                break;
              case "removeLayer":
                i.push((() => this.removeLayer.apply(this, u.args)));
                break;
              case "setPaintProperty":
                i.push((() => this.setPaintProperty.apply(this, u.args)));
                break;
              case "setLayoutProperty":
                i.push((() => this.setLayoutProperty.apply(this, u.args)));
                break;
              case "setFilter":
                i.push((() => this.setFilter.apply(this, u.args)));
                break;
              case "addSource":
                i.push((() => this.addSource.apply(this, u.args)));
                break;
              case "removeSource":
                i.push((() => this.removeSource.apply(this, u.args)));
                break;
              case "setLayerZoomRange":
                i.push((() => this.setLayerZoomRange.apply(this, u.args)));
                break;
              case "setLight":
                i.push((() => this.setLight.apply(this, u.args)));
                break;
              case "setGeoJSONSourceData":
                i.push((() => this.setGeoJSONSourceData.apply(this, u.args)));
                break;
              case "setGlyphs":
                i.push((() => this.setGlyphs.apply(this, u.args)));
                break;
              case "setSprite":
                i.push((() => this.setSprite.apply(this, u.args)));
                break;
              case "setTerrain":
                i.push((() => this.map.setTerrain.apply(this, u.args)));
                break;
              case "setSky":
                i.push((() => this.setSky.apply(this, u.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, u.args);
                break;
              case "setGlobalState":
                i.push((() => this.setGlobalState.apply(this, u.args)));
                break;
              case "setTransition":
                i.push((() => {}));
                break;
              default:
                l.push(u.command)
            }
            return {
              operations: i,
              unimplemented: l
            }
          }
          addImage(e, i) {
            if (this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, i), this._afterImageUpdated(e)
          }
          updateImage(e, i) {
            this.imageManager.updateImage(e, i)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, i, l = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(o.z.source, `sources.${e}`, i, null, l)) return;
            this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
            const u = this.sourceCaches[e] = new Jt(e, i, this.dispatcher);
            u.style = this, u.setEventedParent(this, (() => ({
              isSourceLoaded: u.loaded(),
              source: u.serialize(),
              sourceId: e
            }))), u.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const l in this._layers)
              if (this._layers[l].source === e) return this.fire(new o.k(new Error(`Source "${e}" cannot be removed while layer "${l}" is using it.`)));
            const i = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], i.fire(new o.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, i) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const l = this.sourceCaches[e].getSource();
            if (l.type !== "geojson") throw new Error(`geojsonSource.type is ${l.type}, which is !== 'geojson`);
            l.setData(i), this._changed = !0
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource()
          }
          addLayer(e, i, l = {}) {
            this._checkLoaded();
            const u = e.id;
            if (this.getLayer(u)) return void this.fire(new o.k(new Error(`Layer "${u}" already exists on this map.`)));
            let d;
            if (e.type === "custom") {
              if (gl(this, o.bM(e))) return;
              d = o.bJ(e)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(u, e.source), e = o.bK(e), e = o.e(e, {
                  source: u
                })), this._validate(o.z.layer, `layers.${u}`, e, {
                  arrayIndex: -1
                }, l)) return;
              d = o.bJ(e), this._validateLayer(d), d.setEventedParent(this, {
                layer: {
                  id: u
                }
              })
            }
            const g = i ? this._order.indexOf(i) : this._order.length;
            if (i && g === -1) this.fire(new o.k(new Error(`Cannot add layer "${u}" before non-existing layer "${i}".`)));
            else {
              if (this._order.splice(g, 0, u), this._layerOrderChanged = !0, this._layers[u] = d, this._removedLayers[u] && d.source && d.type !== "custom") {
                const b = this._removedLayers[u];
                delete this._removedLayers[u], b.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload", this.sourceCaches[d.source].pause())
              }
              this._updateLayer(d), d.onAdd && d.onAdd(this.map)
            }
          }
          moveLayer(e, i) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new o.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === i) return;
            const l = this._order.indexOf(e);
            this._order.splice(l, 1);
            const u = i ? this._order.indexOf(i) : this._order.length;
            i && u === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(u, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const i = this._layers[e];
            if (!i) return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            i.setEventedParent(null);
            const l = this._order.indexOf(e);
            this._order.splice(l, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, i, l) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? u.minzoom === i && u.maxzoom === l || (i != null && (u.minzoom = i), l != null && (u.maxzoom = l), this._updateLayer(u)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, i, l = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            if (u) {
              if (!o.bH(u.filter, i)) return i == null ? (u.setFilter(void 0), void this._updateLayer(u)) : void(this._validate(o.z.filter, `layers.${u.id}.filter`, i, null, l) || (u.setFilter(o.bK(i)), this._updateLayer(u)))
            } else this.fire(new o.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return o.bK(this.getLayer(e).filter)
          }
          setLayoutProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? o.bH(d.getLayoutProperty(i), l) || (d.setLayoutProperty(i, l, u), this._updateLayer(d)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, i) {
            const l = this.getLayer(e);
            if (l) return l.getLayoutProperty(i);
            this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? o.bH(d.getPaintProperty(i), l) || (d.setPaintProperty(i, l, u) && this._updateLayer(d), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getPaintProperty(e, i) {
            return this.getLayer(e).getPaintProperty(i)
          }
          setFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = e.sourceLayer,
              d = this.sourceCaches[l];
            if (d === void 0) return void this.fire(new o.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const g = d.getSource().type;
            g === "geojson" && u ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || u ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), d.setFeatureState(u, e.id, i)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = this.sourceCaches[l];
            if (u === void 0) return void this.fire(new o.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const d = u.getSource().type,
              g = d === "vector" ? e.sourceLayer : void 0;
            d !== "vector" || g ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(g, e.id, i) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const i = e.source,
              l = e.sourceLayer,
              u = this.sourceCaches[i];
            if (u !== void 0) return u.getSource().type !== "vector" || l ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), u.getFeatureState(l, e.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new o.k(new Error(`The source '${i}' does not exist in the map's style.`)))
          }
          getTransition() {
            return o.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = o.bN(this.sourceCaches, (d => d.serialize())),
              i = this._serializeByIds(this._order, !0),
              l = this.map.getTerrain() || void 0,
              u = this.stylesheet;
            return o.bO({
              version: u.version,
              name: u.name,
              metadata: u.metadata,
              light: u.light,
              sky: u.sky,
              center: u.center,
              zoom: u.zoom,
              bearing: u.bearing,
              pitch: u.pitch,
              sprite: u.sprite,
              glyphs: u.glyphs,
              transition: u.transition,
              projection: u.projection,
              sources: e,
              layers: i,
              terrain: l
            }, (d => d !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const i = g => this._layers[g].type === "fill-extrusion",
              l = {},
              u = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const b = this._order[g];
              if (i(b)) {
                l[b] = g;
                for (const S of e) {
                  const P = S[b];
                  if (P)
                    for (const A of P) u.push(A)
                }
              }
            }
            u.sort(((g, b) => b.intersectionZ - g.intersectionZ));
            const d = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const b = this._order[g];
              if (i(b))
                for (let S = u.length - 1; S >= 0; S--) {
                  const P = u[S].feature;
                  if (l[P.layer.id] < g) break;
                  d.push(P), u.pop()
                } else
                  for (const S of e) {
                    const P = S[b];
                    if (P)
                      for (const A of P) d.push(A.feature)
                  }
            }
            return d
          }
          queryRenderedFeatures(e, i, l) {
            i && i.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", i.filter, null, i);
            const u = {};
            if (i && i.layers) {
              if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const P of i.layers) {
                const A = this._layers[P];
                if (!A) return this.fire(new o.k(new Error(`The layer '${P}' does not exist in the map's style and cannot be queried for features.`))), [];
                u[A.source] = !0
              }
            }
            const d = [];
            i.availableImages = this._availableImages;
            const g = this._serializedAllLayers(),
              b = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null,
              S = Object.assign(Object.assign({}, i), {
                layers: b
              });
            for (const P in this.sourceCaches) i.layers && !u[P] || d.push(vt(this.sourceCaches[P], this._layers, g, e, S, l, this.map.terrain ? (A, R, D) => this.map.terrain.getElevation(A, R, D) : void 0));
            return this.placement && d.push((function(P, A, R, D, O, $, te) {
              const ee = {},
                ne = $.queryRenderedSymbols(D),
                le = [];
              for (const fe of Object.keys(ne).map(Number)) le.push(te[fe]);
              le.sort(ft);
              for (const fe of le) {
                const de = fe.featureIndex.lookupSymbolFeatures(ne[fe.bucketInstanceId], A, fe.bucketIndex, fe.sourceLayerIndex, O.filter, O.layers, O.availableImages, P);
                for (const be in de) {
                  const Ce = ee[be] = ee[be] || [],
                    pe = de[be];
                  pe.sort(((Be, et) => {
                    const Ze = fe.featureSortOrder;
                    if (Ze) {
                      const Ge = Ze.indexOf(Be.featureIndex);
                      return Ze.indexOf(et.featureIndex) - Ge
                    }
                    return et.featureIndex - Be.featureIndex
                  }));
                  for (const Be of pe) Ce.push(Be)
                }
              }
              return (function(fe, de, be) {
                for (const Ce in fe)
                  for (const pe of fe[Ce]) Tt(pe, be[de[Ce].source]);
                return fe
              })(ee, P, R)
            })(this._layers, g, this.sourceCaches, e, S, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(d)
          }
          querySourceFeatures(e, i) {
            i && i.filter && this._validate(o.z.filter, "querySourceFeatures.filter", i.filter, null, i);
            const l = this.sourceCaches[e];
            return l ? (function(u, d) {
              const g = u.getRenderableIds().map((P => u.getTileByID(P))),
                b = [],
                S = {};
              for (let P = 0; P < g.length; P++) {
                const A = g[P],
                  R = A.tileID.canonical.key;
                S[R] || (S[R] = !0, A.querySourceFeatures(b, d))
              }
              return b
            })(l, i) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, i = {}) {
            this._checkLoaded();
            const l = this.light.getLight();
            let u = !1;
            for (const g in e)
              if (!o.bH(e[g], l[g])) {
                u = !0;
                break
              } if (!u) return;
            const d = {
              now: se.now(),
              transition: o.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, i), this.light.updateTransitions(d)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, i = {}) {
            this._checkLoaded();
            const l = this.getSky();
            let u = !1;
            if (!e && !l) return;
            if (e && !l) u = !0;
            else if (!e && l) u = !0;
            else
              for (const g in e)
                if (!o.bH(e[g], l[g])) {
                  u = !0;
                  break
                } if (!u) return;
            const d = {
              now: se.now(),
              transition: o.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(d)
          }
          _setProjectionInternal(e) {
            const i = (function(l) {
              if (Array.isArray(l)) {
                const u = new ml({
                  type: l
                });
                return {
                  projection: u,
                  transform: new zo,
                  cameraHelper: new Bh(u)
                }
              }
              switch (l) {
                case "mercator":
                  return {
                    projection: new sr, transform: new Sn, cameraHelper: new pi
                  };
                case "globe": {
                  const u = new ml({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: u,
                    transform: new zo,
                    cameraHelper: new Bh(u)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new Po, transform: new Eo, cameraHelper: new Ni
                  };
                default:
                  return o.w(`Unknown projection name: ${l}. Falling back to mercator projection.`), {
                    projection: new sr,
                    transform: new Sn,
                    cameraHelper: new pi
                  }
              }
            })(e);
            this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper);
            for (const l in this.sourceCaches) this.sourceCaches[l].reload()
          }
          _validate(e, i, l, u, d = {}) {
            return (!d || d.validate !== !1) && gl(this, e.call(o.z, o.e({
              key: i,
              style: this.serialize(),
              value: l,
              styleSpec: o.v
            }, u)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), gr().off(xr, this._rtlPluginLoaded);
            for (const i in this._layers) this._layers[i].setEventedParent(null);
            for (const i in this.sourceCaches) {
              const l = this.sourceCaches[i];
              l.setEventedParent(null), l.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles()
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload()
          }
          _updateSources(e) {
            for (const i in this.sourceCaches) this.sourceCaches[i].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e)
          }
          _updatePlacement(e, i, l, u, d = !1) {
            let g = !1,
              b = !1;
            const S = {};
            for (const P of this._order) {
              const A = this._layers[P];
              if (A.type !== "symbol") continue;
              if (!S[A.source]) {
                const D = this.sourceCaches[A.source];
                S[A.source] = D.getRenderableIds(!0).map((O => D.getTileByID(O))).sort(((O, $) => $.tileID.overscaledZ - O.tileID.overscaledZ || (O.tileID.isLessThan($.tileID) ? -1 : 1)))
              }
              const R = this.crossTileSymbolIndex.addLayer(A, S[A.source], e.center.lng);
              g = g || R
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((d = d || this._layerOrderChanged || l === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(se.now(), e.zoom)) && (this.pauseablePlacement = new Pn(e, this.map.terrain, this._order, d, i, l, u, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, S), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(se.now()), b = !0), g && this.pauseablePlacement.placement.setStale()), b || g)
              for (const P of this._order) {
                const A = this._layers[P];
                A.type === "symbol" && this.placement.updateLayerOpacities(A, S[A.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(se.now())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles()
          }
          getImages(e, i) {
            return o._(this, void 0, void 0, (function*() {
              const l = yield this.imageManager.getImages(i.icons);
              this._updateTilesForChangedImages();
              const u = this.sourceCaches[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, i.icons), l
            }))
          }
          getGlyphs(e, i) {
            return o._(this, void 0, void 0, (function*() {
              const l = yield this.glyphManager.getGlyphs(i.stacks), u = this.sourceCaches[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, [""]), l
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, i = {}) {
            this._checkLoaded(), e && this._validate(o.z.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          addSprite(e, i, l = {}, u) {
            this._checkLoaded();
            const d = [{
                id: e,
                url: i
              }],
              g = [...nt(this.stylesheet.sprite), ...d];
            this._validate(o.z.sprite, "sprite", g, null, l) || (this.stylesheet.sprite = g, this._loadSprite(d, !0, u))
          }
          removeSprite(e) {
            this._checkLoaded();
            const i = nt(this.stylesheet.sprite);
            if (i.find((l => l.id === e))) {
              if (this._spritesImagesIds[e])
                for (const l of this._spritesImagesIds[e]) this.imageManager.removeImage(l), this._changedImages[l] = !0;
              i.splice(i.findIndex((l => l.id === e)), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
                dataType: "style"
              }))
            } else this.fire(new o.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return nt(this.stylesheet.sprite)
          }
          setSprite(e, i = {}, l) {
            this._checkLoaded(), e && this._validate(o.z.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, l) : (this._unloadSprite(), l && l(null)))
          }
        }
        var xp = o.aJ([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class bp {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, i, l, u, d, g, b, S, P) {
            this.context = e;
            let A = this.boundPaintVertexBuffers.length !== u.length;
            for (let R = 0; !A && R < u.length; R++) this.boundPaintVertexBuffers[R] !== u[R] && (A = !0);
            !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== l || A || this.boundIndexBuffer !== d || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== b || this.boundDynamicVertexBuffer2 !== S || this.boundDynamicVertexBuffer3 !== P ? this.freshBind(i, l, u, d, g, b, S, P) : (e.bindVertexArray.set(this.vao), b && b.bind(), d && d.dynamicDraw && d.bind(), S && S.bind(), P && P.bind())
          }
          freshBind(e, i, l, u, d, g, b, S) {
            const P = e.numAttributes,
              A = this.context,
              R = A.gl;
            this.vao && this.destroy(), this.vao = A.createVertexArray(), A.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = i, this.boundPaintVertexBuffers = l, this.boundIndexBuffer = u, this.boundVertexOffset = d, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = b, this.boundDynamicVertexBuffer3 = S, i.enableAttributes(R, e);
            for (const D of l) D.enableAttributes(R, e);
            g && g.enableAttributes(R, e), b && b.enableAttributes(R, e), S && S.enableAttributes(R, e), i.bind(), i.setVertexAttribPointers(R, e, d);
            for (const D of l) D.bind(), D.setVertexAttribPointers(R, e, d);
            g && (g.bind(), g.setVertexAttribPointers(R, e, d)), u && u.bind(), b && (b.bind(), b.setVertexAttribPointers(R, e, d)), S && (S.bind(), S.setVertexAttribPointers(R, e, d)), A.currentNumAttributes = P
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const vl = (h, e, i, l, u) => ({
            u_texture: 0,
            u_ele_delta: h,
            u_fog_matrix: e,
            u_fog_color: i ? i.properties.get("fog-color") : o.bf.white,
            u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: u ? 0 : i ? i.calculateFogBlendOpacity(l) : 0,
            u_horizon_color: i ? i.properties.get("horizon-color") : o.bf.white,
            u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: u ? 1 : 0
          }),
          zc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function Ms(h) {
          const e = [];
          for (let i = 0; i < h.length; i++) {
            if (h[i] === null) continue;
            const l = h[i].split(" ");
            e.push(l.pop())
          }
          return e
        }
        class Lc {
          constructor(e, i, l, u, d, g, b, S, P = []) {
            const A = e.gl;
            this.program = A.createProgram();
            const R = Ms(i.staticAttributes),
              D = l ? l.getBinderAttributes() : [],
              O = R.concat(D),
              $ = dn.prelude.staticUniforms ? Ms(dn.prelude.staticUniforms) : [],
              te = b.staticUniforms ? Ms(b.staticUniforms) : [],
              ee = i.staticUniforms ? Ms(i.staticUniforms) : [],
              ne = l ? l.getBinderUniforms() : [],
              le = $.concat(te).concat(ee).concat(ne),
              fe = [];
            for (const Ze of le) fe.indexOf(Ze) < 0 && fe.push(Ze);
            const de = l ? l.defines() : [];
            Ui(A) && de.unshift("#version 300 es"), d && de.push("#define OVERDRAW_INSPECTOR;"), g && de.push("#define TERRAIN3D;"), S && de.push(S), P && de.push(...P);
            let be = de.concat(dn.prelude.fragmentSource, b.fragmentSource, i.fragmentSource).join(`
`),
              Ce = de.concat(dn.prelude.vertexSource, b.vertexSource, i.vertexSource).join(`
`);
            Ui(A) || (be = (function(Ze) {
              return Ze.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(be), Ce = (function(Ze) {
              return Ze.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Ce));
            const pe = A.createShader(A.FRAGMENT_SHADER);
            if (A.isContextLost()) return void(this.failedToCreate = !0);
            if (A.shaderSource(pe, be), A.compileShader(pe), !A.getShaderParameter(pe, A.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${A.getShaderInfoLog(pe)}`);
            A.attachShader(this.program, pe);
            const Be = A.createShader(A.VERTEX_SHADER);
            if (A.isContextLost()) return void(this.failedToCreate = !0);
            if (A.shaderSource(Be, Ce), A.compileShader(Be), !A.getShaderParameter(Be, A.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${A.getShaderInfoLog(Be)}`);
            A.attachShader(this.program, Be), this.attributes = {};
            const et = {};
            this.numAttributes = O.length;
            for (let Ze = 0; Ze < this.numAttributes; Ze++) O[Ze] && (A.bindAttribLocation(this.program, Ze, O[Ze]), this.attributes[O[Ze]] = Ze);
            if (A.linkProgram(this.program), !A.getProgramParameter(this.program, A.LINK_STATUS)) throw new Error(`Program failed to link: ${A.getProgramInfoLog(this.program)}`);
            A.deleteShader(Be), A.deleteShader(pe);
            for (let Ze = 0; Ze < fe.length; Ze++) {
              const Ge = fe[Ze];
              if (Ge && !et[Ge]) {
                const Ke = A.getUniformLocation(this.program, Ge);
                Ke && (et[Ge] = Ke)
              }
            }
            this.fixedUniforms = u(e, et), this.terrainUniforms = ((Ze, Ge) => ({
              u_depth: new o.bP(Ze, Ge.u_depth),
              u_terrain: new o.bP(Ze, Ge.u_terrain),
              u_terrain_dim: new o.bg(Ze, Ge.u_terrain_dim),
              u_terrain_matrix: new o.bR(Ze, Ge.u_terrain_matrix),
              u_terrain_unpack: new o.bS(Ze, Ge.u_terrain_unpack),
              u_terrain_exaggeration: new o.bg(Ze, Ge.u_terrain_exaggeration)
            }))(e, et), this.projectionUniforms = ((Ze, Ge) => ({
              u_projection_matrix: new o.bR(Ze, Ge.u_projection_matrix),
              u_projection_tile_mercator_coords: new o.bS(Ze, Ge.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new o.bS(Ze, Ge.u_projection_clipping_plane),
              u_projection_transition: new o.bg(Ze, Ge.u_projection_transition),
              u_projection_fallback_matrix: new o.bR(Ze, Ge.u_projection_fallback_matrix)
            }))(e, et), this.binderUniforms = l ? l.getUniforms(e, et) : []
          }
          draw(e, i, l, u, d, g, b, S, P, A, R, D, O, $, te, ee, ne, le, fe) {
            const de = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(l), e.setStencilMode(u), e.setColorMode(d), e.setCullFace(g), S) {
              e.activeTexture.set(de.TEXTURE2), de.bindTexture(de.TEXTURE_2D, S.depthTexture), e.activeTexture.set(de.TEXTURE3), de.bindTexture(de.TEXTURE_2D, S.texture);
              for (const Ce in this.terrainUniforms) this.terrainUniforms[Ce].set(S[Ce])
            }
            if (P)
              for (const Ce in P) this.projectionUniforms[zc[Ce]].set(P[Ce]);
            if (b)
              for (const Ce in this.fixedUniforms) this.fixedUniforms[Ce].set(b[Ce]);
            ee && ee.setUniforms(e, this.binderUniforms, $, {
              zoom: te
            });
            let be = 0;
            switch (i) {
              case de.LINES:
                be = 2;
                break;
              case de.TRIANGLES:
                be = 3;
                break;
              case de.LINE_STRIP:
                be = 1
            }
            for (const Ce of O.get()) {
              const pe = Ce.vaos || (Ce.vaos = {});
              (pe[A] || (pe[A] = new bp)).bind(e, this, R, ee ? ee.getPaintVertexBuffers() : [], D, Ce.vertexOffset, ne, le, fe), de.drawElements(i, Ce.primitiveLength * be, de.UNSIGNED_SHORT, Ce.primitiveOffset * be * 2)
            }
          }
        }

        function yl(h, e, i) {
          const l = 1 / o.aC(i, 1, e.transform.tileZoom),
            u = Math.pow(2, i.tileID.overscaledZ),
            d = i.tileSize * Math.pow(2, e.transform.tileZoom) / u,
            g = d * (i.tileID.canonical.x + i.tileID.wrap * u),
            b = d * i.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: i.imageAtlasTexture.size,
            u_scale: [l, h.fromScale, h.toScale],
            u_fade: h.t,
            u_pixel_coord_upper: [g >> 16, b >> 16],
            u_pixel_coord_lower: [65535 & g, 65535 & b]
          }
        }
        const Ia = (h, e, i, l) => {
            const u = h.style.light,
              d = u.properties.get("position"),
              g = [d.x, d.y, d.z],
              b = o.bV();
            u.properties.get("anchor") === "viewport" && o.bW(b, h.transform.bearingInRadians), o.bX(g, g, b);
            const S = h.transform.transformLightDirection(g),
              P = u.properties.get("color");
            return {
              u_lightpos: g,
              u_lightpos_globe: S,
              u_lightintensity: u.properties.get("intensity"),
              u_lightcolor: [P.r, P.g, P.b],
              u_vertical_gradient: +e,
              u_opacity: i,
              u_fill_translate: l
            }
          },
          wp = (h, e, i, l, u, d, g) => o.e(Ia(h, e, i, l), yl(d, h, g), {
            u_height_factor: -Math.pow(2, u.overscaledZ) / g.tileSize / 8
          }),
          xl = (h, e, i, l) => o.e(yl(e, h, i), {
            u_fill_translate: l
          }),
          Lo = (h, e) => ({
            u_world: h,
            u_fill_translate: e
          }),
          Do = (h, e, i, l, u) => o.e(xl(h, e, i, u), {
            u_world: l
          }),
          Tp = (h, e, i, l, u) => {
            const d = h.transform;
            let g, b, S = 0;
            if (i.paint.get("circle-pitch-alignment") === "map") {
              const P = o.aC(e, 1, d.zoom);
              g = !0, b = [P, P], S = P / (o.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * u
            } else g = !1, b = d.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: d.cameraToCenterDistance,
              u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +g,
              u_device_pixel_ratio: h.pixelRatio,
              u_extrude_scale: b,
              u_globe_extrude_scale: S,
              u_translate: l
            }
          },
          bl = h => ({
            u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
          }),
          Sp = h => ({
            u_viewport_size: [h.width, h.height]
          }),
          As = (h, e = 1) => ({
            u_color: h,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Fh = (h, e, i, l) => {
            const u = o.aC(h, 1, e) / (o.$ * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * l;
            return {
              u_extrude_scale: o.aC(h, 1, e),
              u_intensity: i,
              u_globe_extrude_scale: u
            }
          },
          Dc = (h, e, i, l) => {
            const u = o.L();
            o.bY(u, 0, h.width, h.height, 0, 0, 1);
            const d = h.context.gl;
            return {
              u_matrix: u,
              u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
              u_image: i,
              u_color_ramp: l,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          Cp = (h, e, i) => {
            const l = i.paint.get("hillshade-accent-color");
            let u;
            switch (i.paint.get("hillshade-method")) {
              case "basic":
                u = 4;
                break;
              case "combined":
                u = 1;
                break;
              case "igor":
                u = 2;
                break;
              case "multidirectional":
                u = 3;
                break;
              default:
                u = 0
            }
            const d = i.getIlluminationProperties();
            for (let g = 0; g < d.directionRadians.length; g++) i.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[g] += h.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: Rc(0, e.tileID),
              u_exaggeration: i.paint.get("hillshade-exaggeration"),
              u_altitudes: d.altitudeRadians,
              u_azimuths: d.directionRadians,
              u_accent: l,
              u_method: u,
              u_highlights: d.highlightColor,
              u_shadows: d.shadowColor
            }
          },
          Oh = (h, e) => {
            const i = e.stride,
              l = o.L();
            return o.bY(l, 0, o.$, -o.$, 0, 0, 1), o.M(l, l, [0, -o.$, 0]), {
              u_matrix: l,
              u_image: 1,
              u_dimension: [i, i],
              u_zoom: h.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function Rc(h, e) {
          const i = Math.pow(2, e.canonical.z),
            l = e.canonical.y;
          return [new o.a1(0, l / i).toLngLat().lat, new o.a1(0, (l + 1) / i).toLngLat().lat]
        }
        const Nh = (h, e, i = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: i,
            u_opacity: h.paint.get("color-relief-opacity")
          }),
          wl = (h, e, i, l) => {
            const u = h.transform;
            return {
              u_translation: Fc(h, e, i),
              u_ratio: l / o.aC(e, 1, u.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]]
            }
          },
          jh = (h, e, i, l, u) => o.e(wl(h, e, i, l), {
            u_image: 0,
            u_image_height: u
          }),
          Vh = (h, e, i, l, u) => {
            const d = h.transform,
              g = Bc(e, d);
            return {
              u_translation: Fc(h, e, i),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: l / o.aC(e, 1, d.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_image: 0,
              u_scale: [g, u.fromScale, u.toScale],
              u_fade: u.t,
              u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]]
            }
          },
          ks = (h, e, i, l, u, d) => {
            const g = h.lineAtlas,
              b = Bc(e, h.transform),
              S = i.layout.get("line-cap") === "round",
              P = g.getDash(u.from, S),
              A = g.getDash(u.to, S),
              R = P.width * d.fromScale,
              D = A.width * d.toScale;
            return o.e(wl(h, e, i, l), {
              u_patternscale_a: [b / R, -P.height / 2],
              u_patternscale_b: [b / D, -A.height / 2],
              u_sdfgamma: g.width / (256 * Math.min(R, D) * h.pixelRatio) / 2,
              u_image: 0,
              u_tex_y_a: P.y,
              u_tex_y_b: A.y,
              u_mix: d.t
            })
          };

        function Bc(h, e) {
          return 1 / o.aC(h, 1, e.tileZoom)
        }

        function Fc(h, e, i) {
          return o.aD(h.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
        }
        const Ro = (h, e, i, l, u) => {
          return {
            u_tl_parent: h,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: i.mix,
            u_opacity: i.opacity * l.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: l.paint.get("raster-brightness-min"),
            u_brightness_high: l.paint.get("raster-brightness-max"),
            u_saturation_factor: (g = l.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g),
            u_contrast_factor: (d = l.paint.get("raster-contrast"), d > 0 ? 1 / (1 - d) : 1 + d),
            u_spin_weights: Pp(l.paint.get("raster-hue-rotate")),
            u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
            u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y]
          };
          var d, g
        };

        function Pp(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h),
            i = Math.cos(h);
          return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
        }
        const Bo = (h, e, i, l, u, d, g, b, S, P, A, R, D) => {
            const O = g.transform;
            return {
              u_is_size_zoom_constant: +(h === "constant" || h === "source"),
              u_is_size_feature_constant: +(h === "constant" || h === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: O.cameraToCenterDistance,
              u_pitch: O.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +i,
              u_aspect_ratio: O.width / O.height,
              u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1,
              u_label_plane_matrix: b,
              u_coord_matrix: S,
              u_is_text: +A,
              u_pitch_with_map: +l,
              u_is_along_line: u,
              u_is_variable_anchor: d,
              u_texsize: R,
              u_texture: 0,
              u_translation: P,
              u_pitched_scale: D
            }
          },
          qh = (h, e, i, l, u, d, g, b, S, P, A, R, D, O) => {
            const $ = g.transform;
            return o.e(Bo(h, e, i, l, u, d, g, b, S, P, A, R, O), {
              u_gamma_scale: l ? Math.cos($.pitch * Math.PI / 180) * $.cameraToCenterDistance : 1,
              u_device_pixel_ratio: g.pixelRatio,
              u_is_halo: 1
            })
          },
          Ip = (h, e, i, l, u, d, g, b, S, P, A, R, D) => o.e(qh(h, e, i, l, u, d, g, b, S, P, !0, A, 0, D), {
            u_texsize_icon: R,
            u_texture_icon: 1
          }),
          Zh = (h, e) => ({
            u_opacity: h,
            u_color: e
          }),
          Uh = (h, e, i, l, u) => o.e((function(d, g, b, S) {
            const P = b.imageManager.getPattern(d.from.toString()),
              A = b.imageManager.getPattern(d.to.toString()),
              {
                width: R,
                height: D
              } = b.imageManager.getPixelSize(),
              O = Math.pow(2, S.tileID.overscaledZ),
              $ = S.tileSize * Math.pow(2, b.transform.tileZoom) / O,
              te = $ * (S.tileID.canonical.x + S.tileID.wrap * O),
              ee = $ * S.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: P.tl,
              u_pattern_br_a: P.br,
              u_pattern_tl_b: A.tl,
              u_pattern_br_b: A.br,
              u_texsize: [R, D],
              u_mix: g.t,
              u_pattern_size_a: P.displaySize,
              u_pattern_size_b: A.displaySize,
              u_scale_a: g.fromScale,
              u_scale_b: g.toScale,
              u_tile_units_to_pixels: 1 / o.aC(S, 1, b.transform.tileZoom),
              u_pixel_coord_upper: [te >> 16, ee >> 16],
              u_pixel_coord_lower: [65535 & te, 65535 & ee]
            }
          })(i, u, e, l), {
            u_opacity: h
          }),
          Oc = (h, e) => {},
          Nc = {
            fillExtrusion: (h, e) => ({
              u_lightpos: new o.bT(h, e.u_lightpos),
              u_lightpos_globe: new o.bT(h, e.u_lightpos_globe),
              u_lightintensity: new o.bg(h, e.u_lightintensity),
              u_lightcolor: new o.bT(h, e.u_lightcolor),
              u_vertical_gradient: new o.bg(h, e.u_vertical_gradient),
              u_opacity: new o.bg(h, e.u_opacity),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillExtrusionPattern: (h, e) => ({
              u_lightpos: new o.bT(h, e.u_lightpos),
              u_lightpos_globe: new o.bT(h, e.u_lightpos_globe),
              u_lightintensity: new o.bg(h, e.u_lightintensity),
              u_lightcolor: new o.bT(h, e.u_lightcolor),
              u_vertical_gradient: new o.bg(h, e.u_vertical_gradient),
              u_height_factor: new o.bg(h, e.u_height_factor),
              u_opacity: new o.bg(h, e.u_opacity),
              u_fill_translate: new o.bU(h, e.u_fill_translate),
              u_image: new o.bP(h, e.u_image),
              u_texsize: new o.bU(h, e.u_texsize),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade)
            }),
            fill: (h, e) => ({
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillPattern: (h, e) => ({
              u_image: new o.bP(h, e.u_image),
              u_texsize: new o.bU(h, e.u_texsize),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillOutline: (h, e) => ({
              u_world: new o.bU(h, e.u_world),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            fillOutlinePattern: (h, e) => ({
              u_world: new o.bU(h, e.u_world),
              u_image: new o.bP(h, e.u_image),
              u_texsize: new o.bU(h, e.u_texsize),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade),
              u_fill_translate: new o.bU(h, e.u_fill_translate)
            }),
            circle: (h, e) => ({
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_scale_with_map: new o.bP(h, e.u_scale_with_map),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_extrude_scale: new o.bU(h, e.u_extrude_scale),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new o.bg(h, e.u_globe_extrude_scale),
              u_translate: new o.bU(h, e.u_translate)
            }),
            collisionBox: (h, e) => ({
              u_pixel_extrude_scale: new o.bU(h, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (h, e) => ({
              u_viewport_size: new o.bU(h, e.u_viewport_size)
            }),
            debug: (h, e) => ({
              u_color: new o.bQ(h, e.u_color),
              u_overlay: new o.bP(h, e.u_overlay),
              u_overlay_scale: new o.bg(h, e.u_overlay_scale)
            }),
            depth: Oc,
            clippingMask: Oc,
            heatmap: (h, e) => ({
              u_extrude_scale: new o.bg(h, e.u_extrude_scale),
              u_intensity: new o.bg(h, e.u_intensity),
              u_globe_extrude_scale: new o.bg(h, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (h, e) => ({
              u_matrix: new o.bR(h, e.u_matrix),
              u_world: new o.bU(h, e.u_world),
              u_image: new o.bP(h, e.u_image),
              u_color_ramp: new o.bP(h, e.u_color_ramp),
              u_opacity: new o.bg(h, e.u_opacity)
            }),
            hillshade: (h, e) => ({
              u_image: new o.bP(h, e.u_image),
              u_latrange: new o.bU(h, e.u_latrange),
              u_exaggeration: new o.bg(h, e.u_exaggeration),
              u_altitudes: new o.b_(h, e.u_altitudes),
              u_azimuths: new o.b_(h, e.u_azimuths),
              u_accent: new o.bQ(h, e.u_accent),
              u_method: new o.bP(h, e.u_method),
              u_shadows: new o.bZ(h, e.u_shadows),
              u_highlights: new o.bZ(h, e.u_highlights)
            }),
            hillshadePrepare: (h, e) => ({
              u_matrix: new o.bR(h, e.u_matrix),
              u_image: new o.bP(h, e.u_image),
              u_dimension: new o.bU(h, e.u_dimension),
              u_zoom: new o.bg(h, e.u_zoom),
              u_unpack: new o.bS(h, e.u_unpack)
            }),
            colorRelief: (h, e) => ({
              u_image: new o.bP(h, e.u_image),
              u_unpack: new o.bS(h, e.u_unpack),
              u_dimension: new o.bU(h, e.u_dimension),
              u_elevation_stops: new o.bP(h, e.u_elevation_stops),
              u_color_stops: new o.bP(h, e.u_color_stops),
              u_color_ramp_size: new o.bP(h, e.u_color_ramp_size),
              u_opacity: new o.bg(h, e.u_opacity)
            }),
            line: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels)
            }),
            lineGradient: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels),
              u_image: new o.bP(h, e.u_image),
              u_image_height: new o.bg(h, e.u_image_height)
            }),
            linePattern: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_texsize: new o.bU(h, e.u_texsize),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_image: new o.bP(h, e.u_image),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels),
              u_scale: new o.bT(h, e.u_scale),
              u_fade: new o.bg(h, e.u_fade)
            }),
            lineSDF: (h, e) => ({
              u_translation: new o.bU(h, e.u_translation),
              u_ratio: new o.bg(h, e.u_ratio),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bU(h, e.u_units_to_pixels),
              u_patternscale_a: new o.bU(h, e.u_patternscale_a),
              u_patternscale_b: new o.bU(h, e.u_patternscale_b),
              u_sdfgamma: new o.bg(h, e.u_sdfgamma),
              u_image: new o.bP(h, e.u_image),
              u_tex_y_a: new o.bg(h, e.u_tex_y_a),
              u_tex_y_b: new o.bg(h, e.u_tex_y_b),
              u_mix: new o.bg(h, e.u_mix)
            }),
            raster: (h, e) => ({
              u_tl_parent: new o.bU(h, e.u_tl_parent),
              u_scale_parent: new o.bg(h, e.u_scale_parent),
              u_buffer_scale: new o.bg(h, e.u_buffer_scale),
              u_fade_t: new o.bg(h, e.u_fade_t),
              u_opacity: new o.bg(h, e.u_opacity),
              u_image0: new o.bP(h, e.u_image0),
              u_image1: new o.bP(h, e.u_image1),
              u_brightness_low: new o.bg(h, e.u_brightness_low),
              u_brightness_high: new o.bg(h, e.u_brightness_high),
              u_saturation_factor: new o.bg(h, e.u_saturation_factor),
              u_contrast_factor: new o.bg(h, e.u_contrast_factor),
              u_spin_weights: new o.bT(h, e.u_spin_weights),
              u_coords_top: new o.bS(h, e.u_coords_top),
              u_coords_bottom: new o.bS(h, e.u_coords_bottom)
            }),
            symbolIcon: (h, e) => ({
              u_is_size_zoom_constant: new o.bP(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bP(h, e.u_is_size_feature_constant),
              u_size_t: new o.bg(h, e.u_size_t),
              u_size: new o.bg(h, e.u_size),
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_pitch: new o.bg(h, e.u_pitch),
              u_rotate_symbol: new o.bP(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bg(h, e.u_aspect_ratio),
              u_fade_change: new o.bg(h, e.u_fade_change),
              u_label_plane_matrix: new o.bR(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bR(h, e.u_coord_matrix),
              u_is_text: new o.bP(h, e.u_is_text),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_is_along_line: new o.bP(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bP(h, e.u_is_variable_anchor),
              u_texsize: new o.bU(h, e.u_texsize),
              u_texture: new o.bP(h, e.u_texture),
              u_translation: new o.bU(h, e.u_translation),
              u_pitched_scale: new o.bg(h, e.u_pitched_scale)
            }),
            symbolSDF: (h, e) => ({
              u_is_size_zoom_constant: new o.bP(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bP(h, e.u_is_size_feature_constant),
              u_size_t: new o.bg(h, e.u_size_t),
              u_size: new o.bg(h, e.u_size),
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_pitch: new o.bg(h, e.u_pitch),
              u_rotate_symbol: new o.bP(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bg(h, e.u_aspect_ratio),
              u_fade_change: new o.bg(h, e.u_fade_change),
              u_label_plane_matrix: new o.bR(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bR(h, e.u_coord_matrix),
              u_is_text: new o.bP(h, e.u_is_text),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_is_along_line: new o.bP(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bP(h, e.u_is_variable_anchor),
              u_texsize: new o.bU(h, e.u_texsize),
              u_texture: new o.bP(h, e.u_texture),
              u_gamma_scale: new o.bg(h, e.u_gamma_scale),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_is_halo: new o.bP(h, e.u_is_halo),
              u_translation: new o.bU(h, e.u_translation),
              u_pitched_scale: new o.bg(h, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (h, e) => ({
              u_is_size_zoom_constant: new o.bP(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bP(h, e.u_is_size_feature_constant),
              u_size_t: new o.bg(h, e.u_size_t),
              u_size: new o.bg(h, e.u_size),
              u_camera_to_center_distance: new o.bg(h, e.u_camera_to_center_distance),
              u_pitch: new o.bg(h, e.u_pitch),
              u_rotate_symbol: new o.bP(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bg(h, e.u_aspect_ratio),
              u_fade_change: new o.bg(h, e.u_fade_change),
              u_label_plane_matrix: new o.bR(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bR(h, e.u_coord_matrix),
              u_is_text: new o.bP(h, e.u_is_text),
              u_pitch_with_map: new o.bP(h, e.u_pitch_with_map),
              u_is_along_line: new o.bP(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bP(h, e.u_is_variable_anchor),
              u_texsize: new o.bU(h, e.u_texsize),
              u_texsize_icon: new o.bU(h, e.u_texsize_icon),
              u_texture: new o.bP(h, e.u_texture),
              u_texture_icon: new o.bP(h, e.u_texture_icon),
              u_gamma_scale: new o.bg(h, e.u_gamma_scale),
              u_device_pixel_ratio: new o.bg(h, e.u_device_pixel_ratio),
              u_is_halo: new o.bP(h, e.u_is_halo),
              u_translation: new o.bU(h, e.u_translation),
              u_pitched_scale: new o.bg(h, e.u_pitched_scale)
            }),
            background: (h, e) => ({
              u_opacity: new o.bg(h, e.u_opacity),
              u_color: new o.bQ(h, e.u_color)
            }),
            backgroundPattern: (h, e) => ({
              u_opacity: new o.bg(h, e.u_opacity),
              u_image: new o.bP(h, e.u_image),
              u_pattern_tl_a: new o.bU(h, e.u_pattern_tl_a),
              u_pattern_br_a: new o.bU(h, e.u_pattern_br_a),
              u_pattern_tl_b: new o.bU(h, e.u_pattern_tl_b),
              u_pattern_br_b: new o.bU(h, e.u_pattern_br_b),
              u_texsize: new o.bU(h, e.u_texsize),
              u_mix: new o.bg(h, e.u_mix),
              u_pattern_size_a: new o.bU(h, e.u_pattern_size_a),
              u_pattern_size_b: new o.bU(h, e.u_pattern_size_b),
              u_scale_a: new o.bg(h, e.u_scale_a),
              u_scale_b: new o.bg(h, e.u_scale_b),
              u_pixel_coord_upper: new o.bU(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bU(h, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new o.bg(h, e.u_tile_units_to_pixels)
            }),
            terrain: (h, e) => ({
              u_texture: new o.bP(h, e.u_texture),
              u_ele_delta: new o.bg(h, e.u_ele_delta),
              u_fog_matrix: new o.bR(h, e.u_fog_matrix),
              u_fog_color: new o.bQ(h, e.u_fog_color),
              u_fog_ground_blend: new o.bg(h, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new o.bg(h, e.u_fog_ground_blend_opacity),
              u_horizon_color: new o.bQ(h, e.u_horizon_color),
              u_horizon_fog_blend: new o.bg(h, e.u_horizon_fog_blend),
              u_is_globe_mode: new o.bg(h, e.u_is_globe_mode)
            }),
            terrainDepth: (h, e) => ({
              u_ele_delta: new o.bg(h, e.u_ele_delta)
            }),
            terrainCoords: (h, e) => ({
              u_texture: new o.bP(h, e.u_texture),
              u_terrain_coords_id: new o.bg(h, e.u_terrain_coords_id),
              u_ele_delta: new o.bg(h, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (h, e) => ({
              u_input: new o.bg(h, e.u_input),
              u_output_expected: new o.bg(h, e.u_output_expected)
            }),
            atmosphere: (h, e) => ({
              u_sun_pos: new o.bT(h, e.u_sun_pos),
              u_atmosphere_blend: new o.bg(h, e.u_atmosphere_blend),
              u_globe_position: new o.bT(h, e.u_globe_position),
              u_globe_radius: new o.bg(h, e.u_globe_radius),
              u_inv_proj_matrix: new o.bR(h, e.u_inv_proj_matrix)
            }),
            sky: (h, e) => ({
              u_sky_color: new o.bQ(h, e.u_sky_color),
              u_horizon_color: new o.bQ(h, e.u_horizon_color),
              u_horizon: new o.bU(h, e.u_horizon),
              u_horizon_normal: new o.bU(h, e.u_horizon_normal),
              u_sky_horizon_blend: new o.bg(h, e.u_sky_horizon_blend),
              u_sky_blend: new o.bg(h, e.u_sky_blend)
            })
          };
        class $h {
          constructor(e, i, l) {
            this.context = e;
            const u = e.gl;
            this.buffer = u.createBuffer(), this.dynamicDraw = !!l, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), u.bufferData(u.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const i = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const Tl = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Ja {
          constructor(e, i, l, u) {
            this.length = i.length, this.attributes = l, this.itemSize = i.bytesPerElement, this.dynamicDraw = u, this.context = e;
            const d = e.gl;
            this.buffer = d.createBuffer(), e.bindVertexBuffer.set(this.buffer), d.bufferData(d.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const i = this.context.gl;
            this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, i) {
            for (let l = 0; l < this.attributes.length; l++) {
              const u = i.attributes[this.attributes[l].name];
              u !== void 0 && e.enableVertexAttribArray(u)
            }
          }
          setVertexAttribPointers(e, i, l) {
            for (let u = 0; u < this.attributes.length; u++) {
              const d = this.attributes[u],
                g = i.attributes[d.name];
              g !== void 0 && e.vertexAttribPointer(g, d.components, e[Tl[d.type]], !1, this.itemSize, d.offset + this.itemSize * (l || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class xn {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class jc extends xn {
          getDefault() {
            return o.bf.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Vc extends xn {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class Gh extends xn {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class qc extends xn {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Es extends xn {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Zc extends xn {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Mp extends xn {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const i = this.current;
            (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Ap extends xn {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class kp extends xn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class Ep extends xn {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Hh extends xn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class zp extends xn {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class Wh extends xn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.BLEND) : i.disable(i.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Sl extends xn {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Cl extends xn {
          getDefault() {
            return o.bf.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Pl extends xn {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class Uc extends xn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class zs extends xn {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Fo extends xn {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Js extends xn {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class va extends xn {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Xh extends xn {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Yh extends xn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindFramebuffer(i.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class $c extends xn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindRenderbuffer(i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ls extends xn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindTexture(i.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class Il extends xn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindBuffer(i.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ml extends xn {
          getDefault() {
            return null
          }
          set(e) {
            const i = this.gl;
            i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Oo extends xn {
          getDefault() {
            return null
          }
          set(e) {
            var i;
            if (e === this.current && !this.dirty) return;
            const l = this.gl;
            Ui(l) ? l.bindVertexArray(e) : (i = l.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class Al extends xn {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class Kh extends xn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Qs extends xn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class ps extends xn {
          constructor(e, i) {
            super(e), this.context = e, this.parent = i
          }
          getDefault() {
            return null
          }
        }
        class Jh extends ps {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class Gc extends ps {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ln extends ps {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const No = "Framebuffer is not complete";
        class Lp {
          constructor(e, i, l, u, d) {
            this.context = e, this.width = i, this.height = l;
            const g = e.gl,
              b = this.framebuffer = g.createFramebuffer();
            if (this.colorAttachment = new Jh(e, b), u) this.depthAttachment = d ? new ln(e, b) : new Gc(e, b);
            else if (d) throw new Error("Stencil cannot be set without depth");
            if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error(No)
          }
          destroy() {
            const e = this.context.gl,
              i = this.colorAttachment.get();
            if (i && e.deleteTexture(i), this.depthAttachment) {
              const l = this.depthAttachment.get();
              l && e.deleteRenderbuffer(l)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class Qh {
          constructor(e) {
            var i, l;
            if (this.gl = e, this.clearColor = new jc(this), this.clearDepth = new Vc(this), this.clearStencil = new Gh(this), this.colorMask = new qc(this), this.depthMask = new Es(this), this.stencilMask = new Zc(this), this.stencilFunc = new Mp(this), this.stencilOp = new Ap(this), this.stencilTest = new kp(this), this.depthRange = new Ep(this), this.depthTest = new Hh(this), this.depthFunc = new zp(this), this.blend = new Wh(this), this.blendFunc = new Sl(this), this.blendColor = new Cl(this), this.blendEquation = new Pl(this), this.cullFace = new Uc(this), this.cullFaceSide = new zs(this), this.frontFace = new Fo(this), this.program = new Js(this), this.activeTexture = new va(this), this.viewport = new Xh(this), this.bindFramebuffer = new Yh(this), this.bindRenderbuffer = new $c(this), this.bindTexture = new Ls(this), this.bindVertexBuffer = new Il(this), this.bindElementBuffer = new Ml(this), this.bindVertexArray = new Oo(this), this.pixelStoreUnpack = new Al(this), this.pixelStoreUnpackPremultiplyAlpha = new Kh(this), this.pixelStoreUnpackFlipY = new Qs(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Ui(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const u = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : u == null ? void 0 : u.RGBA16F_EXT, this.RGB16F = (l = e.RGB16F) !== null && l !== void 0 ? l : u == null ? void 0 : u.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const u = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, i) {
            return new $h(this, e, i)
          }
          createVertexBuffer(e, i, l) {
            return new Ja(this, e, i, l)
          }
          createRenderbuffer(e, i, l) {
            const u = this.gl,
              d = u.createRenderbuffer();
            return this.bindRenderbuffer.set(d), u.renderbufferStorage(u.RENDERBUFFER, e, i, l), this.bindRenderbuffer.set(null), d
          }
          createFramebuffer(e, i, l, u) {
            return new Lp(this, e, i, l, u)
          }
          clear({
            color: e,
            depth: i,
            stencil: l
          }) {
            const u = this.gl;
            let d = 0;
            e && (d |= u.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), i !== void 0 && (d |= u.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), l !== void 0 && (d |= u.STENCIL_BUFFER_BIT, this.clearStencil.set(l), this.stencilMask.set(255)), u.clear(d)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            o.bH(e.blendFunction, In.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return Ui(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var i;
            return Ui(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let fs;

        function ed(h, e, i, l, u) {
          const d = h.context,
            g = h.transform,
            b = d.gl,
            S = h.useProgram("collisionBox"),
            P = [];
          let A = 0,
            R = 0;
          for (let ne = 0; ne < l.length; ne++) {
            const le = l[ne],
              fe = e.getTile(le).getBucket(i);
            if (!fe) continue;
            const de = u ? fe.textCollisionBox : fe.iconCollisionBox,
              be = fe.collisionCircleArray;
            be.length > 0 && (P.push({
              circleArray: be,
              circleOffset: R,
              coord: le
            }), A += be.length / 4, R = A), de && S.draw(d, b.LINES, Hr.disabled, cn.disabled, h.colorModeForRenderPass(), Rr.disabled, bl(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(le), g.getProjectionData({
              overscaledTileID: le,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), i.id, de.layoutVertexBuffer, de.indexBuffer, de.segments, null, h.transform.zoom, null, null, de.collisionVertexBuffer)
          }
          if (!u || !P.length) return;
          const D = h.useProgram("collisionCircle"),
            O = new o.b$;
          O.resize(4 * A), O._trim();
          let $ = 0;
          for (const ne of P)
            for (let le = 0; le < ne.circleArray.length / 4; le++) {
              const fe = 4 * le,
                de = ne.circleArray[fe + 0],
                be = ne.circleArray[fe + 1],
                Ce = ne.circleArray[fe + 2],
                pe = ne.circleArray[fe + 3];
              O.emplace($++, de, be, Ce, pe, 0), O.emplace($++, de, be, Ce, pe, 1), O.emplace($++, de, be, Ce, pe, 2), O.emplace($++, de, be, Ce, pe, 3)
            }(!fs || fs.length < 2 * A) && (fs = (function(ne) {
              const le = 2 * ne,
                fe = new o.c1;
              fe.resize(le), fe._trim();
              for (let de = 0; de < le; de++) {
                const be = 6 * de;
                fe.uint16[be + 0] = 4 * de + 0, fe.uint16[be + 1] = 4 * de + 1, fe.uint16[be + 2] = 4 * de + 2, fe.uint16[be + 3] = 4 * de + 2, fe.uint16[be + 4] = 4 * de + 3, fe.uint16[be + 5] = 4 * de + 0
              }
              return fe
            })(A));
          const te = d.createIndexBuffer(fs, !0),
            ee = d.createVertexBuffer(O, o.c0.members, !0);
          for (const ne of P) {
            const le = Sp(h.transform);
            D.draw(d, b.TRIANGLES, Hr.disabled, cn.disabled, h.colorModeForRenderPass(), Rr.disabled, le, h.style.map.terrain && h.style.map.terrain.getTerrainData(ne.coord), null, i.id, ee, te, o.aM.simpleSegment(0, 2 * ne.circleOffset, ne.circleArray.length, ne.circleArray.length / 2), null, h.transform.zoom, null, null, null)
          }
          ee.destroy(), te.destroy()
        }
        const Dp = o.ag(new Float32Array(16));

        function td(h, e, i, l, u, d) {
          const {
            horizontalAlign: g,
            verticalAlign: b
          } = o.aH(h);
          return new o.P((-(g - .5) * e / u + l[0]) * d, (-(b - .5) * i / u + l[1]) * d)
        }

        function Rp(h, e, i, l, u, d) {
          const g = e.tileAnchorPoint.add(new o.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let b = l.mult(d);
            i || (b = b.rotate(-u));
            const S = g.add(b);
            return qr(S.x, S.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (i) {
            const b = Cr(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h),
              S = Math.atan(b.y / b.x) + (b.x < 0 ? Math.PI : 0);
            return h.add(l.rotate(S))
          }
          return h.add(l)
        }

        function Hc(h, e, i, l, u, d, g, b, S, P, A, R) {
          const D = h.text.placedSymbolArray,
            O = h.text.dynamicLayoutVertexArray,
            $ = h.icon.dynamicLayoutVertexArray,
            te = {};
          O.clear();
          for (let ee = 0; ee < D.length; ee++) {
            const ne = D.get(ee),
              le = ne.hidden || !ne.crossTileID || h.allowVerticalPlacement && !ne.placedOrientation ? null : l[ne.crossTileID];
            if (le) {
              const fe = new o.P(ne.anchorX, ne.anchorY),
                de = {
                  getElevation: R,
                  width: u.width,
                  height: u.height,
                  pitchedLabelPlaneMatrix: d,
                  pitchWithMap: i,
                  transform: u,
                  tileAnchorPoint: fe,
                  translation: P,
                  unwrappedTileID: A
                },
                be = i ? tn(fe.x, fe.y, de) : Cr(fe.x, fe.y, de),
                Ce = yt(u.cameraToCenterDistance, be.signedDistanceFromCamera);
              let pe = o.ap(h.textSizeData, b, ne) * Ce / o.aB;
              i && (pe *= h.tilePixelRatio / g);
              const {
                width: Be,
                height: et,
                anchor: Ze,
                textOffset: Ge,
                textBoxScale: Ke
              } = le, Rt = td(Ze, Be, et, Ge, Ke, pe), Ft = u.getPitchedTextCorrection(fe.x + P[0], fe.y + P[1], A), St = Rp(be.point, de, e, Rt, -u.bearingInRadians, Ft), pr = h.allowVerticalPlacement && ne.placedOrientation === o.ao.vertical ? Math.PI / 2 : 0;
              for (let Jr = 0; Jr < ne.numGlyphs; Jr++) o.av(O, St, pr);
              S && ne.associatedIconIndex >= 0 && (te[ne.associatedIconIndex] = {
                shiftedAnchor: St,
                angle: pr
              })
            } else vn(ne.numGlyphs, O)
          }
          if (S) {
            $.clear();
            const ee = h.icon.placedSymbolArray;
            for (let ne = 0; ne < ee.length; ne++) {
              const le = ee.get(ne);
              if (le.hidden) vn(le.numGlyphs, $);
              else {
                const fe = te[ne];
                if (fe)
                  for (let de = 0; de < le.numGlyphs; de++) o.av($, fe.shiftedAnchor, fe.angle);
                else vn(le.numGlyphs, $)
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData($)
          }
          h.text.dynamicLayoutVertexBuffer.updateData(O)
        }

        function kl(h, e, i) {
          return i.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
        }

        function jo(h, e, i, l, u, d, g, b, S, P, A, R, D) {
          const O = h.context,
            $ = O.gl,
            te = h.transform,
            ee = b === "map",
            ne = S === "map",
            le = b !== "viewport" && i.layout.get("symbol-placement") !== "point",
            fe = ee && !ne && !le,
            de = !i.layout.get("symbol-sort-key").isConstant();
          let be = !1;
          const Ce = h.getDepthModeForSublayer(0, Hr.ReadOnly),
            pe = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Be = [],
            et = te.getCircleRadiusCorrection();
          for (const Ze of l) {
            const Ge = e.getTile(Ze),
              Ke = Ge.getBucket(i);
            if (!Ke) continue;
            const Rt = u ? Ke.text : Ke.icon;
            if (!Rt || !Rt.segments.get().length || !Rt.hasVisibleVertices) continue;
            const Ft = Rt.programConfigurations.get(i.id),
              St = u || Ke.sdfIcons,
              pr = u ? Ke.textSizeData : Ke.iconSizeData,
              Jr = ne || te.pitch !== 0,
              wn = h.useProgram(kl(St, u, Ke), Ft),
              Ln = o.an(pr, te.zoom),
              Mn = h.style.map.terrain && h.style.map.terrain.getTerrainData(Ze);
            let Gn, Kn, Kr, Dn, si = [0, 0],
              fi = null;
            if (u) Kn = Ge.glyphAtlasTexture, Kr = $.LINEAR, Gn = Ge.glyphAtlasTexture.size, Ke.iconsInText && (si = Ge.imageAtlasTexture.size, fi = Ge.imageAtlasTexture, Dn = Jr || h.options.rotating || h.options.zooming || pr.kind === "composite" || pr.kind === "camera" ? $.LINEAR : $.NEAREST);
            else {
              const oi = i.layout.get("icon-size").constantOr(0) !== 1 || Ke.iconsNeedLinear;
              Kn = Ge.imageAtlasTexture, Kr = St || h.options.rotating || h.options.zooming || oi || Jr ? $.LINEAR : $.NEAREST, Gn = Ge.imageAtlasTexture.size
            }
            const bi = o.aC(Ge, 1, h.transform.zoom),
              Gi = Ht(ee, h.transform, bi),
              La = o.L();
            o.aq(La, Gi);
            const _s = Yt(ne, ee, h.transform, bi),
              gs = o.aD(te, Ge, d, g),
              ho = te.getProjectionData({
                overscaledTileID: Ze,
                applyGlobeMatrix: !D,
                applyTerrainMatrix: !0
              }),
              po = pe && Ke.hasTextData(),
              js = i.layout.get("icon-text-fit") !== "none" && po && Ke.hasIconData();
            if (le) {
              const oi = h.style.map.terrain ? (ba, li) => h.style.map.terrain.getElevation(Ze, ba, li) : null,
                mi = i.layout.get("text-rotation-alignment") === "map";
              Yr(Ke, h, u, Gi, La, ne, P, mi, Ze.toUnwrapped(), te.width, te.height, gs, oi)
            }
            const Vs = u && pe || js,
              ra = le || Vs ? Dp : ne ? Gi : h.transform.clipSpaceToPixelsMatrix,
              Da = St && i.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Hi;
            Hi = St ? Ke.iconsInText ? Ip(pr.kind, Ln, fe, ne, le, Vs, h, ra, _s, gs, Gn, si, et) : qh(pr.kind, Ln, fe, ne, le, Vs, h, ra, _s, gs, u, Gn, 0, et) : Bo(pr.kind, Ln, fe, ne, le, Vs, h, ra, _s, gs, u, Gn, et);
            const vs = {
              program: wn,
              buffers: Rt,
              uniformValues: Hi,
              projectionData: ho,
              atlasTexture: Kn,
              atlasTextureIcon: fi,
              atlasInterpolation: Kr,
              atlasInterpolationIcon: Dn,
              isSDF: St,
              hasHalo: Da
            };
            if (de && Ke.canOverlap) {
              be = !0;
              const oi = Rt.segments.get();
              for (const mi of oi) Be.push({
                segments: new o.aM([mi]),
                sortKey: mi.sortKey,
                state: vs,
                terrainData: Mn
              })
            } else Be.push({
              segments: Rt.segments,
              sortKey: 0,
              state: vs,
              terrainData: Mn
            })
          }
          be && Be.sort(((Ze, Ge) => Ze.sortKey - Ge.sortKey));
          for (const Ze of Be) {
            const Ge = Ze.state;
            if (O.activeTexture.set($.TEXTURE0), Ge.atlasTexture.bind(Ge.atlasInterpolation, $.CLAMP_TO_EDGE), Ge.atlasTextureIcon && (O.activeTexture.set($.TEXTURE1), Ge.atlasTextureIcon && Ge.atlasTextureIcon.bind(Ge.atlasInterpolationIcon, $.CLAMP_TO_EDGE)), Ge.isSDF) {
              const Ke = Ge.uniformValues;
              Ge.hasHalo && (Ke.u_is_halo = 1, Vo(Ge.buffers, Ze.segments, i, h, Ge.program, Ce, A, R, Ke, Ge.projectionData, Ze.terrainData)), Ke.u_is_halo = 0
            }
            Vo(Ge.buffers, Ze.segments, i, h, Ge.program, Ce, A, R, Ge.uniformValues, Ge.projectionData, Ze.terrainData)
          }
        }

        function Vo(h, e, i, l, u, d, g, b, S, P, A) {
          const R = l.context;
          u.draw(R, R.gl.TRIANGLES, d, g, b, Rr.backCCW, S, A, P, i.id, h.layoutVertexBuffer, h.indexBuffer, e, i.paint, l.transform.zoom, h.programConfigurations.get(i.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
        }

        function Wc(h, e, i, l, u) {
          const d = h.context,
            g = d.gl,
            b = cn.disabled,
            S = new In([g.ONE, g.ONE], o.bf.transparent, [!0, !0, !0, !0]),
            P = e.getBucket(i);
          if (!P) return;
          const A = l.key;
          let R = i.heatmapFbos.get(A);
          R || (R = qo(d, e.tileSize, e.tileSize), i.heatmapFbos.set(A, R)), d.bindFramebuffer.set(R.framebuffer), d.viewport.set([0, 0, e.tileSize, e.tileSize]), d.clear({
            color: o.bf.transparent
          });
          const D = P.programConfigurations.get(i.id),
            O = h.useProgram("heatmap", D, !u),
            $ = h.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            te = h.style.map.terrain.getTerrainData(l);
          O.draw(d, g.TRIANGLES, Hr.disabled, b, S, Rr.disabled, Fh(e, h.transform.zoom, i.paint.get("heatmap-intensity"), 1), te, $, i.id, P.layoutVertexBuffer, P.indexBuffer, P.segments, i.paint, h.transform.zoom, D)
        }

        function rd(h, e, i, l, u) {
          const d = h.context,
            g = d.gl,
            b = h.transform;
          d.setColorMode(h.colorModeForRenderPass());
          const S = Zo(d, e),
            P = i.key,
            A = e.heatmapFbos.get(P);
          if (!A) return;
          d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, A.colorAttachment.get()), d.activeTexture.set(g.TEXTURE1), S.bind(g.LINEAR, g.CLAMP_TO_EDGE);
          const R = b.getProjectionData({
            overscaledTileID: i,
            applyTerrainMatrix: u,
            applyGlobeMatrix: !l
          });
          h.useProgram("heatmapTexture").draw(d, g.TRIANGLES, Hr.disabled, cn.disabled, h.colorModeForRenderPass(), Rr.disabled, Dc(h, e, 0, 1), null, R, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, b.zoom), A.destroy(), e.heatmapFbos.delete(P)
        }

        function qo(h, e, i) {
          var l, u;
          const d = h.gl,
            g = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, g), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
          const b = (l = h.HALF_FLOAT) !== null && l !== void 0 ? l : d.UNSIGNED_BYTE,
            S = (u = h.RGBA16F) !== null && u !== void 0 ? u : d.RGBA;
          d.texImage2D(d.TEXTURE_2D, 0, S, e, i, 0, d.RGBA, b, null);
          const P = h.createFramebuffer(e, i, !1, !1);
          return P.colorAttachment.set(g), P
        }

        function Zo(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new o.T(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture
        }

        function Uo(h, e, i, l, u) {
          if (!i || !l || !l.imageAtlas) return;
          const d = l.imageAtlas.patternPositions;
          let g = d[i.to.toString()],
            b = d[i.from.toString()];
          if (!g && b && (g = b), !b && g && (b = g), !g || !b) {
            const S = u.getPaintProperty(e);
            g = d[S], b = d[S]
          }
          g && b && h.setConstantPatternPositions(g, b)
        }

        function El(h, e, i, l, u, d, g, b) {
          const S = h.context.gl,
            P = "fill-pattern",
            A = i.paint.get(P),
            R = A && A.constantOr(1),
            D = i.getCrossfadeParameters();
          let O, $, te, ee, ne;
          const le = h.transform,
            fe = i.paint.get("fill-translate"),
            de = i.paint.get("fill-translate-anchor");
          g ? ($ = R && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", O = S.LINES) : ($ = R ? "fillPattern" : "fill", O = S.TRIANGLES);
          const be = A.constantOr(null);
          for (const Ce of l) {
            const pe = e.getTile(Ce);
            if (R && !pe.patternsLoaded()) continue;
            const Be = pe.getBucket(i);
            if (!Be) continue;
            const et = Be.programConfigurations.get(i.id),
              Ze = h.useProgram($, et),
              Ge = h.style.map.terrain && h.style.map.terrain.getTerrainData(Ce);
            R && (h.context.activeTexture.set(S.TEXTURE0), pe.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE), et.updatePaintBuffers(D)), Uo(et, P, be, pe, i);
            const Ke = le.getProjectionData({
                overscaledTileID: Ce,
                applyGlobeMatrix: !b,
                applyTerrainMatrix: !0
              }),
              Rt = o.aD(le, pe, fe, de);
            if (g) {
              ee = Be.indexBuffer2, ne = Be.segments2;
              const St = [S.drawingBufferWidth, S.drawingBufferHeight];
              te = $ === "fillOutlinePattern" && R ? Do(h, D, pe, St, Rt) : Lo(St, Rt)
            } else ee = Be.indexBuffer, ne = Be.segments, te = R ? xl(h, D, pe, Rt) : {
              u_fill_translate: Rt
            };
            const Ft = h.stencilModeForClipping(Ce);
            Ze.draw(h.context, O, u, Ft, d, Rr.backCCW, te, Ge, Ke, i.id, Be.layoutVertexBuffer, ee, ne, i.paint, h.transform.zoom, et)
          }
        }

        function Xc(h, e, i, l, u, d, g, b) {
          const S = h.context,
            P = S.gl,
            A = "fill-extrusion-pattern",
            R = i.paint.get(A),
            D = R.constantOr(1),
            O = i.getCrossfadeParameters(),
            $ = i.paint.get("fill-extrusion-opacity"),
            te = R.constantOr(null),
            ee = h.transform;
          for (const ne of l) {
            const le = e.getTile(ne),
              fe = le.getBucket(i);
            if (!fe) continue;
            const de = h.style.map.terrain && h.style.map.terrain.getTerrainData(ne),
              be = fe.programConfigurations.get(i.id),
              Ce = h.useProgram(D ? "fillExtrusionPattern" : "fillExtrusion", be);
            D && (h.context.activeTexture.set(P.TEXTURE0), le.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), be.updatePaintBuffers(O));
            const pe = ee.getProjectionData({
              overscaledTileID: ne,
              applyGlobeMatrix: !b,
              applyTerrainMatrix: !0
            });
            Uo(be, A, te, le, i);
            const Be = o.aD(ee, le, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),
              et = i.paint.get("fill-extrusion-vertical-gradient"),
              Ze = D ? wp(h, et, $, Be, ne, O, le) : Ia(h, et, $, Be);
            Ce.draw(S, S.gl.TRIANGLES, u, d, g, Rr.backCCW, Ze, de, pe, i.id, fe.layoutVertexBuffer, fe.indexBuffer, fe.segments, i.paint, h.transform.zoom, be, h.style.map.terrain && fe.centroidVertexBuffer)
          }
        }

        function Ds(h, e, i, l, u, d, g, b, S) {
          var P;
          const A = h.style.projection,
            R = h.context,
            D = h.transform,
            O = R.gl,
            $ = [`#define NUM_ILLUMINATION_SOURCES ${i.paint.get("hillshade-highlight-color").values.length}`],
            te = h.useProgram("hillshade", null, !1, $),
            ee = !h.options.moving;
          for (const ne of l) {
            const le = e.getTile(ne),
              fe = le.fbo;
            if (!fe) continue;
            const de = A.getMeshFromTileID(R, ne.canonical, b, !0, "raster"),
              be = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(ne);
            R.activeTexture.set(O.TEXTURE0), O.bindTexture(O.TEXTURE_2D, fe.colorAttachment.get());
            const Ce = D.getProjectionData({
              overscaledTileID: ne,
              aligned: ee,
              applyGlobeMatrix: !S,
              applyTerrainMatrix: !0
            });
            te.draw(R, O.TRIANGLES, d, u[ne.overscaledZ], g, Rr.backCCW, Cp(h, le, i), be, Ce, i.id, de.vertexBuffer, de.indexBuffer, de.segments)
          }
        }

        function Yc(h, e, i, l, u, d, g, b, S) {
          var P;
          const A = h.style.projection,
            R = h.context,
            D = h.transform,
            O = R.gl,
            $ = h.useProgram("colorRelief"),
            te = !h.options.moving;
          let ee = !0,
            ne = 0;
          for (const le of l) {
            const fe = e.getTile(le),
              de = fe.dem;
            if (ee) {
              const Ze = O.getParameter(O.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: Ge,
                  colorTexture: Ke
                } = i.getColorRampTextures(R, Ze, de.getUnpackVector());
              R.activeTexture.set(O.TEXTURE1), Ge.bind(O.NEAREST, O.CLAMP_TO_EDGE), R.activeTexture.set(O.TEXTURE4), Ke.bind(O.LINEAR, O.CLAMP_TO_EDGE), ee = !1, ne = Ge.size[0]
            }
            if (!de || !de.data) continue;
            const be = de.stride,
              Ce = de.getPixels();
            if (R.activeTexture.set(O.TEXTURE0), R.pixelStoreUnpackPremultiplyAlpha.set(!1), fe.demTexture = fe.demTexture || h.getTileTexture(be), fe.demTexture) {
              const Ze = fe.demTexture;
              Ze.update(Ce, {
                premultiply: !1
              }), Ze.bind(O.LINEAR, O.CLAMP_TO_EDGE)
            } else fe.demTexture = new o.T(R, Ce, O.RGBA, {
              premultiply: !1
            }), fe.demTexture.bind(O.LINEAR, O.CLAMP_TO_EDGE);
            const pe = A.getMeshFromTileID(R, le.canonical, b, !0, "raster"),
              Be = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(le),
              et = D.getProjectionData({
                overscaledTileID: le,
                aligned: te,
                applyGlobeMatrix: !S,
                applyTerrainMatrix: !0
              });
            $.draw(R, O.TRIANGLES, d, u[le.overscaledZ], g, Rr.backCCW, Nh(i, fe.dem, ne), Be, et, i.id, pe.vertexBuffer, pe.indexBuffer, pe.segments)
          }
        }
        const zl = [new o.P(0, 0), new o.P(o.$, 0), new o.P(o.$, o.$), new o.P(0, o.$)];

        function Rs(h, e, i, l, u, d, g, b, S = !1, P = !1) {
          const A = l[l.length - 1].overscaledZ,
            R = h.context,
            D = R.gl,
            O = h.useProgram("raster"),
            $ = h.transform,
            te = h.style.projection,
            ee = h.colorModeForRenderPass(),
            ne = !h.options.moving;
          for (const le of l) {
            const fe = h.getDepthModeForSublayer(le.overscaledZ - A, i.paint.get("raster-opacity") === 1 ? Hr.ReadWrite : Hr.ReadOnly, D.LESS),
              de = e.getTile(le);
            de.registerFadeDuration(i.paint.get("raster-fade-duration"));
            const be = e.findLoadedParent(le, 0),
              Ce = e.findLoadedSibling(le),
              pe = Kc(de, be || Ce || null, e, i, h.transform, h.style.map.terrain);
            let Be, et;
            const Ze = i.paint.get("raster-resampling") === "nearest" ? D.NEAREST : D.LINEAR;
            R.activeTexture.set(D.TEXTURE0), de.texture.bind(Ze, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), R.activeTexture.set(D.TEXTURE1), be ? (be.texture.bind(Ze, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), Be = Math.pow(2, be.tileID.overscaledZ - de.tileID.overscaledZ), et = [de.tileID.canonical.x * Be % 1, de.tileID.canonical.y * Be % 1]) : de.texture.bind(Ze, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), de.texture.useMipmap && R.extTextureFilterAnisotropic && h.transform.pitch > 20 && D.texParameterf(D.TEXTURE_2D, R.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, R.extTextureFilterAnisotropicMax);
            const Ge = h.style.map.terrain && h.style.map.terrain.getTerrainData(le),
              Ke = $.getProjectionData({
                overscaledTileID: le,
                aligned: ne,
                applyGlobeMatrix: !P,
                applyTerrainMatrix: !0
              }),
              Rt = Ro(et || [0, 0], Be || 1, pe, i, b),
              Ft = te.getMeshFromTileID(R, le.canonical, d, g, "raster");
            O.draw(R, D.TRIANGLES, fe, u ? u[le.overscaledZ] : cn.disabled, ee, S ? Rr.frontCCW : Rr.backCCW, Rt, Ge, Ke, i.id, Ft.vertexBuffer, Ft.indexBuffer, Ft.segments)
          }
        }

        function Kc(h, e, i, l, u, d) {
          const g = l.paint.get("raster-fade-duration");
          if (!d && g > 0) {
            const b = se.now(),
              S = (b - h.timeAdded) / g,
              P = e ? (b - e.timeAdded) / g : -1,
              A = i.getSource(),
              R = kt(u, {
                tileSize: A.tileSize,
                roundZoom: A.roundZoom
              }),
              D = !e || Math.abs(e.tileID.overscaledZ - R) > Math.abs(h.tileID.overscaledZ - R),
              O = D && h.refreshedUponExpiration ? 1 : o.ah(D ? S : 1 - P, 0, 1);
            return h.refreshedUponExpiration && S >= 1 && (h.refreshedUponExpiration = !1), e ? {
              opacity: 1,
              mix: 1 - O
            } : {
              opacity: O,
              mix: 0
            }
          }
          return {
            opacity: 1,
            mix: 0
          }
        }
        const nd = new o.bf(1, 0, 0, 1),
          id = new o.bf(0, 1, 0, 1),
          Ll = new o.bf(0, 0, 1, 1),
          Jc = new o.bf(1, 0, 1, 1),
          Bp = new o.bf(0, 1, 1, 1);

        function Qc(h, e, i, l) {
          Ua(h, 0, e + i / 2, h.transform.width, i, l)
        }

        function Yn(h, e, i, l) {
          Ua(h, e - i / 2, 0, i, h.transform.height, l)
        }

        function Ua(h, e, i, l, u, d) {
          const g = h.context,
            b = g.gl;
          b.enable(b.SCISSOR_TEST), b.scissor(e * h.pixelRatio, i * h.pixelRatio, l * h.pixelRatio, u * h.pixelRatio), g.clear({
            color: d
          }), b.disable(b.SCISSOR_TEST)
        }

        function ya(h, e, i) {
          const l = h.context,
            u = l.gl,
            d = h.useProgram("debug"),
            g = Hr.disabled,
            b = cn.disabled,
            S = h.colorModeForRenderPass(),
            P = "$debug",
            A = h.style.map.terrain && h.style.map.terrain.getTerrainData(i);
          l.activeTexture.set(u.TEXTURE0);
          const R = e.getTileByID(i.key).latestRawTileData,
            D = Math.floor((R && R.byteLength || 0) / 1024),
            O = e.getTile(i).tileSize,
            $ = 512 / Math.min(O, 512) * (i.overscaledZ / h.transform.zoom) * .5;
          let te = i.canonical.toString();
          i.overscaledZ !== i.canonical.z && (te += ` => ${i.overscaledZ}`), (function(ne, le) {
            ne.initDebugOverlayCanvas();
            const fe = ne.debugOverlayCanvas,
              de = ne.context.gl,
              be = ne.debugOverlayCanvas.getContext("2d");
            be.clearRect(0, 0, fe.width, fe.height), be.shadowColor = "white", be.shadowBlur = 2, be.lineWidth = 1.5, be.strokeStyle = "white", be.textBaseline = "top", be.font = "bold 36px Open Sans, sans-serif", be.fillText(le, 5, 5), be.strokeText(le, 5, 5), ne.debugOverlayTexture.update(fe), ne.debugOverlayTexture.bind(de.LINEAR, de.CLAMP_TO_EDGE)
          })(h, `${te} ${D}kB`);
          const ee = h.transform.getProjectionData({
            overscaledTileID: i,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          d.draw(l, u.TRIANGLES, g, b, In.alphaBlended, Rr.disabled, As(o.bf.transparent, $), null, ee, P, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), d.draw(l, u.LINE_STRIP, g, b, S, Rr.disabled, As(o.bf.red), A, ee, P, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
        }

        function Dl(h, e, i, l) {
          const {
            isRenderingGlobe: u
          } = l, d = h.context, g = d.gl, b = h.transform, S = h.colorModeForRenderPass(), P = h.getDepthModeFor3D(), A = h.useProgram("terrain");
          d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
          for (const R of i) {
            const D = e.getTerrainMesh(R.tileID),
              O = h.renderToTexture.getTexture(R),
              $ = e.getTerrainData(R.tileID);
            d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, O.texture);
            const te = e.getMeshFrameDelta(b.zoom),
              ee = b.calculateFogMatrix(R.tileID.toUnwrapped()),
              ne = vl(te, ee, h.style.sky, b.pitch, u),
              le = b.getProjectionData({
                overscaledTileID: R.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            A.draw(d, g.TRIANGLES, P, cn.disabled, S, Rr.backCCW, ne, $, le, "terrain", D.vertexBuffer, D.indexBuffer, D.segments)
          }
        }

        function $o(h, e) {
          if (!e.mesh) {
            const i = new o.aL;
            i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1);
            const l = new o.aN;
            l.emplaceBack(0, 1, 2), l.emplaceBack(0, 2, 3), e.mesh = new Tn(h.createVertexBuffer(i, Un.members), h.createIndexBuffer(l), o.aM.simpleSegment(0, 0, i.length, l.length))
          }
          return e.mesh
        }
        class ad {
          constructor(e, i) {
            this.context = new Qh(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: o.ag(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Jt.maxUnderzooming + Jt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Wr
          }
          resize(e, i, l) {
            if (this.width = Math.floor(e * l), this.height = Math.floor(i * l), this.pixelRatio = l, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const u of this.style._order) this.style._layers[u].resize()
          }
          setup() {
            const e = this.context,
              i = new o.aL;
            i.emplaceBack(0, 0), i.emplaceBack(o.$, 0), i.emplaceBack(0, o.$), i.emplaceBack(o.$, o.$), this.tileExtentBuffer = e.createVertexBuffer(i, Un.members), this.tileExtentSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const l = new o.aL;
            l.emplaceBack(0, 0), l.emplaceBack(o.$, 0), l.emplaceBack(0, o.$), l.emplaceBack(o.$, o.$), this.debugBuffer = e.createVertexBuffer(l, Un.members), this.debugSegments = o.aM.simpleSegment(0, 0, 4, 5);
            const u = new o.c6;
            u.emplaceBack(0, 0, 0, 0), u.emplaceBack(o.$, 0, o.$, 0), u.emplaceBack(0, o.$, 0, o.$), u.emplaceBack(o.$, o.$, o.$, o.$), this.rasterBoundsBuffer = e.createVertexBuffer(u, xp.members), this.rasterBoundsSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const d = new o.aL;
            d.emplaceBack(0, 0), d.emplaceBack(o.$, 0), d.emplaceBack(0, o.$), d.emplaceBack(o.$, o.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, Un.members), this.rasterBoundsSegmentsPosOnly = o.aM.simpleSegment(0, 0, 4, 5);
            const g = new o.aL;
            g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(g, Un.members), this.viewportSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const b = new o.c7;
            b.emplaceBack(0), b.emplaceBack(1), b.emplaceBack(3), b.emplaceBack(2), b.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(b);
            const S = new o.aN;
            S.emplaceBack(1, 0, 2), S.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(S);
            const P = this.context.gl;
            this.stencilClearMode = new cn({
              func: P.ALWAYS,
              mask: 0
            }, 0, 255, P.ZERO, P.ZERO, P.ZERO), this.tileExtentMesh = new Tn(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              i = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const l = o.L();
            o.bY(l, 0, this.width, this.height, 0, 0, 1), o.N(l, l, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
            const u = {
              mainMatrix: l,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: l
            };
            this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, Hr.disabled, this.stencilClearMode, In.disabled, Rr.disabled, null, null, u, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, i, l) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + i.length > 256 && this.clearStencil();
            const u = this.context;
            u.setColorMode(In.disabled), u.setDepthMode(Hr.disabled);
            const d = {};
            for (const g of i) d[g.key] = this.nextStencilID++;
            this._renderTileMasks(d, i, l, !0), this._renderTileMasks(d, i, l, !1), this._tileClippingMaskIDs = d
          }
          _renderTileMasks(e, i, l, u) {
            const d = this.context,
              g = d.gl,
              b = this.style.projection,
              S = this.transform,
              P = this.useProgram("clippingMask");
            for (const A of i) {
              const R = e[A.key],
                D = this.style.map.terrain && this.style.map.terrain.getTerrainData(A),
                O = b.getMeshFromTileID(this.context, A.canonical, u, !0, "stencil"),
                $ = S.getProjectionData({
                  overscaledTileID: A,
                  applyGlobeMatrix: !l,
                  applyTerrainMatrix: !0
                });
              P.draw(d, g.TRIANGLES, Hr.disabled, new cn({
                func: g.ALWAYS,
                mask: 0
              }, R, 255, g.KEEP, g.KEEP, g.REPLACE), In.disabled, l ? Rr.disabled : Rr.backCCW, null, D, $, "$clipping", O.vertexBuffer, O.indexBuffer, O.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              i = e.gl,
              l = this.style.projection,
              u = this.transform,
              d = this.useProgram("depth"),
              g = this.getDepthModeFor3D(),
              b = xe(u, {
                tileSize: u.tileSize
              });
            for (const S of b) {
              const P = this.style.map.terrain && this.style.map.terrain.getTerrainData(S),
                A = l.getMeshFromTileID(this.context, S.canonical, !0, !0, "raster"),
                R = u.getProjectionData({
                  overscaledTileID: S,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              d.draw(e, i.TRIANGLES, g, cn.disabled, In.disabled, Rr.backCCW, null, P, R, "$clipping", A.vertexBuffer, A.indexBuffer, A.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              i = this.context.gl;
            return new cn({
              func: i.NOTEQUAL,
              mask: 255
            }, e, 255, i.KEEP, i.KEEP, i.REPLACE)
          }
          stencilModeForClipping(e) {
            const i = this.context.gl;
            return new cn({
              func: i.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, i.KEEP, i.KEEP, i.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const i = this.context.gl,
              l = e.sort(((g, b) => b.overscaledZ - g.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              d = l[0].overscaledZ - u + 1;
            if (d > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + d > 256 && this.clearStencil();
              const g = {};
              for (let b = 0; b < d; b++) g[b + u] = new cn({
                func: i.GEQUAL,
                mask: 255
              }, b + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID += d, [g, l]
            }
            return [{
              [u]: cn.disabled
            }, l]
          }
          stencilConfigForOverlapTwoPass(e) {
            const i = this.context.gl,
              l = e.sort(((g, b) => b.overscaledZ - g.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              d = l[0].overscaledZ - u + 1;
            if (this.clearStencil(), d > 1) {
              const g = {},
                b = {};
              for (let S = 0; S < d; S++) g[S + u] = new cn({
                func: i.GREATER,
                mask: 255
              }, d + 1 + S, 255, i.KEEP, i.KEEP, i.REPLACE), b[S + u] = new cn({
                func: i.GREATER,
                mask: 255
              }, 1 + S, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID = 2 * d + 1, [g, b, l]
            }
            return this.nextStencilID = 3, [{
              [u]: new cn({
                func: i.GREATER,
                mask: 255
              }, 2, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, {
              [u]: new cn({
                func: i.GREATER,
                mask: 255
              }, 1, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, l]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new In([e.CONSTANT_COLOR, e.ONE], new o.bf(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? In.unblended : In.alphaBlended
          }
          getDepthModeForSublayer(e, i, l) {
            if (!this.opaquePassEnabledForLayer()) return Hr.disabled;
            const u = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Hr(l || this.context.gl.LEQUAL, i, [u, u])
          }
          getDepthModeFor3D() {
            return new Hr(this.context.gl.LEQUAL, Hr.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, i) {
            var l, u;
            this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(se.now()), this.imageManager.beginFrame();
            const d = this.style._order,
              g = this.style.sourceCaches,
              b = {},
              S = {},
              P = {},
              A = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((l = e.projection) === null || l === void 0 ? void 0 : l.transitionState) > 0
              };
            for (const D in g) {
              const O = g[D];
              O.used && O.prepare(this.context), b[D] = O.getVisibleCoordinates(!1), S[D] = b[D].slice().reverse(), P[D] = O.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let D = 0; D < d.length; D++)
              if (this.style._layers[d[D]].is3D()) {
                this.opaquePassCutoff = D;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const D of d) {
              const O = this.style._layers[D];
              if (!O.hasOffscreenPass() || O.isHidden(this.transform.zoom)) continue;
              const $ = S[O.source];
              (O.type === "custom" || $.length) && this.renderLayer(this, g[O.source], O, $, A)
            }
            if ((u = this.style.projection) === null || u === void 0 || u.updateGPUdependent({
                context: this.context,
                useProgram: D => this.useProgram(D)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: i.showOverdrawInspector ? o.bf.black : o.bf.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(D, O) {
                const $ = D.context,
                  te = $.gl,
                  ee = ((Ce, pe, Be) => {
                    const et = Math.cos(pe.rollInRadians),
                      Ze = Math.sin(pe.rollInRadians),
                      Ge = he(pe),
                      Ke = pe.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Ce.properties.get("sky-color"),
                      u_horizon_color: Ce.properties.get("horizon-color"),
                      u_horizon: [(pe.width / 2 - Ge * Ze) * Be, (pe.height / 2 + Ge * et) * Be],
                      u_horizon_normal: [-Ze, et],
                      u_sky_horizon_blend: Ce.properties.get("sky-horizon-blend") * pe.height / 2 * Be,
                      u_sky_blend: Ke
                    }
                  })(O, D.style.map.transform, D.pixelRatio),
                  ne = new Hr(te.LEQUAL, Hr.ReadWrite, [0, 1]),
                  le = cn.disabled,
                  fe = D.colorModeForRenderPass(),
                  de = D.useProgram("sky"),
                  be = $o($, O);
                de.draw($, te.TRIANGLES, ne, le, fe, Rr.disabled, ee, null, void 0, "sky", be.vertexBuffer, be.indexBuffer, be.segments)
              })(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const D = this.style._layers[d[this.currentLayer]],
                  O = g[D.source],
                  $ = b[D.source];
                this._renderTileClippingMasks(D, $, !1), this.renderLayer(this, O, D, $, A)
              }
            this.renderPass = "translucent";
            let R = !1;
            for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
              const D = this.style._layers[d[this.currentLayer]],
                O = g[D.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(D, A)) continue;
              this.opaquePassEnabledForLayer() || R || (R = !0, A.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const $ = (D.type === "symbol" ? P : S)[D.source];
              this._renderTileClippingMasks(D, b[D.source], !!this.renderToTexture), this.renderLayer(this, O, D, $, A)
            }
            if (A.isRenderingGlobe && (function(D, O, $) {
                const te = D.context,
                  ee = te.gl,
                  ne = D.useProgram("atmosphere"),
                  le = new Hr(ee.LEQUAL, Hr.ReadOnly, [0, 1]),
                  fe = D.transform,
                  de = (function(Ke, Rt) {
                    const Ft = Ke.properties.get("position"),
                      St = [-Ft.x, -Ft.y, -Ft.z],
                      pr = o.ag(new Float64Array(16));
                    return Ke.properties.get("anchor") === "map" && (o.b6(pr, pr, Rt.rollInRadians), o.b7(pr, pr, -Rt.pitchInRadians), o.b6(pr, pr, Rt.bearingInRadians), o.b7(pr, pr, Rt.center.lat * Math.PI / 180), o.bz(pr, pr, -Rt.center.lng * Math.PI / 180)), o.c5(St, St, pr), St
                  })($, D.transform),
                  be = fe.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Ce = O.properties.get("atmosphere-blend") * be.projectionTransition;
                if (Ce === 0) return;
                const pe = Ys(fe.worldSize, fe.center.lat),
                  Be = fe.inverseProjectionMatrix,
                  et = new Float64Array(4);
                et[3] = 1, o.aw(et, et, fe.modelViewProjectionMatrix), et[0] /= et[3], et[1] /= et[3], et[2] /= et[3], et[3] = 1, o.aw(et, et, Be), et[0] /= et[3], et[1] /= et[3], et[2] /= et[3], et[3] = 1;
                const Ze = ((Ke, Rt, Ft, St, pr) => ({
                    u_sun_pos: Ke,
                    u_atmosphere_blend: Rt,
                    u_globe_position: Ft,
                    u_globe_radius: St,
                    u_inv_proj_matrix: pr
                  }))(de, Ce, [et[0], et[1], et[2]], pe, Be),
                  Ge = $o(te, O);
                ne.draw(te, ee.TRIANGLES, le, cn.disabled, In.alphaBlended, Rr.disabled, Ze, null, null, "atmosphere", Ge.vertexBuffer, Ge.indexBuffer, Ge.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const D = (function(O, $) {
                let te = null;
                const ee = Object.values(O._layers).flatMap((de => de.source && !de.isHidden($) ? [O.sourceCaches[de.source]] : [])),
                  ne = ee.filter((de => de.getSource().type === "vector")),
                  le = ee.filter((de => de.getSource().type !== "vector")),
                  fe = de => {
                    (!te || te.getSource().maxzoom < de.getSource().maxzoom) && (te = de)
                  };
                return ne.forEach((de => fe(de))), te || le.forEach((de => fe(de))), te
              })(this.style, this.transform.zoom);
              D && (function(O, $, te) {
                for (let ee = 0; ee < te.length; ee++) ya(O, $, te[ee])
              })(this, D, D.getVisibleCoordinates())
            }
            this.options.showPadding && (function(D) {
              const O = D.transform.padding;
              Qc(D, D.transform.height - (O.top || 0), 3, nd), Qc(D, O.bottom || 0, 3, id), Yn(D, O.left || 0, 3, Ll), Yn(D, D.transform.width - (O.right || 0), 3, Jc);
              const $ = D.transform.centerPoint;
              (function(te, ee, ne, le) {
                Ua(te, ee - 1, ne - 10, 2, 20, le), Ua(te, ee - 10, ne - 1, 20, 2, le)
              })(D, $.x, D.transform.height - $.y, Bp)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i = this.terrainFacilitator.matrix,
              l = this.transform.modelViewProjectionMatrix;
            let u = this.terrainFacilitator.dirty;
            u || (u = e ? !o.c8(i, l) : !o.c9(i, l)), u || (u = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), u && (o.ca(i, l), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(d, g) {
              const b = d.context,
                S = b.gl,
                P = d.transform,
                A = In.unblended,
                R = new Hr(S.LEQUAL, Hr.ReadWrite, [0, 1]),
                D = g.sourceCache.getRenderableTiles(),
                O = d.useProgram("terrainDepth");
              b.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), b.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), b.clear({
                color: o.bf.transparent,
                depth: 1
              });
              for (const $ of D) {
                const te = g.getTerrainMesh($.tileID),
                  ee = g.getTerrainData($.tileID),
                  ne = P.getProjectionData({
                    overscaledTileID: $.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  le = {
                    u_ele_delta: g.getMeshFrameDelta(P.zoom)
                  };
                O.draw(b, S.TRIANGLES, R, cn.disabled, A, Rr.backCCW, le, ee, ne, "terrain", te.vertexBuffer, te.indexBuffer, te.segments)
              }
              b.bindFramebuffer.set(null), b.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain), (function(d, g) {
              const b = d.context,
                S = b.gl,
                P = d.transform,
                A = In.unblended,
                R = new Hr(S.LEQUAL, Hr.ReadWrite, [0, 1]),
                D = g.getCoordsTexture(),
                O = g.sourceCache.getRenderableTiles(),
                $ = d.useProgram("terrainCoords");
              b.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), b.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), b.clear({
                color: o.bf.transparent,
                depth: 1
              }), g.coordsIndex = [];
              for (const te of O) {
                const ee = g.getTerrainMesh(te.tileID),
                  ne = g.getTerrainData(te.tileID);
                b.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, D.texture);
                const le = {
                    u_terrain_coords_id: (255 - g.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: g.getMeshFrameDelta(P.zoom)
                  },
                  fe = P.getProjectionData({
                    overscaledTileID: te.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                $.draw(b, S.TRIANGLES, R, cn.disabled, A, Rr.backCCW, le, ne, fe, "terrain", ee.vertexBuffer, ee.indexBuffer, ee.segments), g.coordsIndex.push(te.tileID.key)
              }
              b.bindFramebuffer.set(null), b.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, i, l, u, d) {
            l.isHidden(this.transform.zoom) || (l.type === "background" || l.type === "custom" || (u || []).length) && (this.id = l.id, o.cb(l) ? (function(g, b, S, P, A, R) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: D
              } = R, O = cn.disabled, $ = g.colorModeForRenderPass();
              (S._unevaluatedLayout.hasValue("text-variable-anchor") || S._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(te, ee, ne, le, fe, de, be, Ce, pe) {
                const Be = ee.transform,
                  et = ee.style.map.terrain,
                  Ze = fe === "map",
                  Ge = de === "map";
                for (const Ke of te) {
                  const Rt = le.getTile(Ke),
                    Ft = Rt.getBucket(ne);
                  if (!Ft || !Ft.text || !Ft.text.segments.get().length) continue;
                  const St = o.an(Ft.textSizeData, Be.zoom),
                    pr = o.aC(Rt, 1, ee.transform.zoom),
                    Jr = Ht(Ze, ee.transform, pr),
                    wn = ne.layout.get("icon-text-fit") !== "none" && Ft.hasIconData();
                  if (St) {
                    const Ln = Math.pow(2, Be.zoom - Rt.tileID.overscaledZ),
                      Mn = et ? (Gn, Kn) => et.getElevation(Ke, Gn, Kn) : null;
                    Hc(Ft, Ze, Ge, pe, Be, Jr, Ln, St, wn, o.aD(Be, Rt, be, Ce), Ke.toUnwrapped(), Mn)
                  }
                }
              })(P, g, S, b, S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), A), S.paint.get("icon-opacity").constantOr(1) !== 0 && jo(g, b, S, P, !1, S.paint.get("icon-translate"), S.paint.get("icon-translate-anchor"), S.layout.get("icon-rotation-alignment"), S.layout.get("icon-pitch-alignment"), S.layout.get("icon-keep-upright"), O, $, D), S.paint.get("text-opacity").constantOr(1) !== 0 && jo(g, b, S, P, !0, S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.layout.get("text-keep-upright"), O, $, D), b.map.showCollisionBoxes && (ed(g, b, S, P, !0), ed(g, b, S, P, !1))
            })(e, i, l, u, this.style.placement.variableOffsets, d) : o.cc(l) ? (function(g, b, S, P, A) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = A, D = S.paint.get("circle-opacity"), O = S.paint.get("circle-stroke-width"), $ = S.paint.get("circle-stroke-opacity"), te = !S.layout.get("circle-sort-key").isConstant();
              if (D.constantOr(1) === 0 && (O.constantOr(1) === 0 || $.constantOr(1) === 0)) return;
              const ee = g.context,
                ne = ee.gl,
                le = g.transform,
                fe = g.getDepthModeForSublayer(0, Hr.ReadOnly),
                de = cn.disabled,
                be = g.colorModeForRenderPass(),
                Ce = [],
                pe = le.getCircleRadiusCorrection();
              for (let Be = 0; Be < P.length; Be++) {
                const et = P[Be],
                  Ze = b.getTile(et),
                  Ge = Ze.getBucket(S);
                if (!Ge) continue;
                const Ke = S.paint.get("circle-translate"),
                  Rt = S.paint.get("circle-translate-anchor"),
                  Ft = o.aD(le, Ze, Ke, Rt),
                  St = Ge.programConfigurations.get(S.id),
                  pr = g.useProgram("circle", St),
                  Jr = Ge.layoutVertexBuffer,
                  wn = Ge.indexBuffer,
                  Ln = g.style.map.terrain && g.style.map.terrain.getTerrainData(et),
                  Mn = {
                    programConfiguration: St,
                    program: pr,
                    layoutVertexBuffer: Jr,
                    indexBuffer: wn,
                    uniformValues: Tp(g, Ze, S, Ft, pe),
                    terrainData: Ln,
                    projectionData: le.getProjectionData({
                      overscaledTileID: et,
                      applyGlobeMatrix: !R,
                      applyTerrainMatrix: !0
                    })
                  };
                if (te) {
                  const Gn = Ge.segments.get();
                  for (const Kn of Gn) Ce.push({
                    segments: new o.aM([Kn]),
                    sortKey: Kn.sortKey,
                    state: Mn
                  })
                } else Ce.push({
                  segments: Ge.segments,
                  sortKey: 0,
                  state: Mn
                })
              }
              te && Ce.sort(((Be, et) => Be.sortKey - et.sortKey));
              for (const Be of Ce) {
                const {
                  programConfiguration: et,
                  program: Ze,
                  layoutVertexBuffer: Ge,
                  indexBuffer: Ke,
                  uniformValues: Rt,
                  terrainData: Ft,
                  projectionData: St
                } = Be.state;
                Ze.draw(ee, ne.TRIANGLES, fe, de, be, Rr.backCCW, Rt, Ft, St, S.id, Ge, Ke, Be.segments, S.paint, g.transform.zoom, et)
              }
            })(e, i, l, u, d) : o.cd(l) ? (function(g, b, S, P, A) {
              if (S.paint.get("heatmap-opacity") === 0) return;
              const R = g.context,
                {
                  isRenderingToTexture: D,
                  isRenderingGlobe: O
                } = A;
              if (g.style.map.terrain) {
                for (const $ of P) {
                  const te = b.getTile($);
                  b.hasRenderableParent($) || (g.renderPass === "offscreen" ? Wc(g, te, S, $, O) : g.renderPass === "translucent" && rd(g, S, $, D, O))
                }
                R.viewport.set([0, 0, g.width, g.height])
              } else g.renderPass === "offscreen" ? (function($, te, ee, ne) {
                const le = $.context,
                  fe = le.gl,
                  de = $.transform,
                  be = cn.disabled,
                  Ce = new In([fe.ONE, fe.ONE], o.bf.transparent, [!0, !0, !0, !0]);
                (function(pe, Be, et) {
                  const Ze = pe.gl;
                  pe.activeTexture.set(Ze.TEXTURE1), pe.viewport.set([0, 0, Be.width / 4, Be.height / 4]);
                  let Ge = et.heatmapFbos.get(o.c2);
                  Ge ? (Ze.bindTexture(Ze.TEXTURE_2D, Ge.colorAttachment.get()), pe.bindFramebuffer.set(Ge.framebuffer)) : (Ge = qo(pe, Be.width / 4, Be.height / 4), et.heatmapFbos.set(o.c2, Ge))
                })(le, $, ee), le.clear({
                  color: o.bf.transparent
                });
                for (let pe = 0; pe < ne.length; pe++) {
                  const Be = ne[pe];
                  if (te.hasRenderableParent(Be)) continue;
                  const et = te.getTile(Be),
                    Ze = et.getBucket(ee);
                  if (!Ze) continue;
                  const Ge = Ze.programConfigurations.get(ee.id),
                    Ke = $.useProgram("heatmap", Ge),
                    Rt = de.getProjectionData({
                      overscaledTileID: Be,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    Ft = de.getCircleRadiusCorrection();
                  Ke.draw(le, fe.TRIANGLES, Hr.disabled, be, Ce, Rr.backCCW, Fh(et, de.zoom, ee.paint.get("heatmap-intensity"), Ft), null, Rt, ee.id, Ze.layoutVertexBuffer, Ze.indexBuffer, Ze.segments, ee.paint, de.zoom, Ge)
                }
                le.viewport.set([0, 0, $.width, $.height])
              })(g, b, S, P) : g.renderPass === "translucent" && (function($, te) {
                const ee = $.context,
                  ne = ee.gl;
                ee.setColorMode($.colorModeForRenderPass());
                const le = te.heatmapFbos.get(o.c2);
                le && (ee.activeTexture.set(ne.TEXTURE0), ne.bindTexture(ne.TEXTURE_2D, le.colorAttachment.get()), ee.activeTexture.set(ne.TEXTURE1), Zo(ee, te).bind(ne.LINEAR, ne.CLAMP_TO_EDGE), $.useProgram("heatmapTexture").draw(ee, ne.TRIANGLES, Hr.disabled, cn.disabled, $.colorModeForRenderPass(), Rr.disabled, Dc($, te, 0, 1), null, null, te.id, $.viewportBuffer, $.quadTriangleIndexBuffer, $.viewportSegments, te.paint, $.transform.zoom))
              })(g, S)
            })(e, i, l, u, d) : o.ce(l) ? (function(g, b, S, P, A) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = A, D = S.paint.get("line-opacity"), O = S.paint.get("line-width");
              if (D.constantOr(1) === 0 || O.constantOr(1) === 0) return;
              const $ = g.getDepthModeForSublayer(0, Hr.ReadOnly),
                te = g.colorModeForRenderPass(),
                ee = S.paint.get("line-dasharray"),
                ne = S.paint.get("line-pattern"),
                le = ne.constantOr(1),
                fe = S.paint.get("line-gradient"),
                de = S.getCrossfadeParameters(),
                be = le ? "linePattern" : ee ? "lineSDF" : fe ? "lineGradient" : "line",
                Ce = g.context,
                pe = Ce.gl,
                Be = g.transform;
              let et = !0;
              for (const Ze of P) {
                const Ge = b.getTile(Ze);
                if (le && !Ge.patternsLoaded()) continue;
                const Ke = Ge.getBucket(S);
                if (!Ke) continue;
                const Rt = Ke.programConfigurations.get(S.id),
                  Ft = g.context.program.get(),
                  St = g.useProgram(be, Rt),
                  pr = et || St.program !== Ft,
                  Jr = g.style.map.terrain && g.style.map.terrain.getTerrainData(Ze),
                  wn = ne.constantOr(null);
                if (wn && Ge.imageAtlas) {
                  const Kr = Ge.imageAtlas,
                    Dn = Kr.patternPositions[wn.to.toString()],
                    si = Kr.patternPositions[wn.from.toString()];
                  Dn && si && Rt.setConstantPatternPositions(Dn, si)
                }
                const Ln = Be.getProjectionData({
                    overscaledTileID: Ze,
                    applyGlobeMatrix: !R,
                    applyTerrainMatrix: !0
                  }),
                  Mn = Be.getPixelScale(),
                  Gn = le ? Vh(g, Ge, S, Mn, de) : ee ? ks(g, Ge, S, Mn, ee, de) : fe ? jh(g, Ge, S, Mn, Ke.lineClipsArray.length) : wl(g, Ge, S, Mn);
                if (le) Ce.activeTexture.set(pe.TEXTURE0), Ge.imageAtlasTexture.bind(pe.LINEAR, pe.CLAMP_TO_EDGE), Rt.updatePaintBuffers(de);
                else if (ee && (pr || g.lineAtlas.dirty)) Ce.activeTexture.set(pe.TEXTURE0), g.lineAtlas.bind(Ce);
                else if (fe) {
                  const Kr = Ke.gradients[S.id];
                  let Dn = Kr.texture;
                  if (S.gradientVersion !== Kr.version) {
                    let si = 256;
                    if (S.stepInterpolant) {
                      const fi = b.getSource().maxzoom,
                        bi = Ze.canonical.z === fi ? Math.ceil(1 << g.transform.maxZoom - Ze.canonical.z) : 1;
                      si = o.ah(o.c3(Ke.maxLineLength / o.$ * 1024 * bi), 256, Ce.maxTextureSize)
                    }
                    Kr.gradient = o.c4({
                      expression: S.gradientExpression(),
                      evaluationKey: "lineProgress",
                      resolution: si,
                      image: Kr.gradient || void 0,
                      clips: Ke.lineClipsArray
                    }), Kr.texture ? Kr.texture.update(Kr.gradient) : Kr.texture = new o.T(Ce, Kr.gradient, pe.RGBA), Kr.version = S.gradientVersion, Dn = Kr.texture
                  }
                  Ce.activeTexture.set(pe.TEXTURE0), Dn.bind(S.stepInterpolant ? pe.NEAREST : pe.LINEAR, pe.CLAMP_TO_EDGE)
                }
                const Kn = g.stencilModeForClipping(Ze);
                St.draw(Ce, pe.TRIANGLES, $, Kn, te, Rr.disabled, Gn, Jr, Ln, S.id, Ke.layoutVertexBuffer, Ke.indexBuffer, Ke.segments, S.paint, g.transform.zoom, Rt, Ke.layoutVertexBuffer2), et = !1
              }
            })(e, i, l, u, d) : o.cf(l) ? (function(g, b, S, P, A) {
              const R = S.paint.get("fill-color"),
                D = S.paint.get("fill-opacity");
              if (D.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: O
              } = A, $ = g.colorModeForRenderPass(), te = S.paint.get("fill-pattern"), ee = g.opaquePassEnabledForLayer() && !te.constantOr(1) && R.constantOr(o.bf.transparent).a === 1 && D.constantOr(0) === 1 ? "opaque" : "translucent";
              if (g.renderPass === ee) {
                const ne = g.getDepthModeForSublayer(1, g.renderPass === "opaque" ? Hr.ReadWrite : Hr.ReadOnly);
                El(g, b, S, P, ne, $, !1, O)
              }
              if (g.renderPass === "translucent" && S.paint.get("fill-antialias")) {
                const ne = g.getDepthModeForSublayer(S.getPaintProperty("fill-outline-color") ? 2 : 0, Hr.ReadOnly);
                El(g, b, S, P, ne, $, !0, O)
              }
            })(e, i, l, u, d) : o.cg(l) ? (function(g, b, S, P, A) {
              const R = S.paint.get("fill-extrusion-opacity");
              if (R === 0) return;
              const {
                isRenderingToTexture: D
              } = A;
              if (g.renderPass === "translucent") {
                const O = new Hr(g.context.gl.LEQUAL, Hr.ReadWrite, g.depthRangeFor3D);
                if (R !== 1 || S.paint.get("fill-extrusion-pattern").constantOr(1)) Xc(g, b, S, P, O, cn.disabled, In.disabled, D), Xc(g, b, S, P, O, g.stencilModeFor3D(), g.colorModeForRenderPass(), D);
                else {
                  const $ = g.colorModeForRenderPass();
                  Xc(g, b, S, P, O, cn.disabled, $, D)
                }
              }
            })(e, i, l, u, d) : o.ch(l) ? (function(g, b, S, P, A) {
              if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = A, D = g.context, O = g.style.projection.useSubdivision, $ = g.getDepthModeForSublayer(0, Hr.ReadOnly), te = g.colorModeForRenderPass();
              if (g.renderPass === "offscreen")(function(ee, ne, le, fe, de, be, Ce) {
                const pe = ee.context,
                  Be = pe.gl;
                for (const et of le) {
                  const Ze = ne.getTile(et),
                    Ge = Ze.dem;
                  if (!Ge || !Ge.data || !Ze.needsHillshadePrepare) continue;
                  const Ke = Ge.dim,
                    Rt = Ge.stride,
                    Ft = Ge.getPixels();
                  if (pe.activeTexture.set(Be.TEXTURE1), pe.pixelStoreUnpackPremultiplyAlpha.set(!1), Ze.demTexture = Ze.demTexture || ee.getTileTexture(Rt), Ze.demTexture) {
                    const pr = Ze.demTexture;
                    pr.update(Ft, {
                      premultiply: !1
                    }), pr.bind(Be.NEAREST, Be.CLAMP_TO_EDGE)
                  } else Ze.demTexture = new o.T(pe, Ft, Be.RGBA, {
                    premultiply: !1
                  }), Ze.demTexture.bind(Be.NEAREST, Be.CLAMP_TO_EDGE);
                  pe.activeTexture.set(Be.TEXTURE0);
                  let St = Ze.fbo;
                  if (!St) {
                    const pr = new o.T(pe, {
                      width: Ke,
                      height: Ke,
                      data: null
                    }, Be.RGBA);
                    pr.bind(Be.LINEAR, Be.CLAMP_TO_EDGE), St = Ze.fbo = pe.createFramebuffer(Ke, Ke, !0, !1), St.colorAttachment.set(pr.texture)
                  }
                  pe.bindFramebuffer.set(St.framebuffer), pe.viewport.set([0, 0, Ke, Ke]), ee.useProgram("hillshadePrepare").draw(pe, Be.TRIANGLES, de, be, Ce, Rr.disabled, Oh(Ze.tileID, Ge), null, null, fe.id, ee.rasterBoundsBuffer, ee.quadTriangleIndexBuffer, ee.rasterBoundsSegments), Ze.needsHillshadePrepare = !1
                }
              })(g, b, P, S, $, cn.disabled, te), D.viewport.set([0, 0, g.width, g.height]);
              else if (g.renderPass === "translucent")
                if (O) {
                  const [ee, ne, le] = g.stencilConfigForOverlapTwoPass(P);
                  Ds(g, b, S, le, ee, $, te, !1, R), Ds(g, b, S, le, ne, $, te, !0, R)
                } else {
                  const [ee, ne] = g.getStencilConfigForOverlapAndUpdateStencilID(P);
                  Ds(g, b, S, ne, ee, $, te, !1, R)
                }
            })(e, i, l, u, d) : o.ci(l) ? (function(g, b, S, P, A) {
              if (g.renderPass !== "translucent" || !P.length) return;
              const {
                isRenderingToTexture: R
              } = A, D = g.style.projection.useSubdivision, O = g.getDepthModeForSublayer(0, Hr.ReadOnly), $ = g.colorModeForRenderPass();
              if (D) {
                const [te, ee, ne] = g.stencilConfigForOverlapTwoPass(P);
                Yc(g, b, S, ne, te, O, $, !1, R), Yc(g, b, S, ne, ee, O, $, !0, R)
              } else {
                const [te, ee] = g.getStencilConfigForOverlapAndUpdateStencilID(P);
                Yc(g, b, S, ee, te, O, $, !1, R)
              }
            })(e, i, l, u, d) : o.cj(l) ? (function(g, b, S, P, A) {
              if (g.renderPass !== "translucent" || S.paint.get("raster-opacity") === 0 || !P.length) return;
              const {
                isRenderingToTexture: R
              } = A, D = b.getSource(), O = g.style.projection.useSubdivision;
              if (D instanceof It) Rs(g, b, S, P, null, !1, !1, D.tileCoords, D.flippedWindingOrder, R);
              else if (O) {
                const [$, te, ee] = g.stencilConfigForOverlapTwoPass(P);
                Rs(g, b, S, ee, $, !1, !0, zl, !1, R), Rs(g, b, S, ee, te, !0, !0, zl, !1, R)
              } else {
                const [$, te] = g.getStencilConfigForOverlapAndUpdateStencilID(P);
                Rs(g, b, S, te, $, !1, !0, zl, !1, R)
              }
            })(e, i, l, u, d) : o.ck(l) ? (function(g, b, S, P, A) {
              const R = S.paint.get("background-color"),
                D = S.paint.get("background-opacity");
              if (D === 0) return;
              const {
                isRenderingToTexture: O
              } = A, $ = g.context, te = $.gl, ee = g.style.projection, ne = g.transform, le = ne.tileSize, fe = S.paint.get("background-pattern");
              if (g.isPatternMissing(fe)) return;
              const de = !fe && R.a === 1 && D === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass !== de) return;
              const be = cn.disabled,
                Ce = g.getDepthModeForSublayer(0, de === "opaque" ? Hr.ReadWrite : Hr.ReadOnly),
                pe = g.colorModeForRenderPass(),
                Be = g.useProgram(fe ? "backgroundPattern" : "background"),
                et = P || xe(ne, {
                  tileSize: le,
                  terrain: g.style.map.terrain
                });
              fe && ($.activeTexture.set(te.TEXTURE0), g.imageManager.bind(g.context));
              const Ze = S.getCrossfadeParameters();
              for (const Ge of et) {
                const Ke = ne.getProjectionData({
                    overscaledTileID: Ge,
                    applyGlobeMatrix: !O,
                    applyTerrainMatrix: !0
                  }),
                  Rt = fe ? Uh(D, g, fe, {
                    tileID: Ge,
                    tileSize: le
                  }, Ze) : Zh(D, R),
                  Ft = g.style.map.terrain && g.style.map.terrain.getTerrainData(Ge),
                  St = ee.getMeshFromTileID($, Ge.canonical, !1, !0, "raster");
                Be.draw($, te.TRIANGLES, Ce, be, pe, Rr.backCCW, Rt, Ft, Ke, S.id, St.vertexBuffer, St.indexBuffer, St.segments)
              }
            })(e, 0, l, u, d) : o.cl(l) && (function(g, b, S, P) {
              const {
                isRenderingGlobe: A
              } = P, R = g.context, D = S.implementation, O = g.style.projection, $ = g.transform, te = $.getProjectionDataForCustomLayer(A), ee = {
                farZ: $.farZ,
                nearZ: $.nearZ,
                fov: $.fov * Math.PI / 180,
                modelViewProjectionMatrix: $.modelViewProjectionMatrix,
                projectionMatrix: $.projectionMatrix,
                shaderData: {
                  variantName: O.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${O.shaderPreludeCode.vertexSource}`,
                  define: O.shaderDefine
                },
                defaultProjectionData: te
              }, ne = D.renderingMode ? D.renderingMode : "2d";
              if (g.renderPass === "offscreen") {
                const le = D.prerender;
                le && (g.setCustomLayerDefaults(), R.setColorMode(g.colorModeForRenderPass()), le.call(D, R.gl, ee), R.setDirty(), g.setBaseState())
              } else if (g.renderPass === "translucent") {
                g.setCustomLayerDefaults(), R.setColorMode(g.colorModeForRenderPass()), R.setStencilMode(cn.disabled);
                const le = ne === "3d" ? g.getDepthModeFor3D() : g.getDepthModeForSublayer(0, Hr.ReadOnly);
                R.setDepthMode(le), D.render(R.gl, ee), R.setDirty(), g.setBaseState(), R.bindFramebuffer.set(null)
              }
            })(e, 0, l, d))
          }
          saveTileTexture(e) {
            const i = this._tileTextures[e.size[0]];
            i ? i.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const i = this._tileTextures[e];
            return i && i.length > 0 ? i.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const i = this.imageManager.getPattern(e.from.toString()),
              l = this.imageManager.getPattern(e.to.toString());
            return !i || !l
          }
          useProgram(e, i, l = !1, u = []) {
            this.cache = this.cache || {};
            const d = !!this.style.map.terrain,
              g = this.style.projection,
              b = l ? dn.projectionMercator : g.shaderPreludeCode,
              S = l ? En : g.shaderDefine,
              P = e + (i ? i.cacheKey : "") + `/${l?fn:g.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (u ? `/${u.join("/")}` : "");
            return this.cache[P] || (this.cache[P] = new Lc(this.context, dn[e], i, Nc[e], this._showOverdrawInspector, d, b, S, u)), this.cache[P]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: i
            } = this.context.gl;
            return this.width !== e || this.height !== i
          }
        }

        function Bs(h, e) {
          let i, l = !1,
            u = null,
            d = null;
          const g = () => {
            u = null, l && (h.apply(d, i), u = setTimeout(g, e), l = !1)
          };
          return (...b) => (l = !0, d = this, i = b, u || g(), u)
        }
        class Rl {
          constructor(e) {
            this._getCurrentHash = () => {
              const i = window.location.hash.replace("#", "");
              if (this._hashName) {
                let l;
                return i.split("&").map((u => u.split("="))).forEach((u => {
                  u[0] === this._hashName && (l = u)
                })), (l && l[1] || "").split("/")
              }
              return i.split("/")
            }, this._onHashChange = () => {
              const i = this._getCurrentHash();
              if (!this._isValidHash(i)) return !1;
              const l = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+i[2], +i[1]],
                zoom: +i[0],
                bearing: l,
                pitch: +(i[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const i = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, i)
            }, this._removeHash = () => {
              const i = this._getCurrentHash();
              if (i.length === 0) return;
              const l = i.join("/");
              let u = l;
              u.split("&").length > 0 && (u = u.split("&")[0]), this._hashName && (u = `${this._hashName}=${l}`);
              let d = window.location.hash.replace(u, "");
              d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
              let g = window.location.href.replace(/(#.+)?$/, d);
              g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g)
            }, this._updateHash = Bs(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const i = this._map.getCenter(),
              l = Math.round(100 * this._map.getZoom()) / 100,
              u = Math.ceil((l * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              d = Math.pow(10, u),
              g = Math.round(i.lng * d) / d,
              b = Math.round(i.lat * d) / d,
              S = this._map.getBearing(),
              P = this._map.getPitch();
            let A = "";
            if (A += e ? `/${g}/${b}/${l}` : `${l}/${b}/${g}`, (S || P) && (A += "/" + Math.round(10 * S) / 10), P && (A += `/${Math.round(P)}`), this._hashName) {
              const R = this._hashName;
              let D = !1;
              const O = window.location.hash.slice(1).split("&").map(($ => {
                const te = $.split("=")[0];
                return te === R ? (D = !0, `${te}=${A}`) : $
              })).filter(($ => $));
              return D || O.push(`${R}=${A}`), `#${O.join("&")}`
            }
            return `#${A}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new o.S(+e[2], +e[1])
            } catch {
              return !1
            }
            const i = +e[0],
              l = +(e[3] || 0),
              u = +(e[4] || 0);
            return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && l >= -180 && l <= 180 && u >= this._map.getMinPitch() && u <= this._map.getMaxPitch()
          }
        }
        const Qa = {
            linearity: .3,
            easing: o.cm(0, 0, .3, 1)
          },
          eu = o.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, Qa),
          sd = o.e({
            deceleration: 20,
            maxSpeed: 1400
          }, Qa),
          od = o.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Qa),
          ld = o.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, Qa),
          cd = o.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Qa);
        class ud {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: se.now(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              i = se.now();
            for (; e.length > 0 && i - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new o.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: d
              }
              of this._inertiaBuffer) i.zoom += d.zoomDelta || 0, i.bearing += d.bearingDelta || 0, i.pitch += d.pitchDelta || 0, i.roll += d.rollDelta || 0, d.panDelta && i.pan._add(d.panDelta), d.around && (i.around = d.around), d.pinchAround && (i.pinchAround = d.pinchAround);
            const l = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              u = {};
            if (i.pan.mag()) {
              const d = eo(i.pan.mag(), l, o.e({}, eu, e || {})),
                g = i.pan.mult(d.amount / i.pan.mag()),
                b = this._map.cameraHelper.handlePanInertia(g, this._map.transform);
              u.center = b.easingCenter, u.offset = b.easingOffset, Ma(u, d)
            }
            if (i.zoom) {
              const d = eo(i.zoom, l, sd);
              u.zoom = this._map.transform.zoom + d.amount, Ma(u, d)
            }
            if (i.bearing) {
              const d = eo(i.bearing, l, od);
              u.bearing = this._map.transform.bearing + o.ah(d.amount, -179, 179), Ma(u, d)
            }
            if (i.pitch) {
              const d = eo(i.pitch, l, ld);
              u.pitch = this._map.transform.pitch + d.amount, Ma(u, d)
            }
            if (i.roll) {
              const d = eo(i.roll, l, cd);
              u.roll = this._map.transform.roll + o.ah(d.amount, -179, 179), Ma(u, d)
            }
            if (u.zoom || u.bearing) {
              const d = i.pinchAround === void 0 ? i.around : i.pinchAround;
              u.around = d ? this._map.unproject(d) : this._map.getCenter()
            }
            return this.clear(), o.e(u, {
              noMoveStart: !0
            })
          }
        }

        function Ma(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing)
        }

        function eo(h, e, i) {
          const {
            maxSpeed: l,
            linearity: u,
            deceleration: d
          } = i, g = o.ah(h * u / (e / 1e3), -l, l), b = Math.abs(g) / (d * u);
          return {
            easing: i.easing,
            duration: 1e3 * b,
            amount: g * (b / 2)
          }
        }
        class ea extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l, u = {}) {
            l = l instanceof MouseEvent ? l : new MouseEvent(e, l);
            const d = X.mousePos(i.getCanvas(), l),
              g = i.unproject(d);
            super(e, o.e({
              point: d,
              lngLat: g,
              originalEvent: l
            }, u)), this._defaultPrevented = !1, this.target = i
          }
        }
        class to extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            const u = e === "touchend" ? l.changedTouches : l.touches,
              d = X.touchPos(i.getCanvasContainer(), u),
              g = d.map((S => i.unproject(S))),
              b = d.reduce(((S, P, A, R) => S.add(P.div(R.length))), new o.P(0, 0));
            super(e, {
              points: d,
              point: b,
              lngLats: g,
              lngLat: i.unproject(b),
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class tu extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            super(e, {
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class hd {
          constructor(e, i) {
            this._map = e, this._clickTolerance = i.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new tu(e.type, this._map, e))
          }
          mousedown(e, i) {
            return this._mousedownPos = i, this._firePreventable(new ea(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new ea(e.type, this._map, e))
          }
          click(e, i) {
            this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new ea(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new ea(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new ea(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new ea(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new to(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new to(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new to(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new to(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class dd {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new ea(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ea("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new ea(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class ro {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(o.P.convert(e), this._map.terrain)
          }
        }
        class ru {
          constructor(e, i) {
            this._map = e, this._tr = new ro(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = i.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, i) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (X.disableDrag(), this._startPos = this._lastPos = i, this._active = !0)
          }
          mousemoveWindow(e, i) {
            if (!this._active) return;
            const l = i;
            if (this._lastPos.equals(l) || !this._box && l.dist(this._startPos) < this._clickTolerance) return;
            const u = this._startPos;
            this._lastPos = l, this._box || (this._box = X.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const d = Math.min(u.x, l.x),
              g = Math.max(u.x, l.x),
              b = Math.min(u.y, l.y),
              S = Math.max(u.y, l.y);
            X.setTransform(this._box, `translate(${d}px,${b}px)`), this._box.style.width = g - d + "px", this._box.style.height = S - b + "px"
          }
          mouseupWindow(e, i) {
            if (!this._active || e.button !== 0) return;
            const l = this._startPos,
              u = i;
            if (this.reset(), X.suppressClick(), l.x !== u.x || l.y !== u.y) return this._map.fire(new o.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: d => d.fitScreenCoordinates(l, u, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (X.remove(this._box), this._box = null), X.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, i) {
            return this._map.fire(new o.l(e, {
              originalEvent: i
            }))
          }
        }

        function no(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const i = {};
          for (let l = 0; l < h.length; l++) i[h[l].identifier] = e[l];
          return i
        }
        class pd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, i, l) {
            (this.centroid || l.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), l.length === this.numTouches && (this.centroid = (function(u) {
              const d = new o.P(0, 0);
              for (const g of u) d._add(g);
              return d.div(u.length)
            })(i), this.touches = no(l, i)))
          }
          touchmove(e, i, l) {
            if (this.aborted || !this.centroid) return;
            const u = no(l, i);
            for (const d in this.touches) {
              const g = u[d];
              (!g || g.dist(this.touches[d]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, i, l) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), l.length === 0) {
              const u = !this.aborted && this.centroid;
              if (this.reset(), u) return u
            }
          }
        }
        class ta {
          constructor(e) {
            this.singleTap = new pd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, i, l) {
            this.singleTap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this.singleTap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this.singleTap.touchend(e, i, l);
            if (u) {
              const d = e.timeStamp - this.lastTime < 500,
                g = !this.lastTap || this.lastTap.dist(u) < 30;
              if (d && g || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = u, this.count === this.numTaps) return this.reset(), u
            }
          }
        }
        class Aa {
          constructor(e) {
            this._tr = new ro(e), this._zoomIn = new ta({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new ta({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, i, l) {
            this._zoomIn.touchstart(e, i, l), this._zoomOut.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this._zoomIn.touchmove(e, i, l), this._zoomOut.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this._zoomIn.touchend(e, i, l),
              d = this._zoomOut.touchend(e, i, l),
              g = this._tr;
            return u ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: b => b.easeTo({
                duration: 300,
                zoom: g.zoom + 1,
                around: g.unproject(u)
              }, {
                originalEvent: e
              })
            }) : d ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: b => b.easeTo({
                duration: 300,
                zoom: g.zoom - 1,
                around: g.unproject(d)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class io {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const i = this._moveFunction(...e);
            if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta) return this._active = !0, i
          }
          dragStart(e, i) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(i) ? i[0] : i, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, i) {
            if (!this.isEnabled()) return;
            const l = this._lastPoint;
            if (!l) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const u = Array.isArray(i) ? i[0] : i;
            return !this._moved && u.dist(l) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = u, this._move(l, u))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && X.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const ka = 0,
          ao = 2,
          Fp = {
            [ka]: 1,
            [ao]: 2
          };
        class Go {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const i = X.mouseButton(e);
            this._eventButton = i
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(i, l) {
              const u = Fp[l];
              return i.buttons === void 0 || (i.buttons & u) !== u
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return X.mouseButton(e) === this._eventButton
          }
        }
        class Op {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class Np {
          constructor(e = new Go({
            checkCorrectEvent: () => !0
          }), i = new Op) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = i
          }
          _executeRelevantHandler(e, i, l) {
            return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? l(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.startMove(i)), (i => this.oneFingerTouchMoveStateManager.startMove(i)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.endMove(i)), (i => this.oneFingerTouchMoveStateManager.endMove(i)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidStartEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidStartEvent(i)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidMoveEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidEndEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidEndEvent(i)))
          }
        }
        const Ho = h => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = e => {
            e.preventDefault()
          }
        };
        class Wo {
          constructor(e, i) {
            this._clickTolerance = e.clickTolerance || 1, this._map = i, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new o.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, i, l) {
            return this._calculateTransform(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._active) {
              if (!this._shouldBePrevented(l.length)) return e.preventDefault(), this._calculateTransform(e, i, l);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, i, l) {
            this._calculateTransform(e, i, l), this._active && this._shouldBePrevented(l.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, i, l) {
            l.length > 0 && (this._active = !0);
            const u = no(l, i),
              d = new o.P(0, 0),
              g = new o.P(0, 0);
            let b = 0;
            for (const P in u) {
              const A = u[P],
                R = this._touches[P];
              R && (d._add(A), g._add(A.sub(R)), b++, u[P] = A)
            }
            if (this._touches = u, this._shouldBePrevented(b) || !g.mag()) return;
            const S = g.div(b);
            return this._sum._add(S), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: d.div(b),
              panDelta: S
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Ea {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, i, l) {
            this._firstTwoTouches || l.length < 2 || (this._firstTwoTouches = [l[0].identifier, l[1].identifier], this._start([i[0], i[1]]))
          }
          touchmove(e, i, l) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [u, d] = this._firstTwoTouches, g = Qt(l, i, u), b = Qt(l, i, d);
            if (!g || !b) return;
            const S = this._aroundCenter ? null : g.add(b).div(2);
            return this._move([g, b], S, e)
          }
          touchend(e, i, l) {
            if (!this._firstTwoTouches) return;
            const [u, d] = this._firstTwoTouches, g = Qt(l, i, u), b = Qt(l, i, d);
            g && b || (this._active && X.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Qt(h, e, i) {
          for (let l = 0; l < h.length; l++)
            if (h[l].identifier === i) return e[l]
        }

        function nu(h, e) {
          return Math.log(h / e) / Math.LN2
        }
        class Bl extends Ea {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, i) {
            const l = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(nu(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: nu(this._distance, l),
              pinchAround: i
            }
          }
        }

        function iu(h, e) {
          return 180 * h.angleWith(e) / Math.PI
        }
        class so extends Ea {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, i, l) {
            const u = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: iu(this._vector, u),
              pinchAround: i
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const i = 25 / (Math.PI * this._minDiameter) * 360,
              l = iu(e, this._startVector);
            return Math.abs(l) < i
          }
        }

        function Fs(h) {
          return Math.abs(h.y) > Math.abs(h.x)
        }
        class Fl extends Ea {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, i, l) {
            super.touchstart(e, i, l), this._currentTouchCount = l.length
          }
          _start(e) {
            this._lastPoints = e, Fs(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, i, l) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const u = e[0].sub(this._lastPoints[0]),
              d = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(u, d, l.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (u.y + d.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, i, l) {
            if (this._valid !== void 0) return this._valid;
            const u = e.mag() >= 2,
              d = i.mag() >= 2;
            if (!u && !d) return;
            if (!u || !d) return this._firstMove === void 0 && (this._firstMove = l), l - this._firstMove < 100 && void 0;
            const g = e.y > 0 == i.y > 0;
            return Fs(e) && Fs(i) && g
          }
        }
        const un = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class Ol {
          constructor(e) {
            this._tr = new ro(e);
            const i = un;
            this._panStep = i.panStep, this._bearingStep = i.bearingStep, this._pitchStep = i.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let i = 0,
              l = 0,
              u = 0,
              d = 0,
              g = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                i = 1;
                break;
              case 189:
              case 109:
              case 173:
                i = -1;
                break;
              case 37:
                e.shiftKey ? l = -1 : (e.preventDefault(), d = -1);
                break;
              case 39:
                e.shiftKey ? l = 1 : (e.preventDefault(), d = 1);
                break;
              case 38:
                e.shiftKey ? u = 1 : (e.preventDefault(), g = -1);
                break;
              case 40:
                e.shiftKey ? u = -1 : (e.preventDefault(), g = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (l = 0, u = 0), {
              cameraAnimation: b => {
                const S = this._tr;
                b.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: jp,
                  zoom: i ? Math.round(S.zoom) + i * (e.shiftKey ? 2 : 1) : S.zoom,
                  bearing: S.bearing + l * this._bearingStep,
                  pitch: S.pitch + u * this._pitchStep,
                  offset: [-d * this._panStep, -g * this._panStep],
                  center: S.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function jp(h) {
          return h * (2 - h)
        }
        const Nl = 4.000244140625,
          Vp = 1 / 450;
        class fd {
          constructor(e, i) {
            this._onTimeout = l => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(l)
            }, this._map = e, this._tr = new ro(e), this._triggerRenderFrame = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Vp
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const l = se.now(),
              u = l - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = l, i !== 0 && i % Nl == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(u * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i = X.mousePos(this._map.getCanvas(), e),
              l = this._tr;
            this._aroundPoint = this._aroundCenter ? l.transform.locationToScreenPoint(o.S.convert(l.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const b = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += b), typeof this._targetZoom == "number" && (this._targetZoom += b)
            }
            if (this._delta !== 0) {
              const b = this._type === "wheel" && Math.abs(this._delta) > Nl ? this._wheelZoomRate : this._defaultZoomRate;
              let S = 2 / (1 + Math.exp(-Math.abs(this._delta * b)));
              this._delta < 0 && S !== 0 && (S = 1 / S);
              const P = typeof this._targetZoom != "number" ? e.scale : o.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), o.ak(P * S)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              l = this._startZoom,
              u = this._easing;
            let d, g = !1;
            if (this._type === "wheel" && l && u) {
              const b = se.now() - this._lastWheelEventTime,
                S = Math.min((b + 5) / 200, 1),
                P = u(S);
              d = o.C.number(l, i, P), S < 1 ? this._frameId || (this._frameId = !0) : g = !0
            } else d = i, g = !0;
            return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = d, {
              noInertia: !0,
              needsRenderFrame: !g,
              zoomDelta: d - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let i = o.co;
            if (this._prevEase) {
              const l = this._prevEase,
                u = (se.now() - l.start) / l.duration,
                d = l.easing(u + .01) - l.easing(u),
                g = .27 / Math.sqrt(d * d + 1e-4) * .01,
                b = Math.sqrt(.0729 - g * g);
              i = o.cm(g, b, .25, 1)
            }
            return this._prevEase = {
              start: se.now(),
              duration: e,
              easing: i
            }, i
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class au {
          constructor(e, i) {
            this._clickZoom = e, this._tapZoom = i
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class su {
          constructor(e) {
            this._tr = new ro(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, i) {
            return e.preventDefault(), {
              cameraAnimation: l => {
                l.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(i)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class md {
          constructor() {
            this._tap = new ta({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, i, l) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const u = i[0],
                  d = e.timeStamp - this._tapTime < 500,
                  g = this._tapPoint.dist(u) < 30;
                d && g ? l.length > 0 && (this._swipePoint = u, this._swipeTouch = l[0].identifier) : this.reset()
              } else this._tap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (l[0].identifier !== this._swipeTouch) return;
                const u = i[0],
                  d = u.y - this._swipePoint.y;
                return this._swipePoint = u, e.preventDefault(), this._active = !0, {
                  zoomDelta: d / 128
                }
              }
            } else this._tap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            if (this._tapTime) this._swipePoint && l.length === 0 && this.reset();
            else {
              const u = this._tap.touchend(e, i, l);
              u && (this._tapTime = e.timeStamp, this._tapPoint = u)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class _d {
          constructor(e, i, l) {
            this._el = e, this._mousePan = i, this._touchPan = l
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class ou {
          constructor(e, i, l, u) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = i, this._mousePitch = l, this._mouseRoll = u
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class gd {
          constructor(e, i, l, u) {
            this._el = e, this._touchZoom = i, this._touchRotate = l, this._tapDragZoom = u, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class vd {
          constructor(e, i) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = i, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = X.create("div", "maplibregl-cooperative-gesture-screen", e);
            let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const l = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              u = document.createElement("div");
            u.className = "maplibregl-desktop-message", u.textContent = i, this._container.appendChild(u);
            const d = document.createElement("div");
            d.className = "maplibregl-mobile-message", d.textContent = l, this._container.appendChild(d), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (X.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, i) {
            this._enabled && (this._map.fire(new o.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: i
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const za = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class $n extends o.l {}

        function oo(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
        }
        class lu {
          constructor(e, i) {
            this.handleWindowEvent = u => {
              this.handleEvent(u, `${u.type}Window`)
            }, this.handleEvent = (u, d) => {
              if (u.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const g = u.type === "renderFrame" ? void 0 : u,
                b = {
                  needsRenderFrame: !1
                },
                S = {},
                P = {};
              for (const {
                  handlerName: D,
                  handler: O,
                  allowed: $
                }
                of this._handlers) {
                if (!O.isEnabled()) continue;
                let te;
                if (this._blockedByActive(P, $, D)) O.reset();
                else if (O[d || u.type]) {
                  if (o.cp(u, d || u.type)) {
                    const ee = X.mousePos(this._map.getCanvas(), u);
                    te = O[d || u.type](u, ee)
                  } else if (o.cq(u, d || u.type)) {
                    const ee = this._getMapTouches(u.touches),
                      ne = X.touchPos(this._map.getCanvas(), ee);
                    te = O[d || u.type](u, ne, ee)
                  } else o.cr(d || u.type) || (te = O[d || u.type](u));
                  this.mergeHandlerResult(b, S, te, D, g), te && te.needsRenderFrame && this._triggerRenderFrame()
                }(te || O.isActive()) && (P[D] = O)
              }
              const A = {};
              for (const D in this._previousActiveHandlers) P[D] || (A[D] = g);
              this._previousActiveHandlers = P, (Object.keys(A).length || oo(b)) && (this._changes.push([b, S, A]), this._triggerRenderFrame()), (Object.keys(P).length || oo(b)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: R
              } = b;
              R && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], R(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ud(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i);
            const l = this._el;
            this._listeners = [
              [l, "touchstart", {
                passive: !0
              }],
              [l, "touchmove", {
                passive: !1
              }],
              [l, "touchend", void 0],
              [l, "touchcancel", void 0],
              [l, "mousedown", void 0],
              [l, "mousemove", void 0],
              [l, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [l, "mouseover", void 0],
              [l, "mouseout", void 0],
              [l, "dblclick", void 0],
              [l, "click", void 0],
              [l, "keydown", {
                capture: !1
              }],
              [l, "keyup", void 0],
              [l, "wheel", {
                passive: !1
              }],
              [l, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [u, d, g] of this._listeners) X.addEventListener(u, d, u === document ? this.handleWindowEvent : this.handleEvent, g)
          }
          destroy() {
            for (const [e, i, l] of this._listeners) X.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, l)
          }
          _addDefaultHandlers(e) {
            const i = this._map,
              l = i.getCanvasContainer();
            this._add("mapEvent", new hd(i, e));
            const u = i.boxZoom = new ru(i, e);
            this._add("boxZoom", u), e.interactive && e.boxZoom && u.enable();
            const d = i.cooperativeGestures = new vd(i, e.cooperativeGestures);
            this._add("cooperativeGestures", d), e.cooperativeGestures && d.enable();
            const g = new Aa(i),
              b = new su(i);
            i.doubleClickZoom = new au(b, g), this._add("tapZoom", g), this._add("clickZoom", b), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable();
            const S = new md;
            this._add("tapDragZoom", S);
            const P = i.touchPitch = new Fl(i);
            this._add("touchPitch", P), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch);
            const A = () => i.project(i.getCenter()),
              R = (function({
                enable: de,
                clickTolerance: be,
                aroundCenter: Ce = !0,
                minPixelCenterThreshold: pe = 100,
                rotateDegreesPerPixelMoved: Be = .8
              }, et) {
                const Ze = new Go({
                  checkCorrectEvent: Ge => X.mouseButton(Ge) === 0 && Ge.ctrlKey || X.mouseButton(Ge) === 2 && !Ge.ctrlKey
                });
                return new io({
                  clickTolerance: be,
                  move: (Ge, Ke) => {
                    const Rt = et();
                    if (Ce && Math.abs(Rt.y - Ge.y) > pe) return {
                      bearingDelta: o.cn(new o.P(Ge.x, Ke.y), Ke, Rt)
                    };
                    let Ft = (Ke.x - Ge.x) * Be;
                    return Ce && Ke.y < Rt.y && (Ft = -Ft), {
                      bearingDelta: Ft
                    }
                  },
                  moveStateManager: Ze,
                  enable: de,
                  assignEvents: Ho
                })
              })(e, A),
              D = (function({
                enable: de,
                clickTolerance: be,
                pitchDegreesPerPixelMoved: Ce = -.5
              }) {
                const pe = new Go({
                  checkCorrectEvent: Be => X.mouseButton(Be) === 0 && Be.ctrlKey || X.mouseButton(Be) === 2
                });
                return new io({
                  clickTolerance: be,
                  move: (Be, et) => ({
                    pitchDelta: (et.y - Be.y) * Ce
                  }),
                  moveStateManager: pe,
                  enable: de,
                  assignEvents: Ho
                })
              })(e),
              O = (function({
                enable: de,
                clickTolerance: be,
                rollDegreesPerPixelMoved: Ce = .3
              }, pe) {
                const Be = new Go({
                  checkCorrectEvent: et => X.mouseButton(et) === 2 && et.ctrlKey
                });
                return new io({
                  clickTolerance: be,
                  move: (et, Ze) => {
                    const Ge = pe();
                    let Ke = (Ze.x - et.x) * Ce;
                    return Ze.y < Ge.y && (Ke = -Ke), {
                      rollDelta: Ke
                    }
                  },
                  moveStateManager: Be,
                  enable: de,
                  assignEvents: Ho
                })
              })(e, A);
            i.dragRotate = new ou(e, R, D, O), this._add("mouseRotate", R, ["mousePitch"]), this._add("mousePitch", D, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", O, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable();
            const $ = (function({
                enable: de,
                clickTolerance: be
              }) {
                const Ce = new Go({
                  checkCorrectEvent: pe => X.mouseButton(pe) === 0 && !pe.ctrlKey
                });
                return new io({
                  clickTolerance: be,
                  move: (pe, Be) => ({
                    around: Be,
                    panDelta: Be.sub(pe)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Ce,
                  enable: de,
                  assignEvents: Ho
                })
              })(e),
              te = new Wo(e, i);
            i.dragPan = new _d(l, $, te), this._add("mousePan", $), this._add("touchPan", te, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
            const ee = new so,
              ne = new Bl;
            i.touchZoomRotate = new gd(l, ne, ee, S), this._add("touchRotate", ee, ["touchPan", "touchZoom"]), this._add("touchZoom", ne, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate);
            const le = i.scrollZoom = new fd(i, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", le, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom);
            const fe = i.keyboard = new Ol(i);
            this._add("keyboard", fe), e.interactive && e.keyboard && i.keyboard.enable(), this._add("blockableMapEvent", new dd(i))
          }
          _add(e, i, l) {
            this._handlers.push({
              handlerName: e,
              handler: i,
              allowed: l
            }), this._handlersById[e] = i
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: i
                }
                of this._handlers) i.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!za(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, i, l) {
            for (const u in e)
              if (u !== l && (!i || i.indexOf(u) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const i = [];
            for (const l of e) this._el.contains(l.target) && i.push(l);
            return i
          }
          mergeHandlerResult(e, i, l, u, d) {
            if (!l) return;
            o.e(e, l);
            const g = {
              handlerName: u,
              originalEvent: l.originalEvent || d
            };
            l.zoomDelta !== void 0 && (i.zoom = g), l.panDelta !== void 0 && (i.drag = g), l.rollDelta !== void 0 && (i.roll = g), l.pitchDelta !== void 0 && (i.pitch = g), l.bearingDelta !== void 0 && (i.rotate = g)
          }
          _applyChanges() {
            const e = {},
              i = {},
              l = {};
            for (const [u, d, g] of this._changes) u.panDelta && (e.panDelta = (e.panDelta || new o.P(0, 0))._add(u.panDelta)), u.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta), u.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + u.bearingDelta), u.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta), u.rollDelta && (e.rollDelta = (e.rollDelta || 0) + u.rollDelta), u.around !== void 0 && (e.around = u.around), u.pinchAround !== void 0 && (e.pinchAround = u.pinchAround), u.noInertia && (e.noInertia = u.noInertia), o.e(i, d), o.e(l, g);
            this._updateMapTransform(e, i, l), this._changes = []
          }
          _updateMapTransform(e, i, l) {
            const u = this._map,
              d = u._getTransformForUpdate(),
              g = u.terrain;
            if (!(oo(e) || g && this._terrainMovement)) return this._fireEvents(i, l, !0);
            u._stop(!0);
            let {
              panDelta: b,
              zoomDelta: S,
              bearingDelta: P,
              pitchDelta: A,
              rollDelta: R,
              around: D,
              pinchAround: O
            } = e;
            O !== void 0 && (D = O), D = D || u.transform.centerPoint, g && !d.isPointOnMapSurface(D) && (D = d.centerPoint);
            const $ = {
              panDelta: b,
              zoomDelta: S,
              rollDelta: R,
              pitchDelta: A,
              bearingDelta: P,
              around: D
            };
            this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(D) && (D = d.centerPoint);
            const te = D.distSqr(d.centerPoint) < .01 ? d.center : d.screenPointToLocation(b ? D.sub(b) : D);
            g ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom($, d), this._terrainMovement || !i.drag && !i.zoom ? i.drag && this._terrainMovement ? d.setCenter(d.screenPointToLocation(d.centerPoint.sub(b))) : this._map.cameraHelper.handleMapControlsPan($, d, te) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan($, d, te))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom($, d), this._map.cameraHelper.handleMapControlsPan($, d, te)), u._applyUpdatedTransform(d), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(i, l, !0)
          }
          _fireEvents(e, i, l) {
            const u = za(this._eventsInProgress),
              d = za(e),
              g = {};
            for (const R in e) {
              const {
                originalEvent: D
              } = e[R];
              this._eventsInProgress[R] || (g[`${R}start`] = D), this._eventsInProgress[R] = e[R]
            }!u && d && this._fireEvent("movestart", d.originalEvent);
            for (const R in g) this._fireEvent(R, g[R]);
            d && this._fireEvent("move", d.originalEvent);
            for (const R in e) {
              const {
                originalEvent: D
              } = e[R];
              this._fireEvent(R, D)
            }
            const b = {};
            let S;
            for (const R in this._eventsInProgress) {
              const {
                handlerName: D,
                originalEvent: O
              } = this._eventsInProgress[R];
              this._handlersById[D].isActive() || (delete this._eventsInProgress[R], S = i[D] || O, b[`${R}end`] = S)
            }
            for (const R in b) this._fireEvent(R, b[R]);
            const P = za(this._eventsInProgress),
              A = (u || d) && !P;
            if (A && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const R = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && R.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(R)
            }
            if (l && A) {
              this._updatingCamera = !0;
              const R = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                D = O => O !== 0 && -this._bearingSnap < O && O < this._bearingSnap;
              !R || !R.essential && se.prefersReducedMotion ? (this._map.fire(new o.l("moveend", {
                originalEvent: S
              })), D(this._map.getBearing()) && this._map.resetNorth()) : (D(R.bearing || this._map.getBearing()) && (R.bearing = 0), R.freezeElevation = !0, this._map.easeTo(R, {
                originalEvent: S
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, i) {
            this._map.fire(new o.l(e, i ? {
              originalEvent: i
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new $n("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class yd extends o.E {
          constructor(e, i, l) {
            super(), this._renderFrameCallback = () => {
              const u = Math.min((se.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(u)), u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = l.bearingSnap, this.cameraHelper = i, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, i) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = i
          }
          getCenter() {
            return new o.S(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, i) {
            return this.jumpTo({
              center: e
            }, i)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, i) {
            return this.jumpTo({
              elevation: e
            }, i), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, i, l) {
            return e = o.P.convert(e).mult(-1), this.panTo(this.transform.center, o.e({
              offset: e
            }, i), l)
          }
          panTo(e, i, l) {
            return this.easeTo(o.e({
              center: e
            }, i), l)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, i) {
            return this.jumpTo({
              zoom: e
            }, i), this
          }
          zoomTo(e, i, l) {
            return this.easeTo(o.e({
              zoom: e
            }, i), l)
          }
          zoomIn(e, i) {
            return this.zoomTo(this.getZoom() + 1, e, i), this
          }
          zoomOut(e, i) {
            return this.zoomTo(this.getZoom() - 1, e, i), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, i) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new o.l("movestart", i)).fire(new o.l("move", i)).fire(new o.l("moveend", i))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, i) {
            return this.jumpTo({
              bearing: e
            }, i), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, i) {
            return this.jumpTo({
              padding: e
            }, i), this
          }
          rotateTo(e, i, l) {
            return this.easeTo(o.e({
              bearing: e
            }, i), l)
          }
          resetNorth(e, i) {
            return this.rotateTo(0, o.e({
              duration: 1e3
            }, e), i), this
          }
          resetNorthPitch(e, i) {
            return this.easeTo(o.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), i), this
          }
          snapToNorth(e, i) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, i) {
            return this.jumpTo({
              pitch: e
            }, i), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, i) {
            return this.jumpTo({
              roll: e
            }, i), this
          }
          cameraForBounds(e, i) {
            e = pt.convert(e).adjustAntiMeridian();
            const l = i && i.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), l, i)
          }
          _cameraForBoxAndBearing(e, i, l, u) {
            const d = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(u = o.e({
                padding: d,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, u)).padding == "number") {
              const P = u.padding;
              u.padding = {
                top: P,
                bottom: P,
                right: P,
                left: P
              }
            }
            const g = o.e(d, u.padding);
            u.padding = g;
            const b = this.transform,
              S = new pt(e, i);
            return this.cameraHelper.cameraForBoxAndBearing(u, g, S, l, b)
          }
          fitBounds(e, i, l) {
            return this._fitInternal(this.cameraForBounds(e, i), i, l)
          }
          fitScreenCoordinates(e, i, l, u, d) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(e)), this.transform.screenPointToLocation(o.P.convert(i)), l, u), u, d)
          }
          _fitInternal(e, i, l) {
            return e ? (delete(i = o.e(e, i)).padding, i.linear ? this.easeTo(i, l) : this.flyTo(i, l)) : this
          }
          jumpTo(e, i) {
            this.stop();
            const l = this._getTransformForUpdate();
            let u = !1,
              d = !1,
              g = !1;
            const b = l.zoom;
            this.cameraHelper.handleJumpToCenterZoom(l, e);
            const S = l.zoom !== b;
            return "elevation" in e && l.elevation !== +e.elevation && l.setElevation(+e.elevation), "bearing" in e && l.bearing !== +e.bearing && (u = !0, l.setBearing(+e.bearing)), "pitch" in e && l.pitch !== +e.pitch && (d = !0, l.setPitch(+e.pitch)), "roll" in e && l.roll !== +e.roll && (g = !0, l.setRoll(+e.roll)), e.padding == null || l.isPaddingEqual(e.padding) || l.setPadding(e.padding), this._applyUpdatedTransform(l), this.fire(new o.l("movestart", i)).fire(new o.l("move", i)), S && this.fire(new o.l("zoomstart", i)).fire(new o.l("zoom", i)).fire(new o.l("zoomend", i)), u && this.fire(new o.l("rotatestart", i)).fire(new o.l("rotate", i)).fire(new o.l("rotateend", i)), d && this.fire(new o.l("pitchstart", i)).fire(new o.l("pitch", i)).fire(new o.l("pitchend", i)), g && this.fire(new o.l("rollstart", i)).fire(new o.l("roll", i)).fire(new o.l("rollend", i)), this.fire(new o.l("moveend", i))
          }
          calculateCameraOptionsFromTo(e, i, l, u = 0) {
            const d = o.a1.fromLngLat(e, i),
              g = o.a1.fromLngLat(l, u),
              b = g.x - d.x,
              S = g.y - d.y,
              P = g.z - d.z,
              A = Math.hypot(b, S, P);
            if (A === 0) throw new Error("Can't calculate camera options with same From and To");
            const R = Math.hypot(b, S),
              D = o.ak(this.transform.cameraToCenterDistance / A / this.transform.tileSize),
              O = 180 * Math.atan2(b, -S) / Math.PI;
            let $ = 180 * Math.acos(R / A) / Math.PI;
            return $ = P < 0 ? 90 - $ : 90 + $, {
              center: g.toLngLat(),
              elevation: u,
              zoom: D,
              pitch: $,
              bearing: O
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, i, l, u, d) {
            const g = this.transform.calculateCenterFromCameraLngLatAlt(e, i, l, u);
            return {
              center: g.center,
              elevation: g.elevation,
              zoom: g.zoom,
              bearing: l,
              pitch: u,
              roll: d
            }
          }
          easeTo(e, i) {
            this._stop(!1, e.easeId), ((e = o.e({
              offset: [0, 0],
              duration: 500,
              easing: o.co
            }, e)).animate === !1 || !e.essential && se.prefersReducedMotion) && (e.duration = 0);
            const l = this._getTransformForUpdate(),
              u = this.getBearing(),
              d = l.pitch,
              g = l.roll,
              b = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              S = "pitch" in e ? +e.pitch : d,
              P = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              A = "padding" in e ? e.padding : l.padding,
              R = o.P.convert(e.offset);
            let D, O;
            e.around && (D = o.S.convert(e.around), O = l.locationToScreenPoint(D));
            const $ = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              te = this.cameraHelper.handleEaseTo(l, {
                bearing: b,
                pitch: S,
                roll: P,
                padding: A,
                around: D,
                aroundPoint: O,
                offsetAsPoint: R,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || u !== b, this._pitching = this._pitching || S !== d, this._rolling = this._rolling || P !== g, this._padding = !l.isPaddingEqual(A), this._zooming = this._zooming || te.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, $), this.terrain && this._prepareElevation(te.elevationCenter), this._ease((ee => {
              te.easeFunc(ee), this.terrain && !e.freezeElevation && this._updateElevation(ee), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (ee => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, ee)
            }), e), this
          }
          _prepareEase(e, i, l = {}) {
            this._moving = !0, i || l.moving || this.fire(new o.l("movestart", e)), this._zooming && !l.zooming && this.fire(new o.l("zoomstart", e)), this._rotating && !l.rotating && this.fire(new o.l("rotatestart", e)), this._pitching && !l.pitching && this.fire(new o.l("pitchstart", e)), this._rolling && !l.rolling && this.fire(new o.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && i !== this._elevationTarget) {
              const l = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (l - (i - (l * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i
            }
            this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const i = e.getCameraLngLat(),
              l = e.getCameraAltitude(),
              u = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0;
            if (l < u) {
              const d = this.calculateCameraOptionsFromTo(i, u, e.center, e.elevation);
              return {
                pitch: d.pitch,
                zoom: d.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const i = [];
            if (i.push((u => this._elevateCameraIfInsideTerrain(u))), this.transformCameraUpdate && i.push((u => this.transformCameraUpdate(u))), !i.length) return;
            const l = e.clone();
            for (const u of i) {
              const d = l.clone(),
                {
                  center: g,
                  zoom: b,
                  roll: S,
                  pitch: P,
                  bearing: A,
                  elevation: R
                } = u(d);
              g && d.setCenter(g), R !== void 0 && d.setElevation(R), b !== void 0 && d.setZoom(b), S !== void 0 && d.setRoll(S), P !== void 0 && d.setPitch(P), A !== void 0 && d.setBearing(A), l.apply(d)
            }
            this.transform.apply(l)
          }
          _fireMoveEvents(e) {
            this.fire(new o.l("move", e)), this._zooming && this.fire(new o.l("zoom", e)), this._rotating && this.fire(new o.l("rotate", e)), this._pitching && this.fire(new o.l("pitch", e)), this._rolling && this.fire(new o.l("roll", e))
          }
          _afterEase(e, i) {
            if (this._easeId && i && this._easeId === i) return;
            delete this._easeId;
            const l = this._zooming,
              u = this._rotating,
              d = this._pitching,
              g = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, l && this.fire(new o.l("zoomend", e)), u && this.fire(new o.l("rotateend", e)), d && this.fire(new o.l("pitchend", e)), g && this.fire(new o.l("rollend", e)), this.fire(new o.l("moveend", e))
          }
          flyTo(e, i) {
            if (!e.essential && se.prefersReducedMotion) {
              const Ke = o.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Ke, i)
            }
            this.stop(), e = o.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: o.co
            }, e);
            const l = this._getTransformForUpdate(),
              u = l.bearing,
              d = l.pitch,
              g = l.roll,
              b = l.padding,
              S = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              P = "pitch" in e ? +e.pitch : d,
              A = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              R = "padding" in e ? e.padding : l.padding,
              D = o.P.convert(e.offset);
            let O = l.centerPoint.add(D);
            const $ = l.screenPointToLocation(O),
              te = this.cameraHelper.handleFlyTo(l, {
                bearing: S,
                pitch: P,
                roll: A,
                padding: R,
                locationAtOffset: $,
                offsetAsPoint: D,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let ee = e.curve;
            const ne = Math.max(l.width, l.height),
              le = ne / te.scaleOfZoom,
              fe = te.pixelPathLength;
            typeof te.scaleOfMinZoom == "number" && (ee = Math.sqrt(ne / te.scaleOfMinZoom / fe * 2));
            const de = ee * ee;

            function be(Ke) {
              const Rt = (le * le - ne * ne + (Ke ? -1 : 1) * de * de * fe * fe) / (2 * (Ke ? le : ne) * de * fe);
              return Math.log(Math.sqrt(Rt * Rt + 1) - Rt)
            }

            function Ce(Ke) {
              return (Math.exp(Ke) - Math.exp(-Ke)) / 2
            }

            function pe(Ke) {
              return (Math.exp(Ke) + Math.exp(-Ke)) / 2
            }
            const Be = be(!1);
            let et = function(Ke) {
                return pe(Be) / pe(Be + ee * Ke)
              },
              Ze = function(Ke) {
                return ne * ((pe(Be) * (Ce(Rt = Be + ee * Ke) / pe(Rt)) - Ce(Be)) / de) / fe;
                var Rt
              },
              Ge = (be(!0) - Be) / ee;
            if (Math.abs(fe) < 2e-6 || !isFinite(Ge)) {
              if (Math.abs(ne - le) < 1e-6) return this.easeTo(e, i);
              const Ke = le < ne ? -1 : 1;
              Ge = Math.abs(Math.log(le / ne)) / ee, Ze = () => 0, et = Rt => Math.exp(Ke * ee * Rt)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * Ge / ("screenSpeed" in e ? +e.screenSpeed / ee : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = u !== S, this._pitching = P !== d, this._rolling = A !== g, this._padding = !l.isPaddingEqual(R), this._prepareEase(i, !1), this.terrain && this._prepareElevation(te.targetCenter), this._ease((Ke => {
              const Rt = Ke * Ge,
                Ft = 1 / et(Rt),
                St = Ze(Rt);
              this._rotating && l.setBearing(o.C.number(u, S, Ke)), this._pitching && l.setPitch(o.C.number(d, P, Ke)), this._rolling && l.setRoll(o.C.number(g, A, Ke)), this._padding && (l.interpolatePadding(b, R, Ke), O = l.centerPoint.add(D)), te.easeFunc(Ke, Ft, St, O), this.terrain && !e.freezeElevation && this._updateElevation(Ke), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, i) {
            var l;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const u = this._onEaseEnd;
              delete this._onEaseEnd, u.call(this, i)
            }
            return e || (l = this.handlers) === null || l === void 0 || l.stop(!1), this
          }
          _ease(e, i, l) {
            l.animate === !1 || l.duration === 0 ? (e(1), i()) : (this._easeStart = se.now(), this._easeOptions = l, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, i) {
            e = o.aO(e, -180, 180);
            const l = Math.abs(e - i);
            return Math.abs(e - 360 - i) < l && (e -= 360), Math.abs(e + 360 - i) < l && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(e), this.transform.tileZoom) : null
          }
        }
        const cu = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class uu {
          constructor(e = cu) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = i => {
              !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = X.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = X.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = X.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            X.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, i) {
            const l = this._map._getUIString(`AttributionControl.${i}`);
            e.title = l, e.setAttribute("aria-label", l)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((u => typeof u != "string" ? "" : u))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const u = this._map.style.stylesheet;
              this.styleOwner = u.owner, this.styleId = u.id
            }
            const i = this._map.style.sourceCaches;
            for (const u in i) {
              const d = i[u];
              if (d.used || d.usedForTerrain) {
                const g = d.getSource();
                g.attribution && e.indexOf(g.attribution) < 0 && e.push(g.attribution)
              }
            }
            e = e.filter((u => String(u).trim())), e.sort(((u, d) => u.length - d.length)), e = e.filter(((u, d) => {
              for (let g = d + 1; g < e.length; g++)
                if (e[g].indexOf(u) >= 0) return !1;
              return !0
            }));
            const l = e.join(" | ");
            l !== this._attribHTML && (this._attribHTML = l, e.length ? (this._innerContainer.innerHTML = X.sanitize(l), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class xd {
          constructor(e = {}) {
            this._updateCompact = () => {
              const i = this._container.children;
              if (i.length) {
                const l = i[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && l.classList.add("maplibregl-compact") : l.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = X.create("div", "maplibregl-ctrl");
            const i = X.create("a", "maplibregl-ctrl-logo");
            return i.target = "_blank", i.rel = "noopener nofollow", i.href = "https://maplibre.org/", i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), i.setAttribute("rel", "noopener nofollow"), this._container.appendChild(i), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            X.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class $a {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const i = ++this._id;
            return this._queue.push({
              callback: e,
              id: i,
              cancelled: !1
            }), i
          }
          remove(e) {
            const i = this._currentlyRunning,
              l = i ? this._queue.concat(i) : this._queue;
            for (const u of l)
              if (u.id === e) return void(u.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const i = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const l of i)
              if (!l.cancelled && (l.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var jl = o.aJ([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class vr extends o.E {
          constructor(e) {
            super(), this._lastTilesetChange = se.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null
          }
          update(e, i) {
            this.sourceCache.update(e, i), this._renderableTilesKeys = [];
            const l = {};
            for (const u of xe(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: i,
                calculateTileZoom: this.sourceCache._source.calculateTileZoom
              })) l[u.key] = !0, this._renderableTilesKeys.push(u.key), this._tiles[u.key] || (u.terrainRttPosMatrix32f = new Float64Array(16), o.bY(u.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1), this._tiles[u.key] = new Ar(u, this.tileSize), this._lastTilesetChange = se.now());
            for (const u in this._tiles) l[u] || delete this._tiles[u]
          }
          freeRtt(e) {
            for (const i in this._tiles) {
              const l = this._tiles[i];
              (!e || l.tileID.equals(e) || l.tileID.isChildOf(e) || e.isChildOf(l.tileID)) && (l.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, i) {
            return i ? this._getTerrainCoordsForTileRanges(e, i) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const i = {};
            for (const l of this._renderableTilesKeys) {
              const u = this._tiles[l].tileID,
                d = e.clone(),
                g = o.ba();
              if (u.canonical.equals(e.canonical)) o.bY(g, 0, o.$, o.$, 0, 0, 1);
              else if (u.canonical.isChildOf(e.canonical)) {
                const b = u.canonical.z - e.canonical.z,
                  S = u.canonical.x - (u.canonical.x >> b << b),
                  P = u.canonical.y - (u.canonical.y >> b << b),
                  A = o.$ >> b;
                o.bY(g, 0, A, A, 0, 0, 1), o.M(g, g, [-S * A, -P * A, 0])
              } else {
                if (!e.canonical.isChildOf(u.canonical)) continue;
                {
                  const b = e.canonical.z - u.canonical.z,
                    S = e.canonical.x - (e.canonical.x >> b << b),
                    P = e.canonical.y - (e.canonical.y >> b << b),
                    A = o.$ >> b;
                  o.bY(g, 0, o.$, o.$, 0, 0, 1), o.M(g, g, [S * A, P * A, 0]), o.N(g, g, [1 / 2 ** b, 1 / 2 ** b, 0])
                }
              }
              d.terrainRttPosMatrix32f = new Float32Array(g), i[l] = d
            }
            return i
          }
          _getTerrainCoordsForTileRanges(e, i) {
            const l = {};
            for (const u of this._renderableTilesKeys) {
              const d = this._tiles[u].tileID;
              if (!this._isWithinTileRanges(d, i)) continue;
              const g = e.clone(),
                b = o.ba();
              if (d.canonical.z === e.canonical.z) {
                const S = e.canonical.x - d.canonical.x,
                  P = e.canonical.y - d.canonical.y;
                o.bY(b, 0, o.$, o.$, 0, 0, 1), o.M(b, b, [S * o.$, P * o.$, 0])
              } else if (d.canonical.z > e.canonical.z) {
                const S = d.canonical.z - e.canonical.z,
                  P = d.canonical.x - (d.canonical.x >> S << S),
                  A = d.canonical.y - (d.canonical.y >> S << S),
                  R = e.canonical.x - (d.canonical.x >> S),
                  D = e.canonical.y - (d.canonical.y >> S),
                  O = o.$ >> S;
                o.bY(b, 0, O, O, 0, 0, 1), o.M(b, b, [-P * O + R * o.$, -A * O + D * o.$, 0])
              } else {
                const S = e.canonical.z - d.canonical.z,
                  P = e.canonical.x - (e.canonical.x >> S << S),
                  A = e.canonical.y - (e.canonical.y >> S << S),
                  R = (e.canonical.x >> S) - d.canonical.x,
                  D = (e.canonical.y >> S) - d.canonical.y,
                  O = o.$ << S;
                o.bY(b, 0, O, O, 0, 0, 1), o.M(b, b, [P * o.$ + R * O, A * o.$ + D * O, 0])
              }
              g.terrainRttPosMatrix32f = new Float32Array(b), l[u] = g
            }
            return l
          }
          getSourceTile(e, i) {
            const l = this.sourceCache._source;
            let u = e.overscaledZ - this.deltaZoom;
            if (u > l.maxzoom && (u = l.maxzoom), u < l.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(u).key);
            let d = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!d || !d.dem) && i)
              for (; u >= l.minzoom && (!d || !d.dem);) d = this.sourceCache.getTileByID(e.scaledTo(u--).key);
            return d
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, i) {
            return i[e.canonical.z] && e.canonical.x >= i[e.canonical.z].minTileX && e.canonical.x <= i[e.canonical.z].maxTileX && e.canonical.y >= i[e.canonical.z].minTileY && e.canonical.y <= i[e.canonical.z].maxTileY
          }
        }
        class Or {
          constructor(e, i, l) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new vr(i), this.options = l, this.exaggeration = typeof l.exaggeration == "number" ? l.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, i, l, u = o.$) {
            var d;
            if (!(i >= 0 && i < u && l >= 0 && l < u)) return 0;
            const g = this.getTerrainData(e),
              b = (d = g.tile) === null || d === void 0 ? void 0 : d.dem;
            if (!b) return 0;
            const S = o.cs([], [i / u * o.$, l / u * o.$], g.u_terrain_matrix),
              P = [S[0] * b.dim, S[1] * b.dim],
              A = Math.floor(P[0]),
              R = Math.floor(P[1]),
              D = P[0] - A,
              O = P[1] - R;
            return b.get(A, R) * (1 - D) * (1 - O) + b.get(A + 1, R) * D * (1 - O) + b.get(A, R + 1) * (1 - D) * O + b.get(A + 1, R + 1) * D * O
          }
          getElevationForLngLatZoom(e, i) {
            if (!o.ct(i, e.wrap())) return 0;
            const {
              tileID: l,
              mercatorX: u,
              mercatorY: d
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return this.getElevation(l, u % o.$, d % o.$, o.$)
          }
          getElevation(e, i, l, u = o.$) {
            return this.getDEMElevation(e, i, l, u) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const u = this.painter.context,
                d = new o.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new o.T(u, d, u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new o.T(u, new o.R({
                width: 1,
                height: 1
              }), u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.ag([])
            }
            const i = this.sourceCache.getSourceTile(e, !0);
            if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
              const u = this.painter.context;
              i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), {
                premultiply: !1
              }) : i.demTexture = new o.T(u, i.dem.getPixels(), u.gl.RGBA, {
                premultiply: !1
              }), i.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1
            }
            const l = i && i + i.tileID.key + e.key;
            if (l && !this._demMatrixCache[l]) {
              const u = this.sourceCache.sourceCache._source.maxzoom;
              let d = e.canonical.z - i.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= u ? d = e.canonical.z - u : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const g = e.canonical.x - (e.canonical.x >> d << d),
                b = e.canonical.y - (e.canonical.y >> d << d),
                S = o.cu(new Float64Array(16), [1 / (o.$ << d), 1 / (o.$ << d), 0]);
              o.M(S, S, [g * o.$, b * o.$, 0]), this._demMatrixCache[e.key] = {
                matrix: S,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: i && i.dem && i.dem.dim || 1,
              u_terrain_matrix: l ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (i && i.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: i
            }
          }
          getFramebuffer(e) {
            const i = this.painter,
              l = i.width / devicePixelRatio,
              u = i.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === l && this._fbo.height === u || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new o.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i.context.createFramebuffer(l, u, !0, !1), this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, l, u))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let d = 0, g = 0; d < this._coordsTextureSize; d++)
              for (let b = 0; b < this._coordsTextureSize; b++, g += 4) i[g + 0] = 255 & b, i[g + 1] = 255 & d, i[g + 2] = b >> 8 << 4 | d >> 8, i[g + 3] = 0;
            const l = new o.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(i.buffer)),
              u = new o.T(e, l, e.gl.RGBA, {
                premultiply: !1
              });
            return u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = u, u
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl,
              d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              g = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              b = Math.round(this.painter.height / devicePixelRatio);
            l.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), u.readPixels(d, b - g - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null);
            const S = i[0] + (i[2] >> 4 << 8),
              P = i[1] + ((15 & i[2]) << 8),
              A = this.coordsIndex[255 - i[3]],
              R = A && this.sourceCache.getTileByID(A);
            if (!R) return null;
            const D = this._coordsTextureSize,
              O = (1 << R.tileID.canonical.z) * D;
            return new o.a1((R.tileID.canonical.x * D + S) / O + R.tileID.wrap, (R.tileID.canonical.y * D + P) / O, this.getElevation(R.tileID, S, P, D))
          }
          depthAtPoint(e) {
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl;
            return l.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), u.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null), (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
          }
          getTerrainMesh(e) {
            var i;
            const l = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0,
              u = l && e.canonical.y === 0,
              d = l && e.canonical.y === (1 << e.canonical.z) - 1,
              g = `m_${u?"n":""}_${d?"s":""}`;
            if (this._meshCache[g]) return this._meshCache[g];
            const b = this.painter.context,
              S = new o.cv,
              P = new o.aN,
              A = this.meshSize,
              R = o.$ / A,
              D = A * A;
            for (let pe = 0; pe <= A; pe++)
              for (let Be = 0; Be <= A; Be++) S.emplaceBack(Be * R, pe * R, 0);
            for (let pe = 0; pe < D; pe += A + 1)
              for (let Be = 0; Be < A; Be++) P.emplaceBack(Be + pe, A + Be + pe + 1, A + Be + pe + 2), P.emplaceBack(Be + pe, A + Be + pe + 2, Be + pe + 1);
            const O = S.length,
              $ = O + (A + 1),
              te = (A + 1) * A,
              ee = u ? o.bh : 0,
              ne = u ? 0 : 1,
              le = d ? o.bi : o.$,
              fe = d ? 0 : 1;
            for (let pe = 0; pe <= A; pe++) S.emplaceBack(pe * R, ee, ne);
            for (let pe = 0; pe <= A; pe++) S.emplaceBack(pe * R, le, fe);
            for (let pe = 0; pe < A; pe++) P.emplaceBack(te + pe, $ + pe, $ + pe + 1), P.emplaceBack(te + pe, $ + pe + 1, te + pe + 1), P.emplaceBack(0 + pe, O + pe + 1, O + pe), P.emplaceBack(0 + pe, 0 + pe + 1, O + pe + 1);
            const de = S.length,
              be = de + 2 * (A + 1);
            for (const pe of [0, 1])
              for (let Be = 0; Be <= A; Be++)
                for (const et of [0, 1]) S.emplaceBack(pe * o.$, Be * R, et);
            for (let pe = 0; pe < 2 * A; pe += 2) P.emplaceBack(de + pe, de + pe + 1, de + pe + 3), P.emplaceBack(de + pe, de + pe + 3, de + pe + 2), P.emplaceBack(be + pe, be + pe + 3, be + pe + 1), P.emplaceBack(be + pe, be + pe + 2, be + pe + 3);
            const Ce = new Tn(b.createVertexBuffer(S, jl.members), b.createIndexBuffer(P), o.aM.simpleSegment(0, 0, S.length, P.length));
            return this._meshCache[g] = Ce, Ce
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * o.bu / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, i) {
            var l;
            const {
              tileID: u
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return (l = this.getMinMaxElevation(u).minElevation) !== null && l !== void 0 ? l : 0
          }
          getMinMaxElevation(e) {
            const i = this.getTerrainData(e).tile,
              l = {
                minElevation: null,
                maxElevation: null
              };
            return i && i.dem && (l.minElevation = i.dem.min * this.exaggeration, l.maxElevation = i.dem.max * this.exaggeration), l
          }
          _getOverscaledTileIDFromLngLatZoom(e, i) {
            const l = o.a1.fromLngLat(e.wrap()),
              u = (1 << i) * o.$,
              d = l.x * u,
              g = l.y * u,
              b = Math.floor(d / o.$),
              S = Math.floor(g / o.$);
            return {
              tileID: new o.Z(i, 0, i, b, S),
              mercatorX: d,
              mercatorY: g
            }
          }
        }
        class Vl {
          constructor(e, i, l) {
            this._context = e, this._size = i, this._tileSize = l, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              l = new o.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return l.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i.colorAttachment.set(l.texture), {
              id: e,
              fbo: i,
              texture: l,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((i => e.id !== i)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const i of this._recentlyUsed)
              if (!this._objects[i].inUse) return this._objects[i];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const ms = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class ql {
          constructor(e, i) {
            this.painter = e, this.terrain = i, this.pool = new Vl(e.context, 30, i.sourceCache.tileSize * i.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, i) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((l => !e._layers[l].isHidden(i))), this._coordsAscending = {};
            for (const l in e.sourceCaches) {
              this._coordsAscending[l] = {};
              const u = e.sourceCaches[l].getVisibleCoordinates(),
                d = e.sourceCaches[l].getSource(),
                g = d instanceof It ? d.terrainTileRanges : null;
              for (const b of u) {
                const S = this.terrain.sourceCache.getTerrainCoords(b, g);
                for (const P in S) this._coordsAscending[l][P] || (this._coordsAscending[l][P] = []), this._coordsAscending[l][P].push(S[P])
              }
            }
            this._coordsAscendingStr = {};
            for (const l of e._order) {
              const u = e._layers[l],
                d = u.source;
              if (ms[u.type] && !this._coordsAscendingStr[d]) {
                this._coordsAscendingStr[d] = {};
                for (const g in this._coordsAscending[d]) this._coordsAscendingStr[d][g] = this._coordsAscending[d][g].map((b => b.key)).sort().join()
              }
            }
            for (const l of this._renderableTiles)
              for (const u in this._coordsAscendingStr) {
                const d = this._coordsAscendingStr[u][l.tileID.key];
                d && d !== l.rttCoords[u] && (l.rtt = [])
              }
          }
          renderLayer(e, i) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const l = Object.assign(Object.assign({}, i), {
                isRenderingToTexture: !0
              }),
              u = e.type,
              d = this.painter,
              g = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (ms[u] && (this._prevType && ms[this._prevType] || this._stacks.push([]), this._prevType = u, this._stacks[this._stacks.length - 1].push(e.id), !g)) return !0;
            if (ms[this._prevType] || ms[u] && g) {
              this._prevType = u;
              const b = this._stacks.length - 1,
                S = this._stacks[b] || [];
              for (const P of this._renderableTiles) {
                if (this.pool.isFull() && (Dl(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(P), P.rtt[b]) {
                  const R = this.pool.getObjectForId(P.rtt[b].id);
                  if (R.stamp === P.rtt[b].stamp) {
                    this.pool.useObject(R);
                    continue
                  }
                }
                const A = this.pool.getOrCreateFreeObject();
                this.pool.useObject(A), this.pool.stampObject(A), P.rtt[b] = {
                  id: A.id,
                  stamp: A.stamp
                }, d.context.bindFramebuffer.set(A.fbo.framebuffer), d.context.clear({
                  color: o.bf.transparent,
                  stencil: 0
                }), d.currentStencilSource = void 0;
                for (let R = 0; R < S.length; R++) {
                  const D = d.style._layers[S[R]],
                    O = D.source ? this._coordsAscending[D.source][P.tileID.key] : [P.tileID];
                  d.context.viewport.set([0, 0, A.fbo.width, A.fbo.height]), d._renderTileClippingMasks(D, O, !0), d.renderLayer(d, d.style.sourceCaches[D.source], D, O, l), D.source && (P.rttCoords[D.source] = this._coordsAscendingStr[D.source][P.tileID.key])
                }
              }
              return Dl(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects(), ms[u]
            }
            return !1
          }
        }
        const $i = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          bd = B,
          xa = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: cu,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          qp = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class Xo {
          constructor(e, i, l = !1) {
            this.mousedown = d => {
              this.startMove(d, X.mousePos(this.element, d)), X.addEventListener(window, "mousemove", this.mousemove), X.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = d => {
              this.move(d, X.mousePos(this.element, d))
            }, this.mouseup = d => {
              this._rotatePitchHandler.dragEnd(d), this.offTemp()
            }, this.touchstart = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = X.touchPos(this.element, d.targetTouches)[0], this.startMove(d, this._startPos), X.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), X.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = X.touchPos(this.element, d.targetTouches)[0], this.move(d, this._lastPos))
            }, this.touchend = d => {
              d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = i;
            const u = new Np;
            this._rotatePitchHandler = new io({
              clickTolerance: 3,
              move: (d, g) => {
                const b = i.getBoundingClientRect(),
                  S = new o.P((b.bottom - b.top) / 2, (b.right - b.left) / 2);
                return {
                  bearingDelta: o.cn(new o.P(d.x, g.y), g, S),
                  pitchDelta: l ? -.5 * (g.y - d.y) : void 0
                }
              },
              moveStateManager: u,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, X.addEventListener(i, "mousedown", this.mousedown), X.addEventListener(i, "touchstart", this.touchstart, {
              passive: !1
            }), X.addEventListener(i, "touchcancel", this.reset)
          }
          startMove(e, i) {
            this._rotatePitchHandler.dragStart(e, i), X.disableDrag()
          }
          move(e, i) {
            const l = this.map,
              {
                bearingDelta: u,
                pitchDelta: d
              } = this._rotatePitchHandler.dragMove(e, i) || {};
            u && l.setBearing(l.getBearing() + u), d && l.setPitch(l.getPitch() + d)
          }
          off() {
            const e = this.element;
            X.removeEventListener(e, "mousedown", this.mousedown), X.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), X.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), X.removeEventListener(window, "touchend", this.touchend), X.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            X.enableDrag(), X.removeEventListener(window, "mousemove", this.mousemove), X.removeEventListener(window, "mouseup", this.mouseup), X.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), X.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let zn;

        function ei(h, e, i, l = !1) {
          if (l || !i.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
          const u = new o.S(h.lng, h.lat);
          if (h = new o.S(h.lng, h.lat), e) {
            const d = new o.S(h.lng - 360, h.lat),
              g = new o.S(h.lng + 360, h.lat),
              b = i.locationToScreenPoint(h).distSqr(e);
            i.locationToScreenPoint(d).distSqr(e) < b ? h = d : i.locationToScreenPoint(g).distSqr(e) < b && (h = g)
          }
          for (; Math.abs(h.lng - i.center.lng) > 180;) {
            const d = i.locationToScreenPoint(h);
            if (d.x >= 0 && d.y >= 0 && d.x <= i.width && d.y <= i.height) break;
            h.lng > i.center.lng ? h.lng -= 360 : h.lng += 360
          }
          return h.lng !== u.lng && i.isPointOnMapSurface(i.locationToScreenPoint(h)) ? h : u
        }
        const Zl = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function lo(h, e, i) {
          const l = h.classList;
          for (const u in Zl) l.remove(`maplibregl-${i}-anchor-${u}`);
          l.add(`maplibregl-${i}-anchor-${e}`)
        }
        class co extends o.E {
          constructor(e) {
            if (super(), this._onKeyPress = i => {
                const l = i.code,
                  u = i.charCode || i.keyCode;
                l !== "Space" && l !== "Enter" && u !== 32 && u !== 13 || this.togglePopup()
              }, this._onMapClick = i => {
                const l = i.originalEvent.target,
                  u = this._element;
                this._popup && (l === u || u.contains(l)) && this.togglePopup()
              }, this._update = i => {
                if (!this._map) return;
                const l = this._map.loaded() && !this._map.isMoving();
                ((i == null ? void 0 : i.type) === "terrain" || (i == null ? void 0 : i.type) === "render" && !l) && this._map.once("render", this._update), this._lngLat = ei(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let u = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let d = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()), X.setTransform(this._element, `${Zl[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${u}`), se.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(i && i.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = i => {
                if (!this._isDragging) {
                  const l = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = i.point.dist(this._pointerdownPos) >= l
                }
                this._isDragging && (this._pos = i.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.l("dragstart"))), this.fire(new o.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = i => {
                this._element.contains(i.originalEvent.target) && (i.preventDefault(), this._positionDelta = i.point.sub(this._pos).add(this._offset), this._pointerdownPos = i.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = o.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = X.create("div");
              const i = X.createNS("http://www.w3.org/2000/svg", "svg"),
                l = 41,
                u = 27;
              i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${l}px`), i.setAttributeNS(null, "width", `${u}px`), i.setAttributeNS(null, "viewBox", `0 0 ${u} ${l}`);
              const d = X.createNS("http://www.w3.org/2000/svg", "g");
              d.setAttributeNS(null, "stroke", "none"), d.setAttributeNS(null, "stroke-width", "1"), d.setAttributeNS(null, "fill", "none"), d.setAttributeNS(null, "fill-rule", "evenodd");
              const g = X.createNS("http://www.w3.org/2000/svg", "g");
              g.setAttributeNS(null, "fill-rule", "nonzero");
              const b = X.createNS("http://www.w3.org/2000/svg", "g");
              b.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), b.setAttributeNS(null, "fill", "#000000");
              const S = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const ne of S) {
                const le = X.createNS("http://www.w3.org/2000/svg", "ellipse");
                le.setAttributeNS(null, "opacity", "0.04"), le.setAttributeNS(null, "cx", "10.5"), le.setAttributeNS(null, "cy", "5.80029008"), le.setAttributeNS(null, "rx", ne.rx), le.setAttributeNS(null, "ry", ne.ry), b.appendChild(le)
              }
              const P = X.createNS("http://www.w3.org/2000/svg", "g");
              P.setAttributeNS(null, "fill", this._color);
              const A = X.createNS("http://www.w3.org/2000/svg", "path");
              A.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), P.appendChild(A);
              const R = X.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "opacity", "0.25"), R.setAttributeNS(null, "fill", "#000000");
              const D = X.createNS("http://www.w3.org/2000/svg", "path");
              D.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), R.appendChild(D);
              const O = X.createNS("http://www.w3.org/2000/svg", "g");
              O.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), O.setAttributeNS(null, "fill", "#FFFFFF");
              const $ = X.createNS("http://www.w3.org/2000/svg", "g");
              $.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const te = X.createNS("http://www.w3.org/2000/svg", "circle");
              te.setAttributeNS(null, "fill", "#000000"), te.setAttributeNS(null, "opacity", "0.25"), te.setAttributeNS(null, "cx", "5.5"), te.setAttributeNS(null, "cy", "5.5"), te.setAttributeNS(null, "r", "5.4999962");
              const ee = X.createNS("http://www.w3.org/2000/svg", "circle");
              ee.setAttributeNS(null, "fill", "#FFFFFF"), ee.setAttributeNS(null, "cx", "5.5"), ee.setAttributeNS(null, "cy", "5.5"), ee.setAttributeNS(null, "r", "5.4999962"), $.appendChild(te), $.appendChild(ee), g.appendChild(b), g.appendChild(P), g.appendChild(R), g.appendChild(O), g.appendChild($), i.appendChild(g), i.setAttributeNS(null, "height", l * this._scale + "px"), i.setAttributeNS(null, "width", u * this._scale + "px"), this._element.appendChild(i), this._offset = o.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i => {
                i.preventDefault()
              })), this._element.addEventListener("mousedown", (i => {
                i.preventDefault()
              })), lo(this._element, this._anchor, "marker"), e && e.className)
              for (const i of e.className.split(" ")) this._element.classList.add(i);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), X.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = o.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const u = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                  "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var i, l;
            const u = (i = this._map) === null || i === void 0 ? void 0 : i.terrain,
              d = this._map.transform.isLocationOccluded(this._lngLat);
            if (!u || d) {
              const O = d ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== O && (this._element.style.opacity = O))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const g = this._map,
              b = g.terrain.depthAtPoint(this._pos),
              S = g.terrain.getElevationForLngLatZoom(this._lngLat, g.transform.tileZoom);
            if (g.transform.lngLatToCameraDepth(this._lngLat, S) - b < .006) return void(this._element.style.opacity = this._opacity);
            const P = -this._offset.y / g.transform.pixelsPerMeter,
              A = Math.sin(g.getPitch() * Math.PI / 180) * P,
              R = g.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)),
              D = g.transform.lngLatToCameraDepth(this._lngLat, S + A) - R > .006;
            !((l = this._popup) === null || l === void 0) && l.isOpen() && D && this._popup.remove(), this._element.style.opacity = D ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = o.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, i) {
            return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(!0), this
          }
        }
        const hu = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let uo = 0,
          Os = !1;
        const Yo = {
          maxWidth: 100,
          unit: "metric"
        };

        function Ul(h, e, i) {
          const l = i && i.maxWidth || 100,
            u = h._container.clientHeight / 2,
            d = h._container.clientWidth / 2,
            g = h.unproject([d - l / 2, u]),
            b = h.unproject([d + l / 2, u]),
            S = Math.round(h.project(b).x - h.project(g).x),
            P = Math.min(l, S, h._container.clientWidth),
            A = g.distanceTo(b);
          if (i && i.unit === "imperial") {
            const R = 3.2808 * A;
            R > 5280 ? Ns(e, P, R / 5280, h._getUIString("ScaleControl.Miles")) : Ns(e, P, R, h._getUIString("ScaleControl.Feet"))
          } else i && i.unit === "nautical" ? Ns(e, P, A / 1852, h._getUIString("ScaleControl.NauticalMiles")) : A >= 1e3 ? Ns(e, P, A / 1e3, h._getUIString("ScaleControl.Kilometers")) : Ns(e, P, A, h._getUIString("ScaleControl.Meters"))
        }

        function Ns(h, e, i, l) {
          const u = (function(d) {
            const g = Math.pow(10, `${Math.floor(d)}`.length - 1);
            let b = d / g;
            return b = b >= 10 ? 10 : b >= 5 ? 5 : b >= 3 ? 3 : b >= 2 ? 2 : b >= 1 ? 1 : (function(S) {
              const P = Math.pow(10, Math.ceil(-Math.log(S) / Math.LN10));
              return Math.round(S * P) / P
            })(b), g * b
          })(i);
          h.style.width = e * (u / i) + "px", h.innerHTML = `${u}&nbsp;${l}`
        }
        const du = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          pu = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function $l(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return {
                center: new o.P(0, 0),
                top: new o.P(0, h),
                "top-left": new o.P(e, e),
                "top-right": new o.P(-e, e),
                bottom: new o.P(0, -h),
                "bottom-left": new o.P(e, -e),
                "bottom-right": new o.P(-e, -e),
                left: new o.P(h, 0),
                right: new o.P(-h, 0)
              }
            }
            if (h instanceof o.P || Array.isArray(h)) {
              const e = o.P.convert(h);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: o.P.convert(h.center || [0, 0]),
              top: o.P.convert(h.top || [0, 0]),
              "top-left": o.P.convert(h["top-left"] || [0, 0]),
              "top-right": o.P.convert(h["top-right"] || [0, 0]),
              bottom: o.P.convert(h.bottom || [0, 0]),
              "bottom-left": o.P.convert(h["bottom-left"] || [0, 0]),
              "bottom-right": o.P.convert(h["bottom-right"] || [0, 0]),
              left: o.P.convert(h.left || [0, 0]),
              right: o.P.convert(h.right || [0, 0])
            }
          }
          return $l(new o.P(0, 0))
        }
        const fu = B;
        T.AJAXError = o.cz, T.Event = o.l, T.Evented = o.E, T.LngLat = o.S, T.MercatorCoordinate = o.a1, T.Point = o.P, T.addProtocol = o.cA, T.config = o.a, T.removeProtocol = o.cB, T.AttributionControl = uu, T.BoxZoomHandler = ru, T.CanvasSource = yr, T.CooperativeGesturesHandler = vd, T.DoubleClickZoomHandler = au, T.DragPanHandler = _d, T.DragRotateHandler = ou, T.EdgeInsets = nn, T.FullscreenControl = class extends o.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = i == null ? void 0 : i.shadowRoot) === null || e === void 0) && e.fullscreenElement;) i = i.shadowRoot.fullscreenElement;
              i === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            X.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const h = this._fullscreenButton = X.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            X.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, T.GeoJSONSource = er, T.GeolocateControl = class extends o.E {
          constructor(h) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new o.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const i = new o.S(e.coords.longitude, e.coords.latitude),
                l = e.coords.accuracy,
                u = this._map.getBearing(),
                d = o.e({
                  bearing: u
                }, this.options.fitBoundsOptions),
                g = pt.fromLngLat(i, l);
              this._map.fitBounds(g, d, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const i = new o.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Os) return;
                  this.options.trackUserLocation && this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = X.create("button", "maplibregl-ctrl-geolocate", this._container), X.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                } else {
                  const i = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = X.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new co({
                  element: this._dotElement
                }), this._circleElement = X.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new co({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (i => {
                  const l = (i == null ? void 0 : i[0]) instanceof ResizeObserverEntry;
                  i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || l || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.l("trackuserlocationend")), this.fire(new o.l("userlocationlostfocus")))
                }))
              }
            }, this.options = o.e({}, hu, h)
          }
          onAdd(h) {
            return this._map = h, this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return o._(this, arguments, void 0, (function*(e = !1) {
                if (zn !== void 0 && !e) return zn;
                if (window.navigator.permissions === void 0) return zn = !!window.navigator.geolocation, zn;
                try {
                  zn = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  zn = !!window.navigator.geolocation
                }
                return zn
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), X.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, uo = 0, Os = !1
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(),
              i = h.coords;
            return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadius() {
            const h = this._map.getBounds(),
              e = h.getSouthEast(),
              i = h.getNorthEast(),
              l = e.distanceTo(i),
              u = Math.ceil(this._accuracy / (l / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${u}px`, this._circleElement.style.height = `${u}px`
          }
          trigger() {
            if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  uo--, Os = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.l("trackuserlocationstart")), this.fire(new o.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), uo++, uo > 1 ? (h = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Os = !0) : (h = this.options.positionOptions, Os = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, T.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(h) {
            return this._map = h, this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = X.create("button", "maplibregl-ctrl-globe", this._container), X.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            X.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, T.Hash = Rl, T.ImageSource = It, T.KeyboardHandler = Ol, T.LngLatBounds = pt, T.LogoControl = xd, T.Map = class extends yd {
          constructor(h) {
            var e, i;
            o.cw.mark(o.cx.create);
            const l = Object.assign(Object.assign(Object.assign({}, xa), h), {
              canvasContextAttributes: Object.assign(Object.assign({}, xa.canvasContextAttributes), h.canvasContextAttributes)
            });
            if (l.minZoom != null && l.maxZoom != null && l.minZoom > l.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (l.minPitch != null && l.maxPitch != null && l.minPitch > l.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (l.minPitch != null && l.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (l.maxPitch != null && l.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const u = new Sn,
              d = new pi;
            if (l.minZoom !== void 0 && u.setMinZoom(l.minZoom), l.maxZoom !== void 0 && u.setMaxZoom(l.maxZoom), l.minPitch !== void 0 && u.setMinPitch(l.minPitch), l.maxPitch !== void 0 && u.setMaxPitch(l.maxPitch), l.renderWorldCopies !== void 0 && u.setRenderWorldCopies(l.renderWorldCopies), super(u, d, {
                bearingSnap: l.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new $a, this._controls = [], this._mapId = o.a7(), this._contextLost = b => {
                b.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.l("webglcontextlost", {
                  originalEvent: b
                }))
              }, this._contextRestored = b => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new o.l("webglcontextrestored", {
                  originalEvent: b
                }))
              }, this._onMapScroll = b => {
                if (b.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = l.interactive, this._maxTileCacheSize = l.maxTileCacheSize, this._maxTileCacheZoomLevels = l.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, l.canvasContextAttributes), this._trackResize = l.trackResize === !0, this._bearingSnap = l.bearingSnap, this._centerClampedToGround = l.centerClampedToGround, this._refreshExpiredTiles = l.refreshExpiredTiles === !0, this._fadeDuration = l.fadeDuration, this._crossSourceCollisions = l.crossSourceCollisions === !0, this._collectResourceTiming = l.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, $i), l.locale), this._clickTolerance = l.clickTolerance, this._overridePixelRatio = l.pixelRatio, this._maxCanvasSize = l.maxCanvasSize, this.transformCameraUpdate = l.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = l.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Oe.addThrottleControl((() => this.isMoving())), this._requestManager = new st(l.transformRequest), typeof l.container == "string") {
              if (this._container = document.getElementById(l.container), !this._container) throw new Error(`Container '${l.container}' not found.`)
            } else {
              if (!(l.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = l.container
            }
            if (l.maxBounds && this.setMaxBounds(l.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let b = !1;
              const S = Bs((P => {
                this._trackResize && !this._removed && (this.resize(P), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((P => {
                b ? S(P) : b = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new lu(this, l), this._hash = l.hash && new Rl(typeof l.hash == "string" && l.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: l.center,
              elevation: l.elevation,
              zoom: l.zoom,
              bearing: l.bearing,
              pitch: l.pitch,
              roll: l.roll
            }), l.bounds && (this.resize(), this.fitBounds(l.bounds, o.e({}, l.fitBoundsOptions, {
              duration: 0
            }))));
            const g = typeof l.style == "string" || ((i = (e = l.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe";
            this.resize(null, g), this._localIdeographFontFamily = l.localIdeographFontFamily, this._validateStyle = l.validateStyle, l.style && this.setStyle(l.style, {
              localIdeographFontFamily: l.localIdeographFontFamily
            }), l.attributionControl && this.addControl(new uu(typeof l.attributionControl == "boolean" ? void 0 : l.attributionControl)), l.maplibreLogo && this.addControl(new xd, l.logoPosition), this.on("style.load", (() => {
              if (g || this._resizeTransform(), this.transform.unmodified) {
                const b = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(b)
              }
            })), this.on("data", (b => {
              this._update(b.dataType === "style"), this.fire(new o.l(`${b.dataType}data`, b))
            })), this.on("dataloading", (b => {
              this.fire(new o.l(`${b.dataType}dataloading`, b))
            })), this.on("dataabort", (b => {
              this.fire(new o.l("sourcedataabort", b))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(h, e) {
            return this.style.setGlobalStateProperty(h, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i = h.onAdd(this);
            this._controls.push(h);
            const l = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? l.insertBefore(i, l.firstChild) : l.appendChild(i), this
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1
          }
          calculateCameraOptionsFromTo(h, e, i, l) {
            return l == null && this.terrain && (l = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, i, l)
          }
          resize(h, e = !0) {
            const [i, l] = this._containerDimensions(), u = this._getClampedPixelRatio(i, l);
            if (this._resizeCanvas(i, l, u), this.painter.resize(i, l, u), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const b = this._getClampedPixelRatio(i, l);
              this._resizeCanvas(i, l, b), this.painter.resize(i, l, b)
            }
            this._resizeTransform(e);
            const d = !this._moving;
            return d && (this.stop(), this.fire(new o.l("movestart", h)).fire(new o.l("move", h))), this.fire(new o.l("resize", h)), d && this.fire(new o.l("moveend", h)), this
          }
          _resizeTransform(h = !0) {
            var e;
            const [i, l] = this._containerDimensions();
            this.transform.resize(i, l, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, l, h)
          }
          _getClampedPixelRatio(h, e) {
            const {
              0: i,
              1: l
            } = this._maxCanvasSize, u = this.getPixelRatio(), d = h * u, g = e * u;
            return Math.min(d > i ? i / d : 1, g > l ? l / g : 1) * u
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(pt.convert(h)), this._update()
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update()
          }
          project(h) {
            return this.transform.locationToScreenPoint(o.S.convert(h), this.style && this.terrain)
          }
          unproject(h) {
            return this.transform.screenPointToLocation(o.P.convert(h), this.terrain)
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
          }
          _createDelegatedListener(h, e, i) {
            if (h === "mouseenter" || h === "mouseover") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: d => {
                    const g = e.filter((S => this.getLayer(S))),
                      b = g.length !== 0 ? this.queryRenderedFeatures(d.point, {
                        layers: g
                      }) : [];
                    b.length ? l || (l = !0, i.call(this, new ea(h, this, d.originalEvent, {
                      features: b
                    }))) : l = !1
                  },
                  mouseout: () => {
                    l = !1
                  }
                }
              }
            }
            if (h === "mouseleave" || h === "mouseout") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: g => {
                    const b = e.filter((S => this.getLayer(S)));
                    (b.length !== 0 ? this.queryRenderedFeatures(g.point, {
                      layers: b
                    }) : []).length ? l = !0 : l && (l = !1, i.call(this, new ea(h, this, g.originalEvent)))
                  },
                  mouseout: g => {
                    l && (l = !1, i.call(this, new ea(h, this, g.originalEvent)))
                  }
                }
              }
            } {
              const l = u => {
                const d = e.filter((b => this.getLayer(b))),
                  g = d.length !== 0 ? this.queryRenderedFeatures(u.point, {
                    layers: d
                  }) : [];
                g.length && (u.features = g, i.call(this, u), delete u.features)
              };
              return {
                layers: e,
                listener: i,
                delegates: {
                  [h]: l
                }
              }
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e)
          }
          _removeDelegatedListener(h, e, i) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const l = this._delegatedListeners[h];
            for (let u = 0; u < l.length; u++) {
              const d = l[u];
              if (d.listener === i && d.layers.length === e.length && d.layers.every((g => e.includes(g)))) {
                for (const g in d.delegates) this.off(g, d.delegates[g]);
                return void l.splice(u, 1)
              }
            }
          }
          on(h, e, i) {
            if (i === void 0) return super.on(h, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, l, i);
            this._saveDelegatedListener(h, u);
            for (const d in u.delegates) this.on(d, u.delegates[d]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(h, l, i)
              }
            }
          }
          once(h, e, i) {
            if (i === void 0) return super.once(h, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, l, i);
            for (const d in u.delegates) {
              const g = u.delegates[d];
              u.delegates[d] = (...b) => {
                this._removeDelegatedListener(h, l, i), g(...b)
              }
            }
            this._saveDelegatedListener(h, u);
            for (const d in u.delegates) this.once(d, u.delegates[d]);
            return this
          }
          off(h, e, i) {
            return i === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, i), this)
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let i;
            const l = h instanceof o.P || Array.isArray(h),
              u = l ? h : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (l ? {} : h) || {}, u instanceof o.P || typeof u[0] == "number") i = [o.P.convert(u)];
            else {
              const d = o.P.convert(u[0]),
                g = o.P.convert(u[1]);
              i = [d, new o.P(g.x, d.y), g, new o.P(d.x, g.y), d]
            }
            return this.style.queryRenderedFeatures(i, e, this.transform)
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e)
          }
          setStyle(h, e) {
            return (e = o.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e))
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e
          }
          _updateStyle(h, e) {
            var i, l;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(h, e)));
            const u = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new Ec(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof h == "string" ? this.style.loadURL(h, e, u) : this.style.loadJSON(h, e, u), this) : ((l = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || l === void 0 || l.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ec(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const i = this._requestManager.transformRequest(h, "Style");
              o.j(i, new AbortController).then((l => {
                this._updateDiff(l.data, e)
              })).catch((l => {
                l && this.fire(new o.k(l))
              }))
            } else typeof h == "object" && this._updateDiff(h, e)
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0)
            } catch (i) {
              o.w(`Unable to perform style diff: ${i.message||i.error||i}.  Rebuilding the style from scratch.`), this._updateStyle(h, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : o.w("There is no style added to the map.")
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0)
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.sourceCaches[h];
            if (e !== void 0) return e.loaded();
            this.fire(new o.k(new Error(`There is no source with ID '${h}'`)))
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.sourceCaches[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const i in this.style._layers) {
                const l = this.style._layers[i];
                l.type === "hillshade" && l.source === h.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), l.type === "color-relief" && l.source === h.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new Or(this.painter, e, h), this.painter.renderToTexture = new ql(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = i => {
                var l;
                i.dataType === "style" ? this.terrain.sourceCache.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((l = i.source) === null || l === void 0 ? void 0 : l.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(i.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new o.l("terrain", {
              terrain: h
            })), this
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const h = this.style && this.style.sourceCaches;
            for (const e in h) {
              const i = h[e]._tiles;
              for (const l in i) {
                const u = i[l];
                if (u.state !== "loaded" && u.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0)
          }
          getSource(h) {
            return this.style.getSource(h)
          }
          setSourceTileLodParams(h, e, i) {
            if (i) {
              const l = this.getSource(i);
              if (!l) throw new Error(`There is no source with ID "${i}", cannot set LOD parameters`);
              l.calculateTileZoom = ct(Math.max(1, h), Math.max(1, e))
            } else
              for (const l in this.style.sourceCaches) this.style.sourceCaches[l].getSource().calculateTileZoom = ct(Math.max(1, h), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(h, e) {
            const i = this.style.sourceCaches[h];
            if (!i) throw new Error(`There is no source cache with ID "${h}", cannot refresh tile`);
            e === void 0 ? i.reload(!0) : i.refreshTiles(e.map((l => new o.a4(l.z, l.x, l.y))))
          }
          addImage(h, e, i = {}) {
            const {
              pixelRatio: l = 1,
              sdf: u = !1,
              stretchX: d,
              stretchY: g,
              content: b,
              textFitWidth: S,
              textFitHeight: P
            } = i;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || o.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: A,
                  height: R,
                  data: D
                } = e, O = e;
                return this.style.addImage(h, {
                  data: new o.R({
                    width: A,
                    height: R
                  }, new Uint8Array(D)),
                  pixelRatio: l,
                  stretchX: d,
                  stretchY: g,
                  content: b,
                  textFitWidth: S,
                  textFitHeight: P,
                  sdf: u,
                  version: 0,
                  userImage: O
                }), O.onAdd && O.onAdd(this, h), this
              }
            } {
              const {
                width: A,
                height: R,
                data: D
              } = se.getImageData(e);
              this.style.addImage(h, {
                data: new o.R({
                  width: A,
                  height: R
                }, D),
                pixelRatio: l,
                stretchX: d,
                stretchY: g,
                content: b,
                textFitWidth: S,
                textFitHeight: P,
                sdf: u,
                version: 0
              })
            }
          }
          updateImage(h, e) {
            const i = this.style.getImage(h);
            if (!i) return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const l = e instanceof HTMLImageElement || o.b(e) ? se.getImageData(e) : e,
              {
                width: u,
                height: d,
                data: g
              } = l;
            if (u === void 0 || d === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (u !== i.data.width || d !== i.data.height) return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const b = !(e instanceof HTMLImageElement || o.b(e));
            return i.data.replace(g, b), this.style.updateImage(h, i), this
          }
          getImage(h) {
            return this.style.getImage(h)
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new o.k(new Error("Missing required image id"))), !1)
          }
          removeImage(h) {
            this.style.removeImage(h)
          }
          loadImage(h) {
            return Oe.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0)
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0)
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0)
          }
          getLayer(h) {
            return this.style.getLayer(h)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(h, e, i) {
            return this.style.setLayerZoomRange(h, e, i), this._update(!0)
          }
          setFilter(h, e, i = {}) {
            return this.style.setFilter(h, e, i), this._update(!0)
          }
          getFilter(h) {
            return this.style.getFilter(h)
          }
          setPaintProperty(h, e, i, l = {}) {
            return this.style.setPaintProperty(h, e, i, l), this._update(!0)
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e)
          }
          setLayoutProperty(h, e, i, l = {}) {
            return this.style.setLayoutProperty(h, e, i, l), this._update(!0)
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e)
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(h, e, i = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, i, (l => {
              l || this._update(!0)
            })), this
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (i => {
              i || this._update(!0)
            })), this
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update()
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update()
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let h = 0,
              e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e]
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = X.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = X.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i = this._containerDimensions(),
              l = this._getClampedPixelRatio(i[0], i[1]);
            this._resizeCanvas(i[0], i[1], l);
            const u = this._controlContainer = X.create("div", "maplibregl-control-container", h),
              d = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g => {
              d[g] = X.create("div", `maplibregl-ctrl-${g} `, u)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(h, e, i) {
            this._canvas.width = Math.floor(i * h), this._canvas.height = Math.floor(i * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (l => {
              e = {
                requestedAttributes: h
              }, l && (e.statusMessage = l.statusMessage, e.type = l.type)
            }), {
              once: !0
            });
            let i = null;
            if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !i) {
              const l = "Failed to initialize WebGL";
              throw e ? (e.message = l, new Error(JSON.stringify(e))) : new Error(l)
            }
            this.painter = new ad(i, this.transform), me.testSupport(i)
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new o.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h)
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h)
          }
          _render(h) {
            var e, i, l, u, d;
            const g = this._idleTriggered ? this._fadeDuration : 0,
              b = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let S = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const R = this.transform.zoom,
                D = se.now();
              this.style.zoomHistory.update(R, D);
              const O = new o.F(R, {
                  now: D,
                  fadeDuration: g,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition(),
                  globalState: this.style.getGlobalState()
                }),
                $ = O.crossFadingFactor();
              $ === 1 && $ === this._crossFadingFactor || (S = !0, this._crossFadingFactor = $), this.style.update(O)
            }
            const P = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== b;
            (l = this.style.projection) === null || l === void 0 || l.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || P) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, P), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: g,
              showPadding: this.showPadding
            }), this.fire(new o.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.cw.mark(o.cx.load), this.fire(new o.l("load"))), this.style && (this.style.hasTransitions() || S) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const A = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return A || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")), !this._loaded || this._fullyLoaded || A || (this._fullyLoaded = !0, o.cw.mark(o.cx.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const i of this._controls) i.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Oe.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), X.remove(this._canvasContainer), X.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), o.cw.clearMetrics(), this._removed = !0, this.fire(new o.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, se.frame(this._frameRequest, (h => {
              o.cw.frame(h), this._frameRequest = null;
              try {
                this._render(h)
              } catch (e) {
                if (!o.cy(e) && !(function(i) {
                    return i.message === No
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(h) {
            this._vertices = h, this._update()
          }
          get version() {
            return bd
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0)
          }
        }, T.MapMouseEvent = ea, T.MapTouchEvent = to, T.MapWheelEvent = tu, T.Marker = co, T.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                i = e === this._map.getMaxZoom(),
                l = e === this._map.getMinZoom();
              this._zoomInButton.disabled = i, this._zoomOutButton.disabled = l, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", l.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, i) => {
              const l = this._map._getUIString(`NavigationControl.${i}`);
              e.title = l, e.setAttribute("aria-label", l)
            }, this.options = o.e({}, qp, h), this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), X.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), X.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = X.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Xo(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            X.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(h, e) {
            const i = X.create("button", h, this._container);
            return i.type = "button", i.addEventListener("click", e), i
          }
        }, T.Popup = class extends o.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && X.remove(this._content), this._container && (X.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = X.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = X.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const g of this.options.className.split(" ")) this._container.classList.add(g);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ei(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const i = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let l = this.options.anchor;
              const u = $l(this.options.offset);
              if (!l) {
                const g = this._container.offsetWidth,
                  b = this._container.offsetHeight;
                let S;
                S = i.y + u.bottom.y < b ? ["top"] : i.y > this._map.transform.height - b ? ["bottom"] : [], i.x < g / 2 ? S.push("left") : i.x > this._map.transform.width - g / 2 && S.push("right"), l = S.length === 0 ? "bottom" : S.join("-")
              }
              let d = i.add(u[l]);
              this.options.subpixelPositioning || (d = d.round()), X.setTransform(this._container, `${Zl[l]} translate(${d.x}px,${d.y}px)`), lo(this._container, l, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = o.e(Object.create(du), h)
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(h) {
            return this._lngLat = o.S.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h))
          }
          setHTML(h) {
            const e = document.createDocumentFragment(),
              i = document.createElement("body");
            let l;
            for (i.innerHTML = h; l = i.firstChild, l;) e.appendChild(l);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this
          }
          setDOMContent(h) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = X.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h)
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = X.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(pu);
            h && h.focus()
          }
        }, T.RasterDEMTileSource = rr, T.RasterTileSource = Xt, T.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              Ul(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, Ul(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Yo), h)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(h) {
            return this._map = h, this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            X.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, T.ScrollZoomHandler = fd, T.Style = Ec, T.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = h
          }
          onAdd(h) {
            return this._map = h, this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = X.create("button", "maplibregl-ctrl-terrain", this._container), X.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            X.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, T.TwoFingersTouchPitchHandler = Fl, T.TwoFingersTouchRotateHandler = so, T.TwoFingersTouchZoomHandler = Bl, T.TwoFingersTouchZoomRotateHandler = gd, T.VectorTileSource = Wt, T.VideoSource = ur, T.addSourceType = (h, e) => o._(void 0, void 0, void 0, (function*() {
          if (Gr(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((i, l) => {
            Mr[i] = l
          })(h, e)
        })), T.clearPrewarmedResources = function() {
          const h = We;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(ke), We = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, T.createTileMesh = Ps, T.getMaxParallelImageRequests = function() {
          return o.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, T.getRTLTextPluginStatus = function() {
          return gr().getRTLTextPluginStatus()
        }, T.getVersion = function() {
          return fu
        }, T.getWorkerCount = function() {
          return Le.workerCount
        }, T.getWorkerUrl = function() {
          return o.a.WORKER_URL
        }, T.importScriptInWorkers = function(h) {
          return ot().broadcast("IS", h)
        }, T.prewarm = function() {
          zt().acquire(ke)
        }, T.setMaxParallelImageRequests = function(h) {
          o.a.MAX_PARALLEL_IMAGE_REQUESTS = h
        }, T.setRTLTextPlugin = function(h, e) {
          return gr().setRTLTextPlugin(h, e)
        }, T.setWorkerCount = function(h) {
          Le.workerCount = h
        }, T.setWorkerUrl = function(h) {
          o.a.WORKER_URL = h
        }
      }));
      var z = m;
      return z
    }))
  })(Hd)), Hd.exports
}
var nI = rI();
const jd = Fm(nI);
class Yg {
  constructor(s) {
    mr(this, "gm");
    mr(this, "markers", new Map);
    mr(this, "canvases", new Map);
    mr(this, "canvasSize");
    mr(this, "canvasOpacity", .8);
    this.input = s, this.gm = new hl(this.input.tileSize);
    const m = Jv(s.img);
    this.canvasSize = Math.ceil(2e3 / m)
  }
  place([s, m]) {
    const y = this.gm.latLonToPixelsFloor(s, m, this.input.zoom),
      M = this.getMarkerId(y),
      z = this.gm.latLonToPixelBoundsLatLon(s, m, this.input.zoom),
      T = this.input.map;
    if (this.input.markerFn && !this.markers.has(M)) {
      const K = this.input.markerFn();
      K.setLngLat({
        lat: z.min[0],
        lng: (z.max[1] + z.min[1]) / 2
      }).addTo(T), this.markers.set(M, K)
    }
    const {
      key: o,
      pos: B,
      innerPos: N
    } = this.getCanvasPos(y);
    let W = this.canvases.get(o);
    if (!W) {
      const K = this.canvasSize,
        se = B.x * K,
        X = B.y * K,
        me = se + K - 1,
        ge = X + K - 1,
        Ee = this.gm.pixelsToLatLon(se, ge + 1, this.input.zoom),
        ze = this.gm.pixelsToLatLon(me + 1, X, this.input.zoom);
      W = new iI({
        id: `${this.input.id}-${o}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: Rm({
          min: Ee,
          max: ze
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), W.addTo(this.input.map), this.canvases.set(o, W)
    }
    W.place(N.x, N.y)
  }
  clear() {
    const s = this.input.map;
    for (const m of this.canvases.values()) m.removeFrom(s), m.removeDOM();
    this.canvases.clear();
    for (const m of this.markers.values()) m.remove();
    this.markers.clear()
  }
  clearAndPlace(s) {
    this.clear(), this.place(s)
  }
  remove([s, m]) {
    let y = !1;
    const M = this.gm.latLonToPixelsFloor(s, m, this.input.zoom),
      {
        key: z,
        innerPos: T
      } = this.getCanvasPos(M),
      o = this.canvases.get(z);
    o && (y = o.remove(T.x, T.y), o.annotationsCount() === 0 && (this.canvases.delete(z), o.removeFrom(this.input.map), o.removeDOM()));
    const B = this.getMarkerId(M),
      N = this.markers.get(B);
    return N == null || N.remove(), this.markers.delete(B), y
  }
  setCanvasOpacity(s) {
    this.canvasOpacity = s;
    for (const m of this.canvases.values()) m.setOpacity(s)
  }
  getMarkerId([s, m]) {
    return `${this.input.id}:${s},${m}`
  }
  getCanvasPos([s, m]) {
    const y = {
        x: Math.floor(s / this.canvasSize),
        y: Math.floor(m / this.canvasSize)
      },
      M = {
        x: s % this.canvasSize,
        y: m % this.canvasSize
      },
      z = `${y.x},${y.y}`;
    return {
      pos: y,
      innerPos: M,
      key: z
    }
  }
}
class iI {
  constructor(s) {
    mr(this, "annotations", new Set);
    mr(this, "canvas");
    mr(this, "imgSize");
    mr(this, "maps", new Set);
    this.input = s, this.imgSize = Jv(s.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(s, m) {
    const y = this.getPixelKey(s, m);
    if (this.annotations.has(y)) return !1;
    const M = this.canvas.getContext("2d");
    if (M) {
      const z = s * this.imgSize,
        T = m * this.imgSize;
      M.drawImage(this.input.img, z, T)
    }
    return this.annotations.add(y), !0
  }
  remove(s, m) {
    const y = this.getPixelKey(s, m);
    if (!this.annotations.has(y)) return !1;
    const M = this.canvas.getContext("2d");
    if (M) {
      const z = s * this.imgSize,
        T = m * this.imgSize;
      M.clearRect(z, T, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(y), !0
  }
  addTo(s) {
    const m = this.input.id;
    s.getSource(m) || s.addSource(m, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), s.getLayer(m) || s.addLayer({
      id: m,
      type: "raster",
      source: m,
      paint: this.input.layerPaint
    }), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: m
    } = this.input;
    s.getLayer(m) && s.removeLayer(m), s.getSource(m) && s.removeSource(m), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(s) {
    for (const m of this.maps.values()) m.setPaintProperty(this.input.id, "raster-opacity", s)
  }
  getPixelKey(s, m) {
    return `${s},${m}`
  }
}

function Jv(_) {
  return Math.max(_.naturalWidth, _.naturalHeight)
}

function aI() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function Ou(_, s) {
  return s.includes(_)
}

function sI(_) {
  const s = {
      opaque: !0
    },
    m = _.searchParams.get("lat"),
    y = _.searchParams.get("lng");
  m && y && (s.pos = {
    lat: parseFloat(m),
    lng: parseFloat(y)
  });
  const M = _.searchParams.get("zoom");
  M && (s.zoom = parseFloat(M));
  const z = _.searchParams.get("season");
  z && (s.season = parseInt(z));
  const T = _.searchParams.get("opaque");
  return T && (s.opaque = T !== "0"), _.searchParams.get("select") && (s.select = !0), s.newUser = !!_.searchParams.get("new-user"), s.alliance = !!_.searchParams.get("alliance"), s
}

function oI(_, s) {
  return _ = new URL(_), s.pos !== void 0 && (_.searchParams.set("lat", s.pos.lat.toString()), _.searchParams.set("lng", s.pos.lng.toString())), s.zoom !== void 0 && _.searchParams.set("zoom", s.zoom.toString()), s.season !== void 0 && _.searchParams.set("season", s.season.toString()), s.opaque !== void 0 && _.searchParams.set("opaque", s.opaque ? "1" : "0"), s.newUser !== void 0 && _.searchParams.set("new-user", s.newUser ? "1" : "0"), s.alliance !== void 0 && _.searchParams.set("alliance", s.alliance ? "1" : "0"), s.select && _.searchParams.set("alliance", "1"), _
}
const Wd = yi({
  shouldReload: !0
});
var lI = (_, s) => {
    var m;
    (m = s()) == null || m.close()
  },
  cI = Pe('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function uI(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15),
    y = ut(!1),
    M = ut(yi(s.description)),
    z = ut(void 0);
  An(() => {
    const Re = Ie => {
      var Oe;
      Ie.key === "Escape" && ((Oe = m()) == null || Oe.close())
    };
    return document.addEventListener("keydown", Re), () => document.removeEventListener("keydown", Re)
  });
  var T = cI(),
    o = E(T),
    B = E(o),
    N = E(B, !0);
  k(B);
  var W = Z(B, 2),
    K = E(W),
    se = E(K);
  {
    let Re = ht(() => Zv());
    c1(se, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return w(Re)
      },
      max: 512,
      get value() {
        return w(M)
      },
      set value(Ie) {
        ce(M, Ie, !0)
      },
      get validate() {
        return w(z)
      },
      set validate(Ie) {
        ce(z, Ie, !0)
      }
    })
  }
  k(K);
  var X = Z(K, 2),
    me = E(X);
  me.__click = [lI, m];
  var ge = E(me, !0);
  k(me);
  var Ee = Z(me, 2),
    ze = E(Ee, !0);
  k(Ee), k(X), k(W), k(o), _n(2), k(T), Xs(T, Re => m(Re), () => m()), Ye((Re, Ie, Oe) => {
    ye(N, Re), me.disabled = w(y), ye(ge, Ie), Ee.disabled = w(y), ye(ze, Oe)
  }, [() => m1(), () => Tm(), () => BT()]), Ai("submit", W, async () => {
    var Re, Ie, Oe;
    try {
      if (!((Re = w(z)) != null && Re())) return;
      ce(y, !0), s.description !== w(M) && await an.updateAllianceDescription(w(M)), await ((Ie = s.onsuccess) == null ? void 0 : Ie.call(s, w(M))), (Oe = m()) == null || Oe.close()
    } catch (st) {
      Vr.error(st.message)
    } finally {
      ce(y, !1)
    }
  }), H(_, T), Fr()
}
ri(["click"]);
var hI = (_, s, m) => {
    navigator.clipboard.writeText(w(s).toString()), ce(m, !0), setTimeout(() => {
      ce(m, !1)
    }, 1e3)
  },
  dI = Pe('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  pI = Pe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function fI(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15),
    y = ut(""),
    M = ut(!1);
  const z = ht(() => wa.url.origin + `/join?id=${w(y)}`);
  Xr(() => {
    m() && an.getAllianceInvites().then(nt => {
      ce(y, nt[0], !0)
    }).catch(nt => {
      Vr.error(nt.message)
    })
  }), An(() => {
    const nt = qe => {
      qe.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", nt), () => document.removeEventListener("keydown", nt)
  });
  var T = pI(),
    o = E(T),
    B = Z(E(o), 2),
    N = E(B, !0);
  k(B);
  var W = Z(B, 2),
    K = E(W, !0);
  k(W);
  var se = Z(W, 2),
    X = E(se);
  let me;
  var ge = E(X);
  us(ge);
  var Ee = Z(ge, 2),
    ze = E(Ee);
  let Re;
  ze.__click = [hI, z, M];
  var Ie = E(ze, !0);
  k(ze), k(Ee), k(X);
  var Oe = Z(X, 2);
  {
    var st = nt => {
      var qe = dI();
      H(nt, qe)
    };
    je(Oe, nt => {
      w(y) || nt(st)
    })
  }
  k(se), k(o), _n(2), k(T), Yi(T, () => nt => {
    Xr(() => {
      m() ? nt.show() : nt.close()
    })
  }), Ye((nt, qe, Ue, Je, Fe, it) => {
    ye(N, nt), ye(K, qe), me = zr(X, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, me, Ue), Pv(ge, Je), Re = zr(ze, 1, "btn btn-primary", null, Re, Fe), ye(Ie, it)
  }, [() => z3(), () => R3(), () => ({
    invisible: !w(y)
  }), () => w(z).toString(), () => ({
    "btn-success": w(M)
  }), () => w(M) ? km() : $f()]), Ai("close", T, () => m(!1)), H(_, T), Fr()
}
ri(["click"]);
var mI = Lr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function Om(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = mI();
  or(y, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...m
  })), H(_, y)
}
var _I = async (_, s) => {
  await navigator.clipboard.writeText(s.username), Vr.info(GS())
}, gI = Pe('<span class="tooltip h-4"><button><!></button></span>');

function Ah(_, s) {
  Br(s, !0);
  var m = gI(),
    y = E(m);
  y.__click = [_I, s];
  var M = E(y);
  Om(M, {
    class: "size-4 opacity-70"
  }), k(y), k(m), Ye(() => kr(m, "data-tip", `Discord: ${s.username}`)), H(_, m), Fr()
}
ri(["click"]);
var vI = Pe('<input type="radio" class="tab max-[380px]:px-3"/>'),
  yI = Pe('<div class="tabs tabs-border w-max font-medium"></div>');

function Nm(_, s) {
  Br(s, !0);
  const m = [];
  let y = Et(s, "value", 15, "today"),
    M = [{
      value: "today",
      label: mp()
    }, {
      value: "week",
      label: X3()
    }, {
      value: "month",
      label: J3()
    }, {
      value: "all-time",
      label: tT()
    }];
  var z = yI();
  ui(z, 21, () => M, T => T.value, (T, o) => {
    var B = vI();
    us(B);
    var N;
    Ye(() => {
      kr(B, "aria-label", w(o).label), N !== (N = w(o).value) && (B.value = (B.__value = w(o).value) ?? "")
    }), Im(m, [], B, () => (w(o).value, y()), y), H(T, B)
  }), k(z), H(_, z), Fr()
}
const xI = typeof window < "u" ? window : void 0;

function bI(_) {
  let s = _.activeElement;
  for (; s != null && s.shadowRoot;) {
    const m = s.shadowRoot.activeElement;
    if (m === s) break;
    s = m
  }
  return s
}
var yc, Wu, wv;
let wI = (wv = class {
  constructor(s = {}) {
    Ir(this, yc);
    Ir(this, Wu);
    const {
      window: m = xI,
      document: y = m == null ? void 0 : m.document
    } = s;
    m !== void 0 && (ia(this, yc, y), ia(this, Wu, Iv(M => {
      const z = Nu(m, "focusin", M),
        T = Nu(m, "focusout", M);
      return () => {
        z(), T()
      }
    })))
  }
  get current() {
    var s;
    return (s = rt(this, Wu)) == null || s.call(this), rt(this, yc) ? bI(rt(this, yc)) : null
  }
}, yc = new WeakMap, Wu = new WeakMap, wv);
new wI;

function TI(_, s) {
  switch (_) {
    case "post":
      Xr(s);
      break;
    case "pre":
      wm(s);
      break
  }
}

function Qv(_, s, m, y = {}) {
  const {
    lazy: M = !1
  } = y;
  let z = !M,
    T = Array.isArray(_) ? [] : void 0;
  TI(s, () => {
    const o = Array.isArray(_) ? _.map(N => N()) : _();
    if (!z) {
      z = !0, T = o;
      return
    }
    const B = ll(() => m(o, T));
    return T = o, B
  })
}

function Mc(_, s, m) {
  Qv(_, "post", s, m)
}

function SI(_, s, m) {
  Qv(_, "pre", s, m)
}
Mc.pre = SI;
var CI = Pe('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  PI = Pe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  II = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  MI = (_, s, m) => {
    s.onlastpixelclick({
      lat: w(m).lastLatitude ?? 0,
      lng: w(m).lastLongitude ?? 0
    })
  },
  AI = Pe("<button><!></button>"),
  kI = Pe('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  EI = Pe('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  zI = Pe('<div><!> <div class="mt-4"><!></div></div>');

function LI(_, s) {
  Br(s, !0);
  let m = Et(s, "reload", 15),
    y = ut(!0),
    M = ut([]),
    z = ut(0),
    T = ut("today"),
    o = {};
  m(B);

  function B() {
    const ge = w(T);
    an.allianceLeaderboard(ge).then(Ee => {
      ce(M, Ee), o = {
        [ge]: Ee
      }, ce(y, !1)
    }).catch(Ee => {
      Vr.error(Ee.message)
    })
  }
  Mc(() => [w(T)], () => {
    const ge = w(T),
      Ee = o[ge];
    if (Ee) {
      ce(M, Ee), ce(y, !1);
      return
    }
    ce(y, !0), an.allianceLeaderboard(ge).then(ze => {
      ce(M, ze), o[ge] = ze, ce(y, !1)
    }).catch(ze => {
      Vr.error(ze.message)
    })
  });
  var N = zI(),
    W = E(N);
  Nm(W, {
    get value() {
      return w(T)
    },
    set value(ge) {
      ce(T, ge, !0)
    }
  });
  var K = Z(W, 2),
    se = E(K);
  {
    var X = ge => {
        var Ee = CI();
        H(ge, Ee)
      },
      me = ge => {
        var Ee = Kt(),
          ze = Ct(Ee);
        {
          var Re = Oe => {
              var st = PI(),
                nt = E(st),
                qe = Z(nt);
              {
                var Ue = Fe => {
                    var it = Mi();
                    Ye(tt => ye(it, tt), [() => mp().toLowerCase()]), H(Fe, it)
                  },
                  Je = Fe => {
                    var it = Kt(),
                      tt = Ct(it);
                    {
                      var $e = gt => {
                          var Q = Mi();
                          Ye(re => ye(Q, re), [() => zm()]), H(gt, Q)
                        },
                        Ae = gt => {
                          var Q = Kt(),
                            re = Ct(Q);
                          {
                            var _e = ae => {
                              var ke = Mi();
                              Ye(Le => ye(ke, Le), [() => Lm()]), H(ae, ke)
                            };
                            je(re, ae => {
                              w(T) === "month" && ae(_e)
                            }, !0)
                          }
                          H(gt, Q)
                        };
                      je(tt, gt => {
                        w(T) === "week" ? gt($e) : gt(Ae, !1)
                      }, !0)
                    }
                    H(Fe, it)
                  };
                je(qe, Fe => {
                  w(T) === "today" ? Fe(Ue) : Fe(Je, !1)
                })
              }
              k(st), Ye(Fe => ye(nt, `${Fe??""} `), [() => Em()]), H(Oe, st)
            },
            Ie = Oe => {
              var st = EI(),
                nt = E(st),
                qe = E(nt),
                Ue = Z(E(qe)),
                Je = E(Ue, !0);
              k(Ue);
              var Fe = Z(Ue),
                it = E(Fe, !0);
              k(Fe), k(qe), k(nt);
              var tt = Z(nt);
              ui(tt, 31, () => w(M), $e => $e.userId, ($e, Ae, gt) => {
                const Q = ht(() => {
                  var Xt;
                  return ((Xt = Mt.data) == null ? void 0 : Xt.id) === w(Ae).userId
                });
                var re = kI();
                let _e;
                var ae = E(re),
                  ke = E(ae, !0);
                k(ae);
                var Le = Z(ae),
                  lt = E(Le),
                  We = E(lt);
                ls(We, {
                  class: "size-10 border",
                  get userId() {
                    return w(Ae).userId
                  },
                  get pictureUrl() {
                    return w(Ae).picture
                  }
                });
                var _t = Z(We, 2),
                  zt = E(_t),
                  Dt = Z(zt),
                  ot = E(Dt);
                k(Dt), k(_t);
                var dt = Z(_t, 2);
                {
                  var vt = Xt => {
                    const rr = ht(() => Ts(w(Ae).equippedFlag));
                    var er = II(),
                      It = E(er, !0);
                    k(er), Ye(() => {
                      kr(er, "data-tip", w(rr).name), ye(It, w(rr).flag)
                    }), H(Xt, er)
                  };
                  je(dt, Xt => {
                    w(Ae).equippedFlag && Xt(vt)
                  })
                }
                var ft = Z(dt, 2);
                {
                  var Tt = Xt => {
                    Ah(Xt, {
                      get username() {
                        return w(Ae).discord
                      }
                    })
                  };
                  je(ft, Xt => {
                    w(Ae).discord && Xt(Tt)
                  })
                }
                k(lt), k(Le);
                var xt = Z(Le),
                  pt = E(xt),
                  At = Z(pt);
                {
                  var Wt = Xt => {
                    var rr = AI();
                    let er;
                    rr.__click = [MI, s, Ae];
                    var It = E(rr);
                    Sm(It, {
                      class: "size-4"
                    }), k(rr), Ye((ur, yr) => {
                      er = zr(rr, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, er, ur), kr(rr, "data-tip", yr)
                    }, [() => ({
                      tooltip: w(z) > 640
                    }), () => uT()]), H(Xt, rr)
                  };
                  je(At, Xt => {
                    w(Ae).lastLatitude && w(Ae).lastLongitude && Xt(Wt)
                  })
                }
                k(xt), k(re), Ye((Xt, rr, er) => {
                  var It;
                  _e = zr(re, 1, "", null, _e, Xt), ye(ke, w(gt) + 1), zr(_t, 1, `font-semibold ${rr??""} flex gap-1`), ye(zt, `${(w(Q)?((It=Mt.data)==null?void 0:It.name)??w(Ae).name:w(Ae).name)??""} `), ye(ot, `#${w(Ae).userId??""}`), ye(pt, `${er??""} `)
                }, [() => ({
                  "bg-base-200": w(Q)
                }), () => Ri(w(Ae).userId), () => w(Ae).pixelsPainted.toLocaleString("en-US")]), sl(re, () => ol, () => ({
                  duration: 200
                })), H($e, re)
              }), k(tt), k(st), Ye(($e, Ae) => {
                ye(Je, $e), ye(it, Ae)
              }, [() => Dm(), () => Cm()]), H(Oe, st)
            };
          je(ze, Oe => {
            w(M).length === 0 ? Oe(Re) : Oe(Ie, !1)
          }, !0)
        }
        H(ge, Ee)
      };
    je(se, ge => {
      w(y) ? ge(X) : ge(me, !1)
    })
  }
  k(K), k(N), dp("innerWidth", ge => ce(z, ge, !0)), H(_, N), Fr()
}
ri(["click"]);
var DI = Lr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function jm(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = DI();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var RI = (_, s) => s.onclickback(),
  BI = Pe('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  FI = async (_, s) => {
    try {
      w(s).loading = !0, await an.giveAllianceAdmin(w(s).id), w(s).role = "admin"
    } catch {
      Vr.error(_C())
    } finally {
      w(s).loading = !1
    }
  }, OI = async (_, s, m) => {
    try {
      w(s).loading = !0, await an.banAllianceUser(w(s).id), m.data = m.data.filter(y => y.id !== w(s).id)
    } catch {
      Vr.error(NT())
    } finally {
      w(s).loading = !1
    }
  }, NI = Pe('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1), jI = Pe('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'), VI = Pe('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'), qI = Pe('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), ZI = (_, s, m) => {
    an.unbanAllianceUser(w(s).id).then(() => {
      m.data = m.data.filter(y => y.id !== w(s).id)
    }).catch(y => Vr.error(y.message)).finally(() => {
      w(s).loading = !1
    })
  }, UI = Pe('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'), $I = Pe('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'), GI = Pe('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), HI = Pe('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function WI(_, s) {
  Br(s, !0);
  let m = yi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    y = yi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var M = HI(),
    z = E(M),
    T = E(z);
  T.__click = [RI, s];
  var o = E(T);
  b1(o, {
    class: "size-5"
  }), k(T);
  var B = Z(T, 2),
    N = E(B, !0);
  k(B), k(z);
  var W = Z(z, 2),
    K = E(W);
  us(K);
  var se = Z(K, 2),
    X = E(se),
    me = E(X);
  ui(me, 21, () => m.data, Je => Je.id, (Je, Fe, it) => {
    const tt = ht(() => {
      var vt;
      return ((vt = Mt.data) == null ? void 0 : vt.id) === w(Fe).id
    });
    var $e = VI(),
      Ae = E($e),
      gt = E(Ae),
      Q = E(gt);
    ls(Q, {
      class: "size-10 border",
      get userId() {
        return w(Fe).id
      },
      get pictureUrl() {
        return w(Fe).picture
      }
    });
    var re = Z(Q, 2),
      _e = E(re);
    k(re);
    var ae = Z(re, 2);
    {
      var ke = vt => {
        var ft = BI();
        H(vt, ft)
      };
      je(ae, vt => {
        w(Fe).role === "admin" && vt(ke)
      })
    }
    k(gt), k(Ae);
    var Le = Z(Ae),
      lt = E(Le),
      We = E(lt),
      _t = E(We);
    jm(_t, {
      class: "size-4"
    }), k(We);
    var zt = Z(We, 2),
      Dt = E(zt);
    {
      var ot = vt => {
          var ft = NI(),
            Tt = Ct(ft),
            xt = E(Tt);
          xt.__click = [FI, Fe];
          var pt = E(xt, !0);
          k(xt), k(Tt);
          var At = Z(Tt, 2),
            Wt = E(At);
          Wt.__click = [OI, Fe, m];
          var Xt = E(Wt, !0);
          k(Wt), k(At), Ye((rr, er) => {
            xt.disabled = w(Fe).loading, ye(pt, rr), Wt.disabled = w(Fe).loading, ye(Xt, er)
          }, [() => wT(), () => Uv()]), H(vt, ft)
        },
        dt = vt => {
          var ft = jI(),
            Tt = E(ft);
          Tt.disabled = !0;
          var xt = E(Tt, !0);
          k(Tt), k(ft), Ye(pt => ye(xt, pt), [() => IT()]), H(vt, ft)
        };
      je(Dt, vt => {
        w(Fe).role === "member" ? vt(ot) : vt(dt, !1)
      })
    }
    k(zt), k(lt), k(Le), k($e), Ye(vt => {
      var ft;
      zr(re, 1, `font-semibold ${vt??""}`), ye(_e, `${(w(tt)?((ft=Mt.data)==null?void 0:ft.name)??w(Fe).name:w(Fe).name)??""} #${w(Fe).id??""}`)
    }, [() => Ri(w(Fe).id)]), H(Je, $e)
  }), k(me), k(X);
  var ge = Z(X, 2);
  {
    var Ee = Je => {
      var Fe = Kt(),
        it = Ct(Fe);
      ju(it, () => m.page, tt => {
        var $e = qI();
        Yi($e, () => Ae => {
          const gt = new IntersectionObserver(Q => {
            Q[0].isIntersecting && !m.loading && (m.loading = !0, an.getAllianceMembers(m.page).then(re => {
              m.data = [...m.data, ...re.data], m.hasNextPage = re.hasNext, m.page++
            }).catch(re => {
              Vr.error(re.message)
            }).finally(() => {
              m.loading = !1
            }))
          });
          return gt.observe(Ae), () => {
            gt.disconnect()
          }
        }), H(tt, $e)
      }), H(Je, Fe)
    };
    je(ge, Je => {
      m.hasNextPage && Je(Ee)
    })
  }
  k(se);
  var ze = Z(se, 2),
    Re = Z(ze, 2),
    Ie = E(Re),
    Oe = E(Ie);
  ui(Oe, 21, () => y.data, Je => Je.id, (Je, Fe, it) => {
    var tt = UI(),
      $e = E(tt),
      Ae = E($e),
      gt = E(Ae);
    ls(gt, {
      class: "size-10 border",
      get userId() {
        return w(Fe).id
      },
      get pictureUrl() {
        return w(Fe).picture
      }
    });
    var Q = Z(gt, 2),
      re = E(Q);
    k(Q), k(Ae), k($e);
    var _e = Z($e),
      ae = E(_e);
    ae.__click = [ZI, Fe, y];
    var ke = E(ae, !0);
    k(ae), k(_e), k(tt), Ye((Le, lt) => {
      zr(Q, 1, `font-semibold ${Le??""}`), ye(re, `${w(Fe).name??""} #${w(Fe).id??""}`), ae.disabled = w(Fe).loading, ye(ke, lt)
    }, [() => Ri(w(Fe).id), () => kT()]), H(Je, tt)
  }), k(Oe), k(Ie);
  var st = Z(Ie, 2);
  {
    var nt = Je => {
      var Fe = $I(),
        it = E(Fe, !0);
      k(Fe), Ye(tt => ye(it, tt), [() => LT()]), H(Je, Fe)
    };
    je(st, Je => {
      !y.hasNextPage && y.data.length === 0 && Je(nt)
    })
  }
  var qe = Z(st, 2);
  {
    var Ue = Je => {
      var Fe = Kt(),
        it = Ct(Fe);
      ju(it, () => y.page, tt => {
        var $e = GI();
        Yi($e, () => Ae => {
          const gt = new IntersectionObserver(Q => {
            Q[0].isIntersecting && !y.loading && (y.loading = !0, an.getAllianceBannedMembers(y.page).then(re => {
              y.data = [...y.data, ...re.data], y.hasNextPage = re.hasNext, y.page++
            }).catch(re => {
              Vr.error(re.message)
            }).finally(() => {
              y.loading = !1
            }))
          });
          return gt.observe(Ae), () => {
            gt.disconnect()
          }
        }), H(tt, $e)
      }), H(Je, Fe)
    };
    je(qe, Je => {
      y.hasNextPage && Je(Ue)
    })
  }
  k(Re), k(W), k(M), Ye((Je, Fe, it) => {
    ye(N, Je), kr(K, "aria-label", Fe), kr(ze, "aria-label", it)
  }, [() => qv(), () => qT(), () => $v()]), H(_, M), Fr()
}
ri(["click"]);
var XI = Pe('<span class="label"> </span>'),
  YI = Pe('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  KI = Pe('<p class="text-error ml-3 text-sm"> </p>'),
  JI = Pe('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function Xf(_, s) {
  Br(s, !0);
  let m = Et(s, "value", 15),
    y = Et(s, "validate", 15),
    M = ut("");
  const z = ht(() => {
    var ze;
    return ((ze = m()) == null ? void 0 : ze.length) ?? 0
  });
  y(T);

  function T() {
    return s.min !== void 0 && w(z) < s.min ? (ce(M, w(z) === 0 ? "Required" : `Min. characters: ${s.min}`, !0), !1) : s.max !== void 0 && w(z) > s.max ? (ce(M, `Max. characters: ${s.max}`), !1) : !0
  }
  Xr(() => {
    var ze;
    s.max !== void 0 && w(z) > s.max && m((ze = m()) == null ? void 0 : ze.substring(0, s.max))
  });
  var o = JI(),
    B = E(o);
  let N;
  var W = E(B);
  {
    var K = ze => {
      var Re = XI(),
        Ie = E(Re, !0);
      k(Re), Ye(() => ye(Ie, s.label)), H(ze, Re)
    };
    je(W, ze => {
      s.label && ze(K)
    })
  }
  var se = Z(W, 2);
  us(se);
  var X = Z(se, 2);
  {
    var me = ze => {
      var Re = YI(),
        Ie = E(Re, !0);
      k(Re), Ye(() => ye(Ie, s.max - w(z))), H(ze, Re)
    };
    je(X, ze => {
      s.max !== void 0 && ze(me)
    })
  }
  k(B);
  var ge = Z(B, 2);
  {
    var Ee = ze => {
      var Re = KI(),
        Ie = E(Re, !0);
      k(Re), Ye(() => ye(Ie, w(M))), H(ze, Re)
    };
    je(ge, ze => {
      w(M) && ze(Ee)
    })
  }
  k(o), Ye(ze => {
    N = zr(B, 1, "input w-full", null, N, ze), kr(se, "placeholder", s.placeholder), kr(se, "maxlength", s.max)
  }, [() => ({
    "input-error": !!w(M)
  })]), Mm(se, m), H(_, o), Fr()
}
var QI = (_, s) => {
    var m;
    (m = s()) == null || m.close()
  },
  eM = Pe('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function tM(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15),
    y = ut(!1),
    M = ut(""),
    z = ut(void 0);
  An(() => {
    const Re = Ie => {
      var Oe;
      Ie.key === "Escape" && ((Oe = m()) == null || Oe.close())
    };
    return document.addEventListener("keydown", Re), () => document.removeEventListener("keydown", Re)
  });
  var T = eM(),
    o = E(T),
    B = E(o),
    N = E(B, !0);
  k(B);
  var W = Z(B, 2),
    K = E(W),
    se = E(K);
  {
    let Re = ht(() => Hf()),
      Ie = ht(() => _T());
    Xf(se, {
      get label() {
        return w(Re)
      },
      get placeholder() {
        return w(Ie)
      },
      min: 1,
      max: 16,
      get value() {
        return w(M)
      },
      set value(Oe) {
        ce(M, Oe, !0)
      },
      get validate() {
        return w(z)
      },
      set validate(Oe) {
        ce(z, Oe, !0)
      }
    })
  }
  k(K);
  var X = Z(K, 2),
    me = E(X);
  me.__click = [QI, m];
  var ge = E(me, !0);
  k(me);
  var Ee = Z(me, 2),
    ze = E(Ee, !0);
  k(Ee), k(X), k(W), k(o), _n(2), k(T), Xs(T, Re => m(Re), () => m()), Ye((Re, Ie, Oe) => {
    ye(N, Re), me.disabled = w(y), ye(ge, Ie), Ee.disabled = w(y), ye(ze, Oe)
  }, [() => pT(), () => Tm(), () => yT()]), Ai("submit", W, async () => {
    var Re, Ie;
    try {
      if (!((Re = w(z)) != null && Re())) return;
      ce(y, !0);
      const {
        id: Oe
      } = await an.createAlliance(w(M));
      await s.onsuccess(Oe), (Ie = m()) == null || Ie.close()
    } catch (Oe) {
      Vr.error(Oe.message)
    } finally {
      ce(y, !1)
    }
  }), H(_, T), Fr()
}
ri(["click"]);
var rM = Lr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function kh(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = rM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var nM = Lr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'),
  iM = Lr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');

function Yf(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = Kt(),
    M = Ct(y);
  {
    var z = o => {
        var B = nM();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      },
      T = o => {
        var B = iM();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      };
    je(M, o => {
      s.filled ? o(z) : o(T, !1)
    })
  }
  H(_, y)
}
var aM = Lr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function sM(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = aM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var oM = Lr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function lM(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = oM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var cM = Lr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function uM(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = cM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var hM = Lr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function _p(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = hM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}

function dM(_, s = "_blank") {
  return _.replaceAll(/https?:\/\/[^\s]+/g, m => `<a href="${m}"${s?` target="${s}"`:""}>${m}</a>`)
}
var pM = Pe('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  fM = async (_, s, m, y) => {
    try {
      ce(s, !0), await an.leaveAlliance(), ce(m, !0), await y()
    } catch (M) {
      Vr.error(M.message)
    } finally {
      ce(s, !1)
    }
  }, mM = (_, s) => {
    ce(s, !0)
  }, _M = Pe('<div class="tooltip"><button class="btn"><!></button></div>'), gM = (_, s) => {
    var m;
    (m = w(s)) == null || m.show()
  }, vM = Pe('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'), yM = Pe('<section class="text-base-content/80 highlight-link"><!> <!></section>'), xM = Pe('<span class="font-semibold"> </span>'), bM = (_, s) => ce(s, !0), wM = Pe('<button class="text-primary font-semibold underline"> </button>'), TM = (_, s, m) => {
    var y;
    (y = w(s)) != null && y.hq ? m.onhqclick({
      lat: w(s).hq.latitude,
      lng: w(s).hq.longitude
    }) : m.onhqchange()
  }, SM = Pe('<span class="text-primary underline"> </span>'), CM = Pe('<span class="text-primary underline"> </span>'), PM = Pe('<button class="text-base-content/80 p-1"><!></button>'), IM = Pe('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'), MM = Pe('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1), AM = (_, s) => {
    var m;
    (m = w(s)) == null || m.show()
  }, kM = Pe('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1), EM = Pe('<div class="h-full"><!></div>');

function zM(_, s) {
  Br(s, !0);
  let m = ut(void 0),
    y = ut(!0),
    M = ut(void 0),
    z = ut(!1),
    T = ut(void 0),
    o = ut(!1),
    B = ut(!1),
    N = ut(() => {});
  Mc(() => s.open, () => {
    s.open && Wd.shouldReload && W()
  }), An(() => {
    const ge = setInterval(() => {
      Wd.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(ge)
    }
  });
  async function W() {
    try {
      ce(m, await an.getAlliance(), !0), w(m) && w(N)(), ce(y, !1), Wd.shouldReload = !1
    } catch (ge) {
      Vr.error(ge.message)
    }
  }
  var K = EM(),
    se = E(K);
  {
    var X = ge => {
        var Ee = pM();
        H(ge, Ee)
      },
      me = ge => {
        var Ee = Kt(),
          ze = Ct(Ee);
        {
          var Re = Oe => {
              WI(Oe, {
                onclickback: () => ce(B, !1)
              })
            },
            Ie = Oe => {
              var st = Kt(),
                nt = Ct(st);
              {
                var qe = Je => {
                    var Fe = MM(),
                      it = Ct(Fe),
                      tt = E(it),
                      $e = E(tt, !0);
                    k(tt);
                    var Ae = Z(tt, 2),
                      gt = E(Ae),
                      Q = E(gt),
                      re = E(Q);
                    jm(re, {
                      class: "size-4"
                    }), k(Q);
                    var _e = Z(Q, 2),
                      ae = E(_e),
                      ke = E(ae);
                    ke.__click = [fM, z, y, W];
                    var Le = E(ke, !0);
                    k(ke), k(ae), k(_e), k(gt);
                    var lt = Z(gt, 2);
                    {
                      var We = ue => {
                        var j = _M(),
                          U = E(j);
                        U.__click = [mM, o];
                        var Y = E(U);
                        uM(Y, {
                          class: "size-4"
                        }), k(U), k(j), Ye(ie => kr(j, "data-tip", ie), [() => q3()]), H(ue, j)
                      };
                      je(lt, ue => {
                        w(m).role == "admin" && ue(We)
                      })
                    }
                    k(Ae), k(it);
                    var _t = Z(it, 2);
                    {
                      var zt = ue => {
                        var j = yM(),
                          U = E(j);
                        Av(U, () => dM(w(m).description || Zv()));
                        var Y = Z(U, 2);
                        {
                          var ie = he => {
                            var Te = vM();
                            Te.__click = [gM, T];
                            var Me = E(Te);
                            Yf(Me, {
                              class: "size-4"
                            }), k(Te), H(he, Te)
                          };
                          je(Y, he => {
                            w(m).role === "admin" && he(ie)
                          })
                        }
                        k(j), H(ue, j)
                      };
                      je(_t, ue => {
                        (w(m).description || w(m).role === "admin") && ue(zt)
                      })
                    }
                    var Dt = Z(_t, 2),
                      ot = E(Dt),
                      dt = E(ot);
                    kh(dt, {
                      class: "inline size-4"
                    });
                    var vt = Z(dt, 2),
                      ft = E(vt),
                      Tt = Z(ft),
                      xt = E(Tt, !0);
                    k(Tt), k(vt), k(ot);
                    var pt = Z(ot, 2),
                      At = E(pt);
                    _p(At, {
                      class: "inline size-4"
                    });
                    var Wt = Z(At, 2),
                      Xt = E(Wt),
                      rr = Z(Xt);
                    {
                      var er = ue => {
                          var j = xM(),
                            U = E(j, !0);
                          k(j), Ye(Y => ye(U, Y), [() => w(m).members.toLocaleString("en-US")]), H(ue, j)
                        },
                        It = ue => {
                          var j = wM();
                          j.__click = [bM, B];
                          var U = E(j, !0);
                          k(j), Ye(Y => ye(U, Y), [() => w(m).members.toLocaleString("en-US")]), H(ue, j)
                        };
                      je(rr, ue => {
                        w(m).role === "member" ? ue(er) : ue(It, !1)
                      })
                    }
                    k(Wt), k(pt);
                    var ur = Z(pt, 2);
                    {
                      var yr = ue => {
                        var j = IM(),
                          U = E(j);
                        sM(U, {
                          class: "inline size-4"
                        });
                        var Y = Z(U, 2),
                          ie = E(Y),
                          he = Z(ie);
                        he.__click = [TM, m, s];
                        var Te = E(he);
                        {
                          var Me = Qe => {
                              var kt = SM(),
                                xe = E(kt);
                              k(kt), Ye((Nt, Jt) => ye(xe, `${Nt??""}, ${Jt??""}`), [() => w(m).hq.latitude.toFixed(3), () => w(m).hq.longitude.toFixed(3)]), H(Qe, kt)
                            },
                            we = Qe => {
                              var kt = CM(),
                                xe = E(kt, !0);
                              k(kt), Ye(Nt => ye(xe, Nt), [() => g3()]), H(Qe, kt)
                            };
                          je(Te, Qe => {
                            w(m).hq ? Qe(Me) : Qe(we, !1)
                          })
                        }
                        k(he), k(Y);
                        var Ne = Z(Y, 2);
                        {
                          var ct = Qe => {
                            var kt = PM();
                            kt.__click = function(...Nt) {
                              var Jt;
                              (Jt = s.onhqchange) == null || Jt.apply(this, Nt)
                            };
                            var xe = E(kt);
                            Yf(xe, {
                              class: "text-base-content/50 size-4"
                            }), k(kt), H(Qe, kt)
                          };
                          je(Ne, Qe => {
                            w(m).role === "admin" && Qe(ct)
                          })
                        }
                        k(j), Ye(Qe => ye(ie, `${Qe??""}: `), [() => f3()]), H(ue, j)
                      };
                      je(ur, ue => {
                        (w(m).hq || w(m).role === "admin") && ue(yr)
                      })
                    }
                    k(Dt);
                    var Mr = Z(Dt, 2),
                      Gr = E(Mr),
                      xr = E(Gr, !0);
                    k(Gr);
                    var Sr = Z(Gr, 2),
                      wr = E(Sr);
                    LI(wr, {
                      get allianceId() {
                        return w(m).id
                      },
                      get onlastpixelclick() {
                        return s.onlastpixelclick
                      },
                      get reload() {
                        return w(N)
                      },
                      set reload(ue) {
                        ce(N, ue, !0)
                      }
                    }), k(Sr), k(Mr);
                    var gr = Z(Mr, 2);
                    uI(gr, {
                      get description() {
                        return w(m).description
                      },
                      onsuccess: async ue => {
                        w(m) && (w(m).description = ue)
                      },
                      get ref() {
                        return w(T)
                      },
                      set ref(ue) {
                        ce(T, ue, !0)
                      }
                    });
                    var Ar = Z(gr, 2);
                    fI(Ar, {
                      get open() {
                        return w(o)
                      },
                      set open(ue) {
                        ce(o, ue, !0)
                      }
                    }), Ye((ue, j, U, Y, ie) => {
                      ye($e, w(m).name), ke.disabled = w(z), ye(Le, ue), ye(ft, `${j??""}: `), ye(xt, U), ye(Xt, `${Y??""}: `), ye(xr, ie)
                    }, [() => c3(), () => Cm(), () => w(m).pixelsPainted.toLocaleString("en-US"), () => qv(), () => Am()]), H(Je, Fe)
                  },
                  Ue = Je => {
                    var Fe = kM(),
                      it = Ct(Fe),
                      tt = E(it),
                      $e = E(tt);
                    k(tt);
                    var Ae = Z(tt, 2),
                      gt = E(Ae);
                    lM(gt, {
                      class: "size-5"
                    });
                    var Q = Z(gt, 1, !0);
                    k(Ae);
                    var re = Z(Ae, 2),
                      _e = E(re),
                      ae = E(_e, !0);
                    k(_e), k(re);
                    var ke = Z(re, 2);
                    ke.__click = [AM, M];
                    var Le = E(ke);
                    zv(Le, {
                      class: "size-6"
                    });
                    var lt = Z(Le);
                    k(ke), k(it);
                    var We = Z(it, 2);
                    tM(We, {
                      onsuccess: W,
                      get ref() {
                        return w(M)
                      },
                      set ref(_t) {
                        ce(M, _t, !0)
                      }
                    }), Ye((_t, zt, Dt, ot) => {
                      ye($e, `${_t??""}:`), ye(Q, zt), ye(ae, Dt), ye(lt, ` ${ot??""}`)
                    }, [() => x3(), () => T3(), () => P3(), () => A3()]), H(Je, Fe)
                  };
                je(nt, Je => {
                  w(m) ? Je(qe) : Je(Ue, !1)
                }, !0)
              }
              H(Oe, st)
            };
          je(ze, Oe => {
            w(B) ? Oe(Re) : Oe(Ie, !1)
          }, !0)
        }
        H(ge, Ee)
      };
    je(se, ge => {
      w(y) ? ge(X) : ge(me, !1)
    })
  }
  k(K), H(_, K), Fr()
}
ri(["click"]);
var LM = Lr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function gp(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = LM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var DM = Pe('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function RM(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  An(() => {
    const K = se => {
      se.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", K), () => document.removeEventListener("keydown", K)
  });
  var y = DM(),
    M = E(y),
    z = Z(E(M), 2),
    T = E(z);
  gp(T, {
    class: "size-5 max-sm:size-6"
  });
  var o = Z(T, 2),
    B = E(o, !0);
  k(o), k(z);
  var N = Z(z, 2),
    W = E(N);
  zM(W, {
    get open() {
      return m()
    },
    get onhqchange() {
      return s.onhqchange
    },
    get onhqclick() {
      return s.onhqclick
    },
    get onlastpixelclick() {
      return s.onlastpixelclick
    }
  }), k(N), k(M), _n(2), k(y), Yi(y, () => K => {
    Xr(() => {
      m() ? (K.show(), wa.url.searchParams.get("alliance") && (wa.url.searchParams.delete("alliance"), Mv(wa.url.toString()))) : K.close()
    })
  }), Ye(K => ye(B, K), [() => pp()]), Ai("close", y, () => m(!1)), Ii(2, N, () => aa, () => ({
    duration: 300
  })), H(_, y), Fr()
}

function BM(_, s, m) {
  return new Promise((y, M) => {
    _.once("render", () => {
      const z = _.getCanvas().toDataURL(),
        T = document.createElement("img");
      T.src = z, T.onload = () => {
        const o = document.createElement("canvas");
        o.width = T.width, o.height = T.height;
        const B = o.getContext("2d");
        if (B) {
          B.drawImage(T, 0, 0);
          const [N, W, K, se] = B.getImageData(s, m, 1, 1).data;
          y([N, W, K, se])
        } else M(new Error("Could not get 2d context from canvas"));
        T.remove(), o.remove()
      }
    }), _.triggerRepaint()
  })
}

function e0(_, s) {
  return new Promise((m, y) => {
    _.once("render", () => {
      const M = _.getCanvas();
      let z = M;
      if (s != null && s.maxWidth || s != null && s.maxHeight) {
        const T = M.width,
          o = M.height,
          B = (s == null ? void 0 : s.maxWidth) ?? T,
          N = (s == null ? void 0 : s.maxHeight) ?? o;
        z = document.createElement("canvas");
        const W = Math.min(B / T, N / o);
        z.width = Math.floor(T * W), z.height = Math.floor(o * W);
        const K = z.getContext("2d");
        K && K.drawImage(M, 0, 0, z.width, z.height)
      }
      try {
        z.toBlob(T => {
          T && m(T)
        }, (s == null ? void 0 : s.type) ?? "image/png", (s == null ? void 0 : s.quality) ?? 1)
      } catch (T) {
        y(T)
      } finally {
        z !== M && z.remove()
      }
    })
  })
}
var FM = Lr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function OM(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = FM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var NM = Lr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function t0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = NM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
const mc = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function ep(_) {
  const s = Math.floor(_ / mc.hour);
  _ -= s * mc.hour;
  const m = Math.floor(_ / mc.min);
  _ -= m * mc.min;
  const M = Math.floor(_ / mc.sec).toString().padStart(2, "0");
  return s > 0 ? `${s}:${m.toString().padStart(2,"0")}:${M}` : `${m}:${M}`
}

function jM(_) {
  const s = new Date,
    m = s.getFullYear(),
    y = String(s.getMonth() + 1).padStart(2, "0"),
    M = String(s.getDate()).padStart(2, "0"),
    z = String(s.getHours()).padStart(2, "0"),
    T = String(s.getMinutes()).padStart(2, "0"),
    o = String(s.getSeconds()).padStart(2, "0");
  return `${m}-${y}-${M} ${z}:${T}:${o}`
}
var VM = (_, s, m) => {
    navigator.clipboard.writeText(s.url.toString()), ce(m, !0), setTimeout(() => {
      ce(m, !1)
    }, 1e3)
  },
  qM = Pe('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  ZM = Pe('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  UM = async (_, s) => {
    w(s) && (await navigator.clipboard.write([new ClipboardItem({
      "image/png": w(s)
    })]), Vr.info(uP()))
  }, $M = Pe('<div><h3 class="mb-1 mt-5 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'), GM = Pe('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function HM(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15),
    y = ut(!1);
  An(() => {
    const Ie = Oe => {
      Oe.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", Ie), () => document.removeEventListener("keydown", Ie)
  });
  let M = ut(null),
    z = ut("");
  Xr(() => {
    m() ? (s.hideHover(), setTimeout(async () => {
      e0(s.map).then(Ie => {
        ce(M, Ie, !0), ce(z, URL.createObjectURL(w(M)), !0)
      }).finally(() => {
        s.showHover()
      })
    }, 500)) : w(z) && (URL.revokeObjectURL(w(z)), ce(M, null), ce(z, ""))
  });
  var T = GM(),
    o = E(T),
    B = Z(E(o), 2),
    N = E(B);
  t0(N, {
    class: "size-5"
  });
  var W = Z(N);
  k(B);
  var K = Z(B, 2),
    se = E(K);
  us(se);
  var X = Z(se, 2),
    me = E(X);
  let ge;
  me.__click = [VM, s, y];
  var Ee = E(me, !0);
  k(me), k(X), k(K);
  var ze = Z(K, 2);
  {
    var Re = Ie => {
      const Oe = ht(() => {
        var ae;
        return (ae = s.map) == null ? void 0 : ae.getCanvas()
      });
      var st = $M(),
        nt = E(st),
        qe = E(nt);
      OM(qe, {
        class: "inline size-5"
      });
      var Ue = Z(qe);
      k(nt);
      var Je = Z(nt, 2);
      {
        var Fe = ae => {
            var ke = qM();
            Ye(() => {
              kr(ke, "src", w(z)), kr(ke, "width", w(Oe).width), kr(ke, "height", w(Oe).height)
            }), H(ae, ke)
          },
          it = ae => {
            var ke = ZM();
            Ye(() => Ic(ke, `aspect-ratio: ${w(Oe).width/w(Oe).height}`)), H(ae, ke)
          };
        je(Je, ae => {
          w(z) ? ae(Fe) : ae(it, !1)
        })
      }
      var tt = Z(Je, 2),
        $e = E(tt);
      $e.__click = [UM, M];
      var Ae = E($e);
      Pm(Ae, {
        class: "size-5"
      });
      var gt = Z(Ae);
      k($e);
      var Q = Z($e, 2),
        re = E(Q);
      kv(re, {
        class: "size-5"
      });
      var _e = Z(re);
      k(Q), k(tt), k(st), Ye((ae, ke, Le, lt) => {
        ye(Ue, ` ${ae??""}`), ye(gt, ` ${ke??""}`), kr(Q, "href", w(z)), kr(Q, "download", `wplace_${Le??""}.png`), ye(_e, ` ${lt??""}`)
      }, [() => iP(), () => $f(), () => jM().replaceAll(" ", "_").replaceAll(":", "-"), () => oP()]), Ii(2, st, () => aa, () => ({
        duration: 300
      })), H(Ie, st)
    };
    je(ze, Ie => {
      m() && Ie(Re)
    })
  }
  k(o), _n(2), k(T), Yi(T, () => Ie => {
    Xr(() => {
      m() ? Ie.show() : Ie.close()
    })
  }), Ye((Ie, Oe, st, nt) => {
    ye(W, ` ${Ie??""}`), Pv(se, Oe), ge = zr(me, 1, "btn btn-primary", null, ge, st), ye(Ee, nt)
  }, [() => ES(), () => s.url.toString(), () => ({
    "btn-success": w(y)
  }), () => w(y) ? km() : $f()]), Ai("close", T, () => m(!1)), H(_, T), Fr()
}
ri(["click"]);
var WM = Lr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function XM(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = WM();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var YM = Pe('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  KM = Pe('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p></div></div>');

function Vm(_, s) {
  Br(s, !1);
  const m = [Zw(), jw(), Gw(), Xw(), Jw(), t5(), i5()];
  Rv();
  var y = KM(),
    M = E(y),
    z = E(M);
  XM(z, {
    class: "size-5"
  });
  var T = Z(z, 2),
    o = E(T),
    B = Z(o),
    N = E(B, !0);
  k(B), k(T), k(M);
  var W = Z(M, 2),
    K = E(W);
  ui(K, 5, () => m, cp, (me, ge) => {
    var Ee = YM(),
      ze = E(Ee, !0);
    k(Ee), Ye(() => ye(ze, w(ge))), H(me, Ee)
  }), k(K);
  var se = Z(K, 2),
    X = E(se, !0);
  k(se), k(W), k(y), Ye((me, ge, Ee) => {
    ye(o, `${me??""} `), ye(N, ge), ye(X, Ee)
  }, [() => Dw(), () => Fw(), () => o5()]), H(_, y), Fr()
}
var JM = (_, s) => {
    s(!1)
  },
  QM = Pe('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">📑 Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function e4(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  An(() => {
    const N = W => {
      W.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", N), () => document.removeEventListener("keydown", N)
  });
  var y = QM(),
    M = E(y),
    z = Z(E(M), 2),
    T = Z(E(z), 2),
    o = E(T);
  Vm(o, {}), k(T);
  var B = Z(T, 2);
  B.__click = [JM, m], k(z), k(M), _n(2), k(y), Yi(y, () => N => {
    Xr(() => {
      m() ? N.show() : N.close()
    })
  }), Ai("close", y, () => m(!1)), H(_, y), Fr()
}
ri(["click"]);
var t4 = () => {
    wa.url.searchParams.delete("new-user"), Mv(wa.url.toString())
  },
  r4 = Pe('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function n4(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  An(() => {
    const ge = Ee => {
      Ee.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", ge), () => document.removeEventListener("keydown", ge)
  });
  var y = r4(),
    M = E(y),
    z = E(M),
    T = E(z),
    o = E(T),
    B = E(o, !0);
  k(o);
  var N = Z(o, 2);
  Bv(N, {
    hasText: !0,
    size: "medium"
  }), k(T), k(z);
  var W = Z(z, 2),
    K = E(W);
  Vm(K, {}), k(W);
  var se = Z(W, 2),
    X = E(se);
  X.__click = [t4];
  var me = E(X, !0);
  k(X), k(se), k(M), k(y), Yi(y, () => ge => {
    Xr(() => {
      m() ? ge.show() : ge.close()
    })
  }), Ye((ge, Ee) => {
    ye(B, ge), ye(me, Ee)
  }, [() => Ew(), () => u5()]), Ai("close", y, () => m(!1)), H(_, y), Fr()
}
ri(["click"]);

function i4() {
  const _ = navigator.userAgent,
    s = navigator.vendor;
  return /Chrome/.test(_) && /Google Inc/.test(s) ? "Chrome" : /Safari/.test(_) && /Apple Computer/.test(s) ? "Safari" : /Firefox/.test(_) ? "Firefox" : /Edge/.test(_) ? "Edge" : /Opera|OPR/.test(_) ? "Opera" : "Unknown"
}
var a4 = Lr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function s4(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = a4();
  or(y, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...m
  })), H(_, y)
}
var o4 = Lr('<svg><path fill="#0A0A08" d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function l4(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = o4();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 256 256",
    ...m
  })), H(_, y)
}
var c4 = Lr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function tp(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = c4();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var u4 = Pe(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  h4 = Pe('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  d4 = Pe('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  p4 = Pe(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
  f4 = Pe('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a class="link" href="https://www.reddit.com/r/WplaceLive/comments/1lhzmmq/bug_reports_and_feature_requests/" target="_blank"> </a> <span class="mx-0.5">|</span> <a href="https://discord.gg/wplacelive" target="_blank"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank"><!> <span class="link">Instagram</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> · <a class="link" href="https://wplace.live/terms/terms-of-service" target="_blank"> </a> · <a class="link" href="https://wplace.live/terms/privacy" target="_blank"> </a> · <a class="link" href="https://wplace.live/terms/return" target="_blank"> </a></section></div>'),
  m4 = Pe('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function _4(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  An(() => {
    const K = se => {
      se.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", K), () => document.removeEventListener("keydown", K)
  });
  const y = i4();
  var M = m4(),
    z = E(M),
    T = Z(E(z), 2);
  {
    var o = K => {
      var se = f4(),
        X = E(se),
        me = E(X);
      Bv(me, {
        hasText: !0,
        size: "medium"
      });
      var ge = Z(me, 2),
        Ee = E(ge),
        ze = Z(Ee, 4);
      _n(), k(ge);
      var Re = Z(ge, 2),
        Ie = E(Re),
        Oe = E(Ie),
        st = E(Oe, !0);
      k(Oe);
      var nt = Z(Oe, 4),
        qe = E(nt);
      Om(qe, {
        class: "mr-0.5 inline size-4"
      }), _n(2), k(nt);
      var Ue = Z(nt, 4),
        Je = E(Ue);
      s4(Je, {
        class: "mr-0.5 inline size-4"
      }), _n(2), k(Ue);
      var Fe = Z(Ue, 4),
        it = E(Fe);
      l4(it, {
        class: "mr-0.5 inline size-4"
      }), _n(2), k(Fe), k(Ie), k(Re), k(X);
      var tt = Z(X, 2),
        $e = E(tt),
        Ae = E($e, !0);
      k($e);
      var gt = Z($e, 2);
      k(tt);
      var Q = Z(tt, 2),
        re = E(Q),
        _e = E(re, !0);
      k(re);
      var ae = Z(re, 2),
        ke = E(ae),
        Le = Z(ke),
        lt = E(Le);
      tp(lt, {
        class: "size-5"
      }), k(Le);
      var We = Z(Le);
      k(ae);
      var _t = Z(ae, 2),
        zt = E(_t),
        Dt = Z(zt),
        ot = E(Dt, !0);
      k(Dt);
      var dt = Z(Dt);
      k(_t), k(Q);
      var vt = Z(Q, 2),
        ft = E(vt),
        Tt = E(ft, !0);
      k(ft);
      var xt = Z(ft, 2),
        pt = E(xt);
      {
        var At = Sr => {
            var wr = u4(),
              gr = Ct(wr);
            _n(), Ye(Ar => ye(gr, `${Ar??""}: `), [() => CP()]), H(Sr, wr)
          },
          Wt = Sr => {
            var wr = p4(),
              gr = Ct(wr),
              Ar = Z(gr),
              ue = E(Ar, !0);
            k(Ar);
            var j = Z(Ar),
              U = Z(j);
            {
              var Y = he => {
                  var Te = h4();
                  _n(), H(he, Te)
                },
                ie = he => {
                  var Te = Kt(),
                    Me = Ct(Te);
                  {
                    var we = Ne => {
                      var ct = d4();
                      _n(), H(Ne, ct)
                    };
                    je(Me, Ne => {
                      y === "Edge" && Ne(we)
                    }, !0)
                  }
                  H(he, Te)
                };
              je(U, he => {
                y === "Chrome" ? he(Y) : he(ie, !1)
              })
            }
            Ye((he, Te, Me) => {
              ye(gr, `${he??""} `), ye(ue, Te), ye(j, ` ${Me??""} `)
            }, [() => _P(), () => yP(), () => wP()]), H(Sr, wr)
          };
        je(pt, Sr => {
          y !== "Chrome" && y !== "Edge" ? Sr(At) : Sr(Wt, !1)
        })
      }
      k(xt), k(vt);
      var Xt = Z(vt, 2),
        rr = E(Xt);
      Vm(rr, {}), k(Xt);
      var er = Z(Xt, 4),
        It = Z(E(er), 2),
        ur = E(It, !0);
      k(It);
      var yr = Z(It, 2),
        Mr = E(yr, !0);
      k(yr);
      var Gr = Z(yr, 2),
        xr = E(Gr, !0);
      k(Gr), k(er), k(se), Ye((Sr, wr, gr, Ar, ue, j, U, Y, ie, he, Te, Me, we, Ne) => {
        ye(Ee, `${Sr??""} `), ye(ze, ` ©
						${wr??""} `), ye(st, gr), ye(Ae, Ar), kr(gt, "src", fa.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), ye(_e, ue), ye(ke, `${j??""} `), ye(We, ` ${U??""}`), ye(zt, `${Y??""} `), ye(ot, ie), ye(dt, ` ${he??""}`), ye(Tt, Te), ye(ur, Me), ye(Mr, we), ye(xr, Ne)
      }, [() => Cb(), () => Mb(), () => Eb(), () => Db(), () => Fb(), () => jb(), () => Zb(), () => Gb(), () => Xb(), () => Jb(), () => pP(), () => EP(), () => DP(), () => FP()]), Ii(2, se, () => aa, () => ({
        duration: 300
      })), H(K, se)
    };
    je(T, K => {
      m() && K(o)
    })
  }
  k(z);
  var B = Z(z, 2),
    N = E(B),
    W = E(N, !0);
  k(N), k(B), k(M), Yi(M, () => K => {
    Xr(() => {
      m() ? K.show() : K.close()
    })
  }), Ye(K => ye(W, K), [() => vc()]), Ai("close", M, () => m(!1)), H(_, M), Fr()
}

function g4(_) {
  return typeof _ == "function"
}

function Eh(_) {
  return _ !== null && typeof _ == "object"
}
const v4 = ["string", "number", "bigint", "boolean"];

function Kf(_) {
  return _ == null || v4.includes(typeof _) ? !0 : Array.isArray(_) ? _.every(s => Kf(s)) : typeof _ == "object" ? Object.getPrototypeOf(_) === Object.prototype : !1
}
const Vu = Symbol("box"),
  qm = Symbol("is-writable");

function y4(_) {
  return Eh(_) && Vu in _
}

function x4(_) {
  return _r.isBox(_) && qm in _
}

function _r(_) {
  let s = ut(yi(_));
  return {
    [Vu]: !0,
    [qm]: !0,
    get current() {
      return w(s)
    },
    set current(m) {
      ce(s, m, !0)
    }
  }
}

function b4(_, s) {
  const m = ht(_);
  return s ? {
    [Vu]: !0,
    [qm]: !0,
    get current() {
      return w(m)
    },
    set current(y) {
      s(y)
    }
  } : {
    [Vu]: !0,
    get current() {
      return _()
    }
  }
}

function w4(_) {
  return _r.isBox(_) ? _ : g4(_) ? _r.with(_) : _r(_)
}

function T4(_) {
  return Object.entries(_).reduce((s, [m, y]) => _r.isBox(y) ? (_r.isWritableBox(y) ? Object.defineProperty(s, m, {
    get() {
      return y.current
    },
    set(M) {
      y.current = M
    }
  }) : Object.defineProperty(s, m, {
    get() {
      return y.current
    }
  }), s) : Object.assign(s, {
    [m]: y
  }), {})
}

function S4(_) {
  return _r.isWritableBox(_) ? {
    [Vu]: !0,
    get current() {
      return _.current
    }
  } : _
}
_r.from = w4;
_r.with = b4;
_r.flatten = T4;
_r.readonly = S4;
_r.isBox = y4;
_r.isWritableBox = x4;

function C4(..._) {
  return function(s) {
    var m;
    for (const y of _)
      if (y) {
        if (s.defaultPrevented) return;
        typeof y == "function" ? y.call(this, s) : (m = y.current) == null || m.call(this, s)
      }
  }
}
var cc = {},
  zf, Kg;

function P4() {
  if (Kg) return zf;
  Kg = 1;
  var _ = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
    s = /\n/g,
    m = /^\s*/,
    y = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
    M = /^:\s*/,
    z = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
    T = /^[;\s]*/,
    o = /^\s+|\s+$/g,
    B = `
`,
    N = "/",
    W = "*",
    K = "",
    se = "comment",
    X = "declaration";
  zf = function(ge, Ee) {
    if (typeof ge != "string") throw new TypeError("First argument must be a string");
    if (!ge) return [];
    Ee = Ee || {};
    var ze = 1,
      Re = 1;

    function Ie($e) {
      var Ae = $e.match(s);
      Ae && (ze += Ae.length);
      var gt = $e.lastIndexOf(B);
      Re = ~gt ? $e.length - gt : Re + $e.length
    }

    function Oe() {
      var $e = {
        line: ze,
        column: Re
      };
      return function(Ae) {
        return Ae.position = new st($e), Ue(), Ae
      }
    }

    function st($e) {
      this.start = $e, this.end = {
        line: ze,
        column: Re
      }, this.source = Ee.source
    }
    st.prototype.content = ge;

    function nt($e) {
      var Ae = new Error(Ee.source + ":" + ze + ":" + Re + ": " + $e);
      if (Ae.reason = $e, Ae.filename = Ee.source, Ae.line = ze, Ae.column = Re, Ae.source = ge, !Ee.silent) throw Ae
    }

    function qe($e) {
      var Ae = $e.exec(ge);
      if (Ae) {
        var gt = Ae[0];
        return Ie(gt), ge = ge.slice(gt.length), Ae
      }
    }

    function Ue() {
      qe(m)
    }

    function Je($e) {
      var Ae;
      for ($e = $e || []; Ae = Fe();) Ae !== !1 && $e.push(Ae);
      return $e
    }

    function Fe() {
      var $e = Oe();
      if (!(N != ge.charAt(0) || W != ge.charAt(1))) {
        for (var Ae = 2; K != ge.charAt(Ae) && (W != ge.charAt(Ae) || N != ge.charAt(Ae + 1));) ++Ae;
        if (Ae += 2, K === ge.charAt(Ae - 1)) return nt("End of comment missing");
        var gt = ge.slice(2, Ae - 2);
        return Re += 2, Ie(gt), ge = ge.slice(Ae), Re += 2, $e({
          type: se,
          comment: gt
        })
      }
    }

    function it() {
      var $e = Oe(),
        Ae = qe(y);
      if (Ae) {
        if (Fe(), !qe(M)) return nt("property missing ':'");
        var gt = qe(z),
          Q = $e({
            type: X,
            property: me(Ae[0].replace(_, K)),
            value: gt ? me(gt[0].replace(_, K)) : K
          });
        return qe(T), Q
      }
    }

    function tt() {
      var $e = [];
      Je($e);
      for (var Ae; Ae = it();) Ae !== !1 && ($e.push(Ae), Je($e));
      return $e
    }
    return Ue(), tt()
  };

  function me(ge) {
    return ge ? ge.replace(o, K) : K
  }
  return zf
}
var Jg;

function I4() {
  if (Jg) return cc;
  Jg = 1;
  var _ = cc && cc.__importDefault || function(y) {
    return y && y.__esModule ? y : {
      default: y
    }
  };
  Object.defineProperty(cc, "__esModule", {
    value: !0
  }), cc.default = m;
  var s = _(P4());

  function m(y, M) {
    var z = null;
    if (!y || typeof y != "string") return z;
    var T = (0, s.default)(y),
      o = typeof M == "function";
    return T.forEach(function(B) {
      if (B.type === "declaration") {
        var N = B.property,
          W = B.value;
        o ? M(N, W, B) : W && (z = z || {}, z[N] = W)
      }
    }), z
  }
  return cc
}
var M4 = I4();
const Qg = Fm(M4),
  A4 = Qg.default || Qg,
  k4 = /\d/,
  E4 = ["-", "_", "/", "."];

function z4(_ = "") {
  if (!k4.test(_)) return _ !== _.toLowerCase()
}

function L4(_) {
  const s = [];
  let m = "",
    y, M;
  for (const z of _) {
    const T = E4.includes(z);
    if (T === !0) {
      s.push(m), m = "", y = void 0;
      continue
    }
    const o = z4(z);
    if (M === !1) {
      if (y === !1 && o === !0) {
        s.push(m), m = z, y = o;
        continue
      }
      if (y === !0 && o === !1 && m.length > 1) {
        const B = m.at(-1);
        s.push(m.slice(0, Math.max(0, m.length - 1))), m = B + z, y = o;
        continue
      }
    }
    m += z, y = o, M = T
  }
  return s.push(m), s
}

function r0(_) {
  return _ ? L4(_).map(s => R4(s)).join("") : ""
}

function D4(_) {
  return B4(r0(_ || ""))
}

function R4(_) {
  return _ ? _[0].toUpperCase() + _.slice(1) : ""
}

function B4(_) {
  return _ ? _[0].toLowerCase() + _.slice(1) : ""
}

function Vd(_) {
  if (!_) return {};
  const s = {};

  function m(y, M) {
    if (y.startsWith("-moz-") || y.startsWith("-webkit-") || y.startsWith("-ms-") || y.startsWith("-o-")) {
      s[r0(y)] = M;
      return
    }
    if (y.startsWith("--")) {
      s[y] = M;
      return
    }
    s[D4(y)] = M
  }
  return A4(_, m), s
}

function F4(..._) {
  return (...s) => {
    for (const m of _) typeof m == "function" && m(...s)
  }
}

function O4(_, s) {
  const m = RegExp(_, "g");
  return y => {
    if (typeof y != "string") throw new TypeError(`expected an argument of type string, but got ${typeof y}`);
    return y.match(m) ? y.replace(m, s) : y
  }
}
const N4 = O4(/[A-Z]/, _ => `-${_.toLowerCase()}`);

function j4(_) {
  if (!_ || typeof _ != "object" || Array.isArray(_)) throw new TypeError(`expected an argument of type object, but got ${typeof _}`);
  return Object.keys(_).map(s => `${N4(s)}: ${_[s]};`).join(`
`)
}

function n0(_ = {}) {
  return j4(_).replace(`
`, " ")
}
const i0 = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
n0(i0);
const V4 = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  q4 = new Set(V4);

function Z4(_) {
  return q4.has(_)
}

function qa(..._) {
  const s = {
    ..._[0]
  };
  for (let m = 1; m < _.length; m++) {
    const y = _[m];
    if (y) {
      for (const M of Object.keys(y)) {
        const z = s[M],
          T = y[M],
          o = typeof z == "function",
          B = typeof T == "function";
        if (o && Z4(M)) {
          const N = z,
            W = T;
          s[M] = C4(N, W)
        } else if (o && B) s[M] = F4(z, T);
        else if (M === "class") {
          const N = Kf(z),
            W = Kf(T);
          N && W ? s[M] = Fu(z, T) : N ? s[M] = Fu(z) : W && (s[M] = Fu(T))
        } else if (M === "style") {
          const N = typeof z == "object",
            W = typeof T == "object",
            K = typeof z == "string",
            se = typeof T == "string";
          if (N && W) s[M] = {
            ...z,
            ...T
          };
          else if (N && se) {
            const X = Vd(T);
            s[M] = {
              ...z,
              ...X
            }
          } else if (K && W) {
            const X = Vd(z);
            s[M] = {
              ...X,
              ...T
            }
          } else if (K && se) {
            const X = Vd(z),
              me = Vd(T);
            s[M] = {
              ...X,
              ...me
            }
          } else N ? s[M] = z : W ? s[M] = T : K ? s[M] = z : se && (s[M] = T)
        } else s[M] = T !== void 0 ? T : z
      }
      for (const M of Object.getOwnPropertySymbols(y)) {
        const z = s[M],
          T = y[M];
        s[M] = T !== void 0 ? T : z
      }
    }
  }
  return typeof s.style == "object" && (s.style = n0(s.style).replaceAll(`
`, " ")), s.hidden !== !0 && (s.hidden = void 0, delete s.hidden), s.disabled !== !0 && (s.disabled = void 0, delete s.disabled), s
}
const U4 = typeof window < "u" ? window : void 0;

function $4(_) {
  let s = _.activeElement;
  for (; s != null && s.shadowRoot;) {
    const m = s.shadowRoot.activeElement;
    if (m === s) break;
    s = m
  }
  return s
}
var xc, Xu;
class G4 {
  constructor(s = {}) {
    Ir(this, xc);
    Ir(this, Xu);
    const {
      window: m = U4,
      document: y = m == null ? void 0 : m.document
    } = s;
    m !== void 0 && (ia(this, xc, y), ia(this, Xu, Iv(M => {
      const z = Nu(m, "focusin", M),
        T = Nu(m, "focusout", M);
      return () => {
        z(), T()
      }
    })))
  }
  get current() {
    var s;
    return (s = rt(this, Xu)) == null || s.call(this), rt(this, xc) ? $4(rt(this, xc)) : null
  }
}
xc = new WeakMap, Xu = new WeakMap;
new G4;
var Yu, Gs;
class Zm {
  constructor(s) {
    Ir(this, Yu);
    Ir(this, Gs);
    ia(this, Yu, s), ia(this, Gs, Symbol(s))
  }
  get key() {
    return rt(this, Gs)
  }
  exists() {
    return Wx(rt(this, Gs))
  }
  get() {
    const s = Vg(rt(this, Gs));
    if (s === void 0) throw new Error(`Context "${rt(this,Yu)}" not found`);
    return s
  }
  getOr(s) {
    const m = Vg(rt(this, Gs));
    return m === void 0 ? s : m
  }
  set(s) {
    return Xx(rt(this, Gs), s)
  }
}
Yu = new WeakMap, Gs = new WeakMap;

function H4(_, s) {
  switch (_) {
    case "post":
      Xr(s);
      break;
    case "pre":
      wm(s);
      break
  }
}

function a0(_, s, m, y = {}) {
  const {
    lazy: M = !1
  } = y;
  let z = !M,
    T = Array.isArray(_) ? [] : void 0;
  H4(s, () => {
    const o = Array.isArray(_) ? _.map(N => N()) : _();
    if (!z) {
      z = !0, T = o;
      return
    }
    const B = ll(() => m(o, T));
    return T = o, B
  })
}

function So(_, s, m) {
  a0(_, "post", s, m)
}

function W4(_, s, m) {
  a0(_, "pre", s, m)
}
So.pre = W4;
var bc;
class X4 {
  constructor(s, m) {
    Ir(this, bc, ut(void 0));
    m !== void 0 && ce(rt(this, bc), m, !0), So(() => s(), (y, M) => {
      ce(rt(this, bc), M, !0)
    })
  }
  get current() {
    return w(rt(this, bc))
  }
}
bc = new WeakMap;

function Y4(_, s) {
  return setTimeout(s, _)
}

function uc(_) {
  Tv().then(_)
}
const K4 = 1,
  J4 = 9,
  Q4 = 11;

function e6(_) {
  return Eh(_) && _.nodeType === K4 && typeof _.nodeName == "string"
}

function s0(_) {
  return Eh(_) && _.nodeType === J4
}

function t6(_) {
  var s;
  return Eh(_) && ((s = _.constructor) == null ? void 0 : s.name) === "VisualViewport"
}

function r6(_) {
  return Eh(_) && _.nodeType !== void 0
}

function n6(_) {
  return r6(_) && _.nodeType === Q4 && "host" in _
}

function i6(_) {
  return s0(_) ? _ : t6(_) ? _.document : (_ == null ? void 0 : _.ownerDocument) ?? document
}

function o0(_) {
  var s;
  return n6(_) ? o0(_.host) : s0(_) ? _.defaultView ?? window : e6(_) ? ((s = _.ownerDocument) == null ? void 0 : s.defaultView) ?? window : window
}

function a6(_) {
  let s = _.activeElement;
  for (; s != null && s.shadowRoot;) {
    const m = s.shadowRoot.activeElement;
    if (m === s) break;
    s = m
  }
  return s
}
var Ku;
class s6 {
  constructor(s) {
    mr(this, "element");
    Ir(this, Ku, ht(() => this.element.current ? this.element.current.getRootNode() ?? document : document));
    mr(this, "getDocument", () => i6(this.root));
    mr(this, "getWindow", () => this.getDocument().defaultView ?? window);
    mr(this, "getActiveElement", () => a6(this.root));
    mr(this, "isActiveElement", s => s === this.getActiveElement());
    mr(this, "querySelector", s => this.root ? this.root.querySelector(s) : null);
    mr(this, "querySelectorAll", s => this.root ? this.root.querySelectorAll(s) : []);
    mr(this, "setTimeout", (s, m) => this.getWindow().setTimeout(s, m));
    mr(this, "clearTimeout", s => this.getWindow().clearTimeout(s));
    typeof s == "function" ? this.element = _r.with(s) : this.element = s
  }
  get root() {
    return w(rt(this, Ku))
  }
  set root(s) {
    ce(rt(this, Ku), s)
  }
  getElementById(s) {
    return this.root.getElementById(s)
  }
}
Ku = new WeakMap;

function Xa(_, s) {
  return {
    [R1()]: m => _r.isBox(_) ? (_.current = m, ll(() => s == null ? void 0 : s(m)), () => {
      "isConnected" in m && m.isConnected || (_.current = null, s == null || s(null))
    }) : (_(m), ll(() => s == null ? void 0 : s(m)), () => {
      "isConnected" in m && m.isConnected || (_(null), s == null || s(null))
    })
  }
}

function o6(_) {
  return _ ? "true" : "false"
}

function l6(_) {
  return _ ? "true" : "false"
}

function c6(_) {
  return _ ? "" : void 0
}

function u6(_) {
  return _ ? "true" : "false"
}

function h6(_) {
  return _ ? "" : void 0
}

function d6(_) {
  return _ ? !0 : void 0
}
var wc, Ju;
class p6 {
  constructor(s) {
    Ir(this, wc);
    Ir(this, Ju);
    mr(this, "attrs");
    ia(this, wc, s.getVariant ? s.getVariant() : null), ia(this, Ju, rt(this, wc) ? `data-${rt(this,wc)}-` : `data-${s.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(s.parts.map(m => [m, this.getAttr(m)]))
  }
  getAttr(s, m) {
    return m ? `data-${m}-${s}` : `${rt(this,Ju)}${s}`
  }
  selector(s, m) {
    return `[${this.getAttr(s,m)}]`
  }
}
wc = new WeakMap, Ju = new WeakMap;

function l0(_) {
  const s = new p6(_);
  return {
    ...s.attrs,
    selector: s.selector,
    getAttr: s.getAttr
  }
}
const f6 = "ArrowDown",
  m6 = "ArrowLeft",
  _6 = "ArrowRight",
  g6 = "ArrowUp",
  v6 = "End",
  y6 = "Enter",
  x6 = "Home",
  b6 = "p",
  w6 = "n",
  T6 = "j",
  S6 = "k",
  C6 = "h",
  P6 = "l";

function qu() {}

function Ya(_, s) {
  return `bits-${_}`
}

function I6(_) {
  if (!_) return null;
  for (const s of _.childNodes)
    if (s.nodeType !== Node.COMMENT_NODE) return s;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function M6(_ = "bits") {
  return globalThis.bitsIdCounter.current++, `${_}-${globalThis.bitsIdCounter.current}`
}

function A6(_, s) {
  let m = _.nextElementSibling;
  for (; m;) {
    if (m.matches(s)) return m;
    m = m.nextElementSibling
  }
}

function k6(_, s) {
  let m = _.previousElementSibling;
  for (; m;) {
    if (m.matches(s)) return m;
    m = m.previousElementSibling
  }
}

function c0(_) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(_);
  const s = _.length;
  let m = -1,
    y, M = "";
  const z = _.charCodeAt(0);
  if (s === 1 && z === 45) return "\\" + _;
  for (; ++m < s;) {
    if (y = _.charCodeAt(m), y === 0) {
      M += "�";
      continue
    }
    if (y >= 1 && y <= 31 || y === 127 || m === 0 && y >= 48 && y <= 57 || m === 1 && y >= 48 && y <= 57 && z === 45) {
      M += "\\" + y.toString(16) + " ";
      continue
    }
    if (y >= 128 || y === 45 || y === 95 || y >= 48 && y <= 57 || y >= 65 && y <= 90 || y >= 97 && y <= 122) {
      M += _.charAt(m);
      continue
    }
    M += "\\" + _.charAt(m)
  }
  return M
}
const al = "data-value",
  Sa = l0({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  hc = Sa.selector("group"),
  Lf = Sa.selector("group-items"),
  ev = Sa.selector("group-heading"),
  u0 = Sa.selector("item"),
  Df = `${Sa.selector("item")}:not([aria-disabled="true"])`,
  dl = new Zm("Command.Root"),
  E6 = new Zm("Command.List"),
  Zu = new Zm("Command.Group"),
  tv = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var Tc, Qu, eh, th, rh, nh, ih, ah, dr, h0, Xd, Qf, Yd, Kd, Jd, xo, d0, p0, em, Lu, tm, rm, f0, Du, nm, im, m0, Ru, Bu, sh;
const Xm = class Xm {
  constructor(s) {
    Ir(this, dr);
    mr(this, "opts");
    mr(this, "attachment");
    Ir(this, Tc, !1);
    Ir(this, Qu, !0);
    mr(this, "sortAfterTick", !1);
    mr(this, "sortAndFilterAfterTick", !1);
    mr(this, "allItems", new Set);
    mr(this, "allGroups", new Map);
    mr(this, "allIds", new Map);
    Ir(this, eh, ut(0));
    Ir(this, th, ut(null));
    Ir(this, rh, ut(null));
    Ir(this, nh, ut(null));
    Ir(this, ih, ut(tv));
    Ir(this, ah, ut(yi(tv)));
    Ir(this, sh, ht(() => ({
      id: this.opts.id.current,
      role: "application",
      [Sa.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = s, this.attachment = Xa(this.opts.ref);
    const m = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = m, this.commandState = m, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(s) {
    return dl.set(new Xm(s))
  }
  get key() {
    return w(rt(this, eh))
  }
  set key(s) {
    ce(rt(this, eh), s, !0)
  }
  get viewportNode() {
    return w(rt(this, th))
  }
  set viewportNode(s) {
    ce(rt(this, th), s, !0)
  }
  get inputNode() {
    return w(rt(this, rh))
  }
  set inputNode(s) {
    ce(rt(this, rh), s, !0)
  }
  get labelNode() {
    return w(rt(this, nh))
  }
  set labelNode(s) {
    ce(rt(this, nh), s, !0)
  }
  get commandState() {
    return w(rt(this, ih))
  }
  set commandState(s) {
    ce(rt(this, ih), s)
  }
  get _commandState() {
    return w(rt(this, ah))
  }
  set _commandState(s) {
    ce(rt(this, ah), s, !0)
  }
  setState(s, m, y) {
    Object.is(this._commandState[s], m) || (this._commandState[s] = m, s === "search" ? (jr(this, dr, Jd).call(this), jr(this, dr, Yd).call(this)) : s === "value" && (y || jr(this, dr, d0).call(this)), jr(this, dr, Xd).call(this))
  }
  setValue(s, m) {
    s !== this.opts.value.current && s === "" && uc(() => {
      this.key++
    }), this.setState("value", s, m), this.opts.value.current = s
  }
  getValidItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(Df)).filter(y => !!y) : []
  }
  getVisibleItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(u0)).filter(y => !!y) : []
  }
  get itemsGrid() {
    var o, B, N, W;
    if (!this.isGrid) return [];
    const s = this.opts.columns.current ?? 1,
      m = this.getVisibleItems(),
      y = [
        []
      ];
    let M = (o = m[0]) == null ? void 0 : o.getAttribute("data-group"),
      z = 0,
      T = 0;
    for (let K = 0; K < m.length; K++) {
      const se = m[K],
        X = se == null ? void 0 : se.getAttribute("data-group");
      M !== X ? (M = X, z = 1, T++, y.push([{
        index: K,
        firstRowOfGroup: !0,
        ref: se
      }])) : (z++, z > s && (T++, z = 1, y.push([])), (W = y[T]) == null || W.push({
        index: K,
        firstRowOfGroup: ((N = (B = y[T]) == null ? void 0 : B[0]) == null ? void 0 : N.firstRowOfGroup) ?? K === 0,
        ref: se
      }))
    }
    return y
  }
  updateSelectedToIndex(s) {
    const m = this.getValidItems()[s];
    m && this.setValue(m.getAttribute(al) ?? "")
  }
  updateSelectedByItem(s) {
    const m = jr(this, dr, xo).call(this),
      y = this.getValidItems(),
      M = y.findIndex(T => T === m);
    let z = y[M + s];
    this.opts.loop.current && (z = M + s < 0 ? y[y.length - 1] : M + s === y.length ? y[0] : y[M + s]), z && this.setValue(z.getAttribute(al) ?? "")
  }
  updateSelectedByGroup(s) {
    const m = jr(this, dr, xo).call(this);
    let y = m == null ? void 0 : m.closest(hc),
      M;
    for (; y && !M;) y = s > 0 ? A6(y, hc) : k6(y, hc), M = y == null ? void 0 : y.querySelector(Df);
    M ? this.setValue(M.getAttribute(al) ?? "") : this.updateSelectedByItem(s)
  }
  registerValue(s, m) {
    var y;
    return s && s === ((y = this.allIds.get(s)) == null ? void 0 : y.value) || this.allIds.set(s, {
      value: s,
      keywords: m
    }), this._commandState.filtered.items.set(s, jr(this, dr, Qf).call(this, s, m)), this.sortAfterTick || (this.sortAfterTick = !0, uc(() => {
      jr(this, dr, Yd).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(s)
    }
  }
  registerItem(s, m) {
    return this.allItems.add(s), m && (this.allGroups.has(m) ? this.allGroups.get(m).add(s) : this.allGroups.set(m, new Set([s]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, uc(() => {
      jr(this, dr, Jd).call(this), jr(this, dr, Yd).call(this), this.sortAndFilterAfterTick = !1
    })), jr(this, dr, Xd).call(this), () => {
      const y = jr(this, dr, xo).call(this);
      this.allIds.delete(s), this.allItems.delete(s), this.commandState.filtered.items.delete(s), jr(this, dr, Jd).call(this), (y == null ? void 0 : y.getAttribute("id")) === s && jr(this, dr, Kd).call(this), jr(this, dr, Xd).call(this)
    }
  }
  registerGroup(s) {
    return this.allGroups.has(s) || this.allGroups.set(s, new Set), () => {
      this.allIds.delete(s), this.allGroups.delete(s)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(s) {
    const m = this.opts.vimBindings.current && s.ctrlKey;
    switch (s.key) {
      case w6:
      case T6: {
        m && (this.isGrid ? jr(this, dr, tm).call(this, s) : jr(this, dr, Lu).call(this, s));
        break
      }
      case P6: {
        m && this.isGrid && jr(this, dr, Lu).call(this, s);
        break
      }
      case f6:
        this.isGrid ? jr(this, dr, tm).call(this, s) : jr(this, dr, Lu).call(this, s);
        break;
      case _6:
        if (!this.isGrid) break;
        jr(this, dr, Lu).call(this, s);
        break;
      case b6:
      case S6: {
        m && (this.isGrid ? jr(this, dr, im).call(this, s) : jr(this, dr, Bu).call(this, s));
        break
      }
      case C6: {
        m && this.isGrid && jr(this, dr, Bu).call(this, s);
        break
      }
      case g6:
        this.isGrid ? jr(this, dr, im).call(this, s) : jr(this, dr, Bu).call(this, s);
        break;
      case m6:
        if (!this.isGrid) break;
        jr(this, dr, Bu).call(this, s);
        break;
      case x6:
        s.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case v6:
        s.preventDefault(), jr(this, dr, em).call(this);
        break;
      case y6:
        if (!s.isComposing && s.keyCode !== 229) {
          s.preventDefault();
          const y = jr(this, dr, xo).call(this);
          y && (y == null || y.click())
        }
    }
  }
  get props() {
    return w(rt(this, sh))
  }
  set props(s) {
    ce(rt(this, sh), s)
  }
};
Tc = new WeakMap, Qu = new WeakMap, eh = new WeakMap, th = new WeakMap, rh = new WeakMap, nh = new WeakMap, ih = new WeakMap, ah = new WeakMap, dr = new WeakSet, h0 = function() {
  return D1(this._commandState)
}, Xd = function() {
  rt(this, Tc) || (ia(this, Tc, !0), uc(() => {
    var y, M;
    ia(this, Tc, !1);
    const s = jr(this, dr, h0).call(this);
    !Object.is(this.commandState, s) && (this.commandState = s, (M = (y = this.opts.onStateChange) == null ? void 0 : y.current) == null || M.call(y, s))
  }))
}, Qf = function(s, m) {
  const y = this.opts.filter.current ?? v0;
  return s ? y(s, this._commandState.search, m) : 0
}, Yd = function() {
  var T;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    jr(this, dr, Kd).call(this);
    return
  }
  const s = this._commandState.filtered.items,
    m = [];
  for (const o of this._commandState.filtered.groups) {
    const B = this.allGroups.get(o);
    let N = 0;
    if (!B) {
      m.push([o, N]);
      continue
    }
    for (const W of B) {
      const K = s.get(W);
      N = Math.max(K ?? 0, N)
    }
    m.push([o, N])
  }
  const y = this.viewportNode,
    M = this.getValidItems().sort((o, B) => {
      const N = o.getAttribute("data-value"),
        W = B.getAttribute("data-value"),
        K = s.get(N) ?? 0;
      return (s.get(W) ?? 0) - K
    });
  for (const o of M) {
    const B = o.closest(Lf);
    if (B) {
      const N = o.parentElement === B ? o : o.closest(`${Lf} > *`);
      N && B.appendChild(N)
    } else {
      const N = o.parentElement === y ? o : o.closest(`${Lf} > *`);
      N && (y == null || y.appendChild(N))
    }
  }
  const z = m.sort((o, B) => B[1] - o[1]);
  for (const o of z) {
    const B = y == null ? void 0 : y.querySelector(`${hc}[${al}="${c0(o[0])}"]`);
    (T = B == null ? void 0 : B.parentElement) == null || T.appendChild(B)
  }
  jr(this, dr, Kd).call(this)
}, Kd = function() {
  uc(() => {
    const s = this.getValidItems().find(M => M.getAttribute("aria-disabled") !== "true"),
      m = s == null ? void 0 : s.getAttribute(al),
      y = rt(this, Qu) && this.opts.disableInitialScroll.current;
    this.setValue(m ?? "", y), ia(this, Qu, !1)
  })
}, Jd = function() {
  var m, y;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let s = 0;
  for (const M of this.allItems) {
    const z = ((m = this.allIds.get(M)) == null ? void 0 : m.value) ?? "",
      T = ((y = this.allIds.get(M)) == null ? void 0 : y.keywords) ?? [],
      o = jr(this, dr, Qf).call(this, z, T);
    this._commandState.filtered.items.set(M, o), o > 0 && s++
  }
  for (const [M, z] of this.allGroups)
    for (const T of z) {
      const o = this._commandState.filtered.items.get(T);
      if (o && o > 0) {
        this._commandState.filtered.groups.add(M);
        break
      }
    }
  this._commandState.filtered.count = s
}, xo = function() {
  const s = this.opts.ref.current;
  if (!s) return;
  const m = s.querySelector(`${Df}[data-selected]`);
  if (m) return m
}, d0 = function() {
  uc(() => {
    var y, M, z, T, o;
    const s = jr(this, dr, xo).call(this);
    if (!s) return;
    const m = (y = s.parentElement) == null ? void 0 : y.parentElement;
    if (m) {
      if (this.isGrid) {
        const B = jr(this, dr, p0).call(this, s);
        if (s.scrollIntoView({
            block: "nearest"
          }), B) {
          const N = (M = s == null ? void 0 : s.closest(hc)) == null ? void 0 : M.querySelector(ev);
          N == null || N.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const B = I6(m);
        if (B && ((z = B.dataset) == null ? void 0 : z.value) === ((T = s.dataset) == null ? void 0 : T.value)) {
          const N = (o = s == null ? void 0 : s.closest(hc)) == null ? void 0 : o.querySelector(ev);
          N == null || N.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      s.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, p0 = function(s) {
  const m = this.itemsGrid;
  if (m.length === 0) return !1;
  for (let y = 0; y < m.length; y++) {
    const M = m[y];
    if (M !== void 0)
      for (let z = 0; z < M.length; z++) {
        const T = M[z];
        if (!(T === void 0 || T.ref !== s)) return T.firstRowOfGroup
      }
  }
  return !1
}, em = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Lu = function(s) {
  s.preventDefault(), s.metaKey ? jr(this, dr, em).call(this) : s.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, tm = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(jr(this, dr, f0).call(this, s)))
}, rm = function(s, m) {
  if (m.length === 0) return null;
  for (let y = 0; y < m.length; y++) {
    const M = m[y];
    if (M !== void 0)
      for (let z = 0; z < M.length; z++) {
        const T = M[z];
        if (!(T === void 0 || T.ref !== s)) return {
          columnIndex: z,
          rowIndex: y
        }
      }
  }
  return null
}, f0 = function(s) {
  const m = this.itemsGrid,
    y = jr(this, dr, xo).call(this);
  if (!y) return 0;
  const M = jr(this, dr, rm).call(this, y, m);
  if (!M) return 0;
  let z = null;
  const T = s.altKey ? 1 : 0;
  if (s.altKey && M.rowIndex === m.length - 2 && !this.opts.loop.current) z = jr(this, dr, Du).call(this, {
    start: m.length - 1,
    end: m.length,
    expectedColumnIndex: M.columnIndex,
    grid: m
  });
  else if (M.rowIndex === m.length - 1) {
    if (!this.opts.loop.current) return 0;
    z = jr(this, dr, Du).call(this, {
      start: 0 + T,
      end: M.rowIndex,
      expectedColumnIndex: M.columnIndex,
      grid: m
    })
  } else z = jr(this, dr, Du).call(this, {
    start: M.rowIndex + 1 + T,
    end: m.length,
    expectedColumnIndex: M.columnIndex,
    grid: m
  }), z === null && this.opts.loop.current && (z = jr(this, dr, Du).call(this, {
    start: 0,
    end: M.rowIndex,
    expectedColumnIndex: M.columnIndex,
    grid: m
  }));
  return jr(this, dr, nm).call(this, y, z)
}, Du = function({
  start: s,
  end: m,
  grid: y,
  expectedColumnIndex: M
}) {
  var T;
  let z = null;
  for (let o = s; o < m; o++) {
    const B = y[o];
    if (z = ((T = B[M]) == null ? void 0 : T.ref) ?? null, z !== null && qd(z)) {
      z = null;
      continue
    }
    if (z === null)
      for (let N = B.length - 1; N >= 0; N--) {
        const W = B[B.length - 1];
        if (!(W === void 0 || qd(W.ref))) {
          z = W.ref;
          break
        }
      }
    break
  }
  return z
}, nm = function(s, m) {
  if (m === null) return 0;
  const y = this.getValidItems(),
    M = y.findIndex(T => T === s);
  return y.findIndex(T => T === m) - M
}, im = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(jr(this, dr, m0).call(this, s)))
}, m0 = function(s) {
  const m = this.itemsGrid,
    y = jr(this, dr, xo).call(this);
  if (y === void 0) return 0;
  const M = jr(this, dr, rm).call(this, y, m);
  if (M === null) return 0;
  let z = null;
  const T = s.altKey ? 1 : 0;
  if (s.altKey && M.rowIndex === 1 && this.opts.loop.current === !1) z = jr(this, dr, Ru).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: M.columnIndex,
    grid: m
  });
  else if (M.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    z = jr(this, dr, Ru).call(this, {
      start: m.length - 1 - T,
      end: M.rowIndex + 1,
      expectedColumnIndex: M.columnIndex,
      grid: m
    })
  } else z = jr(this, dr, Ru).call(this, {
    start: M.rowIndex - 1 - T,
    end: 0,
    expectedColumnIndex: M.columnIndex,
    grid: m
  }), z === null && this.opts.loop.current && (z = jr(this, dr, Ru).call(this, {
    start: m.length - 1,
    end: M.rowIndex + 1,
    expectedColumnIndex: M.columnIndex,
    grid: m
  }));
  return jr(this, dr, nm).call(this, y, z)
}, Ru = function({
  start: s,
  end: m,
  grid: y,
  expectedColumnIndex: M
}) {
  var T;
  let z = null;
  for (let o = s; o >= m; o--) {
    const B = y[o];
    if (B !== void 0) {
      if (z = ((T = B[M]) == null ? void 0 : T.ref) ?? null, z !== null && qd(z)) {
        z = null;
        continue
      }
      if (z === null)
        for (let N = B.length - 1; N >= 0; N--) {
          const W = B[B.length - 1];
          if (!(W === void 0 || qd(W.ref))) {
            z = W.ref;
            break
          }
        }
      break
    }
  }
  return z
}, Bu = function(s) {
  s.preventDefault(), s.metaKey ? this.updateSelectedToIndex(0) : s.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, sh = new WeakMap;
let Jf = Xm;

function qd(_) {
  return _.getAttribute("aria-disabled") === "true"
}
var oh, lh, ch;
const Ym = class Ym {
  constructor(s, m) {
    mr(this, "opts");
    mr(this, "root");
    mr(this, "attachment");
    Ir(this, oh, ht(() => this.root._commandState.filtered.count === 0 && rt(this, lh) === !1 || this.opts.forceMount.current));
    Ir(this, lh, !0);
    Ir(this, ch, ht(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [Sa.empty]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = m, this.attachment = Xa(this.opts.ref), wm(() => {
      ia(this, lh, !1)
    })
  }
  static create(s) {
    return new Ym(s, dl.get())
  }
  get shouldRender() {
    return w(rt(this, oh))
  }
  set shouldRender(s) {
    ce(rt(this, oh), s)
  }
  get props() {
    return w(rt(this, ch))
  }
  set props(s) {
    ce(rt(this, ch), s)
  }
};
oh = new WeakMap, lh = new WeakMap, ch = new WeakMap;
let am = Ym;
var uh, hh, dh, ph;
const Km = class Km {
  constructor(s, m) {
    mr(this, "opts");
    mr(this, "root");
    mr(this, "attachment");
    Ir(this, uh, ht(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    Ir(this, hh, ut(null));
    Ir(this, dh, ut(""));
    Ir(this, ph, ht(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [Sa.group]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = m, this.attachment = Xa(this.opts.ref), this.trueValue = s.value.current ?? s.id.current, So(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Xr(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(s) {
    return Zu.set(new Km(s, dl.get()))
  }
  get shouldRender() {
    return w(rt(this, uh))
  }
  set shouldRender(s) {
    ce(rt(this, uh), s)
  }
  get headingNode() {
    return w(rt(this, hh))
  }
  set headingNode(s) {
    ce(rt(this, hh), s, !0)
  }
  get trueValue() {
    return w(rt(this, dh))
  }
  set trueValue(s) {
    ce(rt(this, dh), s, !0)
  }
  get props() {
    return w(rt(this, ph))
  }
  set props(s) {
    ce(rt(this, ph), s)
  }
};
uh = new WeakMap, hh = new WeakMap, dh = new WeakMap, ph = new WeakMap;
let sm = Km;
var fh;
const Jm = class Jm {
  constructor(s, m) {
    mr(this, "opts");
    mr(this, "group");
    mr(this, "attachment");
    Ir(this, fh, ht(() => ({
      id: this.opts.id.current,
      [Sa["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = s, this.group = m, this.attachment = Xa(this.opts.ref, y => this.group.headingNode = y)
  }
  static create(s) {
    return new Jm(s, Zu.get())
  }
  get props() {
    return w(rt(this, fh))
  }
  set props(s) {
    ce(rt(this, fh), s)
  }
};
fh = new WeakMap;
let om = Jm;
var mh;
const Qm = class Qm {
  constructor(s, m) {
    mr(this, "opts");
    mr(this, "group");
    mr(this, "attachment");
    Ir(this, mh, ht(() => {
      var s;
      return {
        id: this.opts.id.current,
        role: "group",
        [Sa["group-items"]]: "",
        "aria-labelledby": ((s = this.group.headingNode) == null ? void 0 : s.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = s, this.group = m, this.attachment = Xa(this.opts.ref)
  }
  static create(s) {
    return new Qm(s, Zu.get())
  }
  get props() {
    return w(rt(this, mh))
  }
  set props(s) {
    ce(rt(this, mh), s)
  }
};
mh = new WeakMap;
let lm = Qm;
var np, _h;
const e_ = class e_ {
  constructor(s, m) {
    mr(this, "opts");
    mr(this, "root");
    mr(this, "attachment");
    Ir(this, np, ht(() => {
      var m;
      const s = (m = this.root.viewportNode) == null ? void 0 : m.querySelector(`${u0}[${al}="${c0(this.root.opts.value.current)}"]`);
      if (s != null) return s.getAttribute("id") ?? void 0
    }));
    Ir(this, _h, ht(() => {
      var s, m;
      return {
        id: this.opts.id.current,
        type: "text",
        [Sa.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": l6(!0),
        "aria-controls": ((s = this.root.viewportNode) == null ? void 0 : s.id) ?? void 0,
        "aria-labelledby": ((m = this.root.labelNode) == null ? void 0 : m.id) ?? void 0,
        "aria-activedescendant": w(rt(this, np)),
        ...this.attachment
      }
    }));
    this.opts = s, this.root = m, this.attachment = Xa(this.opts.ref, y => this.root.inputNode = y), So(() => this.opts.ref.current, () => {
      const y = this.opts.ref.current;
      y && this.opts.autofocus.current && Y4(10, () => y.focus())
    }), So(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(s) {
    return new e_(s, dl.get())
  }
  get props() {
    return w(rt(this, _h))
  }
  set props(s) {
    ce(rt(this, _h), s)
  }
};
np = new WeakMap, _h = new WeakMap;
let cm = e_;
var wo, ip, gh, vh, yh, ul, _0, hm, xh;
const t_ = class t_ {
  constructor(s, m) {
    Ir(this, ul);
    mr(this, "opts");
    mr(this, "root");
    mr(this, "attachment");
    Ir(this, wo, null);
    Ir(this, ip, ht(() => {
      var s;
      return this.opts.forceMount.current || ((s = rt(this, wo)) == null ? void 0 : s.opts.forceMount.current) === !0
    }));
    Ir(this, gh, ht(() => {
      if (this.opts.ref.current, w(rt(this, ip)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const s = this.root.commandState.filtered.items.get(this.trueValue);
      return s === void 0 ? !1 : s > 0
    }));
    Ir(this, vh, ht(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    Ir(this, yh, ut(""));
    Ir(this, xh, ht(() => {
      var s;
      return {
        id: this.opts.id.current,
        "aria-disabled": o6(this.opts.disabled.current),
        "aria-selected": u6(this.isSelected),
        "data-disabled": c6(this.opts.disabled.current),
        "data-selected": h6(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (s = rt(this, wo)) == null ? void 0 : s.trueValue,
        [Sa.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = m, ia(this, wo, Zu.getOr(null)), this.trueValue = s.value.current, this.attachment = Xa(this.opts.ref), So([() => this.trueValue, () => {
      var y;
      return (y = rt(this, wo)) == null ? void 0 : y.trueValue
    }, () => this.opts.forceMount.current], () => {
      var y;
      if (!this.opts.forceMount.current) return this.root.registerItem(this.trueValue, (y = rt(this, wo)) == null ? void 0 : y.trueValue)
    }), So([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var y, M;
      !this.opts.value.current && ((y = this.opts.ref.current) != null && y.textContent) && (this.trueValue = this.opts.ref.current.textContent.trim()), this.root.registerValue(this.trueValue, s.keywords.current.map(z => z.trim())), (M = this.opts.ref.current) == null || M.setAttribute(al, this.trueValue)
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(s) {
    const m = Zu.getOr(null);
    return new t_({
      ...s,
      group: m
    }, dl.get())
  }
  get shouldRender() {
    return w(rt(this, gh))
  }
  set shouldRender(s) {
    ce(rt(this, gh), s)
  }
  get isSelected() {
    return w(rt(this, vh))
  }
  set isSelected(s) {
    ce(rt(this, vh), s)
  }
  get trueValue() {
    return w(rt(this, yh))
  }
  set trueValue(s) {
    ce(rt(this, yh), s, !0)
  }
  onpointermove(s) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || jr(this, ul, hm).call(this)
  }
  onclick(s) {
    this.opts.disabled.current || jr(this, ul, _0).call(this)
  }
  get props() {
    return w(rt(this, xh))
  }
  set props(s) {
    ce(rt(this, xh), s)
  }
};
wo = new WeakMap, ip = new WeakMap, gh = new WeakMap, vh = new WeakMap, yh = new WeakMap, ul = new WeakSet, _0 = function() {
  var s;
  this.opts.disabled.current || (jr(this, ul, hm).call(this), (s = this.opts.onSelect) == null || s.current())
}, hm = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, xh = new WeakMap;
let um = t_;
var bh;
const r_ = class r_ {
  constructor(s, m) {
    mr(this, "opts");
    mr(this, "root");
    mr(this, "attachment");
    Ir(this, bh, ht(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [Sa.list]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = m, this.attachment = Xa(this.opts.ref)
  }
  static create(s) {
    return E6.set(new r_(s, dl.get()))
  }
  get props() {
    return w(rt(this, bh))
  }
  set props(s) {
    ce(rt(this, bh), s)
  }
};
bh = new WeakMap;
let dm = r_;
var wh;
const n_ = class n_ {
  constructor(s, m) {
    mr(this, "opts");
    mr(this, "root");
    mr(this, "attachment");
    Ir(this, wh, ht(() => {
      var s;
      return {
        id: this.opts.id.current,
        [Sa["input-label"]]: "",
        for: (s = this.opts.for) == null ? void 0 : s.current,
        style: i0,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = m, this.attachment = Xa(this.opts.ref, y => this.root.labelNode = y)
  }
  static create(s) {
    return new n_(s, dl.get())
  }
  get props() {
    return w(rt(this, wh))
  }
  set props(s) {
    ce(rt(this, wh), s)
  }
};
wh = new WeakMap;
let pm = n_;
var z6 = Pe("<label><!></label>");

function L6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const T = pm.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), W => M(W))
    }),
    o = ht(() => qa(z, T.props));
  var B = z6();
  or(B, () => ({
    ...w(o)
  }));
  var N = E(B);
  ii(N, () => s.children ?? Ta), k(B), H(_, B), Fr()
}
var D6 = Pe("<!> <!>", 1),
  R6 = Pe("<div><!> <!></div>");

function B6(_, s) {
  const m = cs();
  Br(s, !0);
  const y = tt => {
    L6(tt, {
      children: ($e, Ae) => {
        _n();
        var gt = Mi();
        Ye(() => ye(gt, se())), H($e, gt)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let M = Et(s, "id", 19, () => Ya(m)),
    z = Et(s, "ref", 15, null),
    T = Et(s, "value", 15, ""),
    o = Et(s, "onValueChange", 3, qu),
    B = Et(s, "onStateChange", 3, qu),
    N = Et(s, "loop", 3, !1),
    W = Et(s, "shouldFilter", 3, !0),
    K = Et(s, "filter", 3, v0),
    se = Et(s, "label", 3, ""),
    X = Et(s, "vimBindings", 3, !0),
    me = Et(s, "disablePointerSelection", 3, !1),
    ge = Et(s, "disableInitialScroll", 3, !1),
    Ee = Et(s, "columns", 3, null),
    ze = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const Re = Jf.create({
      id: _r.with(() => M()),
      ref: _r.with(() => z(), tt => z(tt)),
      filter: _r.with(() => K()),
      shouldFilter: _r.with(() => W()),
      loop: _r.with(() => N()),
      value: _r.with(() => T(), tt => {
        T() !== tt && (T(tt), o()(tt))
      }),
      vimBindings: _r.with(() => X()),
      disablePointerSelection: _r.with(() => me()),
      disableInitialScroll: _r.with(() => ge()),
      onStateChange: _r.with(() => B()),
      columns: _r.with(() => Ee())
    }),
    Ie = tt => Re.updateSelectedToIndex(tt),
    Oe = tt => Re.updateSelectedByGroup(tt),
    st = tt => Re.updateSelectedByItem(tt),
    nt = () => Re.getValidItems(),
    qe = ht(() => qa(ze, Re.props));
  var Ue = Kt(),
    Je = Ct(Ue);
  {
    var Fe = tt => {
        var $e = D6(),
          Ae = Ct($e);
        y(Ae);
        var gt = Z(Ae, 2);
        ii(gt, () => s.child, () => ({
          props: w(qe)
        })), H(tt, $e)
      },
      it = tt => {
        var $e = R6();
        or($e, () => ({
          ...w(qe)
        }));
        var Ae = E($e);
        y(Ae);
        var gt = Z(Ae, 2);
        ii(gt, () => s.children ?? Ta), k($e), H(tt, $e)
      };
    je(Je, tt => {
      s.child ? tt(Fe) : tt(it, !1)
    })
  }
  return H(_, Ue), Fr({
    updateSelectedToIndex: Ie,
    updateSelectedByGroup: Oe,
    updateSelectedByItem: st,
    getValidItems: nt
  })
}
var F6 = Pe("<div><!></div>");

function O6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = Et(s, "forceMount", 3, !1),
    T = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const o = am.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), se => M(se)),
      forceMount: _r.with(() => z())
    }),
    B = ht(() => qa(o.props, T));
  var N = Kt(),
    W = Ct(N);
  {
    var K = se => {
      var X = Kt(),
        me = Ct(X);
      {
        var ge = ze => {
            var Re = Kt(),
              Ie = Ct(Re);
            ii(Ie, () => s.child, () => ({
              props: w(B)
            })), H(ze, Re)
          },
          Ee = ze => {
            var Re = F6();
            or(Re, () => ({
              ...w(B)
            }));
            var Ie = E(Re);
            ii(Ie, () => s.children ?? Ta), k(Re), H(ze, Re)
          };
        je(me, ze => {
          s.child ? ze(ge) : ze(Ee, !1)
        })
      }
      H(se, X)
    };
    je(W, se => {
      o.shouldRender && se(K)
    })
  }
  H(_, N), Fr()
}
var N6 = Pe("<div><!></div>");

function j6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = Et(s, "value", 3, ""),
    T = Et(s, "forceMount", 3, !1),
    o = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const B = sm.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), me => M(me)),
      forceMount: _r.with(() => T()),
      value: _r.with(() => z())
    }),
    N = ht(() => qa(o, B.props));
  var W = Kt(),
    K = Ct(W);
  {
    var se = me => {
        var ge = Kt(),
          Ee = Ct(ge);
        ii(Ee, () => s.child, () => ({
          props: w(N)
        })), H(me, ge)
      },
      X = me => {
        var ge = N6();
        or(ge, () => ({
          ...w(N)
        }));
        var Ee = E(ge);
        ii(Ee, () => s.children ?? Ta), k(ge), H(me, ge)
      };
    je(K, me => {
      s.child ? me(se) : me(X, !1)
    })
  }
  H(_, W), Fr()
}
var V6 = Pe("<div><!></div>");

function q6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = om.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), se => M(se))
    }),
    o = ht(() => qa(z, T.props));
  var B = Kt(),
    N = Ct(B);
  {
    var W = se => {
        var X = Kt(),
          me = Ct(X);
        ii(me, () => s.child, () => ({
          props: w(o)
        })), H(se, X)
      },
      K = se => {
        var X = V6();
        or(X, () => ({
          ...w(o)
        }));
        var me = E(X);
        ii(me, () => s.children ?? Ta), k(X), H(se, X)
      };
    je(N, se => {
      s.child ? se(W) : se(K, !1)
    })
  }
  H(_, B), Fr()
}
var Z6 = Pe("<div><!></div>"),
  U6 = Pe('<div style="display: contents;"><!></div>');

function $6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = lm.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), se => M(se))
    }),
    o = ht(() => qa(z, T.props));
  var B = U6(),
    N = E(B);
  {
    var W = se => {
        var X = Kt(),
          me = Ct(X);
        ii(me, () => s.child, () => ({
          props: w(o)
        })), H(se, X)
      },
      K = se => {
        var X = Z6();
        or(X, () => ({
          ...w(o)
        }));
        var me = E(X);
        ii(me, () => s.children ?? Ta), k(X), H(se, X)
      };
    je(N, se => {
      s.child ? se(W) : se(K, !1)
    })
  }
  k(B), H(_, B), Fr()
}
var G6 = Pe("<input/>");

function H6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "value", 15, ""),
    M = Et(s, "autofocus", 3, !1),
    z = Et(s, "id", 19, () => Ya(m)),
    T = Et(s, "ref", 15, null),
    o = ir(s, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const B = cm.create({
      id: _r.with(() => z()),
      ref: _r.with(() => T(), me => T(me)),
      value: _r.with(() => y(), me => {
        y(me)
      }),
      autofocus: _r.with(() => M() ?? !1)
    }),
    N = ht(() => qa(o, B.props));
  var W = Kt(),
    K = Ct(W);
  {
    var se = me => {
        var ge = Kt(),
          Ee = Ct(ge);
        ii(Ee, () => s.child, () => ({
          props: w(N)
        })), H(me, ge)
      },
      X = me => {
        var ge = G6();
        us(ge), or(ge, () => ({
          ...w(N)
        })), Mm(ge, y), H(me, ge)
      };
    je(K, me => {
      s.child ? me(se) : me(X, !1)
    })
  }
  H(_, W), Fr()
}
var W6 = Pe("<div><!></div>"),
  X6 = Pe('<div style="display: contents;" data-item-wrapper=""><!></div>');

function Y6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = Et(s, "value", 3, ""),
    T = Et(s, "disabled", 3, !1),
    o = Et(s, "onSelect", 3, qu),
    B = Et(s, "forceMount", 3, !1),
    N = Et(s, "keywords", 19, () => []),
    W = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const K = um.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), ge => M(ge)),
      value: _r.with(() => z()),
      disabled: _r.with(() => T()),
      onSelect: _r.with(() => o()),
      forceMount: _r.with(() => B()),
      keywords: _r.with(() => N())
    }),
    se = ht(() => qa(W, K.props));
  var X = Kt(),
    me = Ct(X);
  ju(me, () => K.root.key, ge => {
    var Ee = X6(),
      ze = E(Ee);
    {
      var Re = Ie => {
        var Oe = Kt(),
          st = Ct(Oe);
        {
          var nt = Ue => {
              var Je = Kt(),
                Fe = Ct(Je);
              ii(Fe, () => s.child, () => ({
                props: w(se)
              })), H(Ue, Je)
            },
            qe = Ue => {
              var Je = W6();
              or(Je, () => ({
                ...w(se)
              }));
              var Fe = E(Je);
              ii(Fe, () => s.children ?? Ta), k(Je), H(Ue, Je)
            };
          je(st, Ue => {
            s.child ? Ue(nt) : Ue(qe, !1)
          })
        }
        H(Ie, Oe)
      };
      je(ze, Ie => {
        K.shouldRender && Ie(Re)
      })
    }
    k(Ee), Ye(() => kr(Ee, "data-value", K.trueValue)), H(ge, Ee)
  }), H(_, X), Fr()
}
var K6 = Pe("<div><!></div>");

function J6(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const T = dm.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), W => M(W)),
      ariaLabel: _r.with(() => s["aria-label"] ?? "Suggestions...")
    }),
    o = ht(() => qa(z, T.props));
  var B = Kt(),
    N = Ct(B);
  ju(N, () => T.root._commandState.search === "", W => {
    var K = Kt(),
      se = Ct(K);
    {
      var X = ge => {
          var Ee = Kt(),
            ze = Ct(Ee);
          ii(ze, () => s.child, () => ({
            props: w(o)
          })), H(ge, Ee)
        },
        me = ge => {
          var Ee = K6();
          or(Ee, () => ({
            ...w(o)
          }));
          var ze = E(Ee);
          ii(ze, () => s.children ?? Ta), k(Ee), H(ge, Ee)
        };
      je(se, ge => {
        s.child ? ge(X) : ge(me, !1)
      })
    }
    H(W, K)
  }), H(_, B), Fr()
}
const rv = 1,
  Q6 = .9,
  eA = .8,
  tA = .17,
  Rf = .1,
  Bf = .999,
  rA = .9999,
  nA = .99,
  iA = /[\\/_+.#"@[({&]/,
  aA = /[\\/_+.#"@[({&]/g,
  sA = /[\s-]/,
  g0 = /[\s-]/g;

function fm(_, s, m, y, M, z, T) {
  if (z === s.length) return M === _.length ? rv : nA;
  const o = `${M},${z}`;
  if (T[o] !== void 0) return T[o];
  const B = y.charAt(z);
  let N = m.indexOf(B, M),
    W = 0,
    K, se, X, me;
  for (; N >= 0;) K = fm(_, s, m, y, N + 1, z + 1, T), K > W && (N === M ? K *= rv : iA.test(_.charAt(N - 1)) ? (K *= eA, X = _.slice(M, N - 1).match(aA), X && M > 0 && (K *= Bf ** X.length)) : sA.test(_.charAt(N - 1)) ? (K *= Q6, me = _.slice(M, N - 1).match(g0), me && M > 0 && (K *= Bf ** me.length)) : (K *= tA, M > 0 && (K *= Bf ** (N - M))), _.charAt(N) !== s.charAt(z) && (K *= rA)), (K < Rf && m.charAt(N - 1) === y.charAt(z + 1) || y.charAt(z + 1) === y.charAt(z) && m.charAt(N - 1) !== y.charAt(z)) && (se = fm(_, s, m, y, N + 1, z + 2, T), se * Rf > K && (K = se * Rf)), K > W && (W = K), N = m.indexOf(B, N + 1);
  return T[o] = W, W
}

function nv(_) {
  return _.toLowerCase().replace(g0, " ")
}

function v0(_, s, m) {
  return _ = m && m.length > 0 ? `${`${_} ${m==null?void 0:m.join(" ")}`}` : _, fm(_, s, nv(_), nv(s), 0, 0, {})
}
const oA = 18,
  y0 = 40,
  lA = `${y0}px`,
  cA = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");

function uA({
  containerRef: _,
  inputRef: s,
  pushPasswordManagerStrategy: m,
  isFocused: y,
  domContext: M
}) {
  let z = ut(!1),
    T = ut(!1),
    o = ut(!1);

  function B() {
    const W = m.current;
    return W === "none" ? !1 : W === "increase-width" && w(z) && w(T)
  }

  function N() {
    const W = _.current,
      K = s.current;
    if (!W || !K || w(o) || m.current === "none") return;
    const se = W,
      X = se.getBoundingClientRect().left + se.offsetWidth,
      me = se.getBoundingClientRect().top + se.offsetHeight / 2,
      ge = X - oA,
      Ee = me;
    M.querySelectorAll(cA).length === 0 && M.getDocument().elementFromPoint(ge, Ee) === W || (ce(z, !0), ce(o, !0))
  }
  return Xr(() => {
    const W = _.current;
    if (!W || m.current === "none") return;

    function K() {
      const me = o0(W).innerWidth - W.getBoundingClientRect().right;
      ce(T, me >= y0)
    }
    K();
    const se = setInterval(K, 1e3);
    return () => {
      clearInterval(se)
    }
  }), Xr(() => {
    const W = y.current || M.getActiveElement() === s.current;
    if (m.current === "none" || !W) return;
    const K = setTimeout(N, 0),
      se = setTimeout(N, 2e3),
      X = setTimeout(N, 5e3),
      me = setTimeout(() => {
        ce(o, !0)
      }, 6e3);
    return () => {
      clearTimeout(K), clearTimeout(se), clearTimeout(X), clearTimeout(me)
    }
  }), {
    get hasPwmBadge() {
      return w(z)
    },
    get willPushPwmBadge() {
      return B()
    },
    PWM_BADGE_SPACE_WIDTH: lA
  }
}
const x0 = l0({
    component: "pin-input",
    parts: ["root", "cell"]
  }),
  hA = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var Ha, Sc, Hs, Va, Wa, Cc, ws, Ws, To, Pc, ap, Th, Sh, sp, op, b0, Ch, Ph, lp, Ih;
const i_ = class i_ {
  constructor(s) {
    Ir(this, op);
    mr(this, "opts");
    mr(this, "attachment");
    Ir(this, Ha, _r(null));
    Ir(this, Sc, ut(!1));
    mr(this, "inputAttachment", Xa(rt(this, Ha)));
    Ir(this, Hs, _r(!1));
    Ir(this, Va, ut(null));
    Ir(this, Wa, ut(null));
    Ir(this, Cc, new X4(() => this.opts.value.current ?? ""));
    Ir(this, ws, ht(() => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
    Ir(this, Ws, ut(yi({
      prev: [null, null, "none"],
      willSyntheticBlur: !1
    })));
    Ir(this, To);
    Ir(this, Pc);
    mr(this, "domContext");
    mr(this, "onkeydown", s => {
      const m = s.key;
      hA.includes(m) || s.ctrlKey || s.metaKey || m && w(rt(this, ws)) && !w(rt(this, ws)).test(m) && s.preventDefault()
    });
    Ir(this, ap, ht(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    Ir(this, Th, ht(() => ({
      id: this.opts.id.current,
      [x0.root]: "",
      style: w(rt(this, ap)),
      ...this.attachment
    })));
    Ir(this, Sh, ht(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    Ir(this, sp, ht(() => ({
      position: "absolute",
      inset: 0,
      width: rt(this, To).willPushPwmBadge ? `calc(100% + ${rt(this,To).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: rt(this, To).willPushPwmBadge ? `inset(0 ${rt(this,To).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    Ir(this, Ch, () => {
      var ge;
      const s = rt(this, Ha).current,
        m = this.opts.ref.current;
      if (!s || !m) return;
      if (this.domContext.getActiveElement() !== s) {
        ce(rt(this, Va), null), ce(rt(this, Wa), null);
        return
      }
      const y = s.selectionStart,
        M = s.selectionEnd,
        z = s.selectionDirection ?? "none",
        T = s.maxLength,
        o = s.value,
        B = w(rt(this, Ws)).prev;
      let N = -1,
        W = -1,
        K;
      if (o.length !== 0 && y !== null && M !== null) {
        const Ee = y === M,
          ze = y === o.length && o.length < T;
        if (Ee && !ze) {
          const Re = y;
          if (Re === 0) N = 0, W = 1, K = "forward";
          else if (Re === T) N = Re - 1, W = Re, K = "backward";
          else if (T > 1 && o.length > 1) {
            let Ie = 0;
            if (B[0] !== null && B[1] !== null) {
              K = Re < B[0] ? "backward" : "forward";
              const Oe = B[0] === B[1] && B[0] < T;
              K === "backward" && !Oe && (Ie = -1)
            }
            N = Ie - Re, W = Ie + Re + 1
          }
        }
        N !== -1 && W !== -1 && N !== W && ((ge = rt(this, Ha).current) == null || ge.setSelectionRange(N, W, K))
      }
      const se = N !== -1 ? N : y,
        X = W !== -1 ? W : M,
        me = K ?? z;
      ce(rt(this, Va), se, !0), ce(rt(this, Wa), X, !0), w(rt(this, Ws)).prev = [se, X, me]
    });
    mr(this, "oninput", s => {
      const m = s.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (m.length > 0 && w(rt(this, ws)) && !w(rt(this, ws)).test(m)) {
        s.preventDefault();
        return
      }
      typeof rt(this, Cc).current == "string" && m.length < rt(this, Cc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")), this.opts.value.current = m
    });
    mr(this, "onfocus", s => {
      const m = rt(this, Ha).current;
      if (m) {
        const y = Math.min(m.value.length, this.opts.maxLength.current - 1),
          M = m.value.length;
        m.setSelectionRange(y, M), ce(rt(this, Va), y, !0), ce(rt(this, Wa), M, !0)
      }
      rt(this, Hs).current = !0
    });
    mr(this, "onpaste", s => {
      var W, K, se, X;
      const m = rt(this, Ha).current;
      if (!m) return;
      const y = me => {
          const ge = m.selectionStart === null ? void 0 : m.selectionStart,
            Ee = m.selectionEnd === null ? void 0 : m.selectionEnd,
            ze = ge !== Ee,
            Re = this.opts.value.current;
          return (ze ? Re.slice(0, ge) + me + Re.slice(Ee) : Re.slice(0, ge) + me + Re.slice(ge)).slice(0, this.opts.maxLength.current)
        },
        M = me => me.length > 0 && w(rt(this, ws)) && !w(rt(this, ws)).test(me);
      if (!((W = this.opts.pasteTransformer) != null && W.current) && (!rt(this, Pc).isIOS || !s.clipboardData || !m)) {
        const me = y((K = s.clipboardData) == null ? void 0 : K.getData("text/plain"));
        M(me) && s.preventDefault();
        return
      }
      const z = ((se = s.clipboardData) == null ? void 0 : se.getData("text/plain")) ?? "",
        T = (X = this.opts.pasteTransformer) != null && X.current ? this.opts.pasteTransformer.current(z) : z;
      s.preventDefault();
      const o = y(T);
      if (M(o)) return;
      m.value = o, this.opts.value.current = o;
      const B = Math.min(o.length, this.opts.maxLength.current - 1),
        N = o.length;
      m.setSelectionRange(B, N), ce(rt(this, Va), B, !0), ce(rt(this, Wa), N, !0)
    });
    mr(this, "onmouseover", s => {
      ce(rt(this, Sc), !0)
    });
    mr(this, "onmouseleave", s => {
      ce(rt(this, Sc), !1)
    });
    mr(this, "onblur", s => {
      if (w(rt(this, Ws)).willSyntheticBlur) {
        w(rt(this, Ws)).willSyntheticBlur = !1;
        return
      }
      rt(this, Hs).current = !1
    });
    Ir(this, Ph, ht(() => {
      var s;
      return {
        id: this.opts.inputId.current,
        style: w(rt(this, sp)),
        autocomplete: this.opts.autocomplete.current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": w(rt(this, Va)),
        "data-pin-input-input-mse": w(rt(this, Wa)),
        inputmode: this.opts.inputmode.current,
        pattern: (s = w(rt(this, ws))) == null ? void 0 : s.source,
        maxlength: this.opts.maxLength.current,
        value: this.opts.value.current,
        disabled: d6(this.opts.disabled.current),
        onpaste: this.onpaste,
        oninput: this.oninput,
        onkeydown: this.onkeydown,
        onmouseover: this.onmouseover,
        onmouseleave: this.onmouseleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.inputAttachment
      }
    }));
    Ir(this, lp, ht(() => Array.from({
      length: this.opts.maxLength.current
    }).map((s, m) => {
      const y = rt(this, Hs).current && w(rt(this, Va)) !== null && w(rt(this, Wa)) !== null && (w(rt(this, Va)) === w(rt(this, Wa)) && m === w(rt(this, Va)) || m >= w(rt(this, Va)) && m < w(rt(this, Wa))),
        M = this.opts.value.current[m] !== void 0 ? this.opts.value.current[m] : null;
      return {
        char: M,
        isActive: y,
        hasFakeCaret: y && M === null
      }
    })));
    Ir(this, Ih, ht(() => ({
      cells: w(rt(this, lp)),
      isFocused: rt(this, Hs).current,
      isHovering: w(rt(this, Sc))
    })));
    var m;
    this.opts = s, this.attachment = Xa(this.opts.ref), this.domContext = new s6(s.ref), ia(this, Pc, {
      value: this.opts.value,
      isIOS: typeof window < "u" && ((m = window == null ? void 0 : window.CSS) == null ? void 0 : m.supports("-webkit-touch-callout", "none"))
    }), ia(this, To, uA({
      containerRef: this.opts.ref,
      inputRef: rt(this, Ha),
      isFocused: rt(this, Hs),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    })), An(() => {
      const y = rt(this, Ha).current,
        M = this.opts.ref.current;
      if (!y || !M) return;
      rt(this, Pc).value.current !== y.value && (this.opts.value.current = y.value), w(rt(this, Ws)).prev = [y.selectionStart, y.selectionEnd, y.selectionDirection ?? "none"];
      const z = Nu(this.domContext.getDocument(), "selectionchange", rt(this, Ch), {
        capture: !0
      });
      rt(this, Ch).call(this), this.domContext.getActiveElement() === y && (rt(this, Hs).current = !0), this.domContext.getElementById("pin-input-style") || jr(this, op, b0).call(this);
      const T = () => {
        M && M.style.setProperty("--bits-pin-input-root-height", `${y.clientHeight}px`)
      };
      T();
      const o = new ResizeObserver(T);
      return o.observe(y), () => {
        z(), o.disconnect()
      }
    }), So([() => this.opts.value.current, () => rt(this, Ha).current], () => {
      dA(() => {
        const y = rt(this, Ha).current;
        if (!y) return;
        y.dispatchEvent(new Event("input"));
        const M = y.selectionStart,
          z = y.selectionEnd,
          T = y.selectionDirection ?? "none";
        M !== null && z !== null && (ce(rt(this, Va), M, !0), ce(rt(this, Wa), z, !0), w(rt(this, Ws)).prev = [M, z, T])
      }, this.domContext)
    }), Xr(() => {
      const y = this.opts.value.current,
        M = rt(this, Cc).current,
        z = this.opts.maxLength.current,
        T = this.opts.onComplete.current;
      M !== void 0 && y !== M && M.length < z && y.length === z && T(y)
    })
  }
  static create(s) {
    return new i_(s)
  }
  get rootProps() {
    return w(rt(this, Th))
  }
  set rootProps(s) {
    ce(rt(this, Th), s)
  }
  get inputWrapperProps() {
    return w(rt(this, Sh))
  }
  set inputWrapperProps(s) {
    ce(rt(this, Sh), s)
  }
  get inputProps() {
    return w(rt(this, Ph))
  }
  set inputProps(s) {
    ce(rt(this, Ph), s)
  }
  get snippetProps() {
    return w(rt(this, Ih))
  }
  set snippetProps(s) {
    ce(rt(this, Ih), s)
  }
};
Ha = new WeakMap, Sc = new WeakMap, Hs = new WeakMap, Va = new WeakMap, Wa = new WeakMap, Cc = new WeakMap, ws = new WeakMap, Ws = new WeakMap, To = new WeakMap, Pc = new WeakMap, ap = new WeakMap, Th = new WeakMap, Sh = new WeakMap, sp = new WeakMap, op = new WeakSet, b0 = function() {
  const s = this.domContext.getDocument(),
    m = s.createElement("style");
  if (m.id = "pin-input-style", s.head.appendChild(m), m.sheet) {
    const y = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    zu(m.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"), zu(m.sheet, `[data-pin-input-input]:autofill { ${y} }`), zu(m.sheet, `[data-pin-input-input]:-webkit-autofill { ${y} }`), zu(m.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), zu(m.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
  }
}, Ch = new WeakMap, Ph = new WeakMap, lp = new WeakMap, Ih = new WeakMap;
let mm = i_;
var Mh;
const a_ = class a_ {
  constructor(s) {
    mr(this, "opts");
    mr(this, "attachment");
    Ir(this, Mh, ht(() => ({
      id: this.opts.id.current,
      [x0.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
      ...this.attachment
    })));
    this.opts = s, this.attachment = Xa(this.opts.ref)
  }
  static create(s) {
    return new a_(s)
  }
  get props() {
    return w(rt(this, Mh))
  }
  set props(s) {
    ce(rt(this, Mh), s)
  }
};
Mh = new WeakMap;
let _m = a_;

function dA(_, s) {
  const m = s.setTimeout(_, 0),
    y = s.setTimeout(_, 10),
    M = s.setTimeout(_, 50);
  return [m, y, M]
}

function zu(_, s) {
  try {
    _.insertRule(s)
  } catch {
    console.error("pin input could not insert CSS rule:", s)
  }
}
var pA = Pe("<div><!> <div><input/></div></div>");

function fA(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "inputId", 19, () => `${Ya(m)}-input`),
    z = Et(s, "ref", 15, null),
    T = Et(s, "maxlength", 3, 6),
    o = Et(s, "textalign", 3, "left"),
    B = Et(s, "inputmode", 3, "numeric"),
    N = Et(s, "onComplete", 3, qu),
    W = Et(s, "pushPasswordManagerStrategy", 3, "increase-width"),
    K = Et(s, "class", 3, ""),
    se = Et(s, "autocomplete", 3, "one-time-code"),
    X = Et(s, "disabled", 3, !1),
    me = Et(s, "value", 15, ""),
    ge = Et(s, "onValueChange", 3, qu),
    Ee = ir(s, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
  const ze = mm.create({
      id: _r.with(() => y()),
      ref: _r.with(() => z(), Je => z(Je)),
      inputId: _r.with(() => M()),
      autocomplete: _r.with(() => se()),
      maxLength: _r.with(() => T()),
      textAlign: _r.with(() => o()),
      disabled: _r.with(() => X()),
      inputmode: _r.with(() => B()),
      pattern: _r.with(() => s.pattern),
      onComplete: _r.with(() => N()),
      value: _r.with(() => me(), Je => {
        me(Je), ge()(Je)
      }),
      pushPasswordManagerStrategy: _r.with(() => W()),
      pasteTransformer: _r.with(() => s.pasteTransformer)
    }),
    Re = ht(() => qa(Ee, ze.inputProps)),
    Ie = ht(() => qa(ze.rootProps, {
      class: K()
    })),
    Oe = ht(() => qa(ze.inputWrapperProps, {}));
  var st = pA();
  or(st, () => ({
    ...w(Ie)
  }));
  var nt = E(st);
  ii(nt, () => s.children ?? Ta, () => ze.snippetProps);
  var qe = Z(nt, 2);
  or(qe, () => ({
    ...w(Oe)
  }));
  var Ue = E(qe);
  us(Ue), or(Ue, () => ({
    ...w(Re)
  })), k(qe), k(st), H(_, st), Fr()
}
var mA = Pe("<div><!></div>");

function _A(_, s) {
  const m = cs();
  Br(s, !0);
  let y = Et(s, "id", 19, () => Ya(m)),
    M = Et(s, "ref", 15, null),
    z = ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
  const T = _m.create({
      id: _r.with(() => y()),
      ref: _r.with(() => M(), se => M(se)),
      cell: _r.with(() => s.cell)
    }),
    o = ht(() => qa(z, T.props));
  var B = Kt(),
    N = Ct(B);
  {
    var W = se => {
        var X = Kt(),
          me = Ct(X);
        ii(me, () => s.child, () => ({
          props: w(o)
        })), H(se, X)
      },
      K = se => {
        var X = mA();
        or(X, () => ({
          ...w(o)
        }));
        var me = E(X);
        ii(me, () => s.children ?? Ta), k(X), H(se, X)
      };
    je(N, se => {
      s.child ? se(W) : se(K, !1)
    })
  }
  H(_, B), Fr()
}

function Ac(..._) {
  return Ev(Fu(_))
}

function gA(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = Et(s, "value", 15, ""),
    M = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var z = Kt(),
    T = Ct(z);
  {
    let o = ht(() => Ac("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", s.class));
    vi(T, () => B6, (B, N) => {
      N(B, Co({
        "data-slot": "command",
        get class() {
          return w(o)
        }
      }, () => M, {
        get value() {
          return y()
        },
        set value(W) {
          y(W)
        },
        get ref() {
          return m()
        },
        set ref(W) {
          m(W)
        }
      }))
    })
  }
  H(_, z), Fr()
}
var vA = Lr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');

function pl(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = vA();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}

function yA(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var M = Kt(),
    z = Ct(M);
  {
    let T = ht(() => Ac("py-6 text-center text-sm", s.class));
    vi(z, () => O6, (o, B) => {
      B(o, Co({
        "data-slot": "command-empty",
        get class() {
          return w(T)
        }
      }, () => y, {
        get ref() {
          return m()
        },
        set ref(N) {
          m(N)
        }
      }))
    })
  }
  H(_, M), Fr()
}
var xA = Pe("<!> <!>", 1);

function bA(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var M = Kt(),
    z = Ct(M);
  {
    let T = ht(() => Ac("text-foreground overflow-hidden p-1", s.class)),
      o = ht(() => s.value ?? s.heading ?? `----${M6()}`);
    vi(z, () => j6, (B, N) => {
      N(B, Co({
        "data-slot": "command-group",
        get class() {
          return w(T)
        },
        get value() {
          return w(o)
        }
      }, () => y, {
        get ref() {
          return m()
        },
        set ref(W) {
          m(W)
        },
        children: (W, K) => {
          var se = xA(),
            X = Ct(se);
          {
            var me = Ee => {
              var ze = Kt(),
                Re = Ct(ze);
              vi(Re, () => q6, (Ie, Oe) => {
                Oe(Ie, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (st, nt) => {
                    _n();
                    var qe = Mi();
                    Ye(() => ye(qe, s.heading)), H(st, qe)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), H(Ee, ze)
            };
            je(X, Ee => {
              s.heading && Ee(me)
            })
          }
          var ge = Z(X, 2);
          vi(ge, () => $6, (Ee, ze) => {
            ze(Ee, {
              get children() {
                return s.children
              }
            })
          }), H(W, se)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  H(_, M), Fr()
}

function wA(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var M = Kt(),
    z = Ct(M);
  {
    let T = ht(() => Ac("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", s.class));
    vi(z, () => Y6, (o, B) => {
      B(o, Co({
        "data-slot": "command-item",
        get class() {
          return w(T)
        }
      }, () => y, {
        get ref() {
          return m()
        },
        set ref(N) {
          m(N)
        }
      }))
    })
  }
  H(_, M), Fr()
}
var TA = Lr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');

function SA(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = TA();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var CA = Pe('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function PA(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = Et(s, "value", 15, ""),
    M = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var z = CA(),
    T = E(z);
  SA(T, {
    class: "size-5 opacity-50"
  });
  var o = Z(T, 2);
  {
    let B = ht(() => Ac("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", s.class));
    vi(o, () => H6, (N, W) => {
      W(N, Co({
        "data-slot": "command-input",
        get class() {
          return w(B)
        }
      }, () => M, {
        get ref() {
          return m()
        },
        set ref(K) {
          m(K)
        },
        get value() {
          return y()
        },
        set value(K) {
          y(K)
        }
      }))
    })
  }
  k(z), H(_, z), Fr()
}

function IA(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var M = Kt(),
    z = Ct(M);
  {
    let T = ht(() => Ac("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", s.class));
    vi(z, () => J6, (o, B) => {
      B(o, Co({
        "data-slot": "command-list",
        get class() {
          return w(T)
        }
      }, () => y, {
        get ref() {
          return m()
        },
        set ref(N) {
          m(N)
        }
      }))
    })
  }
  H(_, M), Fr()
}
var MA = Lr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function AA(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = MA();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var kA = Pe("<span> </span> <!>", 1),
  EA = Pe('<span class="font-flag ml-0.5"> </span> ', 1),
  zA = Pe('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  LA = Pe("<!> <!>", 1),
  DA = Pe("<!> <!>", 1),
  RA = (_, s) => {
    s(0)
  },
  BA = Pe('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  FA = Pe('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function iv(_, s) {
  Br(s, !0);
  let m = Et(s, "countryId", 15, 0),
    y = Et(s, "dropdownDirection", 3, "right"),
    M = ut(null),
    z = ut(null),
    T = ut("");

  function o() {
    Tv().then(() => {
      var Ie;
      (Ie = document.activeElement) == null || Ie.blur(), ce(T, "")
    })
  }
  var B = FA(),
    N = E(B),
    W = E(N),
    K = E(W);
  {
    var se = Ie => {
        var Oe = kA(),
          st = Ct(Oe),
          nt = E(st, !0);
        k(st);
        var qe = Z(st, 2);
        AA(qe, {
          class: "size-3.5"
        }), Ye(Ue => ye(nt, Ue), [() => Nv()]), H(Ie, Oe)
      },
      X = Ie => {
        const Oe = ht(() => Ts(m()));
        var st = EA(),
          nt = Ct(st),
          qe = E(nt, !0);
        k(nt);
        var Ue = Z(nt);
        Ye(() => {
          ye(qe, w(Oe).flag), ye(Ue, ` ${w(Oe).name??""}`)
        }), H(Ie, st)
      };
    je(K, Ie => {
      m() === 0 ? Ie(se) : Ie(X, !1)
    })
  }
  k(W);
  var me = Z(W, 2);
  let ge;
  var Ee = E(me);
  vi(Ee, () => gA, (Ie, Oe) => {
    Oe(Ie, {
      children: (st, nt) => {
        var qe = DA(),
          Ue = Ct(qe);
        vi(Ue, () => PA, (Fe, it) => {
          it(Fe, {
            placeholder: "Country",
            get ref() {
              return w(M)
            },
            set ref(tt) {
              ce(M, tt)
            },
            get value() {
              return w(T)
            },
            set value(tt) {
              ce(T, tt, !0)
            }
          })
        });
        var Je = Z(Ue, 2);
        vi(Je, () => IA, (Fe, it) => {
          it(Fe, {
            children: (tt, $e) => {
              var Ae = LA(),
                gt = Ct(Ae);
              vi(gt, () => yA, (re, _e) => {
                _e(re, {
                  children: (ae, ke) => {
                    _n();
                    var Le = Mi();
                    Ye(lt => ye(Le, lt), [() => Mw()]), H(ae, Le)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var Q = Z(gt, 2);
              vi(Q, () => bA, (re, _e) => {
                _e(re, {
                  children: (ae, ke) => {
                    var Le = Kt(),
                      lt = Ct(Le);
                    ui(lt, 17, () => Xi.countries, We => We.id, (We, _t) => {
                      var zt = Kt(),
                        Dt = Ct(zt);
                      vi(Dt, () => wA, (ot, dt) => {
                        dt(ot, {
                          get value() {
                            return w(_t).name
                          },
                          onSelect: () => {
                            m(w(_t).id), o()
                          },
                          children: (vt, ft) => {
                            var Tt = zA(),
                              xt = E(Tt),
                              pt = E(xt, !0);
                            k(xt);
                            var At = Z(xt);
                            k(Tt), Ye(() => {
                              ye(pt, w(_t).flag), ye(At, ` ${w(_t).name??""}`)
                            }), H(vt, Tt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), H(We, zt)
                    }), H(ae, Le)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), H(tt, Ae)
            },
            $$slots: {
              default: !0
            }
          })
        }), H(st, qe)
      },
      $$slots: {
        default: !0
      }
    })
  }), k(me), k(N);
  var ze = Z(N, 2);
  {
    var Re = Ie => {
      var Oe = BA();
      Oe.__click = [RA, m];
      var st = E(Oe);
      pl(st, {
        class: "size-3.5"
      }), k(Oe), H(Ie, Oe)
    };
    je(ze, Ie => {
      m() != 0 && Ie(Re)
    })
  }
  k(B), Xs(B, Ie => ce(z, Ie), () => w(z)), Ye(Ie => ge = zr(me, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, ge, Ie), [() => ({
    "right-1": y() === "left"
  })]), Ai("focus", W, () => {
    w(M).focus()
  }), H(_, B), Fr()
}
ri(["click"]);
var OA = Lr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function NA(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = OA();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var jA = Lr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  VA = Lr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function gm(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = Kt(),
    M = Ct(y);
  {
    var z = o => {
        var B = jA();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      },
      T = o => {
        var B = VA();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      };
    je(M, o => {
      s.filled ? o(z) : o(T, !1)
    })
  }
  H(_, y)
}
var qA = Pe('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  ZA = Pe('<div class="mb-2"><!></div>'),
  UA = Pe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  $A = (_, s, m) => {
    s.onvisitclick({
      lat: w(m).lastLatitude,
      lng: w(m).lastLongitude
    })
  },
  GA = Pe('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  HA = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  WA = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  XA = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  YA = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  KA = Pe("<span> </span>"),
  JA = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  QA = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  ek = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  tk = Pe('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  rk = Pe('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  nk = Pe('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function ik(_, s) {
  Br(s, !0);
  const m = [];
  let y = ut(1e3);
  const M = ht(() => w(y) <= 640);
  let z = ut("today"),
    T = {
      regions: {
        label: HT(),
        icon: Sm
      },
      countries: {
        label: YT(),
        icon: NA
      },
      players: {
        label: Gv(),
        icon: _p
      },
      alliances: {
        label: Hv(),
        icon: gp
      }
    },
    o = ut("regions"),
    B = ut(0),
    N = yi({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    W = ht(() => {
      var qe, Ue, Je;
      return w(o) === "regions" ? (Ue = (qe = N[w(o)][w(B)]) == null ? void 0 : qe[w(z)]) == null ? void 0 : Ue.entries : (Je = N[w(o)][w(z)]) == null ? void 0 : Je.entries
    });
  const K = 5 * 1e3;
  Xr(() => {
    var Fe;
    if (!s.open) return;
    const qe = w(z),
      Ue = w(o),
      Je = w(B);
    Ue === "players" && (!N[Ue][qe] || Date.now() - N[Ue][qe].time > K) ? an.leaderboardPlayers(qe).then(it => {
      N[Ue][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Vr.error(it.message)) : Ue === "alliances" && (!N[Ue][qe] || Date.now() - N[Ue][qe].time > K) ? an.leaderboardAlliances(qe).then(it => {
      N[Ue][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Vr.error(it.message)) : Ue === "countries" && (!N[Ue][qe] || Date.now() - N[Ue][qe].time > K) ? an.leaderboardCountries(qe).then(it => {
      N[Ue][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Vr.error(it.message)) : Ue === "regions" && (!((Fe = N[Ue][Je]) != null && Fe[qe]) || Date.now() - N[Ue][Je][qe].time > K) && an.leaderboardRegions(qe, Je).then(it => {
      N[Ue][Je] || (N[Ue][Je] = {}), N[Ue][Je][qe] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => Vr.error(it.message))
  });
  var se = nk(),
    X = Ct(se);
  ui(X, 21, () => Object.entries(T), ([qe, {
    label: Ue,
    icon: Je
  }]) => qe, (qe, Ue) => {
    var Je = ht(() => Sv(w(Ue), 2));
    let Fe = () => w(Je)[0],
      it = () => w(Je)[1].label,
      tt = () => w(Je)[1].icon;
    const $e = ht(tt);
    var Ae = qA(),
      gt = E(Ae);
    us(gt);
    var Q, re = Z(gt, 2);
    vi(re, () => w($e), (ae, ke) => {
      ke(ae, {
        get this() {
          return tt()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var _e = Z(re);
    k(Ae), Ye(() => {
      kr(gt, "aria-label", it()), Q !== (Q = Fe()) && (gt.value = (gt.__value = Fe()) ?? ""), ye(_e, ` ${it()??""}`)
    }), Im(m, [], gt, () => (Fe(), w(o)), ae => ce(o, ae)), H(qe, Ae)
  }), k(X);
  var me = Z(X, 2),
    ge = E(me);
  Nm(ge, {
    get value() {
      return w(z)
    },
    set value(qe) {
      ce(z, qe, !0)
    }
  });
  var Ee = Z(ge, 2);
  {
    var ze = qe => {
      iv(qe, {
        dropdownDirection: "left",
        get countryId() {
          return w(B)
        },
        set countryId(Ue) {
          ce(B, Ue, !0)
        }
      })
    };
    je(Ee, qe => {
      w(o) === "regions" && !w(M) && qe(ze)
    })
  }
  k(me);
  var Re = Z(me, 2);
  {
    var Ie = qe => {
      var Ue = ZA(),
        Je = E(Ue);
      iv(Je, {
        get countryId() {
          return w(B)
        },
        set countryId(Fe) {
          ce(B, Fe, !0)
        }
      }), k(Ue), H(qe, Ue)
    };
    je(Re, qe => {
      w(o) === "regions" && w(M) && qe(Ie)
    })
  }
  var Oe = Z(Re, 2);
  {
    var st = qe => {
        var Ue = UA(),
          Je = E(Ue),
          Fe = Z(Je);
        {
          var it = $e => {
              var Ae = Mi();
              Ye(gt => ye(Ae, gt), [() => mp().toLowerCase()]), H($e, Ae)
            },
            tt = $e => {
              var Ae = Kt(),
                gt = Ct(Ae);
              {
                var Q = _e => {
                    var ae = Mi();
                    Ye(ke => ye(ae, ke), [() => zm()]), H(_e, ae)
                  },
                  re = _e => {
                    var ae = Kt(),
                      ke = Ct(ae);
                    {
                      var Le = lt => {
                        var We = Mi();
                        Ye(_t => ye(We, _t), [() => Lm()]), H(lt, We)
                      };
                      je(ke, lt => {
                        w(z) === "month" && lt(Le)
                      }, !0)
                    }
                    H(_e, ae)
                  };
                je(gt, _e => {
                  w(z) === "week" ? _e(Q) : _e(re, !1)
                }, !0)
              }
              H($e, Ae)
            };
          je(Fe, $e => {
            w(z) === "today" ? $e(it) : $e(tt, !1)
          })
        }
        k(Ue), Ye($e => ye(Je, `${$e??""} `), [() => Em()]), H(qe, Ue)
      },
      nt = qe => {
        var Ue = Kt(),
          Je = Ct(Ue);
        {
          var Fe = tt => {
              var $e = Kt(),
                Ae = Ct($e);
              {
                var gt = re => {
                    const _e = ht(() => w(W));
                    var ae = HA(),
                      ke = E(ae),
                      Le = E(ke),
                      lt = Z(E(Le)),
                      We = E(lt, !0);
                    k(lt);
                    var _t = Z(lt),
                      zt = E(_t),
                      Dt = Z(zt, 2),
                      ot = Z(Dt),
                      dt = E(ot);
                    gm(dt, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), k(ot), k(_t), _n(), k(Le), k(ke);
                    var vt = Z(ke);
                    ui(vt, 31, () => w(_e), ft => ft.id, (ft, Tt, xt) => {
                      const pt = ht(() => Ts(w(Tt).countryId));
                      var At = GA(),
                        Wt = E(At),
                        Xt = E(Wt, !0);
                      k(Wt);
                      var rr = Z(Wt),
                        er = E(rr),
                        It = E(er, !0);
                      k(er);
                      var ur = Z(er, 2),
                        yr = E(ur),
                        Mr = Z(yr),
                        Gr = E(Mr);
                      k(Mr), k(ur), k(rr);
                      var xr = Z(rr),
                        Sr = E(xr, !0);
                      k(xr);
                      var wr = Z(xr),
                        gr = E(wr);
                      gr.__click = [$A, s, Tt];
                      var Ar = E(gr, !0);
                      k(gr), k(wr), k(At), Ye((ue, j, U) => {
                        ye(Xt, w(xt) + 1), kr(er, "data-tip", w(pt).name), ye(It, w(pt).flag), zr(ur, 1, `font-semibold ${ue??""}`), ye(yr, `${w(Tt).name??""} `), ye(Gr, `#${w(Tt).number??""}`), ye(Sr, j), ye(Ar, U)
                      }, [() => Ri(w(Tt).cityId), () => w(Tt).pixelsPainted.toLocaleString("en-US"), () => pS()]), sl(At, () => ol, () => ({
                        duration: 200
                      })), H(ft, At)
                    }), k(vt), k(ae), Ye((ft, Tt, xt, pt) => {
                      ye(We, ft), ye(zt, `${Tt??""} `), ye(Dt, `${xt??""} `), kr(ot, "data-tip", pt)
                    }, [() => nS(), () => _c(), () => gc().toLowerCase(), () => uS()]), H(re, ae)
                  },
                  Q = re => {
                    var _e = Kt(),
                      ae = Ct(_e);
                    {
                      var ke = lt => {
                          var We = XA(),
                            _t = E(We),
                            zt = E(_t),
                            Dt = Z(E(zt)),
                            ot = E(Dt, !0);
                          k(Dt);
                          var dt = Z(Dt),
                            vt = E(dt),
                            ft = Z(vt, 2),
                            Tt = Z(ft),
                            xt = E(Tt);
                          gm(xt, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), k(Tt), k(dt), k(zt), k(_t);
                          var pt = Z(_t);
                          ui(pt, 31, () => w(W), At => At.id, (At, Wt, Xt) => {
                            const rr = ht(() => Ts(w(Wt).id));
                            var er = WA(),
                              It = E(er),
                              ur = E(It, !0);
                            k(It);
                            var yr = Z(It),
                              Mr = E(yr),
                              Gr = E(Mr, !0);
                            k(Mr);
                            var xr = Z(Mr, 2),
                              Sr = E(xr, !0);
                            k(xr), k(yr);
                            var wr = Z(yr),
                              gr = E(wr, !0);
                            k(wr), k(er), Ye((Ar, ue) => {
                              ye(ur, w(Xt) + 1), kr(Mr, "data-tip", w(rr).name), ye(Gr, w(rr).flag), zr(xr, 1, `font-semibold ${Ar??""}`), ye(Sr, w(rr).name), ye(gr, ue)
                            }, [() => Ri(w(Wt).id), () => w(Wt).pixelsPainted.toLocaleString("en-US")]), sl(er, () => ol, () => ({
                              duration: 200
                            })), H(At, er)
                          }), k(pt), k(We), Ye((At, Wt, Xt, rr) => {
                            ye(ot, At), ye(vt, `${Wt??""} `), ye(ft, `${Xt??""} `), kr(Tt, "data-tip", rr)
                          }, [() => Nv(), () => _c(), () => gc().toLowerCase(), () => ZS()]), H(lt, We)
                        },
                        Le = lt => {
                          var We = Kt(),
                            _t = Ct(We);
                          {
                            var zt = ot => {
                                const dt = ht(() => w(W));
                                var vt = QA(),
                                  ft = E(vt),
                                  Tt = E(ft),
                                  xt = Z(E(Tt)),
                                  pt = E(xt, !0);
                                k(xt);
                                var At = Z(xt),
                                  Wt = E(At),
                                  Xt = Z(Wt, 2, !0);
                                k(At), k(Tt), k(ft);
                                var rr = Z(ft);
                                ui(rr, 31, () => w(dt), er => er.id, (er, It, ur) => {
                                  const yr = ht(() => {
                                    var xe;
                                    return ((xe = Mt.data) == null ? void 0 : xe.id) === w(It).id
                                  });
                                  var Mr = JA();
                                  let Gr;
                                  var xr = E(Mr),
                                    Sr = E(xr, !0);
                                  k(xr);
                                  var wr = Z(xr),
                                    gr = E(wr),
                                    Ar = E(gr);
                                  ls(Ar, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return w(It).id
                                    },
                                    get pictureUrl() {
                                      return w(It).picture
                                    }
                                  });
                                  var ue = Z(Ar, 2),
                                    j = E(ue),
                                    U = E(j),
                                    Y = Z(U),
                                    ie = E(Y);
                                  k(Y), k(j);
                                  var he = Z(j, 2);
                                  {
                                    var Te = xe => {
                                      const Nt = ht(() => Ts(w(It).equippedFlag));
                                      var Jt = YA(),
                                        jt = E(Jt, !0);
                                      k(Jt), Ye(() => {
                                        kr(Jt, "data-tip", w(Nt).name), ye(jt, w(Nt).flag)
                                      }), H(xe, Jt)
                                    };
                                    je(he, xe => {
                                      w(It).equippedFlag && xe(Te)
                                    })
                                  }
                                  var Me = Z(he, 2);
                                  {
                                    var we = xe => {
                                      Ah(xe, {
                                        get username() {
                                          return w(It).discord
                                        }
                                      })
                                    };
                                    je(Me, xe => {
                                      w(It).discord && xe(we)
                                    })
                                  }
                                  var Ne = Z(Me, 2);
                                  {
                                    var ct = xe => {
                                      var Nt = KA(),
                                        Jt = E(Nt, !0);
                                      k(Nt), Ye((jt, hr) => {
                                        zr(Nt, 1, `badge badge-sm ml-0.5 border-0 ${jt??""} ${hr??""}`), ye(Jt, w(It).allianceName)
                                      }, [() => up(w(It).allianceId), () => Ri(w(It).allianceId)]), H(xe, Nt)
                                    };
                                    je(Ne, xe => {
                                      "allianceName" in w(It) && w(It).allianceName && xe(ct)
                                    })
                                  }
                                  k(ue), k(gr), k(wr);
                                  var Qe = Z(wr),
                                    kt = E(Qe, !0);
                                  k(Qe), k(Mr), Ye((xe, Nt, Jt) => {
                                    Gr = zr(Mr, 1, "", null, Gr, xe), ye(Sr, w(ur) + 1), zr(j, 1, `font-semibold max-sm:ml-2 ${Nt??""} flex gap-1`), ye(U, `${w(It).name??""} `), ye(ie, `#${w(It).id??""}`), ye(kt, Jt)
                                  }, [() => ({
                                    "bg-base-200": w(yr)
                                  }), () => Ri(w(It).id), () => w(It).pixelsPainted.toLocaleString("en-US")]), sl(Mr, () => ol, () => ({
                                    duration: 200
                                  })), H(er, Mr)
                                }), k(rr), k(vt), Ye((er, It, ur) => {
                                  ye(pt, er), ye(Wt, `${It??""} `), ye(Xt, ur)
                                }, [() => Dm(), () => _c(), () => gc().toLowerCase()]), H(ot, vt)
                              },
                              Dt = ot => {
                                var dt = Kt(),
                                  vt = Ct(dt);
                                {
                                  var ft = Tt => {
                                    var xt = tk(),
                                      pt = E(xt),
                                      At = E(pt),
                                      Wt = Z(E(At)),
                                      Xt = E(Wt, !0);
                                    k(Wt);
                                    var rr = Z(Wt),
                                      er = E(rr),
                                      It = Z(er, 2, !0);
                                    k(rr), k(At), k(pt);
                                    var ur = Z(pt);
                                    ui(ur, 31, () => w(W), yr => yr.id, (yr, Mr, Gr) => {
                                      const xr = ht(() => {
                                        var he;
                                        return ((he = Mt.data) == null ? void 0 : he.allianceId) === w(Mr).id
                                      });
                                      var Sr = ek();
                                      let wr;
                                      var gr = E(Sr),
                                        Ar = E(gr, !0);
                                      k(gr);
                                      var ue = Z(gr),
                                        j = E(ue),
                                        U = E(j, !0);
                                      k(j), k(ue);
                                      var Y = Z(ue),
                                        ie = E(Y, !0);
                                      k(Y), k(Sr), Ye((he, Te, Me) => {
                                        wr = zr(Sr, 1, "", null, wr, he), ye(Ar, w(Gr) + 1), zr(j, 1, `font-semibold ${Te??""}`), ye(U, w(Mr).name), ye(ie, Me)
                                      }, [() => ({
                                        "bg-base-200": w(xr)
                                      }), () => Ri(w(Mr).id), () => w(Mr).pixelsPainted.toLocaleString("en-US")]), sl(Sr, () => ol, () => ({
                                        duration: 200
                                      })), H(yr, Sr)
                                    }), k(ur), k(xt), Ye((yr, Mr, Gr) => {
                                      ye(Xt, yr), ye(er, `${Mr??""} `), ye(It, Gr)
                                    }, [() => pp(), () => _c(), () => gc().toLowerCase()]), H(Tt, xt)
                                  };
                                  je(vt, Tt => {
                                    w(o) === "alliances" && Tt(ft)
                                  }, !0)
                                }
                                H(ot, dt)
                              };
                            je(_t, ot => {
                              w(o) === "players" ? ot(zt) : ot(Dt, !1)
                            }, !0)
                          }
                          H(lt, We)
                        };
                      je(ae, lt => {
                        w(o) === "countries" ? lt(ke) : lt(Le, !1)
                      }, !0)
                    }
                    H(re, _e)
                  };
                je(Ae, re => {
                  w(o) === "regions" ? re(gt) : re(Q, !1)
                })
              }
              H(tt, $e)
            },
            it = tt => {
              var $e = rk();
              H(tt, $e)
            };
          je(Je, tt => {
            w(W) ? tt(Fe) : tt(it, !1)
          }, !0)
        }
        H(qe, Ue)
      };
    je(Oe, qe => {
      w(W) && w(W).length === 0 ? qe(st) : qe(nt, !1)
    })
  }
  dp("innerWidth", qe => ce(y, qe, !0)), H(_, se), Fr()
}
ri(["click"]);
var ak = Lr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function w0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = ak();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var sk = Pe('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function ok(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  An(() => {
    const K = se => {
      se.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", K), () => document.removeEventListener("keydown", K)
  });
  var y = sk(),
    M = E(y),
    z = Z(E(M), 2),
    T = E(z);
  w0(T, {
    class: "size-6"
  });
  var o = Z(T, 2),
    B = E(o, !0);
  k(o), k(z);
  var N = Z(z, 2),
    W = E(N);
  ik(W, {
    get onvisitclick() {
      return s.onvisitclick
    },
    get open() {
      return m()
    }
  }), k(N), k(M), _n(2), k(y), Yi(y, () => K => {
    Xr(() => {
      m() ? K.show() : K.close()
    })
  }), Ye(K => ye(B, K), [() => Am()]), Ai("close", y, () => m(!1)), H(_, y), Fr()
}
var lk = Pe("<div><!></div>"),
  ck = Pe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function uk(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  An(() => {
    const o = B => {
      B.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", o), () => document.removeEventListener("keydown", o)
  });
  var y = ck(),
    M = E(y),
    z = Z(E(M), 2);
  {
    var T = o => {
      var B = lk(),
        N = E(B);
      I1(N, {}), k(B), Ii(2, B, () => aa, () => ({
        duration: 300
      })), H(o, B)
    };
    je(z, o => {
      m() && o(T)
    })
  }
  k(M), _n(2), k(y), Yi(y, () => o => {
    Xr(() => {
      m() ? o.show() : o.close()
    })
  }), Ai("close", y, () => m(!1)), H(_, y), Fr()
}
var hk = (_, s, m) => {
    localStorage.setItem(w(s), "true"), ce(m, !1)
  },
  dk = Pe('<span class="indicator-item indicator-bottom indicator-center badge badge-primary badge-xs">new</span>'),
  pk = Pe("<div><!> <!></div>");

function Ff(_, s) {
  Br(s, !0);
  let m = ut(!1);
  const y = ht(() => "showed:" + s.key);
  An(() => {
    ce(m, !localStorage.getItem(w(y)))
  });
  var M = pk();
  M.__click = [hk, y, m];
  var z = E(M);
  {
    var T = B => {
      var N = dk();
      Ii(3, N, () => aa, () => ({
        duration: 200
      })), H(B, N)
    };
    je(z, B => {
      w(m) && B(T)
    })
  }
  var o = Z(z, 2);
  ii(o, () => s.children), k(M), Ye(() => zr(M, 1, `indicator ${s.class??""}`)), H(_, M), Fr()
}
ri(["click"]);
var fk = Pe("<p>You don't have charges to paint. <br/> </p>");

function mk(_, s) {
  Br(s, !1), Rv();
  var m = fk(),
    y = Z(E(m), 2);
  k(m), Ye(M => ye(y, ` Next charge in ${M??""}`), [() => ep(Mt.cooldown ?? 0)]), H(_, m), Fr()
}
var _k = Pe("<canvas></canvas>");

function T0(_, s) {
  Br(s, !0);
  let m = Et(s, "width", 15, 0),
    y = ir(s, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    M = ht(() => Math.ceil(s.fontSize)),
    z = ut(null);
  const T = window.devicePixelRatio ?? 1,
    o = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    B = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  Xr(() => {
    const W = w(z).getContext("2d");
    W.textBaseline = "top", W.font = `${s.weight??"normal"} ${s.fontSize}px ${s.mono?B:o}`, W.fillStyle = s.color ?? "#394e6a", W.setTransform(T, 0, 0, T, 0, 0), W.clearRect(0, 0, m(), w(M)), W.fillText(s.value, 0, 0);
    const K = W.measureText(s.value);
    m(Math.ceil(K.actualBoundingBoxRight)), ce(M, K.actualBoundingBoxDescent)
  });
  var N = _k();
  or(N, () => ({
    width: m() * T,
    height: w(M) * T,
    style: `width: ${m()??""}px; height: ${w(M)??""}px`,
    ...y
  })), Xs(N, W => ce(z, W), () => w(z)), H(_, N), Fr()
}
var gk = Pe('<span class="w-7 text-xs"> </span>'),
  vk = Pe('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'),
  yk = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  xk = Pe('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');

function S0(_, s) {
  Br(s, !0);
  let m = ir(s, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
    y = ut(0);
  var M = xk();
  or(M, () => ({
    ...m,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${s.class??""}`
  }));
  var z = E(M);
  kh(z, {
    class: "size-6"
  });
  var T = Z(z, 2),
    o = E(T),
    B = Z(o);
  {
    var N = se => {
      const X = ht(() => `${Math.floor(s.charges)}/${Mt.data.charges.max}`);
      var me = vk(),
        ge = E(me),
        Ee = E(ge);
      {
        let Ie = ht(() => s.disabled ? "#394e6a33" : "#ffffff");
        T0(Ee, {
          weight: 600,
          fontSize: 16,
          get value() {
            return w(X)
          },
          get color() {
            return w(Ie)
          },
          get width() {
            return w(y)
          },
          set width(Oe) {
            ce(y, Oe, !0)
          }
        })
      }
      k(ge);
      var ze = Z(ge, 2);
      {
        var Re = Ie => {
          var Oe = gk(),
            st = E(Oe);
          k(Oe), Ye(nt => ye(st, `(${nt??""})`), [() => ep(Mt.cooldown)]), H(Ie, Oe)
        };
        je(ze, Ie => {
          s.charges < Mt.data.charges.max && Mt.cooldown !== void 0 && Ie(Re)
        })
      }
      k(me), Ye(Ie => Ic(ge, `width: ${Ie??""}px`), [() => (Math.floor(w(y) / 5) + 1) * 5]), H(se, me)
    };
    je(B, se => {
      s.charges !== void 0 && Mt.data && se(N)
    })
  }
  k(T);
  var W = Z(T, 2);
  {
    var K = se => {
      var X = yk();
      H(se, X)
    };
    je(W, se => {
      s.loading && se(K)
    })
  }
  k(M), Ye(se => ye(o, `${se??""} `), [() => Vv()]), H(_, M), Fr()
}
const bk = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  wk = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  Tk = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  Sk = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class Ck {
  constructor(s) {
    mr(this, "gm");
    mr(this, "opacity", 1);
    mr(this, "id", `paint-preview-${Math.random()}`);
    mr(this, "tiles", new Map);
    this.input = s, this.gm = new hl(this.input.tileSize)
  }
  place([s, m], y) {
    const {
      tile: M,
      pixel: z
    } = this.gm.latLonToTileAndPixel(s, m, this.input.tileZoom), T = this.getTileKey(M[0], M[1]);
    let o = this.tiles.get(T);
    if (!o) {
      const B = this.gm.tileBoundsLatLon(M[0], M[1], this.input.tileZoom),
        N = Rm(B, !0),
        W = new Pk({
          coordinates: N,
          id: `${this.id}-${T}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      W.addTo(this.input.map), this.tiles.set(T, W), o = W
    }
    o.place(z[0], this.input.tileSize - z[1] - 1, y)
  }
  clear() {
    const s = this.input.map;
    for (const m of this.tiles.values()) m.removeFrom(s), m.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(s, m) {
    this.clear(), this.place(s, m)
  }
  remove([s, m]) {
    const {
      tile: y,
      pixel: M
    } = this.gm.latLonToTileAndPixel(s, m, this.input.tileZoom), z = this.getTileKey(y[0], y[1]), T = this.tiles.get(z);
    T && T.remove(M[0], this.input.tileSize - M[1] - 1)
  }
  setCanvasOpacity(s) {
    this.opacity = s;
    for (const m of this.tiles.values()) m.setOpacity(s)
  }
  getTileKey(s, m) {
    return `${s},${m}`
  }
}
class Pk {
  constructor(s) {
    mr(this, "canvas");
    mr(this, "maps", new Set);
    this.input = s;
    const m = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = m, this.canvas.height = m
  }
  place(s, m, y) {
    var T;
    const M = ((T = Xi.colors) == null ? void 0 : T[y]) ?? Xi.colors[0],
      z = this.canvas.getContext("2d");
    if (z) {
      const o = z.createImageData(1, 1),
        [B, N, W] = M.rgb,
        K = y === 0 ? 0 : 255;
      o.data[0] = B, o.data[1] = N, o.data[2] = W, o.data[3] = K, z.putImageData(o, s, m)
    }
  }
  remove(s, m) {
    const y = this.canvas.getContext("2d");
    y && y.clearRect(s, m, 1, 1)
  }
  addTo(s) {
    const m = this.input.id;
    s.getSource(m) || s.addSource(m, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), s.getLayer(m) || (s.addLayer({
      id: m,
      type: "raster",
      source: m,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && s.moveLayer(m, this.input.beforeLayerId)), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: m
    } = this.input;
    s.getLayer(m) && s.removeLayer(m), s.getSource(m) && s.removeSource(m), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(s) {
    for (const m of this.maps.values()) m.setPaintProperty(this.input.id, "raster-opacity", s)
  }
}
var Ik = Lr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function Mk(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = Ik();
  or(y, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...m
  })), H(_, y)
}
var Ak = Lr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function kk(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = Ak();
  or(y, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...m
  })), H(_, y)
}
var Ek = Pe("<div><!></div>");

function il(_, s) {
  Br(s, !0);
  var m = Ek(),
    y = E(m);
  ii(y, () => s.children ?? Ta), k(m), Ye(() => zr(m, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${s.class??""}`)), H(_, m), Fr()
}
var zk = Pe('<div class="confetti svelte-15ksp55"></div>'),
  Lk = Pe("<div></div>");

function Um(_, s) {
  Br(s, !0);
  const m = Et(s, "size", 3, 10),
    y = Et(s, "x", 19, () => [-.5, .5]),
    M = Et(s, "y", 19, () => [.25, 1]),
    z = Et(s, "duration", 3, 2e3),
    T = Et(s, "infinite", 3, !1),
    o = Et(s, "delay", 19, () => [0, 50]),
    B = Et(s, "colorRange", 19, () => [0, 360]),
    N = Et(s, "colorArray", 19, () => []),
    W = Et(s, "amount", 3, 50),
    K = Et(s, "iterationCount", 3, 1),
    se = Et(s, "fallDistance", 3, "100px"),
    X = Et(s, "rounded", 3, !1),
    me = Et(s, "cone", 3, !1),
    ge = Et(s, "noGravity", 3, !1),
    Ee = Et(s, "xSpread", 3, .15),
    ze = Et(s, "destroyOnComplete", 3, !0),
    Re = Et(s, "disableForReducedMotion", 3, !1);
  let Ie = ut(!1);
  An(() => {
    !ze() || T() || typeof K() == "string" || setTimeout(() => ce(Ie, !0), (z() + o()[1]) * K())
  });

  function Oe(Je, Fe) {
    return Math.random() * (Fe - Je) + Je
  }

  function st() {
    return N().length ? N()[Math.round(Math.random() * (N().length - 1))] : `hsl(${Math.round(Oe(B()[0],B()[1]))}, 75%, 50%)`
  }
  var nt = Kt(),
    qe = Ct(nt);
  {
    var Ue = Je => {
      var Fe = Lk();
      let it;
      ui(Fe, 21, () => ({
        length: W()
      }), cp, (tt, $e) => {
        var Ae = zk();
        Ye((gt, Q, re, _e, ae, ke, Le, lt, We, _t, zt) => Ic(Ae, `
        --color: ${gt??""};
        --skew: ${Q??""}deg,${re??""}deg;
        --rotation-xyz: ${_e??""}, ${ae??""}, ${ke??""};
        --rotation-deg: ${Le??""}deg;
        --translate-y-multiplier: ${lt??""};
        --translate-x-multiplier: ${We??""};
        --scale: ${_t??""};
        --transition-delay: ${zt??""}ms;
        --transition-duration: ${T()?`calc(${z()}ms * var(--scale))`:`${z()}ms`};`), [st, () => Oe(-45, 45), () => Oe(-45, 45), () => Oe(-10, 10), () => Oe(-10, 10), () => Oe(-10, 10), () => Oe(0, 360), () => Oe(M()[0], M()[1]), () => Oe(y()[0], y()[1]), () => .1 * Oe(2, 10), () => Oe(o()[0], o()[1])]), H(tt, Ae)
      }), k(Fe), Ye(tt => {
        it = zr(Fe, 1, "confetti-holder svelte-15ksp55", null, it, tt), Ic(Fe, `
    --fall-distance: ${se()??""};
    --size: ${m()??""}px;
    --x-spread: ${1-Ee()};
    --transition-iteration-count: ${(T()?"infinite":K())??""};`)
      }, [() => ({
        rounded: X(),
        cone: me(),
        "no-gravity": ge(),
        "reduced-motion": Re()
      })]), H(Je, Fe)
    };
    je(qe, Je => {
      w(Ie) || Je(Ue)
    })
  }
  H(_, nt), Fr()
}
var Dk = async (_, s, m, y) => {
  try {
    ce(s, !0), await an.purchase({
      id: m,
      amount: 1,
      variant: y.colorIdx
    }), await Mt.refresh(), sa.notification1.play()
  } catch (M) {
    Vr.error(M.message)
  } finally {
    ce(s, !1)
  }
}, Rk = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'), Bk = Pe('<!> <span class="text-sm">Droplets</span>', 1), Fk = Pe('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1), Ok = (_, s) => s(!1), Nk = Pe('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'), jk = Pe('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Vk(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  const y = ht(() => Xi.colors[s.colorIdx]),
    M = ht(() => {
      var X;
      return ((X = Mt.data) == null ? void 0 : X.droplets) ?? 0
    });
  let z = ut(!1);
  const T = ht(() => (w(z), Mt.hasColor(s.colorIdx)));
  An(() => {
    const X = me => {
      me.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", X), () => document.removeEventListener("keydown", X)
  });
  const o = 100,
    B = Xi.products[o];
  var N = jk(),
    W = E(N),
    K = Z(E(W), 2);
  {
    var se = X => {
      var me = Nk(),
        ge = E(me),
        Ee = E(ge),
        ze = E(Ee);
      tp(ze, {
        class: "size-6"
      });
      var Re = Z(ze, 4),
        Ie = E(Re);
      Lv(Ie, {
        get value() {
          return w(M)
        }
      }), k(Re), k(Ee), _n(2), k(ge);
      var Oe = Z(ge, 2),
        st = E(Oe),
        nt = E(st);
      k(st);
      var qe = Z(st, 2),
        Ue = E(qe, !0);
      k(qe);
      var Je = Z(qe, 2),
        Fe = E(Je);
      let it;
      var tt = E(Fe);
      tt.__click = [Dk, z, o, s];
      var $e = E(tt);
      {
        var Ae = ae => {
          var ke = Rk();
          H(ae, ke)
        };
        je($e, ae => {
          w(z) && ae(Ae)
        })
      }
      var gt = Z($e, 2);
      {
        var Q = ae => {
            var ke = Bk(),
              Le = Ct(ke);
            hp(Le, {
              class: "size-5"
            });
            var lt = Z(Le);
            _n(), Ye(We => ye(lt, ` ${We??""} `), [() => B.price.toLocaleString("en-US")]), H(ae, ke)
          },
          re = ae => {
            var ke = Fk(),
              Le = Ct(ke);
            tp(Le, {
              class: "size-5"
            });
            var lt = Z(Le, 2),
              We = E(lt);
            Um(We, {}), k(lt), H(ae, ke)
          };
        je(gt, ae => {
          w(T) ? ae(re, !1) : ae(Q)
        })
      }
      k(tt), k(Fe);
      var _e = Z(Fe, 2);
      _e.__click = [Ok, m], k(Je), k(Oe), k(me), Ye((ae, ke) => {
        Ic(nt, `background: rgb(${w(y).rgb[0]} ${w(y).rgb[1]} ${w(y).rgb[2]})`), kr(nt, "aria-label", w(y).name), ye(Ue, w(y).name), kr(Fe, "data-tip", ae), it = zr(Fe, 1, "", null, it, ke), tt.disabled = w(M) < B.price || w(z) || w(T)
      }, [() => fp(), () => ({
        tooltip: !w(T) && w(M) < B.price
      })]), H(X, me)
    };
    je(K, X => {
      Mt.data && X(se)
    })
  }
  k(W), _n(2), k(N), Yi(N, () => X => {
    Xr(() => {
      m() ? X.show() : X.close()
    })
  }), Ai("close", N, () => m(!1)), H(_, N), Fr()
}
ri(["click"]);
var vm = function() {
  return vm = Object.assign || function(s) {
    for (var m, y = 1, M = arguments.length; y < M; y++) {
      m = arguments[y];
      for (var z in m) Object.prototype.hasOwnProperty.call(m, z) && (s[z] = m[z])
    }
    return s
  }, vm.apply(this, arguments)
};

function Ss(_, s, m, y) {
  function M(z) {
    return z instanceof m ? z : new m(function(T) {
      T(z)
    })
  }
  return new(m || (m = Promise))(function(z, T) {
    function o(W) {
      try {
        N(y.next(W))
      } catch (K) {
        T(K)
      }
    }

    function B(W) {
      try {
        N(y.throw(W))
      } catch (K) {
        T(K)
      }
    }

    function N(W) {
      W.done ? z(W.value) : M(W.value).then(o, B)
    }
    N((y = y.apply(_, s || [])).next())
  })
}

function Cs(_, s) {
  var m = {
      label: 0,
      sent: function() {
        if (z[0] & 1) throw z[1];
        return z[1]
      },
      trys: [],
      ops: []
    },
    y, M, z, T = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return T.next = o(0), T.throw = o(1), T.return = o(2), typeof Symbol == "function" && (T[Symbol.iterator] = function() {
    return this
  }), T;

  function o(N) {
    return function(W) {
      return B([N, W])
    }
  }

  function B(N) {
    if (y) throw new TypeError("Generator is already executing.");
    for (; T && (T = 0, N[0] && (m = 0)), m;) try {
      if (y = 1, M && (z = N[0] & 2 ? M.return : N[0] ? M.throw || ((z = M.return) && z.call(M), 0) : M.next) && !(z = z.call(M, N[1])).done) return z;
      switch (M = 0, z && (N = [N[0] & 2, z.value]), N[0]) {
        case 0:
        case 1:
          z = N;
          break;
        case 4:
          return m.label++, {
            value: N[1],
            done: !1
          };
        case 5:
          m.label++, M = N[1], N = [0];
          continue;
        case 7:
          N = m.ops.pop(), m.trys.pop();
          continue;
        default:
          if (z = m.trys, !(z = z.length > 0 && z[z.length - 1]) && (N[0] === 6 || N[0] === 2)) {
            m = 0;
            continue
          }
          if (N[0] === 3 && (!z || N[1] > z[0] && N[1] < z[3])) {
            m.label = N[1];
            break
          }
          if (N[0] === 6 && m.label < z[1]) {
            m.label = z[1], z = N;
            break
          }
          if (z && m.label < z[2]) {
            m.label = z[2], m.ops.push(N);
            break
          }
          z[2] && m.ops.pop(), m.trys.pop();
          continue
      }
      N = s.call(_, m)
    } catch (W) {
      N = [6, W], M = 0
    } finally {
      y = z = 0
    }
    if (N[0] & 5) throw N[1];
    return {
      value: N[0] ? N[1] : void 0,
      done: !0
    }
  }
}

function C0(_, s, m) {
  if (m || arguments.length === 2)
    for (var y = 0, M = s.length, z; y < M; y++)(z || !(y in s)) && (z || (z = Array.prototype.slice.call(s, 0, y)), z[y] = s[y]);
  return _.concat(z || Array.prototype.slice.call(s))
}
var P0 = "4.6.2";

function rp(_, s) {
  return new Promise(function(m) {
    return setTimeout(m, _, s)
  })
}

function qk() {
  return new Promise(function(_) {
    var s = new MessageChannel;
    s.port1.onmessage = function() {
      return _()
    }, s.port2.postMessage(null)
  })
}

function Zk(_, s) {
  s === void 0 && (s = 1 / 0);
  var m = window.requestIdleCallback;
  return m ? new Promise(function(y) {
    return m.call(window, function() {
      return y()
    }, {
      timeout: s
    })
  }) : rp(Math.min(_, s))
}

function I0(_) {
  return !!_ && typeof _.then == "function"
}

function av(_, s) {
  try {
    var m = _();
    I0(m) ? m.then(function(y) {
      return s(!0, y)
    }, function(y) {
      return s(!1, y)
    }) : s(!0, m)
  } catch (y) {
    s(!1, y)
  }
}

function sv(_, s, m) {
  return m === void 0 && (m = 16), Ss(this, void 0, void 0, function() {
    var y, M, z, T;
    return Cs(this, function(o) {
      switch (o.label) {
        case 0:
          y = Array(_.length), M = Date.now(), z = 0, o.label = 1;
        case 1:
          return z < _.length ? (y[z] = s(_[z], z), T = Date.now(), T >= M + m ? (M = T, [4, qk()]) : [3, 3]) : [3, 4];
        case 2:
          o.sent(), o.label = 3;
        case 3:
          return ++z, [3, 1];
        case 4:
          return [2, y]
      }
    })
  })
}

function Uu(_) {
  return _.then(void 0, function() {}), _
}

function Uk(_, s) {
  for (var m = 0, y = _.length; m < y; ++m)
    if (_[m] === s) return !0;
  return !1
}

function $k(_, s) {
  return !Uk(_, s)
}

function $m(_) {
  return parseInt(_)
}

function ss(_) {
  return parseFloat(_)
}

function $s(_, s) {
  return typeof _ == "number" && isNaN(_) ? s : _
}

function ma(_) {
  return _.reduce(function(s, m) {
    return s + (m ? 1 : 0)
  }, 0)
}

function M0(_, s) {
  if (s === void 0 && (s = 1), Math.abs(s) >= 1) return Math.round(_ / s) * s;
  var m = 1 / s;
  return Math.round(_ * m) / m
}

function Gk(_) {
  for (var s, m, y = "Unexpected syntax '".concat(_, "'"), M = /^\s*([a-z-]*)(.*)$/i.exec(_), z = M[1] || void 0, T = {}, o = /([.:#][\w-]+|\[.+?\])/gi, B = function(se, X) {
      T[se] = T[se] || [], T[se].push(X)
    };;) {
    var N = o.exec(M[2]);
    if (!N) break;
    var W = N[0];
    switch (W[0]) {
      case ".":
        B("class", W.slice(1));
        break;
      case "#":
        B("id", W.slice(1));
        break;
      case "[": {
        var K = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(W);
        if (K) B(K[1], (m = (s = K[4]) !== null && s !== void 0 ? s : K[5]) !== null && m !== void 0 ? m : "");
        else throw new Error(y);
        break
      }
      default:
        throw new Error(y)
    }
  }
  return [z, T]
}

function Hk(_) {
  for (var s = new Uint8Array(_.length), m = 0; m < _.length; m++) {
    var y = _.charCodeAt(m);
    if (y > 127) return new TextEncoder().encode(_);
    s[m] = y
  }
  return s
}

function yo(_, s) {
  var m = _[0] >>> 16,
    y = _[0] & 65535,
    M = _[1] >>> 16,
    z = _[1] & 65535,
    T = s[0] >>> 16,
    o = s[0] & 65535,
    B = s[1] >>> 16,
    N = s[1] & 65535,
    W = 0,
    K = 0,
    se = 0,
    X = 0;
  X += z + N, se += X >>> 16, X &= 65535, se += M + B, K += se >>> 16, se &= 65535, K += y + o, W += K >>> 16, K &= 65535, W += m + T, W &= 65535, _[0] = W << 16 | K, _[1] = se << 16 | X
}

function Ga(_, s) {
  var m = _[0] >>> 16,
    y = _[0] & 65535,
    M = _[1] >>> 16,
    z = _[1] & 65535,
    T = s[0] >>> 16,
    o = s[0] & 65535,
    B = s[1] >>> 16,
    N = s[1] & 65535,
    W = 0,
    K = 0,
    se = 0,
    X = 0;
  X += z * N, se += X >>> 16, X &= 65535, se += M * N, K += se >>> 16, se &= 65535, se += z * B, K += se >>> 16, se &= 65535, K += y * N, W += K >>> 16, K &= 65535, K += M * B, W += K >>> 16, K &= 65535, K += z * o, W += K >>> 16, K &= 65535, W += m * N + y * B + M * o + z * T, W &= 65535, _[0] = W << 16 | K, _[1] = se << 16 | X
}

function dc(_, s) {
  var m = _[0];
  s %= 64, s === 32 ? (_[0] = _[1], _[1] = m) : s < 32 ? (_[0] = m << s | _[1] >>> 32 - s, _[1] = _[1] << s | m >>> 32 - s) : (s -= 32, _[0] = _[1] << s | m >>> 32 - s, _[1] = m << s | _[1] >>> 32 - s)
}

function ja(_, s) {
  s %= 64, s !== 0 && (s < 32 ? (_[0] = _[1] >>> 32 - s, _[1] = _[1] << s) : (_[0] = _[1] << s - 32, _[1] = 0))
}

function ti(_, s) {
  _[0] ^= s[0], _[1] ^= s[1]
}
var Wk = [4283543511, 3981806797],
  Xk = [3301882366, 444984403];

function ov(_) {
  var s = [0, _[0] >>> 1];
  ti(_, s), Ga(_, Wk), s[1] = _[0] >>> 1, ti(_, s), Ga(_, Xk), s[1] = _[0] >>> 1, ti(_, s)
}
var Zd = [2277735313, 289559509],
  Ud = [1291169091, 658871167],
  lv = [0, 5],
  Yk = [0, 1390208809],
  Kk = [0, 944331445];

function Jk(_, s) {
  var m = Hk(_);
  s = s || 0;
  var y = [0, m.length],
    M = y[1] % 16,
    z = y[1] - M,
    T = [0, s],
    o = [0, s],
    B = [0, 0],
    N = [0, 0],
    W;
  for (W = 0; W < z; W = W + 16) B[0] = m[W + 4] | m[W + 5] << 8 | m[W + 6] << 16 | m[W + 7] << 24, B[1] = m[W] | m[W + 1] << 8 | m[W + 2] << 16 | m[W + 3] << 24, N[0] = m[W + 12] | m[W + 13] << 8 | m[W + 14] << 16 | m[W + 15] << 24, N[1] = m[W + 8] | m[W + 9] << 8 | m[W + 10] << 16 | m[W + 11] << 24, Ga(B, Zd), dc(B, 31), Ga(B, Ud), ti(T, B), dc(T, 27), yo(T, o), Ga(T, lv), yo(T, Yk), Ga(N, Ud), dc(N, 33), Ga(N, Zd), ti(o, N), dc(o, 31), yo(o, T), Ga(o, lv), yo(o, Kk);
  B[0] = 0, B[1] = 0, N[0] = 0, N[1] = 0;
  var K = [0, 0];
  switch (M) {
    case 15:
      K[1] = m[W + 14], ja(K, 48), ti(N, K);
    case 14:
      K[1] = m[W + 13], ja(K, 40), ti(N, K);
    case 13:
      K[1] = m[W + 12], ja(K, 32), ti(N, K);
    case 12:
      K[1] = m[W + 11], ja(K, 24), ti(N, K);
    case 11:
      K[1] = m[W + 10], ja(K, 16), ti(N, K);
    case 10:
      K[1] = m[W + 9], ja(K, 8), ti(N, K);
    case 9:
      K[1] = m[W + 8], ti(N, K), Ga(N, Ud), dc(N, 33), Ga(N, Zd), ti(o, N);
    case 8:
      K[1] = m[W + 7], ja(K, 56), ti(B, K);
    case 7:
      K[1] = m[W + 6], ja(K, 48), ti(B, K);
    case 6:
      K[1] = m[W + 5], ja(K, 40), ti(B, K);
    case 5:
      K[1] = m[W + 4], ja(K, 32), ti(B, K);
    case 4:
      K[1] = m[W + 3], ja(K, 24), ti(B, K);
    case 3:
      K[1] = m[W + 2], ja(K, 16), ti(B, K);
    case 2:
      K[1] = m[W + 1], ja(K, 8), ti(B, K);
    case 1:
      K[1] = m[W], ti(B, K), Ga(B, Zd), dc(B, 31), Ga(B, Ud), ti(T, B)
  }
  return ti(T, y), ti(o, y), yo(T, o), yo(o, T), ov(T), ov(o), yo(T, o), yo(o, T), ("00000000" + (T[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (T[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (o[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (o[1] >>> 0).toString(16)).slice(-8)
}

function Qk(_) {
  var s;
  return vm({
    name: _.name,
    message: _.message,
    stack: (s = _.stack) === null || s === void 0 ? void 0 : s.split(`
`)
  }, _)
}

function eE(_) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(_))
}

function tE(_) {
  return typeof _ != "function"
}

function rE(_, s) {
  var m = Uu(new Promise(function(y) {
    var M = Date.now();
    av(_.bind(null, s), function() {
      for (var z = [], T = 0; T < arguments.length; T++) z[T] = arguments[T];
      var o = Date.now() - M;
      if (!z[0]) return y(function() {
        return {
          error: z[1],
          duration: o
        }
      });
      var B = z[1];
      if (tE(B)) return y(function() {
        return {
          value: B,
          duration: o
        }
      });
      y(function() {
        return new Promise(function(N) {
          var W = Date.now();
          av(B, function() {
            for (var K = [], se = 0; se < arguments.length; se++) K[se] = arguments[se];
            var X = o + Date.now() - W;
            if (!K[0]) return N({
              error: K[1],
              duration: X
            });
            N({
              value: K[1],
              duration: X
            })
          })
        })
      })
    })
  }));
  return function() {
    return m.then(function(M) {
      return M()
    })
  }
}

function nE(_, s, m, y) {
  var M = Object.keys(_).filter(function(T) {
      return $k(m, T)
    }),
    z = Uu(sv(M, function(T) {
      return rE(_[T], s)
    }, y));
  return function() {
    return Ss(this, void 0, void 0, function() {
      var o, B, N, W, K;
      return Cs(this, function(se) {
        switch (se.label) {
          case 0:
            return [4, z];
          case 1:
            return o = se.sent(), [4, sv(o, function(X) {
              return Uu(X())
            }, y)];
          case 2:
            return B = se.sent(), [4, Promise.all(B)];
          case 3:
            for (N = se.sent(), W = {}, K = 0; K < M.length; ++K) W[M[K]] = N[K];
            return [2, W]
        }
      })
    })
  }
}

function A0() {
  var _ = window,
    s = navigator;
  return ma(["MSCSSMatrix" in _, "msSetImmediate" in _, "msIndexedDB" in _, "msMaxTouchPoints" in s, "msPointerEnabled" in s]) >= 4
}

function iE() {
  var _ = window,
    s = navigator;
  return ma(["msWriteProfilerMark" in _, "MSStream" in _, "msLaunchUri" in s, "msSaveBlob" in s]) >= 3 && !A0()
}

function zh() {
  var _ = window,
    s = navigator;
  return ma(["webkitPersistentStorage" in s, "webkitTemporaryStorage" in s, (s.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in _, "BatteryManager" in _, "webkitMediaStream" in _, "webkitSpeechGrammar" in _]) >= 5
}

function hs() {
  var _ = window,
    s = navigator;
  return ma(["ApplePayError" in _, "CSSPrimitiveValue" in _, "Counter" in _, s.vendor.indexOf("Apple") === 0, "RGBColor" in _, "WebKitMediaKeys" in _]) >= 4
}

function Gm() {
  var _ = window,
    s = _.HTMLElement,
    m = _.Document;
  return ma(["safari" in _, !("ongestureend" in _), !("TouchEvent" in _), !("orientation" in _), s && !("autocapitalize" in s.prototype), m && "pointerLockElement" in m.prototype]) >= 4
}

function Lh() {
  var _ = window;
  return eE(_.print) && String(_.browser) === "[object WebPageNamespace]"
}

function k0() {
  var _, s, m = window;
  return ma(["buildID" in navigator, "MozAppearance" in ((s = (_ = document.documentElement) === null || _ === void 0 ? void 0 : _.style) !== null && s !== void 0 ? s : {}), "onmozfullscreenchange" in m, "mozInnerScreenX" in m, "CSSMozDocumentRule" in m, "CanvasCaptureMediaStream" in m]) >= 4
}

function aE() {
  var _ = window;
  return ma([!("MediaSettingsRange" in _), "RTCEncodedAudioFrame" in _, "" + _.Intl == "[object Intl]", "" + _.Reflect == "[object Reflect]"]) >= 3
}

function sE() {
  var _ = window,
    s = _.URLPattern;
  return ma(["union" in Set.prototype, "Iterator" in _, s && "hasRegExpGroups" in s.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function oE() {
  var _ = window;
  return ma(["DOMRectList" in _, "RTCPeerConnectionIceEvent" in _, "SVGGeometryElement" in _, "ontransitioncancel" in _]) >= 3
}

function Dh() {
  var _ = window,
    s = navigator,
    m = _.CSS,
    y = _.HTMLButtonElement;
  return ma([!("getStorageUpdates" in s), y && "popover" in y.prototype, "CSSCounterStyleRule" in _, m.supports("font-size-adjust: ex-height 0.5"), m.supports("text-transform: full-width")]) >= 4
}

function lE() {
  if (navigator.platform === "iPad") return !0;
  var _ = screen,
    s = _.width / _.height;
  return ma(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, s > .65 && s < 1.53]) >= 2
}

function cE() {
  var _ = document;
  return _.fullscreenElement || _.msFullscreenElement || _.mozFullScreenElement || _.webkitFullscreenElement || null
}

function uE() {
  var _ = document;
  return (_.exitFullscreen || _.msExitFullscreen || _.mozCancelFullScreen || _.webkitExitFullscreen).call(_)
}

function Hm() {
  var _ = zh(),
    s = k0(),
    m = window,
    y = navigator,
    M = "connection";
  return _ ? ma([!("SharedWorker" in m), y[M] && "ontypechange" in y[M], !("sinkId" in new Audio)]) >= 2 : s ? ma(["onorientationchange" in m, "orientation" in m, /android/i.test(y.appVersion)]) >= 2 : !1
}

function hE() {
  var _ = navigator,
    s = window,
    m = Audio.prototype,
    y = s.visualViewport;
  return ma(["srLatency" in m, "srChannelCount" in m, "devicePosture" in _, y && "segments" in y, "getTextInformation" in Image.prototype]) >= 3
}

function dE() {
  return mE() ? -4 : pE()
}

function pE() {
  var _ = window,
    s = _.OfflineAudioContext || _.webkitOfflineAudioContext;
  if (!s) return -2;
  if (fE()) return -1;
  var m = 4500,
    y = 5e3,
    M = new s(1, y, 44100),
    z = M.createOscillator();
  z.type = "triangle", z.frequency.value = 1e4;
  var T = M.createDynamicsCompressor();
  T.threshold.value = -50, T.knee.value = 40, T.ratio.value = 12, T.attack.value = 0, T.release.value = .25, z.connect(T), T.connect(M.destination), z.start(0);
  var o = _E(M),
    B = o[0],
    N = o[1],
    W = Uu(B.then(function(K) {
      return gE(K.getChannelData(0).subarray(m))
    }, function(K) {
      if (K.name === "timeout" || K.name === "suspended") return -3;
      throw K
    }));
  return function() {
    return N(), W
  }
}

function fE() {
  return hs() && !Gm() && !oE()
}

function mE() {
  return hs() && Dh() && Lh() || zh() && hE() && sE()
}

function _E(_) {
  var s = 3,
    m = 500,
    y = 500,
    M = 5e3,
    z = function() {},
    T = new Promise(function(o, B) {
      var N = !1,
        W = 0,
        K = 0;
      _.oncomplete = function(me) {
        return o(me.renderedBuffer)
      };
      var se = function() {
          setTimeout(function() {
            return B(cv("timeout"))
          }, Math.min(y, K + M - Date.now()))
        },
        X = function() {
          try {
            var me = _.startRendering();
            switch (I0(me) && Uu(me), _.state) {
              case "running":
                K = Date.now(), N && se();
                break;
              case "suspended":
                document.hidden || W++, N && W >= s ? B(cv("suspended")) : setTimeout(X, m);
                break
            }
          } catch (ge) {
            B(ge)
          }
        };
      X(), z = function() {
        N || (N = !0, K > 0 && se())
      }
    });
  return [T, z]
}

function gE(_) {
  for (var s = 0, m = 0; m < _.length; ++m) s += Math.abs(_[m]);
  return s
}

function cv(_) {
  var s = new Error(_);
  return s.name = _, s
}

function E0(_, s, m) {
  var y, M, z;
  return m === void 0 && (m = 50), Ss(this, void 0, void 0, function() {
    var T, o;
    return Cs(this, function(B) {
      switch (B.label) {
        case 0:
          T = document, B.label = 1;
        case 1:
          return T.body ? [3, 3] : [4, rp(m)];
        case 2:
          return B.sent(), [3, 1];
        case 3:
          o = T.createElement("iframe"), B.label = 4;
        case 4:
          return B.trys.push([4, , 10, 11]), [4, new Promise(function(N, W) {
            var K = !1,
              se = function() {
                K = !0, N()
              },
              X = function(Ee) {
                K = !0, W(Ee)
              };
            o.onload = se, o.onerror = X;
            var me = o.style;
            me.setProperty("display", "block", "important"), me.position = "absolute", me.top = "0", me.left = "0", me.visibility = "hidden", s && "srcdoc" in o ? o.srcdoc = s : o.src = "about:blank", T.body.appendChild(o);
            var ge = function() {
              var Ee, ze;
              K || (((ze = (Ee = o.contentWindow) === null || Ee === void 0 ? void 0 : Ee.document) === null || ze === void 0 ? void 0 : ze.readyState) === "complete" ? se() : setTimeout(ge, 10))
            };
            ge()
          })];
        case 5:
          B.sent(), B.label = 6;
        case 6:
          return !((M = (y = o.contentWindow) === null || y === void 0 ? void 0 : y.document) === null || M === void 0) && M.body ? [3, 8] : [4, rp(m)];
        case 7:
          return B.sent(), [3, 6];
        case 8:
          return [4, _(o, o.contentWindow)];
        case 9:
          return [2, B.sent()];
        case 10:
          return (z = o.parentNode) === null || z === void 0 || z.removeChild(o), [7];
        case 11:
          return [2]
      }
    })
  })
}

function vE(_) {
  for (var s = Gk(_), m = s[0], y = s[1], M = document.createElement(m ?? "div"), z = 0, T = Object.keys(y); z < T.length; z++) {
    var o = T[z],
      B = y[o].join(" ");
    o === "style" ? yE(M.style, B) : M.setAttribute(o, B)
  }
  return M
}

function yE(_, s) {
  for (var m = 0, y = s.split(";"); m < y.length; m++) {
    var M = y[m],
      z = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(M);
    if (z) {
      var T = z[1],
        o = z[2],
        B = z[4];
      _.setProperty(T, o, B || "")
    }
  }
}

function xE() {
  for (var _ = window;;) {
    var s = _.parent;
    if (!s || s === _) return !1;
    try {
      if (s.location.origin !== _.location.origin) return !0
    } catch (m) {
      if (m instanceof Error && m.name === "SecurityError") return !0;
      throw m
    }
    _ = s
  }
}
var bE = "mmMwWLliI0O&1",
  wE = "48px",
  pc = ["monospace", "sans-serif", "serif"],
  uv = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function TE() {
  var _ = this;
  return E0(function(s, m) {
    var y = m.document;
    return Ss(_, void 0, void 0, function() {
      var M, z, T, o, B, N, W, K, se, X, me, ge;
      return Cs(this, function(Ee) {
        for (M = y.body, M.style.fontSize = wE, z = y.createElement("div"), z.style.setProperty("visibility", "hidden", "important"), T = {}, o = {}, B = function(ze) {
            var Re = y.createElement("span"),
              Ie = Re.style;
            return Ie.position = "absolute", Ie.top = "0", Ie.left = "0", Ie.fontFamily = ze, Re.textContent = bE, z.appendChild(Re), Re
          }, N = function(ze, Re) {
            return B("'".concat(ze, "',").concat(Re))
          }, W = function() {
            return pc.map(B)
          }, K = function() {
            for (var ze = {}, Re = function(nt) {
                ze[nt] = pc.map(function(qe) {
                  return N(nt, qe)
                })
              }, Ie = 0, Oe = uv; Ie < Oe.length; Ie++) {
              var st = Oe[Ie];
              Re(st)
            }
            return ze
          }, se = function(ze) {
            return pc.some(function(Re, Ie) {
              return ze[Ie].offsetWidth !== T[Re] || ze[Ie].offsetHeight !== o[Re]
            })
          }, X = W(), me = K(), M.appendChild(z), ge = 0; ge < pc.length; ge++) T[pc[ge]] = X[ge].offsetWidth, o[pc[ge]] = X[ge].offsetHeight;
        return [2, uv.filter(function(ze) {
          return se(me[ze])
        })]
      })
    })
  })
}

function SE() {
  var _ = navigator.plugins;
  if (_) {
    for (var s = [], m = 0; m < _.length; ++m) {
      var y = _[m];
      if (y) {
        for (var M = [], z = 0; z < y.length; ++z) {
          var T = y[z];
          M.push({
            type: T.type,
            suffixes: T.suffixes
          })
        }
        s.push({
          name: y.name,
          description: y.description,
          mimeTypes: M
        })
      }
    }
    return s
  }
}

function CE() {
  return PE(LE())
}

function PE(_) {
  var s, m = !1,
    y, M, z = IE(),
    T = z[0],
    o = z[1];
  return ME(T, o) ? (m = AE(o), _ ? y = M = "skipped" : (s = kE(T, o), y = s[0], M = s[1])) : y = M = "unsupported", {
    winding: m,
    geometry: y,
    text: M
  }
}

function IE() {
  var _ = document.createElement("canvas");
  return _.width = 1, _.height = 1, [_, _.getContext("2d")]
}

function ME(_, s) {
  return !!(s && _.toDataURL)
}

function AE(_) {
  return _.rect(0, 0, 10, 10), _.rect(2, 2, 6, 6), !_.isPointInPath(5, 5, "evenodd")
}

function kE(_, s) {
  EE(_, s);
  var m = Of(_),
    y = Of(_);
  if (m !== y) return ["unstable", "unstable"];
  zE(_, s);
  var M = Of(_);
  return [M, m]
}

function EE(_, s) {
  _.width = 240, _.height = 60, s.textBaseline = "alphabetic", s.fillStyle = "#f60", s.fillRect(100, 1, 62, 20), s.fillStyle = "#069", s.font = '11pt "Times New Roman"';
  var m = "Cwm fjordbank gly ".concat("😃");
  s.fillText(m, 2, 15), s.fillStyle = "rgba(102, 204, 0, 0.2)", s.font = "18pt Arial", s.fillText(m, 4, 45)
}

function zE(_, s) {
  _.width = 122, _.height = 110, s.globalCompositeOperation = "multiply";
  for (var m = 0, y = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; m < y.length; m++) {
    var M = y[m],
      z = M[0],
      T = M[1],
      o = M[2];
    s.fillStyle = z, s.beginPath(), s.arc(T, o, 40, 0, Math.PI * 2, !0), s.closePath(), s.fill()
  }
  s.fillStyle = "#f9c", s.arc(60, 60, 60, 0, Math.PI * 2, !0), s.arc(60, 60, 20, 0, Math.PI * 2, !0), s.fill("evenodd")
}

function Of(_) {
  return _.toDataURL()
}

function LE() {
  return hs() && Dh() && Lh()
}

function DE() {
  var _ = navigator,
    s = 0,
    m;
  _.maxTouchPoints !== void 0 ? s = $m(_.maxTouchPoints) : _.msMaxTouchPoints !== void 0 && (s = _.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), m = !0
  } catch {
    m = !1
  }
  var y = "ontouchstart" in window;
  return {
    maxTouchPoints: s,
    touchEvent: m,
    touchStart: y
  }
}

function RE() {
  return navigator.oscpu
}

function BE() {
  var _ = navigator,
    s = [],
    m = _.language || _.userLanguage || _.browserLanguage || _.systemLanguage;
  if (m !== void 0 && s.push([m]), Array.isArray(_.languages)) zh() && aE() || s.push(_.languages);
  else if (typeof _.languages == "string") {
    var y = _.languages;
    y && s.push(y.split(","))
  }
  return s
}

function FE() {
  return window.screen.colorDepth
}

function OE() {
  return $s(ss(navigator.deviceMemory), void 0)
}

function NE() {
  if (!(hs() && Dh() && Lh())) return jE()
}

function jE() {
  var _ = screen,
    s = function(y) {
      return $s($m(y), null)
    },
    m = [s(_.width), s(_.height)];
  return m.sort().reverse(), m
}
var VE = 2500,
  qE = 10,
  Qd, Nf;

function ZE() {
  if (Nf === void 0) {
    var _ = function() {
      var s = ym();
      xm(s) ? Nf = setTimeout(_, VE) : (Qd = s, Nf = void 0)
    };
    _()
  }
}

function UE() {
  var _ = this;
  return ZE(),
    function() {
      return Ss(_, void 0, void 0, function() {
        var s;
        return Cs(this, function(m) {
          switch (m.label) {
            case 0:
              return s = ym(), xm(s) ? Qd ? [2, C0([], Qd, !0)] : cE() ? [4, uE()] : [3, 2] : [3, 2];
            case 1:
              m.sent(), s = ym(), m.label = 2;
            case 2:
              return xm(s) || (Qd = s), [2, s]
          }
        })
      })
    }
}

function $E() {
  var _ = this;
  if (hs() && Dh() && Lh()) return function() {
    return Promise.resolve(void 0)
  };
  var s = UE();
  return function() {
    return Ss(_, void 0, void 0, function() {
      var m, y;
      return Cs(this, function(M) {
        switch (M.label) {
          case 0:
            return [4, s()];
          case 1:
            return m = M.sent(), y = function(z) {
              return z === null ? null : M0(z, qE)
            }, [2, [y(m[0]), y(m[1]), y(m[2]), y(m[3])]]
        }
      })
    })
  }
}

function ym() {
  var _ = screen;
  return [$s(ss(_.availTop), null), $s(ss(_.width) - ss(_.availWidth) - $s(ss(_.availLeft), 0), null), $s(ss(_.height) - ss(_.availHeight) - $s(ss(_.availTop), 0), null), $s(ss(_.availLeft), null)]
}

function xm(_) {
  for (var s = 0; s < 4; ++s)
    if (_[s]) return !1;
  return !0
}

function GE() {
  return $s($m(navigator.hardwareConcurrency), void 0)
}

function HE() {
  var _, s = (_ = window.Intl) === null || _ === void 0 ? void 0 : _.DateTimeFormat;
  if (s) {
    var m = new s().resolvedOptions().timeZone;
    if (m) return m
  }
  var y = -WE();
  return "UTC".concat(y >= 0 ? "+" : "").concat(y)
}

function WE() {
  var _ = new Date().getFullYear();
  return Math.max(ss(new Date(_, 0, 1).getTimezoneOffset()), ss(new Date(_, 6, 1).getTimezoneOffset()))
}

function XE() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function YE() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function KE() {
  if (!(A0() || iE())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function JE() {
  return !!window.openDatabase
}

function QE() {
  return navigator.cpuClass
}

function e8() {
  var _ = navigator.platform;
  return _ === "MacIntel" && hs() && !Gm() ? lE() ? "iPad" : "iPhone" : _
}

function t8() {
  return navigator.vendor || ""
}

function r8() {
  for (var _ = [], s = 0, m = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; s < m.length; s++) {
    var y = m[s],
      M = window[y];
    M && typeof M == "object" && _.push(y)
  }
  return _.sort()
}

function n8() {
  var _ = document;
  try {
    _.cookie = "cookietest=1; SameSite=Strict;";
    var s = _.cookie.indexOf("cookietest=") !== -1;
    return _.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", s
  } catch {
    return !1
  }
}

function i8() {
  var _ = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', _("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", _("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", _("LnNwb25zb3JpdA=="), ".ylamainos", _("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", _("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", _("LmhlYWRlci1ibG9ja2VkLWFk"), _("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", _("I2FkXzMwMFgyNTA="), _("I2Jhbm5lcmZsb2F0MjI="), _("I2NhbXBhaWduLWJhbm5lcg=="), _("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [_("LlppX2FkX2FfSA=="), _("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", _("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), _("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", _("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", _("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", _("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), _("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), _("LmFkZ29vZ2xl"), _("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [_("YW1wLWF1dG8tYWRz"), _("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", _("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [_("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), _("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', _("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [_("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), _("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", _("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), _("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), _("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", _("I3Jla2xhbWk="), _("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), _("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), _("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [_("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", _("LndpZGdldF9wb19hZHNfd2lkZ2V0"), _("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", _("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [_("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), _("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", _("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", _("I3Jla2xhbW5pLWJveA=="), _("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", _("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [_("I2FkdmVydGVudGll"), _("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", _("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", _("LnNwb25zb3JsaW5rZ3J1ZW4="), _("I3dlcmJ1bmdza3k="), _("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), _("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [_("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", _("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [_("LnJla2xhbW9zX3RhcnBhcw=="), _("LnJla2xhbW9zX251b3JvZG9z"), _("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), _("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), _("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [_("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [_("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), _("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", _("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [_("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), _("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), _("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", _("LmFkX19tYWlu"), _("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [_("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [_("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), _("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [_("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), _("I2xpdmVyZUFkV3JhcHBlcg=="), _("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), _("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [_("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", _("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), _("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), _("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [_("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), _("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), _("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", _("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), _("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), _("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), _("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [_("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), _("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), _("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [_("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), _("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), _("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", _("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), _("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", _("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function a8(_) {
  var s = _ === void 0 ? {} : _,
    m = s.debug;
  return Ss(this, void 0, void 0, function() {
    var y, M, z, T, o, B;
    return Cs(this, function(N) {
      switch (N.label) {
        case 0:
          return s8() ? (y = i8(), M = Object.keys(y), z = (B = []).concat.apply(B, M.map(function(W) {
            return y[W]
          })), [4, o8(z)]) : [2, void 0];
        case 1:
          return T = N.sent(), m && l8(y, T), o = M.filter(function(W) {
            var K = y[W],
              se = ma(K.map(function(X) {
                return T[X]
              }));
            return se > K.length * .6
          }), o.sort(), [2, o]
      }
    })
  })
}

function s8() {
  return hs() || Hm()
}

function o8(_) {
  var s;
  return Ss(this, void 0, void 0, function() {
    var m, y, M, z, B, T, o, B;
    return Cs(this, function(N) {
      switch (N.label) {
        case 0:
          for (m = document, y = m.createElement("div"), M = new Array(_.length), z = {}, hv(y), B = 0; B < _.length; ++B) T = vE(_[B]), T.tagName === "DIALOG" && T.show(), o = m.createElement("div"), hv(o), o.appendChild(T), y.appendChild(o), M[B] = T;
          N.label = 1;
        case 1:
          return m.body ? [3, 3] : [4, rp(50)];
        case 2:
          return N.sent(), [3, 1];
        case 3:
          m.body.appendChild(y);
          try {
            for (B = 0; B < _.length; ++B) M[B].offsetParent || (z[_[B]] = !0)
          } finally {
            (s = y.parentNode) === null || s === void 0 || s.removeChild(y)
          }
          return [2, z]
      }
    })
  })
}

function hv(_) {
  _.style.setProperty("visibility", "hidden", "important"), _.style.setProperty("display", "block", "important")
}

function l8(_, s) {
  for (var m = "DOM blockers debug:\n```", y = 0, M = Object.keys(_); y < M.length; y++) {
    var z = M[y];
    m += `
`.concat(z, ":");
    for (var T = 0, o = _[z]; T < o.length; T++) {
      var B = o[T];
      m += `
  `.concat(s[B] ? "🚫" : "➡️", " ").concat(B)
    }
  }
  console.log("".concat(m, "\n```"))
}

function c8() {
  for (var _ = 0, s = ["rec2020", "p3", "srgb"]; _ < s.length; _++) {
    var m = s[_];
    if (matchMedia("(color-gamut: ".concat(m, ")")).matches) return m
  }
}

function u8() {
  if (dv("inverted")) return !0;
  if (dv("none")) return !1
}

function dv(_) {
  return matchMedia("(inverted-colors: ".concat(_, ")")).matches
}

function h8() {
  if (pv("active")) return !0;
  if (pv("none")) return !1
}

function pv(_) {
  return matchMedia("(forced-colors: ".concat(_, ")")).matches
}
var d8 = 100;

function p8() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var _ = 0; _ <= d8; ++_)
      if (matchMedia("(max-monochrome: ".concat(_, ")")).matches) return _;
    throw new Error("Too high value")
  }
}

function f8() {
  if (fc("no-preference")) return 0;
  if (fc("high") || fc("more")) return 1;
  if (fc("low") || fc("less")) return -1;
  if (fc("forced")) return 10
}

function fc(_) {
  return matchMedia("(prefers-contrast: ".concat(_, ")")).matches
}

function m8() {
  if (fv("reduce")) return !0;
  if (fv("no-preference")) return !1
}

function fv(_) {
  return matchMedia("(prefers-reduced-motion: ".concat(_, ")")).matches
}

function _8() {
  if (mv("reduce")) return !0;
  if (mv("no-preference")) return !1
}

function mv(_) {
  return matchMedia("(prefers-reduced-transparency: ".concat(_, ")")).matches
}

function g8() {
  if (_v("high")) return !0;
  if (_v("standard")) return !1
}

function _v(_) {
  return matchMedia("(dynamic-range: ".concat(_, ")")).matches
}
var Rn = Math,
  pa = function() {
    return 0
  };

function v8() {
  var _ = Rn.acos || pa,
    s = Rn.acosh || pa,
    m = Rn.asin || pa,
    y = Rn.asinh || pa,
    M = Rn.atanh || pa,
    z = Rn.atan || pa,
    T = Rn.sin || pa,
    o = Rn.sinh || pa,
    B = Rn.cos || pa,
    N = Rn.cosh || pa,
    W = Rn.tan || pa,
    K = Rn.tanh || pa,
    se = Rn.exp || pa,
    X = Rn.expm1 || pa,
    me = Rn.log1p || pa,
    ge = function(Ue) {
      return Rn.pow(Rn.PI, Ue)
    },
    Ee = function(Ue) {
      return Rn.log(Ue + Rn.sqrt(Ue * Ue - 1))
    },
    ze = function(Ue) {
      return Rn.log(Ue + Rn.sqrt(Ue * Ue + 1))
    },
    Re = function(Ue) {
      return Rn.log((1 + Ue) / (1 - Ue)) / 2
    },
    Ie = function(Ue) {
      return Rn.exp(Ue) - 1 / Rn.exp(Ue) / 2
    },
    Oe = function(Ue) {
      return (Rn.exp(Ue) + 1 / Rn.exp(Ue)) / 2
    },
    st = function(Ue) {
      return Rn.exp(Ue) - 1
    },
    nt = function(Ue) {
      return (Rn.exp(2 * Ue) - 1) / (Rn.exp(2 * Ue) + 1)
    },
    qe = function(Ue) {
      return Rn.log(1 + Ue)
    };
  return {
    acos: _(.12312423423423424),
    acosh: s(1e308),
    acoshPf: Ee(1e154),
    asin: m(.12312423423423424),
    asinh: y(1),
    asinhPf: ze(1),
    atanh: M(.5),
    atanhPf: Re(.5),
    atan: z(.5),
    sin: T(-1e300),
    sinh: o(1),
    sinhPf: Ie(1),
    cos: B(10.000000000123),
    cosh: N(1),
    coshPf: Oe(1),
    tan: W(-1e300),
    tanh: K(1),
    tanhPf: nt(1),
    exp: se(1),
    expm1: X(1),
    expm1Pf: st(1),
    log1p: me(10),
    log1pPf: qe(10),
    powPI: ge(-100)
  }
}
var y8 = "mmMwWLliI0fiflO&1",
  jf = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function x8() {
  return b8(function(_, s) {
    for (var m = {}, y = {}, M = 0, z = Object.keys(jf); M < z.length; M++) {
      var T = z[M],
        o = jf[T],
        B = o[0],
        N = B === void 0 ? {} : B,
        W = o[1],
        K = W === void 0 ? y8 : W,
        se = _.createElement("span");
      se.textContent = K, se.style.whiteSpace = "nowrap";
      for (var X = 0, me = Object.keys(N); X < me.length; X++) {
        var ge = me[X],
          Ee = N[ge];
        Ee !== void 0 && (se.style[ge] = Ee)
      }
      m[T] = se, s.append(_.createElement("br"), se)
    }
    for (var ze = 0, Re = Object.keys(jf); ze < Re.length; ze++) {
      var T = Re[ze];
      y[T] = m[T].getBoundingClientRect().width
    }
    return y
  })
}

function b8(_, s) {
  return s === void 0 && (s = 4e3), E0(function(m, y) {
    var M = y.document,
      z = M.body,
      T = z.style;
    T.width = "".concat(s, "px"), T.webkitTextSizeAdjust = T.textSizeAdjust = "none", zh() ? z.style.zoom = "".concat(1 / y.devicePixelRatio) : hs() && (z.style.zoom = "reset");
    var o = M.createElement("div");
    return o.textContent = C0([], Array(s / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), z.appendChild(o), _(M, z)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function w8() {
  return navigator.pdfViewerEnabled
}

function T8() {
  var _ = new Float32Array(1),
    s = new Uint8Array(_.buffer);
  return _[0] = 1 / 0, _[0] = _[0] - _[0], s[3]
}

function S8() {
  var _ = window.ApplePaySession;
  if (typeof(_ == null ? void 0 : _.canMakePayments) != "function") return -1;
  if (C8()) return -3;
  try {
    return _.canMakePayments() ? 1 : 0
  } catch (s) {
    return P8(s)
  }
}
var C8 = xE;

function P8(_) {
  if (_ instanceof Error && _.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(_.message)) return -2;
  throw _
}

function I8() {
  var _, s = document.createElement("a"),
    m = (_ = s.attributionSourceId) !== null && _ !== void 0 ? _ : s.attributionsourceid;
  return m === void 0 ? void 0 : String(m)
}
var z0 = -1,
  L0 = -2,
  M8 = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  A8 = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  k8 = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  E8 = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  D0 = "WEBGL_debug_renderer_info",
  z8 = "WEBGL_polygon_mode";

function L8(_) {
  var s, m, y, M, z, T, o = _.cache,
    B = R0(o);
  if (!B) return z0;
  if (!F0(B)) return L0;
  var N = B0() ? null : B.getExtension(D0);
  return {
    version: ((s = B.getParameter(B.VERSION)) === null || s === void 0 ? void 0 : s.toString()) || "",
    vendor: ((m = B.getParameter(B.VENDOR)) === null || m === void 0 ? void 0 : m.toString()) || "",
    vendorUnmasked: N ? (y = B.getParameter(N.UNMASKED_VENDOR_WEBGL)) === null || y === void 0 ? void 0 : y.toString() : "",
    renderer: ((M = B.getParameter(B.RENDERER)) === null || M === void 0 ? void 0 : M.toString()) || "",
    rendererUnmasked: N ? (z = B.getParameter(N.UNMASKED_RENDERER_WEBGL)) === null || z === void 0 ? void 0 : z.toString() : "",
    shadingLanguageVersion: ((T = B.getParameter(B.SHADING_LANGUAGE_VERSION)) === null || T === void 0 ? void 0 : T.toString()) || ""
  }
}

function D8(_) {
  var s = _.cache,
    m = R0(s);
  if (!m) return z0;
  if (!F0(m)) return L0;
  var y = m.getSupportedExtensions(),
    M = m.getContextAttributes(),
    z = [],
    T = [],
    o = [],
    B = [],
    N = [];
  if (M)
    for (var W = 0, K = Object.keys(M); W < K.length; W++) {
      var se = K[W];
      T.push("".concat(se, "=").concat(M[se]))
    }
  for (var X = gv(m), me = 0, ge = X; me < ge.length; me++) {
    var Ee = ge[me],
      ze = m[Ee];
    o.push("".concat(Ee, "=").concat(ze).concat(M8.has(ze) ? "=".concat(m.getParameter(ze)) : ""))
  }
  if (y)
    for (var Re = 0, Ie = y; Re < Ie.length; Re++) {
      var Oe = Ie[Re];
      if (!(Oe === D0 && B0() || Oe === z8 && F8())) {
        var st = m.getExtension(Oe);
        if (!st) {
          z.push(Oe);
          continue
        }
        for (var nt = 0, qe = gv(st); nt < qe.length; nt++) {
          var Ee = qe[nt],
            ze = st[Ee];
          B.push("".concat(Ee, "=").concat(ze).concat(A8.has(ze) ? "=".concat(m.getParameter(ze)) : ""))
        }
      }
    }
  for (var Ue = 0, Je = k8; Ue < Je.length; Ue++)
    for (var Fe = Je[Ue], it = 0, tt = E8; it < tt.length; it++) {
      var $e = tt[it],
        Ae = R8(m, Fe, $e);
      N.push("".concat(Fe, ".").concat($e, "=").concat(Ae.join(",")))
    }
  return B.sort(), o.sort(), {
    contextAttributes: T,
    parameters: o,
    shaderPrecisions: N,
    extensions: y,
    extensionParameters: B,
    unsupportedExtensions: z
  }
}

function R0(_) {
  if (_.webgl) return _.webgl.context;
  var s = document.createElement("canvas"),
    m;
  s.addEventListener("webglCreateContextError", function() {
    return m = void 0
  });
  for (var y = 0, M = ["webgl", "experimental-webgl"]; y < M.length; y++) {
    var z = M[y];
    try {
      m = s.getContext(z)
    } catch {}
    if (m) break
  }
  return _.webgl = {
    context: m
  }, m
}

function R8(_, s, m) {
  var y = _.getShaderPrecisionFormat(_[s], _[m]);
  return y ? [y.rangeMin, y.rangeMax, y.precision] : []
}

function gv(_) {
  var s = Object.keys(_.__proto__);
  return s.filter(B8)
}

function B8(_) {
  return typeof _ == "string" && !_.match(/[^A-Z0-9_x]/)
}

function B0() {
  return k0()
}

function F8() {
  return zh() || hs()
}

function F0(_) {
  return typeof _.getParameter == "function"
}

function O8() {
  var _ = Hm() || hs();
  if (!_) return -2;
  if (!window.AudioContext) return -1;
  var s = new AudioContext().baseLatency;
  return s == null ? -1 : isFinite(s) ? s : -3
}

function N8() {
  if (!window.Intl) return -1;
  var _ = window.Intl.DateTimeFormat;
  if (!_) return -2;
  var s = _().resolvedOptions().locale;
  return !s && s !== "" ? -3 : s
}
var j8 = {
  fonts: TE,
  domBlockers: a8,
  fontPreferences: x8,
  audio: dE,
  screenFrame: $E,
  canvas: CE,
  osCpu: RE,
  languages: BE,
  colorDepth: FE,
  deviceMemory: OE,
  screenResolution: NE,
  hardwareConcurrency: GE,
  timezone: HE,
  sessionStorage: XE,
  localStorage: YE,
  indexedDB: KE,
  openDatabase: JE,
  cpuClass: QE,
  platform: e8,
  plugins: SE,
  touchSupport: DE,
  vendor: t8,
  vendorFlavors: r8,
  cookiesEnabled: n8,
  colorGamut: c8,
  invertedColors: u8,
  forcedColors: h8,
  monochrome: p8,
  contrast: f8,
  reducedMotion: m8,
  reducedTransparency: _8,
  hdr: g8,
  math: v8,
  pdfViewerEnabled: w8,
  architecture: T8,
  applePay: S8,
  privateClickMeasurement: I8,
  audioBaseLatency: O8,
  dateTimeLocale: N8,
  webGlBasics: L8,
  webGlExtensions: D8
};

function V8(_) {
  return nE(j8, _, [])
}
var q8 = "$ if upgrade to Pro: https://fpjs.dev/pro";

function Z8(_) {
  var s = U8(_),
    m = $8(s);
  return {
    score: s,
    comment: q8.replace(/\$/g, "".concat(m))
  }
}

function U8(_) {
  if (Hm()) return .4;
  if (hs()) return Gm() && !(Dh() && Lh()) ? .5 : .3;
  var s = "value" in _.platform ? _.platform.value : "";
  return /^Win/.test(s) ? .6 : /^Mac/.test(s) ? .5 : .7
}

function $8(_) {
  return M0(.99 + .01 * _, 1e-4)
}

function G8(_) {
  for (var s = "", m = 0, y = Object.keys(_).sort(); m < y.length; m++) {
    var M = y[m],
      z = _[M],
      T = "error" in z ? "error" : JSON.stringify(z.value);
    s += "".concat(s ? "|" : "").concat(M.replace(/([:|\\])/g, "\\$1"), ":").concat(T)
  }
  return s
}

function O0(_) {
  return JSON.stringify(_, function(s, m) {
    return m instanceof Error ? Qk(m) : m
  }, 2)
}

function N0(_) {
  return Jk(G8(_))
}

function H8(_) {
  var s, m = Z8(_);
  return {
    get visitorId() {
      return s === void 0 && (s = N0(this.components)), s
    },
    set visitorId(y) {
      s = y
    },
    confidence: m,
    components: _,
    version: P0
  }
}

function W8(_) {
  return _ === void 0 && (_ = 50), Zk(_, _ * 2)
}

function X8(_, s) {
  var m = Date.now();
  return {
    get: function(y) {
      return Ss(this, void 0, void 0, function() {
        var M, z, T;
        return Cs(this, function(o) {
          switch (o.label) {
            case 0:
              return M = Date.now(), [4, _()];
            case 1:
              return z = o.sent(), T = H8(z), (s || y != null && y.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(T.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(M - m, `
visitorId: `).concat(T.visitorId, `
components: `).concat(O0(z), "\n```")), [2, T]
          }
        })
      })
    }
  }
}

function Y8() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var _ = new XMLHttpRequest;
    _.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(P0, "/npm-monitoring"), !0), _.send()
  } catch (s) {
    console.error(s)
  }
}

function K8(_) {
  var s;
  return _ === void 0 && (_ = {}), Ss(this, void 0, void 0, function() {
    var m, y, M;
    return Cs(this, function(z) {
      switch (z.label) {
        case 0:
          return (!((s = _.monitoring) !== null && s !== void 0) || s) && Y8(), m = _.delayFallback, y = _.debug, [4, W8(m)];
        case 1:
          return z.sent(), M = V8({
            cache: {},
            debug: y
          }), [2, X8(M, y)]
      }
    })
  })
}
var J8 = {
  load: K8,
  hashComponents: N0,
  componentsToDebugString: O0
};
let Vf = null;
async function Q8() {
  return Vf || (Vf = J8.load()), Vf
}
async function ez() {
  return (await (await Q8()).get()).visitorId
}
var tz = Lr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function $u(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = tz();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var rz = Lr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function vv(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = rz();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var nz = Lr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function j0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = nz();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var iz = Lr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  az = Lr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function V0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = Kt(),
    M = Ct(y);
  {
    var z = o => {
        var B = iz();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      },
      T = o => {
        var B = az();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      };
    je(M, o => {
      s.filled ? o(z) : o(T, !1)
    })
  }
  H(_, y)
}
var sz = Lr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function bm(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = sz();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var oz = Lr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function q0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = oz();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var lz = Lr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');

function cz(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = lz();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var uz = Lr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');

function hz(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = uz();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var dz = Pe("<!> ", 1),
  pz = Pe("<!> ", 1),
  fz = Pe("<!> ", 1),
  mz = Pe('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  _z = Pe("<!> ", 1),
  gz = Pe("<!> <!>", 1),
  vz = (_, s) => ce(s, !w(s)),
  yz = (_, s) => {
    ce(s, "colorpicker")
  },
  xz = (_, s) => {
    s(!s())
  },
  bz = (_, s) => {
    ce(s, "cleararea")
  },
  wz = Pe('<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'),
  Tz = (_, s) => {
    sa.smallPlop.play(), s()
  },
  Sz = (_, s, m) => {
    s(w(m).idx)
  },
  Cz = Pe('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  Pz = Pe("<div><button><!></button></div>"),
  Iz = (_, s) => {
    ce(s, !w(s))
  },
  Mz = (_, s) => {
    ce(s, w(s) === "eraser" ? "pencil" : "eraser", !0)
  },
  Az = Pe('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function kz(_, s) {
  Br(s, !0);
  let m = Et(s, "screenLocked", 15),
    y = Et(s, "opaquePixelArt", 15);
  const M = ht(() => new hl(s.tileSize));
  let z = ut(1),
    T = ut("pencil");
  const o = new Map,
    B = new Map;
  let N = ut(0),
    W = ut(!1),
    K = ut(!0),
    se = ht(() => Mt.charges ?? 0),
    X = ht(() => w(se) - w(N)),
    me = ut(!1),
    ge = !1,
    Ee = ut(!1),
    ze = ut(yi([]));
  const Re = ht(() => w(T) === "pencil"),
    Ie = ht(() => w(T) === "eraser"),
    Oe = ht(() => w(T) === "colorpicker"),
    st = ht(() => w(T) === "cleararea"),
    nt = ht(() => {
      var bt, Xe;
      return Ou((Xe = (bt = Mt) == null ? void 0 : bt.data) == null ? void 0 : Xe.role, ["admin", "global_moderator"])
    });
  let qe = ut(!1),
    Ue = ut(0),
    Je = ut(void 0),
    Fe = ut(void 0);
  const it = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(bt => ({
      ...Xi.colors[bt],
      idx: bt
    })),
    tt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(bt => ({
      ...Xi.colors[bt],
      idx: bt
    }));
  let $e = ut(!1);
  const Ae = ht(() => w($e) ? it : tt),
    gt = "show-all-colors";
  An(() => {
    ce($e, localStorage.getItem(gt) === "true")
  }), Xr(() => {
    localStorage.setItem(gt, w($e) ? "true" : "false")
  });
  const Q = "selected-color";
  An(() => {
    const bt = Number(localStorage.getItem(Q));
    !isNaN(bt) && bt < Xi.colors.length && bt > 0 && ce(z, bt, !0)
  }), Xr(() => {
    localStorage.setItem(Q, w(z).toString())
  });
  const re = new Ck({
    map: s.map,
    tileSize: s.tileSize,
    tileZoom: s.tileZoom,
    beforeLayerId: s.hoverLayerId
  });
  Xr(() => {
    const bt = y() ? 1 : 0;
    re.setCanvasOpacity(bt)
  }), Xr(() => {
    y() ? Uf() : _t([...o.values()])
  });
  let _e = !1;
  An(() => {
    os(s.map.getCenter(), s.map.getZoom());
    const bt = s.map.on("click", lr => {
      var rn;
      s.zoom < s.tileZoom + 2 && ((rn = Mt.data) == null ? void 0 : rn.role) === "user" && s.map.easeTo({
        center: lr.lngLat,
        zoom: 17
      });
      const bn = [lr.lngLat.lat, lr.lngLat.lng];
      if (w(Re)) ke([bn], w(z));
      else if (w(Ie)) Le([bn]);
      else if (w(Oe)) lt(bn, lr.point);
      else if (w(st) && (w(ze).push(bn), ke([bn], 0), w(ze).length >= 2)) {
        const [Qr, _a] = w(ze), [hi, Ki] = w(M).latLonToPixelsFloor(Qr[0], Qr[1], s.tileZoom), [Zn, ai] = w(M).latLonToPixelsFloor(_a[0], _a[1], s.tileZoom), qi = Math.min(hi, Zn), Zi = Math.max(hi, Zn), Bi = Math.min(Ki, ai), Fi = Math.max(Ki, ai), Ji = [];
        for (let wt = Bi; wt <= Fi; wt++) {
          const Gt = w(M).pixelsToLatLon(qi + .5, wt + .5, s.tileZoom),
            Dr = w(M).pixelsToLatLon(Zi + .5, wt + .5, s.tileZoom),
            gn = Xe({
              lat: Gt[0],
              lng: Gt[1]
            }, {
              lat: Dr[0],
              lng: Dr[1]
            }).slice(0, w(X) - Ji.length);
          if (Ji.push(...gn), Ji.length >= w(X)) break
        }
        ke(Ji, 0), ce(ze, [], !0), ce(T, "pencil")
      }
      ce(me, !0)
    });

    function Xe(lr, bn) {
      const rn = w(M).latLonToPixels(lr.lat, lr.lng, s.tileZoom),
        Qr = bn ? w(M).latLonToPixels(bn.lat, bn.lng, s.tileZoom) : rn;
      return w1(rn, Qr).map(hi => w(M).pixelsToLatLon(hi[0] + .5, hi[1] + .5, s.tileZoom))
    }

    function Lt(lr, bn) {
      const rn = Xe(lr, bn);
      w(Re) ? ke(rn, w(z)) : w(Ie) && Le(rn), ce(me, !0)
    }
    let Vt;

    function Cr(lr) {
      const bn = s.map.unproject([lr.clientX, lr.clientY]);
      if (w(Ee)) {
        const rn = Xe(bn, Vt);
        Le(rn)
      }(_e || ge) && Lt(bn, Vt), Vt = bn
    }
    window.addEventListener("mousemove", Cr);
    let Zr = !1;
    const tn = s.map.on("touchstart", lr => {
        if (lr.points.length == 2) {
          m(!1), dt(), Zr = !0, setTimeout(() => Zr = !1, 150);
          return
        }
        m() && setTimeout(() => {
          !Zr && Lt(lr.lngLat)
        }, 150), Vt = lr.lngLat
      }),
      br = s.map.on("touchmove", lr => {
        m() && Lt(lr.lngLat, Vt), Vt = lr.lngLat
      }),
      pn = lr => {
        lr.code === "Space" && (_e || Vt && Lt(Vt), _e = !0, lr.preventDefault())
      };
    document.addEventListener("keydown", pn);
    const Cn = lr => {
      lr.code === "Space" && (_e = !1, ae = !1, w(N) === 0 && w(Ie) && ce(T, "pencil"))
    };
    document.addEventListener("keyup", Cn);

    function Nn(lr) {
      if (lr.button === 2) {
        ce(Ee, !0);
        const rn = s.map.unproject([lr.clientX, lr.clientY]);
        Le([
          [rn.lat, rn.lng]
        ])
      }
    }
    document.addEventListener("mousedown", Nn);

    function vn(lr) {
      lr.button === 2 && ce(Ee, !1)
    }
    document.addEventListener("mouseup", vn);
    const Bn = lr => {
      switch (lr.code) {
        case "KeyE":
          w(N) > 0 && (w(Ie) ? ce(T, "pencil") : ce(T, "eraser"));
          return;
        case "KeyI":
          ce(T, "colorpicker");
          return;
        case "KeyC":
          w(nt) && ce(T, "cleararea");
          return
      }
    };
    return document.addEventListener("keypress", Bn), () => {
      br.unsubscribe(), tn.unsubscribe(), bt.unsubscribe(), document.removeEventListener("mousemove", Cr), document.removeEventListener("keydown", pn), document.removeEventListener("keyup", Cn), document.removeEventListener("keypress", Bn), document.removeEventListener("mousedown", Nn), document.removeEventListener("mouseup", vn), zt()
    }
  });
  let ae = !1;

  function ke(bt, Xe) {
    let Lt = !1;
    const Vt = Xe === 0;
    for (let Cr of bt) {
      const [Zr, tn] = Cr, br = v1(Xe), {
        tile: pn,
        pixel: Cn
      } = w(M).latLonToTileAndPixel(Zr, tn, s.tileZoom), Nn = {
        color: br,
        tile: pn,
        pixel: Cn,
        season: s.season,
        colorIdx: Xe
      }, vn = Ef(Nn), Bn = o.get(vn), lr = w(se) - o.size;
      if (!Bn && lr < 1) {
        if (ae && (_e || m())) continue;
        ae = !0, Vr.info(XS());
        continue
      }
      Bn && Bn.colorIdx === Xe || (sa.plop.play(), Lt || s.hidePixelHover(), o.set(vn, Nn), re.place(Cr, Xe), s.crosshair.place(Cr), Lt = !0, Vt && B.set(vn, Nn))
    }
    ce(N, o.size, !0), Lt && !y() ? _t([...o.values()]) : Lt && y() && Vt && _t([...B.values()])
  }

  function Le(bt) {
    let Xe = !1,
      Lt = !1;
    for (let Vt of bt) {
      const [Cr, Zr] = Vt, {
        tile: tn,
        pixel: br
      } = w(M).latLonToTileAndPixel(Cr, Zr, s.tileZoom), pn = Ef({
        tile: tn,
        pixel: br,
        season: s.season
      }), Cn = o.get(pn);
      Cn && (sa.plop.play(), s.hidePixelHover(), o.delete(pn), B.delete(pn), re.remove([Cr, Zr]), s.crosshair.remove(Vt), Xe = !0, Cn.colorIdx === 0 && (Lt = !0)), o.size === 0 && !(_e || ge || m()) && ce(T, "pencil")
    }
    ce(N, o.size, !0), Xe && !y() ? _t([...o.values()]) : Xe && y() && Lt && _t([...B.values()])
  }

  function lt(bt, Xe) {
    const {
      tile: Lt,
      pixel: Vt
    } = w(M).latLonToTileAndPixel(bt[0], bt[1], s.tileZoom), Cr = Ef({
      tile: Lt,
      pixel: Vt,
      season: s.season
    }), Zr = o.get(Cr);
    if (Zr) {
      vt(Zr.colorIdx), requestAnimationFrame(() => {
        var Cn;
        (Cn = document.getElementById(`color-${Zr.colorIdx}`)) == null || Cn.focus()
      });
      return
    }
    const tn = window.devicePixelRatio,
      br = Math.floor(Xe.x * tn),
      pn = Math.floor(Xe.y * tn);
    s.hidePixelHover(), BM(s.map, br, pn).then(([Cn, Nn, vn]) => {
      const Bn = y1({
        r: Cn,
        g: Nn,
        b: vn
      });
      vt(Bn), requestAnimationFrame(() => {
        var lr;
        (lr = document.getElementById(`color-${Bn}`)) == null || lr.focus()
      })
    })
  }
  Mc(() => w(z), () => {
    s.clickedLatLon && !w(me) && (w(z) === void 0 && ce(z, 1), ke([s.clickedLatLon], w(z)))
  }), Xr(() => {
    const bt = w(K) ? .8 : 0;
    s.crosshair.setCanvasOpacity(bt)
  });
  let We = ut(16.5);
  Xr(() => {
    if (w(Je) && w(Fe) && s.clickedLatLon) {
      const bt = s.map.getZoom();
      if (bt < w(We)) {
        const [Xe, Lt] = s.clickedLatLon, Vt = w(M).latLonToPixelBoundsLatLon(Xe, Lt, s.tileZoom), Cr = Bm(Vt), Zr = w(Je) - w(Fe).clientHeight, tn = w(Je) / 2 - Zr / 2;
        s.map.flyTo({
          center: {
            lat: Cr[0],
            lng: Cr[1]
          },
          zoom: 17.5,
          offset: bt > 11 ? [0, -tn] : [0, 0]
        })
      }
      ce(We, s.tileZoom, !0)
    }
  }), An(() => {
    const bt = () => {
      !document.hidden && (console.log("Tab visible again"), y() ? _t([...B.values()]) : _t([...o.values()]))
    };
    return document.addEventListener("visibilitychange", bt), () => document.removeEventListener("visibilitychange", bt)
  }), Xr(() => {
    switch (w(T)) {
      case "pencil":
        s.map.getCanvas().style.cursor = `url('${Tk}') 8 8, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        s.map.getCanvas().style.cursor = `url('${bk}') 0 16, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        s.map.getCanvas().style.cursor = `url('${wk}') 2 14, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), Xr(() => {
    m() ? ot() : dt()
  });
  async function _t(bt) {
    await s1(bt), s.refreshPixelArt()
  }
  async function zt() {
    await Uf(), re.clear(), s.refreshPixelArt(), s.crosshair.clear()
  }
  async function Dt() {
    await zt(), dt(), s.map.getCanvas().style.cursor = "default", s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4), s.onclose()
  }

  function ot() {
    s.map.dragPan.disable(), s.map.touchZoomRotate.disable(), document.body.style.overscrollBehavior = "none"
  }

  function dt() {
    s.map.dragPan.enable(), s.map.touchZoomRotate.enable(), document.body.style.overscrollBehavior = ""
  }

  function vt(bt) {
    return bt >= 32 && ce($e, !0), Mt.hasColor(bt) ? (sa.smallDropplet.play(), ce(z, bt, !0), ce(T, "pencil"), !0) : (sa.smallDropplet.play(), ce(qe, !0), ce(Ue, bt, !0), !1)
  }
  l1(bt => {
    bt.type === "leave" && w(N) > 0 && bt.cancel()
  });
  const ft = "show-paint-more-than-one-pixel-msg";
  let Tt = ut(!1);
  An(() => {
    var bt;
    ce(Tt, !localStorage.getItem(ft) && (((bt = Mt.data) == null ? void 0 : bt.pixelsPainted) ?? 0) < 100, !0)
  }), Xr(() => {
    w(N) > 1 && (ce(Tt, !1), localStorage.setItem(ft, "false"))
  });
  const xt = "lp";
  An(() => {
    var Xe;
    const bt = localStorage.getItem(xt);
    if (bt) try {
      const Lt = JSON.parse(atob(bt)),
        Vt = (Lt == null ? void 0 : Lt.time) ?? 0,
        Cr = 60 * 1e3;
      (Lt == null ? void 0 : Lt.userId) !== ((Xe = Mt.data) == null ? void 0 : Xe.id) && Date.now() - Vt < 30 * Cr && !T1 && (Vr.error(JS()), Dt())
    } catch (Lt) {
      console.error(Lt)
    }
  });

  function pt() {
    var Xe;
    const bt = btoa(JSON.stringify({
      userId: (Xe = Mt.data) == null ? void 0 : Xe.id,
      time: Date.now()
    }));
    localStorage.setItem(xt, bt)
  }
  var At = Az(),
    Wt = Ct(At),
    Xt = E(Wt);
  {
    var rr = bt => {
        il(bt, {
          children: (Xe, Lt) => {
            var Vt = dz(),
              Cr = Ct(Vt);
            j0(Cr, {
              class: "inline size-5"
            });
            var Zr = Z(Cr);
            Ye(tn => ye(Zr, ` ${tn??""}`), [() => g5()]), H(Xe, Vt)
          },
          $$slots: {
            default: !0
          }
        })
      },
      er = bt => {
        var Xe = Kt(),
          Lt = Ct(Xe);
        {
          var Vt = Zr => {
              il(Zr, {
                class: "not-touchscreen:hidden",
                children: (tn, br) => {
                  var pn = pz(),
                    Cn = Ct(pn);
                  Ug(Cn, {
                    class: "inline size-5"
                  });
                  var Nn = Z(Cn);
                  Ye(vn => ye(Nn, ` ${vn??""}`), [() => x5()]), H(tn, pn)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            Cr = Zr => {
              var tn = Kt(),
                br = Ct(tn);
              {
                var pn = Nn => {
                    il(Nn, {
                      class: "not-touchscreen:hidden",
                      children: (vn, Bn) => {
                        var lr = fz(),
                          bn = Ct(lr);
                        vv(bn, {
                          class: "inline size-5"
                        });
                        var rn = Z(bn, 1, !0);
                        Ye(Qr => ye(rn, Qr), [() => T5()]), H(vn, lr)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Cn = Nn => {
                    var vn = Kt(),
                      Bn = Ct(vn);
                    {
                      var lr = rn => {
                          il(rn, {
                            class: "touchscreen:hidden",
                            children: (Qr, _a) => {
                              var hi = mz(),
                                Ki = Ct(hi);
                              q0(Ki, {
                                class: "inline size-5"
                              });
                              var Zn = Z(Ki),
                                ai = E(Zn, !0);
                              k(Zn);
                              var qi = Z(Zn, 2),
                                Zi = E(qi),
                                Bi = Z(Zi),
                                Fi = E(Bi, !0);
                              k(Bi), k(qi);
                              var Ji = Z(qi);
                              Ye((wt, Gt, Dr, gn) => {
                                ye(ai, wt), ye(Zi, `${Gt??""} `), ye(Fi, Dr), ye(Ji, ` ${gn??""}`)
                              }, [() => P5(), () => z5(), () => A5(), () => R5()]), H(Qr, hi)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        bn = rn => {
                          var Qr = Kt(),
                            _a = Ct(Qr);
                          {
                            var hi = Zn => {
                                il(Zn, {
                                  class: "bg-warning text-warning-content animate-bounce",
                                  children: (ai, qi) => {
                                    var Zi = _z(),
                                      Bi = Ct(Zi);
                                    kh(Bi, {
                                      class: "inline size-5"
                                    });
                                    var Fi = Z(Bi);
                                    Ye(Ji => ye(Fi, ` ${Ji??""}`), [() => O5()]), H(ai, Zi)
                                  },
                                  $$slots: {
                                    default: !0
                                  }
                                })
                              },
                              Ki = Zn => {
                                var ai = Kt(),
                                  qi = Ct(ai);
                                {
                                  var Zi = Bi => {
                                    il(Bi, {
                                      class: "bg-warning text-warning-content animate-bounce",
                                      children: (Fi, Ji) => {
                                        var wt = gz(),
                                          Gt = Ct(wt);
                                        $u(Gt, {
                                          class: "inline size-5"
                                        });
                                        var Dr = Z(Gt, 2);
                                        {
                                          var gn = Wn => {
                                              var Pn = Mi();
                                              Ye(Er => ye(Pn, Er), [() => Wv()]), H(Wn, Pn)
                                            },
                                            Fn = Wn => {
                                              var Pn = Kt(),
                                                Er = Ct(Pn);
                                              {
                                                var Qi = nr => {
                                                  var Ot = Mi();
                                                  Ye(Wr => ye(Ot, Wr), [() => Xv()]), H(nr, Ot)
                                                };
                                                je(Er, nr => {
                                                  w(ze).length === 1 && nr(Qi)
                                                }, !0)
                                              }
                                              H(Wn, Pn)
                                            };
                                          je(Dr, Wn => {
                                            w(ze).length === 0 ? Wn(gn) : Wn(Fn, !1)
                                          })
                                        }
                                        H(Fi, wt)
                                      },
                                      $$slots: {
                                        default: !0
                                      }
                                    })
                                  };
                                  je(qi, Bi => {
                                    w(st) && Bi(Zi)
                                  }, !0)
                                }
                                H(Zn, ai)
                              };
                            je(_a, Zn => {
                              w(Tt) ? Zn(hi) : Zn(Ki, !1)
                            }, !0)
                          }
                          H(rn, Qr)
                        };
                      je(Bn, rn => {
                        w(Re) && w(N) === 0 ? rn(lr) : rn(bn, !1)
                      }, !0)
                    }
                    H(Nn, vn)
                  };
                je(br, Nn => {
                  w(Oe) ? Nn(pn) : Nn(Cn, !1)
                }, !0)
              }
              H(Zr, tn)
            };
          je(Lt, Zr => {
            w(Ie) ? Zr(Vt) : Zr(Cr, !1)
          }, !0)
        }
        H(bt, Xe)
      };
    je(Xt, bt => {
      w(Ie) && w(N) === 0 ? bt(rr) : bt(er, !1)
    })
  }
  var It = Z(Xt, 2),
    ur = E(It);
  ur.__click = [vz, K];
  var yr = E(ur);
  {
    var Mr = bt => {
        Mk(bt, {
          class: "size-4"
        })
      },
      Gr = bt => {
        kk(bt, {
          class: "size-4"
        })
      };
    je(yr, bt => {
      w(K) ? bt(Mr) : bt(Gr, !1)
    })
  }
  k(ur);
  var xr = Z(ur, 2),
    Sr = E(xr),
    wr = E(Sr),
    gr = Z(wr);
  T0(gr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${w(N)??""})`
    },
    mono: !0
  }), k(Sr);
  var Ar = Z(Sr, 2),
    ue = E(Ar),
    j = E(ue);
  _n(), k(ue);
  var U = Z(ue, 2);
  U.__click = [yz, T];
  var Y = E(U);
  vv(Y, {
    class: "size-4.5"
  }), k(U), k(Ar);
  var ie = Z(Ar, 2),
    he = E(ie);
  let Te;
  he.__click = [xz, y];
  var Me = E(he);
  {
    let bt = ht(() => !y());
    V0(Me, {
      class: "size-4.5",
      get filled() {
        return w(bt)
      }
    })
  }
  k(he), k(ie);
  var we = Z(ie, 2);
  {
    var Ne = bt => {
      var Xe = wz(),
        Lt = E(Xe),
        Vt = E(Lt);
      _n(), k(Lt);
      var Cr = Z(Lt, 2);
      Cr.__click = [bz, T];
      var Zr = E(Cr);
      $u(Zr, {
        class: "size-4.5"
      }), k(Cr), k(Xe), Ye(tn => {
        ye(Vt, `${tn??""} `), zr(Cr, 1, bo({
          "btn btn-circle btn-sm": !0,
          "btn-ghost": !w(st),
          "btn-primary": w(st)
        }))
      }, [() => jP()]), H(bt, Xe)
    };
    je(we, bt => {
      w(nt) && bt(Ne)
    })
  }
  k(xr);
  var ct = Z(xr, 2);
  ct.__click = [Tz, Dt];
  var Qe = E(ct);
  pl(Qe, {
    class: "size-4"
  }), k(ct), k(It);
  var kt = Z(It, 2),
    xe = E(kt);
  ui(xe, 23, () => w(Ae), bt => bt.idx, (bt, Xe, Lt) => {
    const Vt = ht(() => {
        const [vn, Bn, lr] = w(Xe).rgb;
        return {
          r: vn,
          g: Bn,
          b: lr
        }
      }),
      Cr = ht(() => w(z) === w(Xe).idx && w(Re)),
      Zr = ht(() => w(Xe).idx === 0),
      tn = ht(() => Mt.hasColor(w(Xe).idx));
    var br = Pz(),
      pn = E(br);
    pn.__click = [Sz, vt, Xe];
    var Cn = E(pn);
    {
      var Nn = vn => {
        var Bn = Cz(),
          lr = Ct(Bn);
        bm(lr, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var bn = Z(lr, 2),
          rn = E(bn);
        bm(rn, {
          class: "text-base-content/80 size-4"
        }), k(bn), H(vn, Bn)
      };
      je(Cn, vn => {
        w(tn) || vn(Nn)
      })
    }
    k(pn), k(br), Ye(() => {
      zr(br, 1, bo({
        tooltip: !0,
        "max-sm:h-6": w($e),
        "max-sm:before:translate-x-1/4": w(Lt) % 8 === 0 && w(Xe).name.length > 7,
        "max-sm:before:-translate-x-1/4": (w(Lt) - 7) % 8 === 0 && w(Xe).name.length > 7,
        "max-xl:before:translate-x-1/4": w(Lt) % 16 === 0 && w(Xe).name.length > 7,
        "max-xl:before:-translate-x-1/4": (w(Lt) - 15) % 16 === 0 && w(Xe).name.length > 7,
        "xl:before:translate-x-1/4": w($e) && w(Lt) % 32 === 0 && w(Xe).name.length > 7,
        "xl:before:-translate-x-1/4": w($e) && (w(Lt) - 31) % 32 === 0 && w(Xe).name.length > 7
      })), kr(br, "data-tip", w(Xe).name), zr(pn, 1, bo({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": w(Cr),
        "border-base-300": !w(Cr) && w(Zr),
        "border-base-content/20": !w(Cr) && !w(Zr),
        "max-sm:h-6 max-sm:rounded-md": w($e)
      })), Ic(pn, w(Zr) ? `background-image: url(${Sk}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${w(Vt).r} ${w(Vt).g} ${w(Vt).b})`), kr(pn, "aria-label", w(Xe).name), kr(pn, "id", `color-${w(Xe).idx??""}`)
    }), Ai("focus", pn, () => {
      w(tn) && (ce(z, w(Xe).idx, !0), ce(T, "pencil"))
    }), H(bt, br)
  }), k(xe), k(kt);
  var Nt = Z(kt, 2),
    Jt = E(Nt);
  Jt.__click = [Iz, $e];
  var jt = E(Jt);
  {
    var hr = bt => {
        cz(bt, {
          class: "size-5"
        })
      },
      $r = bt => {
        hz(bt, {
          class: "size-5"
        })
      };
    je(jt, bt => {
      w($e) ? bt(hr) : bt($r, !1)
    })
  }
  k(Jt);
  var en = Z(Jt, 2),
    tr = E(en);
  {
    let bt = ht(() => w(N) > 100 ? "animate-pulse" : ""),
      Xe = ht(() => w(N) === 0 || w(W) || w(X) < 0 || !fa.captcha),
      Lt = ht(() => w(W) || !fa.captcha);
    S0(tr, {
      get class() {
        return w(bt)
      },
      get charges() {
        return w(X)
      },
      get disabled() {
        return w(Xe)
      },
      get loading() {
        return w(Lt)
      },
      onclick: async () => {
        var Zr;
        const Vt = (Zr = fa.captcha) == null ? void 0 : Zr.token;
        if (!Vt) return;
        sa.droppletAndPlop.play();
        const Cr = [...o.values()];
        ce(W, !0);
        try {
          const tn = await ez();
          await an.paint(Cr, Vt, tn), await o1(Cr), pt(), Mt.refresh(), Wd.shouldReload = !0, await Dt()
        } catch (tn) {
          Vr.error(`${tn.message}`, {
            duration: 7e3
          })
        } finally {
          ce(W, !1), fa.captcha = void 0
        }
      }
    })
  }
  k(en);
  var Ht = Z(en, 2),
    Yt = E(Ht),
    ar = E(Yt),
    qr = E(ar);
  _n(), k(ar);
  var yt = Z(ar, 2);
  let sn;
  yt.__click = [Mz, T];
  var Yr = E(yt);
  Ug(Yr, {
    class: "size-5",
    get filled() {
      return w(Ie)
    }
  }), k(yt), k(Yt), k(Ht), k(Nt), k(Wt), Xs(Wt, bt => ce(Fe, bt), () => w(Fe));
  var kn = Z(Wt, 2);
  Vk(kn, {
    get colorIdx() {
      return w(Ue)
    },
    get open() {
      return w(qe)
    },
    set open(bt) {
      ce(qe, bt, !0)
    }
  }), Ye((bt, Xe, Lt, Vt, Cr, Zr) => {
    ye(wr, `${bt??""} `), ye(j, `${Xe??""} `), zr(U, 1, bo({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !w(Oe),
      "btn-primary": w(Oe)
    })), kr(ie, "data-tip", Lt), Te = zr(he, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Te, Vt), zr(xe, 1, bo({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": w($e),
      "gap-1": !w($e)
    })), ye(qr, `${Cr??""} `), sn = zr(yt, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, sn, Zr), yt.disabled = w(N) === 0
  }, [() => V5(), () => U5(), () => jv(), () => ({
    "text-primary": !y()
  }), () => S1(), () => ({
    "btn-primary": w(Ie)
  })]), dp("innerHeight", bt => ce(Je, bt, !0)), H(_, At), Fr()
}
ri(["click"]);

function Wm(..._) {
  return Ev(Fu(_))
}
var Ez = Pe("<div><!></div>");

function zz(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
  var M = Ez();
  or(M, T => ({
    class: T,
    ...y
  }), [() => Wm("flex items-center", s.class)]);
  var z = E(M);
  ii(z, () => s.children ?? Ta), k(M), Xs(M, T => m(T), () => m()), H(_, M), Fr()
}
var Lz = Pe('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'),
  Dz = Pe(" <!>", 1);

function Rz(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
  var M = Kt(),
    z = Ct(M);
  {
    let T = ht(() => Wm("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", s.cell.isActive && "ring-base-content/40 z-10 ring-2", s.class));
    vi(z, () => _A, (o, B) => {
      B(o, Co({
        get cell() {
          return s.cell
        },
        get class() {
          return w(T)
        }
      }, () => y, {
        get ref() {
          return m()
        },
        set ref(N) {
          m(N)
        },
        children: (N, W) => {
          _n();
          var K = Dz(),
            se = Ct(K),
            X = Z(se);
          {
            var me = ge => {
              var Ee = Lz();
              H(ge, Ee)
            };
            je(X, ge => {
              s.cell.hasFakeCaret && ge(me)
            })
          }
          Ye(() => ye(se, `${s.cell.char??""} `)), H(N, K)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  H(_, M), Fr()
}

function Bz(_, s) {
  Br(s, !0);
  let m = Et(s, "ref", 15, null),
    y = Et(s, "value", 15, ""),
    M = ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var z = Kt(),
    T = Ct(z);
  {
    let o = ht(() => Wm("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", s.class));
    vi(T, () => fA, (B, N) => {
      N(B, Co({
        get class() {
          return w(o)
        }
      }, () => M, {
        get ref() {
          return m()
        },
        set ref(W) {
          m(W)
        },
        get value() {
          return y()
        },
        set value(W) {
          y(W)
        }
      }))
    })
  }
  H(_, z), Fr()
}
var qf = {
    exports: {}
  },
  yv;

function Fz() {
  return yv || (yv = 1, (function(_) {
    (function(s) {
      _.exports ? _.exports = s() : window.intlTelInput = s()
    })(() => {
      var s = (() => {
        var m = Object.defineProperty,
          y = Object.getOwnPropertyDescriptor,
          M = Object.getOwnPropertyNames,
          z = Object.prototype.hasOwnProperty,
          T = (Q, re) => {
            for (var _e in re) m(Q, _e, {
              get: re[_e],
              enumerable: !0
            })
          },
          o = (Q, re, _e, ae) => {
            if (re && typeof re == "object" || typeof re == "function")
              for (let ke of M(re)) !z.call(Q, ke) && ke !== _e && m(Q, ke, {
                get: () => re[ke],
                enumerable: !(ae = y(re, ke)) || ae.enumerable
              });
            return Q
          },
          B = Q => o(m({}, "__esModule", {
            value: !0
          }), Q),
          N = {};
        T(N, {
          Iti: () => tt,
          default: () => gt
        });
        var W = [
            ["af", "93"],
            ["ax", "358", 1],
            ["al", "355"],
            ["dz", "213"],
            ["as", "1", 5, ["684"]],
            ["ad", "376"],
            ["ao", "244"],
            ["ai", "1", 6, ["264"]],
            ["ag", "1", 7, ["268"]],
            ["ar", "54"],
            ["am", "374"],
            ["aw", "297"],
            ["ac", "247"],
            ["au", "61", 0, null, "0"],
            ["at", "43"],
            ["az", "994"],
            ["bs", "1", 8, ["242"]],
            ["bh", "973"],
            ["bd", "880"],
            ["bb", "1", 9, ["246"]],
            ["by", "375"],
            ["be", "32"],
            ["bz", "501"],
            ["bj", "229"],
            ["bm", "1", 10, ["441"]],
            ["bt", "975"],
            ["bo", "591"],
            ["ba", "387"],
            ["bw", "267"],
            ["br", "55"],
            ["io", "246"],
            ["vg", "1", 11, ["284"]],
            ["bn", "673"],
            ["bg", "359"],
            ["bf", "226"],
            ["bi", "257"],
            ["kh", "855"],
            ["cm", "237"],
            ["ca", "1", 1, ["204", "226", "236", "249", "250", "263", "289", "306", "343", "354", "365", "367", "368", "382", "387", "403", "416", "418", "428", "431", "437", "438", "450", "584", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905"]],
            ["cv", "238"],
            ["bq", "599", 1, ["3", "4", "7"]],
            ["ky", "1", 12, ["345"]],
            ["cf", "236"],
            ["td", "235"],
            ["cl", "56"],
            ["cn", "86"],
            ["cx", "61", 2, ["89164"], "0"],
            ["cc", "61", 1, ["89162"], "0"],
            ["co", "57"],
            ["km", "269"],
            ["cg", "242"],
            ["cd", "243"],
            ["ck", "682"],
            ["cr", "506"],
            ["ci", "225"],
            ["hr", "385"],
            ["cu", "53"],
            ["cw", "599", 0],
            ["cy", "357"],
            ["cz", "420"],
            ["dk", "45"],
            ["dj", "253"],
            ["dm", "1", 13, ["767"]],
            ["do", "1", 2, ["809", "829", "849"]],
            ["ec", "593"],
            ["eg", "20"],
            ["sv", "503"],
            ["gq", "240"],
            ["er", "291"],
            ["ee", "372"],
            ["sz", "268"],
            ["et", "251"],
            ["fk", "500"],
            ["fo", "298"],
            ["fj", "679"],
            ["fi", "358", 0],
            ["fr", "33"],
            ["gf", "594"],
            ["pf", "689"],
            ["ga", "241"],
            ["gm", "220"],
            ["ge", "995"],
            ["de", "49"],
            ["gh", "233"],
            ["gi", "350"],
            ["gr", "30"],
            ["gl", "299"],
            ["gd", "1", 14, ["473"]],
            ["gp", "590", 0],
            ["gu", "1", 15, ["671"]],
            ["gt", "502"],
            ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
            ["gn", "224"],
            ["gw", "245"],
            ["gy", "592"],
            ["ht", "509"],
            ["hn", "504"],
            ["hk", "852"],
            ["hu", "36"],
            ["is", "354"],
            ["in", "91"],
            ["id", "62"],
            ["ir", "98"],
            ["iq", "964"],
            ["ie", "353"],
            ["im", "44", 2, ["1624", "74576", "7524", "7924", "7624"], "0"],
            ["il", "972"],
            ["it", "39", 0],
            ["jm", "1", 4, ["876", "658"]],
            ["jp", "81"],
            ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"],
            ["jo", "962"],
            ["kz", "7", 1, ["33", "7"], "8"],
            ["ke", "254"],
            ["ki", "686"],
            ["xk", "383"],
            ["kw", "965"],
            ["kg", "996"],
            ["la", "856"],
            ["lv", "371"],
            ["lb", "961"],
            ["ls", "266"],
            ["lr", "231"],
            ["ly", "218"],
            ["li", "423"],
            ["lt", "370"],
            ["lu", "352"],
            ["mo", "853"],
            ["mg", "261"],
            ["mw", "265"],
            ["my", "60"],
            ["mv", "960"],
            ["ml", "223"],
            ["mt", "356"],
            ["mh", "692"],
            ["mq", "596"],
            ["mr", "222"],
            ["mu", "230"],
            ["yt", "262", 1, ["269", "639"], "0"],
            ["mx", "52"],
            ["fm", "691"],
            ["md", "373"],
            ["mc", "377"],
            ["mn", "976"],
            ["me", "382"],
            ["ms", "1", 16, ["664"]],
            ["ma", "212", 0, null, "0"],
            ["mz", "258"],
            ["mm", "95"],
            ["na", "264"],
            ["nr", "674"],
            ["np", "977"],
            ["nl", "31"],
            ["nc", "687"],
            ["nz", "64"],
            ["ni", "505"],
            ["ne", "227"],
            ["ng", "234"],
            ["nu", "683"],
            ["nf", "672"],
            ["kp", "850"],
            ["mk", "389"],
            ["mp", "1", 17, ["670"]],
            ["no", "47", 0],
            ["om", "968"],
            ["pk", "92"],
            ["pw", "680"],
            ["ps", "970"],
            ["pa", "507"],
            ["pg", "675"],
            ["py", "595"],
            ["pe", "51"],
            ["ph", "63"],
            ["pl", "48"],
            ["pt", "351"],
            ["pr", "1", 3, ["787", "939"]],
            ["qa", "974"],
            ["re", "262", 0, null, "0"],
            ["ro", "40"],
            ["ru", "7", 0, null, "8"],
            ["rw", "250"],
            ["ws", "685"],
            ["sm", "378"],
            ["st", "239"],
            ["sa", "966"],
            ["sn", "221"],
            ["rs", "381"],
            ["sc", "248"],
            ["sl", "232"],
            ["sg", "65"],
            ["sx", "1", 21, ["721"]],
            ["sk", "421"],
            ["si", "386"],
            ["sb", "677"],
            ["so", "252"],
            ["za", "27"],
            ["kr", "82"],
            ["ss", "211"],
            ["es", "34"],
            ["lk", "94"],
            ["bl", "590", 1],
            ["sh", "290"],
            ["kn", "1", 18, ["869"]],
            ["lc", "1", 19, ["758"]],
            ["mf", "590", 2],
            ["pm", "508"],
            ["vc", "1", 20, ["784"]],
            ["sd", "249"],
            ["sr", "597"],
            ["sj", "47", 1, ["79"]],
            ["se", "46"],
            ["ch", "41"],
            ["sy", "963"],
            ["tw", "886"],
            ["tj", "992"],
            ["tz", "255"],
            ["th", "66"],
            ["tl", "670"],
            ["tg", "228"],
            ["tk", "690"],
            ["to", "676"],
            ["tt", "1", 22, ["868"]],
            ["tn", "216"],
            ["tr", "90"],
            ["tm", "993"],
            ["tc", "1", 23, ["649"]],
            ["tv", "688"],
            ["ug", "256"],
            ["ua", "380"],
            ["ae", "971"],
            ["gb", "44", 0, null, "0"],
            ["us", "1", 0],
            ["uy", "598"],
            ["vi", "1", 24, ["340"]],
            ["uz", "998"],
            ["vu", "678"],
            ["va", "39", 1, ["06698"]],
            ["ve", "58"],
            ["vn", "84"],
            ["wf", "681"],
            ["eh", "212", 1, ["5288", "5289"], "0"],
            ["ye", "967"],
            ["zm", "260"],
            ["zw", "263"]
          ],
          K = [];
        for (let Q = 0; Q < W.length; Q++) {
          const re = W[Q];
          K[Q] = {
            name: "",
            iso2: re[0],
            dialCode: re[1],
            priority: re[2] || 0,
            areaCodes: re[3] || null,
            nodeById: {},
            nationalPrefix: re[4] || null
          }
        }
        var se = K,
          X = {
            ad: "Andorra",
            ae: "United Arab Emirates",
            af: "Afghanistan",
            ag: "Antigua & Barbuda",
            ai: "Anguilla",
            al: "Albania",
            am: "Armenia",
            ao: "Angola",
            ar: "Argentina",
            as: "American Samoa",
            at: "Austria",
            au: "Australia",
            aw: "Aruba",
            ax: "Åland Islands",
            az: "Azerbaijan",
            ba: "Bosnia & Herzegovina",
            bb: "Barbados",
            bd: "Bangladesh",
            be: "Belgium",
            bf: "Burkina Faso",
            bg: "Bulgaria",
            bh: "Bahrain",
            bi: "Burundi",
            bj: "Benin",
            bl: "St. Barthélemy",
            bm: "Bermuda",
            bn: "Brunei",
            bo: "Bolivia",
            bq: "Caribbean Netherlands",
            br: "Brazil",
            bs: "Bahamas",
            bt: "Bhutan",
            bw: "Botswana",
            by: "Belarus",
            bz: "Belize",
            ca: "Canada",
            cc: "Cocos (Keeling) Islands",
            cd: "Congo - Kinshasa",
            cf: "Central African Republic",
            cg: "Congo - Brazzaville",
            ch: "Switzerland",
            ci: "Côte d’Ivoire",
            ck: "Cook Islands",
            cl: "Chile",
            cm: "Cameroon",
            cn: "China",
            co: "Colombia",
            cr: "Costa Rica",
            cu: "Cuba",
            cv: "Cape Verde",
            cw: "Curaçao",
            cx: "Christmas Island",
            cy: "Cyprus",
            cz: "Czechia",
            de: "Germany",
            dj: "Djibouti",
            dk: "Denmark",
            dm: "Dominica",
            do: "Dominican Republic",
            dz: "Algeria",
            ec: "Ecuador",
            ee: "Estonia",
            eg: "Egypt",
            eh: "Western Sahara",
            er: "Eritrea",
            es: "Spain",
            et: "Ethiopia",
            fi: "Finland",
            fj: "Fiji",
            fk: "Falkland Islands",
            fm: "Micronesia",
            fo: "Faroe Islands",
            fr: "France",
            ga: "Gabon",
            gb: "United Kingdom",
            gd: "Grenada",
            ge: "Georgia",
            gf: "French Guiana",
            gg: "Guernsey",
            gh: "Ghana",
            gi: "Gibraltar",
            gl: "Greenland",
            gm: "Gambia",
            gn: "Guinea",
            gp: "Guadeloupe",
            gq: "Equatorial Guinea",
            gr: "Greece",
            gt: "Guatemala",
            gu: "Guam",
            gw: "Guinea-Bissau",
            gy: "Guyana",
            hk: "Hong Kong SAR China",
            hn: "Honduras",
            hr: "Croatia",
            ht: "Haiti",
            hu: "Hungary",
            id: "Indonesia",
            ie: "Ireland",
            il: "Israel",
            im: "Isle of Man",
            in: "India",
            io: "British Indian Ocean Territory",
            iq: "Iraq",
            ir: "Iran",
            is: "Iceland",
            it: "Italy",
            je: "Jersey",
            jm: "Jamaica",
            jo: "Jordan",
            jp: "Japan",
            ke: "Kenya",
            kg: "Kyrgyzstan",
            kh: "Cambodia",
            ki: "Kiribati",
            km: "Comoros",
            kn: "St. Kitts & Nevis",
            kp: "North Korea",
            kr: "South Korea",
            kw: "Kuwait",
            ky: "Cayman Islands",
            kz: "Kazakhstan",
            la: "Laos",
            lb: "Lebanon",
            lc: "St. Lucia",
            li: "Liechtenstein",
            lk: "Sri Lanka",
            lr: "Liberia",
            ls: "Lesotho",
            lt: "Lithuania",
            lu: "Luxembourg",
            lv: "Latvia",
            ly: "Libya",
            ma: "Morocco",
            mc: "Monaco",
            md: "Moldova",
            me: "Montenegro",
            mf: "St. Martin",
            mg: "Madagascar",
            mh: "Marshall Islands",
            mk: "North Macedonia",
            ml: "Mali",
            mm: "Myanmar (Burma)",
            mn: "Mongolia",
            mo: "Macao SAR China",
            mp: "Northern Mariana Islands",
            mq: "Martinique",
            mr: "Mauritania",
            ms: "Montserrat",
            mt: "Malta",
            mu: "Mauritius",
            mv: "Maldives",
            mw: "Malawi",
            mx: "Mexico",
            my: "Malaysia",
            mz: "Mozambique",
            na: "Namibia",
            nc: "New Caledonia",
            ne: "Niger",
            nf: "Norfolk Island",
            ng: "Nigeria",
            ni: "Nicaragua",
            nl: "Netherlands",
            no: "Norway",
            np: "Nepal",
            nr: "Nauru",
            nu: "Niue",
            nz: "New Zealand",
            om: "Oman",
            pa: "Panama",
            pe: "Peru",
            pf: "French Polynesia",
            pg: "Papua New Guinea",
            ph: "Philippines",
            pk: "Pakistan",
            pl: "Poland",
            pm: "St. Pierre & Miquelon",
            pr: "Puerto Rico",
            ps: "Palestinian Territories",
            pt: "Portugal",
            pw: "Palau",
            py: "Paraguay",
            qa: "Qatar",
            re: "Réunion",
            ro: "Romania",
            rs: "Serbia",
            ru: "Russia",
            rw: "Rwanda",
            sa: "Saudi Arabia",
            sb: "Solomon Islands",
            sc: "Seychelles",
            sd: "Sudan",
            se: "Sweden",
            sg: "Singapore",
            sh: "St. Helena",
            si: "Slovenia",
            sj: "Svalbard & Jan Mayen",
            sk: "Slovakia",
            sl: "Sierra Leone",
            sm: "San Marino",
            sn: "Senegal",
            so: "Somalia",
            sr: "Suriname",
            ss: "South Sudan",
            st: "São Tomé & Príncipe",
            sv: "El Salvador",
            sx: "Sint Maarten",
            sy: "Syria",
            sz: "Eswatini",
            tc: "Turks & Caicos Islands",
            td: "Chad",
            tg: "Togo",
            th: "Thailand",
            tj: "Tajikistan",
            tk: "Tokelau",
            tl: "Timor-Leste",
            tm: "Turkmenistan",
            tn: "Tunisia",
            to: "Tonga",
            tr: "Turkey",
            tt: "Trinidad & Tobago",
            tv: "Tuvalu",
            tw: "Taiwan",
            tz: "Tanzania",
            ua: "Ukraine",
            ug: "Uganda",
            us: "United States",
            uy: "Uruguay",
            uz: "Uzbekistan",
            va: "Vatican City",
            vc: "St. Vincent & Grenadines",
            ve: "Venezuela",
            vg: "British Virgin Islands",
            vi: "U.S. Virgin Islands",
            vn: "Vietnam",
            vu: "Vanuatu",
            wf: "Wallis & Futuna",
            ws: "Samoa",
            ye: "Yemen",
            yt: "Mayotte",
            za: "South Africa",
            zm: "Zambia",
            zw: "Zimbabwe"
          },
          me = X,
          ge = {
            selectedCountryAriaLabel: "Selected country",
            noCountrySelected: "No country selected",
            countryListAriaLabel: "List of countries",
            searchPlaceholder: "Search",
            zeroSearchResults: "No results found",
            oneSearchResult: "1 result found",
            multipleSearchResults: "${count} results found",
            ac: "Ascension Island",
            xk: "Kosovo"
          },
          Ee = ge,
          ze = {
            ...me,
            ...Ee
          },
          Re = ze;
        for (let Q = 0; Q < se.length; Q++) se[Q].name = Re[se[Q].iso2];
        var Ie = 0,
          Oe = {
            allowDropdown: !0,
            autoPlaceholder: "polite",
            containerClass: "",
            countryOrder: null,
            countrySearch: !0,
            customPlaceholder: null,
            dropdownContainer: null,
            excludeCountries: [],
            fixDropdownWidth: !0,
            formatAsYouType: !0,
            formatOnDisplay: !0,
            geoIpLookup: null,
            hiddenInput: null,
            i18n: {},
            initialCountry: "",
            loadUtils: null,
            nationalMode: !0,
            onlyCountries: [],
            placeholderNumberType: "MOBILE",
            showFlags: !0,
            separateDialCode: !1,
            strictMode: !1,
            useFullscreenPopup: typeof navigator < "u" && typeof window < "u" ? /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 500 : !1,
            validationNumberTypes: ["MOBILE"]
          },
          st = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"],
          nt = Q => Q.replace(/\D/g, ""),
          qe = (Q = "") => Q.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(),
          Ue = Q => {
            const re = nt(Q);
            if (re.charAt(0) === "1") {
              const _e = re.substr(1, 3);
              return st.includes(_e)
            }
            return !1
          },
          Je = (Q, re, _e, ae) => {
            if (_e === 0 && !ae) return 0;
            let ke = 0;
            for (let Le = 0; Le < re.length; Le++) {
              if (/[+0-9]/.test(re[Le]) && ke++, ke === Q && !ae) return Le + 1;
              if (ae && ke === Q + 1) return Le
            }
            return re.length
          },
          Fe = (Q, re, _e) => {
            const ae = document.createElement(Q);
            return re && Object.entries(re).forEach(([ke, Le]) => ae.setAttribute(ke, Le)), _e && _e.appendChild(ae), ae
          },
          it = (Q, ...re) => {
            const {
              instances: _e
            } = Ae;
            Object.values(_e).forEach(ae => ae[Q](...re))
          },
          tt = class {
            constructor(Q, re = {}) {
              this.id = Ie++, this.telInput = Q, this.highlightedItem = null, this.options = Object.assign({}, Oe, re), this.hadInitialPlaceholder = !!Q.getAttribute("placeholder")
            }
            _init() {
              this.options.useFullscreenPopup && (this.options.fixDropdownWidth = !1), this.options.onlyCountries.length === 1 && (this.options.initialCountry = this.options.onlyCountries[0]), this.options.separateDialCode && (this.options.nationalMode = !1), this.options.allowDropdown && !this.options.showFlags && !this.options.separateDialCode && (this.options.nationalMode = !1), this.options.useFullscreenPopup && !this.options.dropdownContainer && (this.options.dropdownContainer = document.body), this.isAndroid = typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1, this.isRTL = !!this.telInput.closest("[dir=rtl]");
              const Q = this.options.allowDropdown || this.options.separateDialCode;
              this.showSelectedCountryOnLeft = this.isRTL ? !Q : Q, this.options.separateDialCode && (this.isRTL ? this.originalPaddingRight = this.telInput.style.paddingRight : this.originalPaddingLeft = this.telInput.style.paddingLeft), this.options.i18n = {
                ...Re,
                ...this.options.i18n
              };
              const re = new Promise((ae, ke) => {
                  this.resolveAutoCountryPromise = ae, this.rejectAutoCountryPromise = ke
                }),
                _e = new Promise((ae, ke) => {
                  this.resolveUtilsScriptPromise = ae, this.rejectUtilsScriptPromise = ke
                });
              this.promise = Promise.all([re, _e]), this.selectedCountryData = {}, this._processCountryData(), this._generateMarkup(), this._setInitialState(), this._initListeners(), this._initRequests()
            }
            _processCountryData() {
              this._processAllCountries(), this._processDialCodes(), this._translateCountryNames(), this._sortCountries()
            }
            _sortCountries() {
              this.options.countryOrder && (this.options.countryOrder = this.options.countryOrder.map(Q => Q.toLowerCase())), this.countries.sort((Q, re) => {
                const {
                  countryOrder: _e
                } = this.options;
                if (_e) {
                  const ae = _e.indexOf(Q.iso2),
                    ke = _e.indexOf(re.iso2),
                    Le = ae > -1,
                    lt = ke > -1;
                  if (Le || lt) return Le && lt ? ae - ke : Le ? -1 : 1
                }
                return Q.name.localeCompare(re.name)
              })
            }
            _addToDialCodeMap(Q, re, _e) {
              re.length > this.dialCodeMaxLen && (this.dialCodeMaxLen = re.length), this.dialCodeToIso2Map.hasOwnProperty(re) || (this.dialCodeToIso2Map[re] = []);
              for (let ke = 0; ke < this.dialCodeToIso2Map[re].length; ke++)
                if (this.dialCodeToIso2Map[re][ke] === Q) return;
              const ae = _e !== void 0 ? _e : this.dialCodeToIso2Map[re].length;
              this.dialCodeToIso2Map[re][ae] = Q
            }
            _processAllCountries() {
              const {
                onlyCountries: Q,
                excludeCountries: re
              } = this.options;
              if (Q.length) {
                const _e = Q.map(ae => ae.toLowerCase());
                this.countries = se.filter(ae => _e.includes(ae.iso2))
              } else if (re.length) {
                const _e = re.map(ae => ae.toLowerCase());
                this.countries = se.filter(ae => !_e.includes(ae.iso2))
              } else this.countries = se
            }
            _translateCountryNames() {
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q].iso2.toLowerCase();
                this.options.i18n.hasOwnProperty(re) && (this.countries[Q].name = this.options.i18n[re])
              }
            }
            _processDialCodes() {
              this.dialCodes = {}, this.dialCodeMaxLen = 0, this.dialCodeToIso2Map = {};
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q];
                this.dialCodes[re.dialCode] || (this.dialCodes[re.dialCode] = !0), this._addToDialCodeMap(re.iso2, re.dialCode, re.priority)
              }
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q];
                if (re.areaCodes) {
                  const _e = this.dialCodeToIso2Map[re.dialCode][0];
                  for (let ae = 0; ae < re.areaCodes.length; ae++) {
                    const ke = re.areaCodes[ae];
                    for (let Le = 1; Le < ke.length; Le++) {
                      const lt = ke.substr(0, Le),
                        We = re.dialCode + lt;
                      this._addToDialCodeMap(_e, We), this._addToDialCodeMap(re.iso2, We)
                    }
                    this._addToDialCodeMap(re.iso2, re.dialCode + ke)
                  }
                }
              }
            }
            _generateMarkup() {
              var dt, vt, ft;
              this.telInput.classList.add("iti__tel-input"), !this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off");
              const {
                allowDropdown: Q,
                separateDialCode: re,
                showFlags: _e,
                containerClass: ae,
                hiddenInput: ke,
                dropdownContainer: Le,
                fixDropdownWidth: lt,
                useFullscreenPopup: We,
                countrySearch: _t,
                i18n: zt
              } = this.options;
              let Dt = "iti";
              Q && (Dt += " iti--allow-dropdown"), _e && (Dt += " iti--show-flags"), ae && (Dt += ` ${ae}`), We || (Dt += " iti--inline-dropdown");
              const ot = Fe("div", {
                class: Dt
              });
              if ((dt = this.telInput.parentNode) == null || dt.insertBefore(ot, this.telInput), Q || _e || re) {
                this.countryContainer = Fe("div", {
                  class: "iti__country-container"
                }, ot), this.showSelectedCountryOnLeft ? this.countryContainer.style.left = "0px" : this.countryContainer.style.right = "0px", Q ? (this.selectedCountry = Fe("button", {
                  type: "button",
                  class: "iti__selected-country",
                  "aria-expanded": "false",
                  "aria-label": this.options.i18n.selectedCountryAriaLabel,
                  "aria-haspopup": "true",
                  "aria-controls": `iti-${this.id}__dropdown-content`,
                  role: "combobox"
                }, this.countryContainer), this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = Fe("div", {
                  class: "iti__selected-country"
                }, this.countryContainer);
                const Tt = Fe("div", {
                  class: "iti__selected-country-primary"
                }, this.selectedCountry);
                if (this.selectedCountryInner = Fe("div", {
                    class: "iti__flag"
                  }, Tt), this.selectedCountryA11yText = Fe("span", {
                    class: "iti__a11y-text"
                  }, this.selectedCountryInner), Q && (this.dropdownArrow = Fe("div", {
                    class: "iti__arrow",
                    "aria-hidden": "true"
                  }, Tt)), re && (this.selectedDialCode = Fe("div", {
                    class: "iti__selected-dial-code"
                  }, this.selectedCountry)), Q) {
                  const xt = lt ? "" : "iti--flexible-dropdown-width";
                  if (this.dropdownContent = Fe("div", {
                      id: `iti-${this.id}__dropdown-content`,
                      class: `iti__dropdown-content iti__hide ${xt}`
                    }), _t && (this.searchInput = Fe("input", {
                      type: "text",
                      class: "iti__search-input",
                      placeholder: zt.searchPlaceholder,
                      role: "combobox",
                      "aria-expanded": "true",
                      "aria-label": zt.searchPlaceholder,
                      "aria-controls": `iti-${this.id}__country-listbox`,
                      "aria-autocomplete": "list",
                      autocomplete: "off"
                    }, this.dropdownContent), this.searchResultsA11yText = Fe("span", {
                      class: "iti__a11y-text"
                    }, this.dropdownContent)), this.countryList = Fe("ul", {
                      class: "iti__country-list",
                      id: `iti-${this.id}__country-listbox`,
                      role: "listbox",
                      "aria-label": zt.countryListAriaLabel
                    }, this.dropdownContent), this._appendListItems(), _t && this._updateSearchResultsText(), Le) {
                    let pt = "iti iti--container";
                    We ? pt += " iti--fullscreen-popup" : pt += " iti--inline-dropdown", this.dropdown = Fe("div", {
                      class: pt
                    }), this.dropdown.appendChild(this.dropdownContent)
                  } else this.countryContainer.appendChild(this.dropdownContent)
                }
              }
              if (ot.appendChild(this.telInput), this._updateInputPadding(), ke) {
                const Tt = this.telInput.getAttribute("name") || "",
                  xt = ke(Tt);
                if (xt.phone) {
                  const pt = (vt = this.telInput.form) == null ? void 0 : vt.querySelector(`input[name="${xt.phone}"]`);
                  pt ? this.hiddenInput = pt : (this.hiddenInput = Fe("input", {
                    type: "hidden",
                    name: xt.phone
                  }), ot.appendChild(this.hiddenInput))
                }
                if (xt.country) {
                  const pt = (ft = this.telInput.form) == null ? void 0 : ft.querySelector(`input[name="${xt.country}"]`);
                  pt ? this.hiddenInputCountry = pt : (this.hiddenInputCountry = Fe("input", {
                    type: "hidden",
                    name: xt.country
                  }), ot.appendChild(this.hiddenInputCountry))
                }
              }
            }
            _appendListItems() {
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q],
                  _e = Q === 0 ? "iti__highlight" : "",
                  ae = Fe("li", {
                    id: `iti-${this.id}__item-${re.iso2}`,
                    class: `iti__country ${_e}`,
                    tabindex: "-1",
                    role: "option",
                    "data-dial-code": re.dialCode,
                    "data-country-code": re.iso2,
                    "aria-selected": "false"
                  }, this.countryList);
                re.nodeById[this.id] = ae;
                let ke = "";
                this.options.showFlags && (ke += `<div class='iti__flag iti__${re.iso2}'></div>`), ke += `<span class='iti__country-name'>${re.name}</span>`, ke += `<span class='iti__dial-code'>+${re.dialCode}</span>`, ae.insertAdjacentHTML("beforeend", ke)
              }
            }
            _setInitialState(Q = !1) {
              const re = this.telInput.getAttribute("value"),
                _e = this.telInput.value,
                ke = re && re.charAt(0) === "+" && (!_e || _e.charAt(0) !== "+") ? re : _e,
                Le = this._getDialCode(ke),
                lt = Ue(ke),
                {
                  initialCountry: We,
                  geoIpLookup: _t
                } = this.options,
                zt = We === "auto" && _t;
              if (Le && !lt) this._updateCountryFromNumber(ke);
              else if (!zt || Q) {
                const Dt = We ? We.toLowerCase() : "";
                Dt && this._getCountryData(Dt, !0) ? this._setCountry(Dt) : Le && lt ? this._setCountry("us") : this._setCountry()
              }
              ke && this._updateValFromNumber(ke)
            }
            _initListeners() {
              this._initTelInputListeners(), this.options.allowDropdown && this._initDropdownListeners(), (this.hiddenInput || this.hiddenInputCountry) && this.telInput.form && this._initHiddenInputListener()
            }
            _initHiddenInputListener() {
              var Q;
              this._handleHiddenInputSubmit = () => {
                this.hiddenInput && (this.hiddenInput.value = this.getNumber()), this.hiddenInputCountry && (this.hiddenInputCountry.value = this.getSelectedCountryData().iso2 || "")
              }, (Q = this.telInput.form) == null || Q.addEventListener("submit", this._handleHiddenInputSubmit)
            }
            _initDropdownListeners() {
              this._handleLabelClick = re => {
                this.dropdownContent.classList.contains("iti__hide") ? this.telInput.focus() : re.preventDefault()
              };
              const Q = this.telInput.closest("label");
              Q && Q.addEventListener("click", this._handleLabelClick), this._handleClickSelectedCountry = () => {
                this.dropdownContent.classList.contains("iti__hide") && !this.telInput.disabled && !this.telInput.readOnly && this._openDropdown()
              }, this.selectedCountry.addEventListener("click", this._handleClickSelectedCountry), this._handleCountryContainerKeydown = re => {
                this.dropdownContent.classList.contains("iti__hide") && ["ArrowUp", "ArrowDown", " ", "Enter"].includes(re.key) && (re.preventDefault(), re.stopPropagation(), this._openDropdown()), re.key === "Tab" && this._closeDropdown()
              }, this.countryContainer.addEventListener("keydown", this._handleCountryContainerKeydown)
            }
            _initRequests() {
              let {
                loadUtils: Q,
                initialCountry: re,
                geoIpLookup: _e
              } = this.options;
              Q && !Ae.utils ? (this._handlePageLoad = () => {
                var ke;
                window.removeEventListener("load", this._handlePageLoad), (ke = Ae.attachUtils(Q)) == null || ke.catch(() => {})
              }, Ae.documentReady() ? this._handlePageLoad() : window.addEventListener("load", this._handlePageLoad)) : this.resolveUtilsScriptPromise(), re === "auto" && _e && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
            }
            _loadAutoCountry() {
              Ae.autoCountry ? this.handleAutoCountry() : Ae.startedLoadingAutoCountry || (Ae.startedLoadingAutoCountry = !0, typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup((Q = "") => {
                const re = Q.toLowerCase();
                re && this._getCountryData(re, !0) ? (Ae.autoCountry = re, setTimeout(() => it("handleAutoCountry"))) : (this._setInitialState(!0), it("rejectAutoCountryPromise"))
              }, () => {
                this._setInitialState(!0), it("rejectAutoCountryPromise")
              }))
            }
            _openDropdownWithPlus() {
              this._openDropdown(), this.searchInput.value = "+", this._filterCountries("", !0)
            }
            _initTelInputListeners() {
              const {
                strictMode: Q,
                formatAsYouType: re,
                separateDialCode: _e,
                formatOnDisplay: ae,
                allowDropdown: ke,
                countrySearch: Le
              } = this.options;
              let lt = !1;
              new RegExp("\\p{L}", "u").test(this.telInput.value) && (lt = !0), this._handleInputEvent = We => {
                if (this.isAndroid && (We == null ? void 0 : We.data) === "+" && _e && ke && Le) {
                  const ot = this.telInput.selectionStart || 0,
                    dt = this.telInput.value.substring(0, ot - 1),
                    vt = this.telInput.value.substring(ot);
                  this.telInput.value = dt + vt, this._openDropdownWithPlus();
                  return
                }
                this._updateCountryFromNumber(this.telInput.value) && this._triggerCountryChange();
                const _t = (We == null ? void 0 : We.data) && /[^+0-9]/.test(We.data),
                  zt = (We == null ? void 0 : We.inputType) === "insertFromPaste" && this.telInput.value;
                _t || zt && !Q ? lt = !0 : /[^+0-9]/.test(this.telInput.value) || (lt = !1);
                const Dt = (We == null ? void 0 : We.detail) && We.detail.isSetNumber && !ae;
                if (re && !lt && !Dt) {
                  const ot = this.telInput.selectionStart || 0,
                    vt = this.telInput.value.substring(0, ot).replace(/[^+0-9]/g, "").length,
                    ft = (We == null ? void 0 : We.inputType) === "deleteContentForward",
                    Tt = this._formatNumberAsYouType(),
                    xt = Je(vt, Tt, ot, ft);
                  this.telInput.value = Tt, this.telInput.setSelectionRange(xt, xt)
                }
              }, this.telInput.addEventListener("input", this._handleInputEvent), (Q || _e) && (this._handleKeydownEvent = We => {
                if (We.key && We.key.length === 1 && !We.altKey && !We.ctrlKey && !We.metaKey) {
                  if (_e && ke && Le && We.key === "+") {
                    We.preventDefault(), this._openDropdownWithPlus();
                    return
                  }
                  if (Q) {
                    const _t = this.telInput.value,
                      zt = _t.charAt(0) === "+",
                      Dt = !zt && this.telInput.selectionStart === 0 && We.key === "+",
                      ot = /^[0-9]$/.test(We.key),
                      dt = _e ? ot : Dt || ot,
                      vt = _t.slice(0, this.telInput.selectionStart) + We.key + _t.slice(this.telInput.selectionEnd),
                      ft = this._getFullNumber(vt),
                      Tt = Ae.utils.getCoreNumber(ft, this.selectedCountryData.iso2),
                      xt = this.maxCoreNumberLength && Tt.length > this.maxCoreNumberLength;
                    let pt = !1;
                    if (zt) {
                      const At = this.selectedCountryData.iso2;
                      pt = this._getCountryFromNumber(ft) !== At
                    }(!dt || xt && !pt && !Dt) && We.preventDefault()
                  }
                }
              }, this.telInput.addEventListener("keydown", this._handleKeydownEvent))
            }
            _cap(Q) {
              const re = parseInt(this.telInput.getAttribute("maxlength") || "", 10);
              return re && Q.length > re ? Q.substr(0, re) : Q
            }
            _trigger(Q, re = {}) {
              const _e = new CustomEvent(Q, {
                bubbles: !0,
                cancelable: !0,
                detail: re
              });
              this.telInput.dispatchEvent(_e)
            }
            _openDropdown() {
              const {
                fixDropdownWidth: Q,
                countrySearch: re
              } = this.options;
              if (Q && (this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`), this.dropdownContent.classList.remove("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "true"), this._setDropdownPosition(), re) {
                const _e = this.countryList.firstElementChild;
                _e && (this._highlightListItem(_e, !1), this.countryList.scrollTop = 0), this.searchInput.focus()
              }
              this._bindDropdownListeners(), this.dropdownArrow.classList.add("iti__arrow--up"), this._trigger("open:countrydropdown")
            }
            _setDropdownPosition() {
              if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.dropdown), !this.options.useFullscreenPopup) {
                const Q = this.telInput.getBoundingClientRect(),
                  re = this.telInput.offsetHeight;
                this.options.dropdownContainer && (this.dropdown.style.top = `${Q.top+re}px`, this.dropdown.style.left = `${Q.left}px`, this._handleWindowScroll = () => this._closeDropdown(), window.addEventListener("scroll", this._handleWindowScroll))
              }
            }
            _bindDropdownListeners() {
              this._handleMouseoverCountryList = ae => {
                var Le;
                const ke = (Le = ae.target) == null ? void 0 : Le.closest(".iti__country");
                ke && this._highlightListItem(ke, !1)
              }, this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList), this._handleClickCountryList = ae => {
                var Le;
                const ke = (Le = ae.target) == null ? void 0 : Le.closest(".iti__country");
                ke && this._selectListItem(ke)
              }, this.countryList.addEventListener("click", this._handleClickCountryList);
              let Q = !0;
              this._handleClickOffToClose = () => {
                Q || this._closeDropdown(), Q = !1
              }, document.documentElement.addEventListener("click", this._handleClickOffToClose);
              let re = "",
                _e = null;
              if (this._handleKeydownOnDropdown = ae => {
                  ["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(ae.key) && (ae.preventDefault(), ae.stopPropagation(), ae.key === "ArrowUp" || ae.key === "ArrowDown" ? this._handleUpDownKey(ae.key) : ae.key === "Enter" ? this._handleEnterKey() : ae.key === "Escape" && this._closeDropdown()), !this.options.countrySearch && /^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(ae.key) && (ae.stopPropagation(), _e && clearTimeout(_e), re += ae.key.toLowerCase(), this._searchForCountry(re), _e = setTimeout(() => {
                    re = ""
                  }, 1e3))
                }, document.addEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch) {
                const ae = () => {
                  const Le = this.searchInput.value.trim();
                  Le ? this._filterCountries(Le) : this._filterCountries("", !0)
                };
                let ke = null;
                this._handleSearchChange = () => {
                  ke && clearTimeout(ke), ke = setTimeout(() => {
                    ae(), ke = null
                  }, 100)
                }, this.searchInput.addEventListener("input", this._handleSearchChange), this.searchInput.addEventListener("click", Le => Le.stopPropagation())
              }
            }
            _searchForCountry(Q) {
              for (let re = 0; re < this.countries.length; re++) {
                const _e = this.countries[re];
                if (_e.name.substr(0, Q.length).toLowerCase() === Q) {
                  const ke = _e.nodeById[this.id];
                  this._highlightListItem(ke, !1), this._scrollTo(ke);
                  break
                }
              }
            }
            _filterCountries(Q, re = !1) {
              let _e = !0;
              this.countryList.innerHTML = "";
              const ae = qe(Q);
              for (let ke = 0; ke < this.countries.length; ke++) {
                const Le = this.countries[ke],
                  lt = qe(Le.name),
                  We = Le.name.split(/[^a-zA-ZÀ-ÿа-яА-Я]/).map(zt => zt[0]).join("").toLowerCase(),
                  _t = `+${Le.dialCode}`;
                if (re || lt.includes(ae) || _t.includes(ae) || Le.iso2.includes(ae) || We.includes(ae)) {
                  const zt = Le.nodeById[this.id];
                  zt && this.countryList.appendChild(zt), _e && (this._highlightListItem(zt, !1), _e = !1)
                }
              }
              _e && this._highlightListItem(null, !1), this.countryList.scrollTop = 0, this._updateSearchResultsText()
            }
            _updateSearchResultsText() {
              const {
                i18n: Q
              } = this.options, re = this.countryList.childElementCount;
              let _e;
              re === 0 ? _e = Q.zeroSearchResults : re === 1 ? _e = Q.oneSearchResult : _e = Q.multipleSearchResults.replace("${count}", re.toString()), this.searchResultsA11yText.textContent = _e
            }
            _handleUpDownKey(Q) {
              var _e, ae;
              let re = Q === "ArrowUp" ? (_e = this.highlightedItem) == null ? void 0 : _e.previousElementSibling : (ae = this.highlightedItem) == null ? void 0 : ae.nextElementSibling;
              !re && this.countryList.childElementCount > 1 && (re = Q === "ArrowUp" ? this.countryList.lastElementChild : this.countryList.firstElementChild), re && (this._scrollTo(re), this._highlightListItem(re, !1))
            }
            _handleEnterKey() {
              this.highlightedItem && this._selectListItem(this.highlightedItem)
            }
            _updateValFromNumber(Q) {
              let re = Q;
              if (this.options.formatOnDisplay && Ae.utils && this.selectedCountryData) {
                const _e = this.options.nationalMode || re.charAt(0) !== "+" && !this.options.separateDialCode,
                  {
                    NATIONAL: ae,
                    INTERNATIONAL: ke
                  } = Ae.utils.numberFormat,
                  Le = _e ? ae : ke;
                re = Ae.utils.formatNumber(re, this.selectedCountryData.iso2, Le)
              }
              re = this._beforeSetNumber(re), this.telInput.value = re
            }
            _updateCountryFromNumber(Q) {
              const re = this._getCountryFromNumber(Q);
              return re !== null ? this._setCountry(re) : !1
            }
            _ensureHasDialCode(Q) {
              const {
                dialCode: re,
                nationalPrefix: _e
              } = this.selectedCountryData;
              if (Q.charAt(0) === "+" || !re) return Q;
              const Le = _e && Q.charAt(0) === _e && !this.options.separateDialCode ? Q.substring(1) : Q;
              return `+${re}${Le}`
            }
            _getCountryFromNumber(Q) {
              const re = Q.indexOf("+");
              let _e = re ? Q.substring(re) : Q;
              const ae = this.selectedCountryData.iso2,
                ke = this.selectedCountryData.dialCode;
              _e = this._ensureHasDialCode(_e);
              const Le = this._getDialCode(_e, !0),
                lt = nt(_e);
              if (Le) {
                const We = nt(Le),
                  _t = this.dialCodeToIso2Map[We];
                if (!ae && this.defaultCountry && _t.includes(this.defaultCountry)) return this.defaultCountry;
                const zt = ae && _t.includes(ae) && (lt.length === We.length || !this.selectedCountryData.areaCodes);
                if (!(ke === "1" && Ue(lt)) && !zt) {
                  for (let ot = 0; ot < _t.length; ot++)
                    if (_t[ot]) return _t[ot]
                }
              } else {
                if (_e.charAt(0) === "+" && lt.length) return "";
                if ((!_e || _e === "+") && !this.selectedCountryData.iso2) return this.defaultCountry
              }
              return null
            }
            _highlightListItem(Q, re) {
              const _e = this.highlightedItem;
              if (_e && (_e.classList.remove("iti__highlight"), _e.setAttribute("aria-selected", "false")), this.highlightedItem = Q, this.highlightedItem) {
                this.highlightedItem.classList.add("iti__highlight"), this.highlightedItem.setAttribute("aria-selected", "true");
                const ae = this.highlightedItem.getAttribute("id") || "";
                this.selectedCountry.setAttribute("aria-activedescendant", ae), this.options.countrySearch && this.searchInput.setAttribute("aria-activedescendant", ae)
              }
              re && this.highlightedItem.focus()
            }
            _getCountryData(Q, re) {
              for (let _e = 0; _e < this.countries.length; _e++)
                if (this.countries[_e].iso2 === Q) return this.countries[_e];
              if (re) return null;
              throw new Error(`No country data for '${Q}'`)
            }
            _setCountry(Q) {
              const {
                separateDialCode: re,
                showFlags: _e,
                i18n: ae
              } = this.options, ke = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
              if (this.selectedCountryData = Q ? this._getCountryData(Q, !1) || {} : {}, this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), this.selectedCountryInner) {
                let Le = "",
                  lt = "";
                Q && _e ? (Le = `iti__flag iti__${Q}`, lt = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`) : (Le = "iti__flag iti__globe", lt = ae.noCountrySelected), this.selectedCountryInner.className = Le, this.selectedCountryA11yText.textContent = lt
              }
              if (this._setSelectedCountryTitleAttribute(Q, re), re) {
                const Le = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                this.selectedDialCode.innerHTML = Le, this._updateInputPadding()
              }
              return this._updatePlaceholder(), this._updateMaxLength(), ke.iso2 !== Q
            }
            _updateInputPadding() {
              if (this.selectedCountry) {
                const re = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth()) + 6;
                this.showSelectedCountryOnLeft ? this.telInput.style.paddingLeft = `${re}px` : this.telInput.style.paddingRight = `${re}px`
              }
            }
            _updateMaxLength() {
              const {
                strictMode: Q,
                placeholderNumberType: re,
                validationNumberTypes: _e
              } = this.options, {
                iso2: ae
              } = this.selectedCountryData;
              if (Q && Ae.utils)
                if (ae) {
                  const ke = Ae.utils.numberType[re];
                  let Le = Ae.utils.getExampleNumber(ae, !1, ke, !0),
                    lt = Le;
                  for (; Ae.utils.isPossibleNumber(Le, ae, _e);) lt = Le, Le += "0";
                  const We = Ae.utils.getCoreNumber(lt, ae);
                  this.maxCoreNumberLength = We.length, ae === "by" && (this.maxCoreNumberLength = We.length + 1)
                } else this.maxCoreNumberLength = null
            }
            _setSelectedCountryTitleAttribute(Q = null, re) {
              if (!this.selectedCountry) return;
              let _e;
              Q && !re ? _e = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}` : Q ? _e = this.selectedCountryData.name : _e = "Unknown", this.selectedCountry.setAttribute("title", _e)
            }
            _getHiddenSelectedCountryWidth() {
              if (this.telInput.parentNode) {
                const Q = this.telInput.parentNode.cloneNode(!1);
                Q.style.visibility = "hidden", document.body.appendChild(Q);
                const re = this.countryContainer.cloneNode();
                Q.appendChild(re);
                const _e = this.selectedCountry.cloneNode(!0);
                re.appendChild(_e);
                const ae = _e.offsetWidth;
                return document.body.removeChild(Q), ae
              }
              return 0
            }
            _updatePlaceholder() {
              const {
                autoPlaceholder: Q,
                placeholderNumberType: re,
                nationalMode: _e,
                customPlaceholder: ae
              } = this.options, ke = Q === "aggressive" || !this.hadInitialPlaceholder && Q === "polite";
              if (Ae.utils && ke) {
                const Le = Ae.utils.numberType[re];
                let lt = this.selectedCountryData.iso2 ? Ae.utils.getExampleNumber(this.selectedCountryData.iso2, _e, Le) : "";
                lt = this._beforeSetNumber(lt), typeof ae == "function" && (lt = ae(lt, this.selectedCountryData)), this.telInput.setAttribute("placeholder", lt)
              }
            }
            _selectListItem(Q) {
              const re = this._setCountry(Q.getAttribute("data-country-code"));
              this._closeDropdown(), this._updateDialCode(Q.getAttribute("data-dial-code")), this.telInput.focus(), re && this._triggerCountryChange()
            }
            _closeDropdown() {
              this.dropdownContent.classList.add("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "false"), this.selectedCountry.removeAttribute("aria-activedescendant"), this.highlightedItem && this.highlightedItem.setAttribute("aria-selected", "false"), this.options.countrySearch && this.searchInput.removeAttribute("aria-activedescendant"), this.dropdownArrow.classList.remove("iti__arrow--up"), document.removeEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch && this.searchInput.removeEventListener("input", this._handleSearchChange), document.documentElement.removeEventListener("click", this._handleClickOffToClose), this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList), this.countryList.removeEventListener("click", this._handleClickCountryList), this.options.dropdownContainer && (this.options.useFullscreenPopup || window.removeEventListener("scroll", this._handleWindowScroll), this.dropdown.parentNode && this.dropdown.parentNode.removeChild(this.dropdown)), this._handlePageLoad && window.removeEventListener("load", this._handlePageLoad), this._trigger("close:countrydropdown")
            }
            _scrollTo(Q) {
              const re = this.countryList,
                _e = document.documentElement.scrollTop,
                ae = re.offsetHeight,
                ke = re.getBoundingClientRect().top + _e,
                Le = ke + ae,
                lt = Q.offsetHeight,
                We = Q.getBoundingClientRect().top + _e,
                _t = We + lt,
                zt = We - ke + re.scrollTop;
              if (We < ke) re.scrollTop = zt;
              else if (_t > Le) {
                const Dt = ae - lt;
                re.scrollTop = zt - Dt
              }
            }
            _updateDialCode(Q) {
              const re = this.telInput.value,
                _e = `+${Q}`;
              let ae;
              if (re.charAt(0) === "+") {
                const ke = this._getDialCode(re);
                ke ? ae = re.replace(ke, _e) : ae = _e, this.telInput.value = ae
              }
            }
            _getDialCode(Q, re) {
              let _e = "";
              if (Q.charAt(0) === "+") {
                let ae = "";
                for (let ke = 0; ke < Q.length; ke++) {
                  const Le = Q.charAt(ke);
                  if (!isNaN(parseInt(Le, 10))) {
                    if (ae += Le, re) this.dialCodeToIso2Map[ae] && (_e = Q.substr(0, ke + 1));
                    else if (this.dialCodes[ae]) {
                      _e = Q.substr(0, ke + 1);
                      break
                    }
                    if (ae.length === this.dialCodeMaxLen) break
                  }
                }
              }
              return _e
            }
            _getFullNumber(Q) {
              const re = Q || this.telInput.value.trim(),
                {
                  dialCode: _e
                } = this.selectedCountryData;
              let ae;
              const ke = nt(re);
              return this.options.separateDialCode && re.charAt(0) !== "+" && _e && ke ? ae = `+${_e}` : ae = "", ae + re
            }
            _beforeSetNumber(Q) {
              let re = Q;
              if (this.options.separateDialCode) {
                let _e = this._getDialCode(re);
                if (_e) {
                  _e = `+${this.selectedCountryData.dialCode}`;
                  const ae = re[_e.length] === " " || re[_e.length] === "-" ? _e.length + 1 : _e.length;
                  re = re.substr(ae)
                }
              }
              return this._cap(re)
            }
            _triggerCountryChange() {
              this._trigger("countrychange")
            }
            _formatNumberAsYouType() {
              const Q = this._getFullNumber(),
                re = Ae.utils ? Ae.utils.formatNumberAsYouType(Q, this.selectedCountryData.iso2) : Q,
                {
                  dialCode: _e
                } = this.selectedCountryData;
              return this.options.separateDialCode && this.telInput.value.charAt(0) !== "+" && re.includes(`+${_e}`) ? (re.split(`+${_e}`)[1] || "").trim() : re
            }
            handleAutoCountry() {
              this.options.initialCountry === "auto" && Ae.autoCountry && (this.defaultCountry = Ae.autoCountry, this.selectedCountryData.iso2 || this.selectedCountryInner.classList.contains("iti__globe") || this.setCountry(this.defaultCountry), this.resolveAutoCountryPromise())
            }
            handleUtils() {
              Ae.utils && (this.telInput.value && this._updateValFromNumber(this.telInput.value), this.selectedCountryData.iso2 && (this._updatePlaceholder(), this._updateMaxLength())), this.resolveUtilsScriptPromise()
            }
            destroy() {
              var ke, Le;
              const {
                allowDropdown: Q,
                separateDialCode: re
              } = this.options;
              if (Q) {
                this._closeDropdown(), this.selectedCountry.removeEventListener("click", this._handleClickSelectedCountry), this.countryContainer.removeEventListener("keydown", this._handleCountryContainerKeydown);
                const lt = this.telInput.closest("label");
                lt && lt.removeEventListener("click", this._handleLabelClick)
              }
              const {
                form: _e
              } = this.telInput;
              this._handleHiddenInputSubmit && _e && _e.removeEventListener("submit", this._handleHiddenInputSubmit), this.telInput.removeEventListener("input", this._handleInputEvent), this._handleKeydownEvent && this.telInput.removeEventListener("keydown", this._handleKeydownEvent), this.telInput.removeAttribute("data-intl-tel-input-id"), re && (this.isRTL ? this.telInput.style.paddingRight = this.originalPaddingRight : this.telInput.style.paddingLeft = this.originalPaddingLeft);
              const ae = this.telInput.parentNode;
              (ke = ae == null ? void 0 : ae.parentNode) == null || ke.insertBefore(this.telInput, ae), (Le = ae == null ? void 0 : ae.parentNode) == null || Le.removeChild(ae), delete Ae.instances[this.id]
            }
            getExtension() {
              return Ae.utils ? Ae.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
            }
            getNumber(Q) {
              if (Ae.utils) {
                const {
                  iso2: re
                } = this.selectedCountryData;
                return Ae.utils.formatNumber(this._getFullNumber(), re, Q)
              }
              return ""
            }
            getNumberType() {
              return Ae.utils ? Ae.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : -99
            }
            getSelectedCountryData() {
              return this.selectedCountryData
            }
            getValidationError() {
              if (Ae.utils) {
                const {
                  iso2: Q
                } = this.selectedCountryData;
                return Ae.utils.getValidationError(this._getFullNumber(), Q)
              }
              return -99
            }
            isValidNumber() {
              if (!this.selectedCountryData.iso2) return !1;
              const Q = this._getFullNumber(),
                re = Q.search(new RegExp("\\p{L}", "u"));
              if (re > -1) {
                const _e = Q.substring(0, re),
                  ae = this._utilsIsPossibleNumber(_e),
                  ke = this._utilsIsPossibleNumber(Q);
                return ae && ke
              }
              return this._utilsIsPossibleNumber(Q)
            }
            _utilsIsPossibleNumber(Q) {
              return Ae.utils ? Ae.utils.isPossibleNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            isValidNumberPrecise() {
              if (!this.selectedCountryData.iso2) return !1;
              const Q = this._getFullNumber(),
                re = Q.search(new RegExp("\\p{L}", "u"));
              if (re > -1) {
                const _e = Q.substring(0, re),
                  ae = this._utilsIsValidNumber(_e),
                  ke = this._utilsIsValidNumber(Q);
                return ae && ke
              }
              return this._utilsIsValidNumber(Q)
            }
            _utilsIsValidNumber(Q) {
              return Ae.utils ? Ae.utils.isValidNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            setCountry(Q) {
              const re = Q == null ? void 0 : Q.toLowerCase(),
                _e = this.selectedCountryData.iso2;
              (Q && re !== _e || !Q && _e) && (this._setCountry(re), this._updateDialCode(this.selectedCountryData.dialCode), this._triggerCountryChange())
            }
            setNumber(Q) {
              const re = this._updateCountryFromNumber(Q);
              this._updateValFromNumber(Q), re && this._triggerCountryChange(), this._trigger("input", {
                isSetNumber: !0
              })
            }
            setPlaceholderNumberType(Q) {
              this.options.placeholderNumberType = Q, this._updatePlaceholder()
            }
            setDisabled(Q) {
              this.telInput.disabled = Q, Q ? this.selectedCountry.setAttribute("disabled", "true") : this.selectedCountry.removeAttribute("disabled")
            }
          },
          $e = Q => {
            if (!Ae.utils && !Ae.startedLoadingUtilsScript) {
              let re;
              if (typeof Q == "function") try {
                re = Promise.resolve(Q())
              } catch (_e) {
                return Promise.reject(_e)
              } else return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof Q}`));
              return Ae.startedLoadingUtilsScript = !0, re.then(_e => {
                const ae = _e == null ? void 0 : _e.default;
                if (!ae || typeof ae != "object") throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                return Ae.utils = ae, it("handleUtils"), !0
              }).catch(_e => {
                throw it("rejectUtilsScriptPromise", _e), _e
              })
            }
            return null
          },
          Ae = Object.assign((Q, re) => {
            const _e = new tt(Q, re);
            return _e._init(), Q.setAttribute("data-intl-tel-input-id", _e.id.toString()), Ae.instances[_e.id] = _e, _e
          }, {
            defaults: Oe,
            documentReady: () => document.readyState === "complete",
            getCountryData: () => se,
            getInstance: Q => {
              const re = Q.getAttribute("data-intl-tel-input-id");
              return re ? Ae.instances[re] : null
            },
            instances: {},
            attachUtils: $e,
            startedLoadingUtilsScript: !1,
            startedLoadingAutoCountry: !1,
            version: "25.3.2"
          }),
          gt = Ae;
        return B(N)
      })();
      return s.default
    })
  })(qf)), qf.exports
}
var Oz = Fz();
const Nz = Fm(Oz);
var jz = Pe('<div><span class="loading loading-spinner loading-xl"></span></div>'),
  Vz = Pe('<span class="w-8"> </span>'),
  qz = Pe('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1),
  Zz = async (_, s, m) => {
    await s(w(m))
  }, Uz = Pe('<span class="w-8"> </span>'), $z = (_, s) => {
    ce(s, "")
  }, Gz = Pe('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1), Hz = Pe('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');

function Wz(_, s) {
  Br(s, !0);
  let m = ut(!0),
    y = ut(""),
    M = ut(0),
    z = ut(!1);
  const T = ht(() => w(M) > 0 || w(z));
  let o = ut(!1),
    B = ut(""),
    N = ut(void 0);
  const W = ht(() => {
    var Ee;
    return `phone:${(Ee=Mt.data)==null?void 0:Ee.id}`
  });
  Xr(() => {
    const Ee = localStorage.getItem(w(W));
    Ee && ce(y, Ee, !0)
  }), An(() => {
    an.getOtpCooldown().then(Re => {
      ce(M, Re.cooldownMs, !0)
    }).catch(Re => {
      Vr.error(Re.message)
    }).finally(() => {
      ce(m, !1)
    });
    const Ee = 1e3,
      ze = setInterval(() => {
        ce(M, Math.max(0, w(M) - Ee), !0)
      }, Ee);
    return () => {
      clearInterval(ze)
    }
  });
  async function K(Ee) {
    try {
      ce(z, !0);
      const ze = await an.sendOtp(Ee);
      Vr.info(`${tC()} ${ze.phone}`), ce(y, ze.phone, !0), ce(M, ze.cooldownMs, !0), localStorage.setItem(w(W), w(y))
    } catch (ze) {
      Vr.error(ze.message)
    } finally {
      ce(z, !1)
    }
  }
  Xr(() => {
    w(B).length === 6 && (ce(o, !0), (async () => {
      try {
        await an.verifyOtp(w(B)), await Mt.refresh(), Vr.success(iC()), localStorage.removeItem(w(W)), s.onsuccess(w(y))
      } catch (Ee) {
        Vr.error(Ee.message)
      } finally {
        ce(B, ""), ce(o, !1)
      }
    })())
  });
  var se = Hz(),
    X = E(se);
  {
    var me = Ee => {
        var ze = jz();
        H(Ee, ze)
      },
      ge = Ee => {
        var ze = Kt(),
          Re = Ct(ze);
        {
          var Ie = st => {
              var nt = qz(),
                qe = Ct(nt),
                Ue = E(qe),
                Je = E(Ue, !0);
              k(Ue);
              var Fe = Z(Ue, 2),
                it = E(Fe, !0);
              k(Fe), k(qe);
              var tt = Z(qe, 2),
                $e = E(tt);
              Yi($e, () => _e => (ce(N, Nz(_e, {
                strictMode: !0,
                initialCountry: "br",
                loadUtils: () => A1(() => import("../chunks/BtRMyUe9.js"), [], import.meta.url),
                containerClass: "w-full",
                dropdownContainer: document.body
              })), () => {
                var ae;
                (ae = w(N)) == null || ae.destroy()
              }));
              var Ae = Z($e, 2),
                gt = E(Ae),
                Q = Z(gt);
              {
                var re = _e => {
                  var ae = Vz(),
                    ke = E(ae);
                  k(ae), Ye(Le => ye(ke, `(${Le??""})`), [() => ep(w(M))]), H(_e, ae)
                };
                je(Q, _e => {
                  w(M) > 0 && _e(re)
                })
              }
              k(Ae), k(tt), Ye((_e, ae, ke) => {
                ye(Je, _e), ye(it, ae), Ae.disabled = w(T), ye(gt, `${ke??""} `)
              }, [() => DC(), () => FC(), () => jC()]), Ai("submit", tt, async () => {
                var ae;
                if (w(T)) return;
                if (!((ae = w(N)) != null && ae.isValidNumber())) {
                  Vr.error(oC());
                  return
                }
                const _e = w(N).getNumber();
                await K(_e)
              }), H(st, nt)
            },
            Oe = st => {
              var nt = Gz(),
                qe = Ct(nt),
                Ue = E(qe),
                Je = E(Ue, !0);
              k(Ue);
              var Fe = Z(Ue, 2),
                it = E(Fe);
              k(Fe), k(qe);
              var tt = Z(qe, 2),
                $e = E(tt);
              {
                const Le = (lt, We) => {
                  let _t = () => We == null ? void 0 : We().cells;
                  var zt = Kt(),
                    Dt = Ct(zt);
                  vi(Dt, () => zz, (ot, dt) => {
                    dt(ot, {
                      class: "border-primary",
                      children: (vt, ft) => {
                        var Tt = Kt(),
                          xt = Ct(Tt);
                        ui(xt, 16, _t, pt => pt, (pt, At) => {
                          var Wt = Kt(),
                            Xt = Ct(Wt);
                          vi(Xt, () => Rz, (rr, er) => {
                            er(rr, {
                              get cell() {
                                return At
                              },
                              class: "border-base-content/20 size-11 sm:size-12"
                            })
                          }), H(pt, Wt)
                        }), H(vt, Tt)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  }), H(lt, zt)
                };
                vi($e, () => Bz, (lt, We) => {
                  We(lt, {
                    maxlength: 6,
                    class: "mx-auto w-max",
                    get disabled() {
                      return w(o)
                    },
                    get value() {
                      return w(B)
                    },
                    set value(_t) {
                      ce(B, _t, !0)
                    },
                    children: Le,
                    $$slots: {
                      default: !0
                    }
                  })
                })
              }
              k(tt);
              var Ae = Z(tt, 2),
                gt = E(Ae);
              gt.__click = [Zz, K, y];
              var Q = E(gt),
                re = Z(Q);
              {
                var _e = Le => {
                  var lt = Uz(),
                    We = E(lt);
                  k(lt), Ye(_t => ye(We, `(${_t??""})`), [() => ep(w(M))]), H(Le, lt)
                };
                je(re, Le => {
                  w(M) > 0 && Le(_e)
                })
              }
              k(gt);
              var ae = Z(gt, 2);
              ae.__click = [$z, y];
              var ke = E(ae, !0);
              k(ae), k(Ae), Ye((Le, lt, We, _t) => {
                ye(Je, Le), ye(it, `${lt??""} ${w(y)??""}`), gt.disabled = w(T), ye(Q, `${We??""} `), ye(ke, _t)
              }, [() => ZC(), () => GC(), () => XC(), () => JC()]), H(st, nt)
            };
          je(Re, st => {
            w(y) ? st(Oe, !1) : st(Ie)
          }, !0)
        }
        H(Ee, ze)
      };
    je(X, Ee => {
      w(m) ? Ee(me) : Ee(ge, !1)
    })
  }
  k(se), H(_, se), Fr()
}
ri(["click"]);
var Xz = Pe('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div></dialog>');

function Yz(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  var y = Xz(),
    M = E(y),
    z = Z(E(M), 2);
  {
    var T = o => {
      Wz(o, {
        onsuccess: () => m(!1)
      })
    };
    je(z, o => {
      m() && o(T)
    })
  }
  k(M), k(y), Yi(y, () => o => {
    Xr(() => {
      m() ? o.show() : o.close()
    })
  }), Ai("close", y, () => m(!1)), H(_, y), Fr()
}
var Kz = (_, s) => {
    s()
  },
  Jz = Pe('<span class="center-absolute loading loading-spinner absolute"></span>'),
  Qz = Pe('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  eL = (_, s, m) => {
    s(w(m).id)
  },
  tL = Pe('<span class="center-absolute loading loading-spinner absolute"></span>'),
  rL = Pe('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  nL = Pe('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  iL = (_, s) => {
    var m;
    (m = w(s)) == null || m.show()
  },
  aL = (_, s) => {
    s(!1)
  },
  sL = (_, s) => {
    var m;
    (m = w(s)) == null || m.close()
  },
  oL = async (_, s) => {
    try {
      ce(s, !0), await an.deleteMe(), Vr.warning(wC()), await Mt.logout()
    } catch (m) {
      Vr.error(m.message)
    } finally {
      ce(s, !1)
    }
  }, lL = Pe('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="flex w-full flex-col gap-3"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="mt-4 flex w-full items-center justify-between"><button type="button" class="btn btn-error btn-soft btn-sm w-max"> </button> <div class="flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <div class="mt-4 flex justify-end gap-2"><button class="btn btn-soft"> </button> <button class="btn btn-error"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function cL(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15),
    y = ut(yi(s.userData.name)),
    M = ut(yi(s.userData.discord)),
    z = ut(yi(s.userData.showLastPixel)),
    T = ut(!1),
    o = ut(void 0),
    B = ut(void 0);
  An(() => {
    const It = ur => {
      ur.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", It), () => document.removeEventListener("keydown", It)
  });
  let N = ut(void 0),
    W = ut(void 0);
  Xr(() => {
    ce(y, s.userData.name, !0), ce(z, s.userData.showLastPixel, !0)
  }), Xr(() => {
    m() && !w(B) && an.getMyProfilePictures().then(It => {
      ce(B, It, !0)
    }).catch(It => {
      Vr.error(It.message)
    })
  });
  let K = ut(!1);
  async function se(It) {
    try {
      ce(K, !0), await an.changeProfilePicture(It), await Mt.refresh()
    } finally {
      ce(K, !1)
    }
  }
  var X = lL(),
    me = Ct(X),
    ge = E(me),
    Ee = Z(E(ge), 2),
    ze = E(Ee, !0);
  k(Ee);
  var Re = Z(Ee, 2),
    Ie = E(Re),
    Oe = E(Ie),
    st = E(Oe),
    nt = E(st);
  ls(nt, {
    class: "size-30",
    get userId() {
      return s.userData.id
    },
    get pictureUrl() {
      return s.userData.picture
    }
  });
  var qe = Z(nt, 2),
    Ue = E(qe);
  zv(Ue, {
    class: "size-5"
  }), k(qe), k(st);
  var Je = Z(st, 2);
  {
    var Fe = It => {
      var ur = nL(),
        yr = E(ur),
        Mr = E(yr, !0);
      k(yr);
      var Gr = Z(yr, 2),
        xr = E(Gr);
      {
        var Sr = gr => {
          var Ar = Qz();
          Ar.__click = [Kz, se];
          var ue = E(Ar);
          ls(ue, {
            class: "size-10 border",
            get userId() {
              return s.userData.id
            }
          });
          var j = Z(ue, 2);
          {
            var U = Y => {
              var ie = Jz();
              H(Y, ie)
            };
            je(j, Y => {
              w(K) && Y(U)
            })
          }
          k(Ar), Ye(() => Ar.disabled = w(K)), H(gr, Ar)
        };
        je(xr, gr => {
          s.userData.picture && gr(Sr)
        })
      }
      var wr = Z(xr, 2);
      ui(wr, 17, () => w(B), gr => gr.id, (gr, Ar) => {
        var ue = Kt(),
          j = Ct(ue);
        {
          var U = Y => {
            var ie = rL();
            ie.__click = [eL, se, Ar];
            var he = E(ie);
            ls(he, {
              class: "size-10 border",
              get userId() {
                return s.userData.id
              },
              get pictureUrl() {
                return w(Ar).url
              }
            });
            var Te = Z(he, 2);
            {
              var Me = we => {
                var Ne = tL();
                H(we, Ne)
              };
              je(Te, we => {
                w(K) && we(Me)
              })
            }
            k(ie), Ye(() => ie.disabled = w(K)), H(Y, ie)
          };
          je(j, Y => {
            s.userData.picture !== w(Ar).url && Y(U)
          })
        }
        H(gr, ue)
      }), k(Gr), k(ur), Ye(gr => ye(Mr, gr), [() => W2()]), H(It, ur)
    };
    je(Je, It => {
      var ur;
      (ur = w(B)) != null && ur.length && It(Fe)
    })
  }
  k(Oe);
  var it = Z(Oe, 2),
    tt = E(it);
  {
    let It = ht(() => Hf()),
      ur = ht(() => Hf());
    Xf(tt, {
      get label() {
        return w(It)
      },
      get placeholder() {
        return w(ur)
      },
      min: 1,
      max: 16,
      get value() {
        return w(y)
      },
      set value(yr) {
        ce(y, yr, !0)
      },
      get validate() {
        return w(N)
      },
      set validate(yr) {
        ce(N, yr, !0)
      }
    })
  }
  var $e = Z(tt, 2);
  {
    let It = ht(() => J5());
    Xf($e, {
      label: "Discord",
      get placeholder() {
        return w(It)
      },
      max: 32,
      get value() {
        return w(M)
      },
      set value(ur) {
        ce(M, ur, !0)
      },
      get validate() {
        return w(W)
      },
      set validate(ur) {
        ce(W, ur, !0)
      }
    })
  }
  var Ae = Z($e, 2),
    gt = E(Ae);
  us(gt);
  var Q = Z(gt);
  k(Ae), k(it), k(Ie);
  var re = Z(Ie, 2),
    _e = E(re);
  _e.__click = [iL, o];
  var ae = E(_e, !0);
  k(_e);
  var ke = Z(_e, 2),
    Le = E(ke);
  Le.__click = [aL, m];
  var lt = E(Le, !0);
  k(Le);
  var We = Z(Le, 2),
    _t = E(We, !0);
  k(We), k(ke), k(re), k(Re), k(ge), k(me), Yi(me, () => It => {
    Xr(() => {
      m() ? It.show() : It.close()
    })
  });
  var zt = Z(me, 2),
    Dt = E(zt),
    ot = Z(E(Dt), 2),
    dt = E(ot, !0);
  k(ot);
  var vt = Z(ot, 2),
    ft = E(vt, !0);
  k(vt);
  var Tt = Z(vt, 2),
    xt = E(Tt);
  xt.__click = [sL, o];
  var pt = E(xt, !0);
  k(xt);
  var At = Z(xt, 2);
  At.__click = [oL, T];
  var Wt = E(At, !0);
  k(At), k(Tt), k(Dt);
  var Xt = Z(Dt, 2),
    rr = E(Xt),
    er = E(rr, !0);
  k(rr), k(Xt), k(zt), Xs(zt, It => ce(o, It), () => w(o)), Ye((It, ur, yr, Mr, Gr, xr, Sr, wr, gr, Ar, ue) => {
    ye(ze, It), kr(qe, "data-tip", ur), ye(Q, ` ${yr??""}`), ye(ae, Mr), Le.disabled = w(T), ye(lt, Gr), We.disabled = w(T), ye(_t, xr), ye(dt, Sr), ye(ft, wr), ye(pt, gr), At.disabled = w(T), ye(Wt, Ar), ye(er, ue)
  }, [() => tP(), () => C1(), () => K2(), () => Gg(), () => vc(), () => rw(), () => aw(), () => lw(), () => Tm(), () => Gg(), () => vc()]), Ai("close", me, () => m(!1)), Ai("submit", Re, async () => {
    var It, ur;
    try {
      if (!((It = w(N)) != null && It()) || !((ur = w(W)) != null && ur())) return;
      ce(T, !0), await an.updateMe({
        name: w(y),
        showLastPixel: w(z),
        discord: w(M)
      }), Mt.refresh(), Vr.success(yC()), m(!1)
    } catch (yr) {
      Vr.error(yr.message)
    } finally {
      ce(T, !1)
    }
  }), g1(gt, () => w(z), It => ce(z, It)), H(_, X), Fr()
}
ri(["click"]);
var uL = Lr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function hL(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = uL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var dL = Lr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function Z0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = dL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var pL = Lr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function fL(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = pL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var mL = Lr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function _L(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = mL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...m
  }), void 0, void 0, "svelte-1977t4s"), H(_, y)
}
var gL = Lr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function U0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = gL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var vL = Lr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function xv(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = vL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var yL = Lr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function xL(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = yL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var bL = Lr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function wL(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = bL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var TL = Lr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function SL(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = TL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var CL = (_, s) => {
    ce(s, !0)
  },
  PL = Pe('<span class="tooltip font-flag ml-0.5"> </span>'),
  IL = Pe('<div class="mt-1"><!></div>'),
  ML = Pe('<p class="w-full text-black"> </p>'),
  AL = Pe('<p class="w-full text-black"><!></p>'),
  kL = Pe('<div class=" flex items-center gap-[8px]"><!> <!></div>'),
  EL = (_, s, m) => {
    localStorage.setItem(f1, w(s).key), ce(m, w(s).key, !0), location.reload()
  },
  zL = Pe('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  LL = Pe("<li><button><!> </button></li>"),
  DL = async (_, s) => {
    var m;
    try {
      const y = await ((m = w(s)) == null ? void 0 : m.prompt());
      (y == null ? void 0 : y.outcome) === "accepted" && ce(s, void 0)
    } catch (y) {
      Vr.error(L2({
        error: y.message
      }))
    }
  }, RL = Pe('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'), BL = Pe('<a class="btn w-full" target="_blank"><!> </a>'), FL = Pe('<a class="btn w-full" target="_blank"><!> </a>'), OL = Pe('<form class="w-full" method="POST"><button class="btn w-full"><!> Purchases</button></form>'), NL = async (_, s, m, y) => {
    var M;
    try {
      ce(s, !0), await m.user.logout(), y(), Vr.warning(CC(), {
        icon: Z0
      }), (M = m.onlogout) == null || M.call(m)
    } catch {
      Vr.error(MC())
    } finally {
      ce(s, !1)
    }
  }, jL = Pe('<div class="dropdown"><div tabindex="0" role="button"><!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 relative right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="0"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div></div></div>  <!> <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function VL(_, s) {
  Br(s, !0);
  let m = ut(!1),
    y = ut(!1);

  function M() {
    var se;
    (se = document.activeElement) == null || se.blur()
  }
  const z = [{
    label: "🇺🇸 English",
    key: "en"
  }, {
    label: "🇧🇷 Português",
    key: "pt"
  }];
  let T = ut(""),
    o = ut(void 0);
  const B = ht(() => {
    var se;
    return !!((se = s.user.data) != null && se.banned) || !!s.user.timeoutUntil
  });
  var N = Kt(),
    W = Ct(N);
  {
    var K = se => {
      var X = jL(),
        me = Ct(X),
        ge = E(me);
      let Ee;
      var ze = E(ge);
      Dv(ze, {
        get userId() {
          return s.user.data.id
        },
        get level() {
          return s.user.data.level
        },
        get pictureUrl() {
          return s.user.data.picture
        }
      }), k(ge);
      var Re = Z(ge, 2),
        Ie = E(Re);
      Ie.__click = M;
      var Oe = E(Ie);
      pl(Oe, {
        class: "size-5"
      }), k(Ie);
      var st = Z(Ie, 2),
        nt = E(st),
        qe = E(nt);
      ls(qe, {
        get userId() {
          return s.user.data.id
        },
        get pictureUrl() {
          return s.user.data.picture
        },
        get isSuspended() {
          return w(B)
        }
      });
      var Ue = Z(qe, 2);
      Ue.__click = [CL, m];
      var Je = E(Ue);
      Yf(Je, {
        class: "size-4"
      }), k(Ue), k(nt);
      var Fe = Z(nt, 2),
        it = E(Fe),
        tt = E(it),
        $e = E(tt, !0);
      k(tt);
      var Ae = Z(tt, 2),
        gt = E(Ae);
      k(Ae);
      var Q = Z(Ae, 2);
      {
        var re = tr => {
          const Ht = ht(() => Ts(s.user.data.equippedFlag));
          var Yt = PL(),
            ar = E(Yt, !0);
          k(Yt), Ye(() => {
            kr(Yt, "data-tip", w(Ht).name), ye(ar, w(Ht).flag)
          }), H(tr, Yt)
        };
        je(Q, tr => {
          s.user.data.equippedFlag && tr(re)
        })
      }
      var _e = Z(Q, 2);
      {
        var ae = tr => {
          var Ht = IL(),
            Yt = E(Ht);
          Ah(Yt, {
            get username() {
              return s.user.data.discord
            }
          }), k(Ht), H(tr, Ht)
        };
        je(_e, tr => {
          s.user.data.discord && tr(ae)
        })
      }
      k(it);
      var ke = Z(it, 2),
        Le = E(ke);
      kh(Le, {
        class: "inline size-4"
      });
      var lt = Z(Le, 2),
        We = E(lt),
        _t = Z(We),
        zt = E(_t, !0);
      k(_t), k(lt), k(ke);
      var Dt = Z(ke, 2),
        ot = E(Dt);
      hL(ot, {
        class: "inline size-4"
      });
      var dt = Z(ot, 2),
        vt = E(dt),
        ft = E(vt);
      k(vt);
      var Tt = Z(vt),
        xt = Z(Tt),
        pt = E(xt);
      gm(pt, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), k(xt), k(dt), k(Dt), k(Fe), k(st);
      var At = Z(st, 2),
        Wt = E(At);
      {
        var Xt = tr => {
          var Ht = kL(),
            Yt = E(Ht);
          U0(Yt, {
            class: "size-6 text-red-500"
          });
          var ar = Z(Yt, 2);
          {
            var qr = sn => {
                var Yr = ML(),
                  kn = E(Yr, !0);
                k(Yr), Ye(bt => ye(kn, bt), [() => Qx()]), H(sn, Yr)
              },
              yt = sn => {
                var Yr = Kt(),
                  kn = Ct(Yr);
                {
                  var bt = Xe => {
                    var Lt = AL(),
                      Vt = E(Lt);
                    Av(Vt, () => e1({
                      until: `<span class="text-secondary font-medium text-nowrap">${s.user.timeoutUntil.toLocaleString()}</span>`
                    })), k(Lt), H(Xe, Lt)
                  };
                  je(kn, Xe => {
                    s.user.timeoutUntil && Xe(bt)
                  }, !0)
                }
                H(sn, Yr)
              };
            je(ar, sn => {
              var Yr;
              (Yr = s.user.data) != null && Yr.banned ? sn(qr) : sn(yt, !1)
            })
          }
          k(Ht), H(tr, Ht)
        };
        je(Wt, tr => {
          w(B) && tr(Xt)
        })
      }
      var rr = Z(Wt, 2),
        er = E(rr),
        It = E(er, !0);
      k(er);
      var ur = Z(er, 2),
        yr = E(ur),
        Mr = E(yr),
        Gr = E(Mr);
      xL(Gr, {
        class: "size-4"
      }), k(Mr);
      var xr = Z(Mr, 2);
      ui(xr, 21, () => z, cp, (tr, Ht) => {
        const Yt = ht(() => w(T) === w(Ht).key);
        var ar = LL(),
          qr = E(ar);
        let yt;
        qr.__click = [EL, Ht, T];
        var sn = E(qr);
        {
          var Yr = bt => {
            var Xe = zL();
            H(bt, Xe)
          };
          je(sn, bt => {
            w(Yt) && bt(Yr)
          })
        }
        var kn = Z(sn);
        k(qr), k(ar), Ye(bt => {
          yt = zr(qr, 1, "font-flag relative font-medium", null, yt, bt), ye(kn, ` ${w(Ht).label??""}`)
        }, [() => ({
          "bg-base-200": w(Yt)
        })]), H(tr, ar)
      }), k(xr), k(yr);
      var Sr = Z(yr, 2),
        wr = E(Sr);
      wr.__click = () => {
        fa.muted = !fa.muted
      };
      var gr = E(wr);
      {
        var Ar = tr => {
            wL(tr, {
              class: "size-4"
            })
          },
          ue = tr => {
            SL(tr, {
              class: "size-4"
            })
          };
        je(gr, tr => {
          fa.muted ? tr(Ar) : tr(ue, !1)
        })
      }
      k(wr), k(Sr), k(ur), k(rr);
      var j = Z(rr, 2);
      {
        var U = tr => {
          var Ht = RL();
          Ht.__click = [DL, o];
          var Yt = E(Ht);
          kv(Yt, {
            class: "size-5"
          });
          var ar = Z(Yt);
          k(Ht), Ye(qr => ye(ar, ` ${qr??""}`), [() => B2()]), H(tr, Ht)
        };
        je(j, tr => {
          w(o) && tr(U)
        })
      }
      var Y = Z(j, 2);
      {
        var ie = tr => {
          var Ht = BL(),
            Yt = E(Ht);
          xv(Yt, {
            class: "size-5"
          });
          var ar = Z(Yt);
          k(Ht), Ye(qr => {
            kr(Ht, "href", `${wa.url.origin??""}/admin/dashboard`), ye(ar, ` ${qr??""}`)
          }, [() => HP()]), H(tr, Ht)
        };
        je(Y, tr => {
          var Ht;
          ((Ht = s.user.data) == null ? void 0 : Ht.role) === "admin" && tr(ie)
        })
      }
      var he = Z(Y, 2);
      {
        var Te = tr => {
          var Ht = FL(),
            Yt = E(Ht);
          xv(Yt, {
            class: "size-5"
          });
          var ar = Z(Yt);
          k(Ht), Ye(qr => {
            kr(Ht, "href", `${wa.url.origin??""}/moderation`), ye(ar, ` ${qr??""}`)
          }, [() => MP()]), H(tr, Ht)
        };
        je(he, tr => {
          var Ht;
          (Ht = s.user.data) != null && Ht.role && s.user.data.role !== "user" && tr(Te)
        })
      }
      var Me = Z(he, 2),
        we = E(Me);
      Fv(we, {
        class: "size-5"
      });
      var Ne = Z(we);
      k(Me);
      var ct = Z(Me, 2),
        Qe = E(ct);
      Om(Qe, {
        class: "size-5"
      }), _n(), k(ct);
      var kt = Z(ct, 2),
        xe = E(kt);
      _L(xe, {
        class: "size-5"
      }), _n(), k(kt);
      var Nt = Z(kt, 2);
      {
        var Jt = tr => {
          var Ht = OL(),
            Yt = E(Ht),
            ar = E(Yt);
          fL(ar, {
            class: "size-5"
          }), _n(), k(Yt), k(Ht), Ye(() => kr(Ht, "action", `${Jx}/payment/create-portal-session`)), H(tr, Ht)
        };
        je(Nt, tr => {
          var Ht;
          (Ht = s.user.data) != null && Ht.isCustomer && tr(Jt)
        })
      }
      var jt = Z(Nt, 2);
      jt.__click = [NL, y, s, M];
      var hr = E(jt);
      Z0(hr, {
        class: "size-5"
      });
      var $r = Z(hr);
      k(jt), k(At), k(Re), k(me);
      var en = Z(me, 2);
      cL(en, {
        get userData() {
          return s.user.data
        },
        get open() {
          return w(m)
        },
        set open(tr) {
          ce(m, tr, !0)
        }
      }), Ye((tr, Ht, Yt, ar, qr, yt, sn, Yr, kn, bt, Xe, Lt) => {
        Ee = zr(ge, 1, "btn size-12 p-0 shadow-md", null, Ee, tr), kr(ge, "title", Ht), kr(tt, "title", s.user.data.name), ye($e, s.user.data.name), zr(Ae, 1, Yt), ye(gt, `#${s.user.data.id??""}`), ye(We, `${ar??""}: `), ye(zt, qr), ye(ft, `Level ${yt??""}`), ye(Tt, ` (${sn??""}%) `), kr(xt, "data-tip", Yr), ye(It, kn), kr(Sr, "data-tip", bt), ye(Ne, ` ${Xe??""}`), jt.disabled = w(y), ye($r, ` ${Lt??""}`)
      }, [() => ({
        "bg-red-500": w(B)
      }), () => I2(), () => bo(Ri(s.user.data.id)), () => Cm(), () => s.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(s.user.data.level), () => Math.floor(s.user.data.level % 1 * 100), () => H5(), () => k2(), () => fa.muted ? FS() : DS(), () => N2(), () => q2()]), Ai("focus", ge, () => {
        ce(o, window.pwaInstallPrompt, !0)
      }), H(se, X)
    };
    je(W, se => {
      s.user.data && s.user.charges !== void 0 && se(K)
    })
  }
  H(_, N), Fr()
}
ri(["click"]);
var qL = Lr('<svg><path d="M100-240v-480l360 240-360 240Zm400 0v-480l360 240-360 240ZM180-480Zm400 0Zm-400 90 136-90-136-90v180Zm400 0 136-90-136-90v180Z"></path></svg>');

function ZL(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = qL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var UL = Lr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function $L(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = UL();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var GL = async (_, s, m, y, M, z) => {
  if (w(s)) {
    m.map.easeTo(w(s)), ce(s, void 0);
    return
  }
  ce(y, !0);
  try {
    os(m.map.getCenter(), m.map.getZoom());
    const T = new hl(w(M)),
      {
        tile: o,
        pixel: B
      } = await an.getRandomTile(m.season),
      N = o.x * w(M) + B.x,
      W = o.y * w(M) + B.y,
      [K, se] = T.pixelsToLatLon(N, W, w(z)),
      X = {
        lat: K,
        lng: se
      },
      me = w(z) + 2;
    ce(s, {
      zoom: me,
      center: X
    }, !0), m.map.flyTo(w(s)), cl.isEmpty() && cl.push({
      pos: m.map.getCenter(),
      zoom: m.map.getZoom()
    }), setTimeout(() => {
      ce(s, void 0)
    }, 2500), cl.push({
      pos: X,
      zoom: me
    })
  } catch (T) {
    Vr.error(T.message)
  } finally {
    ce(y, !1)
  }
}, HL = Pe('<button class="btn btn-square shadow-md"><!></button>');

function WL(_, s) {
  Br(s, !0);
  const m = ht(() => Xi.seasons[s.season].tileSize),
    y = ht(() => Xi.seasons[s.season].zoom);
  let M = ut(!1),
    z = ut(void 0);
  var T = HL();
  T.__click = [GL, z, s, M, m, y];
  var o = E(T);
  {
    var B = W => {
        $L(W, {
          class: "size-5"
        })
      },
      N = W => {
        ZL(W, {
          class: "size-5"
        })
      };
    je(o, W => {
      w(z) ? W(N, !1) : W(B)
    })
  }
  k(T), Ye(W => {
    kr(T, "title", W), T.disabled = w(M)
  }, [() => t2()]), H(_, T), Fr()
}
ri(["click"]);
var XL = Pe('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  YL = Pe('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  KL = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  JL = Pe("<span> </span>"),
  QL = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  eD = Pe('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  tD = Pe('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  rD = Pe('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  nD = Pe('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  iD = Pe('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function aD(_, s) {
  Br(s, !0);
  const m = [];
  let y = ut("today"),
    M = {
      players: {
        label: Gv(),
        icon: _p
      },
      alliances: {
        label: Hv(),
        icon: gp
      }
    },
    z = ut("players"),
    T = yi({
      players: {},
      alliances: {}
    });
  const o = ht(() => T[w(z)][w(y)]);
  Xr(() => {
    if (w(o)) return;
    const ge = w(y),
      Ee = w(z);
    Ee === "players" ? an.leaderboardRegionPlayers(s.regionId, ge).then(ze => {
      T[Ee][ge] = ze
    }).catch(ze => {
      Vr.error(ze.message)
    }) : Ee === "alliances" && an.leaderboardRegionAlliances(s.regionId, ge).then(ze => {
      T[Ee][ge] = ze
    }).catch(ze => {
      Vr.error(ze.message)
    })
  });
  var B = iD(),
    N = Ct(B);
  ui(N, 21, () => Object.entries(M), ([ge, {
    label: Ee,
    icon: ze
  }]) => ge, (ge, Ee) => {
    var ze = ht(() => Sv(w(Ee), 2));
    let Re = () => w(ze)[0],
      Ie = () => w(ze)[1].label,
      Oe = () => w(ze)[1].icon;
    const st = ht(Oe);
    var nt = XL(),
      qe = E(nt);
    us(qe);
    var Ue, Je = Z(qe, 2);
    vi(Je, () => w(st), (it, tt) => {
      tt(it, {
        get this() {
          return Oe()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Fe = Z(Je);
    k(nt), Ye(() => {
      kr(qe, "aria-label", Ie()), Ue !== (Ue = Re()) && (qe.value = (qe.__value = Re()) ?? ""), ye(Fe, ` ${Ie()??""}`)
    }), Im(m, [], qe, () => (Re(), w(z)), it => ce(z, it)), H(ge, nt)
  }), k(N);
  var W = Z(N, 2),
    K = E(W);
  Nm(K, {
    get value() {
      return w(y)
    },
    set value(ge) {
      ce(y, ge, !0)
    }
  }), k(W);
  var se = Z(W, 2);
  {
    var X = ge => {
        var Ee = YL(),
          ze = E(Ee),
          Re = Z(ze);
        {
          var Ie = st => {
              var nt = Mi();
              Ye(qe => ye(nt, qe), [() => mp().toLowerCase()]), H(st, nt)
            },
            Oe = st => {
              var nt = Kt(),
                qe = Ct(nt);
              {
                var Ue = Fe => {
                    var it = Mi();
                    Ye(tt => ye(it, tt), [() => zm()]), H(Fe, it)
                  },
                  Je = Fe => {
                    var it = Kt(),
                      tt = Ct(it);
                    {
                      var $e = Ae => {
                        var gt = Mi();
                        Ye(Q => ye(gt, Q), [() => Lm()]), H(Ae, gt)
                      };
                      je(tt, Ae => {
                        w(y) === "month" && Ae($e)
                      }, !0)
                    }
                    H(Fe, it)
                  };
                je(qe, Fe => {
                  w(y) === "week" ? Fe(Ue) : Fe(Je, !1)
                }, !0)
              }
              H(st, nt)
            };
          je(Re, st => {
            w(y) === "today" ? st(Ie) : st(Oe, !1)
          })
        }
        k(Ee), Ye(st => ye(ze, `${st??""} `), [() => Em()]), H(ge, Ee)
      },
      me = ge => {
        var Ee = Kt(),
          ze = Ct(Ee);
        {
          var Re = Oe => {
              var st = Kt(),
                nt = Ct(st);
              {
                var qe = Je => {
                    const Fe = ht(() => w(o));
                    var it = eD(),
                      tt = E(it),
                      $e = E(tt),
                      Ae = Z(E($e)),
                      gt = E(Ae, !0);
                    k(Ae);
                    var Q = Z(Ae),
                      re = E(Q),
                      _e = Z(re, 2, !0);
                    k(Q), k($e), k(tt);
                    var ae = Z(tt);
                    ui(ae, 31, () => w(Fe), ke => ke.id, (ke, Le, lt) => {
                      const We = ht(() => {
                        var xr;
                        return ((xr = Mt.data) == null ? void 0 : xr.id) === w(Le).id
                      });
                      var _t = QL();
                      let zt;
                      var Dt = E(_t),
                        ot = E(Dt, !0);
                      k(Dt);
                      var dt = Z(Dt),
                        vt = E(dt),
                        ft = E(vt);
                      ls(ft, {
                        class: "size-10 border",
                        get userId() {
                          return w(Le).id
                        },
                        get pictureUrl() {
                          return w(Le).picture
                        }
                      });
                      var Tt = Z(ft, 2),
                        xt = E(Tt),
                        pt = E(xt),
                        At = Z(pt),
                        Wt = E(At);
                      k(At), k(xt);
                      var Xt = Z(xt, 2);
                      {
                        var rr = xr => {
                          const Sr = ht(() => Ts(w(Le).equippedFlag));
                          var wr = KL(),
                            gr = E(wr, !0);
                          k(wr), Ye(() => {
                            kr(wr, "data-tip", w(Sr).name), ye(gr, w(Sr).flag)
                          }), H(xr, wr)
                        };
                        je(Xt, xr => {
                          "equippedFlag" in w(Le) && w(Le).equippedFlag && xr(rr)
                        })
                      }
                      var er = Z(Xt, 2);
                      {
                        var It = xr => {
                          Ah(xr, {
                            get username() {
                              return w(Le).discord
                            }
                          })
                        };
                        je(er, xr => {
                          w(Le).discord && xr(It)
                        })
                      }
                      var ur = Z(er, 2);
                      {
                        var yr = xr => {
                          var Sr = JL(),
                            wr = E(Sr, !0);
                          k(Sr), Ye((gr, Ar) => {
                            zr(Sr, 1, `badge badge-sm ml-0.5 border-0 ${gr??""} ${Ar??""}`), ye(wr, w(Le).allianceName)
                          }, [() => up(w(Le).allianceId), () => Ri(w(Le).allianceId)]), H(xr, Sr)
                        };
                        je(ur, xr => {
                          "allianceName" in w(Le) && w(Le).allianceName && xr(yr)
                        })
                      }
                      k(Tt), k(vt), k(dt);
                      var Mr = Z(dt),
                        Gr = E(Mr, !0);
                      k(Mr), k(_t), Ye((xr, Sr, wr) => {
                        zt = zr(_t, 1, "", null, zt, xr), ye(ot, w(lt) + 1), zr(xt, 1, `font-semibold max-sm:ml-2 ${Sr??""} flex gap-1`), ye(pt, `${w(Le).name??""} `), ye(Wt, `#${w(Le).id??""}`), ye(Gr, wr)
                      }, [() => ({
                        "bg-base-200": w(We)
                      }), () => Ri(w(Le).id), () => w(Le).pixelsPainted.toLocaleString("en-US")]), sl(_t, () => ol, () => ({
                        duration: 200
                      })), H(ke, _t)
                    }), k(ae), k(it), Ye((ke, Le, lt) => {
                      ye(gt, ke), ye(re, `${Le??""} `), ye(_e, lt)
                    }, [() => Dm(), () => _c(), () => gc().toLowerCase()]), H(Je, it)
                  },
                  Ue = Je => {
                    var Fe = Kt(),
                      it = Ct(Fe);
                    {
                      var tt = $e => {
                        var Ae = rD(),
                          gt = E(Ae),
                          Q = E(gt),
                          re = Z(E(Q)),
                          _e = E(re, !0);
                        k(re);
                        var ae = Z(re),
                          ke = E(ae),
                          Le = Z(ke, 2, !0);
                        k(ae), k(Q), k(gt);
                        var lt = Z(gt);
                        ui(lt, 31, () => w(o), We => We.id, (We, _t, zt) => {
                          const Dt = ht(() => {
                            var Xt;
                            return ((Xt = Mt.data) == null ? void 0 : Xt.allianceId) === w(_t).id
                          });
                          var ot = tD();
                          let dt;
                          var vt = E(ot),
                            ft = E(vt, !0);
                          k(vt);
                          var Tt = Z(vt),
                            xt = E(Tt),
                            pt = E(xt, !0);
                          k(xt), k(Tt);
                          var At = Z(Tt),
                            Wt = E(At, !0);
                          k(At), k(ot), Ye((Xt, rr, er) => {
                            dt = zr(ot, 1, "", null, dt, Xt), ye(ft, w(zt) + 1), zr(xt, 1, `font-semibold ${rr??""}`), ye(pt, w(_t).name), ye(Wt, er)
                          }, [() => ({
                            "bg-base-200": w(Dt)
                          }), () => Ri(w(_t).id), () => w(_t).pixelsPainted.toLocaleString("en-US")]), sl(ot, () => ol, () => ({
                            duration: 200
                          })), H(We, ot)
                        }), k(lt), k(Ae), Ye((We, _t, zt) => {
                          ye(_e, We), ye(ke, `${_t??""} `), ye(Le, zt)
                        }, [() => pp(), () => _c(), () => gc().toLowerCase()]), H($e, Ae)
                      };
                      je(it, $e => {
                        w(z) === "alliances" && $e(tt)
                      }, !0)
                    }
                    H(Je, Fe)
                  };
                je(nt, Je => {
                  w(z) === "players" ? Je(qe) : Je(Ue, !1)
                })
              }
              H(Oe, st)
            },
            Ie = Oe => {
              var st = nD();
              H(Oe, st)
            };
          je(ze, Oe => {
            w(o) ? Oe(Re) : Oe(Ie, !1)
          }, !0)
        }
        H(ge, Ee)
      };
    je(se, ge => {
      w(o) && w(o).length === 0 ? ge(X) : ge(me, !1)
    })
  }
  H(_, B), Fr()
}
var sD = Pe('<div class="mt-5"><!></div>'),
  oD = Pe('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function lD(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15);
  const y = ht(() => Ts(s.region.countryId));
  An(() => {
    const ge = Ee => {
      Ee.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", ge), () => document.removeEventListener("keydown", ge)
  });
  var M = oD(),
    z = E(M),
    T = Z(E(z), 2),
    o = E(T),
    B = E(o, !0);
  k(o);
  var N = Z(o, 2),
    W = E(N, !0);
  k(N);
  var K = Z(N, 2),
    se = E(K);
  k(K), k(T);
  var X = Z(T, 2);
  {
    var me = ge => {
      var Ee = sD(),
        ze = E(Ee);
      aD(ze, {
        get regionId() {
          return s.region.id
        }
      }), k(Ee), Ii(2, Ee, () => aa, () => ({
        duration: 300
      })), H(ge, Ee)
    };
    je(X, ge => {
      m() && ge(me)
    })
  }
  k(z), _n(2), k(M), Yi(M, () => ge => {
    Xr(() => {
      m() ? ge.show() : ge.close()
    })
  }), Ye(ge => {
    zr(T, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${ge??""}`), kr(o, "data-tip", w(y).name), ye(B, w(y).flag), ye(W, s.region.name), ye(se, `#${s.region.number??""}`)
  }, [() => Ri(s.region.cityId)]), Ai("close", M, () => m(!1)), H(_, M), Fr()
}
var cD = Lr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function uD(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = cD();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var hD = Lr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  dD = Lr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function pD(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = Kt(),
    M = Ct(y);
  {
    var z = o => {
        var B = hD();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      },
      T = o => {
        var B = dD();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      };
    je(M, o => {
      s.filled ? o(z) : o(T, !1)
    })
  }
  H(_, y)
}
var fD = (_, s, m, y, M) => {
    if (w(s) && w(m)) {
      const z = w(s) - w(m).clientHeight,
        T = w(s) / 2 - z / 2;
      y.map.flyTo({
        center: {
          lat: w(M).center[0],
          lng: w(M).center[1]
        },
        zoom: 17.5,
        offset: [0, -T]
      })
    }
  },
  mD = (_, s, m) => s.onclickregion(w(m)),
  _D = Pe('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'),
  gD = Pe('<div class="skeleton h-5 w-16"></div>'),
  vD = Pe('<div class="skeleton mt-1 h-5 w-32"></div>'),
  yD = Pe('<span class="font-flag tooltip ml-0.5"> </span>'),
  xD = (_, s) => {
    navigator.clipboard.writeText(w(s).allianceId.toString()), Vr.success(km())
  },
  bD = Pe("<button><!></button>"),
  wD = Pe("<span> </span> <!>", 1),
  TD = Pe('<span class="tooltip"><!></span>'),
  SD = Pe('<span class="tooltip"><!></span>'),
  CD = (_, s) => {
    s("report-user")
  },
  PD = Pe("<li><button><!> </button></li>"),
  ID = (_, s) => {
    s("timeout")
  },
  MD = Pe("<li><button><!> </button></li>"),
  AD = (_, s) => {
    s("ban")
  },
  kD = Pe("<li><button><!> </button></li>"),
  ED = async (_, s, m, y, M, z) => {
    ce(s, !0);
    try {
      await an.banAllianceUser(w(m).id), await y({
        ...w(M),
        season: z.season
      })
    } catch (T) {
      Vr.error(T.message)
    } finally {
      ce(s, !1)
    }
  }, zD = Pe('<li><button class="text-error font-medium"><!> </button></li>'), LD = Pe('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'), DD = Pe('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!></div> <!></div>'), RD = (_, s) => s.onclickpaint(s.latLon), BD = async (_, s, m, y) => {
    try {
      ce(s, !0), w(m) ? (await an.deleteFavoriteLocation(w(m).id), Vr.warning(uC())) : (await an.favoriteLocation(w(y).center), Vr.success(pC())), sa.smallPlop.play(), Mt.refresh()
    } catch (M) {
      Vr.error(M.message)
    } finally {
      ce(s, !1)
    }
  }, FD = Pe("<button><!> </button>"), OD = (_, s, m) => s.onclickshare(oI(wa.url, {
    pos: {
      lat: w(m).center[0],
      lng: w(m).center[1]
    },
    zoom: s.zoom
  })), ND = Pe('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><button class="btn btn-primary"><!> </button> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function jD(_, s) {
  Br(s, !0);
  let m = ut(void 0);
  const y = ht(() => new hl(s.tileSize));
  let M = ut(void 0),
    z = ut(void 0),
    T = ut(!1),
    o = ut(!1);
  const B = ht(() => {
      var ot, dt, vt;
      return !!((dt = (ot = w(m)) == null ? void 0 : ot.paintedBy) != null && dt.id) && ((vt = Mt.data) == null ? void 0 : vt.id) === w(m).paintedBy.id
    }),
    N = ht(() => {
      const [ot, dt] = s.latLon ?? [0, 0], vt = w(y).latLonToPixelBoundsLatLon(ot, dt, s.pixelArtZoom), ft = Bm(vt), {
        tile: Tt,
        pixel: xt
      } = w(y).latLonToTileAndPixel(ot, dt, s.pixelArtZoom), pt = w(y).latLonToRegionAndPixel(ot, dt, s.pixelArtZoom);
      return {
        bounds: vt,
        center: ft,
        tile: Tt,
        pixel: xt,
        regionPixel: pt.pixel
      }
    });
  Xr(() => {
    sa.plop.play(), s.crosshair.clearAndPlace(s.latLon)
  });
  let W = 0;
  const K = ({
    pixel: ot,
    tile: dt,
    season: vt
  }) => `s${vt}:p(${ot[0]},${ot[1]}):t(${dt[0]},${dt[1]})`;
  let se;
  Mc(() => [w(N), s.season], () => {
    const ot = {
        ...w(N),
        season: s.season
      },
      dt = K(ot);
    if (ce(m, s.pixelInfoCache.get(dt), !0), w(m) !== void 0) return;
    s.pixelInfoCache.size === 0 && (W = 0), W++, W > 6 ? (clearTimeout(se), se = setTimeout(async () => X(ot), 500)) : X(ot)
  });
  async function X(ot) {
    var ft;
    const dt = await an.getPixelInfo({
      ...ot,
      isModerator: Ou((ft = Mt.data) == null ? void 0 : ft.role, ["admin", "global_moderator", "moderator"])
    });
    if (dt.paintedBy !== void 0) {
      const Tt = K(ot);
      s.pixelInfoCache.set(Tt, dt)
    }
    const vt = K({
      ...w(N),
      season: s.season
    });
    return ce(m, s.pixelInfoCache.get(vt), !0), dt
  }

  function me() {
    s.crosshair.clear(), sa.smallPlop.play(), s.onclose()
  }
  An(() => {
    const ot = dt => {
      dt.key === "Escape" && me()
    };
    return document.addEventListener("keydown", ot), () => document.removeEventListener("keydown", ot)
  });
  const ge = ht(() => {
    var ft, Tt, xt, pt, At;
    const ot = [],
      dt = (Tt = (ft = Mt) == null ? void 0 : ft.data) == null ? void 0 : Tt.role;
    Ou(dt, ["admin"]) && !w(B) && ot.push("ban-user"), Ou(dt, ["admin", "global_moderator", "moderator"]) && !w(B) && ot.push("timeout-user"), w(B) || ot.push("report-user");
    const vt = (xt = w(m)) == null ? void 0 : xt.paintedBy;
    return (vt == null ? void 0 : vt.allianceId) === ((pt = Mt.data) == null ? void 0 : pt.allianceId) && ((At = Mt.data) == null ? void 0 : At.allianceRole) === "admin" && Mt.data.id !== (vt == null ? void 0 : vt.id) && !w(B) && ot.push("ban-alliance"), ot
  });

  function Ee(ot) {
    const dt = (async () => await e0(s.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    s.onclickmodaction(w(m), dt, s.latLon, ot)
  }
  var ze = ND(),
    Re = E(ze),
    Ie = E(Re),
    Oe = E(Ie);
  Oe.__click = [fD, M, z, s, N];
  var st = E(Oe);
  Sm(st, {
    class: "fill-primary size-5"
  }), k(Oe);
  var nt = Z(Oe, 2),
    qe = E(nt),
    Ue = E(qe);
  k(qe);
  var Je = Z(qe, 2);
  {
    var Fe = ot => {
        const dt = ht(() => w(m).region),
          vt = ht(() => Ts(w(dt).countryId));
        var ft = _D();
        ft.__click = [mD, s, dt];
        var Tt = E(ft),
          xt = E(Tt, !0);
        k(Tt);
        var pt = Z(Tt, 2),
          At = E(pt, !0);
        k(pt);
        var Wt = Z(pt, 2),
          Xt = E(Wt);
        k(Wt), k(ft), Ye(rr => {
          zr(ft, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${rr??""}`), kr(Tt, "data-tip", w(vt).name), ye(xt, w(vt).flag), ye(At, w(dt).name), ye(Xt, `#${w(dt).number??""}`)
        }, [() => Ri(w(dt).cityId)]), H(ot, ft)
      },
      it = ot => {
        var dt = gD();
        H(ot, dt)
      };
    je(Je, ot => {
      var dt;
      (dt = w(m)) != null && dt.region ? ot(Fe) : ot(it, !1)
    })
  }
  k(nt), k(Ie);
  var tt = Z(Ie, 2);
  tt.__click = me;
  var $e = E(tt);
  pl($e, {
    class: "size-4"
  }), k(tt), k(Re);
  var Ae = Z(Re, 2),
    gt = E(Ae);
  {
    var Q = ot => {
        var dt = vD();
        H(ot, dt)
      },
      re = ot => {
        var dt = Kt(),
          vt = Ct(dt);
        {
          var ft = xt => {
              var pt = Mi();
              Ye(At => ye(pt, At), [() => _S()]), H(xt, pt)
            },
            Tt = xt => {
              const pt = ht(() => w(m).paintedBy);
              var At = DD(),
                Wt = E(At),
                Xt = E(Wt);
              k(Wt);
              var rr = Z(Wt, 2),
                er = E(rr);
              ls(er, {
                class: "size-5 border-0",
                get userId() {
                  return w(pt).id
                },
                get pictureUrl() {
                  return w(pt).picture
                }
              }), k(rr);
              var It = Z(rr, 2),
                ur = E(It),
                yr = E(ur),
                Mr = E(yr, !0);
              k(yr);
              var Gr = Z(yr, 2),
                xr = E(Gr);
              k(Gr), k(ur);
              var Sr = Z(ur, 2);
              {
                var wr = Me => {
                  const we = ht(() => Ts(w(pt).equippedFlag));
                  var Ne = yD(),
                    ct = E(Ne, !0);
                  k(Ne), Ye(() => {
                    kr(Ne, "data-tip", w(we).name), ye(ct, w(we).flag)
                  }), H(Me, Ne)
                };
                je(Sr, Me => {
                  w(pt).equippedFlag && Me(wr)
                })
              }
              var gr = Z(Sr, 2);
              {
                var Ar = Me => {
                  Ah(Me, {
                    get username() {
                      return w(pt).discord
                    }
                  })
                };
                je(gr, Me => {
                  w(pt).discord && Me(Ar)
                })
              }
              var ue = Z(gr, 2);
              {
                var j = Me => {
                  var we = wD(),
                    Ne = Ct(we),
                    ct = E(Ne, !0);
                  k(Ne);
                  var Qe = Z(Ne, 2);
                  {
                    var kt = xe => {
                      var Nt = bD();
                      Nt.__click = [xD, pt];
                      var Jt = E(Nt);
                      Pm(Jt, {
                        class: "size-3"
                      }), k(Nt), Ye((jt, hr) => {
                        zr(Nt, 1, jt), kr(Nt, "title", hr)
                      }, [() => bo(Ri(w(pt).allianceId)), () => _1({
                        allianceId: w(pt).allianceId
                      })]), H(xe, Nt)
                    };
                    je(Qe, xe => {
                      var Nt, Jt, jt;
                      (((Nt = Mt.data) == null ? void 0 : Nt.role) === "admin" || ((Jt = Mt.data) == null ? void 0 : Jt.role) === "moderator" || ((jt = Mt.data) == null ? void 0 : jt.role) === "global_moderator") && xe(kt)
                    })
                  }
                  Ye((xe, Nt) => {
                    zr(Ne, 1, `badge badge-sm ml-0.5 border-0 ${xe??""} ${Nt??""}`), ye(ct, w(pt).allianceName)
                  }, [() => up(w(pt).allianceId), () => Ri(w(pt).allianceId)]), H(Me, we)
                };
                je(ue, Me => {
                  w(pt).allianceId && Me(j)
                })
              }
              var U = Z(ue, 2);
              {
                var Y = Me => {
                    var we = TD(),
                      Ne = E(we);
                    Zg(Ne, {
                      class: "text-error size-4"
                    }), k(we), Ye(ct => kr(we, "data-tip", ct), [() => $v()]), H(Me, we)
                  },
                  ie = Me => {
                    var we = Kt(),
                      Ne = Ct(we);
                    {
                      var ct = Qe => {
                        var kt = SD(),
                          xe = E(kt);
                        Gf(xe, {
                          class: "text-error size-4"
                        }), k(kt), Ye(Nt => kr(kt, "data-tip", Nt), [() => x1()]), H(Qe, kt)
                      };
                      je(Ne, Qe => {
                        w(m).paintedBy.timedOut && Qe(ct)
                      }, !0)
                    }
                    H(Me, we)
                  };
                je(U, Me => {
                  w(m).paintedBy.banned ? Me(Y) : Me(ie, !1)
                })
              }
              k(It);
              var he = Z(It, 2);
              {
                var Te = Me => {
                  var we = LD(),
                    Ne = E(we),
                    ct = E(Ne);
                  jm(ct, {
                    class: "size-4"
                  }), k(Ne);
                  var Qe = Z(Ne, 2);
                  ui(Qe, 21, () => w(ge), cp, (kt, xe) => {
                    var Nt = Kt(),
                      Jt = Ct(Nt);
                    {
                      var jt = $r => {
                          var en = PD(),
                            tr = E(en);
                          let Ht;
                          tr.__click = [CD, Ee];
                          var Yt = E(tr);
                          U0(Yt, {
                            class: "size-5"
                          });
                          var ar = Z(Yt);
                          k(tr), k(en), Ye((qr, yt) => {
                            Ht = zr(tr, 1, "text-error py-2 font-medium", null, Ht, qr), ye(ar, ` ${yt??""}`)
                          }, [() => ({
                            "cursor-not-allowed": w(B)
                          }), () => u1()]), H($r, en)
                        },
                        hr = $r => {
                          var en = Kt(),
                            tr = Ct(en);
                          {
                            var Ht = ar => {
                                var qr = MD(),
                                  yt = E(qr);
                                let sn;
                                yt.__click = [ID, Ee];
                                var Yr = E(yt);
                                Gf(Yr, {
                                  class: "size-5"
                                });
                                var kn = Z(Yr);
                                k(yt), k(qr), Ye((bt, Xe) => {
                                  sn = zr(yt, 1, "text-error font-medium", null, sn, bt), ye(kn, ` ${Xe??""}`)
                                }, [() => ({
                                  "cursor-not-allowed": w(B)
                                }), () => h1()]), H(ar, qr)
                              },
                              Yt = ar => {
                                var qr = Kt(),
                                  yt = Ct(qr);
                                {
                                  var sn = kn => {
                                      var bt = kD(),
                                        Xe = E(bt);
                                      let Lt;
                                      Xe.__click = [AD, Ee];
                                      var Vt = E(Xe);
                                      Zg(Vt, {
                                        class: "size-5"
                                      });
                                      var Cr = Z(Vt);
                                      k(Xe), k(bt), Ye((Zr, tn) => {
                                        Lt = zr(Xe, 1, "text-error font-medium", null, Lt, Zr), ye(Cr, ` ${tn??""}`)
                                      }, [() => ({
                                        "cursor-not-allowed": w(B)
                                      }), () => d1()]), H(kn, bt)
                                    },
                                    Yr = kn => {
                                      var bt = Kt(),
                                        Xe = Ct(bt);
                                      {
                                        var Lt = Vt => {
                                          var Cr = zD(),
                                            Zr = E(Cr);
                                          Zr.__click = [ED, o, pt, X, N, s];
                                          var tn = E(Zr);
                                          uD(tn, {
                                            class: "size-5"
                                          });
                                          var br = Z(tn);
                                          k(Zr), k(Cr), Ye(pn => ye(br, ` ${pn??""}`), [() => Uv()]), H(Vt, Cr)
                                        };
                                        je(Xe, Vt => {
                                          w(xe) === "ban-alliance" && Vt(Lt)
                                        }, !0)
                                      }
                                      H(kn, bt)
                                    };
                                  je(yt, kn => {
                                    w(xe) === "ban-user" ? kn(sn) : kn(Yr, !1)
                                  }, !0)
                                }
                                H(ar, qr)
                              };
                            je(tr, ar => {
                              w(xe) === "timeout-user" ? ar(Ht) : ar(Yt, !1)
                            }, !0)
                          }
                          H($r, en)
                        };
                      je(Jt, $r => {
                        w(xe) === "report-user" ? $r(jt) : $r(hr, !1)
                      })
                    }
                    H(kt, Nt)
                  }), k(Qe), k(we), H(Me, we)
                };
                je(he, Me => {
                  w(ge).length > 0 && Me(Te)
                })
              }
              k(At), Ye((Me, we) => {
                var Ne;
                ye(Xt, `${Me??""}:`), zr(ur, 1, `font-medium ${we??""} flex gap-1.5`), ye(Mr, ((Ne = Mt.data) == null ? void 0 : Ne.id) === w(pt).id ? Mt.data.name : w(pt).name), ye(xr, `#${w(pt).id??""}`)
              }, [() => yS(), () => Ri(w(pt).id)]), H(xt, At)
            };
          je(vt, xt => {
            w(m).paintedBy.id === 0 ? xt(ft) : xt(Tt, !1)
          }, !0)
        }
        H(ot, dt)
      };
    je(gt, ot => {
      w(m) === void 0 ? ot(Q) : ot(re, !1)
    })
  }
  k(Ae);
  var _e = Z(Ae, 2),
    ae = E(_e);
  ae.__click = [RD, s];
  var ke = E(ae);
  kh(ke, {
    class: "size-4.5"
  });
  var Le = Z(ke);
  k(ae);
  var lt = Z(ae, 2);
  {
    var We = ot => {
      const dt = ht(() => Mt.data.favoriteLocations.find(At => Math.abs(At.latitude - w(N).center[0]) < 5e-5 && Math.abs(At.longitude - w(N).center[1]) < 5e-5)),
        vt = ht(() => !w(dt) && Mt.data.favoriteLocations.length >= Mt.data.maxFavoriteLocations);
      var ft = FD();
      let Tt;
      ft.__click = [BD, T, dt, N];
      var xt = E(ft);
      {
        let At = ht(() => !!w(dt));
        pD(xt, {
          class: "size-4.5",
          get filled() {
            return w(At)
          }
        })
      }
      var pt = Z(xt);
      k(ft), Ye((At, Wt) => {
        Tt = zr(ft, 1, "btn btn-primary btn-soft", null, Tt, At), ft.disabled = w(T) || w(vt), ye(pt, ` ${Wt??""}`)
      }, [() => ({
        "text-yellow-400": !!w(dt)
      }), () => w(vt) ? wS() : CS()]), H(ot, ft)
    };
    je(lt, ot => {
      Mt.data && ot(We)
    })
  }
  var _t = Z(lt, 2);
  _t.__click = [OD, s, N];
  var zt = E(_t);
  t0(zt, {
    class: "size-4.5"
  });
  var Dt = Z(zt);
  k(_t), k(_e), k(ze), Xs(ze, ot => ce(z, ot), () => w(z)), Ye((ot, dt) => {
    ye(Ue, `Pixel: ${w(N).regionPixel[0]??""}, ${w(N).regionPixel[1]??""}`), ae.disabled = Mt.loading, ye(Le, ` ${ot??""}`), ye(Dt, ` ${dt??""}`)
  }, [() => Vv(), () => MS()]), dp("innerHeight", ot => ce(M, ot, !0)), H(_, ze), Fr()
}
ri(["click"]);
var VD = Pe("<!> <!>", 1),
  qD = (_, s, m) => {
    s(w(m))
  },
  ZD = Pe('<div class="mt-3 flex justify-center"><span class="loading loading-spinner"></span></div>'),
  UD = Pe('<div class="mt-3 flex justify-center"><p class="text-base-content/80 text-sm">No one has painted in this area yet.</p></div>'),
  $D = (_, s) => {
    navigator.clipboard.writeText(w(s).map(m => m.id).join(", ")), Vr.success("Player IDs copied to clipboard")
  },
  GD = (_, s, m, y, M) => {
    s.crosshair.clear(), m(w(y).painted), ce(M, w(y).id, !0)
  },
  HD = Pe("<span> </span>"),
  WD = Pe('<tr><th> </th><td class="flex items-center gap-1"><!> <div class="ml-0.5 flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!></div></td><td class="text-center"> </td></tr>'),
  XD = Pe('<div class="max-h-[25vh] overflow-y-auto"><table class="table"><thead><tr><th></th><th>Player <button class="btn btn-xs btn-circle btn-ghost ml-0.5" title="Copy player IDs to clipboard"><!></button></th><th class="text-center">Pixels Painted</th></tr></thead><tbody></tbody></table></div>'),
  YD = Pe('<div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl"><div class="p-3"><div class="flex justify-between gap-1"><h2 class="flex items-center gap-1 pl-1 text-lg"><button class="btn btn-circle btn-soft size-7"><!></button> <span>Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm"> </span></h2> <button class="btn btn-circle btn-sm"><!></button></div> <div class="pb-3"><!></div></div></div>');

function KD(_, s) {
  Br(s, !0);
  let m = yi([]),
    y = ut(yi([])),
    M = ut(!1),
    z = ut(void 0);
  An(() => {
    const X = s.map.on("click", async me => {
      if (m.length >= 2) {
        s.onclose();
        return
      }
      if (m.push(me.lngLat), s.crosshair.place([me.lngLat.lat, me.lngLat.lng]), sa.plop.play(), m.length === 2) try {
        ce(M, !0), ce(y, await T(m[0], m[1]), !0), o(w(y))
      } finally {
        ce(M, !1)
      }
    });
    return () => {
      X.unsubscribe(), s.crosshair.clear()
    }
  });
  async function T(X, me) {
    const ge = new hl(s.tileSize),
      [Ee, ze] = ge.latLonToPixelsFloor(X.lat, X.lng, s.pixelArtZoom),
      [Re, Ie] = ge.latLonToPixelsFloor(me.lat, me.lng, s.pixelArtZoom),
      [Oe, st] = [Math.min(Ee, Re), Math.min(ze, Ie)],
      [nt, qe] = [Math.max(Ee, Re), Math.max(ze, Ie)],
      Ue = nt - Oe,
      Je = qe - st;
    if (Ue * Je > 1e6) return Vr.error("The selected area is too big. Please select an area smaller than 1,000,000 pixels."), [];
    const it = Math.floor(Oe / s.tileSize),
      tt = Math.floor(st / s.tileSize),
      $e = Math.floor(nt / s.tileSize),
      Ae = Math.floor(qe / s.tileSize),
      gt = $e - it + 1,
      Q = Ae - tt + 1,
      re = new Array(Q).fill(0).flatMap((We, _t) => new Array(gt).fill(0).map(async (zt, Dt) => {
        const ot = it + Dt,
          dt = tt + _t;
        let vt = 0,
          ft = 0,
          Tt = s.tileSize - 1,
          xt = s.tileSize - 1;
        dt === tt && (ft = st % s.tileSize), ot === it && (vt = Oe % s.tileSize), dt === Ae && (xt = qe % s.tileSize), ot === $e && (Tt = nt % s.tileSize);
        const rr = [ot, dt],
          er = [vt, ft],
          It = [Tt, xt];
        return {
          response: await an.getPixelAreaInfo({
            season: s.season,
            tile: rr,
            p0: er,
            p1: It
          }),
          tile: rr,
          p0: er,
          p1: It
        }
      })),
      _e = await Promise.all(re),
      ae = new Map;
    for (const {
        response: We,
        p0: _t,
        p1: zt,
        tile: Dt
      }
      of _e) {
      const [ot, dt] = Dt, [vt, ft] = _t, [Tt, xt] = zt, pt = Tt - vt + 1, At = xt - ft + 1;
      for (let Wt = 0; Wt < At; Wt++)
        for (let Xt = 0; Xt < pt; Xt++) {
          const rr = Wt * pt + Xt,
            er = We.paintedBy[rr];
          let It = ae.get(er);
          It || (It = {
            latitudes: [],
            longitudes: []
          }, ae.set(er, It));
          const [ur, yr] = ge.pixelsToLatLon(ot * s.tileSize + (vt + Xt + .5), dt * s.tileSize + (ft + Wt + .5), s.pixelArtZoom);
          It.latitudes.push(ur), It.longitudes.push(yr)
        }
    }
    const {
      users: ke
    } = await an.getMultipleUsersInfoById([...ae.keys()]), Le = t1(ke, We => We.id), lt = [...ae.entries()].map(([We, _t]) => ({
      ...Le[We] ?? {
        id: We,
        name: "Player"
      },
      painted: _t
    }));
    return lt.sort((We, _t) => _t.painted.latitudes.length - We.painted.latitudes.length), lt
  }

  function o(X) {
    for (const me of X) B(me.painted);
    ce(z, void 0)
  }

  function B(X) {
    for (let me = 0; me < X.latitudes.length; me++) s.crosshair.place([X.latitudes[me], X.longitudes[me]]);
    sa.plop.play()
  }
  var N = Kt(),
    W = Ct(N);
  {
    var K = X => {
        il(X, {
          class: "bg-warning",
          children: (me, ge) => {
            var Ee = VD(),
              ze = Ct(Ee);
            $u(ze, {
              class: "inline size-5"
            });
            var Re = Z(ze, 2);
            {
              var Ie = st => {
                  var nt = Mi();
                  Ye(qe => ye(nt, qe), [() => Wv()]), H(st, nt)
                },
                Oe = st => {
                  var nt = Kt(),
                    qe = Ct(nt);
                  {
                    var Ue = Je => {
                      var Fe = Mi();
                      Ye(it => ye(Fe, it), [() => Xv()]), H(Je, Fe)
                    };
                    je(qe, Je => {
                      m.length === 1 && Je(Ue)
                    }, !0)
                  }
                  H(st, nt)
                };
              je(Re, st => {
                m.length === 0 ? st(Ie) : st(Oe, !1)
              })
            }
            H(me, Ee)
          },
          $$slots: {
            default: !0
          }
        })
      },
      se = X => {
        const me = ht(() => w(y).filter($e => $e.id !== 0));
        var ge = YD(),
          Ee = E(ge),
          ze = E(Ee),
          Re = E(ze),
          Ie = E(Re);
        Ie.__click = [qD, o, y];
        var Oe = E(Ie);
        $u(Oe, {
          class: "size-4"
        }), k(Ie);
        var st = Z(Ie, 4),
          nt = E(st);
        k(st), k(Re);
        var qe = Z(Re, 2);
        qe.__click = function(...$e) {
          var Ae;
          (Ae = s.onclose) == null || Ae.apply(this, $e)
        };
        var Ue = E(qe);
        pl(Ue, {
          class: "size-4"
        }), k(qe), k(ze);
        var Je = Z(ze, 2),
          Fe = E(Je);
        {
          var it = $e => {
              var Ae = ZD();
              H($e, Ae)
            },
            tt = $e => {
              var Ae = Kt(),
                gt = Ct(Ae);
              {
                var Q = _e => {
                    var ae = UD();
                    H(_e, ae)
                  },
                  re = _e => {
                    var ae = XD(),
                      ke = E(ae),
                      Le = E(ke),
                      lt = E(Le),
                      We = Z(E(lt)),
                      _t = Z(E(We));
                    _t.__click = [$D, me];
                    var zt = E(_t);
                    Pm(zt, {
                      class: "size-3"
                    }), k(_t), k(We), _n(), k(lt), k(Le);
                    var Dt = Z(Le);
                    ui(Dt, 23, () => w(me), ot => ot.id, (ot, dt, vt) => {
                      var ft = WD();
                      let Tt;
                      ft.__click = [GD, s, B, dt, z];
                      var xt = E(ft),
                        pt = E(xt, !0);
                      k(xt);
                      var At = Z(xt),
                        Wt = E(At);
                      ls(Wt, {
                        class: "size-5 border-0",
                        get userId() {
                          return w(dt).id
                        },
                        get pictureUrl() {
                          return w(dt).picture
                        }
                      });
                      var Xt = Z(Wt, 2),
                        rr = E(Xt),
                        er = E(rr),
                        It = E(er, !0);
                      k(er);
                      var ur = Z(er, 2),
                        yr = E(ur);
                      k(ur), k(rr);
                      var Mr = Z(rr, 2);
                      {
                        var Gr = wr => {
                          var gr = HD(),
                            Ar = E(gr, !0);
                          k(gr), Ye((ue, j) => {
                            zr(gr, 1, `badge badge-sm ml-0.5 border-0 ${ue??""} ${j??""}`), ye(Ar, w(dt).allianceName)
                          }, [() => up(w(dt).allianceId), () => Ri(w(dt).allianceId)]), H(wr, gr)
                        };
                        je(Mr, wr => {
                          w(dt).allianceId && wr(Gr)
                        })
                      }
                      k(Xt), k(At);
                      var xr = Z(At),
                        Sr = E(xr, !0);
                      k(xr), k(ft), Ye((wr, gr, Ar) => {
                        Tt = zr(ft, 1, "hover:bg-base-200 cursor-pointer", null, Tt, wr), ye(pt, w(vt) + 1), zr(rr, 1, `font-medium ${gr??""} flex gap-1.5`), ye(It, w(dt).name), ye(yr, `#${w(dt).id??""}`), ye(Sr, Ar)
                      }, [() => ({
                        "!bg-base-300": w(dt).id === w(z)
                      }), () => Ri(w(dt).id), () => w(dt).painted.latitudes.length.toLocaleString()]), H(ot, ft)
                    }), k(Dt), k(ke), k(ae), H(_e, ae)
                  };
                je(gt, _e => {
                  w(me).length === 0 ? _e(Q) : _e(re, !1)
                }, !0)
              }
              H($e, Ae)
            };
          je(Fe, $e => {
            w(M) ? $e(it) : $e(tt, !1)
          })
        }
        k(Je), k(Ee), k(ge), Ye($e => ye(nt, `(Pixels: ${$e??""})`), [() => w(y).reduce(($e, Ae) => $e + Ae.painted.latitudes.length, 0)]), Ii(3, ge, () => $d, () => ({
          duration: 100
        })), H(X, ge)
      };
    je(W, X => {
      m.length < 2 ? X(K) : X(se, !1)
    })
  }
  H(_, N), Fr()
}
ri(["click"]);

function JD(_) {
  var y;
  const s = document.createElement("div");
  (y = _.parentElement) == null || y.insertBefore(s, _.nextSibling);
  const m = new IntersectionObserver(M => {
    M[0].isIntersecting ? _.classList.remove("stuck") : _.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return m.observe(s), () => {
    s.remove(), m.disconnect()
  }
}
var QD = Lr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  eR = Lr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function tR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var y = Kt(),
    M = Ct(y);
  {
    var z = o => {
        var B = QD();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      },
      T = o => {
        var B = eR();
        or(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...m
        })), H(o, B)
      };
    je(M, o => {
      s.filled ? o(z) : o(T, !1)
    })
  }
  H(_, y)
}
var rR = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  nR = Pe('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'),
  iR = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'),
  aR = Pe('<!> <span class="text-sm"> </span>', 1),
  sR = Pe('<span class="text-sm"> </span>'),
  oR = Pe('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  lR = Pe('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <p class="mt-2 text-center text-xl font-bold"> </p> <!> <div><!></div></div>'),
  cR = (_, s) => {
    ce(s, !w(s))
  },
  uR = Pe('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function hR(_, s) {
  Br(s, !0);
  const m = (Ie, Oe = Ta) => {
      const st = ht(() => {
          var ae;
          return (((ae = Mt.data) == null ? void 0 : ae.droplets) ?? 0) >= T.price
        }),
        nt = ht(() => w(B) === Oe().id);
      var qe = lR(),
        Ue = E(qe),
        Je = E(Ue, !0);
      k(Ue);
      var Fe = Z(Ue, 2),
        it = E(Fe, !0);
      k(Fe);
      var tt = Z(Fe, 2);
      {
        var $e = ae => {
          Um(ae, {})
        };
        je(tt, ae => {
          Oe().id === w(N) && ae($e)
        })
      }
      var Ae = Z(tt, 2);
      let gt;
      var Q = E(Ae);
      {
        var re = ae => {
            var ke = nR();
            ke.__click = async () => {
              try {
                const zt = Oe().id;
                ce(B, zt, !0), await an.purchase({
                  id: z,
                  amount: 1,
                  variant: zt
                }), Mt.refresh(), sa.notification1.play();
                const Dt = M.find(ot => ot.id === zt);
                Dt && (Dt.owned = !0), ce(N, zt, !0)
              } catch (zt) {
                Vr.error(zt.message)
              } finally {
                ce(B, void 0)
              }
            };
            var Le = E(ke);
            {
              var lt = zt => {
                var Dt = rR();
                H(zt, Dt)
              };
              je(Le, zt => {
                w(nt) && zt(lt)
              })
            }
            var We = Z(Le, 2);
            hp(We, {
              class: "size-4"
            });
            var _t = Z(We);
            _n(), k(ke), Ye(zt => {
              ke.disabled = !w(st) || w(nt), ye(_t, ` ${zt??""} `)
            }, [() => T.price.toLocaleString("en-US")]), H(ae, ke)
          },
          _e = ae => {
            const ke = ht(() => {
              var ft;
              return ((ft = Mt.data) == null ? void 0 : ft.equippedFlag) === Oe().id
            });
            var Le = oR();
            let lt;
            Le.__click = async () => {
              try {
                ce(B, Oe().id, !0);
                const ft = w(ke) ? 0 : Oe().id;
                await an.equipFlag(ft), Mt.data && (Mt.data.equippedFlag = ft), Mt.refresh()
              } catch (ft) {
                Vr.error(ft.message)
              } finally {
                ce(B, void 0)
              }
            };
            var We = E(Le),
              _t = E(We, !0);
            k(We);
            var zt = Z(We, 2);
            {
              var Dt = ft => {
                var Tt = iR();
                H(ft, Tt)
              };
              je(zt, ft => {
                w(nt) && ft(Dt)
              })
            }
            var ot = Z(zt, 2);
            {
              var dt = ft => {
                  var Tt = aR(),
                    xt = Ct(Tt);
                  pl(xt, {
                    class: "size-4"
                  });
                  var pt = Z(xt, 2),
                    At = E(pt, !0);
                  k(pt), Ye(Wt => ye(At, Wt), [() => xw()]), H(ft, Tt)
                },
                vt = ft => {
                  var Tt = sR(),
                    xt = E(Tt, !0);
                  k(Tt), Ye(pt => ye(xt, pt), [() => Tw()]), H(ft, Tt)
                };
              je(ot, ft => {
                w(ke) ? ft(dt) : ft(vt, !1)
              })
            }
            k(Le), Ye((ft, Tt) => {
              lt = zr(Le, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, lt, ft), Le.disabled = w(nt), ye(_t, Tt)
            }, [() => ({
              "btn-warning": w(ke)
            }), () => gw()]), H(ae, Le)
          };
        je(Q, ae => {
          Oe().owned ? ae(_e, !1) : ae(re)
        })
      }
      k(Ae), k(qe), Ye((ae, ke) => {
        ye(Je, Oe().flag), ye(it, Oe().name), gt = zr(Ae, 1, "mt-3", null, gt, ae), kr(Ae, "data-tip", ke)
      }, [() => ({
        tooltip: !w(st)
      }), () => fp()]), H(Ie, qe)
    },
    y = Xi.countries.map(Ie => ({
      ...Ie,
      owned: Mt.flagsBitmap.get(Ie.id)
    }));
  y.sort((Ie, Oe) => Number(Oe.owned) - Number(Ie.owned));
  const M = yi(y),
    z = 110,
    T = Xi.products[z];
  let o = ut(!1),
    B = ut(void 0),
    N = ut(void 0);
  var W = uR(),
    K = E(W),
    se = E(K);
  tR(se, {
    class: "size-5.5",
    filled: !0
  }), _n(2), k(K);
  var X = Z(K, 2),
    me = E(X, !0);
  k(X);
  var ge = Z(X, 2);
  ui(ge, 23, () => M, Ie => Ie.id, (Ie, Oe, st) => {
    var nt = Kt(),
      qe = Ct(nt);
    {
      var Ue = Je => {
        m(Je, () => w(Oe))
      };
      je(qe, Je => {
        (w(st) < 8 || w(o)) && Je(Ue)
      })
    }
    H(Ie, nt)
  }), k(ge);
  var Ee = Z(ge, 2),
    ze = E(Ee);
  ze.__click = [cR, o];
  var Re = E(ze, !0);
  k(ze), k(Ee), k(W), Ye(Ie => {
    ye(me, Ie), ye(Re, w(o) ? "Show less" : "Show more")
  }, [() => fw()]), H(_, W), Fr()
}
ri(["click"]);
var dR = Pe('<p class="mt-1 text-center text-sm"> </p>'),
  pR = (_, s) => {
    Cv(s, -1)
  },
  fR = (_, s) => {
    Cv(s)
  },
  mR = (_, s, m) => {
    s(w(m))
  },
  _R = Pe('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  gR = async (_, s, m, y) => {
    try {
      ce(s, !0), await an.purchase({
        id: m.productId,
        amount: y()
      }), sa.notification1.play(), m.onpurchasecompleted(y())
    } catch (M) {
      Vr.error(M.message)
    } finally {
      ce(s, !1)
    }
  }, vR = Pe('<span class="loading loading-spinner center-absolute absolute"></span>'), yR = Pe('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function bv(_, s) {
  Br(s, !0);
  let m = Et(s, "amount", 15, 1);
  const y = ht(() => m() * s.unitPrice),
    M = ht(() => Math.floor(s.userDroplets / s.unitPrice));
  let z = ut(!1);
  Xr(() => {
    m() < 0 && m(0)
  });
  var T = yR(),
    o = E(T),
    B = E(o);
  ii(B, () => s.icon ?? Ta), k(o);
  var N = Z(o, 2),
    W = E(N, !0);
  k(N);
  var K = Z(N, 2);
  {
    var se = Fe => {
      var it = dR(),
        tt = E(it, !0);
      k(it), Ye(() => ye(tt, s.subtitle)), H(Fe, it)
    };
    je(K, Fe => {
      s.subtitle && Fe(se)
    })
  }
  var X = Z(K, 2),
    me = E(X);
  me.__click = [pR, m];
  var ge = Z(me, 2);
  us(ge);
  var Ee = Z(ge, 2);
  Ee.__click = [fR, m];
  var ze = Z(Ee, 2);
  {
    var Re = Fe => {
      var it = _R();
      it.__click = [mR, m, M], H(Fe, it)
    };
    je(ze, Fe => {
      m() < w(M) && Fe(Re)
    })
  }
  k(X);
  var Ie = Z(X, 2);
  let Oe;
  var st = E(Ie);
  st.__click = [gR, z, s, m];
  var nt = E(st);
  {
    var qe = Fe => {
      var it = vR();
      H(Fe, it)
    };
    je(nt, Fe => {
      w(z) && Fe(qe)
    })
  }
  var Ue = Z(nt, 2);
  hp(Ue, {
    class: "size-4"
  });
  var Je = Z(Ue);
  _n(), k(st), k(Ie), k(T), Ye((Fe, it, tt, $e) => {
    ye(W, Fe), Ee.disabled = m() >= w(M), kr(Ie, "data-tip", it), Oe = zr(Ie, 1, "", null, Oe, tt), st.disabled = s.userDroplets < w(y) || w(z) || !m(), ye(Je, ` ${$e??""} `)
  }, [() => s.title(m()), () => fp(), () => ({
    tooltip: s.userDroplets < w(y)
  }), () => w(y).toLocaleString("en-US")]), Mm(ge, m), H(_, T), Fr()
}
ri(["click"]);
var xR = Lr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function bR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = xR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var wR = Lr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function $0(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = wR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var TR = Lr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function SR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = TR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var CR = Lr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function PR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = CR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var IR = Pe('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">✕</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  MR = Pe('<span class="center-absolute absolute"><!></span>'),
  AR = Pe('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function kR(_, s) {
  Br(s, !0);
  let m = Et(s, "open", 15),
    y = ut(void 0),
    M = ut(yi({
      name: Hg(),
      prev: 1e3,
      new: 1e5
    }));
  An(() => {
    const Le = lt => {
      lt.key === "Escape" && m(!1)
    };
    return document.addEventListener("keydown", Le), () => document.removeEventListener("keydown", Le)
  });
  const z = {
      id: 70,
      product: Xi.products[70]
    },
    T = {
      id: 80,
      product: Xi.products[80]
    },
    o = {
      product: Xi.products[120]
    };
  var B = AR(),
    N = Ct(B),
    W = E(N),
    K = E(W);
  {
    var se = Le => {
      var lt = IR(),
        We = E(lt),
        _t = E(We),
        zt = E(_t);
      $0(zt, {
        class: "size-8"
      });
      var Dt = Z(zt, 2),
        ot = E(Dt, !0);
      k(Dt);
      var dt = Z(Dt, 2),
        vt = E(dt);
      {
        let Jt = ht(() => {
          var jt;
          return ((jt = Mt.data) == null ? void 0 : jt.droplets) ?? 0
        });
        Lv(vt, {
          get value() {
            return w(Jt)
          }
        })
      }
      k(dt), _n(2), k(_t), k(We), Yi(We, () => JD);
      var ft = Z(We, 2),
        Tt = E(ft),
        xt = E(Tt),
        pt = E(xt);
      bR(pt, {
        class: "size-5.5",
        filled: !0
      });
      var At = Z(pt, 2),
        Wt = E(At, !0);
      k(At), k(xt);
      var Xt = Z(xt, 2),
        rr = E(Xt, !0);
      k(Xt);
      var er = Z(Xt, 2),
        It = E(er);
      {
        const Jt = hr => {
          PR(hr, {
            class: "text-primary size-26"
          })
        };
        let jt = ht(() => _2());
        bv(It, {
          get productId() {
            return z.id
          },
          title: hr => p2({
            amount: z.product.items[0].amount * hr
          }),
          get subtitle() {
            return w(jt)
          },
          get unitPrice() {
            return z.product.price
          },
          get userDroplets() {
            return Mt.data.droplets
          },
          onpurchasecompleted: async hr => {
            var tr, Ht, Yt, ar, qr;
            const $r = (Ht = (tr = Mt.data) == null ? void 0 : tr.charges) == null ? void 0 : Ht.max;
            await Mt.refresh();
            const en = (ar = (Yt = Mt.data) == null ? void 0 : Yt.charges) == null ? void 0 : ar.max;
            $r !== void 0 && en !== void 0 && (ce(M, {
              name: Hg(),
              prev: $r,
              new: en
            }, !0), (qr = w(y)) == null || qr.show())
          },
          icon: Jt,
          $$slots: {
            icon: !0
          }
        })
      }
      var ur = Z(It, 2);
      {
        const Jt = hr => {
          j0(hr, {
            class: "text-primary my-3 size-20"
          })
        };
        let jt = ht(() => i2());
        bv(ur, {
          get productId() {
            return T.id
          },
          title: hr => s3({
            amount: T.product.items[0].amount * hr
          }),
          get subtitle() {
            return w(jt)
          },
          get unitPrice() {
            return T.product.price
          },
          get userDroplets() {
            return Mt.data.droplets
          },
          onpurchasecompleted: async hr => {
            var en, tr, Ht;
            const $r = (tr = (en = Mt.data) == null ? void 0 : en.charges) == null ? void 0 : tr.count;
            await Mt.refresh(), $r !== void 0 && (ce(M, {
              name: n3(),
              prev: Math.floor($r),
              new: Math.floor($r + T.product.items[0].amount * hr)
            }, !0), (Ht = w(y)) == null || Ht.show())
          },
          icon: Jt,
          $$slots: {
            icon: !0
          }
        })
      }
      k(er), k(Tt);
      var yr = Z(Tt, 2),
        Mr = E(yr),
        Gr = E(Mr);
      _p(Gr, {
        class: "size-5.5",
        filled: !0
      });
      var xr = Z(Gr, 2),
        Sr = E(xr, !0);
      k(xr), k(Mr);
      var wr = Z(Mr, 2),
        gr = E(wr),
        Ar = E(gr),
        ue = E(Ar),
        j = E(ue),
        U = E(j);
      Dv(U, {
        get userId() {
          return Mt.data.id
        },
        get level() {
          return Mt.data.level
        },
        get pictureUrl() {
          return Mt.data.picture
        }
      }), k(j), k(ue), k(Ar);
      var Y = Z(Ar, 2),
        ie = E(Y, !0);
      k(Y);
      var he = Z(Y, 2),
        Te = E(he, !0);
      k(he);
      var Me = Z(he, 2);
      let we;
      var Ne = E(Me),
        ct = E(Ne),
        Qe = E(ct);
      hp(Qe, {
        class: "size-4"
      });
      var kt = Z(Qe);
      _n(), k(ct), k(Ne), k(Me), k(gr), k(wr), k(yr);
      var xe = Z(yr, 2),
        Nt = E(xe);
      hR(Nt, {}), k(xe), k(ft), k(lt), Ye((Jt, jt, hr, $r, en, tr, Ht, Yt, ar) => {
        ye(ot, Jt), ye(Wt, jt), ye(rr, hr), ye(Sr, $r), ye(ie, en), ye(Te, tr), kr(Me, "data-tip", Ht), we = zr(Me, 1, "", null, we, Yt), ct.disabled = Mt.data.droplets < o.product.price, ye(kt, ` ${ar??""} `)
      }, [() => Ov(), () => o2(), () => u2(), () => hw(), () => y2(), () => w2(), () => fp(), () => ({
        tooltip: Mt.data.droplets < o.product.price
      }), () => o.product.price.toLocaleString("en-US")]), Ii(2, lt, () => aa), H(Le, lt)
    };
    je(K, Le => {
      Mt.data && m() && Le(se)
    })
  }
  k(W);
  var X = Z(W, 2),
    me = E(X),
    ge = E(me, !0);
  k(me), k(X), k(N), Yi(N, () => Le => {
    Xr(() => {
      m() ? Le.show() : Le.close()
    })
  });
  var Ee = Z(N, 2),
    ze = E(Ee),
    Re = E(ze),
    Ie = E(Re),
    Oe = E(Ie, !0);
  k(Ie);
  var st = Z(Ie, 2),
    nt = E(st),
    qe = E(nt),
    Ue = Z(qe),
    Je = E(Ue);
  k(Ue), k(nt);
  var Fe = Z(nt, 2),
    it = E(Fe);
  SR(it, {
    class: "size-5"
  }), k(Fe);
  var tt = Z(Fe, 2),
    $e = E(tt, !0);
  k(tt), k(st);
  var Ae = Z(st, 2),
    gt = E(Ae),
    Q = E(gt),
    re = Z(Q);
  ju(re, () => w(M).new, Le => {
    var lt = MR(),
      We = E(lt);
    Um(We, {}), k(lt), H(Le, lt)
  }), k(gt), k(Ae), k(Re), k(ze);
  var _e = Z(ze, 2),
    ae = E(_e),
    ke = E(ae, !0);
  k(ae), k(_e), k(Ee), Xs(Ee, Le => ce(y, Le), () => w(y)), Ye((Le, lt, We) => {
    ye(ge, Le), ye(Oe, w(M).name), ye(qe, `${w(M).prev??""} `), ye(Je, `(+${w(M).new-w(M).prev})`), ye($e, w(M).new), ye(Q, `${lt??""} `), ye(ke, We)
  }, [() => vc(), () => vc(), () => vc()]), Ai("close", N, () => m(!1)), H(_, B), Fr()
}
var ER = Lr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function zR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = ER();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var LR = Lr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function DR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = LR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var RR = Lr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function BR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = RR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var FR = Lr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function OR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = FR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var NR = Lr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function jR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = NR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var VR = Lr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function qR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = VR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}
var ZR = Lr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function UR(_, s) {
  let m = ir(s, ["$$slots", "$$events", "$$legacy"]);
  var y = ZR();
  or(y, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...m
  })), H(_, y)
}

function Zf(_) {
  const s = document.createElement("img");
  return s.src = _, new Promise((m, y) => {
    s.addEventListener("load", () => {
      m(s)
    }), s.addEventListener("error", M => {
      y(M)
    })
  })
}

function $R(_) {
  const s = document.createElement("canvas");
  s.width = _.naturalWidth, s.height = _.naturalHeight;
  const m = s.getContext("2d");
  return m == null || m.drawImage(_, 0, 0), s
}

function GR(_, s, m) {
  return _ < s ? s : _ > m ? m : _
}

function HR(_, s) {
  const m = 10 ** s;
  return Math.round(_ * m) / m
}
var WR = Pe('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  XR = (_, s) => {
    ce(s, !w(s))
  },
  YR = Pe("<button><!></button>"),
  KR = async (_, s, m, y) => {
    var M;
    w(s) || ce(s, await new Promise((z, T) => {
      navigator.geolocation.getCurrentPosition(o => {
        z(o)
      }, o => {
        T(o)
      })
    })), w(s) && (os({
      lat: w(s).coords.latitude,
      lng: w(s).coords.longitude
    }, w(m)), (M = w(y)) == null || M.flyTo({
      center: {
        lat: w(s).coords.latitude,
        lng: w(s).coords.longitude
      },
      zoom: 16.5
    }))
  }, JR = Pe('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'), QR = Pe('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'), e7 = (_, s, m, y) => {
    var M;
    ce(s, !0), w(m) && os((M = w(m)) == null ? void 0 : M.getCenter(), w(y))
  }, t7 = Pe('<button class="btn btn-primary shadow-xl"> </button>'), r7 = Pe('<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"><!></a>'), n7 = Pe('<div class="relative"><!> <!></div>'), i7 = (_, s, m, y) => {
    var z;
    ce(s, !0);
    const M = (z = w(m)) == null ? void 0 : z.getCenter();
    M && os(M, w(y))
  }, a7 = Pe('<button class="btn btn-square shadow-md"><!></button>'), s7 = (_, s) => {
    ce(s, !0)
  }, o7 = Pe('<button class="btn btn-square relative shadow-md"><!></button>'), l7 = (_, s) => {
    ce(s, !0)
  }, c7 = Pe('<button class="btn btn-square relative shadow-md"><!></button>'), u7 = Pe('<div class="flex flex-col items-center gap-3"><!> <!> <!> <!></div>'), h7 = (_, s) => {
    ce(s, !w(s))
  }, d7 = Pe('<div class="flex flex-col gap-3"><button><!></button></div>'), p7 = Pe('<div class="z-100 absolute bottom-1 left-1/2 -translate-x-1/2"><!></div>'), f7 = (_, s) => {
    ce(s, !0)
  }, m7 = Pe('<button class="btn btn-sm btn-circle"><!></button>'), _7 = (_, s) => {
    var m;
    (m = w(s)) == null || m.zoomIn()
  }, g7 = (_, s) => {
    var m;
    (m = w(s)) == null || m.zoomOut()
  }, v7 = (_, s) => {
    ce(s, {
      name: "getPixelAreaInfo"
    }, !0)
  }, y7 = Pe('<button class="btn btn-sm btn-circle" title="Select area"><!></button>'), x7 = Pe('<button class="btn btn-sm btn-circle"><!></button>'), b7 = () => {
    window.location.replace(wa.url.origin)
  }, w7 = Pe('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'), T7 = (_, s) => {
    w(s) && cl.goToPrev(w(s))
  }, S7 = Pe('<button class="btn btn-sm btn-circle"><!></button>'), C7 = Pe('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'), P7 = (_, s, m) => {
    var y;
    (y = w(s)) == null || y.flyTo({
      center: w(s).getCenter(),
      zoom: m
    })
  }, I7 = Pe('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'), M7 = Pe("<span></span>"), A7 = Pe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'), k7 = Pe('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'), E7 = Pe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-xl"><!></div>'), z7 = (_, s) => {
    ce(s, {
      name: "mainMenu"
    }, !0)
  }, L7 = Pe('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'), D7 = Pe('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-6wmtgk"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <!> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <div class="max-sm:hidden"><a href="https://www.twitch.tv/directory/category/wplace" class="btn btn-sm btn-circle" target="_blank" title="Livestreams"><!></a></div> <!> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function vB(_, s) {
  Br(s, !0);
  const m = kf,
    y = r1,
    M = new hl(y),
    z = m - .4,
    T = sI(wa.url),
    o = T.season ?? qg,
    B = new Map;
  let N = ut(void 0),
    W = ut(14.5),
    K = ut(!1);
  const se = ht(() => {
    var wt;
    return ((wt = Mt.data) == null ? void 0 : wt.id) === 401
  });
  let X = ut(!1),
    me = ut(yi(T.select && T.pos ? {
      name: "pixelSelected",
      latLon: [T.pos.lat, T.pos.lng]
    } : {
      name: "mainMenu"
    }));
  An(() => {
    Ee().then(Dr => ce(N, Dr));
    let wt = [0, 0];

    function Gt(Dr) {
      var gn;
      if (w(N) && w(W) > m + 1) {
        const {
          lat: Fn,
          lng: Wn
        } = w(N).unproject([Dr.clientX, Dr.clientY]), Pn = M.latLonToPixels(Fn, Wn, m), Er = Math.floor(Pn[0]), Qi = Math.floor(Pn[1]);
        if (wt[0] !== Er || wt[1] !== Qi) {
          const nr = M.latLonToPixelBoundsLatLon(Fn, Wn, m),
            Ot = Rm(nr, !0);
          (gn = w(N).getSource(Ie)) == null || gn.setCoordinates(Ot), wt = [Er, Qi]
        }
      }
    }
    return window.addEventListener("mousemove", Gt), () => {
      var Dr;
      (Dr = w(N)) == null || Dr.remove(), window.removeEventListener("mousemove", Gt), ge && clearInterval(ge), Uf()
    }
  });
  let ge;
  async function Ee() {
    const wt = T.pos ? {
      ...T.pos,
      zoom: w(W)
    } : await YP();
    T.zoom !== void 0 && (wt.zoom = T.zoom);
    const Gt = await new Promise(Pn => {
      const Er = new jd.Map({
        style: "https://maps.wplace.live/styles/liberty",
        center: wt,
        zoom: wt.zoom,
        container: "map",
        dragRotate: !1,
        doubleClickZoom: !1,
        pitch: 0,
        maxPitch: 0,
        attributionControl: !1
      });
      Er.touchZoomRotate.disableRotation(), Er.on("style.load", () => {
        Er == null || Er.setLayoutProperty("poi_transit", "visibility", "none"), Er == null || Er.setLayoutProperty("poi_r20", "visibility", "none"), Er == null || Er.setLayoutProperty("poi_r7", "visibility", "none"), Er == null || Er.setLayoutProperty("poi_r1", "visibility", "none"), Er == null || Er.setLayoutProperty("building", "visibility", "none"), Er == null || Er.setLayoutProperty("building-3d", "visibility", "none"), Er == null || Er.setLayoutProperty("landuse_pitch", "visibility", "none"), Er == null || Er.setLayoutProperty("landuse_hospital", "visibility", "none"), Er == null || Er.setLayoutProperty("landuse_school", "visibility", "none"), Er == null || Er.setLayoutProperty("landuse_residential", "visibility", "none"), Er == null || Er.setLayoutProperty("waterway_tunnel", "visibility", "none"), Er == null || Er.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
          ["!=", "class", "swimming_pool"]
        ]), Pn(Er)
      })
    });
    Re(Gt), qe();
    const Dr = Xi.refreshIntervalMs;

    function gn() {
      let Pn = w(W) > m + 1.5 ? Dr : 2.5 * Dr;
      try {
        document.visibilityState === "visible" && Re(Gt)
      } finally {
        setTimeout(gn, Pn)
      }
    }
    ge = setTimeout(gn, Dr);
    let Fn = w(W);
    Gt.on("zoom", () => {
      ce(W, Gt.getZoom(), !0);
      const Pn = HR(w(W), 1);
      Pn != Fn && (w(Ae) && w(Ae).setOpacity(gt(Fn)), Fn = Pn)
    });
    let Wn = "default";
    return Gt.on("dragstart", () => {
      const Pn = Gt.getCanvas();
      Wn = Pn.style.cursor, Pn.style.cursor = "move"
    }), Gt.on("dragend", () => {
      Gt.getCanvas().style.cursor = Wn
    }), Gt.on("mouseout", () => {
      Ue()
    }), Gt.on("click", async Pn => {
      var Wr;
      const Er = Pn.lngLat.lat,
        Qi = Pn.lngLat.lng,
        nr = [Er, Qi];
      if (w(me).name === "paintingPixel" || w(me).name === "getPixelAreaInfo") return;
      if (w(me).name === "selectHq") {
        w(me).hq = nr, (Wr = w(Q)) == null || Wr.clearAndPlace(nr);
        return
      }
      const Ot = Gt.getZoom();
      if (Ot < z) {
        Vr.info(EC());
        return
      }
      os({
        lat: Er,
        lng: Qi
      }, Ot), ce(me, {
        name: "pixelSelected",
        latLon: nr
      }, !0)
    }), Gt
  }
  const ze = "pixel-art-layer";

  function Re(wt) {
    const Gt = window.innerWidth,
      Dr = `${n1}/s${qg}/tiles/{x}/{y}.png`;
    if (B.clear(), !wt.style) return;
    wt.getSource(ze) ? wt.refreshTiles(ze) : wt.addSource(ze, {
      type: "raster",
      tiles: [Dr],
      minzoom: m,
      maxzoom: m,
      tileSize: Gt > 640 ? 550 : 400
    }), wt.getLayer(ze) || wt.addLayer({
      id: ze,
      type: "raster",
      source: ze,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": w(Fe)
      }
    })
  }
  const Ie = "pixel-hover",
    Oe = 1e-5,
    st = [
      [0, 0],
      [Oe, 0],
      [Oe, -Oe],
      [0, -Oe]
    ],
    nt = .4;
  async function qe() {
    var wt, Gt, Dr, gn;
    if (!((wt = w(N)) != null && wt.getSource(Ie))) {
      const Fn = $R(await Zf(WP));
      (Gt = w(N)) == null || Gt.addSource(Ie, {
        type: "canvas",
        canvas: Fn,
        coordinates: st
      })
    }(Dr = w(N)) != null && Dr.getLayer(Ie) || (gn = w(N)) == null || gn.addLayer({
      id: Ie,
      type: "raster",
      source: Ie,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": nt
      }
    })
  }

  function Ue() {
    var wt, Gt;
    (Gt = (wt = w(N)) == null ? void 0 : wt.getSource(Ie)) == null || Gt.setCoordinates(st)
  }
  let Je = ut(yi(T.opaque ?? !0)),
    Fe = ht(() => w(Je) ? 1 : .1);
  Xr(() => {
    var wt;
    (wt = w(N)) != null && wt.getLayer(ze) && w(N).setPaintProperty(ze, "raster-opacity", w(Fe))
  });
  let it = ut(void 0),
    tt = ut(void 0),
    $e = ut(void 0);
  An(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(wt => {
    wt.state === "granted" && ce($e, navigator.geolocation.watchPosition(Gt => {
      ce(it, Gt)
    }, Gt => {
      ce(tt, Gt)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    w($e) && navigator.geolocation.clearWatch(w($e))
  }));
  let Ae = ut(void 0);
  Mc(() => [w(it), w(N)], () => {
    var wt, Gt;
    if (w(it) && w(N)) {
      const Dr = {
          lat: w(it).coords.latitude,
          lng: w(it).coords.longitude
        },
        gn = gt(w(W));
      if (!w(Ae)) {
        const Fn = document.createElement("div");
        Fn.classList.add("maplibregl-user-location-dot"), Fn.classList.add("cursor-auto"), ce(Ae, new jd.Marker({
          element: Fn,
          opacity: gn
        }).setLngLat(Dr).addTo(w(N)))
      }(Gt = (wt = w(Ae)) == null ? void 0 : wt.setLngLat(Dr)) == null || Gt.setOpacity(gn)
    }
  });

  function gt(wt) {
    return wt < m ? "1.0" : GR((wt - m) * .2, .5, 1).toFixed(2)
  }
  let Q = ut(void 0);
  Xr(() => {
    var wt;
    w(N) && ((wt = ll(() => w(Q))) == null || wt.clear(), Zf(Wg).then(Gt => {
      ce(Q, new Yg({
        id: "select-crosshair",
        map: w(N),
        tileSize: y,
        zoom: m,
        img: Gt,
        markerFn: () => {
          const Dr = new jd.Marker({
            color: "#0069ff"
          });
          return Dr.addClassName("z-20"), Dr
        }
      }))
    }))
  });
  let re = ut(void 0);
  Xr(() => {
    var wt;
    w(N) && ((wt = ll(() => w(Q))) == null || wt.clear(), Zf(Wg).then(Gt => {
      ce(re, new Yg({
        id: "paint-crosshair",
        map: w(N),
        tileSize: y,
        zoom: m,
        img: Gt
      }))
    }))
  });
  let _e = ut(!1),
    ae = ut(!1),
    ke = ut(!1),
    Le = ut(!!T.newUser),
    lt = ut(!1),
    We = ut(!!T.alliance),
    _t = ut(!1);
  const zt = "void-message-2";
  let Dt = ut(!1);
  Xr(() => {
    const wt = localStorage.getItem(zt);
    Mt.data && !wt && (ce(Dt, !0), localStorage.setItem(zt, "true"))
  });
  let ot = ut(!1),
    dt = ut(yi(wa.url)),
    vt = ut(yi({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    ft = ut(!1);
  const Tt = "view-rules";
  let xt = !1;
  Xr(() => {
    Mt.data && (!xt && Mt.data.pixelsPainted > 1 && (localStorage.getItem(Tt) || (ce(ft, !0), localStorage.setItem(Tt, "true"))), xt = !0)
  });
  let pt = ut(!1);
  Xr(() => {
    var wt;
    ce(pt, !!((wt = Mt.data) != null && wt.needsPhoneVerification))
  });
  let At = ut([]),
    Wt = ht(() => w(W) < z ? "1.0" : w(W) < z + 2 ? "0.5" : "0.3");
  Xr(() => {
    var Gt;
    const wt = (Gt = Mt.data) == null ? void 0 : Gt.favoriteLocations;
    if (wt && w(N)) {
      for (const Dr of ll(() => w(At))) Dr.remove();
      ce(At, wt.map(Dr => {
        const gn = document.createElement("div");
        gn.classList.add("text-yellow-400"), gn.classList.add("cursor-pointer"), gn.classList.add("z-10"), gn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Fn = {
          lat: Dr.latitude,
          lng: Dr.longitude
        };
        return gn.addEventListener("click", Pn => {
          Pn.stopPropagation(), Xt([Dr.latitude, Dr.longitude])
        }), new jd.Marker({
          element: gn,
          opacity: w(Wt)
        }).setLngLat(Fn).addTo(w(N))
      }))
    }
  });

  function Xt(wt) {
    var Dr;
    const Gt = {
      lat: wt[0],
      lng: wt[1]
    };
    (Dr = w(N)) == null || Dr.flyTo({
      center: Gt,
      zoom: Math.max(w(W), 15)
    }), os(Gt, w(W)), ce(me, {
      name: "pixelSelected",
      latLon: [Gt.lat, Gt.lng]
    }, !0)
  }
  Xr(() => {
    if (w(me).name === "paintingPixel")
      for (const wt of w(At)) wt.addClassName("hidden");
    else
      for (const wt of w(At)) wt.removeClassName("hidden"), wt.setOpacity(w(Wt))
  });
  let rr = Number.MAX_VALUE;
  Xr(() => {
    if (Mt.charges !== void 0 && Mt.data) {
      const wt = Mt.data.charges.max,
        Gt = Mt.charges;
      rr < wt && Gt >= wt && sa.notification1.play(), rr = Mt.charges
    }
  });
  let er = ut(!1),
    It = Date.now();
  An(() => {
    const wt = aI(),
      Gt = () => {
        var gn;
        if (!document.hidden && Date.now() - It > 30 * mc.min) {
          if (wt) {
            const Wn = (gn = w(N)) == null ? void 0 : gn.getCenter();
            Wn && os(Wn, w(W)), window.location.replace(wa.url.origin)
          } else Mt.refresh();
          It = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", Gt), () => document.removeEventListener("visibilitychange", Gt)
  }), An(() => {
    function wt() {
      an.online = !0
    }
    window.addEventListener("online", wt);

    function Gt() {
      an.online = !1
    }
    return window.addEventListener("offline", Gt), () => {
      window.removeEventListener("online", wt), window.removeEventListener("offline", Gt)
    }
  }), Xr(() => {
    if (!an.online) {
      const wt = setInterval(() => {
        an.health().then(() => {
          an.online = !0, !Mt.data && !Mt.loading && Mt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(wt)
      }
    }
  }), An(() => {
    function wt(Gt) {
      Gt.data.type && w(N) && Re(w(N))
    }
    return navigator.serviceWorker.addEventListener("message", wt), () => {
      navigator.serviceWorker.removeEventListener("message", wt)
    }
  });
  let ur = ut(!1),
    yr = ut("report-user"),
    Mr = ut(void 0),
    Gr = ut(void 0),
    xr = ut(void 0),
    Sr = ut(0);
  var wr = D7();
  Kx(wt => {
    var Gt = WR();
    Yx.title = "Wplace - Paint the world", _n(6), H(wt, Gt)
  });
  var gr = Ct(wr);
  {
    const wt = nr => {
        var Ot = YR();
        Ot.__click = [XR, Je];
        var Wr = E(Ot);
        {
          let on = ht(() => !w(Je));
          V0(Wr, {
            class: "size-5",
            get filled() {
              return w(on)
            }
          })
        }
        k(Ot), Ye(on => {
          kr(Ot, "title", on), zr(Ot, 1, bo({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": w(Je),
            "btn-primary btn-soft": !w(Je)
          }))
        }, [() => jv()]), H(nr, Ot)
      },
      Gt = nr => {
        var Ot = QR();
        Ot.__click = [KR, it, W, N];
        var Wr = E(Ot);
        {
          var on = cr => {
              OR(cr, {
                class: "size-5.5 fill-blue-800"
              })
            },
            dn = cr => {
              var Tn = JR(),
                Un = E(Tn);
              BR(Un, {
                class: "size-5.5 fill-red-400"
              }), _n(2), k(Tn), H(cr, Tn)
            };
          je(Wr, cr => {
            w(it) ? cr(on) : cr(dn, !1)
          })
        }
        k(Ot), Ye(cr => kr(Ot, "title", cr), [() => yb()]), H(nr, Ot)
      };
    var Ar = Z(E(gr), 2);
    let Dr;
    var ue = E(Ar);
    let gn;
    var j = E(ue);
    {
      var U = nr => {
          var Ot = t7();
          Ot.__click = [e7, _e, N, W];
          var Wr = E(Ot, !0);
          k(Ot), Ye(on => ye(Wr, on), [() => O1()]), H(nr, Ot)
        },
        Y = nr => {
          var Ot = Kt(),
            Wr = Ct(Ot);
          {
            var on = dn => {
              var cr = n7(),
                Tn = E(cr);
              {
                var Un = fn => {
                  var sr = r7(),
                    nn = E(sr);
                  {
                    var Xn = yn => {
                        var mn = Mi("MOD");
                        H(yn, mn)
                      },
                      di = yn => {
                        var mn = Kt(),
                          On = Ct(mn);
                        {
                          var jn = oa => {
                              var Vn = Mi("GM");
                              H(oa, Vn)
                            },
                            Sn = oa => {
                              var Vn = Mi("ADMIN");
                              H(oa, Vn)
                            };
                          je(On, oa => {
                            var Vn;
                            ((Vn = Mt.data) == null ? void 0 : Vn.role) === "global_moderator" ? oa(jn): oa(Sn, !1)
                          }, !0)
                        }
                        H(yn, mn)
                      };
                    je(nn, yn => {
                      var mn;
                      ((mn = Mt.data) == null ? void 0 : mn.role) === "moderator" ? yn(Xn): yn(di, !1)
                    })
                  }
                  k(sr), Ye(() => kr(sr, "href", `${wa.url.origin??""}/moderation`)), H(fn, sr)
                };
                je(Tn, fn => {
                  var sr;
                  Ou((sr = Mt.data) == null ? void 0 : sr.role, ["admin", "moderator", "global_moderator"]) && fn(Un)
                })
              }
              var En = Z(Tn, 2);
              VL(En, {
                get user() {
                  return Mt
                },
                onlogout: () => {
                  ce(me, {
                    name: "mainMenu"
                  }, !0)
                },
                onclickleaderboard: () => {
                  ce(ke, !0)
                },
                onclickshop: () => {
                  var sr;
                  ce(ae, !0);
                  const fn = (sr = w(N)) == null ? void 0 : sr.getCenter();
                  fn && os(fn, w(W))
                }
              }), k(cr), Ii(3, cr, () => aa, () => ({
                duration: 150
              })), H(dn, cr)
            };
            je(Wr, dn => {
              Mt.data && w(N) && w(me).name !== "paintingPixel" && dn(on)
            }, !0)
          }
          H(nr, Ot)
        };
      je(j, nr => {
        !Mt.loading && !Mt.data ? nr(U) : nr(Y, !1)
      })
    }
    var ie = Z(j, 2);
    {
      var he = nr => {
          var Ot = u7(),
            Wr = E(Ot);
          {
            var on = En => {
              Ff(En, {
                key: "shop-profile-picture",
                children: (fn, sr) => {
                  var nn = a7();
                  nn.__click = [i7, ae, N, W];
                  var Xn = E(nn);
                  $0(Xn, {
                    class: "size-5"
                  }), k(nn), Ye(di => kr(nn, "title", di), [() => Ov()]), H(fn, nn)
                },
                $$slots: {
                  default: !0
                }
              })
            };
            je(Wr, En => {
              Mt.data && En(on)
            })
          }
          var dn = Z(Wr, 2);
          {
            var cr = En => {
              var fn = o7();
              fn.__click = [s7, We];
              var sr = E(fn);
              gp(sr, {
                class: "size-5"
              }), k(fn), Ye(nn => kr(fn, "title", nn), [() => pp()]), H(En, fn)
            };
            je(dn, En => {
              Mt.data && En(cr)
            })
          }
          var Tn = Z(dn, 2);
          WL(Tn, {
            get map() {
              return w(N)
            },
            get season() {
              return o
            }
          });
          var Un = Z(Tn, 2);
          Ff(Un, {
            key: "region-leaderboard",
            children: (En, fn) => {
              var sr = c7();
              sr.__click = [l7, ke];
              var nn = E(sr);
              w0(nn, {
                class: "size-5"
              }), k(sr), Ye(Xn => kr(sr, "title", Xn), [() => Am()]), H(En, sr)
            },
            $$slots: {
              default: !0
            }
          }), k(Ot), Ii(3, Ot, () => aa, () => ({
            duration: 150
          })), H(nr, Ot)
        },
        Te = nr => {
          var Ot = Kt(),
            Wr = Ct(Ot);
          {
            var on = dn => {
              var cr = d7(),
                Tn = E(cr);
              let Un;
              Tn.__click = [h7, K];
              var En = E(Tn);
              {
                var fn = nn => {
                    bm(nn, {
                      class: "size-5"
                    })
                  },
                  sr = nn => {
                    tp(nn, {
                      class: "size-5"
                    })
                  };
                je(En, nn => {
                  w(K) ? nn(fn) : nn(sr, !1)
                })
              }
              k(Tn), k(cr), Ye((nn, Xn) => {
                kr(Tn, "title", nn), Un = zr(Tn, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, Un, Xn)
              }, [() => w(K) ? H1() : Y1(), () => ({
                "btn-primary": w(K)
              })]), Ii(1, cr, () => aa, () => ({
                delay: 150,
                duration: 150
              })), H(dn, cr)
            };
            je(Wr, dn => {
              w(N) && w(me).name === "paintingPixel" && dn(on)
            }, !0)
          }
          H(nr, Ot)
        };
      je(ie, nr => {
        w(N) && w(me).name !== "paintingPixel" ? nr(he) : nr(Te, !1)
      })
    }
    k(ue), k(Ar);
    var Me = Z(Ar, 2);
    {
      var we = nr => {
        var Ot = p7(),
          Wr = E(Ot);
        {
          let on = ht(() => a1.trim());
          M1(Wr, {
            get siteKey() {
              return w(on)
            },
            refreshExpired: "auto",
            appearance: "interaction-only",
            callback: dn => {
              fa.captcha = {
                token: dn,
                time: Date.now()
              }
            }
          })
        }
        k(Ot), Ii(2, Ot, () => aa, () => ({
          duration: 300
        })), H(nr, Ot)
      };
      je(Me, nr => {
        i1 && (!fa.captcha || fa.now - fa.captcha.time > 180 * 1e3) && nr(we)
      })
    }
    var Ne = Z(Me, 2);
    let Fn;
    var ct = E(Ne);
    {
      var Qe = nr => {
        Ff(nr, {
          key: "info",
          children: (Ot, Wr) => {
            var on = m7();
            on.__click = [f7, lt];
            var dn = E(on);
            DR(dn, {
              class: "size-3.5"
            }), k(on), Ye(cr => kr(on, "title", cr), [() => Q1()]), H(Ot, on)
          },
          $$slots: {
            default: !0
          }
        })
      };
      je(ct, nr => {
        w(me).name !== "paintingPixel" && nr(Qe)
      })
    }
    var kt = Z(ct, 2),
      xe = E(kt);
    xe.__click = [_7, N];
    var Nt = Z(xe, 2);
    Nt.__click = [g7, N], k(kt);
    var Jt = Z(kt, 2),
      jt = E(Jt),
      hr = E(jt);
    Fv(hr, {
      class: "size-4"
    }), k(jt), k(Jt);
    var $r = Z(Jt, 2);
    {
      var en = nr => {
        var Ot = y7();
        Ot.__click = [v7, me];
        var Wr = E(Ot);
        $u(Wr, {
          class: "size-4"
        }), k(Ot), H(nr, Ot)
      };
      je($r, nr => {
        var Ot, Wr;
        w(me).name !== "paintingPixel" && (((Ot = Mt.data) == null ? void 0 : Ot.role) === "admin" || ((Wr = Mt.data) == null ? void 0 : Wr.role) === "global_moderator") && nr(en)
      })
    }
    var tr = Z($r, 2);
    {
      var Ht = nr => {
        var Ot = x7(),
          Wr = E(Ot);
        UR(Wr, {
          class: "size-4",
          onclick: () => {
            ce(X, !w(X))
          }
        }), k(Ot), Ye(on => kr(Ot, "title", on), [() => $2()]), H(nr, Ot)
      };
      je(tr, nr => {
        w(se) && nr(Ht)
      })
    }
    var Yt = Z(tr, 2);
    {
      var ar = nr => {
        var Ot = w7();
        Ot.__click = [b7];
        var Wr = E(Ot);
        k1(Wr, {
          class: "size-3"
        }), k(Ot), Ye(on => kr(Ot, "title", on), [() => z1()]), H(nr, Ot)
      };
      je(Yt, nr => {
        w(me).name !== "paintingPixel" && nr(ar)
      })
    }
    var qr = Z(Yt, 2);
    {
      var yt = nr => {
        var Ot = S7();
        Ot.__click = [T7, N];
        var Wr = E(Ot);
        qR(Wr, {
          class: "size-3"
        }), k(Ot), Ye((on, dn) => {
          kr(Ot, "title", on), Ot.disabled = dn
        }, [() => lb(), () => !cl.hasPrev()]), Ii(1, Ot, () => aa, () => ({
          delay: 1e3,
          duration: 300
        })), Ii(2, Ot, () => aa, () => ({
          duration: 300
        })), H(nr, Ot)
      };
      je(qr, nr => {
        cl.hasPrev() && w(me).name !== "paintingPixel" && nr(yt)
      })
    }
    k(Ne);
    var sn = Z(Ne, 2);
    let Wn;
    var Yr = E(sn);
    {
      var kn = nr => {
        var Ot = C7(),
          Wr = E(Ot);
        E1(Wr, {
          class: "size-5"
        });
        var on = Z(Wr);
        k(Ot), Ye(dn => ye(on, ` ${dn??""}`), [() => hb()]), Ii(1, Ot, () => aa, () => ({
          duration: 1e3
        })), Ii(2, Ot, () => aa), H(nr, Ot)
      };
      je(Yr, nr => {
        an.online || nr(kn)
      })
    }
    var bt = Z(Yr, 2);
    {
      var Xe = nr => {
        var Ot = I7();
        Ot.__click = [P7, N, m];
        var Wr = E(Ot);
        jR(Wr, {
          class: "size-5"
        });
        var on = Z(Wr);
        k(Ot), Ye(dn => ye(on, ` ${dn??""}`), [() => fb()]), Ii(3, Ot, () => aa, () => ({
          duration: 300
        })), H(nr, Ot)
      };
      je(bt, nr => {
        w(W) < z && nr(Xe)
      })
    }
    k(sn);
    var Lt = Z(sn, 2);
    let Pn;
    var Vt = E(Lt);
    wt(Vt), k(Lt);
    var Cr = Z(Lt, 2);
    let Er;
    var Zr = E(Cr);
    {
      var tn = nr => {
          S0(nr, {
            class: "z-30",
            onclick: () => {
              var Ot;
              (Ot = Mt.data) != null && Ot.needsPhoneVerification ? (ce(pt, !0), Vr.warning($g())) : Mt.charges !== void 0 && Mt.charges < 1 ? Vr.warning(mk, {
                icon: Gf
              }) : w(N) && Mt.data ? (sa.smallDropplet.play(), ce(me, {
                name: "paintingPixel"
              }, !0)) : (ce(_e, !0), w(N) && os(w(N).getCenter(), w(W)))
            },
            get disabled() {
              return Mt.loading
            },
            get loading() {
              return Mt.loading
            },
            get charges() {
              return Mt.charges
            }
          })
        },
        br = nr => {
          var Ot = M7();
          H(nr, Ot)
        };
      je(Zr, nr => {
        w(me).name === "mainMenu" ? nr(tn) : nr(br, !1)
      })
    }
    k(Cr);
    var pn = Z(Cr, 2);
    let Qi;
    var Cn = E(pn);
    Gt(Cn), k(pn);
    var Nn = Z(pn, 2);
    {
      var vn = nr => {
        var Ot = Kt(),
          Wr = Ct(Ot);
        {
          var on = cr => {
              var Tn = A7(),
                Un = E(Tn),
                En = E(Un);
              jD(En, {
                get latLon() {
                  return w(me).latLon
                },
                get map() {
                  return w(N)
                },
                get crosshair() {
                  return w(Q)
                },
                get pixelInfoCache() {
                  return B
                },
                get season() {
                  return o
                },
                get tileSize() {
                  return y
                },
                get pixelArtZoom() {
                  return m
                },
                get zoom() {
                  return w(W)
                },
                get opaquePixelArt() {
                  return w(Je)
                },
                onclose: () => ce(me, {
                  name: "mainMenu"
                }, !0),
                onclickshare: fn => {
                  ce(dt, fn, !0), ce(ot, !0)
                },
                onclickpaint: ([fn, sr]) => {
                  var Xn, di, yn;
                  if (!Mt.data) {
                    ce(_e, !0);
                    return
                  }
                  if ((Xn = Mt.data) != null && Xn.needsPhoneVerification) {
                    ce(pt, !0), Vr.warning($g());
                    return
                  }
                  if (Mt.charges !== void 0 && Mt.charges < 1) {
                    Vr.warning(wb());
                    return
                  }
                  const nn = Bm(M.latLonToPixelBoundsLatLon(fn, sr, m));
                  (di = w(N)) == null || di.flyTo({
                    center: {
                      lat: nn[0],
                      lon: nn[1]
                    }
                  }), ce(me, {
                    name: "paintingPixel",
                    clickedLatLon: [fn, sr]
                  }, !0), (yn = w(Q)) == null || yn.clear()
                },
                onclickregion: fn => {
                  ce(vt, fn, !0), ce(_t, !0)
                },
                onclickmodaction: (fn, sr, nn, Xn) => {
                  var yn, mn, On;
                  (yn = w(N)) == null || yn.setZoom(Math.max(w(W), m + 3.5));
                  const di = M.latLonToPixelBoundsLatLon(nn[0], nn[1], m);
                  (mn = w(N)) == null || mn.setCenter({
                    lat: di.min[0],
                    lng: (di.max[1] + di.min[1]) / 2
                  }), ce(Mr, sr, !0), ce(Gr, fn, !0), ce(xr, nn, !0), ce(Sr, ((On = w(N)) == null ? void 0 : On.getZoom()) ?? 0, !0), ce(yr, Xn, !0), ce(ur, !0)
                }
              }), k(Un), k(Tn), Ii(3, Un, () => $d, () => ({
                duration: 100
              })), H(cr, Tn)
            },
            dn = cr => {
              var Tn = Kt(),
                Un = Ct(Tn);
              {
                var En = sr => {
                    var nn = k7(),
                      Xn = E(nn),
                      di = E(Xn);
                    kz(di, {
                      get map() {
                        return w(N)
                      },
                      get clickedLatLon() {
                        return w(me).clickedLatLon
                      },
                      get tileSize() {
                        return y
                      },
                      get tileZoom() {
                        return m
                      },
                      get season() {
                        return o
                      },
                      get zoom() {
                        return w(W)
                      },
                      get crosshair() {
                        return w(re)
                      },
                      refreshPixelArt: () => w(N) && Re(w(N)),
                      hidePixelHover: Ue,
                      hoverLayerId: Ie,
                      onclose: () => {
                        ce(me, {
                          name: "mainMenu"
                        }, !0), Ue()
                      },
                      get screenLocked() {
                        return w(K)
                      },
                      set screenLocked(yn) {
                        ce(K, yn, !0)
                      },
                      get opaquePixelArt() {
                        return w(Je)
                      },
                      set opaquePixelArt(yn) {
                        ce(Je, yn, !0)
                      }
                    }), k(Xn), k(nn), Ii(3, Xn, () => $d, () => ({
                      duration: 100
                    })), H(sr, nn)
                  },
                  fn = sr => {
                    var nn = Kt(),
                      Xn = Ct(nn);
                    {
                      var di = mn => {
                          var On = E7(),
                            jn = E(On);
                          KD(jn, {
                            get map() {
                              return w(N)
                            },
                            get tileSize() {
                              return y
                            },
                            get pixelArtZoom() {
                              return kf
                            },
                            get season() {
                              return o
                            },
                            get crosshair() {
                              return w(re)
                            },
                            onclose: () => {
                              ce(me, {
                                name: "mainMenu"
                              }, !0), Ue()
                            }
                          }), k(On), H(mn, On)
                        },
                        yn = mn => {
                          var On = Kt(),
                            jn = Ct(On);
                          {
                            var Sn = oa => {
                              var Vn = L7(),
                                ki = E(Vn),
                                pi = E(ki),
                                In = E(pi),
                                Ca = E(In),
                                Rr = E(Ca);
                              q0(Rr, {
                                class: "inline size-4"
                              });
                              var Hr = Z(Rr);
                              k(Ca);
                              var la = Z(Ca, 2);
                              la.__click = [z7, me];
                              var cn = E(la);
                              pl(cn, {
                                class: "size-4"
                              }), k(la), k(In);
                              var Oi = Z(In, 2),
                                Ui = E(Oi);
                              Ui.__click = async () => {
                                var Ka;
                                if (w(me).name === "selectHq") {
                                  const Ps = w(me).hq;
                                  if (Ps) try {
                                    ce(er, !0), await an.updateAllianceHeadquarters(Ps[0], Ps[1]), (Ka = w(Q)) == null || Ka.clear(), ce(We, !0), ce(me, {
                                      name: "mainMenu"
                                    }, !0)
                                  } catch (ds) {
                                    Vr.error(ds.message)
                                  } finally {
                                    ce(er, !1)
                                  }
                                }
                              };
                              var ga = E(Ui);
                              zR(ga, {
                                class: "size-6"
                              }), k(Ui), k(Oi), k(pi), k(ki), k(Vn), Ye(Ka => {
                                ye(Hr, ` ${Ka??""}`), Ui.disabled = w(me).hq === void 0 || w(er)
                              }, [() => jS()]), Ii(3, ki, () => $d, () => ({
                                duration: 100
                              })), H(oa, Vn)
                            };
                            je(jn, oa => {
                              w(me).name === "selectHq" && oa(Sn)
                            }, !0)
                          }
                          H(mn, On)
                        };
                      je(Xn, mn => {
                        w(me).name === "getPixelAreaInfo" ? mn(di) : mn(yn, !1)
                      }, !0)
                    }
                    H(sr, nn)
                  };
                je(Un, sr => {
                  w(me).name === "paintingPixel" && w(re) ? sr(En) : sr(fn, !1)
                }, !0)
              }
              H(cr, Tn)
            };
          je(Wr, cr => {
            w(me).name === "pixelSelected" && w(Q) ? cr(on) : cr(dn, !1)
          })
        }
        H(nr, Ot)
      };
      je(Nn, nr => {
        w(N) && nr(vn)
      })
    }
    k(gr), Ye((nr, Ot, Wr, on, dn, cr, Tn, Un, En) => {
      Dr = zr(Ar, 1, "absolute right-2 top-2 z-30", null, Dr, nr), gn = zr(ue, 1, "flex flex-col gap-4", null, gn, Ot), Fn = zr(Ne, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Fn, Wr), kr(xe, "title", on), kr(Nt, "title", dn), Wn = zr(sn, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Wn, cr), Pn = zr(Lt, 1, "absolute bottom-3 left-3 z-30", null, Pn, Tn), Er = zr(Cr, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, Er, Un), Qi = zr(pn, 1, "absolute bottom-3 right-3 z-30", null, Qi, En)
    }, [() => ({
      hidden: w(X)
    }), () => ({
      "items-end": !Mt.data,
      "items-center": Mt.data
    }), () => ({
      hidden: w(X)
    }), () => rb(), () => ab(), () => ({
      hidden: w(X)
    }), () => ({
      hidden: w(X)
    }), () => ({
      hidden: w(X)
    }), () => ({
      hidden: w(X)
    })])
  }
  var Bn = Z(gr, 2);
  uk(Bn, {
    get open() {
      return w(_e)
    },
    set open(wt) {
      ce(_e, wt, !0)
    }
  });
  var lr = Z(Bn, 2);
  kR(lr, {
    get open() {
      return w(ae)
    },
    set open(wt) {
      ce(ae, wt, !0)
    }
  });
  var bn = Z(lr, 2);
  n4(bn, {
    get open() {
      return w(Le)
    },
    set open(wt) {
      ce(Le, wt, !0)
    }
  });
  var rn = Z(bn, 2);
  _4(rn, {
    get open() {
      return w(lt)
    },
    set open(wt) {
      ce(lt, wt, !0)
    }
  });
  var Qr = Z(rn, 2);
  e4(Qr, {
    get open() {
      return w(ft)
    },
    set open(wt) {
      ce(ft, wt, !0)
    }
  });
  var _a = Z(Qr, 2);
  ok(_a, {
    onvisitclick: wt => {
      var Gt;
      (Gt = w(N)) == null || Gt.flyTo({
        center: wt,
        zoom: kf + 1
      }), os(wt, w(W)), cl.push({
        pos: wt,
        zoom: w(W)
      }), ce(ke, !1)
    },
    get open() {
      return w(ke)
    },
    set open(wt) {
      ce(ke, wt, !0)
    }
  });
  var hi = Z(_a, 2);
  lD(hi, {
    get region() {
      return w(vt)
    },
    get open() {
      return w(_t)
    },
    set open(wt) {
      ce(_t, wt, !0)
    }
  });
  var Ki = Z(hi, 2);
  P1(Ki, {
    get open() {
      return fa.dropletsDialogOpen
    },
    set open(wt) {
      fa.dropletsDialogOpen = wt
    }
  });
  var Zn = Z(Ki, 2);
  {
    var ai = wt => {
      RM(wt, {
        onhqchange: () => {
          ce(me, {
            name: "selectHq"
          }, !0), ce(We, !1)
        },
        onhqclick: Gt => {
          var Dr;
          (Dr = w(N)) == null || Dr.flyTo({
            center: Gt,
            zoom: Math.max(w(W), 15)
          }), ce(me, {
            name: "pixelSelected",
            latLon: [Gt.lat, Gt.lng]
          }, !0), ce(We, !1)
        },
        onlastpixelclick: Gt => {
          var Dr;
          (Dr = w(N)) == null || Dr.flyTo({
            center: Gt,
            zoom: Math.max(w(W), 15)
          }), ce(me, {
            name: "pixelSelected",
            latLon: [Gt.lat, Gt.lng]
          }, !0), ce(We, !1)
        },
        get open() {
          return w(We)
        },
        set open(Gt) {
          ce(We, Gt, !0)
        }
      })
    };
    je(Zn, wt => {
      w(N) && wt(ai)
    })
  }
  var qi = Z(Zn, 2);
  Yz(qi, {
    get open() {
      return w(pt)
    },
    set open(wt) {
      ce(pt, wt, !0)
    }
  });
  var Zi = Z(qi, 2);
  {
    var Bi = wt => {
      HM(wt, {
        get url() {
          return w(dt)
        },
        get map() {
          return w(N)
        },
        hideHover: () => {
          var Gt, Dr;
          (Gt = w(N)) == null || Gt.setPaintProperty(Ie, "raster-opacity", 0), (Dr = w(Q)) == null || Dr.setCanvasOpacity(0)
        },
        showHover: () => {
          var Gt, Dr;
          (Gt = w(N)) == null || Gt.setPaintProperty(Ie, "raster-opacity", nt), (Dr = w(Q)) == null || Dr.setCanvasOpacity(1)
        },
        get open() {
          return w(ot)
        },
        set open(Gt) {
          ce(ot, Gt, !0)
        }
      })
    };
    je(Zi, wt => {
      w(N) && wt(Bi)
    })
  }
  var Fi = Z(Zi, 2);
  {
    var Ji = wt => {
      p1(wt, {
        get image() {
          return w(Mr)
        },
        get paintedBy() {
          return w(Gr).paintedBy
        },
        get latLon() {
          return w(xr)
        },
        get zoom() {
          return w(Sr)
        },
        get action() {
          return w(yr)
        },
        get open() {
          return w(ur)
        },
        set open(Gt) {
          ce(ur, Gt, !0)
        }
      })
    };
    je(Fi, wt => {
      w(Gr) && w(Mr) && w(xr) && wt(Ji)
    })
  }
  H(_, wr), Fr()
}
ri(["click"]);
export {
  vB as component
};