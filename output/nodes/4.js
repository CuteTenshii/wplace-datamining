var yx = Object.defineProperty;
var bx = Object.getPrototypeOf;
var xx = Reflect.get;
var iv = p => {
  throw TypeError(p)
};
var wx = (p, s, r) => s in p ? yx(p, s, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : p[s] = r;
var mn = (p, s, r) => wx(p, typeof s != "symbol" ? s + "" : s, r),
  Uf = (p, s, r) => s.has(p) || iv("Cannot " + r);
var ir = (p, s, r) => (Uf(p, s, "read from private field"), r ? r.call(p) : s.get(p)),
  wn = (p, s, r) => s.has(p) ? iv("Cannot add the same private member more than once") : s instanceof WeakSet ? s.add(p) : s.set(p, r),
  Ma = (p, s, r, x) => (Uf(p, s, "write to private field"), x ? x.call(p, r) : s.set(p, r), r),
  sn = (p, s, r) => (Uf(p, s, "access private method"), r);
var av = (p, s, r) => xx(bx(p), r, s);
import "../chunks/Dzr0zEgr.js";
import {
  o as Yi,
  a as kx,
  s as qi
} from "../chunks/DC4ZOUpm.js";
import {
  ai as Tx,
  bm as Sx,
  bB as Px,
  bo as Mx,
  bC as Ix,
  aX as Cx,
  bD as zx,
  e as Je,
  bE as ov,
  ag as Ax,
  j as g,
  i as H,
  a_ as Zu,
  o as Yr,
  b as q,
  p as nn,
  af as ra,
  bF as Zf,
  bG as Ex,
  f as he,
  T as In,
  bx as Os,
  a as Ct,
  d as M,
  r as S,
  s as D,
  n as bn,
  c as an,
  t as Re,
  w as Ca,
  h as Sr,
  bH as sv,
  x as Lx,
  bI as Dx,
  aR as Oi,
  g as yi,
  S as Yn,
  u as mt,
  A as cn,
  bz as _p,
  z as q_,
  aO as Rx,
  aN as lv,
  aP as jx,
  W as N_,
  bJ as fs,
  aY as Qa,
  bK as r0,
  q as Fx,
  $ as Bx
} from "../chunks/DcuED2r1.js";
import {
  s as te,
  c as n0
} from "../chunks/C7Pahv-Y.js";
import {
  i as Te
} from "../chunks/C11X_6e6.js";
import {
  h as Ox
} from "../chunks/XycMX2w1.js";
import {
  b as Dr,
  a as Vr,
  s as er,
  g as ds,
  r as Ki,
  e as V_,
  f as qx,
  d as Ji,
  i as np,
  c as qs,
  h as t_
} from "../chunks/DqnGd6Ri.js";
import {
  a as _l,
  t as fa
} from "../chunks/DH2LbrSa.js";
import {
  g as mp,
  b as Nx
} from "../chunks/DOSQpApy.js";
import {
  p as vi
} from "../chunks/B1K3FRYh.js";
import {
  g as za,
  P as Vx,
  b as i0
} from "../chunks/4McVxkKC.js";
import {
  S as xa,
  u as Dt,
  t as Zt,
  a as dn,
  r as Do,
  v as Ux,
  w as Zx,
  x as Gx,
  y as Wx,
  f as Hx,
  m as $x,
  c as Xx,
  z as Yx,
  C as cv,
  A as Yd,
  P as Kx
} from "../chunks/CPCzdhld.js";
import {
  A as xi,
  p as U_,
  c as r_,
  g as Gf,
  a as Jx
} from "../chunks/nysmXfr7.js";
import {
  P as Di
} from "../chunks/CHvykOrI.js";
import "../chunks/BXDawSpN.js";
import {
  e as si,
  i as Dc
} from "../chunks/-tVdmFD0.js";
import {
  a as gp,
  b as yl,
  c as Z_
} from "../chunks/CtWlXc7s.js";
import {
  b as ja
} from "../chunks/BHQvDtHR.js";
import {
  i as G_
} from "../chunks/Bre_U80e.js";
import {
  r as Er,
  p as nr,
  s as Rc,
  u as uv
} from "../chunks/CVvyswV1.js";
import {
  C as Ro,
  S as Qx,
  U as e1,
  a as t1,
  r as r1
} from "../chunks/p62F5KPu.js";
import {
  U as n1,
  A as a0,
  D as o0,
  a as Ip,
  I as n_,
  e as i1,
  r as a1,
  p as o1,
  c as s1,
  P as s0,
  b as l1
} from "../chunks/CzoBuF9c.js";
import {
  c as vp,
  b as l0,
  g as na,
  a as Cp
} from "../chunks/5GLaNxVv.js";
import {
  h as zp
} from "../chunks/BaKWY4hh.js";
import {
  L as c0
} from "../chunks/CH8Ks-Vu.js";
import {
  g as je,
  l as c1
} from "../chunks/BfjUzAZv.js";
import {
  c as jc
} from "../chunks/ZsL_LNjT.js";
import {
  d as u1,
  L as Ap,
  p as W_
} from "../chunks/CW0mYKdy.js";
import {
  h as i_,
  E as a_,
  i as Ep,
  D as H_,
  e as hv,
  W as h1,
  s as d1,
  g as p1,
  l as u0,
  d as f1,
  b as _1,
  f as m1,
  r as g1,
  t as v1,
  j as y1,
  k as b1,
  m as dv,
  a as x1,
  p as w1,
  R as k1,
  u as T1,
  n as pv
} from "../chunks/BhGKhVuK.js";
import {
  P as Ra,
  t as S1
} from "../chunks/TWSWk3e0.js";
import {
  l as P1,
  v as M1,
  a as h0,
  s as d0
} from "../chunks/CYP7Df5-.js";
import {
  p as $_,
  m as p0
} from "../chunks/DeO2fKGK.js";
import {
  f as ml
} from "../chunks/CBk00wcu.js";
import {
  k as Ec
} from "../chunks/f42cp2no.js";
import {
  A as f0,
  c as hs
} from "../chunks/D1jrQGm1.js";
import {
  b as X_
} from "../chunks/DmE2OuIN.js";
import {
  u as I1
} from "../chunks/gt3sxhJ4.js";
import {
  u as C1
} from "../chunks/CTPaizwk.js";
import {
  l as Y_
} from "../chunks/jxVN19sI.js";
import {
  f as Ja,
  s as ip
} from "../chunks/D2YwJdYD.js";
import {
  C as K_
} from "../chunks/CMf0fO_4.js";
import {
  L as _0
} from "../chunks/Bsk54aUv.js";
import {
  t as z1,
  r as m0,
  g as A1
} from "../chunks/CokcYi8e.js";
import {
  c as ba
} from "../chunks/CwK7l1iO.js";
import {
  a as g0
} from "../chunks/Ba6gzAR0.js";
import {
  L as E1
} from "../chunks/DqXq84H0.js";
import {
  b as L1
} from "../chunks/CeVZ5f5R.js";
import {
  c as v0
} from "../chunks/D7pxMfeu.js";
import {
  e as D1
} from "../chunks/16z3hqa2.js";
import {
  a as R1
} from "../chunks/CKh9odm7.js";
import {
  d as j1
} from "../chunks/BrTpsMfa.js";
import {
  R as y0
} from "../chunks/rCSjyEmg.js";
import {
  T as Yu,
  G as yp,
  c as F1
} from "../chunks/DxeUuXAQ.js";
import {
  t as b0
} from "../chunks/DhuthSNA.js";
import {
  C as B1
} from "../chunks/BRury-28.js";
import {
  R as O1
} from "../chunks/CCR3bgIh.js";
import {
  W as q1
} from "../chunks/yhZh2uUz.js";
import {
  r as N1
} from "../chunks/Dw4PouOZ.js";
(function() {
  try {
    var p = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    p.SENTRY_RELEASE = {
      id: "358b627090e665fa84c80454e90310d86dcaf84d"
    }
  } catch {}
})();
try {
  (function() {
    var p = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      s = new p.Error().stack;
    s && (p._sentryDebugIds = p._sentryDebugIds || {}, p._sentryDebugIds[s] = "a57df8d0-1e08-4618-a767-9d45459a1c39", p._sentryDebugIdIdentifier = "sentry-dbid-a57df8d0-1e08-4618-a767-9d45459a1c39")
  })()
} catch {}
const V1 = [];

function U1(p, s = !1, r = !1) {
  return ap(p, new Map, "", V1, null, r)
}

function ap(p, s, r, x, z = null, E = !1) {
  if (typeof p == "object" && p !== null) {
    var k = s.get(p);
    if (k !== void 0) return k;
    if (p instanceof Map) return new Map(p);
    if (p instanceof Set) return new Set(p);
    if (Tx(p)) {
      var l = Array(p.length);
      s.set(p, l), z !== null && s.set(z, l);
      for (var F = 0; F < p.length; F += 1) {
        var W = p[F];
        F in p && (l[F] = ap(W, s, r, x, null, E))
      }
      return l
    }
    if (Sx(p) === Px) {
      l = {}, s.set(p, l), z !== null && s.set(z, l);
      for (var ee in p) l[ee] = ap(p[ee], s, r, x, null, E);
      return l
    }
    if (p instanceof Date) return structuredClone(p);
    if (typeof p.toJSON == "function" && !E) return ap(p.toJSON(), s, r, x, p)
  }
  if (p instanceof EventTarget) return p;
  try {
    return structuredClone(p)
  } catch {
    return p
  }
}

function Z1() {
  return Symbol(Mx)
}

function Ch(p, s) {
  Ix(window, ["resize"], () => Cx(() => s(window[p])))
}

function G1(p) {
  return function(...s) {
    var r = s[0];
    return r.preventDefault(), p == null ? void 0 : p.apply(this, s)
  }
}
const W1 = zx;
var Eo, Lo, cs, Sp, ko, Gu, op;
const _m = class _m extends Map {
  constructor(r) {
    super();
    wn(this, ko);
    wn(this, Eo, new Map);
    wn(this, Lo, Je(0));
    wn(this, cs, Je(0));
    wn(this, Sp, ov || -1);
    if (r) {
      for (var [x, z] of r) super.set(x, z);
      ir(this, cs).v = super.size
    }
  }
  has(r) {
    var x = ir(this, Eo),
      z = x.get(r);
    if (z === void 0) {
      var E = super.get(r);
      if (E !== void 0) z = sn(this, ko, Gu).call(this, 0), x.set(r, z);
      else return g(ir(this, Lo)), !1
    }
    return g(z), !0
  }
  forEach(r, x) {
    sn(this, ko, op).call(this), super.forEach(r, x)
  }
  get(r) {
    var x = ir(this, Eo),
      z = x.get(r);
    if (z === void 0) {
      var E = super.get(r);
      if (E !== void 0) z = sn(this, ko, Gu).call(this, 0), x.set(r, z);
      else {
        g(ir(this, Lo));
        return
      }
    }
    return g(z), super.get(r)
  }
  set(r, x) {
    var $;
    var z = ir(this, Eo),
      E = z.get(r),
      k = super.get(r),
      l = super.set(r, x),
      F = ir(this, Lo);
    if (E === void 0) E = sn(this, ko, Gu).call(this, 0), z.set(r, E), H(ir(this, cs), super.size), Zu(F);
    else if (k !== x) {
      Zu(E);
      var W = F.reactions === null ? null : new Set(F.reactions),
        ee = W === null || !(($ = E.reactions) != null && $.every(se => W.has(se)));
      ee && Zu(F)
    }
    return l
  }
  delete(r) {
    var x = ir(this, Eo),
      z = x.get(r),
      E = super.delete(r);
    return z !== void 0 && (x.delete(r), H(ir(this, cs), super.size), H(z, -1), Zu(ir(this, Lo))), E
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var r = ir(this, Eo);
      H(ir(this, cs), 0);
      for (var x of r.values()) H(x, -1);
      Zu(ir(this, Lo)), r.clear()
    }
  }
  keys() {
    return g(ir(this, Lo)), super.keys()
  }
  values() {
    return sn(this, ko, op).call(this), super.values()
  }
  entries() {
    return sn(this, ko, op).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return g(ir(this, cs)), super.size
  }
};
Eo = new WeakMap, Lo = new WeakMap, cs = new WeakMap, Sp = new WeakMap, ko = new WeakSet, Gu = function(r) {
  return ov === ir(this, Sp) ? Je(r) : Ax(r)
}, op = function() {
  g(ir(this, Lo));
  var r = ir(this, Eo);
  if (ir(this, cs).v !== r.size) {
    for (var x of av(_m.prototype, this, "keys").call(this))
      if (!r.has(x)) {
        var z = sn(this, ko, Gu).call(this, 0);
        r.set(x, z)
      }
  }
  for ([, z] of ir(this, Eo)) g(z)
};
let bp = _m;
const H1 = () => "OR",
  $1 = () => "OU",
  X1 = () => "æˆ–",
  Y1 = () => "ODER",
  K1 = () => "O",
  J1 = () => "OU",
  Q1 = () => "O",
  e2 = () => "ã¾ãŸã¯",
  t2 = () => "LUB",
  r2 = () => "Ð˜Ð›Ð˜",
  n2 = () => "ÐÐ‘Ðž",
  i2 = () => "HOáº¶C",
  a2 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? H1() : r === "pt" ? $1() : r === "ch" ? X1() : r === "de" ? Y1() : r === "es" ? K1() : r === "fr" ? J1() : r === "it" ? Q1() : r === "jp" ? e2() : r === "pl" ? t2() : r === "ru" ? r2() : r === "uk" ? n2() : i2()
  },
  o2 = () => "SPACE",
  s2 = () => "ESPAÃ‡O",
  l2 = () => "ç©ºæ ¼é”®",
  c2 = () => "LEERTASTE",
  u2 = () => "ESPACIO",
  h2 = () => "ESPACE",
  d2 = () => "SPAZIO",
  p2 = () => "ã‚¹ãƒšãƒ¼ã‚¹",
  f2 = () => "SPACJA",
  _2 = () => "ÐŸÐ ÐžÐ‘Ð•Ð›",
  m2 = () => "ÐŸÐ ÐžÐ‘Ð†Ð›",
  g2 = () => "PHÃM CÃCH",
  v2 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? o2() : r === "pt" ? s2() : r === "ch" ? l2() : r === "de" ? c2() : r === "es" ? u2() : r === "fr" ? h2() : r === "it" ? d2() : r === "jp" ? p2() : r === "pl" ? f2() : r === "ru" ? _2() : r === "uk" ? m2() : g2()
  },
  y2 = () => "Account Enforcement Policy and Code of Conduct",
  b2 = () => "PolÃ­tica de AplicaÃ§Ã£o da Conta e CÃ³digo de Conduta",
  x2 = () => "è´¦å·æ‰§è¡Œæ”¿ç­–ä¸Žè¡Œä¸ºå®ˆåˆ™",
  w2 = () => "Richtlinie zur Kontodurchsetzung und Verhaltenskodex",
  k2 = () => "PolÃ­tica de Cumplimiento de Cuenta y CÃ³digo de Conducta",
  T2 = () => "Politique dâ€™application du compte et Code de conduite",
  S2 = () => "Norme di applicazione dell'account e Codice di condotta",
  P2 = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆåˆ¶è£ãƒãƒªã‚·ãƒ¼ã¨è¡Œå‹•è¦ç¯„",
  M2 = () => "Polityka egzekwowania zasad konta i kodeks postÄ™powania",
  I2 = () => "ÐŸÐ¾Ð»Ð¸Ñ‚Ð¸ÐºÐ° Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ ÑÐ°Ð½ÐºÑ†Ð¸Ð¹ Ðº Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°Ð¼ Ð¸ ÐšÐ¾Ð´ÐµÐºÑ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ",
  C2 = () => "ÐŸÐ¾Ð»Ñ–Ñ‚Ð¸ÐºÐ° Ð·Ð°ÑÑ‚Ð¾ÑÑƒÐ²Ð°Ð½Ð½Ñ ÑÐ°Ð½ÐºÑ†Ñ–Ð¹ Ð´Ð¾ Ð°ÐºÐ°ÑƒÐ½Ñ‚Ñ–Ð² Ñ‚Ð° ÐšÐ¾Ð´ÐµÐºÑ Ð¿Ð¾Ð²ÐµÐ´Ñ–Ð½ÐºÐ¸",
  z2 = () => "ChÃ­nh sÃ¡ch Xá»­ lÃ½ TÃ i khoáº£n vÃ  Quy táº¯c á»¨ng xá»­",
  A2 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? y2() : r === "pt" ? b2() : r === "ch" ? x2() : r === "de" ? w2() : r === "es" ? k2() : r === "fr" ? T2() : r === "it" ? S2() : r === "jp" ? P2() : r === "pl" ? M2() : r === "ru" ? I2() : r === "uk" ? C2() : z2()
  },
  E2 = () => "Account successfully deleted",
  L2 = () => "Conta deletada com sucesso",
  D2 = () => "è´¦å·å·²æˆåŠŸåˆ é™¤",
  R2 = () => "Konto erfolgreich gelÃ¶scht",
  j2 = () => "Cuenta eliminada correctamente",
  F2 = () => "Compte supprimÃ© avec succÃ¨s",
  B2 = () => "Account eliminato con successo",
  O2 = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚",
  q2 = () => "Konto zostaÅ‚o pomyÅ›lnie usuniÄ™te",
  N2 = () => "ÐÐºÐºÐ°ÑƒÐ½Ñ‚ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑƒÐ´Ð°Ð»Ñ‘Ð½",
  V2 = () => "ÐžÐ±Ð»Ñ–ÐºÐ¾Ð²Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ð¾",
  U2 = () => "ÄÃ£ xÃ³a tÃ i khoáº£n thÃ nh cÃ´ng",
  Z2 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? E2() : r === "pt" ? L2() : r === "ch" ? D2() : r === "de" ? R2() : r === "es" ? j2() : r === "fr" ? F2() : r === "it" ? B2() : r === "jp" ? O2() : r === "pl" ? q2() : r === "ru" ? N2() : r === "uk" ? V2() : U2()
  },
  G2 = () => "Add a new 16x16 profile picture",
  W2 = () => "Adicionar uma nova imagem de perfil 16x16",
  H2 = () => "æ·»åŠ æ–°çš„ 16x16 å¤´åƒ",
  $2 = () => "Neues 16x16-Profilbild hinzufÃ¼gen",
  X2 = () => "AÃ±adir una nueva imagen de perfil 16x16",
  Y2 = () => "Ajouter une nouvelle image de profil 16x16",
  K2 = () => "Aggiungi una nuova immagine del profilo 16x16",
  J2 = () => "æ–°ã—ã„16x16ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒã‚’è¿½åŠ ã™ã‚‹",
  Q2 = () => "Dodaj nowy awatar 16x16",
  ew = () => "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð¾Ð²Ð¾Ðµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ñ 16x16",
  tw = () => "Ð”Ð¾Ð´Ð°Ñ‚Ð¸ Ð½Ð¾Ð²Ðµ Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»ÑŽ 16x16",
  rw = () => "ThÃªm áº£nh Ä‘áº¡i diá»‡n má»›i 16x16",
  nw = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? G2() : r === "pt" ? W2() : r === "ch" ? H2() : r === "de" ? $2() : r === "es" ? X2() : r === "fr" ? Y2() : r === "it" ? K2() : r === "jp" ? J2() : r === "pl" ? Q2() : r === "ru" ? ew() : r === "uk" ? tw() : rw()
  },
  iw = () => "All time",
  aw = () => "Geral",
  ow = () => "å…¨éƒ¨æ—¶é—´",
  sw = () => "Gesamt",
  lw = () => "Todo el tiempo",
  cw = () => "Tout le temps",
  uw = () => "Tutto il tempo",
  hw = () => "å…¨æœŸé–“",
  dw = () => "CaÅ‚y czas",
  pw = () => "Ð—Ð° Ð²ÑÑ‘ Ð²Ñ€ÐµÐ¼Ñ",
  fw = () => "Ð—Ð° Ð²ÐµÑÑŒ Ñ‡Ð°Ñ",
  _w = () => "ToÃ n thá»i gian",
  mw = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? iw() : r === "pt" ? aw() : r === "ch" ? ow() : r === "de" ? sw() : r === "es" ? lw() : r === "fr" ? cw() : r === "it" ? uw() : r === "jp" ? hw() : r === "pl" ? dw() : r === "ru" ? pw() : r === "uk" ? fw() : _w()
  },
  gw = () => "Alliance Name",
  vw = () => "Nome da alianÃ§a",
  yw = () => "è”ç›Ÿåç§°",
  bw = () => "Allianznamen",
  xw = () => "Nombre de la alianza",
  ww = () => "Nom de lâ€™alliance",
  kw = () => "Nome dell'alleanza",
  Tw = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å",
  Sw = () => "Nazwa sojuszu",
  Pw = () => "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð°Ð»ÑŒÑÐ½ÑÐ°",
  Mw = () => "ÐÐ°Ð·Ð²Ð° Ð°Ð»ÑŒÑÐ½ÑÑƒ",
  Iw = () => "TÃªn liÃªn minh",
  Cw = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? gw() : r === "pt" ? vw() : r === "ch" ? yw() : r === "de" ? bw() : r === "es" ? xw() : r === "fr" ? ww() : r === "it" ? kw() : r === "jp" ? Tw() : r === "pl" ? Sw() : r === "ru" ? Pw() : r === "uk" ? Mw() : Iw()
  },
  zw = p => `+${p.amount} Max. Charges`,
  Aw = p => `+${p.amount} Tinta mÃ¡xima`,
  Ew = p => `+${p.amount} æœ€å¤§å……èƒ½ä¸Šé™`,
  Lw = p => `+${p.amount} maximale Ladungen`,
  Dw = p => `+${p.amount} cargas mÃ¡ximas`,
  Rw = p => `+${p.amount} charges max`,
  jw = p => `+${p.amount} cariche massime`,
  Fw = p => `æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸ +${p.amount}`,
  Bw = p => `+${p.amount} maks. Å‚adunkÃ³w`,
  Ow = p => `+${p.amount} Ð¼Ð°ÐºÑ. Ð·Ð°Ñ€ÑÐ´Ð¾Ð²`,
  qw = p => `+${p.amount} Ð¼Ð°ÐºÑ. Ð·Ð°Ñ€ÑÐ´Ñ–Ð²`,
  Nw = p => `+${p.amount} lÆ°á»£t tÃ´ tá»‘i Ä‘a`,
  Vw = (p, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? zw(p) : r === "pt" ? Aw(p) : r === "ch" ? Ew(p) : r === "de" ? Lw(p) : r === "es" ? Dw(p) : r === "fr" ? Rw(p) : r === "it" ? jw(p) : r === "jp" ? Fw(p) : r === "pl" ? Bw(p) : r === "ru" ? Ow(p) : r === "uk" ? qw(p) : Nw(p)
  },
  Uw = p => `+${p.amount} Paint Charges`,
  Zw = p => `+${p.amount} Tintas`,
  Gw = p => `+${p.amount} ç»˜åˆ¶å……èƒ½`,
  Ww = p => `+${p.amount} Pixel-Ladungen`,
  Hw = p => `+${p.amount} cargas de pintura`,
  $w = p => `+${p.amount} charges de peinture`,
  Xw = p => `+${p.amount} cariche di vernice`,
  Yw = p => `ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸ +${p.amount}`,
  Kw = p => `+${p.amount} Å‚adunkÃ³w malowania`,
  Jw = p => `+${p.amount} Ð·Ð°Ñ€ÑÐ´Ð¾Ð²`,
  Qw = p => `+${p.amount} Ð·Ð°Ñ€ÑÐ´Ñ–Ð² Ñ„Ð°Ñ€Ð±Ð¸`,
  e5 = p => `+${p.amount} lÆ°á»£t tÃ´`,
  t5 = (p, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Uw(p) : r === "pt" ? Zw(p) : r === "ch" ? Gw(p) : r === "de" ? Ww(p) : r === "es" ? Hw(p) : r === "fr" ? $w(p) : r === "it" ? Xw(p) : r === "jp" ? Yw(p) : r === "pl" ? Kw(p) : r === "ru" ? Jw(p) : r === "uk" ? Qw(p) : e5(p)
  },
  r5 = () => "and move your cursor over the map.",
  n5 = () => "e mova seu cursor sobre o mapa.",
  i5 = () => "ç„¶åŽæŠŠé¼ æ ‡ç§»åŠ¨åˆ°åœ°å›¾ä¸Šã€‚",
  a5 = () => "gedrÃ¼ckt und bewege deinen Cursor Ã¼ber die Karte.",
  o5 = () => "y mueve el cursor sobre el mapa.",
  s5 = () => "et dÃ©placez votre curseur sur la carte.",
  l5 = () => "e muovi il cursore sopra la mappa.",
  c5 = () => "ãã—ã¦ã€ãƒžãƒƒãƒ—ä¸Šã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã—ã¦ãã ã•ã„ã€‚",
  u5 = () => "i przesuÅ„ kursor po mapie.",
  h5 = () => "Ð¸ Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰Ð°Ð¹Ñ‚Ðµ ÐºÑƒÑ€ÑÐ¾Ñ€ Ð¿Ð¾ ÐºÐ°Ñ€Ñ‚Ðµ.",
  d5 = () => "Ñ– Ð¿Ñ€Ð¾Ð²ÐµÐ´Ñ–Ñ‚ÑŒ ÐºÑƒÑ€ÑÐ¾Ñ€Ð¾Ð¼ Ð¿Ð¾ ÐºÐ°Ñ€Ñ‚Ñ–.",
  p5 = () => "vÃ  di chuyá»ƒn con trá» cá»§a báº¡n trÃªn báº£n Ä‘á»“.",
  f5 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? r5() : r === "pt" ? n5() : r === "ch" ? i5() : r === "de" ? a5() : r === "es" ? o5() : r === "fr" ? s5() : r === "it" ? l5() : r === "jp" ? c5() : r === "pl" ? u5() : r === "ru" ? h5() : r === "uk" ? d5() : p5()
  },
  _5 = () => "Why your suspension should be lifted?",
  m5 = () => "Por que sua suspensÃ£o deve ser reconsiderada?",
  g5 = () => "ä¸ºä»€ä¹ˆåº”è¯¥è§£é™¤ä½ çš„å°ç¦ï¼Ÿ",
  v5 = () => "Warum sollte deine Sperre aufgehoben werden?",
  y5 = () => "Â¿Por quÃ© deberÃ­a levantarse tu suspensiÃ³n?",
  b5 = () => "Pourquoi votre suspension devrait-elle Ãªtre levÃ©e ?",
  x5 = () => "PerchÃ© la tua sospensione dovrebbe essere rivalutata?",
  w5 = () => "ãªãœåœæ­¢ã‚’è§£é™¤ã™ã¹ãã ã¨æ€ã†ã®ã‹æ•™ãˆã¦ãã ã•ã„ã€‚",
  k5 = () => "Dlaczego Twoje zawieszenie powinno zostaÄ‡ cofniÄ™te?",
  T5 = () => "ÐŸÐ¾Ñ‡ÐµÐ¼Ñƒ, Ð¿Ð¾ Ð²Ð°ÑˆÐµÐ¼Ñƒ Ð¼Ð½ÐµÐ½Ð¸ÑŽ, Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ° Ð´Ð¾Ð»Ð¶Ð½Ð° Ð±Ñ‹Ñ‚ÑŒ ÑÐ½ÑÑ‚Ð°?",
  S5 = () => "Ð§Ð¾Ð¼Ñƒ, Ð½Ð° Ð²Ð°ÑˆÑƒ Ð´ÑƒÐ¼ÐºÑƒ, Ð±Ð»Ð¾ÐºÑƒÐ²Ð°Ð½Ð½Ñ Ð¼Ð°Ñ” Ð±ÑƒÑ‚Ð¸ ÑÐºÐ°ÑÐ¾Ð²Ð°Ð½Ð¾?",
  P5 = () => "VÃ¬ sao viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n cá»§a báº¡n nÃªn Ä‘Æ°á»£c gá»¡ bá»?",
  M5 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? _5() : r === "pt" ? m5() : r === "ch" ? g5() : r === "de" ? v5() : r === "es" ? y5() : r === "fr" ? b5() : r === "it" ? x5() : r === "jp" ? w5() : r === "pl" ? k5() : r === "ru" ? T5() : r === "uk" ? S5() : P5()
  },
  I5 = () => "Tell us why you think your suspension should be reconsidered",
  C5 = () => "Explique por que vocÃª acha que sua suspensÃ£o deve ser reconsiderada",
  z5 = () => "å‘Šè¯‰æˆ‘ä»¬ä½ è®¤ä¸ºå°ç¦åº”è¢«é‡æ–°è€ƒè™‘çš„åŽŸå› ",
  A5 = () => "ErklÃ¤re uns, warum deine Sperre deiner Meinung nach Ã¼berprÃ¼ft werden sollte",
  E5 = () => "CuÃ©ntanos por quÃ© crees que tu suspensiÃ³n deberÃ­a ser reconsiderada",
  L5 = () => "Expliquez-nous pourquoi vous pensez que votre suspension devrait Ãªtre reconsidÃ©rÃ©e",
  D5 = () => "Spiega perchÃ© ritieni che la tua sospensione dovrebbe essere rivista",
  R5 = () => "åœæ­¢ã‚’å†æ¤œè¨Žã™ã¹ãã ã¨æ€ã†ç†ç”±ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
  j5 = () => "WyjaÅ›nij, dlaczego Twoje zawieszenie powinno zostaÄ‡ ponownie rozwaÅ¼one",
  F5 = () => "Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ, Ð¿Ð¾Ñ‡ÐµÐ¼Ñƒ Ð²Ñ‹ ÑÑ‡Ð¸Ñ‚Ð°ÐµÑ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð²Ð°ÑˆÑƒ Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÑƒ ÑÑ‚Ð¾Ð¸Ñ‚ Ð¿ÐµÑ€ÐµÑÐ¼Ð¾Ñ‚Ñ€ÐµÑ‚ÑŒ",
  B5 = () => "ÐžÐ¿Ð¸ÑˆÑ–Ñ‚ÑŒ, Ñ‡Ð¾Ð¼Ñƒ Ð²Ð¸ Ð²Ð²Ð°Ð¶Ð°Ñ”Ñ‚Ðµ, Ñ‰Ð¾ Ð±Ð»Ð¾ÐºÑƒÐ²Ð°Ð½Ð½Ñ ÑÐ»Ñ–Ð´ Ð¿ÐµÑ€ÐµÐ³Ð»ÑÐ½ÑƒÑ‚Ð¸",
  O5 = () => "HÃ£y cho chÃºng tÃ´i biáº¿t vÃ¬ sao báº¡n nghÄ© viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n nÃªn Ä‘Æ°á»£c xem xÃ©t láº¡i",
  q5 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? I5() : r === "pt" ? C5() : r === "ch" ? z5() : r === "de" ? A5() : r === "es" ? E5() : r === "fr" ? L5() : r === "it" ? D5() : r === "jp" ? R5() : r === "pl" ? j5() : r === "ru" ? F5() : r === "uk" ? B5() : O5()
  },
  N5 = () => "Appeal sent successfully",
  V5 = () => "Apelo enviado com sucesso",
  U5 = () => "ç”³è¯‰å·²æˆåŠŸå‘é€",
  Z5 = () => "Einspruch erfolgreich gesendet",
  G5 = () => "ApelaciÃ³n enviada correctamente",
  W5 = () => "Recours envoyÃ© avec succÃ¨s",
  H5 = () => "Ricorso inviato con successo",
  $5 = () => "ç•°è­°ç”³ç«‹ã¦ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚",
  X5 = () => "OdwoÅ‚anie zostaÅ‚o pomyÅ›lnie wysÅ‚ane",
  Y5 = () => "ÐÐ¿ÐµÐ»Ð»ÑÑ†Ð¸Ñ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð°",
  K5 = () => "ÐÐ¿ÐµÐ»ÑÑ†Ñ–ÑŽ ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾ Ð½Ð°Ð´Ñ–ÑÐ»Ð°Ð½Ð¾",
  J5 = () => "ÄÃ£ gá»­i khÃ¡ng cÃ¡o thÃ nh cÃ´ng",
  Q5 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? N5() : r === "pt" ? V5() : r === "ch" ? U5() : r === "de" ? Z5() : r === "es" ? G5() : r === "fr" ? W5() : r === "it" ? H5() : r === "jp" ? $5() : r === "pl" ? X5() : r === "ru" ? Y5() : r === "uk" ? K5() : J5()
  },
  e3 = () => "Are you absolutely sure?",
  t3 = () => "VocÃª tem certeza absoluta?",
  r3 = () => "ä½ ç¡®å®šå—ï¼Ÿ",
  n3 = () => "Bist du dir absolut sicher?",
  i3 = () => "Â¿EstÃ¡s absolutamente seguro?",
  a3 = () => "ÃŠtes-vous absolument sÃ»r ?",
  o3 = () => "Sei assolutamente sicuro?",
  s3 = () => "æœ¬å½“ã«å®Ÿè¡Œã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
  l3 = () => "Czy na pewno chcesz to zrobiÄ‡?",
  c3 = () => "Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹?",
  u3 = () => "Ð’Ð¸ Ð°Ð±ÑÐ¾Ð»ÑŽÑ‚Ð½Ð¾ Ð²Ð¿ÐµÐ²Ð½ÐµÐ½Ñ–?",
  h3 = () => "Báº¡n cÃ³ thá»±c sá»± cháº¯c cháº¯n?",
  d3 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? e3() : r === "pt" ? t3() : r === "ch" ? r3() : r === "de" ? n3() : r === "es" ? i3() : r === "fr" ? a3() : r === "it" ? o3() : r === "jp" ? s3() : r === "pl" ? l3() : r === "ru" ? c3() : r === "uk" ? u3() : h3()
  },
  p3 = () => "Ban from alliance",
  f3 = () => "Banir da alianÃ§a",
  _3 = () => "ä»Žè”ç›Ÿä¸­å°ç¦",
  m3 = () => "Aus Allianz bannen",
  g3 = () => "Banear de la alianza",
  v3 = () => "Bannir de lâ€™alliance",
  y3 = () => "Banna dall'alleanza",
  b3 = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‹ã‚‰BAN",
  x3 = () => "Zbanuj z sojuszu",
  w3 = () => "Ð—Ð°Ð±Ð°Ð½Ð¸Ñ‚ÑŒ Ð² Ð°Ð»ÑŒÑÐ½ÑÐµ",
  k3 = () => "Ð—Ð°Ð±Ð°Ð½Ð¸Ñ‚Ð¸ Ð² Ð°Ð»ÑŒÑÐ½ÑÑ–",
  T3 = () => "Cáº¥m khá»i liÃªn minh",
  x0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? p3() : r === "pt" ? f3() : r === "ch" ? _3() : r === "de" ? m3() : r === "es" ? g3() : r === "fr" ? v3() : r === "it" ? y3() : r === "jp" ? b3() : r === "pl" ? x3() : r === "ru" ? w3() : r === "uk" ? k3() : T3()
  },
  S3 = p => `Reason: ${p.reason}`,
  P3 = p => `Motivo: ${p.reason}`,
  M3 = p => `åŽŸå› ï¼š${p.reason}`,
  I3 = p => `Grund: ${p.reason}`,
  C3 = p => `Motivo: ${p.reason}`,
  z3 = p => `Raison : ${p.reason}`,
  A3 = p => `Motivo: ${p.reason}`,
  E3 = p => `ç†ç”±: ${p.reason}`,
  L3 = p => `PowÃ³d: ${p.reason}`,
  D3 = p => `ÐŸÑ€Ð¸Ñ‡Ð¸Ð½Ð°: ${p.reason}`,
  R3 = p => `ÐŸÑ€Ð¸Ñ‡Ð¸Ð½Ð°: ${p.reason}`,
  j3 = p => `LÃ½ do: ${p.reason}`,
  fv = (p, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? S3(p) : r === "pt" ? P3(p) : r === "ch" ? M3(p) : r === "de" ? I3(p) : r === "es" ? C3(p) : r === "fr" ? z3(p) : r === "it" ? A3(p) : r === "jp" ? E3(p) : r === "pl" ? L3(p) : r === "ru" ? D3(p) : r === "uk" ? R3(p) : j3(p)
  },
  F3 = () => "Bug report",
  B3 = () => "Reportar bug",
  O3 = () => "é”™è¯¯æŠ¥å‘Š",
  q3 = () => "Bug melden",
  N3 = () => "Reporte de bug",
  V3 = () => "Signaler un bug",
  U3 = () => "Segnala bug",
  Z3 = () => "ãƒã‚°å ±å‘Š",
  G3 = () => "ZgÅ‚oszenie bÅ‚Ä™du",
  W3 = () => "Ð¡Ð¾Ð¾Ð±Ñ‰Ð¸Ñ‚ÑŒ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐµ",
  H3 = () => "Ð—Ð²Ñ–Ñ‚ Ð¿Ñ€Ð¾ Ð±Ð°Ð³",
  $3 = () => "BÃ¡o lá»—i",
  X3 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? F3() : r === "pt" ? B3() : r === "ch" ? O3() : r === "de" ? q3() : r === "es" ? N3() : r === "fr" ? V3() : r === "it" ? U3() : r === "jp" ? Z3() : r === "pl" ? G3() : r === "ru" ? W3() : r === "uk" ? H3() : $3()
  },
  Y3 = () => "Change language",
  K3 = () => "Mudar idioma",
  J3 = () => "æ›´æ”¹è¯­è¨€",
  Q3 = () => "Sprache Ã¤ndern",
  ek = () => "Cambiar idioma",
  tk = () => "Changer de langue",
  rk = () => "Cambia lingua",
  nk = () => "è¨€èªžã‚’å¤‰æ›´",
  ik = () => "ZmieÅ„ jÄ™zyk",
  ak = () => "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ ÑÐ·Ñ‹Ðº",
  ok = () => "Ð—Ð¼Ñ–Ð½Ð¸Ñ‚Ð¸ Ð¼Ð¾Ð²Ñƒ",
  sk = () => "Thay Ä‘á»•i ngÃ´n ngá»¯",
  lk = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Y3() : r === "pt" ? K3() : r === "ch" ? J3() : r === "de" ? Q3() : r === "es" ? ek() : r === "fr" ? tk() : r === "it" ? rk() : r === "jp" ? nk() : r === "pl" ? ik() : r === "ru" ? ak() : r === "uk" ? ok() : sk()
  },
  ck = () => "Change picture:",
  uk = () => "Trocar imagem:",
  hk = () => "æ›´æ¢å¤´åƒï¼š",
  dk = () => "Bild Ã¤ndern:",
  pk = () => "Cambiar imagen:",
  fk = () => "Changer lâ€™image :",
  _k = () => "Cambia immagine:",
  mk = () => "ç”»åƒã‚’å¤‰æ›´:",
  gk = () => "ZmieÅ„ obraz:",
  vk = () => "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ:",
  yk = () => "Ð—Ð¼Ñ–Ð½Ð¸Ñ‚Ð¸ Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ:",
  bk = () => "Äá»•i áº£nh:",
  xk = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ck() : r === "pt" ? uk() : r === "ch" ? hk() : r === "de" ? dk() : r === "es" ? pk() : r === "fr" ? fk() : r === "it" ? _k() : r === "jp" ? mk() : r === "pl" ? gk() : r === "ru" ? vk() : r === "uk" ? yk() : bk()
  },
  wk = () => "Claim",
  kk = () => "Resgatar",
  Tk = () => "é¢†å–",
  Sk = () => "Einsammeln",
  Pk = () => "Reclamar",
  Mk = () => "RÃ©cupÃ©rer",
  Ik = () => "Riscatta",
  Ck = () => "å—ã‘å–ã‚‹",
  zk = () => "Odbierz",
  Ak = () => "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ",
  Ek = () => "ÐžÑ‚Ñ€Ð¸Ð¼Ð°Ñ‚Ð¸",
  Lk = () => "Nháº­n",
  Dk = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? wk() : r === "pt" ? kk() : r === "ch" ? Tk() : r === "de" ? Sk() : r === "es" ? Pk() : r === "fr" ? Mk() : r === "it" ? Ik() : r === "jp" ? Ck() : r === "pl" ? zk() : r === "ru" ? Ak() : r === "uk" ? Ek() : Lk()
  },
  Rk = () => "Claimed",
  jk = () => "Resgatado",
  Fk = () => "å·²é¢†å–",
  Bk = () => "Eingesammelt",
  Ok = () => "Reclamado",
  qk = () => "RÃ©cupÃ©rÃ©",
  Nk = () => "Riscattato",
  Vk = () => "å—ã‘å–ã‚Šæ¸ˆã¿",
  Uk = () => "Odebrano",
  Zk = () => "ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾",
  Gk = () => "ÐžÑ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾",
  Wk = () => "ÄÃ£ nháº­n",
  Hk = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Rk() : r === "pt" ? jk() : r === "ch" ? Fk() : r === "de" ? Bk() : r === "es" ? Ok() : r === "fr" ? qk() : r === "it" ? Nk() : r === "jp" ? Vk() : r === "pl" ? Uk() : r === "ru" ? Zk() : r === "uk" ? Gk() : Wk()
  },
  $k = () => "Click",
  Xk = () => "Clique",
  Yk = () => "ç‚¹å‡»",
  Kk = () => "Klicken",
  Jk = () => "Haz clic",
  Qk = () => "Cliquez",
  eT = () => "Clicca",
  tT = () => "ã‚¯ãƒªãƒƒã‚¯",
  rT = () => "Kliknij",
  nT = () => "ÐšÐ»Ð¸Ðº",
  iT = () => "ÐšÐ»Ð°Ñ†Ð½Ñ–Ñ‚ÑŒ",
  aT = () => "Nháº¥p",
  oT = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? $k() : r === "pt" ? Xk() : r === "ch" ? Yk() : r === "de" ? Kk() : r === "es" ? Jk() : r === "fr" ? Qk() : r === "it" ? eT() : r === "jp" ? tT() : r === "pl" ? rT() : r === "ru" ? nT() : r === "uk" ? iT() : aT()
  },
  sT = () => "Color Picker",
  lT = () => "Conta Gotas",
  cT = () => "å–è‰²å™¨",
  uT = () => "Farbpipette",
  hT = () => "Selector de color",
  dT = () => "Pipette",
  pT = () => "Contagocce",
  fT = () => "ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼",
  _T = () => "PrÃ³bnik kolorÃ³w",
  mT = () => "ÐŸÐ¸Ð¿ÐµÑ‚ÐºÐ°",
  gT = () => "ÐŸÑ–Ð¿ÐµÑ‚ÐºÐ°",
  vT = () => "Báº£ng chá»n mÃ u",
  yT = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? sT() : r === "pt" ? lT() : r === "ch" ? cT() : r === "de" ? uT() : r === "es" ? hT() : r === "fr" ? dT() : r === "it" ? pT() : r === "jp" ? fT() : r === "pl" ? _T() : r === "ru" ? mT() : r === "uk" ? gT() : vT()
  },
  bT = () => "Coordinates",
  xT = () => "Coordenadas",
  wT = () => "åæ ‡",
  kT = () => "Koordinaten",
  TT = () => "Coordenadas",
  ST = () => "CoordonnÃ©es",
  PT = () => "Coordinate",
  MT = () => "åº§æ¨™",
  IT = () => "WspÃ³Å‚rzÄ™dne",
  CT = () => "ÐšÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ñ‹",
  zT = () => "ÐšÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ð¸",
  AT = () => "Tá»a Ä‘á»™",
  w0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? bT() : r === "pt" ? xT() : r === "ch" ? wT() : r === "de" ? kT() : r === "es" ? TT() : r === "fr" ? ST() : r === "it" ? PT() : r === "jp" ? MT() : r === "pl" ? IT() : r === "ru" ? CT() : r === "uk" ? zT() : AT()
  },
  ET = () => "Copied",
  LT = () => "Copiado",
  DT = () => "å·²å¤åˆ¶",
  RT = () => "Kopiert",
  jT = () => "Copiado",
  FT = () => "CopiÃ©",
  BT = () => "Copiato",
  OT = () => "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  qT = () => "Skopiowano",
  NT = () => "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾",
  VT = () => "Ð¡ÐºÐ¾Ð¿Ñ–Ð¹Ð¾Ð²Ð°Ð½Ð¾",
  UT = () => "ÄÃ£ sao chÃ©p",
  J_ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ET() : r === "pt" ? LT() : r === "ch" ? DT() : r === "de" ? RT() : r === "es" ? jT() : r === "fr" ? FT() : r === "it" ? BT() : r === "jp" ? OT() : r === "pl" ? qT() : r === "ru" ? NT() : r === "uk" ? VT() : UT()
  },
  ZT = p => `Could not install the app: ${p.error}`,
  GT = p => `NÃ£o pode instalar o app: ${p.error}`,
  WT = p => `æ— æ³•å®‰è£…åº”ç”¨ï¼š${p.error}`,
  HT = p => `App konnte nicht installiert werden: ${p.error}`,
  $T = p => `No se pudo instalar la app: ${p.error}`,
  XT = p => `Impossible dâ€™installer lâ€™application : ${p.error}`,
  YT = p => `Impossibile installare l'app: ${p.error}`,
  KT = p => `ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ãã¾ã›ã‚“ã§ã—ãŸ: ${p.error}`,
  JT = p => `Nie udaÅ‚o siÄ™ zainstalowaÄ‡ aplikacji: ${p.error}`,
  QT = p => `ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ: ${p.error}`,
  eS = p => `ÐÐµ Ð²Ð´Ð°Ð»Ð¾ÑÑ Ð²ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ð¸ Ð·Ð°ÑÑ‚Ð¾ÑÑƒÐ½Ð¾Ðº: ${p.error}`,
  tS = p => `KhÃ´ng thá»ƒ cÃ i Ä‘áº·t á»©ng dá»¥ng: ${p.error}`,
  rS = (p, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ZT(p) : r === "pt" ? GT(p) : r === "ch" ? WT(p) : r === "de" ? HT(p) : r === "es" ? $T(p) : r === "fr" ? XT(p) : r === "it" ? YT(p) : r === "jp" ? KT(p) : r === "pl" ? JT(p) : r === "ru" ? QT(p) : r === "uk" ? eS(p) : tS(p)
  },
  nS = () => "Could not logout. Try refreshing the page.",
  iS = () => "NÃ£o foi possÃ­vel sair da conta. Tente recarregar a pÃ¡gina.",
  aS = () => "æ— æ³•ç™»å‡ºï¼Œè¯·å°è¯•åˆ·æ–°é¡µé¢ã€‚",
  oS = () => "Abmelden nicht mÃ¶glich. Versuche, die Seite neu zu laden.",
  sS = () => "No se pudo cerrar sesiÃ³n. Intenta refrescar la pÃ¡gina.",
  lS = () => "Impossible de se dÃ©connecter. Essayez dâ€™actualiser la page.",
  cS = () => "Impossibile disconnettersi. Prova a ricaricare la pagina.",
  uS = () => "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã¦ãã ã•ã„ã€‚",
  hS = () => "Nie udaÅ‚o siÄ™ wylogowaÄ‡. SprÃ³buj odÅ›wieÅ¼yÄ‡ stronÄ™.",
  dS = () => "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ñ‹Ð¹Ñ‚Ð¸ Ð¸Ð· Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿ÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ.",
  pS = () => "ÐÐµ Ð²Ð´Ð°Ð»Ð¾ÑÑ Ð²Ð¸Ð¹Ñ‚Ð¸ Ð· Ð°ÐºÐ°ÑƒÐ½Ñ‚Ð°. Ð¡Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¾Ð½Ð¾Ð²Ð¸Ñ‚Ð¸ ÑÑ‚Ð¾Ñ€Ñ–Ð½ÐºÑƒ.",
  fS = () => "KhÃ´ng thá»ƒ Ä‘Äƒng xuáº¥t. HÃ£y thá»­ táº£i láº¡i trang.",
  _S = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? nS() : r === "pt" ? iS() : r === "ch" ? aS() : r === "de" ? oS() : r === "es" ? sS() : r === "fr" ? lS() : r === "it" ? cS() : r === "jp" ? uS() : r === "pl" ? hS() : r === "ru" ? dS() : r === "uk" ? pS() : fS()
  },
  mS = () => "Countries",
  gS = () => "PaÃ­ses",
  vS = () => "å›½å®¶",
  yS = () => "LÃ¤nder",
  bS = () => "PaÃ­ses",
  xS = () => "Pays",
  wS = () => "Paesi",
  kS = () => "å›½",
  TS = () => "Kraje",
  SS = () => "Ð¡Ñ‚Ñ€Ð°Ð½Ñ‹",
  PS = () => "ÐšÑ€Ð°Ñ—Ð½Ð¸",
  MS = () => "Quá»‘c gia",
  IS = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? mS() : r === "pt" ? gS() : r === "ch" ? vS() : r === "de" ? yS() : r === "es" ? bS() : r === "fr" ? xS() : r === "it" ? wS() : r === "jp" ? kS() : r === "pl" ? TS() : r === "ru" ? SS() : r === "uk" ? PS() : MS()
  },
  CS = () => "Country",
  zS = () => "PaÃ­s",
  AS = () => "å›½å®¶",
  ES = () => "Land",
  LS = () => "PaÃ­s",
  DS = () => "Pays",
  RS = () => "Paese",
  jS = () => "å›½",
  FS = () => "Kraj",
  BS = () => "Ð¡Ñ‚Ñ€Ð°Ð½Ð°",
  OS = () => "ÐšÑ€Ð°Ñ—Ð½Ð°",
  qS = () => "Quá»‘c gia",
  Q_ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? CS() : r === "pt" ? zS() : r === "ch" ? AS() : r === "de" ? ES() : r === "es" ? LS() : r === "fr" ? DS() : r === "it" ? RS() : r === "jp" ? jS() : r === "pl" ? FS() : r === "ru" ? BS() : r === "uk" ? OS() : qS()
  },
  NS = () => "Create",
  VS = () => "Criar",
  US = () => "åˆ›å»º",
  ZS = () => "Erstellen",
  GS = () => "Crear",
  WS = () => "CrÃ©er",
  HS = () => "Crea",
  $S = () => "ä½œæˆ",
  XS = () => "UtwÃ³rz",
  YS = () => "Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ",
  KS = () => "Ð¡Ñ‚Ð²Ð¾Ñ€Ð¸Ñ‚Ð¸",
  JS = () => "Táº¡o",
  QS = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? NS() : r === "pt" ? VS() : r === "ch" ? US() : r === "de" ? ZS() : r === "es" ? GS() : r === "fr" ? WS() : r === "it" ? HS() : r === "jp" ? $S() : r === "pl" ? XS() : r === "ru" ? YS() : r === "uk" ? KS() : JS()
  },
  eP = () => "Create alliance",
  tP = () => "Criar alianÃ§a",
  rP = () => "åˆ›å»ºè”ç›Ÿ",
  nP = () => "Allianz erstellen",
  iP = () => "Crear alianza",
  aP = () => "CrÃ©er une alliance",
  oP = () => "Crea alleanza",
  sP = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’ä½œæˆ",
  lP = () => "UtwÃ³rz sojusz",
  cP = () => "Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð°Ð»ÑŒÑÐ½Ñ",
  uP = () => "Ð¡Ñ‚Ð²Ð¾Ñ€Ð¸Ñ‚Ð¸ Ð°Ð»ÑŒÑÐ½Ñ",
  hP = () => "Táº¡o liÃªn minh",
  dP = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? eP() : r === "pt" ? tP() : r === "ch" ? rP() : r === "de" ? nP() : r === "es" ? iP() : r === "fr" ? aP() : r === "it" ? oP() : r === "jp" ? sP() : r === "pl" ? lP() : r === "ru" ? cP() : r === "uk" ? uP() : hP()
  },
  pP = () => "Create an alliance",
  fP = () => "Crie uma alianÃ§a",
  _P = () => "åˆ›å»ºä¸€ä¸ªè”ç›Ÿ",
  mP = () => "Erstelle eine Allianz",
  gP = () => "Crear una alianza",
  vP = () => "CrÃ©er une alliance",
  yP = () => "Crea un'alleanza",
  bP = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹",
  xP = () => "UtwÃ³rz sojusz",
  wP = () => "Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð°Ð»ÑŒÑÐ½Ñ",
  kP = () => "Ð¡Ñ‚Ð²Ð¾Ñ€Ñ–Ñ‚ÑŒ Ð°Ð»ÑŒÑÐ½Ñ",
  TP = () => "Táº¡o má»™t liÃªn minh",
  SP = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? pP() : r === "pt" ? fP() : r === "ch" ? _P() : r === "de" ? mP() : r === "es" ? gP() : r === "fr" ? vP() : r === "it" ? yP() : r === "jp" ? bP() : r === "pl" ? xP() : r === "ru" ? wP() : r === "uk" ? kP() : TP()
  },
  PP = () => "Dark mode",
  MP = () => "Modo escuro",
  IP = () => "æ·±è‰²æ¨¡å¼",
  CP = () => "Dunkler Modus",
  zP = () => "Modo oscuro",
  AP = () => "Mode sombre",
  EP = () => "Tema scuro",
  LP = () => "ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒž",
  DP = () => "Tryb ciemny",
  RP = () => "Ð¢Ñ‘Ð¼Ð½Ð°Ñ Ñ‚ÐµÐ¼Ð°",
  jP = () => "Ð¢ÐµÐ¼Ð½Ð° Ñ‚ÐµÐ¼Ð°",
  FP = () => "Cháº¿ Ä‘á»™ tá»‘i",
  BP = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? PP() : r === "pt" ? MP() : r === "ch" ? IP() : r === "de" ? CP() : r === "es" ? zP() : r === "fr" ? AP() : r === "it" ? EP() : r === "jp" ? LP() : r === "pl" ? DP() : r === "ru" ? RP() : r === "uk" ? jP() : FP()
  },
  OP = () => "Delete Account",
  qP = () => "Deletar Conta",
  NP = () => "åˆ é™¤è´¦å·",
  VP = () => "Konto lÃ¶schen",
  UP = () => "Eliminar cuenta",
  ZP = () => "Supprimer le compte",
  GP = () => "Elimina account",
  WP = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤",
  HP = () => "UsuÅ„ konto",
  $P = () => "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚",
  XP = () => "Ð’Ð¸Ð´Ð°Ð»Ð¸Ñ‚Ð¸ Ð°ÐºÐ°ÑƒÐ½Ñ‚",
  YP = () => "XÃ³a tÃ i khoáº£n",
  o_ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? OP() : r === "pt" ? qP() : r === "ch" ? NP() : r === "de" ? VP() : r === "es" ? UP() : r === "fr" ? ZP() : r === "it" ? GP() : r === "jp" ? WP() : r === "pl" ? HP() : r === "ru" ? $P() : r === "uk" ? XP() : YP()
  },
  KP = () => "ðŸ™… Disclosing other's personal information is not allowed",
  JP = () => "ðŸ™… Divulgar informaÃ§Ãµes pessoais dos outros nÃ£o Ã© permitido",
  QP = () => "ðŸ™… ä¸å…è®¸æ³„éœ²ä»–äººä¸ªäººä¿¡æ¯",
  eM = () => "ðŸ™… Das VerÃ¶ffentlichen persÃ¶nlicher Daten anderer ist nicht erlaubt",
  tM = () => "ðŸ™… No estÃ¡ permitido divulgar informaciÃ³n personal de otras personas",
  rM = () => "ðŸ™… La divulgation dâ€™informations personnelles dâ€™autrui nâ€™est pas autorisÃ©e",
  nM = () => "ðŸ™… Non Ã¨ consentito divulgare informazioni personali di altre persone",
  iM = () => "ðŸ™… ä»–äººã®å€‹äººæƒ…å ±ã‚’å…¬é–‹ã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  aM = () => "ðŸ™… UdostÄ™pnianie cudzych danych osobowych jest niedozwolone",
  oM = () => "ðŸ™… ÐŸÑƒÐ±Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ Ð»Ð¸Ñ‡Ð½Ð¾Ð¹ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð´Ñ€ÑƒÐ³Ð¸Ñ… Ð»ÑŽÐ´ÐµÐ¹ Ð·Ð°Ð¿Ñ€ÐµÑ‰ÐµÐ½Ð°",
  sM = () => "ðŸ™… ÐŸÐ¾ÑˆÐ¸Ñ€ÐµÐ½Ð½Ñ Ð¾ÑÐ¾Ð±Ð¸ÑÑ‚Ð¾Ñ— Ñ–Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ— Ñ–Ð½ÑˆÐ¸Ñ… Ð»ÑŽÐ´ÐµÐ¹ Ð·Ð°Ð±Ð¾Ñ€Ð¾Ð½ÐµÐ½Ð¾",
  lM = () => "ðŸ™… KhÃ´ng Ä‘Æ°á»£c phÃ©p tiáº¿t lá»™ thÃ´ng tin cÃ¡ nhÃ¢n cá»§a ngÆ°á»i khÃ¡c",
  cM = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? KP() : r === "pt" ? JP() : r === "ch" ? QP() : r === "de" ? eM() : r === "es" ? tM() : r === "fr" ? rM() : r === "it" ? nM() : r === "jp" ? iM() : r === "pl" ? aM() : r === "ru" ? oM() : r === "uk" ? sM() : lM()
  },
  uM = () => "Successfully linked your Discord account.",
  hM = () => "A sua conta Discord foi conectada com sucesso.",
  dM = () => "å·²æˆåŠŸå…³è”ä½ çš„ Discord è´¦å·ã€‚",
  pM = () => "Dein Discord-Konto wurde erfolgreich verknÃ¼pft.",
  fM = () => "Tu cuenta de Discord se ha vinculado correctamente.",
  _M = () => "Votre compte Discord a Ã©tÃ© liÃ© avec succÃ¨s.",
  mM = () => "Il tuo account Discord Ã¨ stato collegato con successo.",
  gM = () => "Discordã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æ­£å¸¸ã«é€£æºã—ã¾ã—ãŸã€‚",
  vM = () => "Twoje konto Discord zostaÅ‚o pomyÅ›lnie poÅ‚Ä…czone.",
  yM = () => "Ð’Ð°Ñˆ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Discord ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¿Ñ€Ð¸Ð²ÑÐ·Ð°Ð½.",
  bM = () => "Ð’Ð°Ñˆ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Discord ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾ Ð¿Ñ€Ð¸Ð²Ê¼ÑÐ·Ð°Ð½Ð¾.",
  xM = () => "ÄÃ£ liÃªn káº¿t tÃ i khoáº£n Discord cá»§a báº¡n thÃ nh cÃ´ng.",
  wM = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? uM() : r === "pt" ? hM() : r === "ch" ? dM() : r === "de" ? pM() : r === "es" ? fM() : r === "fr" ? _M() : r === "it" ? mM() : r === "jp" ? gM() : r === "pl" ? vM() : r === "ru" ? yM() : r === "uk" ? bM() : xM()
  },
  kM = () => "Discord Username",
  TM = () => "UsuÃ¡rio do Discord",
  SM = () => "Discord ç”¨æˆ·å",
  PM = () => "Discord-Benutzername",
  MM = () => "Usuario de Discord",
  IM = () => "Nom dâ€™utilisateur Discord",
  CM = () => "Utente Discord",
  zM = () => "Discordã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å",
  AM = () => "Nazwa uÅ¼ytkownika Discord",
  EM = () => "Ð˜Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Discord",
  LM = () => "Ð†Ð¼Ê¼Ñ Ð² Discord",
  DM = () => "TÃªn ngÆ°á»i dÃ¹ng Discord",
  RM = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? kM() : r === "pt" ? TM() : r === "ch" ? SM() : r === "de" ? PM() : r === "es" ? MM() : r === "fr" ? IM() : r === "it" ? CM() : r === "jp" ? zM() : r === "pl" ? AM() : r === "ru" ? EM() : r === "uk" ? LM() : DM()
  },
  jM = () => "Display your countryâ€™s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  FM = () => "Exiba a bandeira do seu paÃ­s ao lado do seu nome de usuÃ¡rio. AlÃ©m disso, ao pintar em regiÃµes onde vocÃª possui a bandeira correspondente, vocÃª recupera 10% das tintas gastas.",
  BM = () => "åœ¨ç”¨æˆ·åæ—æ˜¾ç¤ºä½ çš„å›½å®¶å›½æ——ã€‚æ­¤å¤–ï¼Œå½“ä½ åœ¨æ‹¥æœ‰å¯¹åº”å›½æ——çš„åŒºåŸŸå†…ç»˜åˆ¶åƒç´ æ—¶ï¼Œå¯ä»¥è¿”è¿˜ 10% æ¶ˆè€—çš„å……èƒ½ã€‚",
  OM = () => "Zeige die Flagge deines Landes neben deinem Benutzernamen an. Wenn du in Regionen malst, in denen du die entsprechende Flagge besitzt, erhÃ¤ltst du 10 % der verbrauchten Pixel zurÃ¼ck.",
  qM = () => "Muestra la bandera de tu paÃ­s junto a tu nombre de usuario. AdemÃ¡s, al pintar en regiones donde posees la bandera correspondiente, recuperas el 10% de las cargas gastadas.",
  NM = () => "Affichez le drapeau de votre pays Ã  cÃ´tÃ© de votre nom dâ€™utilisateur. De plus, lorsque vous peignez dans des rÃ©gions correspondant Ã  votre drapeau, vous rÃ©cupÃ©rez 10 % des charges dÃ©pensÃ©es.",
  VM = () => "Mostra la bandiera del tuo paese accanto al tuo nome utente. Inoltre, quando dipingi in regioni in cui possiedi la bandiera corrispondente, recuperi il 10% delle cariche spese.",
  UM = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã®æ¨ªã«è‡ªåˆ†ã®å›½æ——ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ã•ã‚‰ã«ã€ãã®å›½æ——ã«å¯¾å¿œã™ã‚‹åœ°åŸŸã§ãƒšã‚¤ãƒ³ãƒˆã™ã‚‹ã¨ã€æ¶ˆè²»ã—ãŸãƒãƒ£ãƒ¼ã‚¸ã®10%ãŒæˆ»ã£ã¦ãã¾ã™ã€‚",
  ZM = () => "WyÅ›wietl flagÄ™ swojego kraju obok nazwy uÅ¼ytkownika. Dodatkowo, malujÄ…c w regionach, ktÃ³rych flagÄ™ posiadasz, odzyskujesz 10% zuÅ¼ytych Å‚adunkÃ³w.",
  GM = () => "ÐŸÐ¾ÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ñ„Ð»Ð°Ð³ ÑÐ²Ð¾ÐµÐ¹ ÑÑ‚Ñ€Ð°Ð½Ñ‹ Ñ€ÑÐ´Ð¾Ð¼ Ñ Ð¸Ð¼ÐµÐ½ÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ. ÐšÑ€Ð¾Ð¼Ðµ Ñ‚Ð¾Ð³Ð¾, Ñ€Ð¸ÑÑƒÑ Ð² Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð°Ñ…, Ð³Ð´Ðµ Ñƒ Ð²Ð°Ñ ÐµÑÑ‚ÑŒ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ Ñ„Ð»Ð°Ð³, Ð²Ñ‹ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚Ðµ 10% Ð¿Ð¾Ñ‚Ñ€Ð°Ñ‡ÐµÐ½Ð½Ñ‹Ñ… Ð·Ð°Ñ€ÑÐ´Ð¾Ð².",
  WM = () => "ÐŸÐ¾ÐºÐ°Ð·ÑƒÐ¹Ñ‚Ðµ Ð¿Ñ€Ð°Ð¿Ð¾Ñ€ ÑÐ²Ð¾Ñ”Ñ— ÐºÑ€Ð°Ñ—Ð½Ð¸ Ð¿Ð¾Ñ€ÑƒÑ‡ Ñ–Ð· Ñ–Ð¼â€™ÑÐ¼ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ð°. Ð¢Ð°ÐºÐ¾Ð¶, ÐºÐ¾Ð»Ð¸ Ð²Ð¸ Ð¼Ð°Ð»ÑŽÑ”Ñ‚Ðµ Ð² Ñ€ÐµÐ³Ñ–Ð¾Ð½Ð°Ñ…, Ñ‰Ð¾ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð°ÑŽÑ‚ÑŒ Ð²Ð°ÑˆÐ¾Ð¼Ñƒ Ð¿Ñ€Ð°Ð¿Ð¾Ñ€Ñƒ, Ð²Ð¸ Ð¿Ð¾Ð²ÐµÑ€Ñ‚Ð°Ñ”Ñ‚Ðµ 10% Ð²Ð¸Ñ‚Ñ€Ð°Ñ‡ÐµÐ½Ð¸Ñ… Ð·Ð°Ñ€ÑÐ´Ñ–Ð².",
  HM = () => "Hiá»ƒn thá»‹ cá» quá»‘c gia bÃªn cáº¡nh tÃªn ngÆ°á»i dÃ¹ng cá»§a báº¡n. NgoÃ i ra, khi tÃ´ trong khu vá»±c tÆ°Æ¡ng á»©ng vá»›i lÃ¡ cá» báº¡n sá»Ÿ há»¯u, báº¡n sáº½ nháº­n láº¡i 10% lÆ°á»£t tÃ´ Ä‘Ã£ dÃ¹ng.",
  $M = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? jM() : r === "pt" ? FM() : r === "ch" ? BM() : r === "de" ? OM() : r === "es" ? qM() : r === "fr" ? NM() : r === "it" ? VM() : r === "jp" ? UM() : r === "pl" ? ZM() : r === "ru" ? GM() : r === "uk" ? WM() : HM()
  },
  XM = () => "ðŸ˜ˆ Do not paint over other artworks using random colors or patterns just to mess things up",
  YM = () => "ðŸ˜ˆ NÃ£o desenhe por cima de outras artes usando cores ou padrÃµes aleatÃ³rios sÃ³ para bagunÃ§ar",
  KM = () => "ðŸ˜ˆ è¯·ä¸è¦éšæ„ç”¨éšæœºé¢œè‰²æˆ–å›¾æ¡ˆè¦†ç›–ä»–äººçš„ä½œå“æ¥æ£ä¹±",
  JM = () => "ðŸ˜ˆ Ãœbermale nicht andere Kunstwerke mit irgendwelchen Farben oder Mustern, nur um Chaos zu stiften",
  QM = () => "ðŸ˜ˆ No pintes sobre las obras de otros usando colores o patrones aleatorios sÃ³lo para arruinar",
  e4 = () => "ðŸ˜ˆ Ne peignez pas par-dessus les Å“uvres des autres avec des couleurs ou motifs alÃ©atoires juste pour gÃ¢cher",
  t4 = () => "ðŸ˜ˆ Non disegnare sopra le opere altrui usando colori o pattern casuali solo per rovinare",
  r4 = () => "ðŸ˜ˆ ã„ãŸãšã‚‰ç›®çš„ã§ã€ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ã‚„æ¨¡æ§˜ã§ä»–äººã®ä½œå“ã‚’å¡—ã‚Šã¤ã¶ã•ãªã„ã§ãã ã•ã„",
  n4 = () => "ðŸ˜ˆ Nie maluj po cudzych pracach losowymi kolorami lub wzorami tylko po to, aby wszystko zepsuÄ‡",
  i4 = () => "ðŸ˜ˆ ÐÐµ Ñ€Ð¸ÑÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð²ÐµÑ€Ñ… Ñ‡ÑƒÐ¶Ð¸Ñ… Ñ€Ð°Ð±Ð¾Ñ‚ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ð¼Ð¸ Ñ†Ð²ÐµÑ‚Ð°Ð¼Ð¸ Ð¸Ð»Ð¸ ÑƒÐ·Ð¾Ñ€Ð°Ð¼Ð¸ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ñ€Ð°Ð´Ð¸ Ñ‚Ð¾Ð³Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸ÑÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ‚ÑŒ Ð¸Ñ…",
  a4 = () => "ðŸ˜ˆ ÐÐµ Ð¼Ð°Ð»ÑŽÐ¹Ñ‚Ðµ Ð¿Ð¾Ð²ÐµÑ€Ñ… Ñ‡ÑƒÐ¶Ð¸Ñ… Ñ€Ð¾Ð±Ñ–Ñ‚ Ð²Ð¸Ð¿Ð°Ð´ÐºÐ¾Ð²Ð¸Ð¼Ð¸ ÐºÐ¾Ð»ÑŒÐ¾Ñ€Ð°Ð¼Ð¸ Ñ‡Ð¸ Ð²Ñ–Ð·ÐµÑ€ÑƒÐ½ÐºÐ°Ð¼Ð¸ Ð»Ð¸ÑˆÐµ Ð·Ð°Ñ€Ð°Ð´Ð¸ Ð¿ÑÑƒÐ²Ð°Ð½Ð½Ñ",
  o4 = () => "ðŸ˜ˆ Äá»«ng tÃ´ Ä‘Ã¨ lÃªn tÃ¡c pháº©m cá»§a ngÆ°á»i khÃ¡c báº±ng mÃ u ngáº«u nhiÃªn chá»‰ Ä‘á»ƒ phÃ¡",
  s4 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? XM() : r === "pt" ? YM() : r === "ch" ? KM() : r === "de" ? JM() : r === "es" ? QM() : r === "fr" ? e4() : r === "it" ? t4() : r === "jp" ? r4() : r === "pl" ? n4() : r === "ru" ? i4() : r === "uk" ? a4() : o4()
  },
  l4 = () => "Does not need to be equipped to provide the bonus",
  c4 = () => "NÃ£o precisa estar equipada para obter o bÃ´nus",
  u4 = () => "æ— éœ€è£…å¤‡å³å¯æä¾›åŠ æˆæ•ˆæžœ",
  h4 = () => "Muss nicht ausgerÃ¼stet sein, um den Bonus zu erhalten",
  d4 = () => "No necesita estar equipada para otorgar el bono",
  p4 = () => "Nâ€™a pas besoin dâ€™Ãªtre Ã©quipÃ© pour fournir le bonus",
  f4 = () => "Non deve essere equipaggiato per fornire il bonus",
  _4 = () => "ãƒœãƒ¼ãƒŠã‚¹ã‚’å¾—ã‚‹ãŸã‚ã«è£…å‚™ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  m4 = () => "Nie musi byÄ‡ zaÅ‚oÅ¼one, aby dawaÅ‚o bonus",
  g4 = () => "ÐÐµ Ð½ÑƒÐ¶Ð½Ð¾ ÑÐºÐ¸Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð±Ð¾Ð½ÑƒÑ",
  v4 = () => "ÐÐµ Ð¾Ð±Ð¾Ð²Ê¼ÑÐ·ÐºÐ¾Ð²Ð¾ Ð¾Ð±Ð»Ð°Ð´Ð½ÑƒÐ²Ð°Ñ‚Ð¸, Ñ‰Ð¾Ð± Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ñ‚Ð¸ Ð±Ð¾Ð½ÑƒÑ",
  y4 = () => "KhÃ´ng cáº§n trang bá»‹ Ä‘á»ƒ nháº­n hiá»‡u á»©ng",
  b4 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? l4() : r === "pt" ? c4() : r === "ch" ? u4() : r === "de" ? h4() : r === "es" ? d4() : r === "fr" ? p4() : r === "it" ? f4() : r === "jp" ? _4() : r === "pl" ? m4() : r === "ru" ? g4() : r === "uk" ? v4() : y4()
  },
  x4 = () => "Download",
  w4 = () => "Download",
  k4 = () => "ä¸‹è½½",
  T4 = () => "Download",
  S4 = () => "Descargar",
  P4 = () => "TÃ©lÃ©charger",
  M4 = () => "Download",
  I4 = () => "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
  C4 = () => "Pobierz",
  z4 = () => "Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ",
  A4 = () => "Ð—Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸",
  E4 = () => "Táº£i xuá»‘ng",
  L4 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? x4() : r === "pt" ? w4() : r === "ch" ? k4() : r === "de" ? T4() : r === "es" ? S4() : r === "fr" ? P4() : r === "it" ? M4() : r === "jp" ? I4() : r === "pl" ? C4() : r === "ru" ? z4() : r === "uk" ? A4() : E4()
  },
  D4 = () => "Edit profile",
  R4 = () => "Editar perfil",
  j4 = () => "ç¼–è¾‘ä¸ªäººèµ„æ–™",
  F4 = () => "Profil bearbeiten",
  B4 = () => "Editar perfil",
  O4 = () => "Modifier le profil",
  q4 = () => "Modifica profilo",
  N4 = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’ç·¨é›†",
  V4 = () => "Edytuj profil",
  U4 = () => "Ð ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ",
  Z4 = () => "Ð ÐµÐ´Ð°Ð³ÑƒÐ²Ð°Ñ‚Ð¸ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»ÑŒ",
  G4 = () => "Chá»‰nh sá»­a há»“ sÆ¡",
  W4 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? D4() : r === "pt" ? R4() : r === "ch" ? j4() : r === "de" ? F4() : r === "es" ? B4() : r === "fr" ? O4() : r === "it" ? q4() : r === "jp" ? N4() : r === "pl" ? V4() : r === "ru" ? U4() : r === "uk" ? Z4() : G4()
  },
  H4 = () => "Equip",
  $4 = () => "Equipar",
  X4 = () => "è£…å¤‡",
  Y4 = () => "AusrÃ¼sten",
  K4 = () => "Equipar",
  J4 = () => "Ã‰quiper",
  Q4 = () => "Equipaggia",
  eI = () => "è£…å‚™ã™ã‚‹",
  tI = () => "ZaÅ‚Ã³Å¼",
  rI = () => "Ð­ÐºÐ¸Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
  nI = () => "ÐžÑÐ½Ð°ÑÑ‚Ð¸Ñ‚Ð¸",
  iI = () => "Trang bá»‹",
  aI = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? H4() : r === "pt" ? $4() : r === "ch" ? X4() : r === "de" ? Y4() : r === "es" ? K4() : r === "fr" ? J4() : r === "it" ? Q4() : r === "jp" ? eI() : r === "pl" ? tI() : r === "ru" ? rI() : r === "uk" ? nI() : iI()
  },
  oI = () => "Equipped",
  sI = () => "Equipado",
  lI = () => "å·²è£…å¤‡",
  cI = () => "AusgerÃ¼stet",
  uI = () => "Equipado",
  hI = () => "Ã‰quipÃ©",
  dI = () => "Equipaggiato",
  pI = () => "è£…å‚™ä¸­",
  fI = () => "ZaÅ‚oÅ¼one",
  _I = () => "Ð­ÐºÐ¸Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾",
  mI = () => "ÐžÑÐ½Ð°Ñ‰ÐµÐ½Ð¾",
  gI = () => "ÄÃ£ trang bá»‹",
  vI = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? oI() : r === "pt" ? sI() : r === "ch" ? lI() : r === "de" ? cI() : r === "es" ? uI() : r === "fr" ? hI() : r === "it" ? dI() : r === "jp" ? pI() : r === "pl" ? fI() : r === "ru" ? _I() : r === "uk" ? mI() : gI()
  },
  yI = () => "Error giving admin to user",
  bI = () => "Erro ao tornar usuÃ¡rio admin",
  xI = () => "æŽˆäºˆç®¡ç†å‘˜æƒé™æ—¶å‡ºé”™",
  wI = () => "Fehler beim Vergeben von Admin-Rechten",
  kI = () => "Error al otorgar admin al usuario",
  TI = () => "Erreur lors de lâ€™attribution du rÃ´le admin",
  SI = () => "Errore nel rendere l'utente admin",
  PI = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç®¡ç†è€…æ¨©é™ã‚’ä»˜ä¸Žä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚",
  MI = () => "BÅ‚Ä…d podczas nadawania uprawnieÅ„ admina",
  II = () => "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð²Ñ‹Ð´Ð°Ñ‡Ðµ Ð¿Ñ€Ð°Ð² Ð°Ð´Ð¼Ð¸Ð½Ð° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ",
  CI = () => "ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° Ð¿Ñ–Ð´ Ñ‡Ð°Ñ Ð½Ð°Ð´Ð°Ð½Ð½Ñ Ð¿Ñ€Ð°Ð² Ð°Ð´Ð¼Ñ–Ð½Ñ–ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€Ð°",
  zI = () => "Lá»—i khi gÃ¡n quyá»n admin cho ngÆ°á»i dÃ¹ng",
  AI = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? yI() : r === "pt" ? bI() : r === "ch" ? xI() : r === "de" ? wI() : r === "es" ? kI() : r === "fr" ? TI() : r === "it" ? SI() : r === "jp" ? PI() : r === "pl" ? MI() : r === "ru" ? II() : r === "uk" ? CI() : zI()
  },
  EI = () => "Event",
  LI = () => "Evento",
  DI = () => "æ´»åŠ¨",
  RI = () => "Event",
  jI = () => "Evento",
  FI = () => "Ã‰vÃ©nement",
  BI = () => "Evento",
  OI = () => "ã‚¤ãƒ™ãƒ³ãƒˆ",
  qI = () => "Wydarzenie",
  NI = () => "Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ",
  VI = () => "ÐŸÐ¾Ð´Ñ–Ñ",
  UI = () => "Sá»± kiá»‡n",
  ZI = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? EI() : r === "pt" ? LI() : r === "ch" ? DI() : r === "de" ? RI() : r === "es" ? jI() : r === "fr" ? FI() : r === "it" ? BI() : r === "jp" ? OI() : r === "pl" ? qI() : r === "ru" ? NI() : r === "uk" ? VI() : UI()
  },
  GI = () => "Favorite",
  WI = () => "Favoritar",
  HI = () => "æ”¶è—",
  $I = () => "Favorit",
  XI = () => "Favorito",
  YI = () => "Favori",
  KI = () => "Preferito",
  JI = () => "ãŠæ°—ã«å…¥ã‚Š",
  QI = () => "Ulubione",
  eC = () => "Ð˜Ð·Ð±Ñ€Ð°Ð½Ð½Ð¾Ðµ",
  tC = () => "Ð£ Ð²Ð¸Ð±Ñ€Ð°Ð½Ðµ",
  rC = () => "YÃªu thÃ­ch",
  nC = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? GI() : r === "pt" ? WI() : r === "ch" ? HI() : r === "de" ? $I() : r === "es" ? XI() : r === "fr" ? YI() : r === "it" ? KI() : r === "jp" ? JI() : r === "pl" ? QI() : r === "ru" ? eC() : r === "uk" ? tC() : rC()
  },
  iC = p => `The flag of <b>${p.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
  aC = p => `A bandeira <b>${p.country}</b> nÃ£o possui regiÃµes correspondente no mapa e sÃ³ terÃ¡ efeito cosmÃ©tico.`,
  oC = p => `<b>${p.country}</b> çš„å›½æ——åœ¨åœ°å›¾ä¸Šæ²¡æœ‰å¯¹åº”çš„åŒºåŸŸï¼Œä»…å…·æœ‰è£…é¥°æ•ˆæžœã€‚`,
  sC = p => `Die Flagge von <b>${p.country}</b> hat keine entsprechende Region auf der Karte und ist nur kosmetisch.`,
  lC = p => `La bandera de <b>${p.country}</b> no tiene regiones correspondientes en el mapa y tendrÃ¡ sÃ³lo efecto cosmÃ©tico.`,
  cC = p => `Le drapeau de <b>${p.country}</b> nâ€™a pas de rÃ©gion correspondante sur la carte et aura uniquement un effet cosmÃ©tique.`,
  uC = p => `La bandiera di <b>${p.country}</b> non ha una regione corrispondente sulla mappa e avrÃ  solo effetto cosmetico.`,
  hC = p => `<b>${p.country}</b>ã®å›½æ——ã«ã¯ãƒžãƒƒãƒ—ä¸Šã®å¯¾å¿œã‚¨ãƒªã‚¢ãŒãªã„ãŸã‚ã€è¦‹ãŸç›®ã®ã¿ã®åŠ¹æžœã«ãªã‚Šã¾ã™ã€‚`,
  dC = p => `Flaga <b>${p.country}</b> nie ma odpowiadajÄ…cych jej obszarÃ³w na mapie i ma jedynie efekt kosmetyczny.`,
  pC = p => `Ð¤Ð»Ð°Ð³ <b>${p.country}</b> Ð½Ðµ Ð¸Ð¼ÐµÐµÑ‚ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐ¹ Ð¾Ð±Ð»Ð°ÑÑ‚Ð¸ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ðµ Ð¸ Ð±ÑƒÐ´ÐµÑ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÑ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÐºÐ¾ÑÐ¼ÐµÑ‚Ð¸Ñ‡ÐµÑÐºÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ.`,
  fC = p => `ÐŸÑ€Ð°Ð¿Ð¾Ñ€ <b>${p.country}</b> Ð½Ðµ Ð¼Ð°Ñ” Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð½Ð¸Ñ… Ð¾Ð±Ð»Ð°ÑÑ‚ÐµÐ¹ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ñ– Ñ‚Ð° Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ Ð»Ð¸ÑˆÐµ Ð²Ñ–Ð·ÑƒÐ°Ð»ÑŒÐ½Ð¸Ð¹ ÐµÑ„ÐµÐºÑ‚.`,
  _C = p => `Cá» cá»§a <b>${p.country}</b> khÃ´ng cÃ³ khu vá»±c tÆ°Æ¡ng á»©ng trÃªn báº£n Ä‘á»“ vÃ  chá»‰ cÃ³ tÃ¡c dá»¥ng trang trÃ­.`,
  mC = (p, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? iC(p) : r === "pt" ? aC(p) : r === "ch" ? oC(p) : r === "de" ? sC(p) : r === "es" ? lC(p) : r === "fr" ? cC(p) : r === "it" ? uC(p) : r === "jp" ? hC(p) : r === "pl" ? dC(p) : r === "ru" ? pC(p) : r === "uk" ? fC(p) : _C(p)
  },
  gC = () => "Flag without region on the map",
  vC = () => "Bandeira sem regiÃ£o no mapa",
  yC = () => "æ— åœ°å›¾åŒºåŸŸçš„å›½æ——",
  bC = () => "Flagge ohne Region auf der Karte",
  xC = () => "Bandera sin regiÃ³n en el mapa",
  wC = () => "Drapeau sans rÃ©gion sur la carte",
  kC = () => "Bandiera senza regione sulla mappa",
  TC = () => "ãƒžãƒƒãƒ—ã«å¯¾å¿œã™ã‚‹åœ°åŸŸã®ãªã„æ——",
  SC = () => "Flaga bez regionu na mapie",
  PC = () => "Ð¤Ð»Ð°Ð³ Ð±ÐµÐ· Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° Ð½Ð° ÐºÐ°Ñ€Ñ‚Ðµ",
  MC = () => "ÐŸÑ€Ð°Ð¿Ð¾Ñ€ Ð±ÐµÐ· Ñ€ÐµÐ³Ñ–Ð¾Ð½Ñƒ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ñ–",
  IC = () => "Cá» khÃ´ng cÃ³ vÃ¹ng trÃªn báº£n Ä‘á»“",
  CC = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? gC() : r === "pt" ? vC() : r === "ch" ? yC() : r === "de" ? bC() : r === "es" ? xC() : r === "fr" ? wC() : r === "it" ? kC() : r === "jp" ? TC() : r === "pl" ? SC() : r === "ru" ? PC() : r === "uk" ? MC() : IC()
  },
  zC = () => "Follow the instructions to enable hardware acceleration",
  AC = () => "Siga a instruÃ§Ã£o para habilitar a aceleraÃ§Ã£o de hardware",
  EC = () => "è¯·æŒ‰ç…§è¯´æ˜Žå¯ç”¨ç¡¬ä»¶åŠ é€Ÿ",
  LC = () => "Folge den Anweisungen, um Hardwarebeschleunigung zu aktivieren",
  DC = () => "Sigue las instrucciones para habilitar la aceleraciÃ³n por hardware",
  RC = () => "Suivez les instructions pour activer lâ€™accÃ©lÃ©ration matÃ©rielle",
  jC = () => "Segui le istruzioni per abilitare l'accelerazione hardware",
  FC = () => "ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹ã«ã™ã‚‹æ‰‹é †ã«å¾“ã£ã¦ãã ã•ã„ã€‚",
  BC = () => "PostÄ™puj zgodnie z instrukcjami, aby wÅ‚Ä…czyÄ‡ akceleracjÄ™ sprzÄ™towÄ…",
  OC = () => "Ð¡Ð»ÐµÐ´ÑƒÐ¹Ñ‚Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸ÑÐ¼, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð°Ð¿Ð¿Ð°Ñ€Ð°Ñ‚Ð½Ð¾Ðµ ÑƒÑÐºÐ¾Ñ€ÐµÐ½Ð¸Ðµ",
  qC = () => "Ð”Ð¾Ñ‚Ñ€Ð¸Ð¼ÑƒÐ¹Ñ‚ÐµÑÑŒ Ñ–Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ñ–Ð¹, Ñ‰Ð¾Ð± ÑƒÐ²Ñ–Ð¼ÐºÐ½ÑƒÑ‚Ð¸ Ð°Ð¿Ð°Ñ€Ð°Ñ‚Ð½Ðµ Ð¿Ñ€Ð¸ÑÐºÐ¾Ñ€ÐµÐ½Ð½Ñ",
  NC = () => "LÃ m theo hÆ°á»›ng dáº«n Ä‘á»ƒ báº­t tÄƒng tá»‘c pháº§n cá»©ng",
  VC = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? zC() : r === "pt" ? AC() : r === "ch" ? EC() : r === "de" ? LC() : r === "es" ? DC() : r === "fr" ? RC() : r === "it" ? jC() : r === "jp" ? FC() : r === "pl" ? BC() : r === "ru" ? OC() : r === "uk" ? qC() : NC()
  },
  UC = () => "For more details, see our",
  ZC = () => "Para mais detalhes, veja nossa",
  GC = () => "æ›´å¤šè¯¦æƒ…è¯·å‚é˜…æˆ‘ä»¬çš„",
  WC = () => "FÃ¼r weitere Details siehe unsere",
  HC = () => "Para mÃ¡s detalles, consulta nuestra",
  $C = () => "Pour plus de dÃ©tails, consultez notre",
  XC = () => "Per maggiori dettagli, consulta la nostra",
  YC = () => "è©³ã—ãã¯ã€ã“ã¡ã‚‰ã‚’ã”è¦§ãã ã•ã„:",
  KC = () => "Po wiÄ™cej informacji zobacz naszÄ…",
  JC = () => "ÐŸÐ¾Ð´Ñ€Ð¾Ð±Ð½ÐµÐµ ÑÐ¼. Ð² Ð½Ð°ÑˆÐ¸Ñ…",
  QC = () => "Ð”Ð»Ñ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð½Ñ Ð´Ð¾Ð´Ð°Ñ‚ÐºÐ¾Ð²Ð¾Ñ— Ñ–Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ— Ð¿ÐµÑ€ÐµÐ³Ð»ÑÐ½ÑŒÑ‚Ðµ Ð½Ð°ÑˆÑ–",
  e6 = () => "Äá»ƒ biáº¿t thÃªm chi tiáº¿t, hÃ£y xem",
  t6 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? UC() : r === "pt" ? ZC() : r === "ch" ? GC() : r === "de" ? WC() : r === "es" ? HC() : r === "fr" ? $C() : r === "it" ? XC() : r === "jp" ? YC() : r === "pl" ? KC() : r === "ru" ? JC() : r === "uk" ? QC() : e6()
  },
  r6 = () => "Get invited to an alliance",
  n6 = () => "Seja convidado para uma alianÃ§a",
  i6 = () => "é€šè¿‡é‚€è¯·åŠ å…¥è”ç›Ÿ",
  a6 = () => "Lass dich in eine Allianz einladen",
  o6 = () => "Recibe una invitaciÃ³n para una alianza",
  s6 = () => "Recevoir une invitation dans une alliance",
  l6 = () => "Fatti invitare in un'alleanza",
  c6 = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‹›å¾…ã—ã¦ã‚‚ã‚‰ã†",
  u6 = () => "ZostaÅ„ zaproszony do sojuszu",
  h6 = () => "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸Ð³Ð»Ð°ÑˆÐµÐ½Ð¸Ðµ Ð² Ð°Ð»ÑŒÑÐ½Ñ",
  d6 = () => "ÐžÑ‚Ñ€Ð¸Ð¼Ð°Ð¹Ñ‚Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑˆÐµÐ½Ð½Ñ Ð² Ð°Ð»ÑŒÑÐ½Ñ",
  p6 = () => "Nháº­n lá»i má»i vÃ o má»™t liÃªn minh",
  f6 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? r6() : r === "pt" ? n6() : r === "ch" ? i6() : r === "de" ? a6() : r === "es" ? o6() : r === "fr" ? s6() : r === "it" ? l6() : r === "jp" ? c6() : r === "pl" ? u6() : r === "ru" ? h6() : r === "uk" ? d6() : p6()
  },
  _6 = () => "Get more charges",
  m6 = () => "Recarregue tinta para pintar",
  g6 = () => "èŽ·å¾—æ›´å¤šå……èƒ½",
  v6 = () => "Mehr Pixel-Ladungen bekommen",
  y6 = () => "Obtener mÃ¡s cargas",
  b6 = () => "Obtenir plus de charges",
  x6 = () => "Ricarica la vernice per dipingere",
  w6 = () => "ãƒãƒ£ãƒ¼ã‚¸ã‚’è¿½åŠ ã§ç²å¾—",
  k6 = () => "ZdobÄ…dÅº wiÄ™cej Å‚adunkÃ³w",
  T6 = () => "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð·Ð°Ñ€ÑÐ´Ð¾Ð²",
  S6 = () => "ÐžÑ‚Ñ€Ð¸Ð¼Ð°Ñ‚Ð¸ Ð±Ñ–Ð»ÑŒÑˆÐµ Ð·Ð°Ñ€ÑÐ´Ñ–Ð²",
  P6 = () => "Nháº­n thÃªm lÆ°á»£t tÃ´",
  M6 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? _6() : r === "pt" ? m6() : r === "ch" ? g6() : r === "de" ? v6() : r === "es" ? y6() : r === "fr" ? b6() : r === "it" ? x6() : r === "jp" ? w6() : r === "pl" ? k6() : r === "ru" ? T6() : r === "uk" ? S6() : P6()
  },
  I6 = () => "Give admin",
  C6 = () => "Tornar admin",
  z6 = () => "æŽˆäºˆç®¡ç†å‘˜",
  A6 = () => "Admin vergeben",
  E6 = () => "Dar admin",
  L6 = () => "Donner le rÃ´le admin",
  D6 = () => "Rendi admin",
  R6 = () => "ç®¡ç†è€…ã«ã™ã‚‹",
  j6 = () => "Nadaj uprawnienia admina",
  F6 = () => "Ð¡Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð°Ð´Ð¼Ð¸Ð½Ð¾Ð¼",
  B6 = () => "ÐÐ°Ð´Ð°Ñ‚Ð¸ Ð°Ð´Ð¼Ñ–Ð½-Ð¿Ñ€Ð°Ð²Ð°",
  O6 = () => "GÃ¡n quyá»n admin",
  q6 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? I6() : r === "pt" ? C6() : r === "ch" ? z6() : r === "de" ? A6() : r === "es" ? E6() : r === "fr" ? L6() : r === "it" ? D6() : r === "jp" ? R6() : r === "pl" ? j6() : r === "ru" ? F6() : r === "uk" ? B6() : O6()
  },
  N6 = () => "Giving admin to user",
  V6 = () => "Tornar usuÃ¡rio um admin",
  U6 = () => "æ­£åœ¨æŽˆäºˆç®¡ç†å‘˜æƒé™",
  Z6 = () => "Vergebe Admin-Rechte an Benutzer",
  G6 = () => "Otorgando admin al usuario",
  W6 = () => "Attribution du rÃ´le admin Ã  lâ€™utilisateur",
  H6 = () => "Assegnazione permessi admin all'utente",
  $6 = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç®¡ç†è€…æ¨©é™ã‚’ä»˜ä¸Žä¸­",
  X6 = () => "Nadawanie uprawnieÅ„ admina uÅ¼ytkownikowi",
  Y6 = () => "Ð’Ñ‹Ð´Ð°Ñ‡Ð° Ð¿Ñ€Ð°Ð² Ð°Ð´Ð¼Ð¸Ð½Ð° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ",
  K6 = () => "ÐÐ°Ð´Ð°Ð½Ð½Ñ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ñƒ Ð¿Ñ€Ð°Ð² Ð°Ð´Ð¼Ñ–Ð½Ñ–ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€Ð°",
  J6 = () => "Äang gÃ¡n quyá»n admin cho ngÆ°á»i dÃ¹ng",
  Q6 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? N6() : r === "pt" ? V6() : r === "ch" ? U6() : r === "de" ? Z6() : r === "es" ? G6() : r === "fr" ? W6() : r === "it" ? H6() : r === "jp" ? $6() : r === "pl" ? X6() : r === "ru" ? Y6() : r === "uk" ? K6() : J6()
  },
  ez = () => "Headquarters",
  tz = () => "Quartel General",
  rz = () => "æ€»éƒ¨",
  nz = () => "Hauptquartier",
  iz = () => "Cuartel general",
  az = () => "Quartier gÃ©nÃ©ral",
  oz = () => "Quartier generale",
  sz = () => "æ‹ ç‚¹",
  lz = () => "Siedziba",
  cz = () => "Ð¨Ñ‚Ð°Ð±-ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ñ€Ð°",
  uz = () => "Ð¨Ñ‚Ð°Ð±-ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ñ€Ð°",
  hz = () => "Trá»¥ sá»Ÿ",
  dz = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ez() : r === "pt" ? tz() : r === "ch" ? rz() : r === "de" ? nz() : r === "es" ? iz() : r === "fr" ? az() : r === "it" ? oz() : r === "jp" ? sz() : r === "pl" ? lz() : r === "ru" ? cz() : r === "uk" ? uz() : hz()
  },
  pz = () => "Hide pixel art",
  fz = () => "Esconder Pixel Art",
  _z = () => "éšè—åƒç´ ç”»",
  mz = () => "Pixel-Art ausblenden",
  gz = () => "Ocultar pixel art",
  vz = () => "Masquer le pixel art",
  yz = () => "Nascondi Pixel Art",
  bz = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚¢ãƒ¼ãƒˆã‚’éžè¡¨ç¤º",
  xz = () => "Ukryj pixel art",
  wz = () => "Ð¡ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ-Ð°Ñ€Ñ‚",
  kz = () => "ÐŸÑ€Ð¸Ñ…Ð¾Ð²Ð°Ñ‚Ð¸ Ð¿Ñ–ÐºÑÐµÐ»ÑŒ-Ð°Ñ€Ñ‚",
  Tz = () => "áº¨n pixel art",
  Sz = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? pz() : r === "pt" ? fz() : r === "ch" ? _z() : r === "de" ? mz() : r === "es" ? gz() : r === "fr" ? vz() : r === "it" ? yz() : r === "jp" ? bz() : r === "pl" ? xz() : r === "ru" ? wz() : r === "uk" ? kz() : Tz()
  },
  Pz = () => "Hide UI",
  Mz = () => "Esconder UI",
  Iz = () => "éšè—ç•Œé¢",
  Cz = () => "UI ausblenden",
  zz = () => "Ocultar UI",
  Az = () => "Masquer lâ€™interface",
  Ez = () => "Nascondi UI",
  Lz = () => "UIã‚’éš ã™",
  Dz = () => "Ukryj interfejs",
  Rz = () => "Ð¡ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ",
  jz = () => "ÐŸÑ€Ð¸Ñ…Ð¾Ð²Ð°Ñ‚Ð¸ Ñ–Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ",
  Fz = () => "áº¨n giao diá»‡n",
  Bz = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Pz() : r === "pt" ? Mz() : r === "ch" ? Iz() : r === "de" ? Cz() : r === "es" ? zz() : r === "fr" ? Az() : r === "it" ? Ez() : r === "jp" ? Lz() : r === "pl" ? Dz() : r === "ru" ? Rz() : r === "uk" ? jz() : Fz()
  },
  Oz = () => "Hold",
  qz = () => "Segure",
  Nz = () => "æŒ‰ä½",
  Vz = () => "Halten",
  Uz = () => "Mantener",
  Zz = () => "Maintenir",
  Gz = () => "Tieni premuto",
  Wz = () => "é•·æŠ¼ã—",
  Hz = () => "Przytrzymaj",
  $z = () => "Ð£Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°Ñ‚ÑŒ",
  Xz = () => "Ð£Ñ‚Ñ€Ð¸Ð¼ÑƒÐ¹Ñ‚Ðµ",
  Yz = () => "Giá»¯",
  Kz = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Oz() : r === "pt" ? qz() : r === "ch" ? Nz() : r === "de" ? Vz() : r === "es" ? Uz() : r === "fr" ? Zz() : r === "it" ? Gz() : r === "jp" ? Wz() : r === "pl" ? Hz() : r === "ru" ? $z() : r === "uk" ? Xz() : Yz()
  },
  Jz = () => "How to paint faster",
  Qz = () => "Como pintar mais rÃ¡pido",
  eA = () => "å¦‚ä½•æ›´å¿«åœ°ç»˜åˆ¶",
  tA = () => "Wie man schneller malt",
  rA = () => "CÃ³mo pintar mÃ¡s rÃ¡pido",
  nA = () => "Comment peindre plus vite",
  iA = () => "Come dipingere piÃ¹ velocemente",
  aA = () => "æ—©ãå¡—ã‚‹ã«ã¯",
  oA = () => "Jak malowaÄ‡ szybciej",
  sA = () => "ÐšÐ°Ðº Ñ€Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ Ð±Ñ‹ÑÑ‚Ñ€ÐµÐµ",
  lA = () => "Ð¯Ðº Ð¼Ð°Ð»ÑŽÐ²Ð°Ñ‚Ð¸ ÑˆÐ²Ð¸Ð´ÑˆÐµ",
  cA = () => "CÃ¡ch tÃ´ nhanh hÆ¡n",
  uA = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Jz() : r === "pt" ? Qz() : r === "ch" ? eA() : r === "de" ? tA() : r === "es" ? rA() : r === "fr" ? nA() : r === "it" ? iA() : r === "jp" ? aA() : r === "pl" ? oA() : r === "ru" ? sA() : r === "uk" ? lA() : cA()
  },
  hA = () => "Image",
  dA = () => "Imagem",
  pA = () => "å›¾ç‰‡",
  fA = () => "Bild",
  _A = () => "Imagen",
  mA = () => "Image",
  gA = () => "Immagine",
  vA = () => "ç”»åƒ",
  yA = () => "Obraz",
  bA = () => "Ð˜Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ",
  xA = () => "Ð—Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ",
  wA = () => "HÃ¬nh áº£nh",
  kA = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? hA() : r === "pt" ? dA() : r === "ch" ? pA() : r === "de" ? fA() : r === "es" ? _A() : r === "fr" ? mA() : r === "it" ? gA() : r === "jp" ? vA() : r === "pl" ? yA() : r === "ru" ? bA() : r === "uk" ? xA() : wA()
  },
  TA = () => "Image copied to clipboard",
  SA = () => "Imagem copiada para a Ã¡rea de transferÃªncia",
  PA = () => "å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿",
  MA = () => "Bild in die Zwischenablage kopiert",
  IA = () => "Imagen copiada al portapapeles",
  CA = () => "Image copiÃ©e dans le presse-papiers",
  zA = () => "Immagine copiata negli appunti",
  AA = () => "ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  EA = () => "Obraz skopiowany do schowka",
  LA = () => "Ð˜Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°",
  DA = () => "Ð—Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ ÑÐºÐ¾Ð¿Ñ–Ð¹Ð¾Ð²Ð°Ð½Ð¾ Ð´Ð¾ Ð±ÑƒÑ„ÐµÑ€Ð° Ð¾Ð±Ð¼Ñ–Ð½Ñƒ",
  RA = () => "ÄÃ£ sao chÃ©p hÃ¬nh áº£nh vÃ o clipboard",
  jA = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? TA() : r === "pt" ? SA() : r === "ch" ? PA() : r === "de" ? MA() : r === "es" ? IA() : r === "fr" ? CA() : r === "it" ? zA() : r === "jp" ? AA() : r === "pl" ? EA() : r === "ru" ? LA() : r === "uk" ? DA() : RA()
  },
  FA = () => "Important",
  BA = () => "Importante",
  OA = () => "é‡è¦",
  qA = () => "Wichtig",
  NA = () => "Importante",
  VA = () => "Important",
  UA = () => "Importante",
  ZA = () => "é‡è¦",
  GA = () => "WaÅ¼ne",
  WA = () => "Ð’Ð°Ð¶Ð½Ð¾",
  HA = () => "Ð’Ð°Ð¶Ð»Ð¸Ð²Ð¾",
  $A = () => "Quan trá»ng",
  XA = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? FA() : r === "pt" ? BA() : r === "ch" ? OA() : r === "de" ? qA() : r === "es" ? NA() : r === "fr" ? VA() : r === "it" ? UA() : r === "jp" ? ZA() : r === "pl" ? GA() : r === "ru" ? WA() : r === "uk" ? HA() : $A()
  },
  YA = () => "Increase your maximum paint charges capacity",
  KA = () => "Aumente sua capacidade mÃ¡xima de tinta",
  JA = () => "æå‡ä½ çš„æœ€å¤§ç»˜åˆ¶å……èƒ½ä¸Šé™",
  QA = () => "ErhÃ¶he deine maximale Anzahl an Pixel-Ladungen",
  eE = () => "Aumenta tu capacidad mÃ¡xima de cargas de pintura",
  tE = () => "Augmentez votre capacitÃ© maximale de charges de peinture",
  rE = () => "Aumenta la tua capacitÃ  massima di vernice",
  nE = () => "ãƒšã‚¤ãƒ³ãƒˆã®æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸æ•°ã‚’å¢—ã‚„ã™",
  iE = () => "ZwiÄ™ksz maksymalnÄ… pojemnoÅ›Ä‡ Å‚adunkÃ³w malowania",
  aE = () => "Ð£Ð²ÐµÐ»Ð¸Ñ‡ÑŒÑ‚Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð·Ð°Ñ€ÑÐ´Ð¾Ð²",
  oE = () => "Ð—Ð±Ñ–Ð»ÑŒÑˆÑ‚Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ñƒ ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ Ð·Ð°Ñ€ÑÐ´Ñ–Ð² Ñ„Ð°Ñ€Ð±Ð¸",
  sE = () => "TÄƒng sá»‘ lÆ°á»£t tÃ´ tá»‘i Ä‘a",
  lE = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? YA() : r === "pt" ? KA() : r === "ch" ? JA() : r === "de" ? QA() : r === "es" ? eE() : r === "fr" ? tE() : r === "it" ? rE() : r === "jp" ? nE() : r === "pl" ? iE() : r === "ru" ? aE() : r === "uk" ? oE() : sE()
  },
  cE = () => "Info",
  uE = () => "InformaÃ§Ãµes",
  hE = () => "ä¿¡æ¯",
  dE = () => "Info",
  pE = () => "Info",
  fE = () => "Infos",
  _E = () => "Informazioni",
  mE = () => "æƒ…å ±",
  gE = () => "Informacje",
  vE = () => "Ð˜Ð½Ñ„Ð¾",
  yE = () => "Ð†Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ",
  bE = () => "ThÃ´ng tin",
  xE = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? cE() : r === "pt" ? uE() : r === "ch" ? hE() : r === "de" ? dE() : r === "es" ? pE() : r === "fr" ? fE() : r === "it" ? _E() : r === "jp" ? mE() : r === "pl" ? gE() : r === "ru" ? vE() : r === "uk" ? yE() : bE()
  },
  wE = () => "Install App",
  kE = () => "Instalar App",
  TE = () => "å®‰è£…åº”ç”¨",
  SE = () => "App installieren",
  PE = () => "Instalar app",
  ME = () => "Installer lâ€™application",
  IE = () => "Installa app",
  CE = () => "ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«",
  zE = () => "Zainstaluj aplikacjÄ™",
  AE = () => "Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ",
  EE = () => "Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ð¸ Ð·Ð°ÑÑ‚Ð¾ÑÑƒÐ½Ð¾Ðº",
  LE = () => "CÃ i Ä‘áº·t á»©ng dá»¥ng",
  DE = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? wE() : r === "pt" ? kE() : r === "ch" ? TE() : r === "de" ? SE() : r === "es" ? PE() : r === "fr" ? ME() : r === "it" ? IE() : r === "jp" ? CE() : r === "pl" ? zE() : r === "ru" ? AE() : r === "uk" ? EE() : LE()
  },
  RE = () => "Invite",
  jE = () => "Convite",
  FE = () => "é‚€è¯·",
  BE = () => "Einladen",
  OE = () => "Invitar",
  qE = () => "Invitation",
  NE = () => "Invito",
  VE = () => "æ‹›å¾…",
  UE = () => "ZaproÅ›",
  ZE = () => "ÐŸÑ€Ð¸Ð³Ð»Ð°ÑÐ¸Ñ‚ÑŒ",
  GE = () => "Ð—Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚Ð¸",
  WE = () => "Má»i",
  HE = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? RE() : r === "pt" ? jE() : r === "ch" ? FE() : r === "de" ? BE() : r === "es" ? OE() : r === "fr" ? qE() : r === "it" ? NE() : r === "jp" ? VE() : r === "pl" ? UE() : r === "ru" ? ZE() : r === "uk" ? GE() : WE()
  },
  $E = () => "Invite link",
  XE = () => "Link de convite",
  YE = () => "é‚€è¯·é“¾æŽ¥",
  KE = () => "Einladungslink",
  JE = () => "Enlace de invitaciÃ³n",
  QE = () => "Lien dâ€™invitation",
  e8 = () => "Link di invito",
  t8 = () => "æ‹›å¾…ãƒªãƒ³ã‚¯",
  r8 = () => "Link zaproszenia",
  n8 = () => "Ð¡ÑÑ‹Ð»ÐºÐ°-Ð¿Ñ€Ð¸Ð³Ð»Ð°ÑˆÐµÐ½Ð¸Ðµ",
  i8 = () => "ÐŸÐ¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ-Ð·Ð°Ð¿Ñ€Ð¾ÑˆÐµÐ½Ð½Ñ",
  a8 = () => "LiÃªn káº¿t má»i",
  o8 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? $E() : r === "pt" ? XE() : r === "ch" ? YE() : r === "de" ? KE() : r === "es" ? JE() : r === "fr" ? QE() : r === "it" ? e8() : r === "jp" ? t8() : r === "pl" ? r8() : r === "ru" ? n8() : r === "uk" ? i8() : a8()
  },
  s8 = () => "is enabled on",
  l8 = () => "estÃ¡ habilitado em",
  c8 = () => "å·²åœ¨æ­¤å¯ç”¨ï¼š",
  u8 = () => "aktiviert ist auf",
  h8 = () => "estÃ¡ habilitado en",
  d8 = () => "est activÃ© sur",
  p8 = () => "Ã¨ abilitato su",
  f8 = () => "ã¯æ¬¡ã§æœ‰åŠ¹ã§ã™:",
  _8 = () => "jest wÅ‚Ä…czone na",
  m8 = () => "Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾ Ð½Ð°",
  g8 = () => "ÑƒÐ²Ñ–Ð¼ÐºÐ½ÐµÐ½Ð¾ Ð½Ð°",
  v8 = () => "Ä‘Æ°á»£c báº­t trÃªn",
  y8 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? s8() : r === "pt" ? l8() : r === "ch" ? c8() : r === "de" ? u8() : r === "es" ? h8() : r === "fr" ? d8() : r === "it" ? p8() : r === "jp" ? f8() : r === "pl" ? _8() : r === "ru" ? m8() : r === "uk" ? g8() : v8()
  },
  b8 = () => "Items",
  x8 = () => "Itens",
  w8 = () => "ç‰©å“",
  k8 = () => "Items",
  T8 = () => "Ãtems",
  S8 = () => "Objets",
  P8 = () => "Oggetti",
  M8 = () => "ã‚¢ã‚¤ãƒ†ãƒ ",
  I8 = () => "Przedmioty",
  C8 = () => "ÐŸÑ€ÐµÐ´Ð¼ÐµÑ‚Ñ‹",
  z8 = () => "ÐŸÑ€ÐµÐ´Ð¼ÐµÑ‚Ð¸",
  A8 = () => "Váº­t pháº©m",
  E8 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? b8() : r === "pt" ? x8() : r === "ch" ? w8() : r === "de" ? k8() : r === "es" ? T8() : r === "fr" ? S8() : r === "it" ? P8() : r === "jp" ? M8() : r === "pl" ? I8() : r === "ru" ? C8() : r === "uk" ? z8() : A8()
  },
  L8 = () => "Leave alliance",
  D8 = () => "Sair da alianÃ§a",
  R8 = () => "ç¦»å¼€è”ç›Ÿ",
  j8 = () => "Allianz verlassen",
  F8 = () => "Salir de la alianza",
  B8 = () => "Quitter lâ€™alliance",
  O8 = () => "Esci dall'alleanza",
  q8 = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’æŠœã‘ã‚‹",
  N8 = () => "OpuÅ›Ä‡ sojusz",
  V8 = () => "Ð’Ñ‹Ð¹Ñ‚Ð¸ Ð¸Ð· Ð°Ð»ÑŒÑÐ½ÑÐ°",
  U8 = () => "Ð’Ð¸Ð¹Ñ‚Ð¸ Ð· Ð°Ð»ÑŒÑÐ½ÑÑƒ",
  Z8 = () => "Rá»i liÃªn minh",
  G8 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? L8() : r === "pt" ? D8() : r === "ch" ? R8() : r === "de" ? j8() : r === "es" ? F8() : r === "fr" ? B8() : r === "it" ? O8() : r === "jp" ? q8() : r === "pl" ? N8() : r === "ru" ? V8() : r === "uk" ? U8() : Z8()
  },
  W8 = () => "Light mode",
  H8 = () => "Modo claro",
  $8 = () => "æµ…è‰²æ¨¡å¼",
  X8 = () => "Heller Modus",
  Y8 = () => "Modo claro",
  K8 = () => "Mode clair",
  J8 = () => "Tema chiaro",
  Q8 = () => "ãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒž",
  eL = () => "Tryb jasny",
  tL = () => "Ð¡Ð²ÐµÑ‚Ð»Ð°Ñ Ñ‚ÐµÐ¼Ð°",
  rL = () => "Ð¡Ð²Ñ–Ñ‚Ð»Ð° Ñ‚ÐµÐ¼Ð°",
  nL = () => "Cháº¿ Ä‘á»™ sÃ¡ng",
  iL = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? W8() : r === "pt" ? H8() : r === "ch" ? $8() : r === "de" ? X8() : r === "es" ? Y8() : r === "fr" ? K8() : r === "it" ? J8() : r === "jp" ? Q8() : r === "pl" ? eL() : r === "ru" ? tL() : r === "uk" ? rL() : nL()
  },
  aL = () => "Limit reached",
  oL = () => "Limite atingido",
  sL = () => "å·²è¾¾åˆ°ä¸Šé™",
  lL = () => "Limit erreicht",
  cL = () => "LÃ­mite alcanzado",
  uL = () => "Limite atteinte",
  hL = () => "Limite raggiunto",
  dL = () => "ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚",
  pL = () => "OsiÄ…gniÄ™to limit",
  fL = () => "Ð”Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚ Ð»Ð¸Ð¼Ð¸Ñ‚",
  _L = () => "Ð”Ð¾ÑÑÐ³Ð½ÑƒÑ‚Ð¾ Ð»Ñ–Ð¼Ñ–Ñ‚",
  mL = () => "ÄÃ£ Ä‘áº¡t giá»›i háº¡n",
  gL = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? aL() : r === "pt" ? oL() : r === "ch" ? sL() : r === "de" ? lL() : r === "es" ? cL() : r === "fr" ? uL() : r === "it" ? hL() : r === "jp" ? dL() : r === "pl" ? pL() : r === "ru" ? fL() : r === "uk" ? _L() : mL()
  },
  vL = () => "Link your Discord",
  yL = () => "Conectar Discord",
  bL = () => "å…³è”ä½ çš„ Discord",
  xL = () => "Discord verknÃ¼pfen",
  wL = () => "Vincular Discord",
  kL = () => "Lier votre Discord",
  TL = () => "Collega Discord",
  SL = () => "Discordã‚’é€£æºã™ã‚‹",
  PL = () => "PoÅ‚Ä…cz Discord",
  ML = () => "ÐŸÑ€Ð¸Ð²ÑÐ·Ð°Ñ‚ÑŒ Discord",
  IL = () => "ÐŸÑ€Ð¸Ð²Ê¼ÑÐ·Ð°Ñ‚Ð¸ Discord",
  CL = () => "LiÃªn káº¿t Discord",
  zL = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? vL() : r === "pt" ? yL() : r === "ch" ? bL() : r === "de" ? xL() : r === "es" ? wL() : r === "fr" ? kL() : r === "it" ? TL() : r === "jp" ? SL() : r === "pl" ? PL() : r === "ru" ? ML() : r === "uk" ? IL() : CL()
  },
  AL = () => "Location favorited",
  EL = () => "LocalizaÃ§Ã£o favoritada",
  LL = () => "ä½ç½®å·²æ”¶è—",
  DL = () => "Ort favorisiert",
  RL = () => "UbicaciÃ³n agregada a favoritos",
  jL = () => "Emplacement ajoutÃ© aux favoris",
  FL = () => "LocalitÃ  aggiunta ai preferiti",
  BL = () => "å ´æ‰€ã‚’ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã—ã¾ã—ãŸã€‚",
  OL = () => "Lokalizacja dodana do ulubionych",
  qL = () => "Ð›Ð¾ÐºÐ°Ñ†Ð¸Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð° Ð² Ð¸Ð·Ð±Ñ€Ð°Ð½Ð½Ð¾Ðµ",
  NL = () => "Ð›Ð¾ÐºÐ°Ñ†Ñ–ÑŽ Ð´Ð¾Ð´Ð°Ð½Ð¾ Ð´Ð¾ Ð²Ð¸Ð±Ñ€Ð°Ð½Ð¸Ñ…",
  VL = () => "ÄÃ£ thÃªm vá»‹ trÃ­ vÃ o yÃªu thÃ­ch",
  UL = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? AL() : r === "pt" ? EL() : r === "ch" ? LL() : r === "de" ? DL() : r === "es" ? RL() : r === "fr" ? jL() : r === "it" ? FL() : r === "jp" ? BL() : r === "pl" ? OL() : r === "ru" ? qL() : r === "uk" ? NL() : VL()
  },
  ZL = () => "Location unfavorited",
  GL = () => "LocalizaÃ§Ã£o desfavoritada",
  WL = () => "ä½ç½®å·²å–æ¶ˆæ”¶è—",
  HL = () => "Ort aus Favoriten entfernt",
  $L = () => "UbicaciÃ³n eliminada de favoritos",
  XL = () => "Emplacement retirÃ© des favoris",
  YL = () => "LocalitÃ  rimossa dai preferiti",
  KL = () => "å ´æ‰€ã®ãŠæ°—ã«å…¥ã‚Šã‚’è§£é™¤ã—ã¾ã—ãŸã€‚",
  JL = () => "Lokalizacja usuniÄ™ta z ulubionych",
  QL = () => "Ð›Ð¾ÐºÐ°Ñ†Ð¸Ñ ÑƒÐ´Ð°Ð»ÐµÐ½Ð° Ð¸Ð· Ð¸Ð·Ð±Ñ€Ð°Ð½Ð½Ð¾Ð³Ð¾",
  eD = () => "Ð›Ð¾ÐºÐ°Ñ†Ñ–ÑŽ Ð²Ð¸Ð»ÑƒÑ‡ÐµÐ½Ð¾ Ð· Ð²Ð¸Ð±Ñ€Ð°Ð½Ð¸Ñ…",
  tD = () => "ÄÃ£ bá» yÃªu thÃ­ch vá»‹ trÃ­",
  rD = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ZL() : r === "pt" ? GL() : r === "ch" ? WL() : r === "de" ? HL() : r === "es" ? $L() : r === "fr" ? XL() : r === "it" ? YL() : r === "jp" ? KL() : r === "pl" ? JL() : r === "ru" ? QL() : r === "uk" ? eD() : tD()
  },
  nD = () => "Lock",
  iD = () => "Travar",
  aD = () => "é”å®š",
  oD = () => "Sperren",
  sD = () => "Bloquear",
  lD = () => "Verrouiller",
  cD = () => "Blocca",
  uD = () => "ãƒ­ãƒƒã‚¯",
  hD = () => "Zablokuj",
  dD = () => "Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
  pD = () => "Ð—Ð°Ð±Ð»Ð¾ÐºÑƒÐ²Ð°Ñ‚Ð¸",
  fD = () => "KhÃ³a",
  _D = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? nD() : r === "pt" ? iD() : r === "ch" ? aD() : r === "de" ? oD() : r === "es" ? sD() : r === "fr" ? lD() : r === "it" ? cD() : r === "jp" ? uD() : r === "pl" ? hD() : r === "ru" ? dD() : r === "uk" ? pD() : fD()
  },
  mD = () => "Log in",
  gD = () => "Entrar",
  vD = () => "ç™»å½•",
  yD = () => "Einloggen",
  bD = () => "Iniciar sesiÃ³n",
  xD = () => "Se connecter",
  wD = () => "Accedi",
  kD = () => "ãƒ­ã‚°ã‚¤ãƒ³",
  TD = () => "Zaloguj siÄ™",
  SD = () => "Ð’Ð¾Ð¹Ñ‚Ð¸",
  PD = () => "Ð£Ð²Ñ–Ð¹Ñ‚Ð¸",
  MD = () => "ÄÄƒng nháº­p",
  ID = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? mD() : r === "pt" ? gD() : r === "ch" ? vD() : r === "de" ? yD() : r === "es" ? bD() : r === "fr" ? xD() : r === "it" ? wD() : r === "jp" ? kD() : r === "pl" ? TD() : r === "ru" ? SD() : r === "uk" ? PD() : MD()
  },
  CD = () => "Logged out",
  zD = () => "Logout feito",
  AD = () => "å·²ç™»å‡º",
  ED = () => "Ausgeloggt",
  LD = () => "SesiÃ³n cerrada",
  DD = () => "DÃ©connectÃ©",
  RD = () => "Logout effettuato",
  jD = () => "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚",
  FD = () => "Wylogowano",
  BD = () => "Ð’Ñ‹ Ð²Ñ‹ÑˆÐ»Ð¸ Ð¸Ð· Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°",
  OD = () => "Ð’Ð¸Ñ…Ñ–Ð´ Ð²Ð¸ÐºÐ¾Ð½Ð°Ð½Ð¾",
  qD = () => "ÄÃ£ Ä‘Äƒng xuáº¥t",
  ND = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? CD() : r === "pt" ? zD() : r === "ch" ? AD() : r === "de" ? ED() : r === "es" ? LD() : r === "fr" ? DD() : r === "it" ? RD() : r === "jp" ? jD() : r === "pl" ? FD() : r === "ru" ? BD() : r === "uk" ? OD() : qD()
  },
  VD = () => "This action will log your account out from all devices.",
  UD = () => "Essa aÃ§Ã£o ira desconectar sua conta de todos os dispositivos.",
  ZD = () => "æ­¤æ“ä½œå°†ä½¿ä½ çš„è´¦å·åœ¨æ‰€æœ‰è®¾å¤‡ä¸Šç™»å‡ºã€‚",
  GD = () => "Diese Aktion meldet dein Konto auf allen GerÃ¤ten ab.",
  WD = () => "Esta acciÃ³n cerrarÃ¡ tu sesiÃ³n en todos los dispositivos.",
  HD = () => "Cette action dÃ©connectera votre compte de tous les appareils.",
  $D = () => "Questa azione disconnetterÃ  il tuo account da tutti i dispositivi.",
  XD = () => "ã“ã®æ“ä½œã«ã‚ˆã‚Šã€ã™ã¹ã¦ã®ç«¯æœ«ã‹ã‚‰ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ­ã‚°ã‚¢ã‚¦ãƒˆã•ã‚Œã¾ã™ã€‚",
  YD = () => "Ta akcja wyloguje Twoje konto ze wszystkich urzÄ…dzeÅ„.",
  KD = () => "Ð­Ñ‚Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ñ‚ Ð²Ð°Ñˆ ÑÐµÐ°Ð½Ñ Ð½Ð° Ð²ÑÐµÑ… ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°Ñ….",
  JD = () => "Ð¦Ñ Ð´Ñ–Ñ Ð²Ð¸Ð²ÐµÐ´Ðµ Ð²Ð°Ñˆ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð· ÑƒÑÑ–Ñ… Ð¿Ñ€Ð¸ÑÑ‚Ñ€Ð¾Ñ—Ð².",
  QD = () => "HÃ nh Ä‘á»™ng nÃ y sáº½ Ä‘Äƒng xuáº¥t tÃ i khoáº£n cá»§a báº¡n khá»i táº¥t cáº£ thiáº¿t bá»‹.",
  eR = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? VD() : r === "pt" ? UD() : r === "ch" ? ZD() : r === "de" ? GD() : r === "es" ? WD() : r === "fr" ? HD() : r === "it" ? $D() : r === "jp" ? XD() : r === "pl" ? YD() : r === "ru" ? KD() : r === "uk" ? JD() : QD()
  },
  tR = () => "My map is lagging",
  rR = () => "Meu mapa estÃ¡ travando",
  nR = () => "æˆ‘çš„åœ°å›¾å¾ˆå¡",
  iR = () => "Meine Karte laggt",
  aR = () => "Mi mapa va con lag",
  oR = () => "Ma carte lag",
  sR = () => "La mia mappa Ã¨ lenta",
  lR = () => "ãƒžãƒƒãƒ—ã®å‹•ä½œãŒé‡ã„ã§ã™ã€‚",
  cR = () => "Mapa siÄ™ zacina",
  uR = () => "ÐšÐ°Ñ€Ñ‚Ð° Ñ‚Ð¾Ñ€Ð¼Ð¾Ð·Ð¸Ñ‚",
  hR = () => "ÐšÐ°Ñ€Ñ‚Ð° Ð³Ð°Ð»ÑŒÐ¼ÑƒÑ”",
  dR = () => "Báº£n Ä‘á»“ cá»§a tÃ´i Ä‘ang bá»‹ lag",
  pR = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? tR() : r === "pt" ? rR() : r === "ch" ? nR() : r === "de" ? iR() : r === "es" ? aR() : r === "fr" ? oR() : r === "it" ? sR() : r === "jp" ? lR() : r === "pl" ? cR() : r === "ru" ? uR() : r === "uk" ? hR() : dR()
  },
  fR = () => "Mark all as read",
  _R = () => "Marcar tudo como lido",
  mR = () => "å…¨éƒ¨æ ‡è®°ä¸ºå·²è¯»",
  gR = () => "Alle als gelesen markieren",
  vR = () => "Marcar todo como leÃ­do",
  yR = () => "Tout marquer comme lu",
  bR = () => "Segna tutto come letto",
  xR = () => "ã™ã¹ã¦æ—¢èª­ã«ã™ã‚‹",
  wR = () => "Oznacz wszystko jako przeczytane",
  kR = () => "ÐžÑ‚Ð¼ÐµÑ‚Ð¸Ñ‚ÑŒ Ð²ÑÑ‘ ÐºÐ°Ðº Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ð¾Ðµ",
  TR = () => "ÐŸÐ¾Ð·Ð½Ð°Ñ‡Ð¸Ñ‚Ð¸ Ð²ÑÐµ ÑÐº Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ðµ",
  SR = () => "ÄÃ¡nh dáº¥u táº¥t cáº£ lÃ  Ä‘Ã£ Ä‘á»c",
  PR = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? fR() : r === "pt" ? _R() : r === "ch" ? mR() : r === "de" ? gR() : r === "es" ? vR() : r === "fr" ? yR() : r === "it" ? bR() : r === "jp" ? xR() : r === "pl" ? wR() : r === "ru" ? kR() : r === "uk" ? TR() : SR()
  },
  MR = () => "+2 max. charge/niveau",
  IR = () => "+2 tinta mÃ¡xima/level",
  CR = () => "æ¯çº§ +2 æœ€å¤§å……èƒ½",
  zR = () => "+2 max. Ladung/Level",
  AR = () => "+2 carga mÃ¡xima/nivel",
  ER = () => "+2 charge max/niveau",
  LR = () => "+2 cariche massime/livello",
  DR = () => "ãƒ¬ãƒ™ãƒ«ã”ã¨ã«æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸ +2",
  RR = () => "+2 maks. Å‚adunkÃ³w na poziom",
  jR = () => "+2 Ð¼Ð°ÐºÑ. Ð·Ð°Ñ€ÑÐ´Ð°/ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ",
  FR = () => "+2 Ð¼Ð°ÐºÑ. Ð·Ð°Ñ€ÑÐ´/Ñ€Ñ–Ð²ÐµÐ½ÑŒ",
  BR = () => "+2 lÆ°á»£t tÃ´ tá»‘i Ä‘a má»—i cáº¥p",
  OR = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? MR() : r === "pt" ? IR() : r === "ch" ? CR() : r === "de" ? zR() : r === "es" ? AR() : r === "fr" ? ER() : r === "it" ? LR() : r === "jp" ? DR() : r === "pl" ? RR() : r === "ru" ? jR() : r === "uk" ? FR() : BR()
  },
  qR = () => "Menu",
  NR = () => "Menu",
  VR = () => "èœå•",
  UR = () => "MenÃ¼",
  ZR = () => "MenÃº",
  GR = () => "Menu",
  WR = () => "Menu",
  HR = () => "ãƒ¡ãƒ‹ãƒ¥ãƒ¼",
  $R = () => "Menu",
  XR = () => "ÐœÐµÐ½ÑŽ",
  YR = () => "ÐœÐµÐ½ÑŽ",
  KR = () => "Menu",
  JR = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? qR() : r === "pt" ? NR() : r === "ch" ? VR() : r === "de" ? UR() : r === "es" ? ZR() : r === "fr" ? GR() : r === "it" ? WR() : r === "jp" ? HR() : r === "pl" ? $R() : r === "ru" ? XR() : r === "uk" ? YR() : KR()
  },
  QR = () => "Month",
  ej = () => "MÃªs",
  tj = () => "æœˆ",
  rj = () => "Monat",
  nj = () => "Mes",
  ij = () => "Mois",
  aj = () => "Mese",
  oj = () => "æœˆ",
  sj = () => "MiesiÄ…c",
  lj = () => "ÐœÐµÑÑÑ†",
  cj = () => "ÐœÑ–ÑÑÑ†ÑŒ",
  uj = () => "ThÃ¡ng",
  hj = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? QR() : r === "pt" ? ej() : r === "ch" ? tj() : r === "de" ? rj() : r === "es" ? nj() : r === "fr" ? ij() : r === "it" ? aj() : r === "jp" ? oj() : r === "pl" ? sj() : r === "ru" ? lj() : r === "uk" ? cj() : uj()
  },
  dj = () => "More",
  pj = () => "Mais",
  fj = () => "æ›´å¤š",
  _j = () => "Mehr",
  mj = () => "MÃ¡s",
  gj = () => "Plus",
  vj = () => "Altro",
  yj = () => "ã‚‚ã£ã¨è¦‹ã‚‹",
  bj = () => "WiÄ™cej",
  xj = () => "Ð•Ñ‰Ñ‘",
  wj = () => "Ð‘Ñ–Ð»ÑŒÑˆÐµ",
  kj = () => "ThÃªm",
  Tj = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? dj() : r === "pt" ? pj() : r === "ch" ? fj() : r === "de" ? _j() : r === "es" ? mj() : r === "fr" ? gj() : r === "it" ? vj() : r === "jp" ? yj() : r === "pl" ? bj() : r === "ru" ? xj() : r === "uk" ? wj() : kj()
  },
  Sj = () => "Mute",
  Pj = () => "Mutar",
  Mj = () => "é™éŸ³",
  Ij = () => "Stummschalten",
  Cj = () => "Silenciar",
  zj = () => "Muet",
  Aj = () => "Muta",
  Ej = () => "ãƒŸãƒ¥ãƒ¼ãƒˆ",
  Lj = () => "Wycisz",
  Dj = () => "Ð—Ð°Ð¼ÑŒÑŽÑ‚Ð¸Ñ‚ÑŒ",
  Rj = () => "Ð—Ð°Ð³Ð»ÑƒÑˆÐ¸Ñ‚Ð¸",
  jj = () => "Táº¯t tiáº¿ng",
  Fj = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Sj() : r === "pt" ? Pj() : r === "ch" ? Mj() : r === "de" ? Ij() : r === "es" ? Cj() : r === "fr" ? zj() : r === "it" ? Aj() : r === "jp" ? Ej() : r === "pl" ? Lj() : r === "ru" ? Dj() : r === "uk" ? Rj() : jj()
  },
  Bj = () => "My location",
  Oj = () => "Minha localizaÃ§Ã£o",
  qj = () => "æˆ‘çš„ä½ç½®",
  Nj = () => "Mein Standort",
  Vj = () => "Mi ubicaciÃ³n",
  Uj = () => "Ma position",
  Zj = () => "La mia posizione",
  Gj = () => "ç¾åœ¨åœ°",
  Wj = () => "Moja lokalizacja",
  Hj = () => "ÐœÐ¾Ñ‘ Ð¼ÐµÑÑ‚Ð¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ",
  $j = () => "ÐœÐ¾Ñ” Ð¼Ñ–ÑÑ†ÐµÐ·Ð½Ð°Ñ…Ð¾Ð´Ð¶ÐµÐ½Ð½Ñ",
  Xj = () => "Vá»‹ trÃ­ cá»§a tÃ´i",
  Yj = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Bj() : r === "pt" ? Oj() : r === "ch" ? qj() : r === "de" ? Nj() : r === "es" ? Vj() : r === "fr" ? Uj() : r === "it" ? Zj() : r === "jp" ? Gj() : r === "pl" ? Wj() : r === "ru" ? Hj() : r === "uk" ? $j() : Xj()
  },
  Kj = () => "Name",
  Jj = () => "Nome",
  Qj = () => "åç§°",
  eF = () => "Name",
  tF = () => "Nombre",
  rF = () => "Nom",
  nF = () => "Nome",
  iF = () => "åå‰",
  aF = () => "Nazwa",
  oF = () => "Ð˜Ð¼Ñ",
  sF = () => "Ð†Ð¼Ê¼Ñ",
  lF = () => "TÃªn",
  s_ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Kj() : r === "pt" ? Jj() : r === "ch" ? Qj() : r === "de" ? eF() : r === "es" ? tF() : r === "fr" ? rF() : r === "it" ? nF() : r === "jp" ? iF() : r === "pl" ? aF() : r === "ru" ? oF() : r === "uk" ? sF() : lF()
  },
  cF = () => "Your name is how other users will see you in Wplace. It can be changed every 60 days.",
  uF = () => "Seu nome Ã© como outros usuÃ¡rios o verÃ£o no Wplace. VocÃª pode alterÃ¡-lo a cada 60 dias.",
  hF = () => "ä½ çš„åç§°æ˜¯å…¶ä»–çŽ©å®¶åœ¨ Wplace ä¸­çœ‹åˆ°çš„åå­—ã€‚æ¯ 60 å¤©å¯ä»¥æ›´æ”¹ä¸€æ¬¡ã€‚",
  dF = () => "Dein Name ist das, was andere Nutzer in Wplace sehen. Er kann alle 60 Tage geÃ¤ndert werden.",
  pF = () => "Tu nombre es cÃ³mo te verÃ¡n otros usuarios en Wplace. Se puede cambiar cada 60 dÃ­as.",
  fF = () => "Votre nom est celui que les autres utilisateurs verront dans Wplace. Vous pouvez le changer tous les 60 jours.",
  _F = () => "Il tuo nome Ã¨ come gli altri utenti ti vedranno su Wplace. Puoi cambiarlo ogni 60 giorni.",
  mF = () => "ã‚ãªãŸã®åå‰ã¯ã€Wplaceå†…ã§ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¡¨ç¤ºã•ã‚Œã‚‹åå‰ã§ã™ã€‚60æ—¥ã«ä¸€åº¦å¤‰æ›´ã§ãã¾ã™ã€‚",
  gF = () => "Twoje imiÄ™ to to, jak inni uÅ¼ytkownicy widzÄ… CiÄ™ w Wplace. MoÅ¼na je zmieniaÄ‡ co 60 dni.",
  vF = () => "Ð’Ð°ÑˆÐµ Ð¸Ð¼Ñ â€” Ñ‚Ð¾, ÐºÐ°Ðº Ð²Ð°Ñ Ð²Ð¸Ð´ÑÑ‚ Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ð¸ Ð² Wplace. Ð•Ð³Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¼ÐµÐ½ÑÑ‚ÑŒ Ñ€Ð°Ð· Ð² 60 Ð´Ð½ÐµÐ¹.",
  yF = () => "Ð’Ð°ÑˆÐµ Ñ–Ð¼Ê¼Ñ â€” Ñ†Ðµ Ñ‚Ðµ, ÑÐº Ñ–Ð½ÑˆÑ– ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ñ– Ð±Ð°Ñ‡Ð¸Ñ‚Ð¸Ð¼ÑƒÑ‚ÑŒ Ð²Ð°Ñ Ñƒ Wplace. Ð™Ð¾Ð³Ð¾ Ð¼Ð¾Ð¶Ð½Ð° Ð·Ð¼Ñ–Ð½ÑŽÐ²Ð°Ñ‚Ð¸ Ñ€Ð°Ð· Ð½Ð° 60 Ð´Ð½Ñ–Ð².",
  bF = () => "TÃªn lÃ  cÃ¡ch ngÆ°á»i chÆ¡i khÃ¡c nhÃ¬n tháº¥y báº¡n trong Wplace. Báº¡n cÃ³ thá»ƒ Ä‘á»•i tÃªn má»—i 60 ngÃ y.",
  xF = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? cF() : r === "pt" ? uF() : r === "ch" ? hF() : r === "de" ? dF() : r === "es" ? pF() : r === "fr" ? fF() : r === "it" ? _F() : r === "jp" ? mF() : r === "pl" ? gF() : r === "ru" ? vF() : r === "uk" ? yF() : bF()
  },
  wF = () => "No action",
  kF = () => "Sem opÃ§Ã£o",
  TF = () => "æ— æ“ä½œ",
  SF = () => "Keine Aktion",
  PF = () => "Sin acciÃ³n",
  MF = () => "Aucune action",
  IF = () => "Nessuna azione",
  CF = () => "å¯¾å¿œãªã—",
  zF = () => "Brak akcji",
  AF = () => "ÐÐµÑ‚ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ",
  EF = () => "ÐÐµÐ¼Ð°Ñ” Ð´Ñ–Ñ—",
  LF = () => "KhÃ´ng cÃ³ hÃ nh Ä‘á»™ng",
  DF = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? wF() : r === "pt" ? kF() : r === "ch" ? TF() : r === "de" ? SF() : r === "es" ? PF() : r === "fr" ? MF() : r === "it" ? IF() : r === "jp" ? CF() : r === "pl" ? zF() : r === "ru" ? AF() : r === "uk" ? EF() : LF()
  },
  RF = () => "No banned users",
  jF = () => "Sem usuÃ¡rios banidos",
  FF = () => "æ²¡æœ‰è¢«å°ç¦çš„ç”¨æˆ·",
  BF = () => "Keine gebannten Benutzer",
  OF = () => "No hay usuarios baneados",
  qF = () => "Aucun utilisateur banni",
  NF = () => "Nessun utente bannato",
  VF = () => "BANã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã„ã¾ã›ã‚“ã€‚",
  UF = () => "Brak zbanowanych uÅ¼ytkownikÃ³w",
  ZF = () => "ÐÐµÑ‚ Ð·Ð°Ð±Ð°Ð½ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹",
  GF = () => "ÐÐµÐ¼Ð°Ñ” Ð·Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¸Ñ… ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ñ–Ð²",
  WF = () => "KhÃ´ng cÃ³ ngÆ°á»i dÃ¹ng bá»‹ cáº¥m",
  HF = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? RF() : r === "pt" ? jF() : r === "ch" ? FF() : r === "de" ? BF() : r === "es" ? OF() : r === "fr" ? qF() : r === "it" ? NF() : r === "jp" ? VF() : r === "pl" ? UF() : r === "ru" ? ZF() : r === "uk" ? GF() : WF()
  },
  $F = () => "No country found.",
  XF = () => "PaÃ­s nÃ£o encontrado.",
  YF = () => "æœªæ‰¾åˆ°å›½å®¶ã€‚",
  KF = () => "Kein Land gefunden.",
  JF = () => "No se encontrÃ³ ningÃºn paÃ­s.",
  QF = () => "Aucun pays trouvÃ©.",
  e7 = () => "Paese non trovato.",
  t7 = () => "å›½ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚",
  r7 = () => "Nie znaleziono kraju.",
  n7 = () => "Ð¡Ñ‚Ñ€Ð°Ð½Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°.",
  i7 = () => "ÐšÑ€Ð°Ñ—Ð½Ñƒ Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾.",
  a7 = () => "KhÃ´ng tÃ¬m tháº¥y quá»‘c gia.",
  o7 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? $F() : r === "pt" ? XF() : r === "ch" ? YF() : r === "de" ? KF() : r === "es" ? JF() : r === "fr" ? QF() : r === "it" ? e7() : r === "jp" ? t7() : r === "pl" ? r7() : r === "ru" ? n7() : r === "uk" ? i7() : a7()
  },
  s7 = () => "No description",
  l7 = () => "Sem descriÃ§Ã£o",
  c7 = () => "æ— æè¿°",
  u7 = () => "Keine Beschreibung",
  h7 = () => "Sin descripciÃ³n",
  d7 = () => "Aucune description",
  p7 = () => "Nessuna descrizione",
  f7 = () => "èª¬æ˜Žãªã—",
  _7 = () => "Brak opisu",
  m7 = () => "Ð‘ÐµÐ· Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ",
  g7 = () => "Ð‘ÐµÐ· Ð¾Ð¿Ð¸ÑÑƒ",
  v7 = () => "KhÃ´ng cÃ³ mÃ´ táº£",
  k0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? s7() : r === "pt" ? l7() : r === "ch" ? c7() : r === "de" ? u7() : r === "es" ? h7() : r === "fr" ? d7() : r === "it" ? p7() : r === "jp" ? f7() : r === "pl" ? _7() : r === "ru" ? m7() : r === "uk" ? g7() : v7()
  },
  y7 = () => "ðŸš« No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  b7 = () => "ðŸš« ConteÃºdo inapropriado nÃ£o permitido (+18, discurso de Ã³dio, links inapropriados, conteÃºdo altamente sugestivo, ...)",
  x7 = () => "ðŸš« ä¸å…è®¸å‡ºçŽ°ä¸å½“å†…å®¹ï¼ˆ+18ã€ä»‡æ¨è¨€è®ºã€ä¸å½“é“¾æŽ¥ã€é«˜åº¦æš—ç¤ºæ€§å†…å®¹ç­‰ï¼‰",
  w7 = () => "ðŸš« Kein unangemessener Inhalt (+18, Hassrede, unangemessene Links, stark anzÃ¼gliches Material, ...)",
  k7 = () => "ðŸš« Sin contenido inapropiado (+18, discurso de odio, enlaces inapropiados, contenido altamente sugerente, ...)",
  T7 = () => "ðŸš« Aucun contenu inappropriÃ© (+18, discours haineux, liens inappropriÃ©s, contenu trÃ¨s suggestif, ...)",
  S7 = () => "ðŸš« Contenuto inappropriato non consentito (+18, discorsi d'odio, link inappropriati, contenuto altamente esplicito, ...)",
  P7 = () => "ðŸš« ä¸é©åˆ‡ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯ç¦æ­¢ã§ã™ï¼ˆ18ç¦ã€ãƒ˜ã‚¤ãƒˆã‚¹ãƒ”ãƒ¼ãƒã€ä¸é©åˆ‡ãªãƒªãƒ³ã‚¯ã€éŽåº¦ã«æ€§çš„ãªå†…å®¹ãªã©ï¼‰ã€‚",
  M7 = () => "ðŸš« Brak treÅ›ci nieodpowiednich (+18, mowa nienawiÅ›ci, nieodpowiednie linki, mocno sugestywne materiaÅ‚y, ...)",
  I7 = () => "ðŸš« ÐÐ¸ÐºÐ°ÐºÐ¾Ð³Ð¾ Ð½ÐµÐ¿Ñ€Ð¸ÐµÐ¼Ð»ÐµÐ¼Ð¾Ð³Ð¾ ÐºÐ¾Ð½Ñ‚ÐµÐ½Ñ‚Ð° (+18, Ñ€ÐµÑ‡ÑŒ Ð½ÐµÐ½Ð°Ð²Ð¸ÑÑ‚Ð¸, Ð½ÐµÐ¿Ñ€Ð¸ÐµÐ¼Ð»ÐµÐ¼Ñ‹Ðµ ÑÑÑ‹Ð»ÐºÐ¸, ÐºÑ€Ð°Ð¹Ð½Ðµ Ð¾Ñ‚ÐºÑ€Ð¾Ð²ÐµÐ½Ð½Ñ‹Ð¹ ÐºÐ¾Ð½Ñ‚ÐµÐ½Ñ‚ Ð¸ Ñ‚.Ð¿.)",
  C7 = () => "ðŸš« Ð–Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð½ÐµÐ¿Ñ€Ð¸Ð¹Ð½ÑÑ‚Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ð½Ñ‚ÐµÐ½Ñ‚Ñƒ (+18, Ð¼Ð¾Ð²Ð° Ð²Ð¾Ñ€Ð¾Ð¶Ð½ÐµÑ‡Ñ–, Ð½ÐµÐ¿Ñ€Ð¸Ð¹Ð½ÑÑ‚Ð½Ñ– Ð¿Ð¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ, Ð´ÑƒÐ¶Ðµ Ð²Ñ–Ð´Ð²ÐµÑ€Ñ‚Ð¸Ð¹ ÐºÐ¾Ð½Ñ‚ÐµÐ½Ñ‚, ...)",
  z7 = () => "ðŸš« KhÃ´ng cho phÃ©p ná»™i dung khÃ´ng phÃ¹ há»£p (+18, ngÃ´n tá»« thÃ¹ háº±n, liÃªn káº¿t khÃ´ng phÃ¹ há»£p, ná»™i dung khiÃªu gá»£i máº¡nh, ...)",
  A7 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? y7() : r === "pt" ? b7() : r === "ch" ? x7() : r === "de" ? w7() : r === "es" ? k7() : r === "fr" ? T7() : r === "it" ? S7() : r === "jp" ? P7() : r === "pl" ? M7() : r === "ru" ? I7() : r === "uk" ? C7() : z7()
  },
  E7 = () => "No more charges",
  L7 = () => "Acabou a tinta",
  D7 = () => "æ²¡æœ‰å‰©ä½™å……èƒ½",
  R7 = () => "Keine Ladungen mehr",
  j7 = () => "No tienes mÃ¡s cargas",
  F7 = () => "Plus de charges",
  B7 = () => "Vernice esaurita",
  O7 = () => "ãƒãƒ£ãƒ¼ã‚¸ãŒæ®‹ã£ã¦ã„ã¾ã›ã‚“ã€‚",
  q7 = () => "Brak Å‚adunkÃ³w",
  N7 = () => "Ð—Ð°Ñ€ÑÐ´Ñ‹ Ð·Ð°ÐºÐ¾Ð½Ñ‡Ð¸Ð»Ð¸ÑÑŒ",
  V7 = () => "Ð—Ð°Ñ€ÑÐ´ Ð·Ð°ÐºÑ–Ð½Ñ‡Ð¸Ð²ÑÑ",
  U7 = () => "KhÃ´ng cÃ²n lÆ°á»£t tÃ´",
  Z7 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? E7() : r === "pt" ? L7() : r === "ch" ? D7() : r === "de" ? R7() : r === "es" ? j7() : r === "fr" ? F7() : r === "it" ? B7() : r === "jp" ? O7() : r === "pl" ? q7() : r === "ru" ? N7() : r === "uk" ? V7() : U7()
  },
  G7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ Do not paint with more than one account",
  W7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ NÃ£o desenhe com mais de uma conta",
  H7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ è¯·å‹¿ä½¿ç”¨å¤šä¸ªè´¦å·è¿›è¡Œç»˜åˆ¶",
  $7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ Verwende nicht mehr als ein Konto zum Malen",
  X7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ No pintes con mÃ¡s de una cuenta",
  Y7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ Ne dessinez pas avec plus dâ€™un compte",
  K7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ Non disegnare con piÃ¹ di un account",
  J7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ è¤‡æ•°ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒšã‚¤ãƒ³ãƒˆã—ãªã„ã§ãã ã•ã„ã€‚",
  Q7 = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ Nie maluj, uÅ¼ywajÄ…c wiÄ™cej niÅ¼ jednego konta",
  eB = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ ÐÐµÐ»ÑŒÐ·Ñ Ñ€Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ Ñ Ð±Ð¾Ð»ÐµÐµ Ñ‡ÐµÐ¼ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°",
  tB = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ ÐÐµ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÐ¹Ñ‚Ðµ Ð±Ñ–Ð»ÑŒÑˆÐµ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð°ÐºÐ°ÑƒÐ½Ñ‚Ð°",
  rB = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ KhÃ´ng tÃ´ báº±ng nhiá»u hÆ¡n má»™t tÃ i khoáº£n",
  nB = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? G7() : r === "pt" ? W7() : r === "ch" ? H7() : r === "de" ? $7() : r === "es" ? X7() : r === "fr" ? Y7() : r === "it" ? K7() : r === "jp" ? J7() : r === "pl" ? Q7() : r === "ru" ? eB() : r === "uk" ? tB() : rB()
  },
  iB = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  aB = () => "NÃ£o Ã© permitido usar vÃ¡rias contas. Use sua conta principal para pintar.",
  oB = () => "ä½ ä¸èƒ½ä½¿ç”¨å¤šä¸ªè´¦å·ã€‚è¯·ä½¿ç”¨ä½ çš„ä¸»è´¦å·è¿›è¡Œç»˜åˆ¶ã€‚",
  sB = () => "Es ist nicht erlaubt, mehrere Konten zu verwenden. Nutze dein Hauptkonto zum Malen.",
  lB = () => "No estÃ¡ permitido usar varias cuentas. Usa tu cuenta principal para pintar.",
  cB = () => "Lâ€™utilisation de plusieurs comptes nâ€™est pas autorisÃ©e. Utilisez votre compte principal pour peindre.",
  uB = () => "Non Ã¨ consentito usare piÃ¹ account. Usa il tuo account principale per dipingere.",
  hB = () => "è¤‡æ•°ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ¡ã‚¤ãƒ³ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒšã‚¤ãƒ³ãƒˆã—ã¦ãã ã•ã„ã€‚",
  dB = () => "Nie moÅ¼esz uÅ¼ywaÄ‡ wielu kont. UÅ¼yj swojego gÅ‚Ã³wnego konta do malowania.",
  pB = () => "Ð—Ð°Ð¿Ñ€ÐµÑ‰ÐµÐ½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð¾Ð². Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð´Ð»Ñ Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ.",
  fB = () => "Ð’Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÐ²Ð°Ñ‚Ð¸ ÐºÑ–Ð»ÑŒÐºÐ° Ð°ÐºÐ°ÑƒÐ½Ñ‚Ñ–Ð² Ð·Ð°Ð±Ð¾Ñ€Ð¾Ð½ÐµÐ½Ð¾. Ð’Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÐ¹Ñ‚Ðµ ÑÐ²Ñ–Ð¹ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¸Ð¹ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð´Ð»Ñ Ð¼Ð°Ð»ÑŽÐ²Ð°Ð½Ð½Ñ.",
  _B = () => "Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng nhiá»u tÃ i khoáº£n. HÃ£y dÃ¹ng tÃ i khoáº£n chÃ­nh cá»§a báº¡n Ä‘á»ƒ tÃ´.",
  mB = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? iB() : r === "pt" ? aB() : r === "ch" ? oB() : r === "de" ? sB() : r === "es" ? lB() : r === "fr" ? cB() : r === "it" ? uB() : r === "jp" ? hB() : r === "pl" ? dB() : r === "ru" ? pB() : r === "uk" ? fB() : _B()
  },
  gB = () => "No notifications",
  vB = () => "Nenhuma notificaÃ§Ã£o",
  yB = () => "æ²¡æœ‰é€šçŸ¥",
  bB = () => "Keine Benachrichtigungen",
  xB = () => "No hay notificaciones",
  wB = () => "Aucune notification",
  kB = () => "Nessuna notifica",
  TB = () => "é€šçŸ¥ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  SB = () => "Brak powiadomieÅ„",
  PB = () => "ÐÐµÑ‚ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ð¹",
  MB = () => "ÐÐµÐ¼Ð°Ñ” ÑÐ¿Ð¾Ð²Ñ–Ñ‰ÐµÐ½ÑŒ",
  IB = () => "KhÃ´ng cÃ³ thÃ´ng bÃ¡o",
  CB = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? gB() : r === "pt" ? vB() : r === "ch" ? yB() : r === "de" ? bB() : r === "es" ? xB() : r === "fr" ? wB() : r === "it" ? kB() : r === "jp" ? TB() : r === "pl" ? SB() : r === "ru" ? PB() : r === "uk" ? MB() : IB()
  },
  zB = () => "No pixels painted",
  AB = () => "Nenhum pixel pintado",
  EB = () => "å°šæœªç»˜åˆ¶åƒç´ ",
  LB = () => "Keine Pixel gemalt",
  DB = () => "No se han pintado pÃ­xeles",
  RB = () => "Aucun pixel peint",
  jB = () => "Nessun pixel dipinto",
  FB = () => "ã¾ã ãƒ”ã‚¯ã‚»ãƒ«ãŒå¡—ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚",
  BB = () => "Brak pomalowanych pikseli",
  OB = () => "ÐÐµÑ‚ Ð½Ð°Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹",
  qB = () => "Ð–Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¿Ñ–ÐºÑÐµÐ»Ñ Ð½Ðµ Ð½Ð°Ð¼Ð°Ð»ÑŒÐ¾Ð²Ð°Ð½Ð¾",
  NB = () => "ChÆ°a cÃ³ pixel nÃ o Ä‘Æ°á»£c tÃ´",
  em = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? zB() : r === "pt" ? AB() : r === "ch" ? EB() : r === "de" ? LB() : r === "es" ? DB() : r === "fr" ? RB() : r === "it" ? jB() : r === "jp" ? FB() : r === "pl" ? BB() : r === "ru" ? OB() : r === "uk" ? qB() : NB()
  },
  VB = () => "No place found",
  UB = () => "Nenhum local encontrado",
  ZB = () => "æœªæ‰¾åˆ°åœ°ç‚¹",
  GB = () => "Kein Ort gefunden",
  WB = () => "No se encontrÃ³ ningÃºn lugar",
  HB = () => "Aucun endroit trouvÃ©",
  $B = () => "Nessun luogo trovato",
  XB = () => "å ´æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚",
  YB = () => "Nie znaleziono miejsca",
  KB = () => "ÐœÐµÑÑ‚Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹",
  JB = () => "ÐœÑ–ÑÑ†Ðµ Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾",
  QB = () => "KhÃ´ng tÃ¬m tháº¥y Ä‘á»‹a Ä‘iá»ƒm nÃ o",
  e9 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? VB() : r === "pt" ? UB() : r === "ch" ? ZB() : r === "de" ? GB() : r === "es" ? WB() : r === "fr" ? HB() : r === "it" ? $B() : r === "jp" ? XB() : r === "pl" ? YB() : r === "ru" ? KB() : r === "uk" ? JB() : QB()
  },
  t9 = () => "No recent locations",
  r9 = () => "Nenhum local recente",
  n9 = () => "æš‚æ— æœ€è¿‘ä½ç½®",
  i9 = () => "Keine besuchten Orte",
  a9 = () => "No hay ubicaciones recientes",
  o9 = () => "Aucun emplacement rÃ©cent",
  s9 = () => "Nessuna localitÃ  recente",
  l9 = () => "æœ€è¿‘ã®å ´æ‰€ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  c9 = () => "Brak ostatnich lokalizacji",
  u9 = () => "ÐÐµÑ‚ Ð½ÐµÐ´Ð°Ð²Ð½Ð¸Ñ… Ð»Ð¾ÐºÐ°Ñ†Ð¸Ð¹",
  h9 = () => "ÐÐµÐ¼Ð°Ñ” Ð½ÐµÑ‰Ð¾Ð´Ð°Ð²Ð½Ñ–Ñ… Ð»Ð¾ÐºÐ°Ñ†Ñ–Ð¹",
  d9 = () => "KhÃ´ng cÃ³ vá»‹ trÃ­ gáº§n Ä‘Ã¢y",
  p9 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? t9() : r === "pt" ? r9() : r === "ch" ? n9() : r === "de" ? i9() : r === "es" ? a9() : r === "fr" ? o9() : r === "it" ? s9() : r === "jp" ? l9() : r === "pl" ? c9() : r === "ru" ? u9() : r === "uk" ? h9() : d9()
  },
  f9 = () => "No corresponding region on the map (cosmetic effect only)",
  _9 = () => "NÃ£o possui regiÃ£o no mapa (apenas efeito cosmÃ©tico)",
  m9 = () => "åœ¨åœ°å›¾ä¸Šæ²¡æœ‰å¯¹åº”åŒºåŸŸï¼ˆä»…è£…é¥°æ•ˆæžœï¼‰",
  g9 = () => "Keine entsprechende Region auf der Karte (nur kosmetischer Effekt)",
  v9 = () => "Sin regiÃ³n correspondiente en el mapa (solo efecto cosmÃ©tico)",
  y9 = () => "Aucune rÃ©gion correspondante sur la carte (effet cosmÃ©tique seulement)",
  b9 = () => "Non ha una regione sulla mappa (solo effetto cosmetico)",
  x9 = () => "ãƒžãƒƒãƒ—ä¸Šã«å¯¾å¿œã™ã‚‹åœ°åŸŸã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆè¦‹ãŸç›®ã®ã¿ã®åŠ¹æžœï¼‰ã€‚",
  w9 = () => "Brak odpowiadajÄ…cego regionu na mapie (tylko efekt kosmetyczny)",
  k9 = () => "ÐÐµÑ‚ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐ¹ Ð¾Ð±Ð»Ð°ÑÑ‚Ð¸ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ðµ (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÐºÐ¾ÑÐ¼ÐµÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ ÑÑ„Ñ„ÐµÐºÑ‚)",
  T9 = () => "ÐÐµÐ¼Ð°Ñ” Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð½Ð¾Ñ— Ð¾Ð±Ð»Ð°ÑÑ‚Ñ– Ð½Ð° ÐºÐ°Ñ€Ñ‚Ñ– (Ð»Ð¸ÑˆÐµ ÐºÐ¾ÑÐ¼ÐµÑ‚Ð¸Ñ‡Ð½Ð¸Ð¹ ÐµÑ„ÐµÐºÑ‚)",
  S9 = () => "KhÃ´ng cÃ³ vÃ¹ng tÆ°Æ¡ng á»©ng trÃªn báº£n Ä‘á»“ (chá»‰ cÃ³ tÃ¡c dá»¥ng trang trÃ­)",
  P9 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? f9() : r === "pt" ? _9() : r === "ch" ? m9() : r === "de" ? g9() : r === "es" ? v9() : r === "fr" ? y9() : r === "it" ? b9() : r === "jp" ? x9() : r === "pl" ? w9() : r === "ru" ? k9() : r === "uk" ? T9() : S9()
  },
  M9 = () => "ðŸ¤– Use of bots is not allowed",
  I9 = () => "ðŸ¤– Usar bots nÃ£o Ã© permitido",
  C9 = () => "ðŸ¤– ä¸å…è®¸ä½¿ç”¨æœºå™¨äººæˆ–è„šæœ¬",
  z9 = () => "ðŸ¤– Das Verwenden von Bots ist verboten",
  A9 = () => "ðŸ¤– No se permite el uso de bots",
  E9 = () => "ðŸ¤– Lâ€™utilisation de bots nâ€™est pas autorisÃ©e",
  L9 = () => "ðŸ¤– L'uso di bot non Ã¨ consentito",
  D9 = () => "ðŸ¤– ãƒœãƒƒãƒˆã®ä½¿ç”¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  R9 = () => "ðŸ¤– UÅ¼ywanie botÃ³w jest zabronione",
  j9 = () => "ðŸ¤– Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð±Ð¾Ñ‚Ð¾Ð² Ð·Ð°Ð¿Ñ€ÐµÑ‰ÐµÐ½Ð¾",
  F9 = () => "ðŸ¤– Ð’Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ð½Ð½Ñ Ð±Ð¾Ñ‚Ñ–Ð² Ð·Ð°Ð±Ð¾Ñ€Ð¾Ð½ÐµÐ½Ð¾",
  B9 = () => "ðŸ¤– KhÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng bot",
  O9 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? M9() : r === "pt" ? I9() : r === "ch" ? C9() : r === "de" ? z9() : r === "es" ? A9() : r === "fr" ? E9() : r === "it" ? L9() : r === "jp" ? D9() : r === "pl" ? R9() : r === "ru" ? j9() : r === "uk" ? F9() : B9()
  },
  q9 = () => "Not enough Droplets",
  N9 = () => "Droplets insuficientes",
  V9 = () => "æ°´æ»´æ•°é‡ä¸è¶³",
  U9 = () => "Nicht genug Droplets",
  Z9 = () => "No tienes suficientes gotas",
  G9 = () => "Pas assez de droplets",
  W9 = () => "Gocce insufficienti",
  H9 = () => "ãƒ‰ãƒ­ãƒƒãƒ—ãƒ¬ãƒƒãƒˆãŒè¶³ã‚Šã¾ã›ã‚“ã€‚",
  $9 = () => "Za maÅ‚o kropli",
  X9 = () => "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ droplets",
  Y9 = () => "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð½ÑŒÐ¾ Ð´Ñ€Ð¾Ð¿Ð»ÐµÑ‚Ñ–Ð²",
  K9 = () => "KhÃ´ng Ä‘á»§ droplets",
  Lp = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? q9() : r === "pt" ? N9() : r === "ch" ? V9() : r === "de" ? U9() : r === "es" ? Z9() : r === "fr" ? G9() : r === "it" ? W9() : r === "jp" ? H9() : r === "pl" ? $9() : r === "ru" ? X9() : r === "uk" ? Y9() : K9()
  },
  J9 = () => "You are not in an alliance",
  Q9 = () => "VocÃª nÃ£o estÃ¡ em uma alianÃ§a",
  eO = () => "ä½ ä¸åœ¨ä»»ä½•è”ç›Ÿä¸­",
  tO = () => "Du bist in keiner Allianz",
  rO = () => "No estÃ¡s en una alianza",
  nO = () => "Vous nâ€™Ãªtes pas dans une alliance",
  iO = () => "Non sei in un'alleanza",
  aO = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‰€å±žã—ã¦ã„ã¾ã›ã‚“ã€‚",
  oO = () => "Nie jesteÅ› w Å¼adnym sojuszu",
  sO = () => "Ð’Ñ‹ Ð½Ðµ ÑÐ¾ÑÑ‚Ð¾Ð¸Ñ‚Ðµ Ð² Ð°Ð»ÑŒÑÐ½ÑÐµ",
  lO = () => "Ð’Ð¸ Ð½Ðµ Ð¿ÐµÑ€ÐµÐ±ÑƒÐ²Ð°Ñ”Ñ‚Ðµ Ð² Ð°Ð»ÑŒÑÐ½ÑÑ–",
  cO = () => "Báº¡n khÃ´ng á»Ÿ trong liÃªn minh nÃ o",
  uO = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? J9() : r === "pt" ? Q9() : r === "ch" ? eO() : r === "de" ? tO() : r === "es" ? rO() : r === "fr" ? nO() : r === "it" ? iO() : r === "jp" ? aO() : r === "pl" ? oO() : r === "ru" ? sO() : r === "uk" ? lO() : cO()
  },
  hO = () => "Not painted",
  dO = () => "NÃ£o pintado",
  pO = () => "æœªç»˜åˆ¶",
  fO = () => "Nicht gemalt",
  _O = () => "No pintado",
  mO = () => "Non peint",
  gO = () => "Non dipinto",
  vO = () => "æœªå¡—ã‚Š",
  yO = () => "Niezamalowane",
  bO = () => "ÐÐµ Ð½Ð°Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð¾",
  xO = () => "ÐÐµ Ð½Ð°Ð¼Ð°Ð»ÑŒÐ¾Ð²Ð°Ð½Ð¾",
  wO = () => "ChÆ°a tÃ´",
  kO = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? hO() : r === "pt" ? dO() : r === "ch" ? pO() : r === "de" ? fO() : r === "es" ? _O() : r === "fr" ? mO() : r === "it" ? gO() : r === "jp" ? vO() : r === "pl" ? yO() : r === "ru" ? bO() : r === "uk" ? xO() : wO()
  },
  TO = () => "Not set",
  SO = () => "NÃ£o configurado",
  PO = () => "æœªè®¾ç½®",
  MO = () => "Nicht gesetzt",
  IO = () => "No establecido",
  CO = () => "Non dÃ©fini",
  zO = () => "Non impostato",
  AO = () => "æœªè¨­å®š",
  EO = () => "Nie ustawiono",
  LO = () => "ÐÐµ Ð·Ð°Ð´Ð°Ð½Ð¾",
  DO = () => "ÐÐµ Ð·Ð°Ð´Ð°Ð½Ð¾",
  RO = () => "ChÆ°a Ä‘áº·t",
  jO = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? TO() : r === "pt" ? SO() : r === "ch" ? PO() : r === "de" ? MO() : r === "es" ? IO() : r === "fr" ? CO() : r === "it" ? zO() : r === "jp" ? AO() : r === "pl" ? EO() : r === "ru" ? LO() : r === "uk" ? DO() : RO()
  },
  FO = () => "Notifications",
  BO = () => "NotificaÃ§Ãµes",
  OO = () => "é€šçŸ¥",
  qO = () => "Benachrichtigungen",
  NO = () => "Notificaciones",
  VO = () => "Notifications",
  UO = () => "Notifiche",
  ZO = () => "é€šçŸ¥",
  GO = () => "Powiadomienia",
  WO = () => "Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ",
  HO = () => "Ð¡Ð¿Ð¾Ð²Ñ–Ñ‰ÐµÐ½Ð½Ñ",
  $O = () => "ThÃ´ng bÃ¡o",
  T0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? FO() : r === "pt" ? BO() : r === "ch" ? OO() : r === "de" ? qO() : r === "es" ? NO() : r === "fr" ? VO() : r === "it" ? UO() : r === "jp" ? ZO() : r === "pl" ? GO() : r === "ru" ? WO() : r === "uk" ? HO() : $O()
  },
  XO = () => "Offline",
  YO = () => "Desconectado",
  KO = () => "ç¦»çº¿",
  JO = () => "Offline",
  QO = () => "Desconectado",
  eq = () => "Hors ligne",
  tq = () => "Offline",
  rq = () => "ã‚ªãƒ•ãƒ©ã‚¤ãƒ³",
  nq = () => "Offline",
  iq = () => "ÐžÑ„Ñ„Ð»Ð°Ð¹Ð½",
  aq = () => "ÐžÑ„Ð»Ð°Ð¹Ð½",
  oq = () => "Ngoáº¡i tuyáº¿n",
  sq = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? XO() : r === "pt" ? YO() : r === "ch" ? KO() : r === "de" ? JO() : r === "es" ? QO() : r === "fr" ? eq() : r === "it" ? tq() : r === "jp" ? rq() : r === "pl" ? nq() : r === "ru" ? iq() : r === "uk" ? aq() : oq()
  },
  lq = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  cq = () => "no canto superior direito da tela. Isso bloquearÃ¡ a tela, mas tambÃ©m permitirÃ¡ pintar movendo o dedo sobre o mapa.",
  uq = () => "åœ¨å±å¹•å³ä¸Šè§’ã€‚æ­¤æ“ä½œä¼šé”å®šå±å¹•ï¼Œä½†åŒæ—¶å¯ä»¥é€šè¿‡ç§»åŠ¨æ‰‹æŒ‡åœ¨åœ°å›¾ä¸Šè¿›è¡Œç»˜åˆ¶ã€‚",
  hq = () => "in der oberen rechten Ecke des Bildschirms. Dadurch wird der Bildschirm gesperrt, aber du kannst durch Bewegen deines Fingers Ã¼ber die Karte malen.",
  dq = () => "en la esquina superior derecha de la pantalla. Esto bloquearÃ¡ la pantalla pero tambiÃ©n permitirÃ¡ pintar moviendo el dedo sobre el mapa.",
  pq = () => "dans le coin supÃ©rieur droit de lâ€™Ã©cran. Cela verrouille lâ€™Ã©cran mais permet de peindre en dÃ©plaÃ§ant votre doigt sur la carte.",
  fq = () => "nell'angolo in alto a destra dello schermo. Questo bloccherÃ  lo schermo, ma ti permetterÃ  di dipingere muovendo il dito sulla mappa.",
  _q = () => "ç”»é¢å³ä¸Šã®ãƒœã‚¿ãƒ³ã§ã™ã€‚ç”»é¢ã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ãŒã€æŒ‡ã‚’ãƒžãƒƒãƒ—ä¸Šã§å‹•ã‹ã™ã“ã¨ã§ãƒšã‚¤ãƒ³ãƒˆã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚",
  mq = () => "w prawym gÃ³rnym rogu ekranu. To zablokuje ekran, ale umoÅ¼liwi malowanie poprzez przesuwanie palcem po mapie.",
  gq = () => "Ð² Ð¿Ñ€Ð°Ð²Ð¾Ð¼ Ð²ÐµÑ€Ñ…Ð½ÐµÐ¼ ÑƒÐ³Ð»Ñƒ ÑÐºÑ€Ð°Ð½Ð°. Ð­ÐºÑ€Ð°Ð½ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½, Ð½Ð¾ Ð¿Ñ€Ð¸ ÑÑ‚Ð¾Ð¼ Ð¼Ð¾Ð¶Ð½Ð¾ Ñ€Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ, Ð¿Ñ€Ð¾Ð²Ð¾Ð´Ñ Ð¿Ð°Ð»ÑŒÑ†ÐµÐ¼ Ð¿Ð¾ ÐºÐ°Ñ€Ñ‚Ðµ.",
  vq = () => "Ñƒ Ð²ÐµÑ€Ñ…Ð½ÑŒÐ¾Ð¼Ñƒ Ð¿Ñ€Ð°Ð²Ð¾Ð¼Ñƒ ÐºÑƒÑ‚Ñ– ÐµÐºÑ€Ð°Ð½Ð°. Ð¦Ðµ Ð·Ð°Ð±Ð»Ð¾ÐºÑƒÑ” ÐµÐºÑ€Ð°Ð½, Ð°Ð»Ðµ Ð´Ð¾Ð·Ð²Ð¾Ð»Ð¸Ñ‚ÑŒ Ð¼Ð°Ð»ÑŽÐ²Ð°Ñ‚Ð¸, Ð¿Ñ€Ð¾Ð²Ð¾Ð´ÑÑ‡Ð¸ Ð¿Ð°Ð»ÑŒÑ†ÐµÐ¼ Ð¿Ð¾ ÐºÐ°Ñ€Ñ‚Ñ–.",
  yq = () => "á»Ÿ gÃ³c trÃªn bÃªn pháº£i mÃ n hÃ¬nh. Äiá»u nÃ y sáº½ khÃ³a mÃ n hÃ¬nh nhÆ°ng cho phÃ©p báº¡n tÃ´ báº±ng cÃ¡ch rÃª ngÃ³n tay trÃªn báº£n Ä‘á»“.",
  bq = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? lq() : r === "pt" ? cq() : r === "ch" ? uq() : r === "de" ? hq() : r === "es" ? dq() : r === "fr" ? pq() : r === "it" ? fq() : r === "jp" ? _q() : r === "pl" ? mq() : r === "ru" ? gq() : r === "uk" ? vq() : yq()
  },
  xq = () => "OpenMapTiles Data from",
  wq = () => "OpenMapTiles com dados do",
  kq = () => "åœ°å›¾æ•°æ®æ¥è‡ª OpenMapTiles",
  Tq = () => "OpenMapTiles Daten von",
  Sq = () => "Datos de OpenMapTiles de",
  Pq = () => "DonnÃ©es OpenMapTiles de",
  Mq = () => "OpenMapTiles con dati da",
  Iq = () => "OpenMapTiles ãƒ‡ãƒ¼ã‚¿æä¾›:",
  Cq = () => "Dane OpenMapTiles z",
  zq = () => "Ð”Ð°Ð½Ð½Ñ‹Ðµ OpenMapTiles Ð¾Ñ‚",
  Aq = () => "Ð”Ð°Ð½Ñ– OpenMapTiles Ð²Ñ–Ð´",
  Eq = () => "Dá»¯ liá»‡u OpenMapTiles tá»«",
  Lq = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? xq() : r === "pt" ? wq() : r === "ch" ? kq() : r === "de" ? Tq() : r === "es" ? Sq() : r === "fr" ? Pq() : r === "it" ? Mq() : r === "jp" ? Iq() : r === "pl" ? Cq() : r === "ru" ? zq() : r === "uk" ? Aq() : Eq()
  },
  Dq = () => "or hold",
  Rq = () => "ou segure",
  jq = () => "æˆ–æŒ‰ä½",
  Fq = () => "oder",
  Bq = () => "o mantÃ©n pulsado",
  Oq = () => "ou maintenez",
  qq = () => "o tieni premuto",
  Nq = () => "ã¾ãŸã¯é•·æŠ¼ã—",
  Vq = () => "lub przytrzymaj",
  Uq = () => "Ð¸Ð»Ð¸ ÑƒÐ´ÐµÑ€Ð¶Ð¸Ð²Ð°Ð¹Ñ‚Ðµ",
  Zq = () => "Ð°Ð±Ð¾ ÑƒÑ‚Ñ€Ð¸Ð¼ÑƒÐ¹Ñ‚Ðµ",
  Gq = () => "hoáº·c giá»¯",
  Wq = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Dq() : r === "pt" ? Rq() : r === "ch" ? jq() : r === "de" ? Fq() : r === "es" ? Bq() : r === "fr" ? Oq() : r === "it" ? qq() : r === "jp" ? Nq() : r === "pl" ? Vq() : r === "ru" ? Uq() : r === "uk" ? Zq() : Gq()
  },
  Hq = () => "Overview",
  $q = () => "VisÃ£o Geral",
  Xq = () => "æ¦‚è§ˆ",
  Yq = () => "Ãœbersicht",
  Kq = () => "Resumen",
  Jq = () => "Vue dâ€™ensemble",
  Qq = () => "Panoramica",
  eN = () => "æ¦‚è¦",
  tN = () => "PrzeglÄ…d",
  rN = () => "ÐžÐ±Ð·Ð¾Ñ€",
  nN = () => "ÐžÐ³Ð»ÑÐ´",
  iN = () => "Tá»•ng quan",
  aN = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Hq() : r === "pt" ? $q() : r === "ch" ? Xq() : r === "de" ? Yq() : r === "es" ? Kq() : r === "fr" ? Jq() : r === "it" ? Qq() : r === "jp" ? eN() : r === "pl" ? tN() : r === "ru" ? rN() : r === "uk" ? nN() : iN()
  },
  oN = () => "Paint",
  sN = () => "Pintar",
  lN = () => "ç»˜ç”»",
  cN = () => "Malen",
  uN = () => "Pintar",
  hN = () => "Peindre",
  dN = () => "Dipingi",
  pN = () => "ãƒšã‚¤ãƒ³ãƒˆ",
  fN = () => "Maluj",
  _N = () => "Ð Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ",
  mN = () => "ÐœÐ°Ð»ÑŽÐ²Ð°Ñ‚Ð¸",
  gN = () => "TÃ´",
  S0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? oN() : r === "pt" ? sN() : r === "ch" ? lN() : r === "de" ? cN() : r === "es" ? uN() : r === "fr" ? hN() : r === "it" ? dN() : r === "jp" ? pN() : r === "pl" ? fN() : r === "ru" ? _N() : r === "uk" ? mN() : gN()
  },
  vN = () => "Paint pixel",
  yN = () => "Pintar pixel",
  bN = () => "ç»˜åˆ¶åƒç´ ",
  xN = () => "Pixel malen",
  wN = () => "Pintar pÃ­xel",
  kN = () => "Peindre un pixel",
  TN = () => "Dipingere pixel",
  SN = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’å¡—ã‚‹",
  PN = () => "Pomaluj piksel",
  MN = () => "ÐÐ°Ñ€Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ",
  IN = () => "ÐÐ°Ð¼Ð°Ð»ÑŽÐ²Ð°Ñ‚Ð¸ Ð¿Ñ–ÐºÑÐµÐ»ÑŒ",
  CN = () => "TÃ´ pixel",
  zN = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? vN() : r === "pt" ? yN() : r === "ch" ? bN() : r === "de" ? xN() : r === "es" ? wN() : r === "fr" ? kN() : r === "it" ? TN() : r === "jp" ? SN() : r === "pl" ? PN() : r === "ru" ? MN() : r === "uk" ? IN() : CN()
  },
  AN = () => "Painted",
  EN = () => "Pintados",
  LN = () => "å·²ç»˜åˆ¶",
  DN = () => "gemalt",
  RN = () => "Pintado",
  jN = () => "Peints",
  FN = () => "Dipinti",
  BN = () => "å¡—ã‚‰ã‚ŒãŸ",
  ON = () => "Pomalowane",
  qN = () => "ÐÐ°Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð¾",
  NN = () => "ÐÐ°Ð¼Ð°Ð»ÑŒÐ¾Ð²Ð°Ð½Ð¾",
  VN = () => "ÄÃ£ tÃ´",
  Sc = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? AN() : r === "pt" ? EN() : r === "ch" ? LN() : r === "de" ? DN() : r === "es" ? RN() : r === "fr" ? jN() : r === "it" ? FN() : r === "jp" ? BN() : r === "pl" ? ON() : r === "ru" ? qN() : r === "uk" ? NN() : VN()
  },
  UN = () => "Painted by",
  ZN = () => "Pintado por",
  GN = () => "ç»˜åˆ¶è€…",
  WN = () => "Gemalt von",
  HN = () => "Pintado por",
  $N = () => "Peint par",
  XN = () => "Dipinto da",
  YN = () => "å¡—ã£ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼",
  KN = () => "Pomalowane przez",
  JN = () => "ÐÐ°Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð¾",
  QN = () => "ÐÐ°Ð¼Ð°Ð»ÑŒÐ¾Ð²Ð°Ð½Ð¾",
  eV = () => "ÄÆ°á»£c tÃ´ bá»Ÿi",
  tV = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? UN() : r === "pt" ? ZN() : r === "ch" ? GN() : r === "de" ? WN() : r === "es" ? HN() : r === "fr" ? $N() : r === "it" ? XN() : r === "jp" ? YN() : r === "pl" ? KN() : r === "ru" ? JN() : r === "uk" ? QN() : eV()
  },
  rV = () => "âœ… Painting over other artworks to complement them or create a new drawing is allowed",
  nV = () => "âœ… Desenhar sobre outras artes para complementar ou criar novas artes Ã© permitido",
  iV = () => "âœ… åœ¨ä¸ç ´åä½œå“çš„å‰æä¸‹ï¼Œå¯¹ä»–äººä½œå“è¿›è¡Œè¡¥å……æˆ–åˆ›ä½œæ–°å›¾æ˜¯å…è®¸çš„",
  aV = () => "âœ… Ãœber andere Kunstwerke zu malen, um sie zu ergÃ¤nzen oder ein neues Bild zu erstellen, ist erlaubt",
  oV = () => "âœ… Pintar sobre las obras de otros para complementarlas o crear un nuevo dibujo estÃ¡ permitido",
  sV = () => "âœ… Peindre par-dessus dâ€™autres Å“uvres pour les complÃ©ter ou crÃ©er un nouveau dessin est autorisÃ©",
  lV = () => "âœ… Disegnare sopra le opere altrui per completarle o creare nuove opere Ã¨ consentito",
  cV = () => "âœ… ä»–äººã®ä½œå“ã‚’è£œå®Œã—ãŸã‚Šã€æ–°ã—ã„çµµã‚’ä½œã‚‹ç›®çš„ã§ä¸Šã‹ã‚‰æãè¶³ã™ã“ã¨ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  uV = () => "âœ… Malowanie po cudzych pracach, aby je uzupeÅ‚niÄ‡ lub stworzyÄ‡ nowy rysunek, jest dozwolone",
  hV = () => "âœ… Ð Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ Ð¿Ð¾Ð²ÐµÑ€Ñ… Ñ‡ÑƒÐ¶Ð¸Ñ… Ñ€Ð°Ð±Ð¾Ñ‚, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¸Ñ… Ð¸Ð»Ð¸ ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð½Ð¾Ð²Ñ‹Ð¹ Ñ€Ð¸ÑÑƒÐ½Ð¾Ðº, Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¾",
  dV = () => "âœ… ÐœÐ°Ð»ÑŽÐ²Ð°Ñ‚Ð¸ Ð¿Ð¾Ð²ÐµÑ€Ñ… Ñ‡ÑƒÐ¶Ð¸Ñ… Ñ€Ð¾Ð±Ñ–Ñ‚, Ñ‰Ð¾Ð± Ð´Ð¾Ð¿Ð¾Ð²Ð½Ð¸Ñ‚Ð¸ Ñ—Ñ… Ð°Ð±Ð¾ ÑÑ‚Ð²Ð¾Ñ€Ð¸Ñ‚Ð¸ Ð½Ð¾Ð²Ð¸Ð¹ Ð¼Ð°Ð»ÑŽÐ½Ð¾Ðº, Ð´Ð¾Ð·Ð²Ð¾Ð»ÐµÐ½Ð¾",
  pV = () => "âœ… TÃ´ Ä‘Ã¨ lÃªn tÃ¡c pháº©m cá»§a ngÆ°á»i khÃ¡c Ä‘á»ƒ bá»• sung hoáº·c táº¡o tranh má»›i lÃ  Ä‘Æ°á»£c phÃ©p",
  fV = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? rV() : r === "pt" ? nV() : r === "ch" ? iV() : r === "de" ? aV() : r === "es" ? oV() : r === "fr" ? sV() : r === "it" ? lV() : r === "jp" ? cV() : r === "pl" ? uV() : r === "ru" ? hV() : r === "uk" ? dV() : pV()
  },
  _V = () => "Phone verification required",
  mV = () => "VerificaÃ§Ã£o de telefone necessÃ¡ria",
  gV = () => "éœ€è¦è¿›è¡Œç”µè¯éªŒè¯",
  vV = () => "Telefon-Verifizierung erforderlich",
  yV = () => "Se requiere verificaciÃ³n de telÃ©fono",
  bV = () => "VÃ©rification du tÃ©lÃ©phone requise",
  xV = () => "Verifica del telefono richiesta",
  wV = () => "é›»è©±ç•ªå·ã®ç¢ºèªãŒå¿…è¦ã§ã™ã€‚",
  kV = () => "Wymagana weryfikacja telefonu",
  TV = () => "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ð°",
  SV = () => "ÐŸÐ¾Ñ‚Ñ€Ñ–Ð±Ð½Ðµ Ð¿Ñ–Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¶ÐµÐ½Ð½Ñ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ñƒ",
  PV = () => "YÃªu cáº§u xÃ¡c minh sá»‘ Ä‘iá»‡n thoáº¡i",
  _v = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? _V() : r === "pt" ? mV() : r === "ch" ? gV() : r === "de" ? vV() : r === "es" ? yV() : r === "fr" ? bV() : r === "it" ? xV() : r === "jp" ? wV() : r === "pl" ? kV() : r === "ru" ? TV() : r === "uk" ? SV() : PV()
  },
  MV = () => "Pick a color from the map",
  IV = () => "Escolha uma cor do mapa",
  CV = () => "ä»Žåœ°å›¾ä¸­æ‹¾å–é¢œè‰²",
  zV = () => "Farbe von der Karte auswÃ¤hlen",
  AV = () => "Elige un color del mapa",
  EV = () => "Choisissez une couleur sur la carte",
  LV = () => "Scegli un colore dalla mappa",
  DV = () => "ãƒžãƒƒãƒ—ã‹ã‚‰è‰²ã‚’æ‹¾ã†",
  RV = () => "Wybierz kolor z mapy",
  jV = () => "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ†Ð²ÐµÑ‚ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ðµ",
  FV = () => "ÐžÐ±ÐµÑ€Ñ–Ñ‚ÑŒ ÐºÐ¾Ð»Ñ–Ñ€ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ñ–",
  BV = () => "Chá»n má»™t mÃ u tá»« báº£n Ä‘á»“",
  OV = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? MV() : r === "pt" ? IV() : r === "ch" ? CV() : r === "de" ? zV() : r === "es" ? AV() : r === "fr" ? EV() : r === "it" ? LV() : r === "jp" ? DV() : r === "pl" ? RV() : r === "ru" ? jV() : r === "uk" ? FV() : BV()
  },
  qV = () => "Pixels",
  NV = () => "Pixels",
  VV = () => "åƒç´ ",
  UV = () => "Pixel",
  ZV = () => "PÃ­xeles",
  GV = () => "Pixels",
  WV = () => "Pixel",
  HV = () => "ãƒ”ã‚¯ã‚»ãƒ«",
  $V = () => "Piksele",
  XV = () => "ÐŸÐ¸ÐºÑÐµÐ»Ð¸",
  YV = () => "ÐŸÑ–ÐºÑÐµÐ»Ñ–",
  KV = () => "Pixel",
  Pc = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? qV() : r === "pt" ? NV() : r === "ch" ? VV() : r === "de" ? UV() : r === "es" ? ZV() : r === "fr" ? GV() : r === "it" ? WV() : r === "jp" ? HV() : r === "pl" ? $V() : r === "ru" ? XV() : r === "uk" ? YV() : KV()
  },
  JV = () => "Pixels painted inside the country",
  QV = () => "Pixels pintados dentro do paÃ­s",
  eU = () => "åœ¨è¯¥å›½å®¶å†…ç»˜åˆ¶çš„åƒç´ æ•°",
  tU = () => "Pixel, die innerhalb des Landes gemalt wurden",
  rU = () => "PÃ­xeles pintados dentro del paÃ­s",
  nU = () => "Pixels peints dans le pays",
  iU = () => "Pixel dipinti all'interno del paese",
  aU = () => "ãã®å›½ã®é ˜åŸŸå†…ã§å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°",
  oU = () => "Piksele pomalowane wewnÄ…trz kraju",
  sU = () => "ÐŸÐ¸ÐºÑÐµÐ»Ð¸, Ð½Ð°Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ ÑÑ‚Ñ€Ð°Ð½Ñ‹",
  lU = () => "ÐŸÑ–ÐºÑÐµÐ»Ñ–, Ð½Ð°Ð¼Ð°Ð»ÑŒÐ¾Ð²Ð°Ð½Ñ– Ð²ÑÐµÑ€ÐµÐ´Ð¸Ð½Ñ– ÐºÑ€Ð°Ñ—Ð½Ð¸",
  cU = () => "Pixel Ä‘Ã£ tÃ´ trong quá»‘c gia",
  uU = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? JV() : r === "pt" ? QV() : r === "ch" ? eU() : r === "de" ? tU() : r === "es" ? rU() : r === "fr" ? nU() : r === "it" ? iU() : r === "jp" ? aU() : r === "pl" ? oU() : r === "ru" ? sU() : r === "uk" ? lU() : cU()
  },
  hU = () => "Pixels painted inside the region",
  dU = () => "Pixels pintados dentro da regiÃ£o",
  pU = () => "åœ¨è¯¥åŒºåŸŸå†…ç»˜åˆ¶çš„åƒç´ æ•°",
  fU = () => "Pixel, die innerhalb der Region gemalt wurden",
  _U = () => "PÃ­xeles pintados dentro de la regiÃ³n",
  mU = () => "Pixels peints dans la rÃ©gion",
  gU = () => "Pixel dipinti all'interno della regione",
  vU = () => "ãã®åœ°åŸŸå†…ã§å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°",
  yU = () => "Piksele pomalowane wewnÄ…trz regionu",
  bU = () => "ÐŸÐ¸ÐºÑÐµÐ»Ð¸, Ð½Ð°Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð°",
  xU = () => "ÐŸÑ–ÐºÑÐµÐ»Ñ–, Ð½Ð°Ð¼Ð°Ð»ÑŒÐ¾Ð²Ð°Ð½Ñ– Ð² Ð¼ÐµÐ¶Ð°Ñ… Ñ€ÐµÐ³Ñ–Ð¾Ð½Ñƒ",
  wU = () => "Pixel Ä‘Ã£ tÃ´ trong vÃ¹ng",
  kU = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? hU() : r === "pt" ? dU() : r === "ch" ? pU() : r === "de" ? fU() : r === "es" ? _U() : r === "fr" ? mU() : r === "it" ? gU() : r === "jp" ? vU() : r === "pl" ? yU() : r === "ru" ? bU() : r === "uk" ? xU() : wU()
  },
  TU = () => "Players",
  SU = () => "Jogadores",
  PU = () => "çŽ©å®¶",
  MU = () => "Spieler",
  IU = () => "Jugadores",
  CU = () => "Joueurs",
  zU = () => "Giocatori",
  AU = () => "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
  EU = () => "Gracze",
  LU = () => "Ð˜Ð³Ñ€Ð¾ÐºÐ¸",
  DU = () => "Ð“Ñ€Ð°Ð²Ñ†Ñ–",
  RU = () => "NgÆ°á»i chÆ¡i",
  P0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? TU() : r === "pt" ? SU() : r === "ch" ? PU() : r === "de" ? MU() : r === "es" ? IU() : r === "fr" ? CU() : r === "it" ? zU() : r === "jp" ? AU() : r === "pl" ? EU() : r === "ru" ? LU() : r === "uk" ? DU() : RU()
  },
  jU = () => "âœ… Griefing political party flags or portraits of politicians is allowed",
  FU = () => "âœ… Desenhar sobre bandeiras de partidos e retratos de polÃ­ticos Ã© permitido",
  BU = () => "âœ… ç ´åæ”¿å…šæ——å¸œæˆ–æ”¿æ²»äººç‰©è‚–åƒæ˜¯å…è®¸çš„",
  OU = () => "âœ… Das Griefen von Parteiflaggen oder PolitikerportrÃ¤ts ist erlaubt",
  qU = () => "âœ… Griefear banderas de partidos polÃ­ticos o retratos de polÃ­ticos estÃ¡ permitido",
  NU = () => "âœ… Peindre par-dessus les drapeaux de partis politiques ou les portraits de politiciens est autorisÃ©",
  VU = () => "âœ… Ãˆ consentito disegnare sopra bandiere di partito e ritratti di politici",
  UU = () => "âœ… æ”¿å…šã®æ——ã‚„æ”¿æ²»å®¶ã®è‚–åƒç”»ã‚’ã‚°ãƒªãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã™ã‚‹ã“ã¨ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  ZU = () => "âœ… Niszczenie flag partii politycznych lub portretÃ³w politykÃ³w jest dozwolone",
  GU = () => "âœ… Ð“Ñ€Ð¸Ñ„ÐµÑ€ÑÑ‚Ð²Ð¾ Ð¿Ð¾ Ð¾Ñ‚Ð½Ð¾ÑˆÐµÐ½Ð¸ÑŽ Ðº Ñ„Ð»Ð°Ð³Ð°Ð¼ Ð¿Ð°Ñ€Ñ‚Ð¸Ð¹ Ð¸Ð»Ð¸ Ð¿Ð¾Ñ€Ñ‚Ñ€ÐµÑ‚Ð°Ð¼ Ð¿Ð¾Ð»Ð¸Ñ‚Ð¸ÐºÐ¾Ð² Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¾",
  WU = () => "âœ… ÐœÐ°Ð»ÑŽÐ²Ð°Ñ‚Ð¸ Ð¿Ð¾Ð²ÐµÑ€Ñ… Ð¿Ñ€Ð°Ð¿Ð¾Ñ€Ñ–Ð² Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹ Ð°Ð±Ð¾ Ð¿Ð¾Ñ€Ñ‚Ñ€ÐµÑ‚Ñ–Ð² Ð¿Ð¾Ð»Ñ–Ñ‚Ð¸ÐºÑ–Ð² Ð´Ð¾Ð·Ð²Ð¾Ð»ÐµÐ½Ð¾",
  HU = () => "âœ… TÃ´ Ä‘Ã¨ lÃªn cá» Ä‘áº£ng phÃ¡i chÃ­nh trá»‹ hoáº·c chÃ¢n dung chÃ­nh trá»‹ gia lÃ  Ä‘Æ°á»£c phÃ©p",
  $U = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? jU() : r === "pt" ? FU() : r === "ch" ? BU() : r === "de" ? OU() : r === "es" ? qU() : r === "fr" ? NU() : r === "it" ? VU() : r === "jp" ? UU() : r === "pl" ? ZU() : r === "ru" ? GU() : r === "uk" ? WU() : HU()
  },
  XU = () => "Map powered by:",
  YU = () => "Mapa fornecido por:",
  KU = () => "åœ°å›¾æ”¯æŒï¼š",
  JU = () => "Karte bereitgestellt von:",
  QU = () => "Mapa proporcionado por:",
  eZ = () => "Carte fournie par :",
  tZ = () => "Mappa fornita da:",
  rZ = () => "åœ°å›³æä¾›:",
  nZ = () => "Mapa dostarczana przez:",
  iZ = () => "ÐšÐ°Ñ€Ñ‚Ð° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ:",
  aZ = () => "ÐšÐ°Ñ€Ñ‚Ð° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ñ–:",
  oZ = () => "Báº£n Ä‘á»“ Ä‘Æ°á»£c cung cáº¥p bá»Ÿi:",
  sZ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? XU() : r === "pt" ? YU() : r === "ch" ? KU() : r === "de" ? JU() : r === "es" ? QU() : r === "fr" ? eZ() : r === "it" ? tZ() : r === "jp" ? rZ() : r === "pl" ? nZ() : r === "ru" ? iZ() : r === "uk" ? aZ() : oZ()
  },
  lZ = () => "Privacy",
  cZ = () => "Privacidade",
  uZ = () => "éšç§",
  hZ = () => "Datenschutz",
  dZ = () => "Privacidad",
  pZ = () => "ConfidentialitÃ©",
  fZ = () => "Privacy",
  _Z = () => "ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼",
  mZ = () => "PrywatnoÅ›Ä‡",
  gZ = () => "ÐšÐ¾Ð½Ñ„Ð¸Ð´ÐµÐ½Ñ†Ð¸Ð°Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ",
  vZ = () => "ÐšÐ¾Ð½Ñ„Ñ–Ð´ÐµÐ½Ñ†Ñ–Ð¹Ð½Ñ–ÑÑ‚ÑŒ",
  yZ = () => "Quyá»n riÃªng tÆ°",
  bZ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? lZ() : r === "pt" ? cZ() : r === "ch" ? uZ() : r === "de" ? hZ() : r === "es" ? dZ() : r === "fr" ? pZ() : r === "it" ? fZ() : r === "jp" ? _Z() : r === "pl" ? mZ() : r === "ru" ? gZ() : r === "uk" ? vZ() : yZ()
  },
  xZ = () => "Profile",
  wZ = () => "Perfil",
  kZ = () => "ä¸ªäººèµ„æ–™",
  TZ = () => "Profil",
  SZ = () => "Perfil",
  PZ = () => "Profil",
  MZ = () => "Profilo",
  IZ = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«",
  CZ = () => "Profil",
  zZ = () => "ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ",
  AZ = () => "ÐŸÑ€Ð¾Ñ„Ñ–Ð»ÑŒ",
  EZ = () => "Há»“ sÆ¡",
  LZ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? xZ() : r === "pt" ? wZ() : r === "ch" ? kZ() : r === "de" ? TZ() : r === "es" ? SZ() : r === "fr" ? PZ() : r === "it" ? MZ() : r === "jp" ? IZ() : r === "pl" ? CZ() : r === "ru" ? zZ() : r === "uk" ? AZ() : EZ()
  },
  DZ = () => "Profile updated",
  RZ = () => "Perfil atualizado",
  jZ = () => "ä¸ªäººèµ„æ–™å·²æ›´æ–°",
  FZ = () => "Profil aktualisiert",
  BZ = () => "Perfil actualizado",
  OZ = () => "Profil mis Ã  jour",
  qZ = () => "Profilo aggiornato",
  NZ = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚",
  VZ = () => "Profil zaktualizowany",
  UZ = () => "ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð»Ñ‘Ð½",
  ZZ = () => "ÐŸÑ€Ð¾Ñ„Ñ–Ð»ÑŒ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾",
  GZ = () => "ÄÃ£ cáº­p nháº­t há»“ sÆ¡",
  WZ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? DZ() : r === "pt" ? RZ() : r === "ch" ? jZ() : r === "de" ? FZ() : r === "es" ? BZ() : r === "fr" ? OZ() : r === "it" ? qZ() : r === "jp" ? NZ() : r === "pl" ? VZ() : r === "ru" ? UZ() : r === "uk" ? ZZ() : GZ()
  },
  HZ = () => "Random place",
  $Z = () => "Local aleatÃ³rio",
  XZ = () => "éšæœºåœ°ç‚¹",
  YZ = () => "ZufÃ¤lliger Ort",
  KZ = () => "Lugar aleatorio",
  JZ = () => "Lieu alÃ©atoire",
  QZ = () => "Luogo casuale",
  eG = () => "ãƒ©ãƒ³ãƒ€ãƒ ãªå ´æ‰€",
  tG = () => "Losowe miejsce",
  rG = () => "Ð¡Ð»ÑƒÑ‡Ð°Ð¹Ð½Ð¾Ðµ Ð¼ÐµÑÑ‚Ð¾",
  nG = () => "Ð’Ð¸Ð¿Ð°Ð´ÐºÐ¾Ð²Ðµ Ð¼Ñ–ÑÑ†Ðµ",
  iG = () => "Vá»‹ trÃ­ ngáº«u nhiÃªn",
  aG = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? HZ() : r === "pt" ? $Z() : r === "ch" ? XZ() : r === "de" ? YZ() : r === "es" ? KZ() : r === "fr" ? JZ() : r === "it" ? QZ() : r === "jp" ? eG() : r === "pl" ? tG() : r === "ru" ? rG() : r === "uk" ? nG() : iG()
  },
  oG = () => "Recent",
  sG = () => "Recente",
  lG = () => "æœ€è¿‘",
  cG = () => "Aktuell",
  uG = () => "Reciente",
  hG = () => "RÃ©cent",
  dG = () => "Recente",
  pG = () => "æœ€è¿‘",
  fG = () => "Ostatnie",
  _G = () => "ÐÐµÐ´Ð°Ð²Ð½Ð¸Ðµ",
  mG = () => "ÐÐµÑ‰Ð¾Ð´Ð°Ð²Ð½Ñ–",
  gG = () => "Gáº§n Ä‘Ã¢y",
  vG = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? oG() : r === "pt" ? sG() : r === "ch" ? lG() : r === "de" ? cG() : r === "es" ? uG() : r === "fr" ? hG() : r === "it" ? dG() : r === "jp" ? pG() : r === "pl" ? fG() : r === "ru" ? _G() : r === "uk" ? mG() : gG()
  },
  yG = () => "Recharge paint charges",
  bG = () => "Recarga de tinta",
  xG = () => "ä¸ºç»˜åˆ¶å……èƒ½å……ç”µ",
  wG = () => "Pixel-Ladungen aufladen",
  kG = () => "Recargar cargas de pintura",
  TG = () => "Recharger les charges de peinture",
  SG = () => "Ricarica della vernice",
  PG = () => "ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸ã‚’å›žå¾©",
  MG = () => "DoÅ‚aduj Å‚adunki malowania",
  IG = () => "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð·Ð°Ñ€ÑÐ´Ñ‹",
  CG = () => "ÐŸÐ¾Ð¿Ð¾Ð²Ð½Ð¸Ñ‚Ð¸ Ð·Ð°Ñ€ÑÐ´Ð¸ Ñ„Ð°Ñ€Ð±Ð¸",
  zG = () => "Náº¡p láº¡i lÆ°á»£t tÃ´",
  AG = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? yG() : r === "pt" ? bG() : r === "ch" ? xG() : r === "de" ? wG() : r === "es" ? kG() : r === "fr" ? TG() : r === "it" ? SG() : r === "jp" ? PG() : r === "pl" ? MG() : r === "ru" ? IG() : r === "uk" ? CG() : zG()
  },
  EG = () => "Redo",
  LG = () => "Refazer",
  DG = () => "é‡åš",
  RG = () => "Wiederholen",
  jG = () => "Rehacer",
  FG = () => "RÃ©tablir",
  BG = () => "Rifai",
  OG = () => "ã‚„ã‚Šç›´ã™",
  qG = () => "PonÃ³w",
  NG = () => "ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚ÑŒ",
  VG = () => "ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ð¸",
  UG = () => "LÃ m láº¡i",
  ZG = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? EG() : r === "pt" ? LG() : r === "ch" ? DG() : r === "de" ? RG() : r === "es" ? jG() : r === "fr" ? FG() : r === "it" ? BG() : r === "jp" ? OG() : r === "pl" ? qG() : r === "ru" ? NG() : r === "uk" ? VG() : UG()
  },
  GG = () => "Refund",
  WG = () => "Reembolso",
  HG = () => "é€€æ¬¾",
  $G = () => "RÃ¼ckerstattung",
  XG = () => "Reembolso",
  YG = () => "Remboursement",
  KG = () => "Rimborso",
  JG = () => "è¿”é‡‘",
  QG = () => "Zwrot",
  eW = () => "Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‚ ÑÑ€ÐµÐ´ÑÑ‚Ð²",
  tW = () => "ÐŸÐ¾Ð²ÐµÑ€Ð½ÐµÐ½Ð½Ñ ÐºÐ¾ÑˆÑ‚Ñ–Ð²",
  rW = () => "HoÃ n tiá»n",
  M0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? GG() : r === "pt" ? WG() : r === "ch" ? HG() : r === "de" ? $G() : r === "es" ? XG() : r === "fr" ? YG() : r === "it" ? KG() : r === "jp" ? JG() : r === "pl" ? QG() : r === "ru" ? eW() : r === "uk" ? tW() : rW()
  },
  nW = () => "Region",
  iW = () => "RegiÃ£o",
  aW = () => "åŒºåŸŸ",
  oW = () => "Region",
  sW = () => "RegiÃ³n",
  lW = () => "RÃ©gion",
  cW = () => "Regione",
  uW = () => "åœ°åŸŸ",
  hW = () => "Region",
  dW = () => "Ð ÐµÐ³Ð¸Ð¾Ð½",
  pW = () => "Ð ÐµÐ³Ñ–Ð¾Ð½",
  fW = () => "VÃ¹ng",
  _W = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? nW() : r === "pt" ? iW() : r === "ch" ? aW() : r === "de" ? oW() : r === "es" ? sW() : r === "fr" ? lW() : r === "it" ? cW() : r === "jp" ? uW() : r === "pl" ? hW() : r === "ru" ? dW() : r === "uk" ? pW() : fW()
  },
  mW = () => "Regions",
  gW = () => "RegiÃµes",
  vW = () => "åŒºåŸŸ",
  yW = () => "Regionen",
  bW = () => "Regiones",
  xW = () => "RÃ©gions",
  wW = () => "Regioni",
  kW = () => "åœ°åŸŸ",
  TW = () => "Regiony",
  SW = () => "Ð ÐµÐ³Ð¸Ð¾Ð½Ñ‹",
  PW = () => "Ð ÐµÐ³Ñ–Ð¾Ð½Ð¸",
  MW = () => "CÃ¡c vÃ¹ng",
  IW = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? mW() : r === "pt" ? gW() : r === "ch" ? vW() : r === "de" ? yW() : r === "es" ? bW() : r === "fr" ? xW() : r === "it" ? wW() : r === "jp" ? kW() : r === "pl" ? TW() : r === "ru" ? SW() : r === "uk" ? PW() : MW()
  },
  CW = () => "Report feedback",
  zW = () => "Feedback de denÃºncia",
  AW = () => "ä¸¾æŠ¥åé¦ˆ",
  EW = () => "Meldungs-Feedback",
  LW = () => "Feedback del reporte",
  DW = () => "Retour de signalement",
  RW = () => "Feedback segnalazione",
  jW = () => "é€šå ±ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯",
  FW = () => "Informacja zwrotna o zgÅ‚oszeniu",
  BW = () => "ÐžÐ±Ñ€Ð°Ñ‚Ð½Ð°Ñ ÑÐ²ÑÐ·ÑŒ Ð¿Ð¾ Ð¶Ð°Ð»Ð¾Ð±Ðµ",
  OW = () => "Ð’Ñ–Ð´Ð³ÑƒÐº Ñ‰Ð¾Ð´Ð¾ ÑÐºÐ°Ñ€Ð³Ð¸",
  qW = () => "Pháº£n há»“i bÃ¡o cÃ¡o",
  mv = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? CW() : r === "pt" ? zW() : r === "ch" ? AW() : r === "de" ? EW() : r === "es" ? LW() : r === "fr" ? DW() : r === "it" ? RW() : r === "jp" ? jW() : r === "pl" ? FW() : r === "ru" ? BW() : r === "uk" ? OW() : qW()
  },
  NW = () => "Your report has been reviewed, and a penalty has been applied to the reported player.",
  VW = () => "Um jogador denunciado recentemente por vocÃª foi punido.",
  UW = () => "ä½ çš„ä¸¾æŠ¥å·²è¢«å®¡æ ¸ï¼Œå¯¹è¢«ä¸¾æŠ¥çŽ©å®¶å·²æ–½åŠ æƒ©ç½šã€‚",
  ZW = () => "Deine Meldung wurde Ã¼berprÃ¼ft und der gemeldete Spieler wurde bestraft.",
  GW = () => "Un jugador reportado recientemente por ti ha sido sancionado.",
  WW = () => "Votre signalement a Ã©tÃ© analysÃ© et une sanction a Ã©tÃ© appliquÃ©e au joueur signalÃ©.",
  HW = () => "Un giocatore che hai segnalato di recente Ã¨ stato punito.",
  $W = () => "ã‚ãªãŸã®é€šå ±ãŒç¢ºèªã•ã‚Œã€å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‡¦ç½°ãŒé©ç”¨ã•ã‚Œã¾ã—ãŸã€‚",
  XW = () => "Twoje zgÅ‚oszenie zostaÅ‚o przeanalizowane i na ukaranego gracza naÅ‚oÅ¼ono karÄ™.",
  YW = () => "Ð’Ð°ÑˆÐ° Ð½ÐµÐ´Ð°Ð²Ð½ÑÑ Ð¶Ð°Ð»Ð¾Ð±Ð° Ð±Ñ‹Ð»Ð° Ñ€Ð°ÑÑÐ¼Ð¾Ñ‚Ñ€ÐµÐ½Ð°, Ð¸ Ðº ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÑƒ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¾ Ð½Ð°ÐºÐ°Ð·Ð°Ð½Ð¸Ðµ.",
  KW = () => "ÐšÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ð°, Ð½Ð° ÑÐºÐ¾Ð³Ð¾ Ð²Ð¸ Ð½ÐµÑ‰Ð¾Ð´Ð°Ð²Ð½Ð¾ Ð¿Ð¾ÑÐºÐ°Ñ€Ð¶Ð¸Ð»Ð¸ÑÑ, Ð±ÑƒÐ»Ð¾ Ð¿Ð¾ÐºÐ°Ñ€Ð°Ð½Ð¾.",
  JW = () => "BÃ¡o cÃ¡o gáº§n Ä‘Ã¢y cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½ vÃ  ngÆ°á»i chÆ¡i bá»‹ bÃ¡o cÃ¡o Ä‘Ã£ bá»‹ pháº¡t.",
  gv = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? NW() : r === "pt" ? VW() : r === "ch" ? UW() : r === "de" ? ZW() : r === "es" ? GW() : r === "fr" ? WW() : r === "it" ? HW() : r === "jp" ? $W() : r === "pl" ? XW() : r === "ru" ? YW() : r === "uk" ? KW() : JW()
  },
  QW = () => "Thank you for helping keep the community fair and safe.",
  eH = () => "Obrigado por ajudar a manter a comunidade justa e segura!",
  tH = () => "æ„Ÿè°¢ä½ å¸®åŠ©ç»´æŠ¤ç¤¾åŒºçš„å…¬å¹³ä¸Žå®‰å…¨ã€‚",
  rH = () => "Danke, dass du hilfst, die Community fair und sicher zu halten.",
  nH = () => "Gracias por ayudar a mantener la comunidad justa y segura.",
  iH = () => "Merci dâ€™aider Ã  garder la communautÃ© juste et sÃ»re.",
  aH = () => "Grazie per aiutare a mantenere la comunitÃ  giusta e sicura!",
  oH = () => "ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚’å…¬æ­£ã§å®‰å…¨ã«ä¿ã¤ãŸã‚ã«ã”å”åŠ›ã„ãŸã ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚",
  sH = () => "DziÄ™kujemy za pomoc w utrzymaniu uczciwej i bezpiecznej spoÅ‚ecznoÅ›ci.",
  lH = () => "Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾, Ñ‡Ñ‚Ð¾ Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÐµÑ‚Ðµ Ð´ÐµÐ»Ð°Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÑÑ‚Ð²Ð¾ Ñ‡ÐµÑÑ‚Ð½ÐµÐµ Ð¸ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½ÐµÐµ.",
  cH = () => "Ð”ÑÐºÑƒÑ”Ð¼Ð¾, Ñ‰Ð¾ Ð´Ð¾Ð¿Ð¾Ð¼Ð°Ð³Ð°Ñ”Ñ‚Ðµ Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÑƒÐ²Ð°Ñ‚Ð¸ Ñ‡ÐµÑÐ½Ñ–ÑÑ‚ÑŒ Ñ‚Ð° Ð±ÐµÐ·Ð¿ÐµÐºÑƒ ÑÐ¿Ñ–Ð»ÑŒÐ½Ð¾Ñ‚Ð¸.",
  uH = () => "Cáº£m Æ¡n báº¡n Ä‘Ã£ giÃºp giá»¯ cá»™ng Ä‘á»“ng cÃ´ng báº±ng vÃ  an toÃ n.",
  hH = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? QW() : r === "pt" ? eH() : r === "ch" ? tH() : r === "de" ? rH() : r === "es" ? nH() : r === "fr" ? iH() : r === "it" ? aH() : r === "jp" ? oH() : r === "pl" ? sH() : r === "ru" ? lH() : r === "uk" ? cH() : uH()
  },
  dH = () => "This action may take some time to be completed.",
  pH = () => "Essa aÃ§Ã£o pode levar algum tempo para ser realizada.",
  fH = () => "è¯¥æ“ä½œå¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´æ‰èƒ½å®Œæˆã€‚",
  _H = () => "Diese Aktion kann etwas Zeit in Anspruch nehmen.",
  mH = () => "Esta acciÃ³n puede tardar un poco en completarse.",
  gH = () => "Cette action peut prendre un certain temps Ã  Ãªtre complÃ©tÃ©e.",
  vH = () => "Questa azione potrebbe richiedere del tempo per essere completata.",
  yH = () => "ã“ã®æ“ä½œã®å®Œäº†ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚",
  bH = () => "Ta akcja moÅ¼e chwilÄ™ potrwaÄ‡.",
  xH = () => "Ð­Ñ‚Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð·Ð°Ð½ÑÑ‚ÑŒ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ.",
  wH = () => "Ð¦Ñ Ð´Ñ–Ñ Ð¼Ð¾Ð¶Ðµ Ð·Ð°Ð¹Ð½ÑÑ‚Ð¸ Ð´ÐµÑÐºÐ¸Ð¹ Ñ‡Ð°Ñ.",
  kH = () => "HÃ nh Ä‘á»™ng nÃ y cÃ³ thá»ƒ máº¥t má»™t lÃºc Ä‘á»ƒ hoÃ n thÃ nh.",
  TH = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? dH() : r === "pt" ? pH() : r === "ch" ? fH() : r === "de" ? _H() : r === "es" ? mH() : r === "fr" ? gH() : r === "it" ? vH() : r === "jp" ? yH() : r === "pl" ? bH() : r === "ru" ? xH() : r === "uk" ? wH() : kH()
  },
  SH = () => "Rules",
  PH = () => "Regras",
  MH = () => "è§„åˆ™",
  IH = () => "Regeln",
  CH = () => "Reglas",
  zH = () => "RÃ¨gles",
  AH = () => "Regole",
  EH = () => "ãƒ«ãƒ¼ãƒ«",
  LH = () => "Zasady",
  DH = () => "ÐŸÑ€Ð°Ð²Ð¸Ð»Ð°",
  RH = () => "ÐŸÑ€Ð°Ð²Ð¸Ð»Ð°",
  jH = () => "Luáº­t",
  FH = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? SH() : r === "pt" ? PH() : r === "ch" ? MH() : r === "de" ? IH() : r === "es" ? CH() : r === "fr" ? zH() : r === "it" ? AH() : r === "jp" ? EH() : r === "pl" ? LH() : r === "ru" ? DH() : r === "uk" ? RH() : jH()
  },
  BH = () => "Select a color",
  OH = () => "Selecione uma color",
  qH = () => "é€‰æ‹©ä¸€ç§é¢œè‰²",
  NH = () => "Farbe auswÃ¤hlen",
  VH = () => "Selecciona un color",
  UH = () => "SÃ©lectionnez une couleur",
  ZH = () => "Seleziona un colore",
  GH = () => "è‰²ã‚’é¸æŠž",
  WH = () => "Wybierz kolor",
  HH = () => "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ†Ð²ÐµÑ‚",
  $H = () => "Ð’Ð¸Ð±ÐµÑ€Ñ–Ñ‚ÑŒ ÐºÐ¾Ð»Ñ–Ñ€",
  XH = () => "Chá»n má»™t mÃ u",
  YH = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? BH() : r === "pt" ? OH() : r === "ch" ? qH() : r === "de" ? NH() : r === "es" ? VH() : r === "fr" ? UH() : r === "it" ? ZH() : r === "jp" ? GH() : r === "pl" ? WH() : r === "ru" ? HH() : r === "uk" ? $H() : XH()
  },
  KH = () => "Select a pixel to erase",
  JH = () => "Selecione um pixel para apagar",
  QH = () => "é€‰æ‹©è¦æ“¦é™¤çš„åƒç´ ",
  e$ = () => "Pixel zum LÃ¶schen auswÃ¤hlen",
  t$ = () => "Selecciona un pÃ­xel para borrar",
  r$ = () => "SÃ©lectionnez un pixel Ã  effacer",
  n$ = () => "Seleziona un pixel da cancellare",
  i$ = () => "æ¶ˆã—ãŸã„ãƒ”ã‚¯ã‚»ãƒ«ã‚’é¸æŠž",
  a$ = () => "Wybierz piksel do usuniÄ™cia",
  o$ = () => "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ Ð´Ð»Ñ ÑÑ‚Ð¸Ñ€Ð°Ð½Ð¸Ñ",
  s$ = () => "Ð’Ð¸Ð±ÐµÑ€Ñ–Ñ‚ÑŒ Ð¿Ñ–ÐºÑÐµÐ»ÑŒ Ð´Ð»Ñ ÑÑ‚Ð¸Ñ€Ð°Ð½Ð½Ñ",
  l$ = () => "Chá»n pixel Ä‘á»ƒ xÃ³a",
  c$ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? KH() : r === "pt" ? JH() : r === "ch" ? QH() : r === "de" ? e$() : r === "es" ? t$() : r === "fr" ? r$() : r === "it" ? n$() : r === "jp" ? i$() : r === "pl" ? a$() : r === "ru" ? o$() : r === "uk" ? s$() : l$()
  },
  u$ = () => "Select the area's first corner",
  h$ = () => "Selecione o primeiro canto da Ã¡rea",
  d$ = () => "é€‰æ‹©åŒºåŸŸçš„ç¬¬ä¸€ä¸ªè§’",
  p$ = () => "Erste Ecke des Bereichs auswÃ¤hlen",
  f$ = () => "Selecciona la primera esquina del Ã¡rea",
  _$ = () => "SÃ©lectionnez le premier coin de la zone",
  m$ = () => "Seleziona il primo angolo dell'area",
  g$ = () => "é ˜åŸŸã®æœ€åˆã®è§’ã‚’é¸æŠž",
  v$ = () => "Wybierz pierwszy naroÅ¼nik obszaru",
  y$ = () => "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÑƒÐ³Ð¾Ð» Ð¾Ð±Ð»Ð°ÑÑ‚Ð¸",
  b$ = () => "Ð’Ð¸Ð±ÐµÑ€Ñ–Ñ‚ÑŒ Ð¿ÐµÑ€ÑˆÐ¸Ð¹ ÐºÑƒÑ‚ Ð¾Ð±Ð»Ð°ÑÑ‚Ñ–",
  x$ = () => "Chá»n gÃ³c Ä‘áº§u tiÃªn cá»§a vÃ¹ng",
  w$ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? u$() : r === "pt" ? h$() : r === "ch" ? d$() : r === "de" ? p$() : r === "es" ? f$() : r === "fr" ? _$() : r === "it" ? m$() : r === "jp" ? g$() : r === "pl" ? v$() : r === "ru" ? y$() : r === "uk" ? b$() : x$()
  },
  k$ = () => "Select the area's opposite corner",
  T$ = () => "Selecione o canto oposto da Ã¡rea",
  S$ = () => "é€‰æ‹©åŒºåŸŸçš„å¯¹è§’",
  P$ = () => "GegenÃ¼berliegende Ecke des Bereichs auswÃ¤hlen",
  M$ = () => "Selecciona la esquina opuesta del Ã¡rea",
  I$ = () => "SÃ©lectionnez le coin opposÃ© de la zone",
  C$ = () => "Seleziona l'angolo opposto dell'area",
  z$ = () => "é ˜åŸŸã®åå¯¾å´ã®è§’ã‚’é¸æŠž",
  A$ = () => "Wybierz przeciwlegÅ‚y naroÅ¼nik obszaru",
  E$ = () => "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½Ñ‹Ð¹ ÑƒÐ³Ð¾Ð» Ð¾Ð±Ð»Ð°ÑÑ‚Ð¸",
  L$ = () => "Ð’Ð¸Ð±ÐµÑ€Ñ–Ñ‚ÑŒ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð»ÐµÐ¶Ð½Ð¸Ð¹ ÐºÑƒÑ‚ Ð¾Ð±Ð»Ð°ÑÑ‚Ñ–",
  D$ = () => "Chá»n gÃ³c Ä‘á»‘i diá»‡n cá»§a vÃ¹ng",
  R$ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? k$() : r === "pt" ? T$() : r === "ch" ? S$() : r === "de" ? P$() : r === "es" ? M$() : r === "fr" ? I$() : r === "it" ? C$() : r === "jp" ? z$() : r === "pl" ? A$() : r === "ru" ? E$() : r === "uk" ? L$() : D$()
  },
  j$ = () => "Select the headquarters location",
  F$ = () => "Selecione a localizaÃ§Ã£o do quartel general",
  B$ = () => "é€‰æ‹©æ€»éƒ¨ä½ç½®",
  O$ = () => "Standort des Hauptquartiers auswÃ¤hlen",
  q$ = () => "Selecciona la ubicaciÃ³n del cuartel general",
  N$ = () => "SÃ©lectionnez lâ€™emplacement du quartier gÃ©nÃ©ral",
  V$ = () => "Seleziona la posizione del quartier generale",
  U$ = () => "æ‹ ç‚¹ã®å ´æ‰€ã‚’é¸æŠž",
  Z$ = () => "Wybierz lokalizacjÄ™ siedziby",
  G$ = () => "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¼ÐµÑÑ‚Ð¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑˆÑ‚Ð°Ð±-ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ñ€Ñ‹",
  W$ = () => "Ð’Ð¸Ð±ÐµÑ€Ñ–Ñ‚ÑŒ Ñ€Ð¾Ð·Ñ‚Ð°ÑˆÑƒÐ²Ð°Ð½Ð½Ñ ÑˆÑ‚Ð°Ð±-ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ñ€Ð¸",
  H$ = () => "Chá»n vá»‹ trÃ­ trá»¥ sá»Ÿ",
  $$ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? j$() : r === "pt" ? F$() : r === "ch" ? B$() : r === "de" ? O$() : r === "es" ? q$() : r === "fr" ? N$() : r === "it" ? V$() : r === "jp" ? U$() : r === "pl" ? Z$() : r === "ru" ? G$() : r === "uk" ? W$() : H$()
  },
  X$ = () => "Send the link below to everybody you want to invite to the alliance",
  Y$ = () => "Envie o link abaixo para quem vocÃª deseja convidar para a alianÃ§a",
  K$ = () => "å°†ä¸‹é¢çš„é“¾æŽ¥å‘é€ç»™ä½ æƒ³é‚€è¯·åŠ å…¥è”ç›Ÿçš„æ‰€æœ‰äºº",
  J$ = () => "Sende den untenstehenden Link an alle, die du in die Allianz einladen mÃ¶chtest",
  Q$ = () => "EnvÃ­a el siguiente enlace a las personas que quieras invitar a la alianza",
  eX = () => "Envoyez le lien ci-dessous Ã  toutes les personnes que vous souhaitez inviter dans lâ€™alliance",
  tX = () => "Invia il link qui sotto a chi vuoi invitare nell'alleanza",
  rX = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‹›å¾…ã—ãŸã„ç›¸æ‰‹ã«ã€ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’é€ã£ã¦ãã ã•ã„ã€‚",
  nX = () => "WyÅ›lij poniÅ¼szy link wszystkim, ktÃ³rych chcesz zaprosiÄ‡ do sojuszu",
  iX = () => "ÐžÑ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð¸Ð¶Ðµ Ð²ÑÐµÐ¼, ÐºÐ¾Ð³Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸Ð³Ð»Ð°ÑÐ¸Ñ‚ÑŒ Ð² Ð°Ð»ÑŒÑÐ½Ñ",
  aX = () => "ÐÐ°Ð´Ñ–ÑˆÐ»Ñ–Ñ‚ÑŒ Ð¿Ð¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ Ð½Ð¸Ð¶Ñ‡Ðµ Ð²ÑÑ–Ð¼, ÐºÐ¾Ð³Ð¾ Ñ…Ð¾Ñ‡ÐµÑ‚Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚Ð¸ Ð² Ð°Ð»ÑŒÑÐ½Ñ",
  oX = () => "Gá»­i liÃªn káº¿t dÆ°á»›i Ä‘Ã¢y cho nhá»¯ng ngÆ°á»i báº¡n muá»‘n má»i vÃ o liÃªn minh",
  sX = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? X$() : r === "pt" ? Y$() : r === "ch" ? K$() : r === "de" ? J$() : r === "es" ? Q$() : r === "fr" ? eX() : r === "it" ? tX() : r === "jp" ? rX() : r === "pl" ? nX() : r === "ru" ? iX() : r === "uk" ? aX() : oX()
  },
  lX = () => "Your browser doesn't seem to be compatible to load the map. Please try another browser",
  cX = () => "Seu navegador nÃ£o parece ser compatÃ­vel para o mapa. Por favor, tente outro navegador",
  uX = () => "æ‚¨çš„æµè§ˆå™¨ä¼¼ä¹Žä¸å…¼å®¹åŠ è½½åœ°å›¾ã€‚è¯·å°è¯•ä½¿ç”¨å…¶ä»–æµè§ˆå™¨",
  hX = () => "Ihr Browser scheint nicht kompatibel zu sein, um die Karte zu laden. Bitte versuchen Sie es mit einem anderen Browser",
  dX = () => "Tu navegador no parece ser compatible para cargar el mapa. Por favor, prueba con otro navegador.",
  pX = () => "Votre navigateur ne semble pas compatible pour charger la carte. Veuillez essayer un autre navigateur",
  fX = () => "Il tuo browser non sembra essere compatibile per caricare la mappa. Prova un altro browser",
  _X = () => "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯åœ°å›³ã®èª­ã¿è¾¼ã¿ã«å¯¾å¿œã—ã¦ã„ãªã„ã‚ˆã†ã§ã™ã€‚åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚",
  mX = () => "Twoja przeglÄ…darka wydaje siÄ™ byÄ‡ niekompatybilna z Å‚adowaniem mapy. SprÃ³buj innej przeglÄ…darki.",
  gX = () => "Ð’Ð°Ñˆ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€, Ð¿Ð¾Ñ…Ð¾Ð¶Ðµ, Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ ÐºÐ°Ñ€Ñ‚Ñ‹. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€.",
  vX = () => "Ð’Ð°Ñˆ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€, ÑÑ…Ð¾Ð¶Ðµ, Ð½ÐµÑÑƒÐ¼Ñ–ÑÐ½Ð¸Ð¹ Ð´Ð»Ñ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ ÐºÐ°Ñ€Ñ‚Ð¸. Ð‘ÑƒÐ´ÑŒ Ð»Ð°ÑÐºÐ°, ÑÐ¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ñ–Ð½ÑˆÐ¸Ð¹ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€",
  yX = () => "TrÃ¬nh duyá»‡t cá»§a báº¡n cÃ³ váº» khÃ´ng tÆ°Æ¡ng thÃ­ch Ä‘á»ƒ táº£i báº£n Ä‘á»“. Vui lÃ²ng thá»­ trÃ¬nh duyá»‡t khÃ¡c",
  bX = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? lX() : r === "pt" ? cX() : r === "ch" ? uX() : r === "de" ? hX() : r === "es" ? dX() : r === "fr" ? pX() : r === "it" ? fX() : r === "jp" ? _X() : r === "pl" ? mX() : r === "ru" ? gX() : r === "uk" ? vX() : yX()
  },
  xX = () => "Share",
  wX = () => "Compartilhar",
  kX = () => "åˆ†äº«",
  TX = () => "Teilen",
  SX = () => "Compartir",
  PX = () => "Partager",
  MX = () => "Condividi",
  IX = () => "å…±æœ‰",
  CX = () => "UdostÄ™pnij",
  zX = () => "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ",
  AX = () => "ÐŸÐ¾Ð´Ñ–Ð»Ð¸Ñ‚Ð¸ÑÑ",
  EX = () => "Chia sáº»",
  LX = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? xX() : r === "pt" ? wX() : r === "ch" ? kX() : r === "de" ? TX() : r === "es" ? SX() : r === "fr" ? PX() : r === "it" ? MX() : r === "jp" ? IX() : r === "pl" ? CX() : r === "ru" ? zX() : r === "uk" ? AX() : EX()
  },
  DX = () => "Share place",
  RX = () => "Compartilhar local",
  jX = () => "åˆ†äº«åœ°ç‚¹",
  FX = () => "Ort teilen",
  BX = () => "Compartir lugar",
  OX = () => "Partager le lieu",
  qX = () => "Condividi luogo",
  NX = () => "å ´æ‰€ã‚’å…±æœ‰",
  VX = () => "UdostÄ™pnij miejsce",
  UX = () => "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð¼ÐµÑÑ‚Ð¾Ð¼",
  ZX = () => "ÐŸÐ¾Ð´Ñ–Ð»Ð¸Ñ‚Ð¸ÑÑ Ð¼Ñ–ÑÑ†ÐµÐ¼",
  GX = () => "Chia sáº» vá»‹ trÃ­",
  WX = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? DX() : r === "pt" ? RX() : r === "ch" ? jX() : r === "de" ? FX() : r === "es" ? BX() : r === "fr" ? OX() : r === "it" ? qX() : r === "jp" ? NX() : r === "pl" ? VX() : r === "ru" ? UX() : r === "uk" ? ZX() : GX()
  },
  HX = () => "Show last painted pixel on alliance",
  $X = () => "Mostrar Ãºltimo pixel pintado na alianÃ§a",
  XX = () => "åœ¨è”ç›Ÿä¸­æ˜¾ç¤ºæœ€åŽç»˜åˆ¶çš„åƒç´ ",
  YX = () => "Zuletzt gemalten Pixel in der Allianz anzeigen",
  KX = () => "Mostrar el Ãºltimo pÃ­xel pintado en la alianza",
  JX = () => "Afficher le dernier pixel peint dans lâ€™alliance",
  QX = () => "Mostra l'ultimo pixel dipinto nell'alleanza",
  eY = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã®æœ€å¾Œã«å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã‚’è¡¨ç¤º",
  tY = () => "PokaÅ¼ ostatni pomalowany piksel w sojuszu",
  rY = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ, Ð½Ð°Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð°Ð»ÑŒÑÐ½ÑÐ¾Ð¼",
  nY = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚Ð¸ Ð¾ÑÑ‚Ð°Ð½Ð½Ñ–Ð¹ Ð½Ð°Ð¼Ð°Ð»ÑŒÐ¾Ð²Ð°Ð½Ð¸Ð¹ Ð¿Ñ–ÐºÑÐµÐ»ÑŒ Ð² Ð°Ð»ÑŒÑÐ½ÑÑ–",
  iY = () => "Hiá»ƒn thá»‹ pixel cuá»‘i cÃ¹ng Ä‘Æ°á»£c tÃ´ cá»§a liÃªn minh",
  aY = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? HX() : r === "pt" ? $X() : r === "ch" ? XX() : r === "de" ? YX() : r === "es" ? KX() : r === "fr" ? JX() : r === "it" ? QX() : r === "jp" ? eY() : r === "pl" ? tY() : r === "ru" ? rY() : r === "uk" ? nY() : iY()
  },
  oY = () => "Show Pixel Art",
  sY = () => "Mostrar Pixel Art",
  lY = () => "æ˜¾ç¤ºåƒç´ è‰ºæœ¯",
  cY = () => "Pixel-Art anzeigen",
  uY = () => "Mostrar Pixel Art",
  hY = () => "Afficher le pixel art",
  dY = () => "Mostra Pixel Art",
  pY = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚¢ãƒ¼ãƒˆã‚’è¡¨ç¤º",
  fY = () => "PokaÅ¼ Pixel Art",
  _Y = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ-Ð°Ñ€Ñ‚",
  mY = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚Ð¸ Pixel Art",
  gY = () => "Hiá»ƒn thá»‹ pixel art",
  vY = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? oY() : r === "pt" ? sY() : r === "ch" ? lY() : r === "de" ? cY() : r === "es" ? uY() : r === "fr" ? hY() : r === "it" ? dY() : r === "jp" ? pY() : r === "pl" ? fY() : r === "ru" ? _Y() : r === "uk" ? mY() : gY()
  },
  yY = () => "Show profile",
  bY = () => "Exibir perfil",
  xY = () => "æŸ¥çœ‹ä¸ªäººèµ„æ–™",
  wY = () => "Profil anzeigen",
  kY = () => "Mostrar perfil",
  TY = () => "Afficher le profil",
  SY = () => "Mostra profilo",
  PY = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’è¦‹ã‚‹",
  MY = () => "PokaÅ¼ profil",
  IY = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ",
  CY = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚Ð¸ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»ÑŒ",
  zY = () => "Hiá»ƒn thá»‹ há»“ sÆ¡",
  AY = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? yY() : r === "pt" ? bY() : r === "ch" ? xY() : r === "de" ? wY() : r === "es" ? kY() : r === "fr" ? TY() : r === "it" ? SY() : r === "jp" ? PY() : r === "pl" ? MY() : r === "ru" ? IY() : r === "uk" ? CY() : zY()
  },
  EY = () => "SPACE",
  LY = () => "EspaÃ§o",
  DY = () => "ç©ºæ ¼é”®",
  RY = () => "Leertaste",
  jY = () => "Espacio",
  FY = () => "Espace",
  BY = () => "Spazio",
  OY = () => "ã‚¹ãƒšãƒ¼ã‚¹",
  qY = () => "SPACJA",
  NY = () => "ÐŸÑ€Ð¾Ð±ÐµÐ»",
  VY = () => "ÐŸÑ€Ð¾Ð±Ñ–Ð»",
  UY = () => "PhÃ­m cÃ¡ch",
  ZY = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? EY() : r === "pt" ? LY() : r === "ch" ? DY() : r === "de" ? RY() : r === "es" ? jY() : r === "fr" ? FY() : r === "it" ? BY() : r === "jp" ? OY() : r === "pl" ? qY() : r === "ru" ? NY() : r === "uk" ? VY() : UY()
  },
  GY = () => "Store",
  WY = () => "Loja",
  HY = () => "å•†åº—",
  $Y = () => "Shop",
  XY = () => "Tienda",
  YY = () => "Boutique",
  KY = () => "Negozio",
  JY = () => "ã‚¹ãƒˆã‚¢",
  QY = () => "Sklep",
  eK = () => "ÐœÐ°Ð³Ð°Ð·Ð¸Ð½",
  tK = () => "ÐœÐ°Ð³Ð°Ð·Ð¸Ð½",
  rK = () => "Cá»­a hÃ ng",
  I0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? GY() : r === "pt" ? WY() : r === "ch" ? HY() : r === "de" ? $Y() : r === "es" ? XY() : r === "fr" ? YY() : r === "it" ? KY() : r === "jp" ? JY() : r === "pl" ? QY() : r === "ru" ? eK() : r === "uk" ? tK() : rK()
  },
  nK = () => "Submit",
  iK = () => "Enviar",
  aK = () => "æäº¤",
  oK = () => "Senden",
  sK = () => "Enviar",
  lK = () => "Envoyer",
  cK = () => "Invia",
  uK = () => "é€ä¿¡",
  hK = () => "WyÅ›lij",
  dK = () => "ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ",
  pK = () => "ÐÐ°Ð´Ñ–ÑÐ»Ð°Ñ‚Ð¸",
  fK = () => "Gá»­i",
  _K = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? nK() : r === "pt" ? iK() : r === "ch" ? aK() : r === "de" ? oK() : r === "es" ? sK() : r === "fr" ? lK() : r === "it" ? cK() : r === "jp" ? uK() : r === "pl" ? hK() : r === "ru" ? dK() : r === "uk" ? pK() : fK()
  },
  mK = () => "Suggestions",
  gK = () => "SugestÃµes",
  vK = () => "å»ºè®®",
  yK = () => "VorschlÃ¤ge",
  bK = () => "Sugerencias",
  xK = () => "Suggestions",
  wK = () => "Suggerimenti",
  kK = () => "ææ¡ˆ",
  TK = () => "Sugestie",
  SK = () => "ÐŸÑ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ",
  PK = () => "ÐŸÑ€Ð¾Ð¿Ð¾Ð·Ð¸Ñ†Ñ–Ñ—",
  MK = () => "Gá»£i Ã½",
  IK = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? mK() : r === "pt" ? gK() : r === "ch" ? vK() : r === "de" ? yK() : r === "es" ? bK() : r === "fr" ? xK() : r === "it" ? wK() : r === "jp" ? kK() : r === "pl" ? TK() : r === "ru" ? SK() : r === "uk" ? PK() : MK()
  },
  CK = () => "Service Workers are not supported/enabled in your browser. Some features might not work properly.",
  zK = () => "Service Workers nÃ£o sÃ£o suportados ou estÃ£o desativados em seu navegador. Alguns recursos podem nÃ£o funcionar corretamente.",
  AK = () => "ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒ/æœªå¯ç”¨ Service Workerã€‚ä¸€äº›åŠŸèƒ½å¯èƒ½æ— æ³•æ­£å¸¸å·¥ä½œã€‚",
  EK = () => "Service Worker werden in deinem Browser nicht unterstÃ¼tzt/aktiviert. Einige Funktionen kÃ¶nnten nicht richtig funktionieren.",
  LK = () => "Service Workers no estÃ¡n soportados o estÃ¡n desactivados en tu navegador. Algunas funciones pueden no funcionar correctamente.",
  DK = () => "Les Service Workers ne sont pas pris en charge/activÃ©s dans votre navigateur. Certaines fonctionnalitÃ©s peuvent ne pas fonctionner correctement.",
  RK = () => "I Service Worker non sono supportati o sono disabilitati nel tuo browser. Alcune funzionalitÃ  potrebbero non funzionare correttamente.",
  jK = () => "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯Service WorkerãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚ä¸€éƒ¨ã®æ©Ÿèƒ½ãŒæ­£ã—ãå‹•ä½œã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚",
  FK = () => "Service Workers nie sÄ… obsÅ‚ugiwane lub sÄ… wyÅ‚Ä…czone w Twojej przeglÄ…darce. NiektÃ³re funkcje mogÄ… nie dziaÅ‚aÄ‡ poprawnie.",
  BK = () => "Service Workers Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÑŽÑ‚ÑÑ Ð¸Ð»Ð¸ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ñ‹ Ð² Ð²Ð°ÑˆÐµÐ¼ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ðµ. ÐÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð¼Ð¾Ð³ÑƒÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½ÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾.",
  OK = () => "Service Workers Ð½Ðµ Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÑƒÑŽÑ‚ÑŒÑÑ Ð°Ð±Ð¾ Ð²Ð¸Ð¼ÐºÐ½ÐµÐ½Ñ– Ñƒ Ð²Ð°ÑˆÐ¾Ð¼Ñƒ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ñ–. Ð”ÐµÑÐºÑ– Ñ„ÑƒÐ½ÐºÑ†Ñ–Ñ— Ð¼Ð¾Ð¶ÑƒÑ‚ÑŒ Ð¿Ñ€Ð°Ñ†ÑŽÐ²Ð°Ñ‚Ð¸ Ð½ÐµÐºÐ¾Ñ€ÐµÐºÑ‚Ð½Ð¾.",
  qK = () => "TrÃ¬nh duyá»‡t cá»§a báº¡n khÃ´ng há»— trá»£/báº­t Service Workers. Má»™t sá»‘ tÃ­nh nÄƒng cÃ³ thá»ƒ khÃ´ng hoáº¡t Ä‘á»™ng Ä‘Ãºng.",
  NK = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? CK() : r === "pt" ? zK() : r === "ch" ? AK() : r === "de" ? EK() : r === "es" ? LK() : r === "fr" ? DK() : r === "it" ? RK() : r === "jp" ? jK() : r === "pl" ? FK() : r === "ru" ? BK() : r === "uk" ? OK() : qK()
  },
  VK = () => "Terms",
  UK = () => "Termos",
  ZK = () => "æ¡æ¬¾",
  GK = () => "Bedingungen",
  WK = () => "TÃ©rminos",
  HK = () => "Conditions",
  $K = () => "Termini",
  XK = () => "åˆ©ç”¨è¦ç´„",
  YK = () => "Warunki",
  KK = () => "Ð£ÑÐ»Ð¾Ð²Ð¸Ñ",
  JK = () => "Ð£Ð¼Ð¾Ð²Ð¸",
  QK = () => "Äiá»u khoáº£n",
  eJ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? VK() : r === "pt" ? UK() : r === "ch" ? ZK() : r === "de" ? GK() : r === "es" ? WK() : r === "fr" ? HK() : r === "it" ? $K() : r === "jp" ? XK() : r === "pl" ? YK() : r === "ru" ? KK() : r === "uk" ? JK() : QK()
  },
  tJ = () => "This action is irreversible, do you want to proceed?",
  rJ = () => "Esta aÃ§Ã£o Ã© irreversÃ­vel, vocÃª deseja prosseguir?",
  nJ = () => "æ­¤æ“ä½œä¸å¯é€†ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ",
  iJ = () => "Diese Aktion ist irreversibel. MÃ¶chtest du fortfahren?",
  aJ = () => "Esta acciÃ³n es irreversible, Â¿quieres continuar?",
  oJ = () => "Cette action est irrÃ©versible, souhaitez-vous continuer ?",
  sJ = () => "Questa azione Ã¨ irreversibile, vuoi procedere?",
  lJ = () => "ã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚å®Ÿè¡Œã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
  cJ = () => "Ta akcja jest nieodwracalna. Czy chcesz kontynuowaÄ‡?",
  uJ = () => "Ð­Ñ‚Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð½ÐµÐ¾Ð±Ñ€Ð°Ñ‚Ð¸Ð¼Ð¾. ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ñ‚ÑŒ?",
  hJ = () => "Ð¦ÑŽ Ð´Ñ–ÑŽ Ð½ÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ ÑÐºÐ°ÑÑƒÐ²Ð°Ñ‚Ð¸. ÐŸÑ€Ð¾Ð´Ð¾Ð²Ð¶Ð¸Ñ‚Ð¸?",
  dJ = () => "HÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c, báº¡n cÃ³ muá»‘n tiáº¿p tá»¥c?",
  pJ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? tJ() : r === "pt" ? rJ() : r === "ch" ? nJ() : r === "de" ? iJ() : r === "es" ? aJ() : r === "fr" ? oJ() : r === "it" ? sJ() : r === "jp" ? lJ() : r === "pl" ? cJ() : r === "ru" ? uJ() : r === "uk" ? hJ() : dJ()
  },
  fJ = () => "this month",
  _J = () => "neste mÃªs",
  mJ = () => "æœ¬æœˆ",
  gJ = () => "diesen Monat",
  vJ = () => "este mes",
  yJ = () => "ce mois-ci",
  bJ = () => "questo mese",
  xJ = () => "ä»Šæœˆ",
  wJ = () => "w tym miesiÄ…cu",
  kJ = () => "Ð² ÑÑ‚Ð¾Ð¼ Ð¼ÐµÑÑÑ†Ðµ",
  TJ = () => "Ñ†ÑŒÐ¾Ð³Ð¾ Ð¼Ñ–ÑÑÑ†Ñ",
  SJ = () => "thÃ¡ng nÃ y",
  tm = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? fJ() : r === "pt" ? _J() : r === "ch" ? mJ() : r === "de" ? gJ() : r === "es" ? vJ() : r === "fr" ? yJ() : r === "it" ? bJ() : r === "jp" ? xJ() : r === "pl" ? wJ() : r === "ru" ? kJ() : r === "uk" ? TJ() : SJ()
  },
  PJ = () => "this week",
  MJ = () => "nesta semana",
  IJ = () => "æœ¬å‘¨",
  CJ = () => "diese Woche",
  zJ = () => "esta semana",
  AJ = () => "cette semaine",
  EJ = () => "questa settimana",
  LJ = () => "ä»Šé€±",
  DJ = () => "w tym tygodniu",
  RJ = () => "Ð½Ð° ÑÑ‚Ð¾Ð¹ Ð½ÐµÐ´ÐµÐ»Ðµ",
  jJ = () => "Ñ†ÑŒÐ¾Ð³Ð¾ Ñ‚Ð¸Ð¶Ð½Ñ",
  FJ = () => "tuáº§n nÃ y",
  rm = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? PJ() : r === "pt" ? MJ() : r === "ch" ? IJ() : r === "de" ? CJ() : r === "es" ? zJ() : r === "fr" ? AJ() : r === "it" ? EJ() : r === "jp" ? LJ() : r === "pl" ? DJ() : r === "ru" ? RJ() : r === "uk" ? jJ() : FJ()
  },
  BJ = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  OJ = () => "Isso excluirÃ¡ permanentemente sua conta e todos os dados associados. Esta aÃ§Ã£o nÃ£o pode ser desfeita.",
  qJ = () => "è¿™å°†æ°¸ä¹…åˆ é™¤ä½ çš„è´¦å·åŠæ‰€æœ‰ç›¸å…³æ•°æ®ï¼Œæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚",
  NJ = () => "Dies wird dein Konto und alle dazugehÃ¶rigen Daten dauerhaft lÃ¶schen. Diese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden.",
  VJ = () => "Esto eliminarÃ¡ permanentemente tu cuenta y todos los datos asociados. Esta acciÃ³n no se puede deshacer.",
  UJ = () => "Cela supprimera dÃ©finitivement votre compte et toutes les donnÃ©es associÃ©es. Cette action est irrÃ©versible.",
  ZJ = () => "Questa azione eliminerÃ  definitivamente il tuo account e tutti i dati associati. Non potrÃ  essere annullata.",
  GJ = () => "ã“ã®æ“ä½œã«ã‚ˆã‚Šã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¨é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒå®Œå…¨ã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚å…ƒã«æˆ»ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚",
  WJ = () => "To trwale usunie Twoje konto i wszystkie powiÄ…zane dane. Tej akcji nie moÅ¼na cofnÄ…Ä‡.",
  HJ = () => "Ð­Ñ‚Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð½Ð°Ð²ÑÐµÐ³Ð´Ð° ÑƒÐ´Ð°Ð»Ð¸Ñ‚ Ð²Ð°Ñˆ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð¸ Ð²ÑÐµ ÑÐ²ÑÐ·Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ. Ð•Ð³Ð¾ Ð½ÐµÐ»ÑŒÐ·Ñ Ð¾Ñ‚Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ.",
  $J = () => "Ð¦Ðµ Ð½Ð°Ð·Ð°Ð²Ð¶Ð´Ð¸ Ð²Ð¸Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²Ð°Ñˆ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ñ– Ð²ÑÑ– Ð¿Ð¾Ð²Ê¼ÑÐ·Ð°Ð½Ñ– Ð´Ð°Ð½Ñ–. Ð¦ÑŽ Ð´Ñ–ÑŽ Ð½Ðµ Ð¼Ð¾Ð¶Ð½Ð° Ð±ÑƒÐ´Ðµ ÑÐºÐ°ÑÑƒÐ²Ð°Ñ‚Ð¸.",
  XJ = () => "Viá»‡c nÃ y sáº½ xÃ³a vÄ©nh viá»…n tÃ i khoáº£n vÃ  táº¥t cáº£ dá»¯ liá»‡u liÃªn quan. HÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c.",
  YJ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? BJ() : r === "pt" ? OJ() : r === "ch" ? qJ() : r === "de" ? NJ() : r === "es" ? VJ() : r === "fr" ? UJ() : r === "it" ? ZJ() : r === "jp" ? GJ() : r === "pl" ? WJ() : r === "ru" ? HJ() : r === "uk" ? $J() : XJ()
  },
  KJ = () => "Tickets",
  JJ = () => "Tickets",
  QJ = () => "å·¥å•",
  eQ = () => "Tickets",
  tQ = () => "Tickets",
  rQ = () => "Tickets",
  nQ = () => "Ticket",
  iQ = () => "ãƒã‚±ãƒƒãƒˆ",
  aQ = () => "Tickety",
  oQ = () => "Ð¢Ð¸ÐºÐµÑ‚Ñ‹",
  sQ = () => "Ð¢Ñ–ÐºÐµÑ‚Ð¸",
  lQ = () => "Phiáº¿u há»— trá»£",
  cQ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? KJ() : r === "pt" ? JJ() : r === "ch" ? QJ() : r === "de" ? eQ() : r === "es" ? tQ() : r === "fr" ? rQ() : r === "it" ? nQ() : r === "jp" ? iQ() : r === "pl" ? aQ() : r === "ru" ? oQ() : r === "uk" ? sQ() : lQ()
  },
  uQ = () => "Timeout appeal",
  hQ = () => "RevisÃ£o de suspensÃ£o",
  dQ = () => "ç¦è¨€ç”³è¯‰",
  pQ = () => "Timeout-Einspruch",
  fQ = () => "ApelaciÃ³n de suspensiÃ³n",
  _Q = () => "Recours de suspension",
  mQ = () => "Ricorso contro la sospensione",
  gQ = () => "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ç•°è­°ç”³ç«‹ã¦",
  vQ = () => "OdwoÅ‚anie od zawieszenia",
  yQ = () => "ÐÐ¿ÐµÐ»Ð»ÑÑ†Ð¸Ñ Ð½Ð° Ñ‚Ð°Ð¹Ð¼-Ð°ÑƒÑ‚",
  bQ = () => "ÐÐ¿ÐµÐ»ÑÑ†Ñ–Ñ Ð½Ð° Ñ‚Ð°Ð¹Ð¼-Ð°ÑƒÑ‚",
  xQ = () => "KhÃ¡ng cÃ¡o táº¡m khÃ³a",
  wQ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? uQ() : r === "pt" ? hQ() : r === "ch" ? dQ() : r === "de" ? pQ() : r === "es" ? fQ() : r === "fr" ? _Q() : r === "it" ? mQ() : r === "jp" ? gQ() : r === "pl" ? vQ() : r === "ru" ? yQ() : r === "uk" ? bQ() : xQ()
  },
  kQ = () => "Appeal",
  TQ = () => "Apelar",
  SQ = () => "ç”³è¯‰",
  PQ = () => "Einspruch",
  MQ = () => "Apelar",
  IQ = () => "Recours",
  CQ = () => "Fare ricorso",
  zQ = () => "ç•°è­°ç”³ç«‹ã¦",
  AQ = () => "OdwoÅ‚aj siÄ™",
  EQ = () => "ÐÐ¿ÐµÐ»Ð»ÑÑ†Ð¸Ñ",
  LQ = () => "ÐŸÐ¾Ð´Ð°Ñ‚Ð¸ Ð°Ð¿ÐµÐ»ÑÑ†Ñ–ÑŽ",
  DQ = () => "KhÃ¡ng cÃ¡o",
  RQ = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? kQ() : r === "pt" ? TQ() : r === "ch" ? SQ() : r === "de" ? PQ() : r === "es" ? MQ() : r === "fr" ? IQ() : r === "it" ? CQ() : r === "jp" ? zQ() : r === "pl" ? AQ() : r === "ru" ? EQ() : r === "uk" ? LQ() : DQ()
  },
  jQ = () => "to paint.",
  FQ = () => "para pintar",
  BQ = () => "è¿›è¡Œç»˜åˆ¶ï¼Œ",
  OQ = () => "gedrÃ¼ckt halten, um zu malen",
  qQ = () => "para pintar.",
  NQ = () => "pour peindre.",
  VQ = () => "per dipingere",
  UQ = () => "å¡—ã‚‹ã«ã¯",
  ZQ = () => "aby malowaÄ‡.",
  GQ = () => "Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ñ€Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ.",
  WQ = () => "Ñ‰Ð¾Ð± Ð¼Ð°Ð»ÑŽÐ²Ð°Ñ‚Ð¸.",
  HQ = () => "Ä‘á»ƒ tÃ´.",
  $Q = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? jQ() : r === "pt" ? FQ() : r === "ch" ? BQ() : r === "de" ? OQ() : r === "es" ? qQ() : r === "fr" ? NQ() : r === "it" ? VQ() : r === "jp" ? UQ() : r === "pl" ? ZQ() : r === "ru" ? GQ() : r === "uk" ? WQ() : HQ()
  },
  XQ = () => "You can paint more than 1 pixel",
  YQ = () => "VocÃª pode pintar mais de 1 pixel",
  KQ = () => "ä½ å¯ä»¥ä¸€æ¬¡ç»˜åˆ¶å¤šä¸ªåƒç´ ",
  JQ = () => "Du kannst mehr als 1 Pixel malen",
  QQ = () => "Puedes pintar mÃ¡s de 1 pÃ­xel",
  eee = () => "Vous pouvez peindre plus dâ€™un pixel",
  tee = () => "Puoi dipingere piÃ¹ di 1 pixel",
  ree = () => "1ã¤ä»¥ä¸Šã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã¾ã¨ã‚ã¦å¡—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚",
  nee = () => "MoÅ¼esz pomalowaÄ‡ wiÄ™cej niÅ¼ 1 piksel",
  iee = () => "Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ñ€Ð¸ÑÐ¾Ð²Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÐµÐµ Ñ‡ÐµÐ¼ 1 Ð¿Ð¸ÐºÑÐµÐ»ÑŒ",
  aee = () => "Ð’Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¼Ð°Ð»ÑŽÐ²Ð°Ñ‚Ð¸ Ð±Ñ–Ð»ÑŒÑˆÐµ, Ð½Ñ–Ð¶ 1 Ð¿Ñ–ÐºÑÐµÐ»ÑŒ",
  oee = () => "Báº¡n cÃ³ thá»ƒ tÃ´ nhiá»u hÆ¡n 1 pixel",
  see = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? XQ() : r === "pt" ? YQ() : r === "ch" ? KQ() : r === "de" ? JQ() : r === "es" ? QQ() : r === "fr" ? eee() : r === "it" ? tee() : r === "jp" ? ree() : r === "pl" ? nee() : r === "ru" ? iee() : r === "uk" ? aee() : oee()
  },
  lee = () => "Today",
  cee = () => "Hoje",
  uee = () => "ä»Šå¤©",
  hee = () => "Heute",
  dee = () => "Hoy",
  pee = () => "Aujourdâ€™hui",
  fee = () => "Oggi",
  _ee = () => "ä»Šæ—¥",
  mee = () => "DziÅ›",
  gee = () => "Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ",
  vee = () => "Ð¡ÑŒÐ¾Ð³Ð¾Ð´Ð½Ñ–",
  yee = () => "HÃ´m nay",
  Dp = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? lee() : r === "pt" ? cee() : r === "ch" ? uee() : r === "de" ? hee() : r === "es" ? dee() : r === "fr" ? pee() : r === "it" ? fee() : r === "jp" ? _ee() : r === "pl" ? mee() : r === "ru" ? gee() : r === "uk" ? vee() : yee()
  },
  bee = () => "Toggle art opacity",
  xee = () => "Alterar opacidade",
  wee = () => "åˆ‡æ¢ä½œå“ä¸é€æ˜Žåº¦",
  kee = () => "Art-Transparenz umschalten",
  Tee = () => "Alternar opacidad del arte",
  See = () => "Basculer lâ€™opacitÃ© de lâ€™art",
  Pee = () => "Modifica opacitÃ ",
  Mee = () => "ã‚¢ãƒ¼ãƒˆã®ä¸é€æ˜Žåº¦ã‚’åˆ‡ã‚Šæ›¿ãˆ",
  Iee = () => "PrzeÅ‚Ä…cz przezroczystoÅ›Ä‡ grafik",
  Cee = () => "ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð½ÐµÐ¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ð¾ÑÑ‚ÑŒ Ð°Ñ€Ñ‚Ð°",
  zee = () => "ÐŸÐµÑ€ÐµÐ¼ÐºÐ½ÑƒÑ‚Ð¸ Ð¿Ñ€Ð¾Ð·Ð¾Ñ€Ñ–ÑÑ‚ÑŒ Ð°Ñ€Ñ‚Ñƒ",
  Aee = () => "Chuyá»ƒn Ä‘á»™ trong suá»‘t cá»§a art",
  C0 = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? bee() : r === "pt" ? xee() : r === "ch" ? wee() : r === "de" ? kee() : r === "es" ? Tee() : r === "fr" ? See() : r === "it" ? Pee() : r === "jp" ? Mee() : r === "pl" ? Iee() : r === "ru" ? Cee() : r === "uk" ? zee() : Aee()
  },
  Eee = () => "Twitch account migrated successfully.",
  Lee = () => "Conta da Twitch migrada com sucesso.",
  Dee = () => "Twitch è´¦å·è¿ç§»æˆåŠŸã€‚",
  Ree = () => "Twitch-Konto erfolgreich migriert.",
  jee = () => "Cuenta de Twitch migrada correctamente.",
  Fee = () => "Compte Twitch migrÃ© avec succÃ¨s.",
  Bee = () => "Account Twitch migrato con successo.",
  Oee = () => "Twitchã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ç§»è¡ŒãŒå®Œäº†ã—ã¾ã—ãŸã€‚",
  qee = () => "Konto Twitch zostaÅ‚o pomyÅ›lnie przeniesione.",
  Nee = () => "ÐÐºÐºÐ°ÑƒÐ½Ñ‚ Twitch ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¼Ð¸Ð³Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½.",
  Vee = () => "ÐÐºÐ°ÑƒÐ½Ñ‚ Twitch ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾ Ð¿ÐµÑ€ÐµÐ½ÐµÑÐµÐ½Ð¾.",
  Uee = () => "ÄÃ£ di chuyá»ƒn tÃ i khoáº£n Twitch thÃ nh cÃ´ng.",
  Zee = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Eee() : r === "pt" ? Lee() : r === "ch" ? Dee() : r === "de" ? Ree() : r === "es" ? jee() : r === "fr" ? Fee() : r === "it" ? Bee() : r === "jp" ? Oee() : r === "pl" ? qee() : r === "ru" ? Nee() : r === "uk" ? Vee() : Uee()
  },
  Gee = () => "Please confirm by entering your username:",
  Wee = () => "Por favor, confirme digitando seu nome de usuÃ¡rio:",
  Hee = () => "è¯·é€šè¿‡è¾“å…¥ç”¨æˆ·åè¿›è¡Œç¡®è®¤ï¼š",
  $ee = () => "Bitte bestÃ¤tige, indem du deinen Benutzernamen eingibst:",
  Xee = () => "Confirma escribiendo tu nombre de usuario:",
  Yee = () => "Veuillez confirmer en entrant votre nom dâ€™utilisateur :",
  Kee = () => "Conferma digitando il tuo nome utente:",
  Jee = () => "ç¢ºèªã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:",
  Qee = () => "PotwierdÅº, wpisujÄ…c swojÄ… nazwÄ™ uÅ¼ytkownika:",
  ete = () => "Ð”Ð»Ñ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÐµ Ð¸Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ:",
  tte = () => "ÐŸÑ–Ð´Ñ‚Ð²ÐµÑ€Ð´Ñ–Ñ‚ÑŒ, Ð±ÑƒÐ´ÑŒ Ð»Ð°ÑÐºÐ°, Ð²Ð²Ñ–Ð²ÑˆÐ¸ Ð²Ð°ÑˆÐµ Ñ–Ð¼Ê¼Ñ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ð°:",
  rte = () => "HÃ£y xÃ¡c nháº­n báº±ng cÃ¡ch nháº­p tÃªn ngÆ°á»i dÃ¹ng cá»§a báº¡n:",
  nte = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Gee() : r === "pt" ? Wee() : r === "ch" ? Hee() : r === "de" ? $ee() : r === "es" ? Xee() : r === "fr" ? Yee() : r === "it" ? Kee() : r === "jp" ? Jee() : r === "pl" ? Qee() : r === "ru" ? ete() : r === "uk" ? tte() : rte()
  },
  ite = () => "Type your username",
  ate = () => "Digite seu nome de usuÃ¡rio",
  ote = () => "è¾“å…¥ä½ çš„ç”¨æˆ·å",
  ste = () => "Benutzernamen eingeben",
  lte = () => "Escribe tu nombre de usuario",
  cte = () => "Tapez votre nom dâ€™utilisateur",
  ute = () => "Digita il tuo nome utente",
  hte = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›",
  dte = () => "Wpisz swojÄ… nazwÄ™ uÅ¼ytkownika",
  pte = () => "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ",
  fte = () => "Ð’Ð²ÐµÐ´Ñ–Ñ‚ÑŒ ÑÐ²Ð¾Ñ” Ñ–Ð¼Ê¼Ñ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ð°",
  _te = () => "Nháº­p tÃªn ngÆ°á»i dÃ¹ng",
  mte = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ite() : r === "pt" ? ate() : r === "ch" ? ote() : r === "de" ? ste() : r === "es" ? lte() : r === "fr" ? cte() : r === "it" ? ute() : r === "jp" ? hte() : r === "pl" ? dte() : r === "ru" ? pte() : r === "uk" ? fte() : _te()
  },
  gte = () => "Understood",
  vte = () => "Entendido",
  yte = () => "æˆ‘å·²äº†è§£",
  bte = () => "Verstanden",
  xte = () => "Entendido",
  wte = () => "Compris",
  kte = () => "Capito",
  Tte = () => "ç†è§£ã—ã¾ã—ãŸ",
  Ste = () => "ZrozumiaÅ‚em",
  Pte = () => "ÐŸÐ¾Ð½ÑÑ‚Ð½Ð¾",
  Mte = () => "Ð—Ñ€Ð¾Ð·ÑƒÐ¼Ñ–Ð»Ð¾",
  Ite = () => "ÄÃ£ hiá»ƒu",
  Cte = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? gte() : r === "pt" ? vte() : r === "ch" ? yte() : r === "de" ? bte() : r === "es" ? xte() : r === "fr" ? wte() : r === "it" ? kte() : r === "jp" ? Tte() : r === "pl" ? Ste() : r === "ru" ? Pte() : r === "uk" ? Mte() : Ite()
  },
  zte = () => "Undo",
  Ate = () => "Desfazer",
  Ete = () => "æ’¤æ¶ˆ",
  Lte = () => "RÃ¼ckgÃ¤ngig machen",
  Dte = () => "Deshacer",
  Rte = () => "Annuler",
  jte = () => "Annulla",
  Fte = () => "å…ƒã«æˆ»ã™",
  Bte = () => "Cofnij",
  Ote = () => "ÐžÑ‚Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ",
  qte = () => "Ð¡ÐºÐ°ÑÑƒÐ²Ð°Ñ‚Ð¸",
  Nte = () => "HoÃ n tÃ¡c",
  Vte = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? zte() : r === "pt" ? Ate() : r === "ch" ? Ete() : r === "de" ? Lte() : r === "es" ? Dte() : r === "fr" ? Rte() : r === "it" ? jte() : r === "jp" ? Fte() : r === "pl" ? Bte() : r === "ru" ? Ote() : r === "uk" ? qte() : Nte()
  },
  Ute = p => `Unlink Discord (${p.username})`,
  Zte = p => `Desconectar Discord (${p.username})`,
  Gte = p => `å–æ¶ˆå…³è” Discordï¼ˆ${p.username}ï¼‰`,
  Wte = p => `Discord trennen (${p.username})`,
  Hte = p => `Desvincular Discord (${p.username})`,
  $te = p => `Dissocier Discord (${p.username})`,
  Xte = p => `Scollega Discord (${p.username})`,
  Yte = p => `Discordã¨ã®é€£æºã‚’è§£é™¤ (${p.username})`,
  Kte = p => `OdÅ‚Ä…cz Discord (${p.username})`,
  Jte = p => `ÐžÑ‚Ð²ÑÐ·Ð°Ñ‚ÑŒ Discord (${p.username})`,
  Qte = p => `Ð’Ñ–Ð´Ê¼Ñ”Ð´Ð½Ð°Ñ‚Ð¸ Discord (${p.username})`,
  ere = p => `Há»§y liÃªn káº¿t Discord (${p.username})`,
  tre = (p, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Ute(p) : r === "pt" ? Zte(p) : r === "ch" ? Gte(p) : r === "de" ? Wte(p) : r === "es" ? Hte(p) : r === "fr" ? $te(p) : r === "it" ? Xte(p) : r === "jp" ? Yte(p) : r === "pl" ? Kte(p) : r === "ru" ? Jte(p) : r === "uk" ? Qte(p) : ere(p)
  },
  rre = () => "Discord unlinked",
  nre = () => "Discord desconectado",
  ire = () => "Discord å·²å–æ¶ˆå…³è”",
  are = () => "Discord-Konto getrennt",
  ore = () => "Discord desvinculado",
  sre = () => "Discord dissociÃ©",
  lre = () => "Discord scollegato",
  cre = () => "Discordã¨ã®é€£æºã‚’è§£é™¤ã—ã¾ã—ãŸã€‚",
  ure = () => "Discord odÅ‚Ä…czony",
  hre = () => "Discord Ð¾Ñ‚Ð²ÑÐ·Ð°Ð½",
  dre = () => "Discord Ð²Ñ–Ð´Ê¼Ñ”Ð´Ð½Ð°Ð½Ð¾",
  pre = () => "ÄÃ£ há»§y liÃªn káº¿t Discord",
  fre = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? rre() : r === "pt" ? nre() : r === "ch" ? ire() : r === "de" ? are() : r === "es" ? ore() : r === "fr" ? sre() : r === "it" ? lre() : r === "jp" ? cre() : r === "pl" ? ure() : r === "ru" ? hre() : r === "uk" ? dre() : pre()
  },
  _re = () => "Unmute",
  mre = () => "Desmutar",
  gre = () => "å–æ¶ˆé™éŸ³",
  vre = () => "Stummschaltung aufheben",
  yre = () => "Quitar silencio",
  bre = () => "RÃ©activer le son",
  xre = () => "Riattiva audio",
  wre = () => "ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤",
  kre = () => "WyÅ‚Ä…cz wyciszenie",
  Tre = () => "Ð¡Ð½ÑÑ‚ÑŒ Ð¼ÑŒÑŽÑ‚",
  Sre = () => "Ð£Ð²Ñ–Ð¼ÐºÐ½ÑƒÑ‚Ð¸ Ð·Ð²ÑƒÐº",
  Pre = () => "Báº­t tiáº¿ng",
  Mre = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? _re() : r === "pt" ? mre() : r === "ch" ? gre() : r === "de" ? vre() : r === "es" ? yre() : r === "fr" ? bre() : r === "it" ? xre() : r === "jp" ? wre() : r === "pl" ? kre() : r === "ru" ? Tre() : r === "uk" ? Sre() : Pre()
  },
  Ire = () => "Update",
  Cre = () => "Atualizar",
  zre = () => "æ›´æ–°",
  Are = () => "Aktualisieren",
  Ere = () => "Actualizar",
  Lre = () => "Mettre Ã  jour",
  Dre = () => "Aggiorna",
  Rre = () => "æ›´æ–°",
  jre = () => "Aktualizuj",
  Fre = () => "ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ",
  Bre = () => "ÐžÐ½Ð¾Ð²Ð¸Ñ‚Ð¸",
  Ore = () => "Cáº­p nháº­t",
  qre = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Ire() : r === "pt" ? Cre() : r === "ch" ? zre() : r === "de" ? Are() : r === "es" ? Ere() : r === "fr" ? Lre() : r === "it" ? Dre() : r === "jp" ? Rre() : r === "pl" ? jre() : r === "ru" ? Fre() : r === "uk" ? Bre() : Ore()
  },
  Nre = () => "Use hardware acceleration when available",
  Vre = () => "Usar aceleraÃ§Ã£o grÃ¡fica quando disponÃ­vel",
  Ure = () => "åœ¨å¯ç”¨æ—¶ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿ",
  Zre = () => "Hardwarebeschleunigung verwenden, wenn verfÃ¼gbar",
  Gre = () => "Usar aceleraciÃ³n por hardware cuando estÃ© disponible",
  Wre = () => "Utiliser lâ€™accÃ©lÃ©ration matÃ©rielle lorsquâ€™elle est disponible",
  Hre = () => "Usa l'accelerazione grafica quando disponibile",
  $re = () => "åˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹",
  Xre = () => "UÅ¼ywaj akceleracji sprzÄ™towej, gdy jest dostÄ™pna",
  Yre = () => "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð°Ð¿Ð¿Ð°Ñ€Ð°Ñ‚Ð½Ð¾Ðµ ÑƒÑÐºÐ¾Ñ€ÐµÐ½Ð¸Ðµ, ÐµÑÐ»Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾",
  Kre = () => "Ð’Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÐ²Ð°Ñ‚Ð¸ Ð°Ð¿Ð°Ñ€Ð°Ñ‚Ð½Ðµ Ð¿Ñ€Ð¸ÑÐºÐ¾Ñ€ÐµÐ½Ð½Ñ, ÑÐºÑ‰Ð¾ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾",
  Jre = () => "DÃ¹ng tÄƒng tá»‘c pháº§n cá»©ng khi cÃ³ thá»ƒ",
  Qre = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Nre() : r === "pt" ? Vre() : r === "ch" ? Ure() : r === "de" ? Zre() : r === "es" ? Gre() : r === "fr" ? Wre() : r === "it" ? Hre() : r === "jp" ? $re() : r === "pl" ? Xre() : r === "ru" ? Yre() : r === "uk" ? Kre() : Jre()
  },
  ene = () => "Username copied to clipboard",
  tne = () => "UsuÃ¡rio copiado",
  rne = () => "ç”¨æˆ·åå·²å¤åˆ¶åˆ°å‰ªè´´æ¿",
  nne = () => "Benutzername in die Zwischenablage kopiert",
  ine = () => "Nombre de usuario copiado al portapapeles",
  ane = () => "Nom dâ€™utilisateur copiÃ©",
  one = () => "Nome utente copiato",
  sne = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  lne = () => "Nazwa uÅ¼ytkownika skopiowana do schowka",
  cne = () => "Ð˜Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°",
  une = () => "Ð†Ð¼Ê¼Ñ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ð° ÑÐºÐ¾Ð¿Ñ–Ð¹Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼Ñ–Ð½Ñƒ",
  hne = () => "ÄÃ£ sao chÃ©p tÃªn ngÆ°á»i dÃ¹ng vÃ o clipboard",
  dne = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ene() : r === "pt" ? tne() : r === "ch" ? rne() : r === "de" ? nne() : r === "es" ? ine() : r === "fr" ? ane() : r === "it" ? one() : r === "jp" ? sne() : r === "pl" ? lne() : r === "ru" ? cne() : r === "uk" ? une() : hne()
  },
  pne = () => "Verify if",
  fne = () => "Verifique se",
  _ne = () => "è¯·æ£€æŸ¥æ˜¯å¦",
  mne = () => "ÃœberprÃ¼fe, ob",
  gne = () => "Verifica si",
  vne = () => "VÃ©rifiez si",
  yne = () => "Verifica se",
  bne = () => "æ¬¡ã‚’ç¢ºèª:",
  xne = () => "SprawdÅº, czy",
  wne = () => "Ð£Ð´Ð¾ÑÑ‚Ð¾Ð²ÐµÑ€ÑŒÑ‚ÐµÑÑŒ Ð² Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾",
  kne = () => "ÐŸÐµÑ€ÐµÐºÐ¾Ð½Ð°Ð¹Ñ‚ÐµÑÑ, Ñ‰Ð¾",
  Tne = () => "Kiá»ƒm tra xem",
  Sne = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? pne() : r === "pt" ? fne() : r === "ch" ? _ne() : r === "de" ? mne() : r === "es" ? gne() : r === "fr" ? vne() : r === "it" ? yne() : r === "jp" ? bne() : r === "pl" ? xne() : r === "ru" ? wne() : r === "uk" ? kne() : Tne()
  },
  Pne = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  Mne = () => "A violaÃ§Ã£o destas regras pode levar Ã  suspensÃ£o da conta ou Ã  remoÃ§Ã£o de desenhos.",
  Ine = () => "è¿åè¿™äº›è§„åˆ™å¯èƒ½å¯¼è‡´ä½ çš„è´¦å·è¢«æš‚åœæˆ–ä½œå“è¢«ç§»é™¤ã€‚",
  Cne = () => "VerstÃ¶ÃŸe gegen diese Regeln kÃ¶nnen zur Sperrung deines Kontos oder zur Entfernung von Zeichnungen fÃ¼hren.",
  zne = () => "Las violaciones de estas reglas pueden resultar en la suspensiÃ³n de tu cuenta o la eliminaciÃ³n de dibujos.",
  Ane = () => "La violation de ces rÃ¨gles peut entraÃ®ner la suspension de votre compte ou la suppression de dessins.",
  Ene = () => "La violazione di queste regole puÃ² portare alla sospensione dell'account o alla rimozione dei disegni.",
  Lne = () => "ã“ã‚Œã‚‰ã®ãƒ«ãƒ¼ãƒ«ã«é•åã—ãŸå ´åˆã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®åœæ­¢ã‚„ä½œå“ã®å‰Šé™¤ãªã©ã®æŽªç½®ãŒå–ã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚",
  Dne = () => "Åamanie tych zasad moÅ¼e skutkowaÄ‡ zawieszeniem konta lub usuniÄ™ciem rysunkÃ³w.",
  Rne = () => "ÐÐ°Ñ€ÑƒÑˆÐµÐ½Ð¸Ðµ ÑÑ‚Ð¸Ñ… Ð¿Ñ€Ð°Ð²Ð¸Ð» Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ñ€Ð¸Ð²ÐµÑÑ‚Ð¸ Ðº Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐµ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð° Ð¸Ð»Ð¸ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸ÑŽ Ñ€Ð¸ÑÑƒÐ½ÐºÐ¾Ð².",
  jne = () => "ÐŸÐ¾Ñ€ÑƒÑˆÐµÐ½Ð½Ñ Ñ†Ð¸Ñ… Ð¿Ñ€Ð°Ð²Ð¸Ð» Ð¼Ð¾Ð¶Ðµ Ð¿Ñ€Ð¸Ð·Ð²ÐµÑÑ‚Ð¸ Ð´Ð¾ Ð±Ð»Ð¾ÐºÑƒÐ²Ð°Ð½Ð½Ñ Ð°ÐºÐ°ÑƒÐ½Ñ‚Ð° Ð°Ð±Ð¾ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ð½Ñ Ð¼Ð°Ð»ÑŽÐ½ÐºÑ–Ð².",
  Fne = () => "Vi pháº¡m cÃ¡c luáº­t nÃ y cÃ³ thá»ƒ dáº«n Ä‘áº¿n viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n hoáº·c xÃ³a tranh.",
  Bne = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Pne() : r === "pt" ? Mne() : r === "ch" ? Ine() : r === "de" ? Cne() : r === "es" ? zne() : r === "fr" ? Ane() : r === "it" ? Ene() : r === "jp" ? Lne() : r === "pl" ? Dne() : r === "ru" ? Rne() : r === "uk" ? jne() : Fne()
  },
  One = () => "Week",
  qne = () => "Semana",
  Nne = () => "å‘¨",
  Vne = () => "Woche",
  Une = () => "Semana",
  Zne = () => "Semaine",
  Gne = () => "Settimana",
  Wne = () => "é€±",
  Hne = () => "TydzieÅ„",
  $ne = () => "ÐÐµÐ´ÐµÐ»Ñ",
  Xne = () => "Ð¢Ð¸Ð¶Ð´ÐµÐ½ÑŒ",
  Yne = () => "Tuáº§n",
  Kne = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? One() : r === "pt" ? qne() : r === "ch" ? Nne() : r === "de" ? Vne() : r === "es" ? Une() : r === "fr" ? Zne() : r === "it" ? Gne() : r === "jp" ? Wne() : r === "pl" ? Hne() : r === "ru" ? $ne() : r === "uk" ? Xne() : Yne()
  },
  Jne = () => "Welcome to",
  Qne = () => "Bem vindo ao",
  eie = () => "æ¬¢è¿Žæ¥åˆ°",
  tie = () => "Willkommen bei",
  rie = () => "Bienvenido a",
  nie = () => "Bienvenue sur",
  iie = () => "Benvenuto su",
  aie = () => "ã‚ˆã†ã“ã",
  oie = () => "Witamy w",
  sie = () => "Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ Ð²",
  lie = () => "Ð›Ð°ÑÐºÐ°Ð²Ð¾ Ð¿Ñ€Ð¾ÑÐ¸Ð¼Ð¾ Ð´Ð¾",
  cie = () => "ChÃ o má»«ng Ä‘áº¿n vá»›i",
  uie = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Jne() : r === "pt" ? Qne() : r === "ch" ? eie() : r === "de" ? tie() : r === "es" ? rie() : r === "fr" ? nie() : r === "it" ? iie() : r === "jp" ? aie() : r === "pl" ? oie() : r === "ru" ? sie() : r === "uk" ? lie() : cie()
  },
  hie = () => "When painting, click on the button",
  die = () => "Quando pintar clique no botÃ£o",
  pie = () => "åœ¨ç»˜åˆ¶æ—¶ï¼Œç‚¹å‡»æŒ‰é’®",
  fie = () => "Wenn du malst, klicke auf den Button",
  _ie = () => "Cuando estÃ©s pintando, haz clic en el botÃ³n",
  mie = () => "En peignant, cliquez sur le bouton",
  gie = () => "Quando dipingi, clicca sul pulsante",
  vie = () => "ãƒšã‚¤ãƒ³ãƒˆä¸­ã«ã€æ¬¡ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚",
  yie = () => "Podczas malowania kliknij przycisk",
  bie = () => "Ð’Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ",
  xie = () => "ÐŸÑ–Ð´ Ñ‡Ð°Ñ Ð¼Ð°Ð»ÑŽÐ²Ð°Ð½Ð½Ñ Ð½Ð°Ñ‚Ð¸ÑÐ½Ñ–Ñ‚ÑŒ ÐºÐ½Ð¾Ð¿ÐºÑƒ",
  wie = () => "Khi tÃ´, hÃ£y nháº¥p vÃ o nÃºt",
  kie = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? hie() : r === "pt" ? die() : r === "ch" ? pie() : r === "de" ? fie() : r === "es" ? _ie() : r === "fr" ? mie() : r === "it" ? gie() : r === "jp" ? vie() : r === "pl" ? yie() : r === "ru" ? bie() : r === "uk" ? xie() : wie()
  },
  Tie = () => "You don't have charges to paint. Wait to recharge.",
  Sie = () => "VocÃª nÃ£o possui tinta para pintar. Aguarde para carrega-las.",
  Pie = () => "ä½ æ²¡æœ‰å¯ç”¨å……èƒ½ï¼Œè«‹ç­‰å¾…å……èƒ½æ¢å¤ã€‚",
  Mie = () => "Du hast keine Ladungen zum Malen. Warte, bis sie sich aufladen.",
  Iie = () => "No tienes cargas para pintar. Espera a que se recarguen.",
  Cie = () => "Vous nâ€™avez pas de charges pour peindre. Attendez quâ€™elles se rechargent.",
  zie = () => "Non hai vernice per dipingere. Attendi la ricarica.",
  Aie = () => "ãƒšã‚¤ãƒ³ãƒˆç”¨ã®ãƒãƒ£ãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å›žå¾©ã™ã‚‹ã¾ã§ãŠå¾…ã¡ãã ã•ã„ã€‚",
  Eie = () => "Nie masz Å‚adunkÃ³w do malowania. Poczekaj na doÅ‚adowanie.",
  Lie = () => "Ð£ Ð²Ð°Ñ Ð½ÐµÑ‚ Ð·Ð°Ñ€ÑÐ´Ð¾Ð² Ð´Ð»Ñ Ñ€Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ. ÐŸÐ¾Ð´Ð¾Ð¶Ð´Ð¸Ñ‚Ðµ, Ð¿Ð¾ÐºÐ° Ð¾Ð½Ð¸ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²ÑÑ‚ÑÑ.",
  Die = () => "Ð£ Ð²Ð°Ñ Ð½ÐµÐ¼Ð°Ñ” Ð·Ð°Ñ€ÑÐ´Ñ–Ð² Ð´Ð»Ñ Ð¼Ð°Ð»ÑŽÐ²Ð°Ð½Ð½Ñ. Ð—Ð°Ñ‡ÐµÐºÐ°Ð¹Ñ‚Ðµ, Ð¿Ð¾ÐºÐ¸ Ð²Ð¾Ð½Ð¸ Ð²Ñ–Ð´Ð½Ð¾Ð²Ð»ÑÑ‚ÑŒÑÑ.",
  Rie = () => "Báº¡n khÃ´ng cÃ²n lÆ°á»£t tÃ´ Ä‘á»ƒ váº½. HÃ£y chá» náº¡p láº¡i.",
  jie = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Tie() : r === "pt" ? Sie() : r === "ch" ? Pie() : r === "de" ? Mie() : r === "es" ? Iie() : r === "fr" ? Cie() : r === "it" ? zie() : r === "jp" ? Aie() : r === "pl" ? Eie() : r === "ru" ? Lie() : r === "uk" ? Die() : Rie()
  },
  Fie = () => "You need to zoom in to select a pixel",
  Bie = () => "DÃª zoom para selecionar um pixel",
  Oie = () => "ä½ éœ€è¦æ”¾å¤§æ‰èƒ½é€‰æ‹©åƒç´ ",
  qie = () => "Du musst hineinzoomen, um einen Pixel zu wÃ¤hlen",
  Nie = () => "Acerca el zoom para seleccionar un pÃ­xel",
  Vie = () => "Zoomez pour sÃ©lectionner un pixel",
  Uie = () => "Devi fare zoom per selezionare un pixel",
  Zie = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’é¸æŠžã™ã‚‹ã«ã¯ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚",
  Gie = () => "Musisz przybliÅ¼yÄ‡, aby wybraÄ‡ piksel",
  Wie = () => "ÐŸÑ€Ð¸Ð±Ð»Ð¸Ð·ÑŒÑ‚Ðµ ÐºÐ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ",
  Hie = () => "Ð—Ð±Ñ–Ð»ÑŒÑˆÑ–Ñ‚ÑŒ Ð¼Ð°ÑÑˆÑ‚Ð°Ð±, Ñ‰Ð¾Ð± Ð²Ð¸Ð±Ñ€Ð°Ñ‚Ð¸ Ð¿Ñ–ÐºÑÐµÐ»ÑŒ",
  $ie = () => "Báº¡n cáº§n phÃ³ng to Ä‘á»ƒ chá»n pixel",
  Xie = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Fie() : r === "pt" ? Bie() : r === "ch" ? Oie() : r === "de" ? qie() : r === "es" ? Nie() : r === "fr" ? Vie() : r === "it" ? Uie() : r === "jp" ? Zie() : r === "pl" ? Gie() : r === "ru" ? Wie() : r === "uk" ? Hie() : $ie()
  },
  Yie = () => "Your account has been banned for violating the rules",
  Kie = () => "A sua conta foi banida por quebrar as regras",
  Jie = () => "ä½ çš„è´¦å·å› è¿åè§„åˆ™å·²è¢«å°ç¦",
  Qie = () => "Dein Konto wurde wegen RegelverstÃ¶ÃŸen gebannt",
  eae = () => "Tu cuenta ha sido baneada por infringir las reglas",
  tae = () => "Votre compte a Ã©tÃ© banni pour avoir enfreint les rÃ¨gles",
  rae = () => "Il tuo account Ã¨ stato bannato per aver infranto le regole",
  nae = () => "ãƒ«ãƒ¼ãƒ«é•åã«ã‚ˆã‚Šã€ã‚ãªãŸã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯BANã•ã‚Œã¾ã—ãŸã€‚",
  iae = () => "Twoje konto zostaÅ‚o zbanowane za Å‚amanie zasad",
  aae = () => "Ð’Ð°Ñˆ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð±Ñ‹Ð» Ð·Ð°Ð±Ð°Ð½ÐµÐ½ Ð·Ð° Ð½Ð°Ñ€ÑƒÑˆÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»",
  oae = () => "Ð’Ð°Ñˆ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ Ð·Ð° Ð¿Ð¾Ñ€ÑƒÑˆÐµÐ½Ð½Ñ Ð¿Ñ€Ð°Ð²Ð¸Ð»",
  sae = () => "TÃ i khoáº£n cá»§a báº¡n Ä‘Ã£ bá»‹ khÃ³a vÃ¬ vi pháº¡m luáº­t",
  lae = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Yie() : r === "pt" ? Kie() : r === "ch" ? Jie() : r === "de" ? Qie() : r === "es" ? eae() : r === "fr" ? tae() : r === "it" ? rae() : r === "jp" ? nae() : r === "pl" ? iae() : r === "ru" ? aae() : r === "uk" ? oae() : sae()
  },
  cae = () => "Zoom in",
  uae = () => "Aumentar zoom",
  hae = () => "æ”¾å¤§",
  dae = () => "Hineinzoomen",
  pae = () => "Acercar",
  fae = () => "Zoom avant",
  _ae = () => "Zoom avanti",
  mae = () => "ã‚ºãƒ¼ãƒ ã‚¤ãƒ³",
  gae = () => "PrzybliÅ¼",
  vae = () => "ÐŸÑ€Ð¸Ð±Ð»Ð¸Ð·Ð¸Ñ‚ÑŒ",
  yae = () => "Ð—Ð±Ñ–Ð»ÑŒÑˆÐ¸Ñ‚Ð¸",
  bae = () => "PhÃ³ng to",
  xae = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? cae() : r === "pt" ? uae() : r === "ch" ? hae() : r === "de" ? dae() : r === "es" ? pae() : r === "fr" ? fae() : r === "it" ? _ae() : r === "jp" ? mae() : r === "pl" ? gae() : r === "ru" ? vae() : r === "uk" ? yae() : bae()
  },
  wae = () => "Zoom in to see the pixels",
  kae = () => "Amplie para ver os pixels",
  Tae = () => "æ”¾å¤§ä»¥æŸ¥çœ‹åƒç´ ",
  Sae = () => "Hineinzoomen, um die Pixel zu sehen",
  Pae = () => "Acerca el zoom para ver los pÃ­xeles",
  Mae = () => "Zoomez pour voir les pixels",
  Iae = () => "Ingrandisci per vedere i pixel",
  Cae = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’è¦‹ã‚‹ã«ã¯ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚",
  zae = () => "PrzybliÅ¼, aby zobaczyÄ‡ piksele",
  Aae = () => "ÐŸÑ€Ð¸Ð±Ð»Ð¸Ð·ÑŒÑ‚Ðµ ÐºÐ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ²Ð¸Ð´ÐµÑ‚ÑŒ Ð¿Ð¸ÐºÑÐµÐ»Ð¸",
  Eae = () => "Ð—Ð±Ñ–Ð»ÑŒÑˆÑ–Ñ‚ÑŒ Ð¼Ð°ÑÑˆÑ‚Ð°Ð±, Ñ‰Ð¾Ð± Ð¿Ð¾Ð±Ð°Ñ‡Ð¸Ñ‚Ð¸ Ð¿Ñ–ÐºÑÐµÐ»Ñ–",
  Lae = () => "PhÃ³ng to Ä‘á»ƒ tháº¥y cÃ¡c pixel",
  Dae = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? wae() : r === "pt" ? kae() : r === "ch" ? Tae() : r === "de" ? Sae() : r === "es" ? Pae() : r === "fr" ? Mae() : r === "it" ? Iae() : r === "jp" ? Cae() : r === "pl" ? zae() : r === "ru" ? Aae() : r === "uk" ? Eae() : Lae()
  },
  Rae = () => "Zoom out",
  jae = () => "Diminuir zoom",
  Fae = () => "ç¼©å°",
  Bae = () => "Herauszoomen",
  Oae = () => "Alejar",
  qae = () => "Zoom arriÃ¨re",
  Nae = () => "Zoom indietro",
  Vae = () => "ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ",
  Uae = () => "Oddal",
  Zae = () => "ÐžÑ‚Ð´Ð°Ð»Ð¸Ñ‚ÑŒ",
  Gae = () => "Ð—Ð¼ÐµÐ½ÑˆÐ¸Ñ‚Ð¸",
  Wae = () => "Thu nhá»",
  Hae = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Rae() : r === "pt" ? jae() : r === "ch" ? Fae() : r === "de" ? Bae() : r === "es" ? Oae() : r === "fr" ? qae() : r === "it" ? Nae() : r === "jp" ? Vae() : r === "pl" ? Uae() : r === "ru" ? Zae() : r === "uk" ? Gae() : Wae()
  },
  $ae = () => "Save with map",
  Xae = () => "Salvar com mapa",
  Yae = () => "è¿žåŒåœ°å›¾ä¸€èµ·ä¿å­˜",
  Kae = () => "Mit Karte speichern",
  Jae = () => "Guardar con mapa",
  Qae = () => "Enregistrer avec la carte",
  eoe = () => "Salva con mappa",
  toe = () => "ãƒžãƒƒãƒ—ä»˜ãã§ä¿å­˜",
  roe = () => "Zapisz z mapÄ…",
  noe = () => "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ ÐºÐ°Ñ€Ñ‚Ð¾Ð¹",
  ioe = () => "Ð—Ð±ÐµÑ€ÐµÐ³Ñ‚Ð¸ Ð· ÐºÐ°Ñ€Ñ‚Ð¾ÑŽ",
  aoe = () => "LÆ°u kÃ¨m báº£n Ä‘á»“",
  ooe = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? $ae() : r === "pt" ? Xae() : r === "ch" ? Yae() : r === "de" ? Kae() : r === "es" ? Jae() : r === "fr" ? Qae() : r === "it" ? eoe() : r === "jp" ? toe() : r === "pl" ? roe() : r === "ru" ? noe() : r === "uk" ? ioe() : aoe()
  },
  soe = () => "Show less",
  loe = () => "Mostrar menos",
  coe = () => "æ”¶èµ·",
  uoe = () => "Weniger anzeigen",
  hoe = () => "Mostrar menos",
  doe = () => "Afficher moins",
  poe = () => "Mostra meno",
  foe = () => "å°‘ãªãè¡¨ç¤º",
  _oe = () => "PokaÅ¼ mniej",
  moe = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¼ÐµÐ½ÑŒÑˆÐµ",
  goe = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚Ð¸ Ð¼ÐµÐ½ÑˆÐµ",
  voe = () => "áº¨n bá»›t",
  yoe = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? soe() : r === "pt" ? loe() : r === "ch" ? coe() : r === "de" ? uoe() : r === "es" ? hoe() : r === "fr" ? doe() : r === "it" ? poe() : r === "jp" ? foe() : r === "pl" ? _oe() : r === "ru" ? moe() : r === "uk" ? goe() : voe()
  },
  boe = () => "Show more",
  xoe = () => "Mostrar mais",
  woe = () => "æ˜¾ç¤ºæ›´å¤š",
  koe = () => "Mehr anzeigen",
  Toe = () => "Mostrar mÃ¡s",
  Soe = () => "Afficher plus",
  Poe = () => "Mostra altro",
  Moe = () => "ã‚‚ã£ã¨è¦‹ã‚‹",
  Ioe = () => "PokaÅ¼ wiÄ™cej",
  Coe = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ",
  zoe = () => "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚Ð¸ Ð±Ñ–Ð»ÑŒÑˆÐµ",
  Aoe = () => "Hiá»ƒn thá»‹ thÃªm",
  Eoe = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? boe() : r === "pt" ? xoe() : r === "ch" ? woe() : r === "de" ? koe() : r === "es" ? Toe() : r === "fr" ? Soe() : r === "it" ? Poe() : r === "jp" ? Moe() : r === "pl" ? Ioe() : r === "ru" ? Coe() : r === "uk" ? zoe() : Aoe()
  },
  Loe = () => "Flags",
  Doe = () => "Bandeiras",
  Roe = () => "æ——å¸œ",
  joe = () => "Flaggen",
  Foe = () => "Banderas",
  Boe = () => "Drapeaux",
  Ooe = () => "Bandiere",
  qoe = () => "æ——",
  Noe = () => "Flagi",
  Voe = () => "Ð¤Ð»Ð°Ð³Ð¸",
  Uoe = () => "ÐŸÑ€Ð°Ð¿Ð¾Ñ€Ð¸",
  Zoe = () => "Cá»",
  Goe = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Loe() : r === "pt" ? Doe() : r === "ch" ? Roe() : r === "de" ? joe() : r === "es" ? Foe() : r === "fr" ? Boe() : r === "it" ? Ooe() : r === "jp" ? qoe() : r === "pl" ? Noe() : r === "ru" ? Voe() : r === "uk" ? Uoe() : Zoe()
  },
  Woe = () => "Free",
  Hoe = () => "GrÃ¡tis",
  $oe = () => "å…è´¹",
  Xoe = () => "Kostenlos",
  Yoe = () => "Gratis",
  Koe = () => "Gratuit",
  Joe = () => "Gratuito",
  Qoe = () => "ç„¡æ–™",
  ese = () => "Darmowy",
  tse = () => "Ð‘ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ð¾",
  rse = () => "Ð‘ÐµÐ·ÐºÐ¾ÑˆÑ‚Ð¾Ð²Ð½Ð¾",
  nse = () => "Miá»…n phÃ­",
  ise = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Woe() : r === "pt" ? Hoe() : r === "ch" ? $oe() : r === "de" ? Xoe() : r === "es" ? Yoe() : r === "fr" ? Koe() : r === "it" ? Joe() : r === "jp" ? Qoe() : r === "pl" ? ese() : r === "ru" ? tse() : r === "uk" ? rse() : nse()
  },
  ase = () => "Change frame",
  ose = () => "Alterar moldura",
  sse = () => "æ›´æ”¹æ¡†æž¶",
  lse = () => "Rahmen Ã¤ndern",
  cse = () => "Cambiar marco",
  use = () => "Changer de cadre",
  hse = () => "Cambia cornice",
  dse = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å¤‰æ›´",
  pse = () => "ZmieÅ„ ramkÄ™",
  fse = () => "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ ÐºÐ°Ð´Ñ€",
  _se = () => "Ð—Ð¼Ñ–Ð½Ð¸Ñ‚Ð¸ ÐºÐ°Ð´Ñ€",
  mse = () => "Äá»•i khung",
  gse = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ase() : r === "pt" ? ose() : r === "ch" ? sse() : r === "de" ? lse() : r === "es" ? cse() : r === "fr" ? use() : r === "it" ? hse() : r === "jp" ? dse() : r === "pl" ? pse() : r === "ru" ? fse() : r === "uk" ? _se() : mse()
  },
  vse = () => "Frame equipped!",
  yse = () => "Moldura equipada!",
  bse = () => "æ¡†æž¶å·²è£…å¤‡ï¼",
  xse = () => "Rahmen ausgerÃ¼stet!",
  wse = () => "Â¡Marco equipado!",
  kse = () => "Cadre Ã©quipÃ© !",
  Tse = () => "Telaio equipaggiato!",
  Sse = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è£…å‚™ã—ã¾ã—ãŸï¼",
  Pse = () => "Rama wyposaÅ¼ona!",
  Mse = () => "Ð Ð°Ð¼Ð° ÑÐ½Ð°Ñ€ÑÐ¶ÐµÐ½Ð°!",
  Ise = () => "Ð Ð°Ð¼Ñƒ Ð¾ÑÐ½Ð°Ñ‰ÐµÐ½Ð¾!",
  Cse = () => "ÄÃ£ trang bá»‹ khung!",
  zse = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? vse() : r === "pt" ? yse() : r === "ch" ? bse() : r === "de" ? xse() : r === "es" ? wse() : r === "fr" ? kse() : r === "it" ? Tse() : r === "jp" ? Sse() : r === "pl" ? Pse() : r === "ru" ? Mse() : r === "uk" ? Ise() : Cse()
  },
  Ase = () => "Error equipping frame. Try again later.",
  Ese = () => "Erro ao equipar moldura. Tente novamente mais tarde.",
  Lse = () => "è£…å¤‡è¾¹æ¡†å¤±è´¥ã€‚è¯·ç¨åŽå†è¯•ã€‚",
  Dse = () => "Fehler beim AusrÃ¼sten des Rahmens. Versuchen Sie es spÃ¤ter erneut.",
  Rse = () => "Error al equipar el marco. IntÃ©ntalo de nuevo mÃ¡s tarde.",
  jse = () => "Erreur lors de l'Ã©quipement du cadre. Veuillez rÃ©essayer plus tard.",
  Fse = () => "Errore durante l'equipaggiamento della cornice. Riprova piÃ¹ tardi.",
  Bse = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã®è£…å‚™ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚å¾Œã§ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚",
  Ose = () => "BÅ‚Ä…d podczas wyposaÅ¼ania ramki. SprÃ³buj ponownie pÃ³Åºniej.",
  qse = () => "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐµ Ñ€Ð°Ð¼ÐºÐ¸. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.",
  Nse = () => "ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° Ð¿Ñ–Ð´ Ñ‡Ð°Ñ ÐµÐºÑ–Ð¿Ñ–Ñ€ÑƒÐ²Ð°Ð½Ð½Ñ Ñ€Ð°Ð¼ÐºÐ¸. Ð¡Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ñ–Ð·Ð½Ñ–ÑˆÐµ.",
  Vse = () => "Lá»—i khi trang bá»‹ khung. Vui lÃ²ng thá»­ láº¡i sau.",
  Use = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Ase() : r === "pt" ? Ese() : r === "ch" ? Lse() : r === "de" ? Dse() : r === "es" ? Rse() : r === "fr" ? jse() : r === "it" ? Fse() : r === "jp" ? Bse() : r === "pl" ? Ose() : r === "ru" ? qse() : r === "uk" ? Nse() : Vse()
  },
  Zse = () => "Frame Inventory",
  Gse = () => "InventÃ¡rio de Molduras",
  Wse = () => "æ¡†æž¶åº“å­˜",
  Hse = () => "Rahmenbestand",
  $se = () => "Inventario de marcos",
  Xse = () => "Inventaire de cadres",
  Yse = () => "Inventario telai",
  Kse = () => "ãƒ•ãƒ¬ãƒ¼ãƒ åœ¨åº«",
  Jse = () => "Inwentarz ram",
  Qse = () => "Ð˜Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ Ñ€Ð°Ð¼Ð¾Ðº",
  ele = () => "Ð†Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ Ñ€Ð°Ð¼",
  tle = () => "Tá»“n kho khung",
  rle = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Zse() : r === "pt" ? Gse() : r === "ch" ? Wse() : r === "de" ? Hse() : r === "es" ? $se() : r === "fr" ? Xse() : r === "it" ? Yse() : r === "jp" ? Kse() : r === "pl" ? Jse() : r === "ru" ? Qse() : r === "uk" ? ele() : tle()
  },
  nle = () => "Choose a frame for your profile picture",
  ile = () => "Escolha uma moldura para sua foto de perfil",
  ale = () => "é€‰æ‹©ä¸€ä¸ªè¾¹æ¡†ä½œä¸ºæ‚¨çš„ä¸ªäººèµ„æ–™å›¾ç‰‡",
  ole = () => "WÃ¤hle einen Rahmen fÃ¼r dein Profilbild",
  sle = () => "Elige un marco para tu foto de perfil",
  lle = () => "Choisissez un cadre pour votre photo de profil",
  cle = () => "Scegli una cornice per la tua immagine del profilo",
  ule = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å†™çœŸã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠž",
  hle = () => "Wybierz ramkÄ™ do swojego zdjÄ™cia profilowego",
  dle = () => "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ€Ð°Ð¼ÐºÑƒ Ð´Ð»Ñ ÑÐ²Ð¾ÐµÐ¹ Ñ„Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ð¸Ð¸ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ñ",
  ple = () => "ÐžÐ±ÐµÑ€Ñ–Ñ‚ÑŒ Ñ€Ð°Ð¼ÐºÑƒ Ð´Ð»Ñ ÑÐ²Ð¾Ð³Ð¾ Ñ„Ð¾Ñ‚Ð¾ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»ÑŽ",
  fle = () => "Chá»n má»™t khung cho áº£nh Ä‘áº¡i diá»‡n cá»§a báº¡n",
  _le = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? nle() : r === "pt" ? ile() : r === "ch" ? ale() : r === "de" ? ole() : r === "es" ? sle() : r === "fr" ? lle() : r === "it" ? cle() : r === "jp" ? ule() : r === "pl" ? hle() : r === "ru" ? dle() : r === "uk" ? ple() : fle()
  },
  mle = () => "Your frames",
  gle = () => "Suas molduras",
  vle = () => "æ‚¨çš„å¸§",
  yle = () => "Ihre Rahmen",
  ble = () => "Tus marcos",
  xle = () => "Vos montures",
  wle = () => "Le tue cornici",
  kle = () => "ã‚ãªãŸã®ãƒ•ãƒ¬ãƒ¼ãƒ ",
  Tle = () => "Twoje ramki",
  Sle = () => "Ð’Ð°ÑˆÐ¸ ÐºÐ°Ð´Ñ€Ñ‹",
  Ple = () => "Ð’Ð°ÑˆÑ– Ð¾Ð¿Ñ€Ð°Ð²Ð¸",
  Mle = () => "Khung cá»§a báº¡n",
  Ile = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? mle() : r === "pt" ? gle() : r === "ch" ? vle() : r === "de" ? yle() : r === "es" ? ble() : r === "fr" ? xle() : r === "it" ? wle() : r === "jp" ? kle() : r === "pl" ? Tle() : r === "ru" ? Sle() : r === "uk" ? Ple() : Mle()
  },
  Cle = () => "No frame in your profile",
  zle = () => "Sem moldura no seu perfil",
  Ale = () => "æ‚¨çš„ä¸ªäººèµ„æ–™ä¸­æ²¡æœ‰ç›¸æ¡†",
  Ele = () => "Kein Rahmen in deinem Profil",
  Lle = () => "Sin marco en tu perfil",
  Dle = () => "Aucun cadre dans votre profil",
  Rle = () => "Nessuna cornice nel tuo profilo",
  jle = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“",
  Fle = () => "Brak ramki w Twoim profilu",
  Ble = () => "ÐÐµÑ‚ Ñ€Ð°Ð¼ÐºÐ¸ Ð² Ð²Ð°ÑˆÐµÐ¼ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ðµ",
  Ole = () => "Ð£ Ð²Ð°ÑˆÐ¾Ð¼Ñƒ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»Ñ– Ð½ÐµÐ¼Ð°Ñ” Ñ€Ð°Ð¼ÐºÐ¸",
  qle = () => "KhÃ´ng cÃ³ khung hÃ¬nh trong há»“ sÆ¡ cá»§a báº¡n",
  Nle = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Cle() : r === "pt" ? zle() : r === "ch" ? Ale() : r === "de" ? Ele() : r === "es" ? Lle() : r === "fr" ? Dle() : r === "it" ? Rle() : r === "jp" ? jle() : r === "pl" ? Fle() : r === "ru" ? Ble() : r === "uk" ? Ole() : qle()
  },
  Vle = () => "Selected",
  Ule = () => "Selecionado",
  Zle = () => "å·²é€‰ä¸­",
  Gle = () => "AusgewÃ¤hlt",
  Wle = () => "Seleccionado",
  Hle = () => "SÃ©lectionnÃ©",
  $le = () => "Selezionato",
  Xle = () => "é¸æŠžæ¸ˆã¿",
  Yle = () => "Wybrano",
  Kle = () => "Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð¾",
  Jle = () => "Ð’Ð¸Ð±Ñ€Ð°Ð½Ð¾",
  Qle = () => "ÄÃ£ chá»n",
  vv = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Vle() : r === "pt" ? Ule() : r === "ch" ? Zle() : r === "de" ? Gle() : r === "es" ? Wle() : r === "fr" ? Hle() : r === "it" ? $le() : r === "jp" ? Xle() : r === "pl" ? Yle() : r === "ru" ? Kle() : r === "uk" ? Jle() : Qle()
  },
  ece = () => "Frames store",
  tce = () => "Moldura",
  rce = () => "å¸§å­˜å‚¨",
  nce = () => "Rahmenspeicher",
  ice = () => "Tienda de marcos",
  ace = () => "Magasin de cadres",
  oce = () => "Corniceria",
  sce = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¹ãƒˆã‚¢",
  lce = () => "Sklep z ramkami",
  cce = () => "ÐœÐ°Ð³Ð°Ð·Ð¸Ð½ Ñ€Ð°Ð¼Ð¾Ðº",
  uce = () => "ÐœÐ°Ð³Ð°Ð·Ð¸Ð½ Ñ€Ð°Ð¼Ð¾Ðº",
  hce = () => "Cá»­a hÃ ng khung",
  dce = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? ece() : r === "pt" ? tce() : r === "ch" ? rce() : r === "de" ? nce() : r === "es" ? ice() : r === "fr" ? ace() : r === "it" ? oce() : r === "jp" ? sce() : r === "pl" ? lce() : r === "ru" ? cce() : r === "uk" ? uce() : hce()
  },
  pce = () => "We don't have frames to buy yet, wait for future updates ;)",
  fce = () => "Ainda nÃ£o temos molduras para comprar, aguarde por futuras atualizaÃ§Ãµes ;)",
  _ce = () => "æˆ‘ä»¬è¿˜æ²¡æœ‰ç›¸æ¡†å¯ä¾›è´­ä¹°ï¼Œæ•¬è¯·æœŸå¾…æœªæ¥çš„æ›´æ–° :)",
  mce = () => "Wir haben noch keine Rahmen zum Kauf, bleibt dran fÃ¼r zukÃ¼nftige Updates ;)",
  gce = () => "AÃºn no tenemos marcos para comprar, espera futuras actualizaciones ;)",
  vce = () => "Nous n'avons pas encore de cadres Ã  acheter, attendez les futures mises Ã  jour ;)",
  yce = () => "Non abbiamo ancora cornici da acquistare, attendete futuri aggiornamenti ;)",
  bce = () => "ã¾ã è³¼å…¥ã§ãã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»Šå¾Œã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ãŠå¾…ã¡ãã ã•ã„ã­ ;)",
  xce = () => "Nie mamy jeszcze ramek do kupienia, poczekaj na przyszÅ‚e aktualizacje ;)",
  wce = () => "Ð£ Ð½Ð°Ñ Ð¿Ð¾ÐºÐ° Ð½ÐµÑ‚ Ñ€Ð°Ð¼ Ð´Ð»Ñ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸, Ð¶Ð´Ð¸Ñ‚Ðµ Ð±ÑƒÐ´ÑƒÑ‰Ð¸Ñ… Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹ ;)",
  kce = () => "Ð£ Ð½Ð°Ñ Ñ‰Ðµ Ð½ÐµÐ¼Ð°Ñ” Ñ€Ð°Ð¼ Ð´Ð»Ñ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸, Ñ‡ÐµÐºÐ°Ð¹Ñ‚Ðµ Ð¼Ð°Ð¹Ð±ÑƒÑ‚Ð½Ñ–Ñ… Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½ÑŒ ;)",
  Tce = () => "ChÃºng tÃ´i chÆ°a cÃ³ khung áº£nh Ä‘á»ƒ bÃ¡n Ä‘Ã¢u, hÃ£y chá» cÃ¡c báº£n cáº­p nháº­t sáº¯p tá»›i nhÃ© ;)",
  Sce = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? pce() : r === "pt" ? fce() : r === "ch" ? _ce() : r === "de" ? mce() : r === "es" ? gce() : r === "fr" ? vce() : r === "it" ? yce() : r === "jp" ? bce() : r === "pl" ? xce() : r === "ru" ? wce() : r === "uk" ? kce() : Tce()
  },
  Pce = () => "Buy",
  Mce = () => "Comprar",
  Ice = () => "è´­ä¹°",
  Cce = () => "Kaufen",
  zce = () => "Comprar",
  Ace = () => "Acheter",
  Ece = () => "Acquista",
  Lce = () => "è³¼å…¥",
  Dce = () => "Kup",
  Rce = () => "ÐšÑƒÐ¿Ð¸Ñ‚ÑŒ",
  jce = () => "ÐšÑƒÐ¿Ð¸",
  Fce = () => "Mua",
  Bce = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Pce() : r === "pt" ? Mce() : r === "ch" ? Ice() : r === "de" ? Cce() : r === "es" ? zce() : r === "fr" ? Ace() : r === "it" ? Ece() : r === "jp" ? Lce() : r === "pl" ? Dce() : r === "ru" ? Rce() : r === "uk" ? jce() : Fce()
  },
  Oce = () => "None",
  qce = () => "Nenhum",
  Nce = () => "æ— ",
  Vce = () => "Keine",
  Uce = () => "Ninguno",
  Zce = () => "Aucun",
  Gce = () => "Nessuno",
  Wce = () => "ãªã—",
  Hce = () => "Brak",
  $ce = () => "ÐÐµÑ‚",
  Xce = () => "Ð–Ð¾Ð´Ð½Ð¾Ð³Ð¾",
  Yce = () => "KhÃ´ng cÃ³",
  Kce = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Oce() : r === "pt" ? qce() : r === "ch" ? Nce() : r === "de" ? Vce() : r === "es" ? Uce() : r === "fr" ? Zce() : r === "it" ? Gce() : r === "jp" ? Wce() : r === "pl" ? Hce() : r === "ru" ? $ce() : r === "uk" ? Xce() : Yce()
  },
  Jce = () => "No frame",
  Qce = () => "Sem moldura",
  eue = () => "æ— è¾¹æ¡†",
  tue = () => "Kein Rahmen",
  rue = () => "Sin marco",
  nue = () => "Aucun cadre",
  iue = () => "Nessuna cornice",
  aue = () => "ãƒ•ãƒ¬ãƒ¼ãƒ ãªã—",
  oue = () => "Brak ramki",
  sue = () => "Ð‘ÐµÐ· Ñ€Ð°Ð¼ÐºÐ¸",
  lue = () => "Ð‘ÐµÐ· Ñ€Ð°Ð¼ÐºÐ¸",
  cue = () => "KhÃ´ng khung",
  uue = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Jce() : r === "pt" ? Qce() : r === "ch" ? eue() : r === "de" ? tue() : r === "es" ? rue() : r === "fr" ? nue() : r === "it" ? iue() : r === "jp" ? aue() : r === "pl" ? oue() : r === "ru" ? sue() : r === "uk" ? lue() : cue()
  },
  hue = () => "Wayback Tool",
  due = () => "Ferramenta Wayback",
  pue = () => "Wayback å·¥å…·",
  fue = () => "Wayback-Werkzeug",
  _ue = () => "Herramienta Wayback",
  mue = () => "Outil Wayback",
  gue = () => "Strumento Wayback",
  vue = () => "Wayback ãƒ„ãƒ¼ãƒ«",
  yue = () => "NarzÄ™dzie Wayback",
  bue = () => "Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Wayback",
  xue = () => "Ð†Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Wayback",
  wue = () => "CÃ´ng cá»¥ Wayback",
  kue = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? hue() : r === "pt" ? due() : r === "ch" ? pue() : r === "de" ? fue() : r === "es" ? _ue() : r === "fr" ? mue() : r === "it" ? gue() : r === "jp" ? vue() : r === "pl" ? yue() : r === "ru" ? bue() : r === "uk" ? xue() : wue()
  },
  Tue = () => "You can only appeal once per punishment",
  Sue = () => "VocÃª sÃ³ pode apelar uma vez por puniÃ§Ã£o",
  Pue = () => "æ‚¨åªèƒ½å¯¹æ¯æ¬¡å¤„ç½šä¸Šè¯‰ä¸€æ¬¡ã€‚",
  Mue = () => "Sie kÃ¶nnen nur einmal pro Bestrafung Berufung einlegen.",
  Iue = () => "Solo puedes apelar una vez por sanciÃ³n",
  Cue = () => "Vous ne pouvez faire appel qu'une seule fois par sanction.",
  zue = () => "Puoi appellare solo una volta per punizione",
  Aue = () => "ç½°å‰‡ã«ã¤ãã€ç•°è­°ç”³ã—ç«‹ã¦ã¯ä¸€åº¦ã—ã‹ã§ãã¾ã›ã‚“ã€‚",
  Eue = () => "MoÅ¼esz odwoÅ‚aÄ‡ siÄ™ tylko raz od kaÅ¼dej kary",
  Lue = () => "Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð°Ñ‚ÑŒ Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸ÑŽ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð· Ð·Ð° ÐºÐ°Ð¶Ð´Ð¾Ðµ Ð½Ð°ÐºÐ°Ð·Ð°Ð½Ð¸Ðµ",
  Due = () => "Ð’Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð°Ñ‚Ð¸ Ð°Ð¿ÐµÐ»ÑÑ†Ñ–ÑŽ Ð»Ð¸ÑˆÐµ Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð· Ð·Ð° Ð¿Ð¾ÐºÐ°Ñ€Ð°Ð½Ð½Ñ.",
  Rue = () => "Báº¡n chá»‰ cÃ³ thá»ƒ khÃ¡ng cÃ¡o má»™t láº§n cho má»—i hÃ¬nh pháº¡t.",
  jue = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Tue() : r === "pt" ? Sue() : r === "ch" ? Pue() : r === "de" ? Mue() : r === "es" ? Iue() : r === "fr" ? Cue() : r === "it" ? zue() : r === "jp" ? Aue() : r === "pl" ? Eue() : r === "ru" ? Lue() : r === "uk" ? Due() : Rue()
  },
  Fue = () => "Appeal feedback",
  Bue = () => "Feedback de apelo",
  Oue = () => "ä¸Šè¯‰åé¦ˆ",
  que = () => "RÃ¼ckmeldung zum Einspruch",
  Nue = () => "RetroalimentaciÃ³n de apelaciÃ³n",
  Vue = () => "Retour d'information sur l'appel",
  Uue = () => "Feedback d'appello",
  Zue = () => "ç•°è­°ç”³ã—ç«‹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯",
  Gue = () => "Informacja zwrotna dotyczÄ…ca odwoÅ‚ania",
  Wue = () => "ÐžÐ±Ñ€Ð°Ñ‚Ð½Ð°Ñ ÑÐ²ÑÐ·ÑŒ Ð¿Ð¾ Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸Ð¸",
  Hue = () => "Ð’Ñ–Ð´Ð³ÑƒÐº Ñ‰Ð¾Ð´Ð¾ Ð°Ð¿ÐµÐ»ÑÑ†Ñ–Ñ—",
  $ue = () => "Pháº£n há»“i vá» khiáº¿u náº¡i",
  yv = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Fue() : r === "pt" ? Bue() : r === "ch" ? Oue() : r === "de" ? que() : r === "es" ? Nue() : r === "fr" ? Vue() : r === "it" ? Uue() : r === "jp" ? Zue() : r === "pl" ? Gue() : r === "ru" ? Wue() : r === "uk" ? Hue() : $ue()
  },
  Xue = () => "Your appeal was reviewed by the moderation team and approved. The applied sanction was reversed.",
  Yue = () => "Sua apelaÃ§Ã£o foi revisada pela equipe de moderaÃ§Ã£o e aprovada. A sanÃ§Ã£o aplicada foi revertida.",
  Kue = () => "æ‚¨çš„ç”³è¯‰å·²ç”±å®¡æ ¸å›¢é˜Ÿå®¡æŸ¥å¹¶æ‰¹å‡†ã€‚æ‰€æ–½åŠ çš„å¤„ç½šå·²è¢«æ’¤é”€ã€‚",
  Jue = () => "Ihr Einspruch wurde vom Moderationsteam geprÃ¼ft und genehmigt. Die verhÃ¤ngte Sanktion wurde aufgehoben.",
  Que = () => "Su apelaciÃ³n fue revisada por el equipo de moderaciÃ³n y aprobada. La sanciÃ³n aplicada fue revertida.",
  ehe = () => "Votre appel a Ã©tÃ© examinÃ© par l'Ã©quipe de modÃ©ration et approuvÃ©. La sanction appliquÃ©e a Ã©tÃ© annulÃ©e.",
  the = () => "Il tuo ricorso Ã¨ stato esaminato dal team di moderazione e approvato. La sanzione applicata Ã¨ stata revocata.",
  rhe = () => "ãŠå®¢æ§˜ã®ç•°è­°ç”³ã—ç«‹ã¦ã¯ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ãƒ ã«ã‚ˆã£ã¦å¯©æŸ»ã•ã‚Œã€æ‰¿èªã•ã‚Œã¾ã—ãŸã€‚é©ç”¨ã•ã‚ŒãŸåˆ¶è£ã¯æ’¤å›žã•ã‚Œã¾ã—ãŸã€‚",
  nhe = () => "Twoja apelacja zostaÅ‚a rozpatrzona przez zespÃ³Å‚ moderacji i zatwierdzona. NaÅ‚oÅ¼ona sankcja zostaÅ‚a anulowana.",
  ihe = () => "Ð’Ð°ÑˆÐ° Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸Ñ Ð±Ñ‹Ð»Ð° Ñ€Ð°ÑÑÐ¼Ð¾Ñ‚Ñ€ÐµÐ½Ð° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ Ð¼Ð¾Ð´ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð¸ Ð¾Ð´Ð¾Ð±Ñ€ÐµÐ½Ð°. ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð½Ð°Ñ ÑÐ°Ð½ÐºÑ†Ð¸Ñ Ð±Ñ‹Ð»Ð° Ð¾Ñ‚Ð¼ÐµÐ½ÐµÐ½Ð°.",
  ahe = () => "Ð’Ð°ÑˆÐ° Ð°Ð¿ÐµÐ»ÑÑ†Ñ–Ñ Ð±ÑƒÐ»Ð° Ñ€Ð¾Ð·Ð³Ð»ÑÐ½ÑƒÑ‚Ð° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾ÑŽ Ð¼Ð¾Ð´ÐµÑ€Ð°Ñ†Ñ–Ñ— Ñ‚Ð° ÑÑ…Ð²Ð°Ð»ÐµÐ½Ð°. Ð—Ð°ÑÑ‚Ð¾ÑÐ¾Ð²Ð°Ð½Ð° ÑÐ°Ð½ÐºÑ†Ñ–Ñ Ð±ÑƒÐ»Ð° ÑÐºÐ°ÑÐ¾Ð²Ð°Ð½Ð°.",
  ohe = () => "Khiáº¿u náº¡i cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c Ä‘á»™i ngÅ© kiá»ƒm duyá»‡t xem xÃ©t vÃ  cháº¥p thuáº­n. Biá»‡n phÃ¡p trá»«ng pháº¡t Ä‘Ã£ Ã¡p dá»¥ng Ä‘Ã£ Ä‘Æ°á»£c gá»¡ bá».",
  bv = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Xue() : r === "pt" ? Yue() : r === "ch" ? Kue() : r === "de" ? Jue() : r === "es" ? Que() : r === "fr" ? ehe() : r === "it" ? the() : r === "jp" ? rhe() : r === "pl" ? nhe() : r === "ru" ? ihe() : r === "uk" ? ahe() : ohe()
  },
  she = () => "Your appeal was reviewed by the moderation team and the decision was upheld.",
  lhe = () => "Sua apelaÃ§Ã£o foi revisada pela equipe de moderaÃ§Ã£o e a decisao foi mantida.",
  che = () => "æ‚¨çš„ç”³è¯‰å·²ç”±å®¡æ ¸å›¢é˜Ÿå®¡æ ¸ï¼Œå¹¶ç»´æŒåŽŸåˆ¤ã€‚",
  uhe = () => "Ihr Einspruch wurde vom Moderationsteam Ã¼berprÃ¼ft und die Entscheidung wurde beibehalten.",
  hhe = () => "Su apelaciÃ³n fue revisada por el equipo de moderaciÃ³n y la decisiÃ³n fue confirmada.",
  dhe = () => "Votre appel a Ã©tÃ© examinÃ© par l'Ã©quipe de modÃ©ration et la dÃ©cision a Ã©tÃ© maintenue.",
  phe = () => "Il tuo appello Ã¨ stato esaminato dal team di moderazione e la decisione Ã¨ stata confermata.",
  fhe = () => "ã‚ãªãŸã®ç•°è­°ç”³ã—ç«‹ã¦ã¯ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ãƒ ã«ã‚ˆã£ã¦å¯©æŸ»ã•ã‚Œã€æ±ºå®šã¯ç¶­æŒã•ã‚Œã¾ã—ãŸã€‚",
  _he = () => "Twoja apelacja zostaÅ‚a rozpatrzona przez zespÃ³Å‚ moderacji i decyzja zostaÅ‚a podtrzymana.",
  mhe = () => "Ð’Ð°ÑˆÐ° Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸Ñ Ð±Ñ‹Ð»Ð° Ñ€Ð°ÑÑÐ¼Ð¾Ñ‚Ñ€ÐµÐ½Ð° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ Ð¼Ð¾Ð´ÐµÑ€Ð°Ñ†Ð¸Ð¸, Ð¸ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ Ð±Ñ‹Ð»Ð¾ Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¾ Ð² ÑÐ¸Ð»Ðµ.",
  ghe = () => "Ð’Ð°ÑˆÐ° Ð°Ð¿ÐµÐ»ÑÑ†Ñ–Ñ Ð±ÑƒÐ»Ð° Ñ€Ð¾Ð·Ð³Ð»ÑÐ½ÑƒÑ‚Ð° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾ÑŽ Ð¼Ð¾Ð´ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ–Ð², Ñ– Ñ€Ñ–ÑˆÐµÐ½Ð½Ñ Ð±ÑƒÐ»Ð¾ Ð·Ð°Ð»Ð¸ÑˆÐµÐ½Ð¾ Ð² ÑÐ¸Ð»Ñ–.",
  vhe = () => "ÄÆ¡n khÃ¡ng nghá»‹ cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c Ä‘á»™i ngÅ© kiá»ƒm duyá»‡t xem xÃ©t vÃ  quyáº¿t Ä‘á»‹nh Ä‘Ã£ Ä‘Æ°á»£c giá»¯ nguyÃªn.",
  xv = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? she() : r === "pt" ? lhe() : r === "ch" ? che() : r === "de" ? uhe() : r === "es" ? hhe() : r === "fr" ? dhe() : r === "it" ? phe() : r === "jp" ? fhe() : r === "pl" ? _he() : r === "ru" ? mhe() : r === "uk" ? ghe() : vhe()
  },
  yhe = () => "If you believe your suspension was a mistake, you can submit an appeal to have your punishment reviewed. Each punishment allows only <b>1 appeal</b>. If you have already submitted an appeal for this punishment, you will not be able to submit another for the same case. Submitting an appeal <b>does not guarantee your suspension will be removed</b>; however, our team will review your situation again. After the review, <b>you will receive a notification</b>.",
  bhe = () => `Se vocÃª acredita que sua suspensÃ£o foi um erro, vocÃª pode enviar um apelo para que sua puniÃ§Ã£o seja revisada.

Cada puniÃ§Ã£o permite apenas <b>1 apelo</b>. Se vocÃª jÃ¡ enviou um apelo para esta puniÃ§Ã£o, nÃ£o serÃ¡ possÃ­vel enviar outro para o mesmo caso.

Enviar um apelo <b>nÃ£o garante que sua suspensÃ£o serÃ¡ removida</b>; no entanto, nossa equipe analisarÃ¡ sua situaÃ§Ã£o novamente.

ApÃ³s a revisÃ£o, <b>vocÃª receberÃ¡ uma notificaÃ§Ã£o</b>.`,
  xhe = () => "å¦‚æžœæ‚¨è®¤ä¸ºæ‚¨çš„è´¦å·æš‚åœæ˜¯é”™è¯¯çš„ï¼Œæ‚¨å¯ä»¥æäº¤ç”³è¯‰ï¼Œä»¥ä¾¿æˆ‘ä»¬é‡æ–°å®¡æ ¸æ‚¨çš„å¤„ç½šã€‚æ¯æ¬¡å¤„ç½šä»…å…è®¸æäº¤ <b>1 æ¬¡ç”³è¯‰</b>ã€‚å¦‚æžœæ‚¨å·²ä¸ºæ­¤æ¬¡å¤„ç½šæäº¤è¿‡ç”³è¯‰ï¼Œåˆ™æ— æ³•å†æ¬¡ä¸ºç›¸åŒæ¡ˆä»¶æäº¤ç”³è¯‰ã€‚æäº¤ç”³è¯‰<b>å¹¶ä¸èƒ½ä¿è¯æ‚¨çš„è´¦å·æš‚åœä¼šè¢«è§£é™¤</b>ï¼›ä½†æ˜¯ï¼Œæˆ‘ä»¬çš„å›¢é˜Ÿå°†é‡æ–°å®¡æŸ¥æ‚¨çš„æƒ…å†µã€‚å®¡æŸ¥ç»“æŸåŽï¼Œ<b>æ‚¨å°†æ”¶åˆ°é€šçŸ¥</b>ã€‚",
  whe = () => "Wenn Sie glauben, dass Ihre Sperre ein Fehler war, kÃ¶nnen Sie Einspruch einlegen, damit Ihre Strafe Ã¼berprÃ¼ft wird. Jede Strafe erlaubt nur <b>1 Einspruch</b>. Wenn Sie bereits einen Einspruch gegen diese Strafe eingereicht haben, ist es nicht mÃ¶glich, einen weiteren fÃ¼r denselben Fall einzureichen. Das Einreichen eines Einspruchs <b>garantiert nicht, dass Ihre Sperre aufgehoben wird</b>; unser Team wird Ihre Situation jedoch erneut prÃ¼fen. Nach der ÃœberprÃ¼fung <b>erhalten Sie eine Benachrichtigung</b>.",
  khe = () => "Si crees que tu suspensiÃ³n fue un error, puedes enviar una apelaciÃ³n para que tu sanciÃ³n sea revisada.Cada sanciÃ³n permite solo <b>1 apelaciÃ³n</b>. Si ya enviaste una apelaciÃ³n para esta sanciÃ³n, no serÃ¡ posible enviar otra para el mismo caso.Enviar una apelaciÃ³n <b>no garantiza que tu suspensiÃ³n serÃ¡ eliminada</b>; sin embargo, nuestro equipo revisarÃ¡ tu situaciÃ³n nuevamente.DespuÃ©s de la revisiÃ³n, <b>recibirÃ¡s una notificaciÃ³n</b>.",
  The = () => "Si vous pensez que votre suspension Ã©tait une erreur, vous pouvez soumettre un appel afin que votre sanction soit rÃ©examinÃ©e. Chaque sanction n'autorise qu'<b>un seul appel</b>. Si vous avez dÃ©jÃ  soumis un appel pour cette sanction, il ne sera pas possible d'en soumettre un autre pour le mÃªme cas. Soumettre un appel <b>ne garantit pas que votre suspension sera levÃ©e</b> ; cependant, notre Ã©quipe rÃ©examinera votre situation. AprÃ¨s l'examen, <b>vous recevrez une notification</b>.",
  She = () => "Se ritieni che la tua sospensione sia stata un errore, puoi inviare un ricorso affinchÃ© la tua sanzione venga revisionata. Ogni sanzione consente un solo <b>ricorso</b>. Se hai giÃ  inviato un ricorso per questa sanzione, non sarÃ  possibile inviarne un altro per lo stesso caso. L'invio di un ricorso <b>non garantisce che la tua sospensione venga rimossa</b>; tuttavia, il nostro team esaminerÃ  nuovamente la tua situazione. Dopo la revisione, <b>riceverai una notifica</b>.",
  Phe = () => "åœæ­¢ãŒé–“é•ã„ã ã£ãŸã¨æ€ã‚ã‚Œã‚‹å ´åˆã¯ã€å†å¯©æŸ»ã®ãŸã‚ã«ç•°è­°ç”³ã—ç«‹ã¦ã‚’æå‡ºã§ãã¾ã™ã€‚å„å‡¦ç½°ã«ã¤ãã€ç•°è­°ç”³ã—ç«‹ã¦ã¯<b>1å›žã®ã¿</b>å¯èƒ½ã§ã™ã€‚ã“ã®å‡¦ç½°ã«å¯¾ã—ã¦æ—¢ã«ç•°è­°ç”³ã—ç«‹ã¦ã‚’æå‡ºã—ã¦ã„ã‚‹å ´åˆã€åŒã˜ã‚±ãƒ¼ã‚¹ã«å¯¾ã—ã¦å†åº¦æå‡ºã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ç•°è­°ç”³ã—ç«‹ã¦ã‚’æå‡ºã—ã¦ã‚‚ã€<b>åœæ­¢ãŒè§£é™¤ã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“</b>ãŒã€å¼Šç¤¾ã®ãƒãƒ¼ãƒ ãŒãŠå®¢æ§˜ã®çŠ¶æ³ã‚’å†åº¦å¯©æŸ»ã„ãŸã—ã¾ã™ã€‚å†å¯©æŸ»å¾Œã€<b>é€šçŸ¥ãŒå±Šãã¾ã™</b>ã€‚",
  Mhe = () => "JeÅ›li uwaÅ¼asz, Å¼e Twoje zawieszenie byÅ‚o bÅ‚Ä™dem, moÅ¼esz zÅ‚oÅ¼yÄ‡ odwoÅ‚anie w celu ponownego rozpatrzenia Twojej kary. KaÅ¼da kara zezwala tylko na <b>1 odwoÅ‚anie</b>. JeÅ›li juÅ¼ zÅ‚oÅ¼yÅ‚eÅ› odwoÅ‚anie w sprawie tej kary, nie bÄ™dzie moÅ¼liwe zÅ‚oÅ¼enie kolejnego dla tej samej sprawy. ZÅ‚oÅ¼enie odwoÅ‚ania <b>nie gwarantuje, Å¼e Twoje zawieszenie zostanie zdjÄ™te</b>; jednak nasz zespÃ³Å‚ ponownie przeanalizuje TwojÄ… sytuacjÄ™. Po ponownym rozpatrzeniu, <b>otrzymasz powiadomienie</b>.",
  Ihe = () => "Ð•ÑÐ»Ð¸ Ð²Ñ‹ ÑÑ‡Ð¸Ñ‚Ð°ÐµÑ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð²Ð°ÑˆÐ° Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ° Ð±Ñ‹Ð»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ¾Ð¹, Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð°Ñ‚ÑŒ Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸ÑŽ Ð´Ð»Ñ Ð¿ÐµÑ€ÐµÑÐ¼Ð¾Ñ‚Ñ€Ð° Ð²Ð°ÑˆÐµÐ³Ð¾ Ð½Ð°ÐºÐ°Ð·Ð°Ð½Ð¸Ñ. ÐŸÐ¾ ÐºÐ°Ð¶Ð´Ð¾Ð¼Ñƒ Ð½Ð°ÐºÐ°Ð·Ð°Ð½Ð¸ÑŽ Ð´Ð¾Ð¿ÑƒÑÐºÐ°ÐµÑ‚ÑÑ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð´Ð½Ð° Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸Ñ. Ð•ÑÐ»Ð¸ Ð²Ñ‹ ÑƒÐ¶Ðµ Ð¿Ð¾Ð´Ð°Ð²Ð°Ð»Ð¸ Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸ÑŽ Ð¿Ð¾ ÑÑ‚Ð¾Ð¼Ñƒ Ð½Ð°ÐºÐ°Ð·Ð°Ð½Ð¸ÑŽ, Ð²Ñ‹ Ð½Ðµ ÑÐ¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð°Ñ‚ÑŒ ÐµÑ‰Ðµ Ð¾Ð´Ð½Ñƒ Ð¿Ð¾ Ñ‚Ð¾Ð¼Ñƒ Ð¶Ðµ Ð´ÐµÐ»Ñƒ. ÐŸÐ¾Ð´Ð°Ñ‡Ð° Ð°Ð¿ÐµÐ»Ð»ÑÑ†Ð¸Ð¸ Ð½Ðµ Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ ÑÐ½ÑÑ‚Ð¸Ñ Ð²Ð°ÑˆÐµÐ¹ Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ¸; Ð¾Ð´Ð½Ð°ÐºÐ¾ Ð½Ð°ÑˆÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð½Ð¾ Ñ€Ð°ÑÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚ Ð²Ð°ÑˆÑƒ ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸ÑŽ. ÐŸÐ¾ÑÐ»Ðµ Ð¿ÐµÑ€ÐµÑÐ¼Ð¾Ñ‚Ñ€Ð° Ð²Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ.",
  Che = () => "Ð¯ÐºÑ‰Ð¾ Ð²Ð¸ Ð²Ð²Ð°Ð¶Ð°Ñ”Ñ‚Ðµ, Ñ‰Ð¾ Ð²Ð°ÑˆÐµ Ð±Ð»Ð¾ÐºÑƒÐ²Ð°Ð½Ð½Ñ Ð±ÑƒÐ»Ð¾ Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ¾Ð²Ð¸Ð¼, Ð²Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð°Ñ‚Ð¸ Ð°Ð¿ÐµÐ»ÑÑ†Ñ–ÑŽ Ð´Ð»Ñ Ð¿ÐµÑ€ÐµÐ³Ð»ÑÐ´Ñƒ Ð²Ð°ÑˆÐ¾Ð³Ð¾ Ð¿Ð¾ÐºÐ°Ñ€Ð°Ð½Ð½Ñ. ÐšÐ¾Ð¶Ð½Ðµ Ð¿Ð¾ÐºÐ°Ñ€Ð°Ð½Ð½Ñ Ð´Ð¾Ð·Ð²Ð¾Ð»ÑÑ” Ð»Ð¸ÑˆÐµ <b>1 Ð°Ð¿ÐµÐ»ÑÑ†Ñ–ÑŽ</b>. Ð¯ÐºÑ‰Ð¾ Ð²Ð¸ Ð²Ð¶Ðµ Ð¿Ð¾Ð´Ð°Ð²Ð°Ð»Ð¸ Ð°Ð¿ÐµÐ»ÑÑ†Ñ–ÑŽ Ñ‰Ð¾Ð´Ð¾ Ñ†ÑŒÐ¾Ð³Ð¾ Ð¿Ð¾ÐºÐ°Ñ€Ð°Ð½Ð½Ñ, Ð²Ð¸ Ð½Ðµ Ð·Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð°Ñ‚Ð¸ Ñ–Ð½ÑˆÑƒ Ð´Ð»Ñ Ñ‚Ð¾Ð³Ð¾ ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð²Ð¸Ð¿Ð°Ð´ÐºÑƒ. ÐŸÐ¾Ð´Ð°Ñ‡Ð° Ð°Ð¿ÐµÐ»ÑÑ†Ñ–Ñ— <b>Ð½Ðµ Ð³Ð°Ñ€Ð°Ð½Ñ‚ÑƒÑ”, Ñ‰Ð¾ Ð²Ð°ÑˆÐµ Ð±Ð»Ð¾ÐºÑƒÐ²Ð°Ð½Ð½Ñ Ð±ÑƒÐ´Ðµ Ð·Ð½ÑÑ‚Ð¾</b>; Ð¾Ð´Ð½Ð°Ðº Ð½Ð°ÑˆÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð½Ð¾ Ñ€Ð¾Ð·Ð³Ð»ÑÐ½Ðµ Ð²Ð°ÑˆÑƒ ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ñ–ÑŽ. ÐŸÑ–ÑÐ»Ñ Ð¿ÐµÑ€ÐµÐ³Ð»ÑÐ´Ñƒ <b>Ð²Ð¸ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ñ”Ñ‚Ðµ ÑÐ¿Ð¾Ð²Ñ–Ñ‰ÐµÐ½Ð½Ñ</b>.",
  zhe = () => "Náº¿u báº¡n tin ráº±ng quyáº¿t Ä‘á»‹nh Ä‘Ã¬nh chá»‰ cá»§a báº¡n lÃ  sai, báº¡n cÃ³ thá»ƒ gá»­i Ä‘Æ¡n khÃ¡ng nghá»‹ Ä‘á»ƒ hÃ¬nh pháº¡t cá»§a báº¡n Ä‘Æ°á»£c xem xÃ©t láº¡i. Má»—i hÃ¬nh pháº¡t chá»‰ cho phÃ©p <b>1 láº§n khÃ¡ng nghá»‹</b>. Náº¿u báº¡n Ä‘Ã£ gá»­i khÃ¡ng nghá»‹ cho hÃ¬nh pháº¡t nÃ y, báº¡n sáº½ khÃ´ng thá»ƒ gá»­i thÃªm má»™t khÃ¡ng nghá»‹ nÃ o khÃ¡c cho cÃ¹ng trÆ°á»ng há»£p Ä‘Ã³. Viá»‡c gá»­i khÃ¡ng nghá»‹ <b>khÃ´ng Ä‘áº£m báº£o ráº±ng quyáº¿t Ä‘á»‹nh Ä‘Ã¬nh chá»‰ cá»§a báº¡n sáº½ Ä‘Æ°á»£c gá»¡ bá»</b>; tuy nhiÃªn, Ä‘á»™i ngÅ© cá»§a chÃºng tÃ´i sáº½ xem xÃ©t láº¡i trÆ°á»ng há»£p cá»§a báº¡n. Sau khi xem xÃ©t, <b>báº¡n sáº½ nháº­n Ä‘Æ°á»£c thÃ´ng bÃ¡o</b>.",
  Ahe = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? yhe() : r === "pt" ? bhe() : r === "ch" ? xhe() : r === "de" ? whe() : r === "es" ? khe() : r === "fr" ? The() : r === "it" ? She() : r === "jp" ? Phe() : r === "pl" ? Mhe() : r === "ru" ? Ihe() : r === "uk" ? Che() : zhe()
  },
  Ehe = () => "Always remember to follow our code of conduct.",
  Lhe = () => "Lembre-se de sempre seguir o nosso cÃ³digo de conduta.",
  Dhe = () => "è¯·å§‹ç»ˆéµå®ˆæˆ‘ä»¬çš„è¡Œä¸ºå‡†åˆ™ã€‚",
  Rhe = () => "Denken Sie immer daran, unseren Verhaltenskodex zu befolgen.",
  jhe = () => "Recuerda siempre seguir nuestro cÃ³digo de conducta.",
  Fhe = () => "N'oubliez pas de toujours suivre notre code de conduite.",
  Bhe = () => "Ricorda di seguire sempre il nostro codice di condotta.",
  Ohe = () => "ç§ãŸã¡ã®è¡Œå‹•è¦ç¯„ã‚’å¸¸ã«å®ˆã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚",
  qhe = () => "Zawsze pamiÄ™taj o przestrzeganiu naszego kodeksu postÄ™powania.",
  Nhe = () => "Ð’ÑÐµÐ³Ð´Ð° Ð¿Ð¾Ð¼Ð½Ð¸Ñ‚Ðµ Ð¾ ÑÐ¾Ð±Ð»ÑŽÐ´ÐµÐ½Ð¸Ð¸ Ð½Ð°ÑˆÐµÐ³Ð¾ ÐºÐ¾Ð´ÐµÐºÑÐ° Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ.",
  Vhe = () => "ÐŸÐ°Ð¼'ÑÑ‚Ð°Ð¹Ñ‚Ðµ Ð·Ð°Ð²Ð¶Ð´Ð¸ Ð´Ð¾Ñ‚Ñ€Ð¸Ð¼ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ð½Ð°ÑˆÐ¾Ð³Ð¾ ÐºÐ¾Ð´ÐµÐºÑÑƒ Ð¿Ð¾Ð²ÐµÐ´Ñ–Ð½ÐºÐ¸.",
  Uhe = () => "HÃ£y luÃ´n nhá»› tuÃ¢n thá»§ quy táº¯c á»©ng xá»­ cá»§a chÃºng tÃ´i.",
  wv = (p = {}, s = {}) => {
    const r = s.locale ?? je();
    return r === "en" ? Ehe() : r === "pt" ? Lhe() : r === "ch" ? Dhe() : r === "de" ? Rhe() : r === "es" ? jhe() : r === "fr" ? Fhe() : r === "it" ? Bhe() : r === "jp" ? Ohe() : r === "pl" ? qhe() : r === "ru" ? Nhe() : r === "uk" ? Vhe() : Uhe()
  },
  os = 2 * Math.PI * 6378137 / 2;
class Aa {
  constructor(s = 256) {
    mn(this, "initialResolution");
    this.tileSize = s, this.initialResolution = 2 * os / this.tileSize
  }
  latLonToMeters(s, r) {
    const x = r / 180 * os,
      z = Math.log(Math.tan((90 + s) * Math.PI / 360)) / (Math.PI / 180) * os / 180;
    return [x, z]
  }
  metersToLatLon(s, r) {
    const x = s / os * 180;
    let z = r / os * 180;
    return z = 180 / Math.PI * (2 * Math.atan(Math.exp(z * Math.PI / 180)) - Math.PI / 2), [z, x]
  }
  pixelsToMeters(s, r, x) {
    const z = this.resolution(x),
      E = s * z - os,
      k = os - r * z;
    return [E, k]
  }
  pixelsToLatLon(s, r, x) {
    const [z, E] = this.pixelsToMeters(s, r, x);
    return this.metersToLatLon(z, E)
  }
  latLonToPixels(s, r, x) {
    const [z, E] = this.latLonToMeters(s, r);
    return this.metersToPixels(z, E, x)
  }
  latLonToPixelsFloor(s, r, x) {
    const [z, E] = this.latLonToPixels(s, r, x);
    return [Math.floor(z), Math.floor(E)]
  }
  metersToPixels(s, r, x) {
    const z = this.resolution(x),
      E = (s + os) / z,
      k = (os - r) / z;
    return [E, k]
  }
  latLonToTile(s, r, x) {
    const [z, E] = this.latLonToMeters(s, r);
    return this.metersToTile(z, E, x)
  }
  metersToTile(s, r, x) {
    const [z, E] = this.metersToPixels(s, r, x);
    return this.pixelsToTile(z, E)
  }
  pixelsToTile(s, r) {
    const x = Math.ceil(s / this.tileSize) - 1,
      z = Math.ceil(r / this.tileSize) - 1;
    return [x, z]
  }
  pixelsToTileLocal(s, r) {
    return {
      tile: this.pixelsToTile(s, r),
      pixel: [Math.floor(s) % this.tileSize, Math.floor(r) % this.tileSize]
    }
  }
  tileBounds(s, r, x) {
    const [z, E] = this.pixelsToMeters(s * this.tileSize, r * this.tileSize, x), [k, l] = this.pixelsToMeters((s + 1) * this.tileSize, (r + 1) * this.tileSize, x);
    return {
      min: [z, E],
      max: [k, l]
    }
  }
  tileBoundsLatLon(s, r, x) {
    const z = this.tileBounds(s, r, x);
    return {
      min: this.metersToLatLon(z.min[0], z.min[1]),
      max: this.metersToLatLon(z.max[0], z.max[1])
    }
  }
  resolution(s) {
    return this.initialResolution / 2 ** s
  }
  latLonToTileAndPixel(s, r, x) {
    const [z, E] = this.latLonToMeters(s, r), [k, l] = this.metersToTile(z, E, x), [F, W] = this.metersToPixels(z, E, x);
    return {
      tile: [k, l],
      pixel: [Math.floor(F) % this.tileSize, Math.floor(W) % this.tileSize]
    }
  }
  pixelBounds(s, r, x) {
    return {
      min: this.pixelsToMeters(s, r, x),
      max: this.pixelsToMeters(s + 1, r + 1, x)
    }
  }
  pixelToBoundsLatLon(s, r, x) {
    const z = this.pixelBounds(s, r, x),
      E = .001885,
      k = (z.max[0] - z.min[0]) * E,
      l = (z.max[1] - z.min[1]) * E;
    return z.min[0] -= k, z.max[0] -= k, z.min[1] -= l, z.max[1] -= l, {
      min: this.metersToLatLon(z.min[0], z.min[1]),
      max: this.metersToLatLon(z.max[0], z.max[1])
    }
  }
  latLonToTileBoundsLatLon(s, r, x) {
    const [z, E] = this.latLonToMeters(s, r), [k, l] = this.metersToTile(z, E, x);
    return this.tileBoundsLatLon(k, l, x)
  }
  latLonToPixelBoundsLatLon(s, r, x) {
    const [z, E] = this.latLonToMeters(s, r), [k, l] = this.metersToPixels(z, E, x);
    return this.pixelToBoundsLatLon(Math.floor(k), Math.floor(l), x)
  }
  latLonToRegionAndPixel(s, r, x, z = xa.regionSize) {
    const [E, k] = this.latLonToPixelsFloor(s, r, x), l = this.tileSize * z;
    return {
      region: [Math.floor(E / l), Math.floor(k / l)],
      pixel: [E % l, k % l]
    }
  }
}

function nm(p, s = !0) {
  const {
    min: r,
    max: x
  } = p;
  return s ? [
    [r[1], x[0]],
    [x[1], x[0]],
    [x[1], r[0]],
    [r[1], r[0]]
  ] : [
    [r[0], x[1]],
    [x[0], x[1]],
    [x[0], r[1]],
    [r[0], r[1]]
  ]
}

function im(p) {
  return [(p.min[0] + p.max[0]) / 2, (p.min[1] + p.max[1]) / 2]
}
const Zhe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  kv = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function Ghe(p) {
  return Math.floor(Math.random() * p)
}
const l_ = 14.5;
async function Whe() {
  const p = $he();
  if (p) return p;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const r = await new Promise((x, z) => navigator.geolocation.getCurrentPosition(E => x(E), E => z(E)));
      return {
        lat: r.coords.latitude,
        lng: r.coords.longitude,
        zoom: l_
      }
    }
  } catch (s) {
    console.error(s)
  }
  return {
    ...Hhe().pos,
    zoom: l_
  }
}

function Hhe() {
  const p = Object.entries(z0),
    s = Ghe(p.length),
    [r, x] = p[s];
  return {
    city: r,
    pos: x
  }
}
const z0 = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  A0 = "location";

function ss(p, s) {
  localStorage.setItem(A0, JSON.stringify({
    ...p,
    zoom: s
  }))
}

function $he() {
  const p = localStorage.getItem(A0);
  if (!p) return;
  const s = JSON.parse(p);
  return s.zoom ?? (s.zoom = l_), s
}

function Xhe(p) {
  return p.lat >= -90 && p.lat <= 90 && p.lng >= -180 && p.lng <= 180
}
var eh, th;
class Yhe {
  constructor() {
    wn(this, eh, Je(-1));
    wn(this, th, Je([]))
  }
  get idx() {
    return g(ir(this, eh))
  }
  set idx(s) {
    H(ir(this, eh), s, !0)
  }
  get entries() {
    return g(ir(this, th))
  }
  set entries(s) {
    H(ir(this, th), s)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(s) {
    const r = this.idx + 1,
      x = this.entries[r];
    x && (this.idx = r, s.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(s) {
    const r = this.idx - 1,
      x = this.entries[r];
    x && (this.idx = r, s.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(s) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), s]
  }
}
eh = new WeakMap, th = new WeakMap;
const Khe = new Yhe;

function Jhe(p) {
  return p && p.__esModule && Object.prototype.hasOwnProperty.call(p, "default") ? p.default : p
}
var sp = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */
var Qhe = sp.exports,
  Tv;

function ede() {
  return Tv || (Tv = 1, (function(p, s) {
    (function(r, x) {
      p.exports = x()
    })(Qhe, (function() {
      var r = {},
        x = {};

      function z(k, l, F) {
        if (x[k] = F, k === "index") {
          var W = "var sharedModule = {}; (" + x.shared + ")(sharedModule); (" + x.worker + ")(sharedModule);",
            ee = {};
          return x.shared(ee), x.index(r, ee), typeof window < "u" && r.setWorkerUrl(window.URL.createObjectURL(new Blob([W], {
            type: "text/javascript"
          }))), r
        }
      }
      z("shared", ["exports"], (function(k) {
        function l(i, t, n, o) {
          return new(n || (n = Promise))((function(u, _) {
            function m(P) {
              try {
                b(o.next(P))
              } catch (I) {
                _(I)
              }
            }

            function y(P) {
              try {
                b(o.throw(P))
              } catch (I) {
                _(I)
              }
            }

            function b(P) {
              var I;
              P.done ? u(P.value) : (I = P.value, I instanceof n ? I : new n((function(L) {
                L(I)
              }))).then(m, y)
            }
            b((o = o.apply(i, t || [])).next())
          }))
        }

        function F(i, t) {
          this.x = i, this.y = t
        }

        function W(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var ee, $;
        typeof SuppressedError == "function" && SuppressedError, F.prototype = {
          clone() {
            return new F(this.x, this.y)
          },
          add(i) {
            return this.clone()._add(i)
          },
          sub(i) {
            return this.clone()._sub(i)
          },
          multByPoint(i) {
            return this.clone()._multByPoint(i)
          },
          divByPoint(i) {
            return this.clone()._divByPoint(i)
          },
          mult(i) {
            return this.clone()._mult(i)
          },
          div(i) {
            return this.clone()._div(i)
          },
          rotate(i) {
            return this.clone()._rotate(i)
          },
          rotateAround(i, t) {
            return this.clone()._rotateAround(i, t)
          },
          matMult(i) {
            return this.clone()._matMult(i)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(i) {
            return this.x === i.x && this.y === i.y
          },
          dist(i) {
            return Math.sqrt(this.distSqr(i))
          },
          distSqr(i) {
            const t = i.x - this.x,
              n = i.y - this.y;
            return t * t + n * n
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(i) {
            return Math.atan2(this.y - i.y, this.x - i.x)
          },
          angleWith(i) {
            return this.angleWithSep(i.x, i.y)
          },
          angleWithSep(i, t) {
            return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t)
          },
          _matMult(i) {
            const t = i[2] * this.x + i[3] * this.y;
            return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this
          },
          _add(i) {
            return this.x += i.x, this.y += i.y, this
          },
          _sub(i) {
            return this.x -= i.x, this.y -= i.y, this
          },
          _mult(i) {
            return this.x *= i, this.y *= i, this
          },
          _div(i) {
            return this.x /= i, this.y /= i, this
          },
          _multByPoint(i) {
            return this.x *= i.x, this.y *= i.y, this
          },
          _divByPoint(i) {
            return this.x /= i.x, this.y /= i.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const i = this.y;
            return this.y = this.x, this.x = -i, this
          },
          _rotate(i) {
            const t = Math.cos(i),
              n = Math.sin(i),
              o = n * this.x + t * this.y;
            return this.x = t * this.x - n * this.y, this.y = o, this
          },
          _rotateAround(i, t) {
            const n = Math.cos(i),
              o = Math.sin(i),
              u = t.y + o * (this.x - t.x) + n * (this.y - t.y);
            return this.x = t.x + n * (this.x - t.x) - o * (this.y - t.y), this.y = u, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: F
        }, F.convert = function(i) {
          if (i instanceof F) return i;
          if (Array.isArray(i)) return new F(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new F(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var se = (function() {
            if ($) return ee;

            function i(t, n, o, u) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (u - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = o, this.p2y = u
            }
            return $ = 1, ee = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, n) {
                if (n === void 0 && (n = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, u = 0; u < 8; u++) {
                  var _ = this.sampleCurveX(o) - t;
                  if (Math.abs(_) < n) return o;
                  var m = this.sampleCurveDerivativeX(o);
                  if (Math.abs(m) < 1e-6) break;
                  o -= _ / m
                }
                var y = 0,
                  b = 1;
                for (o = t, u = 0; u < 20 && (_ = this.sampleCurveX(o), !(Math.abs(_ - t) < n)); u++) t > _ ? y = o : b = o, o = .5 * (b - y) + y;
                return o
              },
              solve: function(t, n) {
                return this.sampleCurveY(this.solveCurveX(t, n))
              }
            }, ee
          })(),
          _e = W(se);
        let ge, V;

        function Me() {
          return ge == null && (ge = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ge
        }

        function we() {
          if (V == null && (V = !1, Me())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let o = 0; o < 25; o++) {
                const u = 4 * o;
                t.fillStyle = `rgb(${u},${u+1},${u+2})`, t.fillRect(o % 5, Math.floor(o / 5), 1, 1)
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let o = 0; o < 100; o++)
                if (o % 4 != 3 && n[o] !== o) {
                  V = !0;
                  break
                }
            }
          }
          return V || !1
        }
        var Fe = 1e-6,
          be = typeof Float32Array < "u" ? Float32Array : Array;

        function Xe() {
          var i = new be(9);
          return be != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i
        }

        function tt(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }

        function Ye() {
          var i = new be(3);
          return be != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i
        }

        function Ce(i) {
          var t = i[0],
            n = i[1],
            o = i[2];
          return Math.sqrt(t * t + n * n + o * o)
        }

        function De(i, t, n) {
          var o = new be(3);
          return o[0] = i, o[1] = t, o[2] = n, o
        }

        function Ke(i, t, n) {
          return i[0] = t[0] + n[0], i[1] = t[1] + n[1], i[2] = t[2] + n[2], i
        }

        function Le(i, t, n) {
          return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i
        }

        function Ne(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = n[0],
            y = n[1],
            b = n[2];
          return i[0] = u * b - _ * y, i[1] = _ * m - o * b, i[2] = o * y - u * m, i
        }
        var vt, et = Ce;

        function We(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = t[3];
          return i[0] = n[0] * o + n[4] * u + n[8] * _ + n[12] * m, i[1] = n[1] * o + n[5] * u + n[9] * _ + n[13] * m, i[2] = n[2] * o + n[6] * u + n[10] * _ + n[14] * m, i[3] = n[3] * o + n[7] * u + n[11] * _ + n[15] * m, i
        }

        function _t() {
          var i = new be(4);
          return be != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i
        }

        function Vt(i, t, n, o) {
          var u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx",
            _ = Math.PI / 360;
          t *= _, o *= _, n *= _;
          var m = Math.sin(t),
            y = Math.cos(t),
            b = Math.sin(n),
            P = Math.cos(n),
            I = Math.sin(o),
            L = Math.cos(o);
          switch (u) {
            case "xyz":
              i[0] = m * P * L + y * b * I, i[1] = y * b * L - m * P * I, i[2] = y * P * I + m * b * L, i[3] = y * P * L - m * b * I;
              break;
            case "xzy":
              i[0] = m * P * L - y * b * I, i[1] = y * b * L - m * P * I, i[2] = y * P * I + m * b * L, i[3] = y * P * L + m * b * I;
              break;
            case "yxz":
              i[0] = m * P * L + y * b * I, i[1] = y * b * L - m * P * I, i[2] = y * P * I - m * b * L, i[3] = y * P * L + m * b * I;
              break;
            case "yzx":
              i[0] = m * P * L + y * b * I, i[1] = y * b * L + m * P * I, i[2] = y * P * I - m * b * L, i[3] = y * P * L - m * b * I;
              break;
            case "zxy":
              i[0] = m * P * L - y * b * I, i[1] = y * b * L + m * P * I, i[2] = y * P * I + m * b * L, i[3] = y * P * L - m * b * I;
              break;
            case "zyx":
              i[0] = m * P * L - y * b * I, i[1] = y * b * L + m * P * I, i[2] = y * P * I - m * b * L, i[3] = y * P * L + m * b * I;
              break;
            default:
              throw new Error("Unknown angle order " + u)
          }
          return i
        }

        function Et() {
          var i = new be(2);
          return be != Float32Array && (i[0] = 0, i[1] = 0), i
        }

        function Pt(i, t) {
          var n = new be(2);
          return n[0] = i, n[1] = t, n
        }
        Ye(), vt = new be(4), be != Float32Array && (vt[0] = 0, vt[1] = 0, vt[2] = 0, vt[3] = 0), Ye(), De(1, 0, 0), De(0, 1, 0), _t(), _t(), Xe(), Et();
        const lt = 8192;

        function $t(i, t, n) {
          return t * (lt / (i.tileSize * Math.pow(2, n - i.tileID.overscaledZ)))
        }

        function yt(i, t) {
          return (i % t + t) % t
        }

        function Rt(i, t, n) {
          return i * (1 - n) + t * n
        }

        function jt(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const t = i * i,
            n = t * i;
          return 4 * (i < .5 ? n : 3 * (i - t) + n - .75)
        }

        function Xt(i, t, n, o) {
          const u = new _e(i, t, n, o);
          return _ => u.solve(_)
        }
        const fr = Xt(.25, .1, .25, 1);

        function Yt(i, t, n) {
          return Math.min(n, Math.max(t, i))
        }

        function lr(i, t, n) {
          const o = n - t,
            u = ((i - t) % o + o) % o + t;
          return u === t ? n : u
        }

        function ot(i, ...t) {
          for (const n of t)
            for (const o in n) i[o] = n[o];
          return i
        }
        let nt = 1;

        function Ut(i, t, n) {
          const o = {};
          for (const u in i) o[u] = t.call(this, i[u], u, i);
          return o
        }

        function Qt(i, t, n) {
          const o = {};
          for (const u in i) t.call(this, i[u], u, i) && (o[u] = i[u]);
          return o
        }

        function Ot(i) {
          return Array.isArray(i) ? i.map(Ot) : typeof i == "object" && i ? Ut(i, Ot) : i
        }
        const mr = {};

        function zt(i) {
          mr[i] || (typeof console < "u" && console.warn(i), mr[i] = !0)
        }

        function Mt(i, t, n) {
          return (n.y - i.y) * (t.x - i.x) > (t.y - i.y) * (n.x - i.x)
        }

        function kt(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope
        }
        let It = null;

        function Gt(i) {
          if (It == null) {
            const t = i.navigator ? i.navigator.userAgent : null;
            It = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return It
        }

        function ht(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap
        }
        const hr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function wr(i, t, n, o, u) {
          return l(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const _ = new VideoFrame(i, {
              timestamp: 0
            });
            try {
              const m = _ == null ? void 0 : _.format;
              if (!m || !m.startsWith("BGR") && !m.startsWith("RGB")) throw new Error(`Unrecognized format ${m}`);
              const y = m.startsWith("BGR"),
                b = new Uint8ClampedArray(o * u * 4);
              if (yield _.copyTo(b, (function(P, I, L, B, U) {
                  const G = 4 * Math.max(-I, 0),
                    K = (Math.max(0, L) - L) * B * 4 + G,
                    ne = 4 * B,
                    pe = Math.max(0, I),
                    Ze = Math.max(0, L);
                  return {
                    rect: {
                      x: pe,
                      y: Ze,
                      width: Math.min(P.width, I + B) - pe,
                      height: Math.min(P.height, L + U) - Ze
                    },
                    layout: [{
                      offset: K,
                      stride: ne
                    }]
                  }
                })(i, t, n, o, u)), y)
                for (let P = 0; P < b.length; P += 4) {
                  const I = b[P];
                  b[P] = b[P + 2], b[P + 2] = I
                }
              return b
            } finally {
              _.close()
            }
          }))
        }
        let ur, qr;

        function kr(i, t, n, o) {
          return i.addEventListener(t, n, o), {
            unsubscribe: () => {
              i.removeEventListener(t, n, o)
            }
          }
        }

        function Zr(i) {
          return i * Math.PI / 180
        }

        function Wr(i) {
          return i / Math.PI * 180
        }
        const tr = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          Hr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          sr = "AbortError";

        function de() {
          return new Error(sr)
        }
        const O = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function N(i) {
          return O.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
        }
        const X = "global-dispatcher";
        class re extends Error {
          constructor(t, n, o, u) {
            super(`AJAXError: ${n} (${t}): ${o}`), this.status = t, this.statusText = n, this.url = o, this.body = u
          }
        }
        const Q = () => kt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          ue = function(i, t) {
            if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
              const o = N(i.url);
              if (o) return o(i, t);
              if (kt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                targetMapId: X
              }, t)
            }
            if (!(/^file:/.test(n = i.url) || /^file:/.test(Q()) && !/^\w+:/.test(n))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(o, u) {
                return l(this, void 0, void 0, (function*() {
                  const _ = new Request(o.url, {
                    method: o.method || "GET",
                    body: o.body,
                    credentials: o.credentials,
                    headers: o.headers,
                    cache: o.cache,
                    referrer: Q(),
                    signal: u.signal
                  });
                  let m, y;
                  o.type !== "json" || _.headers.has("Accept") || _.headers.set("Accept", "application/json");
                  try {
                    m = yield fetch(_)
                  } catch (P) {
                    throw new re(0, P.message, o.url, new Blob)
                  }
                  if (!m.ok) {
                    const P = yield m.blob();
                    throw new re(m.status, m.statusText, o.url, P)
                  }
                  y = o.type === "arrayBuffer" || o.type === "image" ? m.arrayBuffer() : o.type === "json" ? m.json() : m.text();
                  const b = yield y;
                  if (u.signal.aborted) throw de();
                  return {
                    data: b,
                    cacheControl: m.headers.get("Cache-Control"),
                    expires: m.headers.get("Expires")
                  }
                }))
              })(i, t);
              if (kt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                mustQueue: !0,
                targetMapId: X
              }, t)
            }
            var n;
            return (function(o, u) {
              return new Promise(((_, m) => {
                var y;
                const b = new XMLHttpRequest;
                b.open(o.method || "GET", o.url, !0), o.type !== "arrayBuffer" && o.type !== "image" || (b.responseType = "arraybuffer");
                for (const P in o.headers) b.setRequestHeader(P, o.headers[P]);
                o.type === "json" && (b.responseType = "text", !((y = o.headers) === null || y === void 0) && y.Accept || b.setRequestHeader("Accept", "application/json")), b.withCredentials = o.credentials === "include", b.onerror = () => {
                  m(new Error(b.statusText))
                }, b.onload = () => {
                  if (!u.signal.aborted)
                    if ((b.status >= 200 && b.status < 300 || b.status === 0) && b.response !== null) {
                      let P = b.response;
                      if (o.type === "json") try {
                        P = JSON.parse(b.response)
                      } catch (I) {
                        return void m(I)
                      }
                      _({
                        data: P,
                        cacheControl: b.getResponseHeader("Cache-Control"),
                        expires: b.getResponseHeader("Expires")
                      })
                    } else {
                      const P = new Blob([b.response], {
                        type: b.getResponseHeader("Content-Type")
                      });
                      m(new re(b.status, b.statusText, o.url, P))
                    }
                }, u.signal.addEventListener("abort", (() => {
                  b.abort(), m(de())
                })), b.send(o.body)
              }))
            })(i, t)
          };

        function ke(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const t = new URL(i),
            n = window.location;
          return t.protocol === n.protocol && t.host === n.host
        }

        function xe(i, t, n) {
          n[i] && n[i].indexOf(t) !== -1 || (n[i] = n[i] || [], n[i].push(t))
        }

        function Ee(i, t, n) {
          if (n && n[i]) {
            const o = n[i].indexOf(t);
            o !== -1 && n[i].splice(o, 1)
          }
        }
        class He {
          constructor(t, n = {}) {
            ot(this, n), this.type = t
          }
        }
        class Be extends He {
          constructor(t, n = {}) {
            super("error", ot({
              error: t
            }, n))
          }
        }
        class ie {
          on(t, n) {
            return this._listeners = this._listeners || {}, xe(t, n, this._listeners), {
              unsubscribe: () => {
                this.off(t, n)
              }
            }
          }
          off(t, n) {
            return Ee(t, n, this._listeners), Ee(t, n, this._oneTimeListeners), this
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, xe(t, n, this._oneTimeListeners), this) : new Promise((o => this.once(t, o)))
          }
          fire(t, n) {
            typeof t == "string" && (t = new He(t, n || {}));
            const o = t.type;
            if (this.listens(o)) {
              t.target = this;
              const u = this._listeners && this._listeners[o] ? this._listeners[o].slice() : [];
              for (const y of u) y.call(this, t);
              const _ = this._oneTimeListeners && this._oneTimeListeners[o] ? this._oneTimeListeners[o].slice() : [];
              for (const y of _) Ee(o, y, this._oneTimeListeners), y.call(this, t);
              const m = this._eventedParent;
              m && (ot(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), m.fire(t))
            } else t instanceof Be && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this
          }
        }
        var J = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            "font-faces": {
              type: "array",
              value: "fontFaces"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            encoding: {
              type: "enum",
              values: {
                mvt: {},
                mlt: {}
              },
              default: "mvt"
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Ve = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function rt(i, t) {
          const n = {};
          for (const o in i) o !== "ref" && (n[o] = i[o]);
          return Ve.forEach((o => {
            o in t && (n[o] = t[o])
          })), n
        }

        function Ue(i, t) {
          if (Array.isArray(i)) {
            if (!Array.isArray(t) || i.length !== t.length) return !1;
            for (let n = 0; n < i.length; n++)
              if (!Ue(i[n], t[n])) return !1;
            return !0
          }
          if (typeof i == "object" && i !== null && t !== null) {
            if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
            for (const n in i)
              if (!Ue(i[n], t[n])) return !1;
            return !0
          }
          return i === t
        }

        function ae(i, t) {
          i.push(t)
        }

        function Ie(i, t, n) {
          ae(n, {
            command: "addSource",
            args: [i, t[i]]
          })
        }

        function $e(i, t, n) {
          ae(t, {
            command: "removeSource",
            args: [i]
          }), n[i] = !0
        }

        function dt(i, t, n, o) {
          $e(i, n, o), Ie(i, t, n)
        }

        function Tt(i, t, n) {
          let o;
          for (o in i[n])
            if (Object.prototype.hasOwnProperty.call(i[n], o) && o !== "data" && !Ue(i[n][o], t[n][o])) return !1;
          for (o in t[n])
            if (Object.prototype.hasOwnProperty.call(t[n], o) && o !== "data" && !Ue(i[n][o], t[n][o])) return !1;
          return !0
        }

        function pt(i, t, n, o, u, _) {
          i = i || {}, t = t || {};
          for (const m in i) Object.prototype.hasOwnProperty.call(i, m) && (Ue(i[m], t[m]) || n.push({
            command: _,
            args: [o, m, t[m], u]
          }));
          for (const m in t) Object.prototype.hasOwnProperty.call(t, m) && !Object.prototype.hasOwnProperty.call(i, m) && (Ue(i[m], t[m]) || n.push({
            command: _,
            args: [o, m, t[m], u]
          }))
        }

        function St(i) {
          return i.id
        }

        function qt(i, t) {
          return i[t.id] = t, i
        }
        class qe {
          constructor(t, n, o, u) {
            this.message = (t ? `${t}: ` : "") + o, u && (this.identifier = u), n != null && n.__line__ && (this.line = n.__line__)
          }
        }

        function bt(i, ...t) {
          for (const n of t)
            for (const o in n) i[o] = n[o];
          return i
        }
        class Jt extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t
          }
        }
        class Cr {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [o, u] of n) this.bindings[o] = u
          }
          concat(t) {
            return new Cr(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const _r = {
            kind: "null"
          },
          Qe = {
            kind: "number"
          },
          rr = {
            kind: "string"
          },
          Kt = {
            kind: "boolean"
          },
          Tr = {
            kind: "color"
          },
          Rr = {
            kind: "projectionDefinition"
          },
          Qr = {
            kind: "object"
          },
          br = {
            kind: "value"
          },
          Nt = {
            kind: "collator"
          },
          wt = {
            kind: "formatted"
          },
          Ge = {
            kind: "padding"
          },
          xt = {
            kind: "colorArray"
          },
          Wt = {
            kind: "numberArray"
          },
          At = {
            kind: "resolvedImage"
          },
          pr = {
            kind: "variableAnchorOffsetCollection"
          };

        function ar(i, t) {
          return {
            kind: "array",
            itemType: i,
            N: t
          }
        }

        function zr(i) {
          if (i.kind === "array") {
            const t = zr(i.itemType);
            return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return i.kind
        }
        const Jr = [_r, Qe, rr, Kt, Tr, Rr, wt, Qr, ar(br), Ge, Wt, xt, At, pr];

        function jr(i, t) {
          if (t.kind === "error") return null;
          if (i.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !jr(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null
          } else {
            if (i.kind === t.kind) return null;
            if (i.kind === "value") {
              for (const n of Jr)
                if (!jr(n, t)) return null
            }
          }
          return `Expected ${zr(i)} but found ${zr(t)} instead.`
        }

        function Or(i, t) {
          return t.some((n => n.kind === i.kind))
        }

        function Fr(i, t) {
          return t.some((n => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i))
        }

        function rn(i, t) {
          return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind
        }
        const An = .96422,
          kn = .82521,
          Kr = 4 / 29,
          Ur = 6 / 29,
          Cn = 3 * Ur * Ur,
          En = Ur * Ur * Ur,
          Tn = Math.PI / 180,
          Un = 180 / Math.PI;

        function Jn(i) {
          return (i %= 360) < 0 && (i += 360), i
        }

        function ft([i, t, n, o]) {
          let u, _;
          const m = Lr((.2225045 * (i = Ft(i)) + .7168786 * (t = Ft(t)) + .0606169 * (n = Ft(n))) / 1);
          i === t && t === n ? u = _ = m : (u = Lr((.4360747 * i + .3850649 * t + .1430804 * n) / An), _ = Lr((.0139322 * i + .0971045 * t + .7141733 * n) / kn));
          const y = 116 * m - 16;
          return [y < 0 ? 0 : y, 500 * (u - m), 200 * (m - _), o]
        }

        function Ft(i) {
          return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
        }

        function Lr(i) {
          return i > En ? Math.pow(i, 1 / 3) : i / Cn + Kr
        }

        function On([i, t, n, o]) {
          let u = (i + 16) / 116,
            _ = isNaN(t) ? u : u + t / 500,
            m = isNaN(n) ? u : u - n / 200;
          return u = 1 * Si(u), _ = An * Si(_), m = kn * Si(m), [Zn(3.1338561 * _ - 1.6168667 * u - .4906146 * m), Zn(-.9787684 * _ + 1.9161415 * u + .033454 * m), Zn(.0719453 * _ - .2289914 * u + 1.4052427 * m), o]
        }

        function Zn(i) {
          return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
        }

        function Si(i) {
          return i > Ur ? i * i * i : Cn * (i - Kr)
        }
        const Kn = Object.hasOwn || function(i, t) {
          return Object.prototype.hasOwnProperty.call(i, t)
        };

        function Nn(i, t) {
          return Kn(i, t) ? i[t] : void 0
        }

        function Ri(i) {
          return parseInt(i.padEnd(2, i), 16) / 255
        }

        function Br(i, t) {
          return Pr(t ? i / 100 : i, 0, 1)
        }

        function Pr(i, t, n) {
          return Math.min(Math.max(t, i), n)
        }

        function Dn(i) {
          return !i.some(Number.isNaN)
        }
        const pn = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function Ar(i, t, n) {
          return i + n * (t - i)
        }

        function gn(i, t, n) {
          return i.map(((o, u) => Ar(o, t[u], n)))
        }
        class Ir {
          constructor(t, n, o, u = 1, _ = !0) {
            this.r = t, this.g = n, this.b = o, this.a = u, _ || (this.r *= u, this.g *= u, this.b *= u, u || this.overwriteGetter("rgb", [t, n, o, u]))
          }
          static parse(t) {
            if (t instanceof Ir) return t;
            if (typeof t != "string") return;
            const n = (function(o) {
              if ((o = o.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const u = Nn(pn, o);
              if (u) {
                const [m, y, b] = u;
                return [m / 255, y / 255, b / 255, 1]
              }
              if (o.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)) {
                const m = o.length < 6 ? 1 : 2;
                let y = 1;
                return [Ri(o.slice(y, y += m)), Ri(o.slice(y, y += m)), Ri(o.slice(y, y += m)), Ri(o.slice(y, y + m) || "ff")]
              }
              if (o.startsWith("rgb")) {
                const m = o.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (m) {
                  const [y, b, P, I, L, B, U, G, K, ne, pe, Ze] = m, ye = [I || " ", U || " ", ne].join("");
                  if (ye === "  " || ye === "  /" || ye === ",," || ye === ",,,") {
                    const ze = [P, B, K].join(""),
                      at = ze === "%%%" ? 100 : ze === "" ? 255 : 0;
                    if (at) {
                      const gt = [Pr(+b / at, 0, 1), Pr(+L / at, 0, 1), Pr(+G / at, 0, 1), pe ? Br(+pe, Ze) : 1];
                      if (Dn(gt)) return gt
                    }
                  }
                  return
                }
              }
              const _ = o.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (_) {
                const [m, y, b, P, I, L, B, U, G] = _, K = [b || " ", I || " ", B].join("");
                if (K === "  " || K === "  /" || K === ",," || K === ",,,") {
                  const ne = [+y, Pr(+P, 0, 100), Pr(+L, 0, 100), U ? Br(+U, G) : 1];
                  if (Dn(ne)) return (function([pe, Ze, ye, ze]) {
                    function at(gt) {
                      const Ht = (gt + pe / 30) % 12,
                        xr = Ze * Math.min(ye, 1 - ye);
                      return ye - xr * Math.max(-1, Math.min(Ht - 3, 9 - Ht, 1))
                    }
                    return pe = Jn(pe), Ze /= 100, ye /= 100, [at(0), at(8), at(4), ze]
                  })(ne)
                }
              }
            })(t);
            return n ? new Ir(...n, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: n,
              b: o,
              a: u
            } = this, _ = u || 1 / 0;
            return this.overwriteGetter("rgb", [t / _, n / _, o / _, u])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [n, o, u, _] = ft(t), m = Math.sqrt(o * o + u * u);
              return [Math.round(1e4 * m) ? Jn(Math.atan2(u, o) * Un) : NaN, m, n, _]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", ft(this.rgb))
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, {
              value: n
            }), n
          }
          toString() {
            const [t, n, o, u] = this.rgb;
            return `rgba(${[t,n,o].map((_=>Math.round(255*_))).join(",")},${u})`
          }
          static interpolate(t, n, o, u = "rgb") {
            switch (u) {
              case "rgb": {
                const [_, m, y, b] = gn(t.rgb, n.rgb, o);
                return new Ir(_, m, y, b, !1)
              }
              case "hcl": {
                const [_, m, y, b] = t.hcl, [P, I, L, B] = n.hcl;
                let U, G;
                if (isNaN(_) || isNaN(P)) isNaN(_) ? isNaN(P) ? U = NaN : (U = P, y !== 1 && y !== 0 || (G = I)) : (U = _, L !== 1 && L !== 0 || (G = m));
                else {
                  let ye = P - _;
                  P > _ && ye > 180 ? ye -= 360 : P < _ && _ - P > 180 && (ye += 360), U = _ + o * ye
                }
                const [K, ne, pe, Ze] = (function([ye, ze, at, gt]) {
                  return ye = isNaN(ye) ? 0 : ye * Tn, On([at, Math.cos(ye) * ze, Math.sin(ye) * ze, gt])
                })([U, G ?? Ar(m, I, o), Ar(y, L, o), Ar(b, B, o)]);
                return new Ir(K, ne, pe, Ze, !1)
              }
              case "lab": {
                const [_, m, y, b] = On(gn(t.lab, n.lab, o));
                return new Ir(_, m, y, b, !1)
              }
            }
          }
        }
        Ir.black = new Ir(0, 0, 0, 1), Ir.white = new Ir(1, 1, 1, 1), Ir.transparent = new Ir(0, 0, 0, 0), Ir.red = new Ir(1, 0, 0, 1);
        class tn {
          constructor(t, n, o) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, n) {
            return this.collator.compare(t, n)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Gn = ["bottom", "center", "top"];
        class qn {
          constructor(t, n, o, u, _, m) {
            this.text = t, this.image = n, this.scale = o, this.fontStack = u, this.textColor = _, this.verticalAlign = m
          }
        }
        class Ln {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new Ln([new qn(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof Ln ? t : Ln.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class Pn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Pn) return t;
            if (typeof t == "number") return new Pn([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t)
                if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new Pn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o) {
            return new Pn(gn(t.values, n.values, o))
          }
        }
        class Mn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Mn) return t;
            if (typeof t == "number") return new Mn([t]);
            if (Array.isArray(t)) {
              for (const n of t)
                if (typeof n != "number") return;
              return new Mn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o) {
            return new Mn(gn(t.values, n.values, o))
          }
        }
        class fn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof fn) return t;
            if (typeof t == "string") {
              const o = Ir.parse(t);
              return o ? new fn([o]) : void 0
            }
            if (!Array.isArray(t)) return;
            const n = [];
            for (const o of t) {
              if (typeof o != "string") return;
              const u = Ir.parse(o);
              if (!u) return;
              n.push(u)
            }
            return new fn(n)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o, u = "rgb") {
            const _ = [];
            if (t.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let m = 0; m < t.values.length; m++) _.push(Ir.interpolate(t.values[m], n.values[m], o, u));
            return new fn(_)
          }
        }
        class un extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const ia = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Wn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Wn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const o = t[n],
                  u = t[n + 1];
                if (typeof o != "string" || !ia.has(o) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number") return
              }
              return new Wn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, n, o) {
            const u = t.values,
              _ = n.values;
            if (u.length !== _.length) throw new un(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const m = [];
            for (let y = 0; y < u.length; y += 2) {
              if (u[y] !== _[y]) throw new un(`Cannot interpolate values containing mismatched anchors. from[${y}]: ${u[y]}, to[${y}]: ${_[y]}`);
              m.push(u[y]);
              const [b, P] = u[y + 1], [I, L] = _[y + 1];
              m.push([Ar(b, I, o), Ar(P, L, o)])
            }
            return new Wn(m)
          }
        }
        class ii {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new ii({
              name: t,
              available: !1
            }) : null
          }
        }
        class li {
          constructor(t, n, o) {
            this.from = t, this.to = n, this.transition = o
          }
          static interpolate(t, n, o) {
            return new li(t, n, o)
          }
          static parse(t) {
            return t instanceof li ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new li(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new li(t.from, t.to, t.transition) : typeof t == "string" ? new li(t, t, 1) : void 0
          }
        }

        function ji(i, t, n, o) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[i,t,n,o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o=="number"?[i,t,n,o]:[i,t,n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Pi(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof li || i instanceof Ir || i instanceof tn || i instanceof Ln || i instanceof Pn || i instanceof Mn || i instanceof fn || i instanceof Wn || i instanceof ii) return !0;
          if (Array.isArray(i)) {
            for (const t of i)
              if (!Pi(t)) return !1;
            return !0
          }
          if (typeof i == "object") {
            for (const t in i)
              if (!Pi(i[t])) return !1;
            return !0
          }
          return !1
        }

        function Qn(i) {
          if (i === null) return _r;
          if (typeof i == "string") return rr;
          if (typeof i == "boolean") return Kt;
          if (typeof i == "number") return Qe;
          if (i instanceof Ir) return Tr;
          if (i instanceof li) return Rr;
          if (i instanceof tn) return Nt;
          if (i instanceof Ln) return wt;
          if (i instanceof Pn) return Ge;
          if (i instanceof Mn) return Wt;
          if (i instanceof fn) return xt;
          if (i instanceof Wn) return pr;
          if (i instanceof ii) return At;
          if (Array.isArray(i)) {
            const t = i.length;
            let n;
            for (const o of i) {
              const u = Qn(o);
              if (n) {
                if (n === u) continue;
                n = br;
                break
              }
              n = u
            }
            return ar(n || br, t)
          }
          return Qr
        }

        function hi(i) {
          const t = typeof i;
          return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof Ir || i instanceof li || i instanceof Ln || i instanceof Pn || i instanceof Mn || i instanceof fn || i instanceof Wn || i instanceof ii ? i.toString() : JSON.stringify(i)
        }
        class Mi {
          constructor(t, n) {
            this.type = t, this.value = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Pi(t[1])) return n.error("invalid value");
            const o = t[1];
            let u = Qn(o);
            const _ = n.expectedType;
            return u.kind !== "array" || u.N !== 0 || !_ || _.kind !== "array" || typeof _.N == "number" && _.N !== 0 || (u = _), new Mi(u, o)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const Ni = {
          string: rr,
          number: Qe,
          boolean: Kt,
          object: Qr
        };
        class Sn {
          constructor(t, n) {
            this.type = t, this.args = n
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let o, u = 1;
            const _ = t[0];
            if (_ === "array") {
              let y, b;
              if (t.length > 2) {
                const P = t[1];
                if (typeof P != "string" || !(P in Ni) || P === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                y = Ni[P], u++
              } else y = br;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                b = t[2], u++
              }
              o = ar(y, b)
            } else {
              if (!Ni[_]) throw new Error(`Types doesn't contain name = ${_}`);
              o = Ni[_]
            }
            const m = [];
            for (; u < t.length; u++) {
              const y = n.parse(t[u], u, br);
              if (!y) return null;
              m.push(y)
            }
            return new Sn(o, m)
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const o = this.args[n].evaluate(t);
              if (!jr(this.type, Qn(o))) return o;
              if (n === this.args.length - 1) throw new un(`Expected value to be of type ${zr(this.type)}, but found ${zr(Qn(o))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const wa = {
          "to-boolean": Kt,
          "to-color": Tr,
          "to-number": Qe,
          "to-string": rr
        };
        class vn {
          constructor(t, n) {
            this.type = t, this.args = n
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const o = t[0];
            if (!wa[o]) throw new Error(`Can't parse ${o} as it is not part of the known types`);
            if ((o === "to-boolean" || o === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const u = wa[o],
              _ = [];
            for (let m = 1; m < t.length; m++) {
              const y = n.parse(t[m], m, br);
              if (!y) return null;
              _.push(y)
            }
            return new vn(u, _)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, o;
                for (const u of this.args) {
                  if (n = u.evaluate(t), o = null, n instanceof Ir) return n;
                  if (typeof n == "string") {
                    const _ = t.parseColor(n);
                    if (_) return _
                  } else if (Array.isArray(n) && (o = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : ji(n[0], n[1], n[2], n[3]), !o)) return new Ir(n[0] / 255, n[1] / 255, n[2] / 255, n[3])
                }
                throw new un(o || `Could not parse color from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "padding": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = Pn.parse(n);
                  if (u) return u
                }
                throw new un(`Could not parse padding from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "numberArray": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = Mn.parse(n);
                  if (u) return u
                }
                throw new un(`Could not parse numberArray from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "colorArray": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = fn.parse(n);
                  if (u) return u
                }
                throw new un(`Could not parse colorArray from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const o of this.args) {
                  n = o.evaluate(t);
                  const u = Wn.parse(n);
                  if (u) return u
                }
                throw new un(`Could not parse variableAnchorOffsetCollection from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "number": {
                let n = null;
                for (const o of this.args) {
                  if (n = o.evaluate(t), n === null) return 0;
                  const u = Number(n);
                  if (!isNaN(u)) return u
                }
                throw new un(`Could not convert ${JSON.stringify(n)} to number.`)
              }
              case "formatted":
                return Ln.fromString(hi(this.args[0].evaluate(t)));
              case "resolvedImage":
                return ii.fromString(hi(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return hi(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const yn = ["Unknown", "Point", "LineString", "Polygon"];
        class Ba {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? yn[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let n = this._parseColorCache.get(t);
            return n || (n = Ir.parse(t), this._parseColorCache.set(t, n)), n
          }
        }
        class Rn {
          constructor(t, n, o = [], u, _ = new Cr, m = []) {
            this.registry = t, this.path = o, this.key = o.map((y => `[${y}]`)).join(""), this.scope = _, this.errors = m, this.expectedType = u, this._isConstant = n
          }
          parse(t, n, o, u, _ = {}) {
            return n ? this.concat(n, o, u)._parse(t, _) : this._parse(t, _)
          }
          _parse(t, n) {
            function o(u, _, m) {
              return m === "assert" ? new Sn(_, [u]) : m === "coerce" ? new vn(_, [u]) : u
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const u = t[0];
              if (typeof u != "string") return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const _ = this.registry[u];
              if (_) {
                let m = _.parse(t, this);
                if (!m) return null;
                if (this.expectedType) {
                  const y = this.expectedType,
                    b = m.type;
                  if (y.kind !== "string" && y.kind !== "number" && y.kind !== "boolean" && y.kind !== "object" && y.kind !== "array" || b.kind !== "value") {
                    if (y.kind === "projectionDefinition" && ["string", "array"].includes(b.kind) || ["color", "formatted", "resolvedImage"].includes(y.kind) && ["value", "string"].includes(b.kind) || ["padding", "numberArray"].includes(y.kind) && ["value", "number", "array"].includes(b.kind) || y.kind === "colorArray" && ["value", "string", "array"].includes(b.kind) || y.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(b.kind)) m = o(m, y, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(y, b)) return null
                  } else m = o(m, y, n.typeAnnotation || "assert")
                }
                if (!(m instanceof Mi) && m.type.kind !== "resolvedImage" && this._isConstant(m)) {
                  const y = new Ba;
                  try {
                    m = new Mi(m.type, m.evaluate(y))
                  } catch (b) {
                    return this.error(b.message), null
                  }
                }
                return m
              }
              return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, n, o) {
            const u = typeof t == "number" ? this.path.concat(t) : this.path,
              _ = o ? this.scope.concat(o) : this.scope;
            return new Rn(this.registry, this._isConstant, u, n || null, _, this.errors)
          }
          error(t, ...n) {
            const o = `${this.key}${n.map((u=>`[${u}]`)).join("")}`;
            this.errors.push(new Jt(o, t))
          }
          checkSubtype(t, n) {
            const o = jr(t, n);
            return o && this.error(o), o
          }
        }
        class Oa {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result)
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const o = [];
            for (let _ = 1; _ < t.length - 1; _ += 2) {
              const m = t[_];
              if (typeof m != "string") return n.error(`Expected string, but found ${typeof m} instead.`, _);
              if (/[^a-zA-Z0-9_]/.test(m)) return n.error("Variable names must contain only alphanumeric characters or '_'.", _);
              const y = n.parse(t[_ + 1], _ + 1);
              if (!y) return null;
              o.push([m, y])
            }
            const u = n.parse(t[t.length - 1], t.length - 1, n.expectedType, o);
            return u ? new Oa(o, u) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class Vi {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const o = t[1];
            return n.scope.has(o) ? new Vi(o, n.scope.get(o)) : n.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class eo {
          constructor(t, n, o) {
            this.type = t, this.index = n, this.input = o
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, Qe),
              u = n.parse(t[2], 2, ar(n.expectedType || br));
            return o && u ? new eo(u.type.itemType, o, u) : null
          }
          evaluate(t) {
            const n = this.index.evaluate(t),
              o = this.input.evaluate(t);
            if (n < 0) throw new un(`Array index out of bounds: ${n} < 0.`);
            if (n >= o.length) throw new un(`Array index out of bounds: ${n} > ${o.length-1}.`);
            if (n !== Math.floor(n)) throw new un(`Array index must be an integer, but found ${n} instead.`);
            return o[n]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class qa {
          constructor(t, n) {
            this.type = Kt, this.needle = t, this.haystack = n
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, br),
              u = n.parse(t[2], 2, br);
            return o && u ? Or(o.type, [Kt, rr, Qe, _r, br]) ? new qa(o, u) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${zr(o.type)} instead`) : null
          }
          evaluate(t) {
            const n = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!o) return !1;
            if (!Fr(n, ["boolean", "string", "number", "null"])) throw new un(`Expected first argument to be of type boolean, string, number or null, but found ${zr(Qn(n))} instead.`);
            if (!Fr(o, ["string", "array"])) throw new un(`Expected second argument to be of type array or string, but found ${zr(Qn(o))} instead.`);
            return o.indexOf(n) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class ka {
          constructor(t, n, o) {
            this.type = Qe, this.needle = t, this.haystack = n, this.fromIndex = o
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, br),
              u = n.parse(t[2], 2, br);
            if (!o || !u) return null;
            if (!Or(o.type, [Kt, rr, Qe, _r, br])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${zr(o.type)} instead`);
            if (t.length === 4) {
              const _ = n.parse(t[3], 3, Qe);
              return _ ? new ka(o, u, _) : null
            }
            return new ka(o, u)
          }
          evaluate(t) {
            const n = this.needle.evaluate(t),
              o = this.haystack.evaluate(t);
            if (!Fr(n, ["boolean", "string", "number", "null"])) throw new un(`Expected first argument to be of type boolean, string, number or null, but found ${zr(Qn(n))} instead.`);
            let u;
            if (this.fromIndex && (u = this.fromIndex.evaluate(t)), Fr(o, ["string"])) {
              const _ = o.indexOf(n, u);
              return _ === -1 ? -1 : [...o.slice(0, _)].length
            }
            if (Fr(o, ["array"])) return o.indexOf(n, u);
            throw new un(`Expected second argument to be of type array or string, but found ${zr(Qn(o))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class oo {
          constructor(t, n, o, u, _, m) {
            this.inputType = t, this.type = n, this.input = o, this.cases = u, this.outputs = _, this.otherwise = m
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let o, u;
            n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
            const _ = {},
              m = [];
            for (let P = 2; P < t.length - 1; P += 2) {
              let I = t[P];
              const L = t[P + 1];
              Array.isArray(I) || (I = [I]);
              const B = n.concat(P);
              if (I.length === 0) return B.error("Expected at least one branch label.");
              for (const G of I) {
                if (typeof G != "number" && typeof G != "string") return B.error("Branch labels must be numbers or strings.");
                if (typeof G == "number" && Math.abs(G) > Number.MAX_SAFE_INTEGER) return B.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof G == "number" && Math.floor(G) !== G) return B.error("Numeric branch labels must be integer values.");
                if (o) {
                  if (B.checkSubtype(o, Qn(G))) return null
                } else o = Qn(G);
                if (_[String(G)] !== void 0) return B.error("Branch labels must be unique.");
                _[String(G)] = m.length
              }
              const U = n.parse(L, P, u);
              if (!U) return null;
              u = u || U.type, m.push(U)
            }
            const y = n.parse(t[1], 1, br);
            if (!y) return null;
            const b = n.parse(t[t.length - 1], t.length - 1, u);
            return b ? y.type.kind !== "value" && n.concat(1).checkSubtype(o, y.type) ? null : new oo(o, u, y, _, m, b) : null
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (Qn(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Na {
          constructor(t, n, o) {
            this.type = t, this.branches = n, this.otherwise = o
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let o;
            n.expectedType && n.expectedType.kind !== "value" && (o = n.expectedType);
            const u = [];
            for (let m = 1; m < t.length - 1; m += 2) {
              const y = n.parse(t[m], m, Kt);
              if (!y) return null;
              const b = n.parse(t[m + 1], m + 1, o);
              if (!b) return null;
              u.push([y, b]), o = o || b.type
            }
            const _ = n.parse(t[t.length - 1], t.length - 1, o);
            if (!_) return null;
            if (!o) throw new Error("Can't infer output type");
            return new Na(o, u, _)
          }
          evaluate(t) {
            for (const [n, o] of this.branches)
              if (n.evaluate(t)) return o.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [n, o] of this.branches) t(n), t(o);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, n]) => n.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class to {
          constructor(t, n, o, u) {
            this.type = t, this.input = n, this.beginIndex = o, this.endIndex = u
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1, br),
              u = n.parse(t[2], 2, Qe);
            if (!o || !u) return null;
            if (!Or(o.type, [ar(br), rr, br])) return n.error(`Expected first argument to be of type array or string, but found ${zr(o.type)} instead`);
            if (t.length === 4) {
              const _ = n.parse(t[3], 3, Qe);
              return _ ? new to(o.type, o, u, _) : null
            }
            return new to(o.type, o, u)
          }
          evaluate(t) {
            const n = this.input.evaluate(t),
              o = this.beginIndex.evaluate(t);
            let u;
            if (this.endIndex && (u = this.endIndex.evaluate(t)), Fr(n, ["string"])) return [...n].slice(o, u).join("");
            if (Fr(n, ["array"])) return n.slice(o, u);
            throw new un(`Expected first argument to be of type array or string, but found ${zr(Qn(n))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function di(i, t) {
          const n = i.length - 1;
          let o, u, _ = 0,
            m = n,
            y = 0;
          for (; _ <= m;)
            if (y = Math.floor((_ + m) / 2), o = i[y], u = i[y + 1], o <= t) {
              if (y === n || t < u) return y;
              _ = y + 1
            } else {
              if (!(o > t)) throw new un("Input is not a number.");
              m = y - 1
            } return 0
        }
        class Ii {
          constructor(t, n, o) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [u, _] of o) this.labels.push(u), this.outputs.push(_)
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const o = n.parse(t[1], 1, Qe);
            if (!o) return null;
            const u = [];
            let _ = null;
            n.expectedType && n.expectedType.kind !== "value" && (_ = n.expectedType);
            for (let m = 1; m < t.length; m += 2) {
              const y = m === 1 ? -1 / 0 : t[m],
                b = t[m + 1],
                P = m,
                I = m + 1;
              if (typeof y != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', P);
              if (u.length && u[u.length - 1][0] >= y) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', P);
              const L = n.parse(b, I, _);
              if (!L) return null;
              _ = _ || L.type, u.push([y, L])
            }
            return new Ii(_, o, u)
          }
          evaluate(t) {
            const n = this.labels,
              o = this.outputs;
            if (n.length === 1) return o[0].evaluate(t);
            const u = this.input.evaluate(t);
            if (u <= n[0]) return o[0].evaluate(t);
            const _ = n.length;
            return u >= n[_ - 1] ? o[_ - 1].evaluate(t) : o[di(n, u)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function _a(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var pi, Va, Bo = (function() {
            if (Va) return pi;

            function i(t, n, o, u) {
              this.cx = 3 * t, this.bx = 3 * (o - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (u - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = o, this.p2y = u
            }
            return Va = 1, pi = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, n) {
                if (n === void 0 && (n = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var o = t, u = 0; u < 8; u++) {
                  var _ = this.sampleCurveX(o) - t;
                  if (Math.abs(_) < n) return o;
                  var m = this.sampleCurveDerivativeX(o);
                  if (Math.abs(m) < 1e-6) break;
                  o -= _ / m
                }
                var y = 0,
                  b = 1;
                for (o = t, u = 0; u < 20 && (_ = this.sampleCurveX(o), !(Math.abs(_ - t) < n)); u++) t > _ ? y = o : b = o, o = .5 * (b - y) + y;
                return o
              },
              solve: function(t, n) {
                return this.sampleCurveY(this.solveCurveX(t, n))
              }
            }, pi
          })(),
          vs = _a(Bo);
        class Hn {
          constructor(t, n, o, u, _) {
            this.type = t, this.operator = n, this.interpolation = o, this.input = u, this.labels = [], this.outputs = [];
            for (const [m, y] of _) this.labels.push(m), this.outputs.push(y)
          }
          static interpolationFactor(t, n, o, u) {
            let _ = 0;
            if (t.name === "exponential") _ = wl(n, t.base, o, u);
            else if (t.name === "linear") _ = wl(n, 1, o, u);
            else if (t.name === "cubic-bezier") {
              const m = t.controlPoints;
              _ = new vs(m[0], m[1], m[2], m[3]).solve(wl(n, 1, o, u))
            }
            return _
          }
          static parse(t, n) {
            let [o, u, _, ...m] = t;
            if (!Array.isArray(u) || u.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (u[0] === "linear") u = {
              name: "linear"
            };
            else if (u[0] === "exponential") {
              const P = u[1];
              if (typeof P != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              u = {
                name: "exponential",
                base: P
              }
            } else {
              if (u[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
              {
                const P = u.slice(1);
                if (P.length !== 4 || P.some((I => typeof I != "number" || I < 0 || I > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                u = {
                  name: "cubic-bezier",
                  controlPoints: P
                }
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (_ = n.parse(_, 2, Qe), !_) return null;
            const y = [];
            let b = null;
            o !== "interpolate-hcl" && o !== "interpolate-lab" || n.expectedType == xt ? n.expectedType && n.expectedType.kind !== "value" && (b = n.expectedType) : b = Tr;
            for (let P = 0; P < m.length; P += 2) {
              const I = m[P],
                L = m[P + 1],
                B = P + 3,
                U = P + 4;
              if (typeof I != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', B);
              if (y.length && y[y.length - 1][0] >= I) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', B);
              const G = n.parse(L, U, b);
              if (!G) return null;
              b = b || G.type, y.push([I, G])
            }
            return rn(b, Qe) || rn(b, Rr) || rn(b, Tr) || rn(b, Ge) || rn(b, Wt) || rn(b, xt) || rn(b, pr) || rn(b, ar(Qe)) ? new Hn(b, o, u, _, y) : n.error(`Type ${zr(b)} is not interpolatable.`)
          }
          evaluate(t) {
            const n = this.labels,
              o = this.outputs;
            if (n.length === 1) return o[0].evaluate(t);
            const u = this.input.evaluate(t);
            if (u <= n[0]) return o[0].evaluate(t);
            const _ = n.length;
            if (u >= n[_ - 1]) return o[_ - 1].evaluate(t);
            const m = di(n, u),
              y = Hn.interpolationFactor(this.interpolation, u, n[m], n[m + 1]),
              b = o[m].evaluate(t),
              P = o[m + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Ar(b, P, y);
                  case "color":
                    return Ir.interpolate(b, P, y);
                  case "padding":
                    return Pn.interpolate(b, P, y);
                  case "colorArray":
                    return fn.interpolate(b, P, y);
                  case "numberArray":
                    return Mn.interpolate(b, P, y);
                  case "variableAnchorOffsetCollection":
                    return Wn.interpolate(b, P, y);
                  case "array":
                    return gn(b, P, y);
                  case "projectionDefinition":
                    return li.interpolate(b, P, y)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Ir.interpolate(b, P, y, "hcl");
                  case "colorArray":
                    return fn.interpolate(b, P, y, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Ir.interpolate(b, P, y, "lab");
                  case "colorArray":
                    return fn.interpolate(b, P, y, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function wl(i, t, n, o) {
          const u = o - n,
            _ = i - n;
          return u === 0 ? 0 : t === 1 ? _ / u : (Math.pow(t, _) - 1) / (Math.pow(t, u) - 1)
        }
        const La = {
          color: Ir.interpolate,
          number: Ar,
          padding: Pn.interpolate,
          numberArray: Mn.interpolate,
          colorArray: fn.interpolate,
          variableAnchorOffsetCollection: Wn.interpolate,
          array: gn
        };
        class Ns {
          constructor(t, n) {
            this.type = t, this.args = n
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let o = null;
            const u = n.expectedType;
            u && u.kind !== "value" && (o = u);
            const _ = [];
            for (const y of t.slice(1)) {
              const b = n.parse(y, 1 + _.length, o, void 0, {
                typeAnnotation: "omit"
              });
              if (!b) return null;
              o = o || b.type, _.push(b)
            }
            if (!o) throw new Error("No output type");
            const m = u && _.some((y => jr(u, y.type)));
            return new Ns(m ? br : o, _)
          }
          evaluate(t) {
            let n, o = null,
              u = 0;
            for (const _ of this.args)
              if (u++, o = _.evaluate(t), o && o instanceof ii && !o.available && (n || (n = o.name), o = null, u === this.args.length && (o = n)), o !== null) break;
            return o
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function Dh(i, t) {
          return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function Oo(i, t, n, o) {
          return o.compare(t, n) === 0
        }

        function so(i, t, n) {
          const o = i !== "==" && i !== "!=";
          return class E0 {
            constructor(_, m, y) {
              this.type = Kt, this.lhs = _, this.rhs = m, this.collator = y, this.hasUntypedArgument = _.type.kind === "value" || m.type.kind === "value"
            }
            static parse(_, m) {
              if (_.length !== 3 && _.length !== 4) return m.error("Expected two or three arguments.");
              const y = _[0];
              let b = m.parse(_[1], 1, br);
              if (!b) return null;
              if (!Dh(y, b.type)) return m.concat(1).error(`"${y}" comparisons are not supported for type '${zr(b.type)}'.`);
              let P = m.parse(_[2], 2, br);
              if (!P) return null;
              if (!Dh(y, P.type)) return m.concat(2).error(`"${y}" comparisons are not supported for type '${zr(P.type)}'.`);
              if (b.type.kind !== P.type.kind && b.type.kind !== "value" && P.type.kind !== "value") return m.error(`Cannot compare types '${zr(b.type)}' and '${zr(P.type)}'.`);
              o && (b.type.kind === "value" && P.type.kind !== "value" ? b = new Sn(P.type, [b]) : b.type.kind !== "value" && P.type.kind === "value" && (P = new Sn(b.type, [P])));
              let I = null;
              if (_.length === 4) {
                if (b.type.kind !== "string" && P.type.kind !== "string" && b.type.kind !== "value" && P.type.kind !== "value") return m.error("Cannot use collator to compare non-string types.");
                if (I = m.parse(_[3], 3, Nt), !I) return null
              }
              return new E0(b, P, I)
            }
            evaluate(_) {
              const m = this.lhs.evaluate(_),
                y = this.rhs.evaluate(_);
              if (o && this.hasUntypedArgument) {
                const b = Qn(m),
                  P = Qn(y);
                if (b.kind !== P.kind || b.kind !== "string" && b.kind !== "number") throw new un(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${b.kind}, ${P.kind}) instead.`)
              }
              if (this.collator && !o && this.hasUntypedArgument) {
                const b = Qn(m),
                  P = Qn(y);
                if (b.kind !== "string" || P.kind !== "string") return t(_, m, y)
              }
              return this.collator ? n(_, m, y, this.collator.evaluate(_)) : t(_, m, y)
            }
            eachChild(_) {
              _(this.lhs), _(this.rhs), this.collator && _(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const Bc = so("==", (function(i, t, n) {
            return t === n
          }), Oo),
          Fp = so("!=", (function(i, t, n) {
            return t !== n
          }), (function(i, t, n, o) {
            return !Oo(0, t, n, o)
          })),
          Rh = so("<", (function(i, t, n) {
            return t < n
          }), (function(i, t, n, o) {
            return o.compare(t, n) < 0
          })),
          kl = so(">", (function(i, t, n) {
            return t > n
          }), (function(i, t, n, o) {
            return o.compare(t, n) > 0
          })),
          Tl = so("<=", (function(i, t, n) {
            return t <= n
          }), (function(i, t, n, o) {
            return o.compare(t, n) <= 0
          })),
          Ua = so(">=", (function(i, t, n) {
            return t >= n
          }), (function(i, t, n, o) {
            return o.compare(t, n) >= 0
          }));
        class Vs {
          constructor(t, n, o) {
            this.type = Nt, this.locale = o, this.caseSensitive = t, this.diacriticSensitive = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const o = t[1];
            if (typeof o != "object" || Array.isArray(o)) return n.error("Collator options argument must be an object.");
            const u = n.parse(o["case-sensitive"] !== void 0 && o["case-sensitive"], 1, Kt);
            if (!u) return null;
            const _ = n.parse(o["diacritic-sensitive"] !== void 0 && o["diacritic-sensitive"], 1, Kt);
            if (!_) return null;
            let m = null;
            return o.locale && (m = n.parse(o.locale, 1, rr), !m) ? null : new Vs(u, _, m)
          }
          evaluate(t) {
            return new tn(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class ys {
          constructor(t, n, o, u, _) {
            this.type = rr, this.number = t, this.locale = n, this.currency = o, this.minFractionDigits = u, this.maxFractionDigits = _
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const o = n.parse(t[1], 1, Qe);
            if (!o) return null;
            const u = t[2];
            if (typeof u != "object" || Array.isArray(u)) return n.error("NumberFormat options argument must be an object.");
            let _ = null;
            if (u.locale && (_ = n.parse(u.locale, 1, rr), !_)) return null;
            let m = null;
            if (u.currency && (m = n.parse(u.currency, 1, rr), !m)) return null;
            let y = null;
            if (u["min-fraction-digits"] && (y = n.parse(u["min-fraction-digits"], 1, Qe), !y)) return null;
            let b = null;
            return u["max-fraction-digits"] && (b = n.parse(u["max-fraction-digits"], 1, Qe), !b) ? null : new ys(o, _, m, y, b)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class Sl {
          constructor(t) {
            this.type = wt, this.sections = t
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const o = t[1];
            if (!Array.isArray(o) && typeof o == "object") return n.error("First argument must be an image or text section.");
            const u = [];
            let _ = !1;
            for (let m = 1; m <= t.length - 1; ++m) {
              const y = t[m];
              if (_ && typeof y == "object" && !Array.isArray(y)) {
                _ = !1;
                let b = null;
                if (y["font-scale"] && (b = n.parse(y["font-scale"], 1, Qe), !b)) return null;
                let P = null;
                if (y["text-font"] && (P = n.parse(y["text-font"], 1, ar(rr)), !P)) return null;
                let I = null;
                if (y["text-color"] && (I = n.parse(y["text-color"], 1, Tr), !I)) return null;
                let L = null;
                if (y["vertical-align"]) {
                  if (typeof y["vertical-align"] == "string" && !Gn.includes(y["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${y["vertical-align"]}' instead.`);
                  if (L = n.parse(y["vertical-align"], 1, rr), !L) return null
                }
                const B = u[u.length - 1];
                B.scale = b, B.font = P, B.textColor = I, B.verticalAlign = L
              } else {
                const b = n.parse(t[m], 1, br);
                if (!b) return null;
                const P = b.type.kind;
                if (P !== "string" && P !== "value" && P !== "null" && P !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                _ = !0, u.push({
                  content: b,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new Sl(u)
          }
          evaluate(t) {
            return new Ln(this.sections.map((n => {
              const o = n.content.evaluate(t);
              return Qn(o) === At ? new qn("", o, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new qn(hi(o), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Us {
          constructor(t) {
            this.type = At, this.input = t
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const o = n.parse(t[1], 1, rr);
            return o ? new Us(o) : n.error("No image name provided.")
          }
          evaluate(t) {
            const n = this.input.evaluate(t),
              o = ii.fromString(n);
            return o && t.availableImages && (o.available = t.availableImages.indexOf(n) > -1), o
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Oc {
          constructor(t) {
            this.type = Qe, this.input = t
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = n.parse(t[1], 1);
            return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${zr(o.type)} instead.`) : new Oc(o) : null
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new un(`Expected value to be of type string or array, but found ${zr(Qn(n))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const ro = 8192;

        function Bp(i, t) {
          const n = (180 + i[0]) / 360,
            o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360,
            u = Math.pow(2, t.z);
          return [Math.round(n * u * ro), Math.round(o * u * ro)]
        }

        function qc(i, t) {
          const n = Math.pow(2, t.z);
          return [(u = (i[0] / ro + t.x) / n, 360 * u - 180), (o = (i[1] / ro + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90)];
          var o, u
        }

        function So(i, t) {
          i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1])
        }

        function Zs(i, t) {
          return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3])
        }

        function jh(i, t, n) {
          const o = i[0] - t[0],
            u = i[1] - t[1],
            _ = i[0] - n[0],
            m = i[1] - n[1];
          return o * m - _ * u == 0 && o * _ <= 0 && u * m <= 0
        }

        function Gs(i, t, n, o) {
          return (u = [o[0] - n[0], o[1] - n[1]])[0] * (_ = [t[0] - i[0], t[1] - i[1]])[1] - u[1] * _[0] != 0 && !(!Bh(i, t, n, o) || !Bh(n, o, i, t));
          var u, _
        }

        function Op(i, t, n) {
          for (const o of n)
            for (let u = 0; u < o.length - 1; ++u)
              if (Gs(i, t, o[u], o[u + 1])) return !0;
          return !1
        }

        function qo(i, t, n = !1) {
          let o = !1;
          for (const y of t)
            for (let b = 0; b < y.length - 1; b++) {
              if (jh(i, y[b], y[b + 1])) return n;
              (_ = y[b])[1] > (u = i)[1] != (m = y[b + 1])[1] > u[1] && u[0] < (m[0] - _[0]) * (u[1] - _[1]) / (m[1] - _[1]) + _[0] && (o = !o)
            }
          var u, _, m;
          return o
        }

        function qp(i, t) {
          for (const n of t)
            if (qo(i, n)) return !0;
          return !1
        }

        function Fh(i, t) {
          for (const n of i)
            if (!qo(n, t)) return !1;
          for (let n = 0; n < i.length - 1; ++n)
            if (Op(i[n], i[n + 1], t)) return !1;
          return !0
        }

        function Np(i, t) {
          for (const n of t)
            if (Fh(i, n)) return !0;
          return !1
        }

        function Bh(i, t, n, o) {
          const u = o[0] - n[0],
            _ = o[1] - n[1],
            m = (i[0] - n[0]) * _ - u * (i[1] - n[1]),
            y = (t[0] - n[0]) * _ - u * (t[1] - n[1]);
          return m > 0 && y < 0 || m < 0 && y > 0
        }

        function Nc(i, t, n) {
          const o = [];
          for (let u = 0; u < i.length; u++) {
            const _ = [];
            for (let m = 0; m < i[u].length; m++) {
              const y = Bp(i[u][m], n);
              So(t, y), _.push(y)
            }
            o.push(_)
          }
          return o
        }

        function Vc(i, t, n) {
          const o = [];
          for (let u = 0; u < i.length; u++) {
            const _ = Nc(i[u], t, n);
            o.push(_)
          }
          return o
        }

        function Uc(i, t, n, o) {
          if (i[0] < n[0] || i[0] > n[2]) {
            const u = .5 * o;
            let _ = i[0] - n[0] > u ? -o : n[0] - i[0] > u ? o : 0;
            _ === 0 && (_ = i[0] - n[2] > u ? -o : n[2] - i[0] > u ? o : 0), i[0] += _
          }
          So(t, i)
        }

        function Zc(i, t, n, o) {
          const u = Math.pow(2, o.z) * ro,
            _ = [o.x * ro, o.y * ro],
            m = [];
          for (const y of i)
            for (const b of y) {
              const P = [b.x + _[0], b.y + _[1]];
              Uc(P, t, n, u), m.push(P)
            }
          return m
        }

        function Oh(i, t, n, o) {
          const u = Math.pow(2, o.z) * ro,
            _ = [o.x * ro, o.y * ro],
            m = [];
          for (const b of i) {
            const P = [];
            for (const I of b) {
              const L = [I.x + _[0], I.y + _[1]];
              So(t, L), P.push(L)
            }
            m.push(P)
          }
          if (t[2] - t[0] <= u / 2) {
            (y = t)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
            for (const b of m)
              for (const P of b) Uc(P, t, n, u)
          }
          var y;
          return m
        }
        class No {
          constructor(t, n) {
            this.type = Kt, this.geojson = t, this.geometries = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Pi(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") {
                const u = [];
                for (const _ of o.features) {
                  const {
                    type: m,
                    coordinates: y
                  } = _.geometry;
                  m === "Polygon" && u.push(y), m === "MultiPolygon" && u.push(...y)
                }
                if (u.length) return new No(o, {
                  type: "MultiPolygon",
                  coordinates: u
                })
              } else if (o.type === "Feature") {
                const u = o.geometry.type;
                if (u === "Polygon" || u === "MultiPolygon") return new No(o, o.geometry)
              } else if (o.type === "Polygon" || o.type === "MultiPolygon") return new No(o, o)
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = n.canonicalID();
                if (o.type === "Polygon") {
                  const y = Nc(o.coordinates, _, m),
                    b = Zc(n.geometry(), u, _, m);
                  if (!Zs(u, _)) return !1;
                  for (const P of b)
                    if (!qo(P, y)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const y = Vc(o.coordinates, _, m),
                    b = Zc(n.geometry(), u, _, m);
                  if (!Zs(u, _)) return !1;
                  for (const P of b)
                    if (!qp(P, y)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = n.canonicalID();
                if (o.type === "Polygon") {
                  const y = Nc(o.coordinates, _, m),
                    b = Oh(n.geometry(), u, _, m);
                  if (!Zs(u, _)) return !1;
                  for (const P of b)
                    if (!Fh(P, y)) return !1
                }
                if (o.type === "MultiPolygon") {
                  const y = Vc(o.coordinates, _, m),
                    b = Oh(n.geometry(), u, _, m);
                  if (!Zs(u, _)) return !1;
                  for (const P of b)
                    if (!Np(P, y)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let qh = class {
          constructor(i = [], t = (n, o) => n < o ? -1 : n > o ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n)
          }
          push(i) {
            this.data.push(i), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), i
          }
          peek() {
            return this.data[0]
          }
          _up(i) {
            const {
              data: t,
              compare: n
            } = this, o = t[i];
            for (; i > 0;) {
              const u = i - 1 >> 1,
                _ = t[u];
              if (n(o, _) >= 0) break;
              t[i] = _, i = u
            }
            t[i] = o
          }
          _down(i) {
            const {
              data: t,
              compare: n
            } = this, o = this.length >> 1, u = t[i];
            for (; i < o;) {
              let _ = 1 + (i << 1);
              const m = _ + 1;
              if (m < this.length && n(t[m], t[_]) < 0 && (_ = m), n(t[_], u) >= 0) break;
              t[i] = t[_], i = _
            }
            t[i] = u
          }
        };

        function Nh(i, t, n = 0, o = i.length - 1, u = Vp) {
          for (; o > n;) {
            if (o - n > 600) {
              const b = o - n + 1,
                P = t - n + 1,
                I = Math.log(b),
                L = .5 * Math.exp(2 * I / 3),
                B = .5 * Math.sqrt(I * L * (b - L) / b) * (P - b / 2 < 0 ? -1 : 1);
              Nh(i, t, Math.max(n, Math.floor(t - P * L / b + B)), Math.min(o, Math.floor(t + (b - P) * L / b + B)), u)
            }
            const _ = i[t];
            let m = n,
              y = o;
            for (Po(i, n, t), u(i[o], _) > 0 && Po(i, n, o); m < y;) {
              for (Po(i, m, y), m++, y--; u(i[m], _) < 0;) m++;
              for (; u(i[y], _) > 0;) y--
            }
            u(i[n], _) === 0 ? Po(i, n, y) : (y++, Po(i, y, o)), y <= t && (n = y + 1), t <= y && (o = y - 1)
          }
        }

        function Po(i, t, n) {
          const o = i[t];
          i[t] = i[n], i[n] = o
        }

        function Vp(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function Pl(i, t) {
          if (i.length <= 1) return [i];
          const n = [];
          let o, u;
          for (const _ of i) {
            const m = Zp(_);
            m !== 0 && (_.area = Math.abs(m), u === void 0 && (u = m < 0), u === m < 0 ? (o && n.push(o), o = [_]) : o.push(_))
          }
          if (o && n.push(o), t > 1)
            for (let _ = 0; _ < n.length; _++) n[_].length <= t || (Nh(n[_], t, 1, n[_].length - 1, Up), n[_] = n[_].slice(0, t));
          return n
        }

        function Up(i, t) {
          return t.area - i.area
        }

        function Zp(i) {
          let t = 0;
          for (let n, o, u = 0, _ = i.length, m = _ - 1; u < _; m = u++) n = i[u], o = i[m], t += (o.x - n.x) * (n.y + o.y);
          return t
        }
        const Ml = 1 / 298.257223563,
          Gc = Ml * (2 - Ml),
          Vh = Math.PI / 180;
        class Wc {
          constructor(t) {
            const n = 6378.137 * Vh * 1e3,
              o = Math.cos(t * Vh),
              u = 1 / (1 - Gc * (1 - o * o)),
              _ = Math.sqrt(u);
            this.kx = n * _ * o, this.ky = n * _ * u * (1 - Gc)
          }
          distance(t, n) {
            const o = this.wrap(t[0] - n[0]) * this.kx,
              u = (t[1] - n[1]) * this.ky;
            return Math.sqrt(o * o + u * u)
          }
          pointOnLine(t, n) {
            let o, u, _, m, y = 1 / 0;
            for (let b = 0; b < t.length - 1; b++) {
              let P = t[b][0],
                I = t[b][1],
                L = this.wrap(t[b + 1][0] - P) * this.kx,
                B = (t[b + 1][1] - I) * this.ky,
                U = 0;
              L === 0 && B === 0 || (U = (this.wrap(n[0] - P) * this.kx * L + (n[1] - I) * this.ky * B) / (L * L + B * B), U > 1 ? (P = t[b + 1][0], I = t[b + 1][1]) : U > 0 && (P += L / this.kx * U, I += B / this.ky * U)), L = this.wrap(n[0] - P) * this.kx, B = (n[1] - I) * this.ky;
              const G = L * L + B * B;
              G < y && (y = G, o = P, u = I, _ = b, m = U)
            }
            return {
              point: [o, u],
              index: _,
              t: Math.max(0, Math.min(1, m))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function Hc(i, t) {
          return t[0] - i[0]
        }

        function Ws(i) {
          return i[1] - i[0] + 1
        }

        function lo(i, t) {
          return i[1] >= i[0] && i[1] < t
        }

        function $c(i, t) {
          if (i[0] > i[1]) return [null, null];
          const n = Ws(i);
          if (t) {
            if (n === 2) return [i, null];
            const u = Math.floor(n / 2);
            return [
              [i[0], i[0] + u],
              [i[0] + u, i[1]]
            ]
          }
          if (n === 1) return [i, null];
          const o = Math.floor(n / 2) - 1;
          return [
            [i[0], i[0] + o],
            [i[0] + o + 1, i[1]]
          ]
        }

        function Xc(i, t) {
          if (!lo(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let o = t[0]; o <= t[1]; ++o) So(n, i[o]);
          return n
        }

        function Il(i) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of i)
            for (const o of n) So(t, o);
          return t
        }

        function Uh(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0
        }

        function Yc(i, t, n) {
          if (!Uh(i) || !Uh(t)) return NaN;
          let o = 0,
            u = 0;
          return i[2] < t[0] && (o = t[0] - i[2]), i[0] > t[2] && (o = i[0] - t[2]), i[1] > t[3] && (u = i[1] - t[3]), i[3] < t[1] && (u = t[1] - i[3]), n.distance([0, 0], [o, u])
        }

        function Vo(i, t, n) {
          const o = n.pointOnLine(t, i);
          return n.distance(i, o.point)
        }

        function Kc(i, t, n, o, u) {
          const _ = Math.min(Vo(i, [n, o], u), Vo(t, [n, o], u)),
            m = Math.min(Vo(n, [i, t], u), Vo(o, [i, t], u));
          return Math.min(_, m)
        }

        function $n(i, t, n, o, u) {
          if (!lo(t, i.length) || !lo(o, n.length)) return 1 / 0;
          let _ = 1 / 0;
          for (let m = t[0]; m < t[1]; ++m) {
            const y = i[m],
              b = i[m + 1];
            for (let P = o[0]; P < o[1]; ++P) {
              const I = n[P],
                L = n[P + 1];
              if (Gs(y, b, I, L)) return 0;
              _ = Math.min(_, Kc(y, b, I, L, u))
            }
          }
          return _
        }

        function Gp(i, t, n, o, u) {
          if (!lo(t, i.length) || !lo(o, n.length)) return NaN;
          let _ = 1 / 0;
          for (let m = t[0]; m <= t[1]; ++m)
            for (let y = o[0]; y <= o[1]; ++y)
              if (_ = Math.min(_, u.distance(i[m], n[y])), _ === 0) return _;
          return _
        }

        function Wp(i, t, n) {
          if (qo(i, t, !0)) return 0;
          let o = 1 / 0;
          for (const u of t) {
            const _ = u[0],
              m = u[u.length - 1];
            if (_ !== m && (o = Math.min(o, Vo(i, [m, _], n)), o === 0)) return o;
            const y = n.pointOnLine(u, i);
            if (o = Math.min(o, n.distance(i, y.point)), o === 0) return o
          }
          return o
        }

        function Hp(i, t, n, o) {
          if (!lo(t, i.length)) return NaN;
          for (let _ = t[0]; _ <= t[1]; ++_)
            if (qo(i[_], n, !0)) return 0;
          let u = 1 / 0;
          for (let _ = t[0]; _ < t[1]; ++_) {
            const m = i[_],
              y = i[_ + 1];
            for (const b of n)
              for (let P = 0, I = b.length, L = I - 1; P < I; L = P++) {
                const B = b[L],
                  U = b[P];
                if (Gs(m, y, B, U)) return 0;
                u = Math.min(u, Kc(m, y, B, U, o))
              }
          }
          return u
        }

        function Zh(i, t) {
          for (const n of i)
            for (const o of n)
              if (qo(o, t, !0)) return !0;
          return !1
        }

        function $p(i, t, n, o = 1 / 0) {
          const u = Il(i),
            _ = Il(t);
          if (o !== 1 / 0 && Yc(u, _, n) >= o) return o;
          if (Zs(u, _)) {
            if (Zh(i, t)) return 0
          } else if (Zh(t, i)) return 0;
          let m = 1 / 0;
          for (const y of i)
            for (let b = 0, P = y.length, I = P - 1; b < P; I = b++) {
              const L = y[I],
                B = y[b];
              for (const U of t)
                for (let G = 0, K = U.length, ne = K - 1; G < K; ne = G++) {
                  const pe = U[ne],
                    Ze = U[G];
                  if (Gs(L, B, pe, Ze)) return 0;
                  m = Math.min(m, Kc(L, B, pe, Ze, n))
                }
            }
          return m
        }

        function Gh(i, t, n, o, u, _) {
          if (!_) return;
          const m = Yc(Xc(o, _), u, n);
          m < t && i.push([m, _, [0, 0]])
        }

        function Cl(i, t, n, o, u, _, m) {
          if (!_ || !m) return;
          const y = Yc(Xc(o, _), Xc(u, m), n);
          y < t && i.push([y, _, m])
        }

        function zl(i, t, n, o, u = 1 / 0) {
          let _ = Math.min(o.distance(i[0], n[0][0]), u);
          if (_ === 0) return _;
          const m = new qh([
              [0, [0, i.length - 1],
                [0, 0]
              ]
            ], Hc),
            y = Il(n);
          for (; m.length > 0;) {
            const b = m.pop();
            if (b[0] >= _) continue;
            const P = b[1],
              I = t ? 50 : 100;
            if (Ws(P) <= I) {
              if (!lo(P, i.length)) return NaN;
              if (t) {
                const L = Hp(i, P, n, o);
                if (isNaN(L) || L === 0) return L;
                _ = Math.min(_, L)
              } else
                for (let L = P[0]; L <= P[1]; ++L) {
                  const B = Wp(i[L], n, o);
                  if (_ = Math.min(_, B), _ === 0) return 0
                }
            } else {
              const L = $c(P, t);
              Gh(m, _, o, i, y, L[0]), Gh(m, _, o, i, y, L[1])
            }
          }
          return _
        }

        function Al(i, t, n, o, u, _ = 1 / 0) {
          let m = Math.min(_, u.distance(i[0], n[0]));
          if (m === 0) return m;
          const y = new qh([
            [0, [0, i.length - 1],
              [0, n.length - 1]
            ]
          ], Hc);
          for (; y.length > 0;) {
            const b = y.pop();
            if (b[0] >= m) continue;
            const P = b[1],
              I = b[2],
              L = t ? 50 : 100,
              B = o ? 50 : 100;
            if (Ws(P) <= L && Ws(I) <= B) {
              if (!lo(P, i.length) && lo(I, n.length)) return NaN;
              let U;
              if (t && o) U = $n(i, P, n, I, u), m = Math.min(m, U);
              else if (t && !o) {
                const G = i.slice(P[0], P[1] + 1);
                for (let K = I[0]; K <= I[1]; ++K)
                  if (U = Vo(n[K], G, u), m = Math.min(m, U), m === 0) return m
              } else if (!t && o) {
                const G = n.slice(I[0], I[1] + 1);
                for (let K = P[0]; K <= P[1]; ++K)
                  if (U = Vo(i[K], G, u), m = Math.min(m, U), m === 0) return m
              } else U = Gp(i, P, n, I, u), m = Math.min(m, U)
            } else {
              const U = $c(P, t),
                G = $c(I, o);
              Cl(y, m, u, i, n, U[0], G[0]), Cl(y, m, u, i, n, U[0], G[1]), Cl(y, m, u, i, n, U[1], G[0]), Cl(y, m, u, i, n, U[1], G[1])
            }
          }
          return m
        }

        function Jc(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : i.type === "MultiLineString" ? i.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : i.type === "MultiPoint" ? i.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [i]
        }
        class Uo {
          constructor(t, n) {
            this.type = Qe, this.geojson = t, this.geometries = n
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Pi(t[1])) {
              const o = t[1];
              if (o.type === "FeatureCollection") return new Uo(o, o.features.map((u => Jc(u.geometry))).flat());
              if (o.type === "Feature") return new Uo(o, Jc(o.geometry));
              if ("type" in o && "coordinates" in o) return new Uo(o, Jc(o))
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, o) {
                const u = n.geometry(),
                  _ = u.flat().map((b => qc([b.x, b.y], n.canonical)));
                if (u.length === 0) return NaN;
                const m = new Wc(_[0][1]);
                let y = 1 / 0;
                for (const b of o) {
                  switch (b.type) {
                    case "Point":
                      y = Math.min(y, Al(_, !1, [b.coordinates], !1, m, y));
                      break;
                    case "LineString":
                      y = Math.min(y, Al(_, !1, b.coordinates, !0, m, y));
                      break;
                    case "Polygon":
                      y = Math.min(y, zl(_, !1, b.coordinates, m, y))
                  }
                  if (y === 0) return y
                }
                return y
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, o) {
                const u = n.geometry(),
                  _ = u.flat().map((b => qc([b.x, b.y], n.canonical)));
                if (u.length === 0) return NaN;
                const m = new Wc(_[0][1]);
                let y = 1 / 0;
                for (const b of o) {
                  switch (b.type) {
                    case "Point":
                      y = Math.min(y, Al(_, !0, [b.coordinates], !1, m, y));
                      break;
                    case "LineString":
                      y = Math.min(y, Al(_, !0, b.coordinates, !0, m, y));
                      break;
                    case "Polygon":
                      y = Math.min(y, zl(_, !0, b.coordinates, m, y))
                  }
                  if (y === 0) return y
                }
                return y
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(n, o) {
                const u = n.geometry();
                if (u.length === 0 || u[0].length === 0) return NaN;
                const _ = Pl(u, 0).map((b => b.map((P => P.map((I => qc([I.x, I.y], n.canonical))))))),
                  m = new Wc(_[0][0][0][1]);
                let y = 1 / 0;
                for (const b of o)
                  for (const P of _) {
                    switch (b.type) {
                      case "Point":
                        y = Math.min(y, zl([b.coordinates], !1, P, m, y));
                        break;
                      case "LineString":
                        y = Math.min(y, zl(b.coordinates, !0, P, m, y));
                        break;
                      case "Polygon":
                        y = Math.min(y, $p(P, b.coordinates, m, y))
                    }
                    if (y === 0) return y
                  }
                return y
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Hs {
          constructor(t) {
            this.type = br, this.key = t
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const o = t[1];
            return o == null ? n.error("Global state property must be defined.") : typeof o != "string" ? n.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Hs(o)
          }
          evaluate(t) {
            var n;
            const o = (n = t.globals) === null || n === void 0 ? void 0 : n.globalState;
            return o && Object.keys(o).length !== 0 ? Nn(o, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const bs = {
          "==": Bc,
          "!=": Fp,
          ">": kl,
          "<": Rh,
          ">=": Ua,
          "<=": Tl,
          array: Sn,
          at: eo,
          boolean: Sn,
          case: Na,
          coalesce: Ns,
          collator: Vs,
          format: Sl,
          image: Us,
          in: qa,
          "index-of": ka,
          interpolate: Hn,
          "interpolate-hcl": Hn,
          "interpolate-lab": Hn,
          length: Oc,
          let: Oa,
          literal: Mi,
          match: oo,
          number: Sn,
          "number-format": ys,
          object: Sn,
          slice: to,
          step: Ii,
          string: Sn,
          "to-boolean": vn,
          "to-color": vn,
          "to-number": vn,
          "to-string": vn,
          var: Vi,
          within: No,
          distance: Uo,
          "global-state": Hs
        };
        class Da {
          constructor(t, n, o, u) {
            this.name = t, this.type = n, this._evaluate = o, this.args = u
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, n) {
            const o = t[0],
              u = Da.definitions[o];
            if (!u) return n.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const _ = Array.isArray(u) ? u[0] : u.type,
              m = Array.isArray(u) ? [
                [u[1], u[2]]
              ] : u.overloads,
              y = m.filter((([P]) => !Array.isArray(P) || P.length === t.length - 1));
            let b = null;
            for (const [P, I] of y) {
              b = new Rn(n.registry, El, n.path, null, n.scope);
              const L = [];
              let B = !1;
              for (let U = 1; U < t.length; U++) {
                const G = t[U],
                  K = Array.isArray(P) ? P[U - 1] : P.type,
                  ne = b.parse(G, 1 + L.length, K);
                if (!ne) {
                  B = !0;
                  break
                }
                L.push(ne)
              }
              if (!B)
                if (Array.isArray(P) && P.length !== L.length) b.error(`Expected ${P.length} arguments, but found ${L.length} instead.`);
                else {
                  for (let U = 0; U < L.length; U++) {
                    const G = Array.isArray(P) ? P[U] : P.type,
                      K = L[U];
                    b.concat(U + 1).checkSubtype(G, K.type)
                  }
                  if (b.errors.length === 0) return new Da(o, _, I, L)
                }
            }
            if (y.length === 1) n.errors.push(...b.errors);
            else {
              const P = (y.length ? y : m).map((([L]) => {
                  return B = L, Array.isArray(B) ? `(${B.map(zr).join(", ")})` : `(${zr(B.type)}...)`;
                  var B
                })).join(" | "),
                I = [];
              for (let L = 1; L < t.length; L++) {
                const B = n.parse(t[L], 1 + I.length);
                if (!B) return null;
                I.push(zr(B.type))
              }
              n.error(`Expected arguments of type ${P}, but found (${I.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, n) {
            Da.definitions = n;
            for (const o in n) t[o] = Da
          }
        }

        function Wh(i, [t, n, o, u]) {
          t = t.evaluate(i), n = n.evaluate(i), o = o.evaluate(i);
          const _ = u ? u.evaluate(i) : 1,
            m = ji(t, n, o, _);
          if (m) throw new un(m);
          return new Ir(t / 255, n / 255, o / 255, _, !1)
        }

        function Hh(i, t) {
          return i in t
        }

        function Qc(i, t) {
          const n = t[i];
          return n === void 0 ? null : n
        }

        function Zo(i) {
          return {
            type: i
          }
        }

        function El(i) {
          if (i instanceof Vi) return El(i.boundExpression);
          if (i instanceof Da && i.name === "error" || i instanceof Vs || i instanceof No || i instanceof Uo || i instanceof Hs) return !1;
          const t = i instanceof vn || i instanceof Sn;
          let n = !0;
          return i.eachChild((o => {
            n = t ? n && El(o) : n && o instanceof Mi
          })), !!n && Ll(i) && Dl(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function Ll(i) {
          if (i instanceof Da && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof No || i instanceof Uo) return !1;
          let t = !0;
          return i.eachChild((n => {
            t && !Ll(n) && (t = !1)
          })), t
        }

        function $s(i) {
          if (i instanceof Da && i.name === "feature-state") return !1;
          let t = !0;
          return i.eachChild((n => {
            t && !$s(n) && (t = !1)
          })), t
        }

        function Dl(i, t) {
          if (i instanceof Da && t.indexOf(i.name) >= 0) return !1;
          let n = !0;
          return i.eachChild((o => {
            n && !Dl(o, t) && (n = !1)
          })), n
        }

        function $h(i) {
          return {
            result: "success",
            value: i
          }
        }

        function xs(i) {
          return {
            result: "error",
            value: i
          }
        }

        function ws(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
        }

        function Xh(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
        }

        function eu(i) {
          return !!i.expression && i.expression.interpolated
        }

        function Fn(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
        }

        function Rl(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && Qn(i) === Qr
        }

        function Xp(i) {
          return i
        }

        function Yh(i, t) {
          const n = i.stops && typeof i.stops[0][0] == "object",
            o = n || !(n || i.property !== void 0),
            u = i.type || (eu(t) ? "exponential" : "interval"),
            _ = (function(I) {
              switch (I.type) {
                case "color":
                  return Ir.parse;
                case "padding":
                  return Pn.parse;
                case "numberArray":
                  return Mn.parse;
                case "colorArray":
                  return fn.parse;
                default:
                  return null
              }
            })(t);
          if (_ && ((i = bt({}, i)).stops && (i.stops = i.stops.map((I => [I[0], _(I[1])]))), i.default = _(i.default ? i.default : t.default)), i.colorSpace && (m = i.colorSpace) !== "rgb" && m !== "hcl" && m !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var m;
          const y = (function(I) {
            switch (I) {
              case "exponential":
                return Kh;
              case "interval":
                return Kp;
              case "categorical":
                return Yp;
              case "identity":
                return Jh;
              default:
                throw new Error(`Unknown function type "${I}"`)
            }
          })(u);
          let b, P;
          if (u === "categorical") {
            b = Object.create(null);
            for (const I of i.stops) b[I[0]] = I[1];
            P = typeof i.stops[0][0]
          }
          if (n) {
            const I = {},
              L = [];
            for (let G = 0; G < i.stops.length; G++) {
              const K = i.stops[G],
                ne = K[0].zoom;
              I[ne] === void 0 && (I[ne] = {
                zoom: ne,
                type: i.type,
                property: i.property,
                default: i.default,
                stops: []
              }, L.push(ne)), I[ne].stops.push([K[0].value, K[1]])
            }
            const B = [];
            for (const G of L) B.push([I[G].zoom, Yh(I[G], t)]);
            const U = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: U,
              interpolationFactor: Hn.interpolationFactor.bind(void 0, U),
              zoomStops: B.map((G => G[0])),
              evaluate: ({
                zoom: G
              }, K) => Kh({
                stops: B,
                base: i.base
              }, t, G).evaluate(G, K)
            }
          }
          if (o) {
            const I = u === "exponential" ? {
              name: "exponential",
              base: i.base !== void 0 ? i.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: I,
              interpolationFactor: Hn.interpolationFactor.bind(void 0, I),
              zoomStops: i.stops.map((L => L[0])),
              evaluate: ({
                zoom: L
              }) => y(i, t, L, b, P)
            }
          }
          return {
            kind: "source",
            evaluate(I, L) {
              const B = L && L.properties ? L.properties[i.property] : void 0;
              return B === void 0 ? Go(i.default, t.default) : y(i, t, B, b, P)
            }
          }
        }

        function Go(i, t, n) {
          return i !== void 0 ? i : t !== void 0 ? t : n !== void 0 ? n : void 0
        }

        function Yp(i, t, n, o, u) {
          return Go(typeof n === u ? o[n] : void 0, i.default, t.default)
        }

        function Kp(i, t, n) {
          if (Fn(n) !== "number") return Go(i.default, t.default);
          const o = i.stops.length;
          if (o === 1 || n <= i.stops[0][0]) return i.stops[0][1];
          if (n >= i.stops[o - 1][0]) return i.stops[o - 1][1];
          const u = di(i.stops.map((_ => _[0])), n);
          return i.stops[u][1]
        }

        function Kh(i, t, n) {
          const o = i.base !== void 0 ? i.base : 1;
          if (Fn(n) !== "number") return Go(i.default, t.default);
          const u = i.stops.length;
          if (u === 1 || n <= i.stops[0][0]) return i.stops[0][1];
          if (n >= i.stops[u - 1][0]) return i.stops[u - 1][1];
          const _ = di(i.stops.map((I => I[0])), n),
            m = (function(I, L, B, U) {
              const G = U - B,
                K = I - B;
              return G === 0 ? 0 : L === 1 ? K / G : (Math.pow(L, K) - 1) / (Math.pow(L, G) - 1)
            })(n, o, i.stops[_][0], i.stops[_ + 1][0]),
            y = i.stops[_][1],
            b = i.stops[_ + 1][1],
            P = La[t.type] || Xp;
          return typeof y.evaluate == "function" ? {
            evaluate(...I) {
              const L = y.evaluate.apply(void 0, I),
                B = b.evaluate.apply(void 0, I);
              if (L !== void 0 && B !== void 0) return P(L, B, m, i.colorSpace)
            }
          } : P(y, b, m, i.colorSpace)
        }

        function Jh(i, t, n) {
          switch (t.type) {
            case "color":
              n = Ir.parse(n);
              break;
            case "formatted":
              n = Ln.fromString(n.toString());
              break;
            case "resolvedImage":
              n = ii.fromString(n.toString());
              break;
            case "padding":
              n = Pn.parse(n);
              break;
            case "colorArray":
              n = fn.parse(n);
              break;
            case "numberArray":
              n = Mn.parse(n);
              break;
            default:
              Fn(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0)
          }
          return Go(n, i.default, t.default)
        }
        Da.register(bs, {
          error: [{
              kind: "error"
            },
            [rr], (i, [t]) => {
              throw new un(t.evaluate(i))
            }
          ],
          typeof: [rr, [br], (i, [t]) => zr(Qn(t.evaluate(i)))],
          "to-rgba": [ar(Qe, 4), [Tr], (i, [t]) => {
            const [n, o, u, _] = t.evaluate(i).rgb;
            return [255 * n, 255 * o, 255 * u, _]
          }],
          rgb: [Tr, [Qe, Qe, Qe], Wh],
          rgba: [Tr, [Qe, Qe, Qe, Qe], Wh],
          has: {
            type: Kt,
            overloads: [
              [
                [rr], (i, [t]) => Hh(t.evaluate(i), i.properties())
              ],
              [
                [rr, Qr], (i, [t, n]) => Hh(t.evaluate(i), n.evaluate(i))
              ]
            ]
          },
          get: {
            type: br,
            overloads: [
              [
                [rr], (i, [t]) => Qc(t.evaluate(i), i.properties())
              ],
              [
                [rr, Qr], (i, [t, n]) => Qc(t.evaluate(i), n.evaluate(i))
              ]
            ]
          },
          "feature-state": [br, [rr], (i, [t]) => Qc(t.evaluate(i), i.featureState || {})],
          properties: [Qr, [], i => i.properties()],
          "geometry-type": [rr, [], i => i.geometryType()],
          id: [br, [], i => i.id()],
          zoom: [Qe, [], i => i.globals.zoom],
          "heatmap-density": [Qe, [], i => i.globals.heatmapDensity || 0],
          elevation: [Qe, [], i => i.globals.elevation || 0],
          "line-progress": [Qe, [], i => i.globals.lineProgress || 0],
          accumulated: [br, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
          "+": [Qe, Zo(Qe), (i, t) => {
            let n = 0;
            for (const o of t) n += o.evaluate(i);
            return n
          }],
          "*": [Qe, Zo(Qe), (i, t) => {
            let n = 1;
            for (const o of t) n *= o.evaluate(i);
            return n
          }],
          "-": {
            type: Qe,
            overloads: [
              [
                [Qe, Qe], (i, [t, n]) => t.evaluate(i) - n.evaluate(i)
              ],
              [
                [Qe], (i, [t]) => -t.evaluate(i)
              ]
            ]
          },
          "/": [Qe, [Qe, Qe], (i, [t, n]) => t.evaluate(i) / n.evaluate(i)],
          "%": [Qe, [Qe, Qe], (i, [t, n]) => t.evaluate(i) % n.evaluate(i)],
          ln2: [Qe, [], () => Math.LN2],
          pi: [Qe, [], () => Math.PI],
          e: [Qe, [], () => Math.E],
          "^": [Qe, [Qe, Qe], (i, [t, n]) => Math.pow(t.evaluate(i), n.evaluate(i))],
          sqrt: [Qe, [Qe], (i, [t]) => Math.sqrt(t.evaluate(i))],
          log10: [Qe, [Qe], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
          ln: [Qe, [Qe], (i, [t]) => Math.log(t.evaluate(i))],
          log2: [Qe, [Qe], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
          sin: [Qe, [Qe], (i, [t]) => Math.sin(t.evaluate(i))],
          cos: [Qe, [Qe], (i, [t]) => Math.cos(t.evaluate(i))],
          tan: [Qe, [Qe], (i, [t]) => Math.tan(t.evaluate(i))],
          asin: [Qe, [Qe], (i, [t]) => Math.asin(t.evaluate(i))],
          acos: [Qe, [Qe], (i, [t]) => Math.acos(t.evaluate(i))],
          atan: [Qe, [Qe], (i, [t]) => Math.atan(t.evaluate(i))],
          min: [Qe, Zo(Qe), (i, t) => Math.min(...t.map((n => n.evaluate(i))))],
          max: [Qe, Zo(Qe), (i, t) => Math.max(...t.map((n => n.evaluate(i))))],
          abs: [Qe, [Qe], (i, [t]) => Math.abs(t.evaluate(i))],
          round: [Qe, [Qe], (i, [t]) => {
            const n = t.evaluate(i);
            return n < 0 ? -Math.round(-n) : Math.round(n)
          }],
          floor: [Qe, [Qe], (i, [t]) => Math.floor(t.evaluate(i))],
          ceil: [Qe, [Qe], (i, [t]) => Math.ceil(t.evaluate(i))],
          "filter-==": [Kt, [rr, br], (i, [t, n]) => i.properties()[t.value] === n.value],
          "filter-id-==": [Kt, [br], (i, [t]) => i.id() === t.value],
          "filter-type-==": [Kt, [rr], (i, [t]) => i.geometryType() === t.value],
          "filter-<": [Kt, [rr, br], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o < u
          }],
          "filter-id-<": [Kt, [br], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n < o
          }],
          "filter->": [Kt, [rr, br], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o > u
          }],
          "filter-id->": [Kt, [br], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n > o
          }],
          "filter-<=": [Kt, [rr, br], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o <= u
          }],
          "filter-id-<=": [Kt, [br], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n <= o
          }],
          "filter->=": [Kt, [rr, br], (i, [t, n]) => {
            const o = i.properties()[t.value],
              u = n.value;
            return typeof o == typeof u && o >= u
          }],
          "filter-id->=": [Kt, [br], (i, [t]) => {
            const n = i.id(),
              o = t.value;
            return typeof n == typeof o && n >= o
          }],
          "filter-has": [Kt, [br], (i, [t]) => t.value in i.properties()],
          "filter-has-id": [Kt, [], i => i.id() !== null && i.id() !== void 0],
          "filter-type-in": [Kt, [ar(rr)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
          "filter-id-in": [Kt, [ar(br)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
          "filter-in-small": [Kt, [rr, ar(br)], (i, [t, n]) => n.value.indexOf(i.properties()[t.value]) >= 0],
          "filter-in-large": [Kt, [rr, ar(br)], (i, [t, n]) => (function(o, u, _, m) {
            for (; _ <= m;) {
              const y = _ + m >> 1;
              if (u[y] === o) return !0;
              u[y] > o ? m = y - 1 : _ = y + 1
            }
            return !1
          })(i.properties()[t.value], n.value, 0, n.value.length - 1)],
          all: {
            type: Kt,
            overloads: [
              [
                [Kt, Kt], (i, [t, n]) => t.evaluate(i) && n.evaluate(i)
              ],
              [Zo(Kt), (i, t) => {
                for (const n of t)
                  if (!n.evaluate(i)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: Kt,
            overloads: [
              [
                [Kt, Kt], (i, [t, n]) => t.evaluate(i) || n.evaluate(i)
              ],
              [Zo(Kt), (i, t) => {
                for (const n of t)
                  if (n.evaluate(i)) return !0;
                return !1
              }]
            ]
          },
          "!": [Kt, [Kt], (i, [t]) => !t.evaluate(i)],
          "is-supported-script": [Kt, [rr], (i, [t]) => {
            const n = i.globals && i.globals.isSupportedScript;
            return !n || n(t.evaluate(i))
          }],
          upcase: [rr, [rr], (i, [t]) => t.evaluate(i).toUpperCase()],
          downcase: [rr, [rr], (i, [t]) => t.evaluate(i).toLowerCase()],
          concat: [rr, Zo(br), (i, t) => t.map((n => hi(n.evaluate(i)))).join("")],
          "resolved-locale": [rr, [Nt], (i, [t]) => t.evaluate(i).resolvedLocale()]
        });
        class tu {
          constructor(t, n, o) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Ba, this._defaultValue = n ? (function(u) {
              if (u.type === "color" && Rl(u.default)) return new Ir(0, 0, 0, 0);
              switch (u.type) {
                case "color":
                  return Ir.parse(u.default) || null;
                case "padding":
                  return Pn.parse(u.default) || null;
                case "numberArray":
                  return Mn.parse(u.default) || null;
                case "colorArray":
                  return fn.parse(u.default) || null;
                case "variableAnchorOffsetCollection":
                  return Wn.parse(u.default) || null;
                case "projectionDefinition":
                  return li.parse(u.default) || null;
                default:
                  return u.default === void 0 ? null : u.default
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this._globalState = o
          }
          evaluateWithoutErrorHandling(t, n, o, u, _, m) {
            return this._globalState && (t = Ho(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = o, this._evaluator.canonical = u, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = m, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, n, o, u, _, m) {
            this._globalState && (t = Ho(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = o || null, this._evaluator.canonical = u, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = m || null;
            try {
              const y = this.expression.evaluate(this._evaluator);
              if (y == null || typeof y == "number" && y != y) return this._defaultValue;
              if (this._enumValues && !(y in this._enumValues)) throw new un(`Expected value to be one of ${Object.keys(this._enumValues).map((b=>JSON.stringify(b))).join(", ")}, but found ${JSON.stringify(y)} instead.`);
              return y
            } catch (y) {
              return this._warningHistory[y.message] || (this._warningHistory[y.message] = !0, typeof console < "u" && console.warn(y.message)), this._defaultValue
            }
          }
        }

        function jl(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in bs
        }

        function Wo(i, t, n) {
          const o = new Rn(bs, El, [], t ? (function(_) {
              const m = {
                color: Tr,
                string: rr,
                number: Qe,
                enum: rr,
                boolean: Kt,
                formatted: wt,
                padding: Ge,
                numberArray: Wt,
                colorArray: xt,
                projectionDefinition: Rr,
                resolvedImage: At,
                variableAnchorOffsetCollection: pr
              };
              return _.type === "array" ? ar(m[_.value] || br, _.length) : m[_.type]
            })(t) : void 0),
            u = o.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return u ? $h(new tu(u, t, n)) : xs(o.errors)
        }
        class Xs {
          constructor(t, n, o) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !$s(n.expression), this.globalStateRefs = Ol(n.expression), this._globalState = o
          }
          evaluateWithoutErrorHandling(t, n, o, u, _, m) {
            return this._globalState && (t = Ho(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, o, u, _, m)
          }
          evaluate(t, n, o, u, _, m) {
            return this._globalState && (t = Ho(t, this._globalState)), this._styleExpression.evaluate(t, n, o, u, _, m)
          }
        }
        class ru {
          constructor(t, n, o, u, _) {
            this.kind = t, this.zoomStops = o, this._styleExpression = n, this.isStateDependent = t !== "camera" && !$s(n.expression), this.globalStateRefs = Ol(n.expression), this.interpolationType = u, this._globalState = _
          }
          evaluateWithoutErrorHandling(t, n, o, u, _, m) {
            return this._globalState && (t = Ho(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, o, u, _, m)
          }
          evaluate(t, n, o, u, _, m) {
            return this._globalState && (t = Ho(t, this._globalState)), this._styleExpression.evaluate(t, n, o, u, _, m)
          }
          interpolationFactor(t, n, o) {
            return this.interpolationType ? Hn.interpolationFactor(this.interpolationType, t, n, o) : 0
          }
        }

        function Qh(i, t, n) {
          const o = Wo(i, t, n);
          if (o.result === "error") return o;
          const u = o.value.expression,
            _ = Ll(u);
          if (!_ && !ws(t)) return xs([new Jt("", "data expressions not supported")]);
          const m = Dl(u, ["zoom"]);
          if (!m && !Xh(t)) return xs([new Jt("", "zoom expressions not supported")]);
          const y = Bl(u);
          return y || m ? y instanceof Jt ? xs([y]) : y instanceof Hn && !eu(t) ? xs([new Jt("", '"interpolate" expressions cannot be used with this property')]) : $h(y ? new ru(_ ? "camera" : "composite", o.value, y.labels, y instanceof Hn ? y.interpolation : void 0, n) : new Xs(_ ? "constant" : "source", o.value, n)) : xs([new Jt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Fl {
          constructor(t, n) {
            this._parameters = t, this._specification = n, bt(this, Yh(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new Fl(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function Bl(i) {
          let t = null;
          if (i instanceof Oa) t = Bl(i.result);
          else if (i instanceof Ns) {
            for (const n of i.args)
              if (t = Bl(n), t) break
          } else(i instanceof Ii || i instanceof Hn) && i.input instanceof Da && i.input.name === "zoom" && (t = i);
          return t instanceof Jt || i.eachChild((n => {
            const o = Bl(n);
            o instanceof Jt ? t = o : !t && o ? t = new Jt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && o && t !== o && (t = new Jt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Ol(i, t = new Set) {
          return i instanceof Hs && t.add(i.key), i.eachChild((n => {
            Ol(n, t)
          })), t
        }

        function Ho(i, t) {
          const {
            zoom: n,
            heatmapDensity: o,
            elevation: u,
            lineProgress: _,
            isSupportedScript: m,
            accumulated: y
          } = i ?? {};
          return {
            zoom: n,
            heatmapDensity: o,
            elevation: u,
            lineProgress: _,
            isSupportedScript: m,
            accumulated: y,
            globalState: t
          }
        }

        function ql(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const t of i.slice(1))
                if (!ql(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const Jp = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function Ys(i, t) {
          if (i == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          ql(i) || (i = Ks(i));
          const n = Wo(i, Jp, t);
          if (n.result === "error") throw new Error(n.value.map((o => `${o.key}: ${o.message}`)).join(", "));
          return {
            filter: (o, u, _) => n.value.evaluate(o, u, {}, _),
            needGeometry: nu(i),
            getGlobalStateRefs: () => Ol(n.value.expression)
          }
        }

        function ed(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function nu(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let t = 1; t < i.length; t++)
            if (nu(i[t])) return !0;
          return !1
        }

        function Ks(i) {
          if (!i) return !0;
          const t = i[0];
          return i.length <= 1 ? t !== "any" : t === "==" ? iu(i[1], i[2], "==") : t === "!=" ? Nl(iu(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? iu(i[1], i[2], t) : t === "any" ? (n = i.slice(1), ["any"].concat(n.map(Ks))) : t === "all" ? ["all"].concat(i.slice(1).map(Ks)) : t === "none" ? ["all"].concat(i.slice(1).map(Ks).map(Nl)) : t === "in" ? td(i[1], i.slice(2)) : t === "!in" ? Nl(td(i[1], i.slice(2))) : t === "has" ? rd(i[1]) : t !== "!has" || Nl(rd(i[1]));
          var n
        }

        function iu(i, t, n) {
          switch (i) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, i, t]
          }
        }

        function td(i, t) {
          if (t.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((n => typeof n != typeof t[0])) ? ["filter-in-large", i, ["literal", t.sort(ed)]] : ["filter-in-small", i, ["literal", t]]
          }
        }

        function rd(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i]
          }
        }

        function Nl(i) {
          return ["!", i]
        }

        function Vl(i) {
          const t = typeof i;
          if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let u = "[";
            for (const _ of i) u += `${Vl(_)},`;
            return `${u}]`
          }
          const n = Object.keys(i).sort();
          let o = "{";
          for (let u = 0; u < n.length; u++) o += `${JSON.stringify(n[u])}:${Vl(i[n[u]])},`;
          return `${o}}`
        }

        function nd(i) {
          let t = "";
          for (const n of Ve) t += `/${Vl(i[n])}`;
          return t
        }

        function Ul(i) {
          const t = i.value;
          return t ? [new qe(i.key, t, "constants have been deprecated as of v8")] : []
        }

        function fi(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
        }

        function co(i) {
          if (Array.isArray(i)) return i.map(co);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const t = {};
            for (const n in i) t[n] = co(i[n]);
            return t
          }
          return fi(i)
        }

        function ma(i) {
          const t = i.key,
            n = i.value,
            o = i.valueSpec || {},
            u = i.objectElementValidators || {},
            _ = i.style,
            m = i.styleSpec,
            y = i.validateSpec;
          let b = [];
          const P = Fn(n);
          if (P !== "object") return [new qe(t, n, `object expected, ${P} found`)];
          for (const I in n) {
            const L = I.split(".")[0],
              B = Nn(o, L) || o["*"];
            let U;
            if (Nn(u, L)) U = u[L];
            else if (Nn(o, L)) U = y;
            else if (u["*"]) U = u["*"];
            else {
              if (!o["*"]) {
                b.push(new qe(t, n[I], `unknown property "${I}"`));
                continue
              }
              U = y
            }
            b = b.concat(U({
              key: (t && `${t}.`) + I,
              value: n[I],
              valueSpec: B,
              style: _,
              styleSpec: m,
              object: n,
              objectKey: I,
              validateSpec: y
            }, n))
          }
          for (const I in o) u[I] || o[I].required && o[I].default === void 0 && n[I] === void 0 && b.push(new qe(t, n, `missing required property "${I}"`));
          return b
        }

        function ks(i) {
          const t = i.value,
            n = i.valueSpec,
            o = i.style,
            u = i.styleSpec,
            _ = i.key,
            m = i.arrayElementValidator || i.validateSpec;
          if (Fn(t) !== "array") return [new qe(_, t, `array expected, ${Fn(t)} found`)];
          if (n.length && t.length !== n.length) return [new qe(_, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new qe(_, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let y = {
            type: n.value,
            values: n.values
          };
          u.$version < 7 && (y.function = n.function), Fn(n.value) === "object" && (y = n.value);
          let b = [];
          for (let P = 0; P < t.length; P++) b = b.concat(m({
            array: t,
            arrayIndex: P,
            value: t[P],
            valueSpec: y,
            validateSpec: i.validateSpec,
            style: o,
            styleSpec: u,
            key: `${_}[${P}]`
          }));
          return b
        }

        function Zl(i) {
          const t = i.key,
            n = i.value,
            o = i.valueSpec;
          let u = Fn(n);
          return u === "number" && n != n && (u = "NaN"), u !== "number" ? [new qe(t, n, `number expected, ${u} found`)] : "minimum" in o && n < o.minimum ? [new qe(t, n, `${n} is less than the minimum value ${o.minimum}`)] : "maximum" in o && n > o.maximum ? [new qe(t, n, `${n} is greater than the maximum value ${o.maximum}`)] : []
        }

        function id(i) {
          const t = i.valueSpec,
            n = fi(i.value.type);
          let o, u, _, m = {};
          const y = n !== "categorical" && i.value.property === void 0,
            b = !y,
            P = Fn(i.value.stops) === "array" && Fn(i.value.stops[0]) === "array" && Fn(i.value.stops[0][0]) === "object",
            I = ma({
              key: i.key,
              value: i.value,
              valueSpec: i.styleSpec.function,
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: i.styleSpec,
              objectElementValidators: {
                stops: function(U) {
                  if (n === "identity") return [new qe(U.key, U.value, 'identity function may not have a "stops" property')];
                  let G = [];
                  const K = U.value;
                  return G = G.concat(ks({
                    key: U.key,
                    value: K,
                    valueSpec: U.valueSpec,
                    validateSpec: U.validateSpec,
                    style: U.style,
                    styleSpec: U.styleSpec,
                    arrayElementValidator: L
                  })), Fn(K) === "array" && K.length === 0 && G.push(new qe(U.key, K, "array must have at least one stop")), G
                },
                default: function(U) {
                  return U.validateSpec({
                    key: U.key,
                    value: U.value,
                    valueSpec: t,
                    validateSpec: U.validateSpec,
                    style: U.style,
                    styleSpec: U.styleSpec
                  })
                }
              }
            });
          return n === "identity" && y && I.push(new qe(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || I.push(new qe(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !eu(i.valueSpec) && I.push(new qe(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (b && !ws(i.valueSpec) ? I.push(new qe(i.key, i.value, "property functions not supported")) : y && !Xh(i.valueSpec) && I.push(new qe(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !P || i.value.property !== void 0 || I.push(new qe(i.key, i.value, '"property" property is required')), I;

          function L(U) {
            let G = [];
            const K = U.value,
              ne = U.key;
            if (Fn(K) !== "array") return [new qe(ne, K, `array expected, ${Fn(K)} found`)];
            if (K.length !== 2) return [new qe(ne, K, `array length 2 expected, length ${K.length} found`)];
            if (P) {
              if (Fn(K[0]) !== "object") return [new qe(ne, K, `object expected, ${Fn(K[0])} found`)];
              if (K[0].zoom === void 0) return [new qe(ne, K, "object stop key must have zoom")];
              if (K[0].value === void 0) return [new qe(ne, K, "object stop key must have value")];
              if (_ && _ > fi(K[0].zoom)) return [new qe(ne, K[0].zoom, "stop zoom values must appear in ascending order")];
              fi(K[0].zoom) !== _ && (_ = fi(K[0].zoom), u = void 0, m = {}), G = G.concat(ma({
                key: `${ne}[0]`,
                value: K[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: U.validateSpec,
                style: U.style,
                styleSpec: U.styleSpec,
                objectElementValidators: {
                  zoom: Zl,
                  value: B
                }
              }))
            } else G = G.concat(B({
              key: `${ne}[0]`,
              value: K[0],
              validateSpec: U.validateSpec,
              style: U.style,
              styleSpec: U.styleSpec
            }, K));
            return jl(co(K[1])) ? G.concat([new qe(`${ne}[1]`, K[1], "expressions are not allowed in function stops.")]) : G.concat(U.validateSpec({
              key: `${ne}[1]`,
              value: K[1],
              valueSpec: t,
              validateSpec: U.validateSpec,
              style: U.style,
              styleSpec: U.styleSpec
            }))
          }

          function B(U, G) {
            const K = Fn(U.value),
              ne = fi(U.value),
              pe = U.value !== null ? U.value : G;
            if (o) {
              if (K !== o) return [new qe(U.key, pe, `${K} stop domain type must match previous stop domain type ${o}`)]
            } else o = K;
            if (K !== "number" && K !== "string" && K !== "boolean") return [new qe(U.key, pe, "stop domain value must be a number, string, or boolean")];
            if (K !== "number" && n !== "categorical") {
              let Ze = `number expected, ${K} found`;
              return ws(t) && n === void 0 && (Ze += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new qe(U.key, pe, Ze)]
            }
            return n !== "categorical" || K !== "number" || isFinite(ne) && Math.floor(ne) === ne ? n !== "categorical" && K === "number" && u !== void 0 && ne < u ? [new qe(U.key, pe, "stop domain values must appear in ascending order")] : (u = ne, n === "categorical" && ne in m ? [new qe(U.key, pe, "stop domain values must be unique")] : (m[ne] = !0, [])) : [new qe(U.key, pe, `integer expected, found ${ne}`)]
          }
        }

        function Ts(i) {
          const t = (i.expressionContext === "property" ? Qh : Wo)(co(i.value), i.valueSpec);
          if (t.result === "error") return t.value.map((o => new qe(`${i.key}${o.key}`, i.value, o.message)));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new qe(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !$s(n)) return [new qe(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !$s(n)) return [new qe(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!Dl(n, ["zoom", "feature-state"])) return [new qe(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !Ll(n)) return [new qe(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function au(i) {
          const t = i.key,
            n = i.value,
            o = Fn(n);
          return o !== "string" ? [new qe(t, n, `color expected, ${o} found`)] : Ir.parse(String(n)) ? [] : [new qe(t, n, `color expected, "${n}" found`)]
        }

        function Js(i) {
          const t = i.key,
            n = i.value,
            o = i.valueSpec,
            u = [];
          return Array.isArray(o.values) ? o.values.indexOf(fi(n)) === -1 && u.push(new qe(t, n, `expected one of [${o.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(o.values).indexOf(fi(n)) === -1 && u.push(new qe(t, n, `expected one of [${Object.keys(o.values).join(", ")}], ${JSON.stringify(n)} found`)), u
        }

        function ou(i) {
          return ql(co(i.value)) ? Ts(bt({}, i, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : su(i)
        }

        function su(i) {
          const t = i.value,
            n = i.key;
          if (Fn(t) !== "array") return [new qe(n, t, `array expected, ${Fn(t)} found`)];
          const o = i.styleSpec;
          let u, _ = [];
          if (t.length < 1) return [new qe(n, t, "filter array must have at least 1 element")];
          switch (_ = _.concat(Js({
              key: `${n}[0]`,
              value: t[0],
              valueSpec: o.filter_operator,
              style: i.style,
              styleSpec: i.styleSpec
            })), fi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && fi(t[1]) === "$type" && _.push(new qe(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && _.push(new qe(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (u = Fn(t[1]), u !== "string" && _.push(new qe(`${n}[1]`, t[1], `string expected, ${u} found`)));
              for (let m = 2; m < t.length; m++) u = Fn(t[m]), fi(t[1]) === "$type" ? _ = _.concat(Js({
                key: `${n}[${m}]`,
                value: t[m],
                valueSpec: o.geometry_type,
                style: i.style,
                styleSpec: i.styleSpec
              })) : u !== "string" && u !== "number" && u !== "boolean" && _.push(new qe(`${n}[${m}]`, t[m], `string, number, or boolean expected, ${u} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let m = 1; m < t.length; m++) _ = _.concat(su({
                key: `${n}[${m}]`,
                value: t[m],
                style: i.style,
                styleSpec: i.styleSpec
              }));
              break;
            case "has":
            case "!has":
              u = Fn(t[1]), t.length !== 2 ? _.push(new qe(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : u !== "string" && _.push(new qe(`${n}[1]`, t[1], `string expected, ${u} found`))
          }
          return _
        }

        function lu(i, t) {
          const n = i.key,
            o = i.validateSpec,
            u = i.style,
            _ = i.styleSpec,
            m = i.value,
            y = i.objectKey,
            b = _[`${t}_${i.layerType}`];
          if (!b) return [];
          const P = y.match(/^(.*)-transition$/);
          if (t === "paint" && P && b[P[1]] && b[P[1]].transition) return o({
            key: n,
            value: m,
            valueSpec: _.transition,
            style: u,
            styleSpec: _
          });
          const I = i.valueSpec || b[y];
          if (!I) return [new qe(n, m, `unknown property "${y}"`)];
          let L;
          if (Fn(m) === "string" && ws(I) && !I.tokens && (L = /^{([^}]+)}$/.exec(m))) return [new qe(n, m, `"${y}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(L[1])} }\`.`)];
          const B = [];
          return i.layerType === "symbol" && y === "text-font" && Rl(co(m)) && fi(m.type) === "identity" && B.push(new qe(n, m, '"text-font" does not support identity functions')), B.concat(o({
            key: i.key,
            value: m,
            valueSpec: I,
            style: u,
            styleSpec: _,
            expressionContext: "property",
            propertyType: t,
            propertyKey: y
          }))
        }

        function Qs(i) {
          return lu(i, "paint")
        }

        function ad(i) {
          return lu(i, "layout")
        }

        function cu(i) {
          let t = [];
          const n = i.value,
            o = i.key,
            u = i.style,
            _ = i.styleSpec;
          if (Fn(n) !== "object") return [new qe(o, n, `object expected, ${Fn(n)} found`)];
          n.type || n.ref || t.push(new qe(o, n, 'either "type" or "ref" is required'));
          let m = fi(n.type);
          const y = fi(n.ref);
          if (n.id) {
            const b = fi(n.id);
            for (let P = 0; P < i.arrayIndex; P++) {
              const I = u.layers[P];
              fi(I.id) === b && t.push(new qe(o, n.id, `duplicate layer id "${n.id}", previously used at line ${I.id.__line__}`))
            }
          }
          if ("ref" in n) {
            let b;
            ["type", "source", "source-layer", "filter", "layout"].forEach((P => {
              P in n && t.push(new qe(o, n[P], `"${P}" is prohibited for ref layers`))
            })), u.layers.forEach((P => {
              fi(P.id) === y && (b = P)
            })), b ? b.ref ? t.push(new qe(o, n.ref, "ref cannot reference another ref layer")) : m = fi(b.type) : t.push(new qe(o, n.ref, `ref layer "${y}" not found`))
          } else if (m !== "background")
            if (n.source) {
              const b = u.sources && u.sources[n.source],
                P = b && fi(b.type);
              b ? P === "vector" && m === "raster" ? t.push(new qe(o, n.source, `layer "${n.id}" requires a raster source`)) : P !== "raster-dem" && m === "hillshade" || P !== "raster-dem" && m === "color-relief" ? t.push(new qe(o, n.source, `layer "${n.id}" requires a raster-dem source`)) : P === "raster" && m !== "raster" ? t.push(new qe(o, n.source, `layer "${n.id}" requires a vector source`)) : P !== "vector" || n["source-layer"] ? P === "raster-dem" && m !== "hillshade" && m !== "color-relief" ? t.push(new qe(o, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : m !== "line" || !n.paint || !n.paint["line-gradient"] || P === "geojson" && b.lineMetrics || t.push(new qe(o, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new qe(o, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new qe(o, n.source, `source "${n.source}" not found`))
            } else t.push(new qe(o, n, 'missing required property "source"'));
          return t = t.concat(ma({
            key: o,
            value: n,
            valueSpec: _.layer,
            style: i.style,
            styleSpec: i.styleSpec,
            validateSpec: i.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => i.validateSpec({
                key: `${o}.type`,
                value: n.type,
                valueSpec: _.layer.type,
                style: i.style,
                styleSpec: i.styleSpec,
                validateSpec: i.validateSpec,
                object: n,
                objectKey: "type"
              }),
              filter: ou,
              layout: b => ma({
                layer: n,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": P => ad(bt({
                    layerType: m
                  }, P))
                }
              }),
              paint: b => ma({
                layer: n,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": P => Qs(bt({
                    layerType: m
                  }, P))
                }
              })
            }
          })), t
        }

        function Mo(i) {
          const t = i.value,
            n = i.key,
            o = Fn(t);
          return o !== "string" ? [new qe(n, t, `string expected, ${o} found`)] : []
        }
        const od = {
          promoteId: function({
            key: i,
            value: t
          }) {
            if (Fn(t) === "string") return Mo({
              key: i,
              value: t
            });
            {
              const n = [];
              for (const o in t) n.push(...Mo({
                key: `${i}.${o}`,
                value: t[o]
              }));
              return n
            }
          }
        };

        function uu(i) {
          const t = i.value,
            n = i.key,
            o = i.styleSpec,
            u = i.style,
            _ = i.validateSpec;
          if (!t.type) return [new qe(n, t, '"type" is required')];
          const m = fi(t.type);
          let y;
          switch (m) {
            case "vector":
            case "raster":
              return y = ma({
                key: n,
                value: t,
                valueSpec: o[`source_${m.replace("-","_")}`],
                style: i.style,
                styleSpec: o,
                objectElementValidators: od,
                validateSpec: _
              }), y;
            case "raster-dem":
              return y = (function(b) {
                var P;
                const I = (P = b.sourceName) !== null && P !== void 0 ? P : "",
                  L = b.value,
                  B = b.styleSpec,
                  U = B.source_raster_dem,
                  G = b.style;
                let K = [];
                const ne = Fn(L);
                if (L === void 0) return K;
                if (ne !== "object") return K.push(new qe("source_raster_dem", L, `object expected, ${ne} found`)), K;
                const pe = fi(L.encoding) === "custom",
                  Ze = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  ye = b.value.encoding ? `"${b.value.encoding}"` : "Default";
                for (const ze in L) !pe && Ze.includes(ze) ? K.push(new qe(ze, L[ze], `In "${I}": "${ze}" is only valid when "encoding" is set to "custom". ${ye} encoding found`)) : U[ze] ? K = K.concat(b.validateSpec({
                  key: ze,
                  value: L[ze],
                  valueSpec: U[ze],
                  validateSpec: b.validateSpec,
                  style: G,
                  styleSpec: B
                })) : K.push(new qe(ze, L[ze], `unknown property "${ze}"`));
                return K
              })({
                sourceName: n,
                value: t,
                style: i.style,
                styleSpec: o,
                validateSpec: _
              }), y;
            case "geojson":
              if (y = ma({
                  key: n,
                  value: t,
                  valueSpec: o.source_geojson,
                  style: u,
                  styleSpec: o,
                  validateSpec: _,
                  objectElementValidators: od
                }), t.cluster)
                for (const b in t.clusterProperties) {
                  const [P, I] = t.clusterProperties[b], L = typeof P == "string" ? [P, ["accumulated"],
                    ["get", b]
                  ] : P;
                  y.push(...Ts({
                    key: `${n}.${b}.map`,
                    value: I,
                    expressionContext: "cluster-map"
                  })), y.push(...Ts({
                    key: `${n}.${b}.reduce`,
                    value: L,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return y;
            case "video":
              return ma({
                key: n,
                value: t,
                valueSpec: o.source_video,
                style: u,
                validateSpec: _,
                styleSpec: o
              });
            case "image":
              return ma({
                key: n,
                value: t,
                valueSpec: o.source_image,
                style: u,
                validateSpec: _,
                styleSpec: o
              });
            case "canvas":
              return [new qe(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Js({
                key: `${n}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function hu(i) {
          const t = i.value,
            n = i.styleSpec,
            o = n.light,
            u = i.style;
          let _ = [];
          const m = Fn(t);
          if (t === void 0) return _;
          if (m !== "object") return _ = _.concat([new qe("light", t, `object expected, ${m} found`)]), _;
          for (const y in t) {
            const b = y.match(/^(.*)-transition$/);
            _ = _.concat(b && o[b[1]] && o[b[1]].transition ? i.validateSpec({
              key: y,
              value: t[y],
              valueSpec: n.transition,
              validateSpec: i.validateSpec,
              style: u,
              styleSpec: n
            }) : o[y] ? i.validateSpec({
              key: y,
              value: t[y],
              valueSpec: o[y],
              validateSpec: i.validateSpec,
              style: u,
              styleSpec: n
            }) : [new qe(y, t[y], `unknown property "${y}"`)])
          }
          return _
        }

        function Ss(i) {
          const t = i.value,
            n = i.styleSpec,
            o = n.sky,
            u = i.style,
            _ = Fn(t);
          if (t === void 0) return [];
          if (_ !== "object") return [new qe("sky", t, `object expected, ${_} found`)];
          let m = [];
          for (const y in t) m = m.concat(o[y] ? i.validateSpec({
            key: y,
            value: t[y],
            valueSpec: o[y],
            style: u,
            styleSpec: n
          }) : [new qe(y, t[y], `unknown property "${y}"`)]);
          return m
        }

        function sd(i) {
          const t = i.value,
            n = i.styleSpec,
            o = n.terrain,
            u = i.style;
          let _ = [];
          const m = Fn(t);
          if (t === void 0) return _;
          if (m !== "object") return _ = _.concat([new qe("terrain", t, `object expected, ${m} found`)]), _;
          for (const y in t) _ = _.concat(o[y] ? i.validateSpec({
            key: y,
            value: t[y],
            valueSpec: o[y],
            validateSpec: i.validateSpec,
            style: u,
            styleSpec: n
          }) : [new qe(y, t[y], `unknown property "${y}"`)]);
          return _
        }

        function ld(i) {
          let t = [];
          const n = i.value,
            o = i.key;
          if (Array.isArray(n)) {
            const u = [],
              _ = [];
            for (const m in n) n[m].id && u.includes(n[m].id) && t.push(new qe(o, n, `all the sprites' ids must be unique, but ${n[m].id} is duplicated`)), u.push(n[m].id), n[m].url && _.includes(n[m].url) && t.push(new qe(o, n, `all the sprites' URLs must be unique, but ${n[m].url} is duplicated`)), _.push(n[m].url), t = t.concat(ma({
              key: `${o}[${m}]`,
              value: n[m],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: i.validateSpec
            }));
            return t
          }
          return Mo({
            key: o,
            value: n
          })
        }

        function cd(i) {
          return t = i.value, t && t.constructor === Object ? [] : [new qe(i.key, i.value, `object expected, ${Fn(i.value)} found`)];
          var t
        }
        const ud = {
          "*": () => [],
          array: ks,
          boolean: function(i) {
            const t = i.value,
              n = i.key,
              o = Fn(t);
            return o !== "boolean" ? [new qe(n, t, `boolean expected, ${o} found`)] : []
          },
          number: Zl,
          color: au,
          constants: Ul,
          enum: Js,
          filter: ou,
          function: id,
          layer: cu,
          object: ma,
          source: uu,
          light: hu,
          sky: Ss,
          terrain: sd,
          projection: function(i) {
            const t = i.value,
              n = i.styleSpec,
              o = n.projection,
              u = i.style,
              _ = Fn(t);
            if (t === void 0) return [];
            if (_ !== "object") return [new qe("projection", t, `object expected, ${_} found`)];
            let m = [];
            for (const y in t) m = m.concat(o[y] ? i.validateSpec({
              key: y,
              value: t[y],
              valueSpec: o[y],
              style: u,
              styleSpec: n
            }) : [new qe(y, t[y], `unknown property "${y}"`)]);
            return m
          },
          projectionDefinition: function(i) {
            const t = i.key;
            let n = i.value;
            n = n instanceof String ? n.valueOf() : n;
            const o = Fn(n);
            return o !== "array" || (function(u) {
              return Array.isArray(u) && u.length === 3 && typeof u[0] == "string" && typeof u[1] == "string" && typeof u[2] == "number"
            })(n) || (function(u) {
              return !!["interpolate", "step", "literal"].includes(u[0])
            })(n) ? ["array", "string"].includes(o) ? [] : [new qe(t, n, `projection expected, invalid type "${o}" found`)] : [new qe(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)]
          },
          string: Mo,
          formatted: function(i) {
            return Mo(i).length === 0 ? [] : Ts(i)
          },
          resolvedImage: function(i) {
            return Mo(i).length === 0 ? [] : Ts(i)
          },
          padding: function(i) {
            const t = i.key,
              n = i.value;
            if (Fn(n) === "array") {
              if (n.length < 1 || n.length > 4) return [new qe(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
              const o = {
                type: "number"
              };
              let u = [];
              for (let _ = 0; _ < n.length; _++) u = u.concat(i.validateSpec({
                key: `${t}[${_}]`,
                value: n[_],
                validateSpec: i.validateSpec,
                valueSpec: o
              }));
              return u
            }
            return Zl({
              key: t,
              value: n,
              valueSpec: {}
            })
          },
          numberArray: function(i) {
            const t = i.key,
              n = i.value;
            if (Fn(n) === "array") {
              const o = {
                type: "number"
              };
              if (n.length < 1) return [new qe(t, n, "array length at least 1 expected, length 0 found")];
              let u = [];
              for (let _ = 0; _ < n.length; _++) u = u.concat(i.validateSpec({
                key: `${t}[${_}]`,
                value: n[_],
                validateSpec: i.validateSpec,
                valueSpec: o
              }));
              return u
            }
            return Zl({
              key: t,
              value: n,
              valueSpec: {}
            })
          },
          colorArray: function(i) {
            const t = i.key,
              n = i.value;
            if (Fn(n) === "array") {
              if (n.length < 1) return [new qe(t, n, "array length at least 1 expected, length 0 found")];
              let o = [];
              for (let u = 0; u < n.length; u++) o = o.concat(au({
                key: `${t}[${u}]`,
                value: n[u]
              }));
              return o
            }
            return au({
              key: t,
              value: n
            })
          },
          variableAnchorOffsetCollection: function(i) {
            const t = i.key,
              n = i.value,
              o = Fn(n),
              u = i.styleSpec;
            if (o !== "array" || n.length < 1 || n.length % 2 != 0) return [new qe(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let _ = [];
            for (let m = 0; m < n.length; m += 2) _ = _.concat(Js({
              key: `${t}[${m}]`,
              value: n[m],
              valueSpec: u.layout_symbol["text-anchor"]
            })), _ = _.concat(ks({
              key: `${t}[${m+1}]`,
              value: n[m + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: u
            }));
            return _
          },
          sprite: ld,
          state: cd
        };

        function Gl(i) {
          const t = i.value,
            n = i.valueSpec,
            o = i.styleSpec;
          return i.validateSpec = Gl, n.expression && Rl(fi(t)) ? id(i) : n.expression && jl(co(t)) ? Ts(i) : n.type && ud[n.type] ? ud[n.type](i) : ma(bt({}, i, {
            valueSpec: n.type ? o[n.type] : n
          }))
        }

        function hd(i) {
          const t = i.value,
            n = i.key,
            o = Mo(i);
          return o.length || (t.indexOf("{fontstack}") === -1 && o.push(new qe(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && o.push(new qe(n, t, '"glyphs" url must include a "{range}" token'))), o
        }

        function aa(i, t = J) {
          let n = [];
          return n = n.concat(Gl({
            key: "",
            value: i,
            valueSpec: t.$root,
            styleSpec: t,
            style: i,
            validateSpec: Gl,
            objectElementValidators: {
              glyphs: hd,
              "*": () => []
            }
          })), i.constants && (n = n.concat(Ul({
            key: "constants",
            value: i.constants
          }))), ga(n)
        }

        function ca(i) {
          return function(t) {
            return i(Object.assign({}, t, {
              validateSpec: Gl
            }))
          }
        }

        function ga(i) {
          return [].concat(i).sort(((t, n) => t.line - n.line))
        }

        function ua(i) {
          return function(...t) {
            return ga(i.apply(this, t))
          }
        }
        aa.source = ua(ca(uu)), aa.sprite = ua(ca(ld)), aa.glyphs = ua(ca(hd)), aa.light = ua(ca(hu)), aa.sky = ua(ca(Ss)), aa.terrain = ua(ca(sd)), aa.state = ua(ca(cd)), aa.layer = ua(ca(cu)), aa.filter = ua(ca(ou)), aa.paintProperty = ua(ca(Qs)), aa.layoutProperty = ua(ca(ad));
        const dd = J,
          Ps = aa,
          Qp = Ps.light,
          el = Ps.sky,
          pd = Ps.paintProperty,
          du = Ps.layoutProperty;

        function fd(i, t) {
          let n = !1;
          if (t && t.length)
            for (const o of t) i.fire(new Be(new Error(o.message))), n = !0;
          return n
        }
        class $o {
          constructor(t, n, o) {
            const u = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const m = new Int32Array(this.arrayBuffer);
              t = m[0], this.d = (n = m[1]) + 2 * (o = m[2]);
              for (let b = 0; b < this.d * this.d; b++) {
                const P = m[3 + b],
                  I = m[3 + b + 1];
                u.push(P === I ? null : m.subarray(P, I))
              }
              const y = m[3 + u.length + 1];
              this.keys = m.subarray(m[3 + u.length], y), this.bboxes = m.subarray(y), this.insert = this._insertReadonly
            } else {
              this.d = n + 2 * o;
              for (let m = 0; m < this.d * this.d; m++) u.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = n, this.extent = t, this.padding = o, this.scale = n / t, this.uid = 0;
            const _ = o / n * t;
            this.min = -_, this.max = t + _
          }
          insert(t, n, o, u, _) {
            this._forEachCell(n, o, u, _, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(_)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, n, o, u, _, m) {
            this.cells[_].push(m)
          }
          query(t, n, o, u, _) {
            const m = this.min,
              y = this.max;
            if (t <= m && n <= m && y <= o && y <= u && !_) return Array.prototype.slice.call(this.keys);
            {
              const b = [];
              return this._forEachCell(t, n, o, u, this._queryCell, b, {}, _), b
            }
          }
          _queryCell(t, n, o, u, _, m, y, b) {
            const P = this.cells[_];
            if (P !== null) {
              const I = this.keys,
                L = this.bboxes;
              for (let B = 0; B < P.length; B++) {
                const U = P[B];
                if (y[U] === void 0) {
                  const G = 4 * U;
                  (b ? b(L[G + 0], L[G + 1], L[G + 2], L[G + 3]) : t <= L[G + 2] && n <= L[G + 3] && o >= L[G + 0] && u >= L[G + 1]) ? (y[U] = !0, m.push(I[U])) : y[U] = !1
                }
              }
            }
          }
          _forEachCell(t, n, o, u, _, m, y, b) {
            const P = this._convertToCellCoord(t),
              I = this._convertToCellCoord(n),
              L = this._convertToCellCoord(o),
              B = this._convertToCellCoord(u);
            for (let U = P; U <= L; U++)
              for (let G = I; G <= B; G++) {
                const K = this.d * G + U;
                if ((!b || b(this._convertFromCellCoord(U), this._convertFromCellCoord(G), this._convertFromCellCoord(U + 1), this._convertFromCellCoord(G + 1))) && _.call(this, t, n, o, u, K, m, y, b)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              n = 3 + this.cells.length + 1 + 1;
            let o = 0;
            for (let m = 0; m < this.cells.length; m++) o += this.cells[m].length;
            const u = new Int32Array(n + o + this.keys.length + this.bboxes.length);
            u[0] = this.extent, u[1] = this.n, u[2] = this.padding;
            let _ = n;
            for (let m = 0; m < t.length; m++) {
              const y = t[m];
              u[3 + m] = _, u.set(y, _), _ += y.length
            }
            return u[3 + t.length] = _, u.set(this.keys, _), _ += this.keys.length, u[3 + t.length + 1] = _, u.set(this.bboxes, _), _ += this.bboxes.length, u.buffer
          }
          static serialize(t, n) {
            const o = t.toArrayBuffer();
            return n && n.push(o), {
              buffer: o
            }
          }
          static deserialize(t) {
            return new $o(t.buffer)
          }
        }
        const uo = {};

        function Mr(i, t, n = {}) {
          if (uo[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: i,
            writeable: !1
          }), uo[i] = {
            klass: t,
            omit: n.omit || [],
            shallow: n.shallow || []
          }
        }
        Mr("Object", Object), Mr("Set", Set), Mr("TransferableGridIndex", $o), Mr("Color", Ir), Mr("Error", Error), Mr("AJAXError", re), Mr("ResolvedImage", ii), Mr("StylePropertyFunction", Fl), Mr("StyleExpression", tu, {
          omit: ["_evaluator"]
        }), Mr("ZoomDependentExpression", ru), Mr("ZoomConstantExpression", Xs), Mr("CompoundExpression", Da, {
          omit: ["_evaluate"]
        });
        for (const i in bs) bs[i]._classRegistryKey || Mr(`Expression_${i}`, bs[i]);

        function _d(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
        }

        function pu(i) {
          return i.$name || i.constructor._classRegistryKey
        }

        function md(i) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const n = pu(t);
            return !(!n || n === "Object")
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || _d(i) || ht(i) || ArrayBuffer.isView(i) || i instanceof ImageData)
        }

        function ho(i, t) {
          if (md(i)) return (_d(i) || ht(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const _ = [];
            for (const m of i) _.push(ho(m, t));
            return _
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const n = pu(i);
          if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!uo[n]) throw new Error(`${n} is not registered.`);
          const {
            klass: o
          } = uo[n], u = o.serialize ? o.serialize(i, t) : {};
          if (o.serialize) {
            if (t && u === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const _ in i) {
              if (!i.hasOwnProperty(_) || uo[n].omit.indexOf(_) >= 0) continue;
              const m = i[_];
              u[_] = uo[n].shallow.indexOf(_) >= 0 ? m : ho(m, t)
            }
            i instanceof Error && (u.message = i.message)
          }
          if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (u.$name = n), u
        }

        function tl(i) {
          if (md(i)) return i;
          if (Array.isArray(i)) return i.map(tl);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const t = pu(i) || "Object";
          if (!uo[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: n
          } = uo[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(i);
          const o = Object.create(n.prototype);
          for (const u of Object.keys(i)) {
            if (u === "$name") continue;
            const _ = i[u];
            o[u] = uo[t].shallow.indexOf(u) >= 0 ? _ : tl(_)
          }
          return o
        }
        class fu {
          constructor() {
            this.first = !0
          }
          update(t, n) {
            const o = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = o, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = o, !0) : (this.lastFloorZoom > o ? (this.lastIntegerZoom = o + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < o && (this.lastIntegerZoom = o, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = o, !0))
          }
        }
        const jn = {
          "Latin-1 Supplement": i => i >= 128 && i <= 255,
          "Hangul Jamo": i => i >= 4352 && i <= 4607,
          Khmer: i => i >= 6016 && i <= 6143,
          "General Punctuation": i => i >= 8192 && i <= 8303,
          "Letterlike Symbols": i => i >= 8448 && i <= 8527,
          "Number Forms": i => i >= 8528 && i <= 8591,
          "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
          "Control Pictures": i => i >= 9216 && i <= 9279,
          "Optical Character Recognition": i => i >= 9280 && i <= 9311,
          "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
          "Geometric Shapes": i => i >= 9632 && i <= 9727,
          "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
          "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
          "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
          "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
          Hiragana: i => i >= 12352 && i <= 12447,
          Katakana: i => i >= 12448 && i <= 12543,
          Kanbun: i => i >= 12688 && i <= 12703,
          "CJK Strokes": i => i >= 12736 && i <= 12783,
          "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
          "CJK Compatibility": i => i >= 13056 && i <= 13311,
          "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
          "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
          "Hangul Syllables": i => i >= 44032 && i <= 55215,
          "Private Use Area": i => i >= 57344 && i <= 63743,
          "Vertical Forms": i => i >= 65040 && i <= 65055,
          "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
          "Small Form Variants": i => i >= 65104 && i <= 65135,
          "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
        };

        function _u(i) {
          for (const t of i)
            if (Wl(t.charCodeAt(0))) return !0;
          return !1
        }

        function mu(i) {
          for (const t of i)
            if (!vd(t.charCodeAt(0))) return !1;
          return !0
        }

        function Ms(i) {
          const t = i.map((n => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source
            } catch {
              return null
            }
          })).filter((n => n));
          return new RegExp(t.join("|"), "u")
        }
        const gd = Ms(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function vd(i) {
          return !gd.test(String.fromCodePoint(i))
        }
        const gu = Ms(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function Wl(i) {
          return !(i !== 746 && i !== 747 && (i < 4352 || !(jn["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || jn["CJK Compatibility"](i) || jn["CJK Strokes"](i) || !(!jn["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || jn["Enclosed CJK Letters and Months"](i) || jn["Ideographic Description Characters"](i) || jn.Kanbun(i) || jn.Katakana(i) && i !== 12540 || !(!jn["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!jn["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || jn["Vertical Forms"](i) || jn["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || gu.test(String.fromCodePoint(i)))))
        }

        function Hl(i) {
          return !(Wl(i) || (function(t) {
            return !!(jn["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || jn["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || jn["Letterlike Symbols"](t) || jn["Number Forms"](t) || jn["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || jn["Control Pictures"](t) && t !== 9251 || jn["Optical Character Recognition"](t) || jn["Enclosed Alphanumerics"](t) || jn["Geometric Shapes"](t) || jn["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || jn["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || jn["CJK Symbols and Punctuation"](t) || jn.Katakana(t) || jn["Private Use Area"](t) || jn["CJK Compatibility Forms"](t) || jn["Small Form Variants"](t) || jn["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(i))
        }
        const yd = Ms(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function bd(i) {
          return yd.test(String.fromCodePoint(i))
        }

        function xd(i, t) {
          return !(!t && bd(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || jn.Khmer(i))
        }

        function ef(i) {
          for (const t of i)
            if (bd(t.charCodeAt(0))) return !0;
          return !1
        }
        const po = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(i) {
            if (po.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(i, t) {
            return l(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const n = i.pluginURL,
                o = new Promise((_ => {
                  this.loadScriptResolve = _
                }));
              t(n);
              const u = new Promise((_ => setTimeout((() => _()), this.TIMEOUT)));
              if (yield Promise.race([o, u]), this.isParsed()) {
                const _ = {
                  pluginStatus: "loaded",
                  pluginURL: n
                };
                return this.setState(_), _
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${n}`)
            }))
          }
        };
        class ei {
          constructor(t, n) {
            this.isSupportedScript = wd, this.zoom = t, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new fu, this.transition = n.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new fu, this.transition = {})
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              n = t - Math.floor(t),
              o = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: n + (1 - n) * o
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - o) * n
            }
          }
        }

        function wd(i) {
          return (function(t, n) {
            for (const o of t)
              if (!xd(o.charCodeAt(0), n)) return !1;
            return !0
          })(i, po.getRTLTextPluginStatus() === "loaded")
        }
        class rl {
          constructor(t, n, o) {
            this.property = t, this.value = n, this.expression = (function(u, _, m) {
              if (Rl(u)) return new Fl(u, _);
              if (jl(u)) {
                const y = Qh(u, _, m);
                if (y.result === "error") throw new Error(y.value.map((b => `${b.key}: ${b.message}`)).join(", "));
                return y.value
              } {
                let y = u;
                return _.type === "color" && typeof u == "string" ? y = Ir.parse(u) : _.type !== "padding" || typeof u != "number" && !Array.isArray(u) ? _.type !== "numberArray" || typeof u != "number" && !Array.isArray(u) ? _.type !== "colorArray" || typeof u != "string" && !Array.isArray(u) ? _.type === "variableAnchorOffsetCollection" && Array.isArray(u) ? y = Wn.parse(u) : _.type === "projectionDefinition" && typeof u == "string" && (y = li.parse(u)) : y = fn.parse(u) : y = Mn.parse(u) : y = Pn.parse(u), {
                  globalStateRefs: new Set,
                  _globalState: null,
                  kind: "constant",
                  evaluate: () => y
                }
              }
            })(n === void 0 ? t.specification.default : n, t.specification, o)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, n, o) {
            return this.property.possiblyEvaluate(this, t, n, o)
          }
        }
        class vu {
          constructor(t, n) {
            this.property = t, this.value = new rl(t, void 0, n)
          }
          transitioned(t, n) {
            return new yu(this.property, this.value, n, ot({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new yu(this.property, this.value, null, {}, 0)
          }
        }
        class kd {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = n
          }
          getValue(t) {
            return Ot(this._values[t].value.value)
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new vu(this._values[t].property, this._globalState)), this._values[t].value = new rl(this._values[t].property, n === null ? void 0 : Ot(n), this._globalState)
          }
          getTransition(t) {
            return Ot(this._values[t].transition)
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new vu(this._values[t].property, this._globalState)), this._values[t].transition = Ot(n) || void 0
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const o = this.getValue(n);
              o !== void 0 && (t[n] = o);
              const u = this.getTransition(n);
              u !== void 0 && (t[`${n}-transition`] = u)
            }
            return t
          }
          transitioned(t, n) {
            const o = new bu(this._properties);
            for (const u of Object.keys(this._values)) o._values[u] = this._values[u].transitioned(t, n._values[u]);
            return o
          }
          untransitioned() {
            const t = new bu(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t
          }
        }
        class yu {
          constructor(t, n, o, u, _) {
            this.property = t, this.value = n, this.begin = _ + u.delay || 0, this.end = this.begin + u.duration || 0, t.specification.transition && (u.delay || u.duration) && (this.prior = o)
          }
          possiblyEvaluate(t, n, o) {
            const u = t.now || 0,
              _ = this.value.possiblyEvaluate(t, n, o),
              m = this.prior;
            if (m) {
              if (u > this.end) return this.prior = null, _;
              if (this.value.isDataDriven()) return this.prior = null, _;
              if (u < this.begin) return m.possiblyEvaluate(t, n, o);
              {
                const y = (u - this.begin) / (this.end - this.begin);
                return this.property.interpolate(m.possiblyEvaluate(t, n, o), _, jt(y))
              }
            }
            return _
          }
        }
        class bu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, n, o) {
            const u = new Xo(this._properties);
            for (const _ of Object.keys(this._values)) u._values[_] = this._values[_].possiblyEvaluate(t, n, o);
            return u
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class Td {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = n
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return Ot(this._values[t].value)
          }
          setValue(t, n) {
            this._values[t] = new rl(this._values[t].property, n === null ? void 0 : Ot(n), this._globalState)
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const o = this.getValue(n);
              o !== void 0 && (t[n] = o)
            }
            return t
          }
          possiblyEvaluate(t, n, o) {
            const u = new Xo(this._properties);
            for (const _ of Object.keys(this._values)) u._values[_] = this._values[_].possiblyEvaluate(t, n, o);
            return u
          }
        }
        class Za {
          constructor(t, n, o) {
            this.property = t, this.value = n, this.parameters = o
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, n, o, u) {
            return this.property.evaluate(this.value, this.parameters, t, n, o, u)
          }
        }
        class Xo {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class Xr {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n)
          }
          interpolate(t, n, o) {
            const u = La[this.specification.type];
            return u ? u(t, n, o) : t
          }
        }
        class ln {
          constructor(t, n) {
            this.specification = t, this.overrides = n
          }
          possiblyEvaluate(t, n, o, u) {
            return new Za(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(n, null, {}, o, u)
            } : t.expression, n)
          }
          interpolate(t, n, o) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new Za(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const u = La[this.specification.type];
            if (u) {
              const _ = u(t.value.value, n.value.value, o);
              return new Za(this, {
                kind: "constant",
                value: _
              }, t.parameters)
            }
            return t
          }
          evaluate(t, n, o, u, _, m) {
            return t.kind === "constant" ? t.value : t.evaluate(n, o, u, _, m)
          }
        }
        class nl extends ln {
          possiblyEvaluate(t, n, o, u) {
            if (t.value === void 0) return new Za(this, {
              kind: "constant",
              value: void 0
            }, n);
            if (t.expression.kind === "constant") {
              const _ = t.expression.evaluate(n, null, {}, o, u),
                m = t.property.specification.type === "resolvedImage" && typeof _ != "string" ? _.name : _,
                y = this._calculate(m, m, m, n);
              return new Za(this, {
                kind: "constant",
                value: y
              }, n)
            }
            if (t.expression.kind === "camera") {
              const _ = this._calculate(t.expression.evaluate({
                zoom: n.zoom - 1
              }), t.expression.evaluate({
                zoom: n.zoom
              }), t.expression.evaluate({
                zoom: n.zoom + 1
              }), n);
              return new Za(this, {
                kind: "constant",
                value: _
              }, n)
            }
            return new Za(this, t.expression, n)
          }
          evaluate(t, n, o, u, _, m) {
            if (t.kind === "source") {
              const y = t.evaluate(n, o, u, _, m);
              return this._calculate(y, y, y, n)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(n.zoom) - 1
            }, o, u), t.evaluate({
              zoom: Math.floor(n.zoom)
            }, o, u), t.evaluate({
              zoom: Math.floor(n.zoom) + 1
            }, o, u), n) : t.value
          }
          _calculate(t, n, o, u) {
            return u.zoom > u.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: n
            } : {
              from: o,
              to: n
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Sd {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, n, o, u) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const _ = t.expression.evaluate(n, null, {}, o, u);
                return this._calculate(_, _, _, n)
              }
              return this._calculate(t.expression.evaluate(new ei(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new ei(Math.floor(n.zoom), n)), t.expression.evaluate(new ei(Math.floor(n.zoom + 1), n)), n)
            }
          }
          _calculate(t, n, o, u) {
            return u.zoom > u.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: n
            } : {
              from: o,
              to: n
            }
          }
          interpolate(t) {
            return t
          }
        }
        class il {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, n, o, u) {
            return !!t.expression.evaluate(n, null, {}, o, u)
          }
          interpolate() {
            return !1
          }
        }
        class oa {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const o = t[n];
              o.specification.overridable && this.overridableProperties.push(n);
              const u = this.defaultPropertyValues[n] = new rl(o, void 0, void 0),
                _ = this.defaultTransitionablePropertyValues[n] = new vu(o, void 0);
              this.defaultTransitioningPropertyValues[n] = _.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = u.possiblyEvaluate({})
            }
          }
        }
        Mr("DataDrivenProperty", ln), Mr("DataConstantProperty", Xr), Mr("CrossFadedDataDrivenProperty", nl), Mr("CrossFadedProperty", Sd), Mr("ColorRampProperty", il);
        const xu = "-transition";
        class Ga extends ie {
          constructor(t, n, o) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = o, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Ys(t.filter, o)), n.layout && (this._unevaluatedLayout = new Td(n.layout, o)), n.paint)) {
              this._transitionablePaint = new kd(n.paint, o);
              for (const u in t.paint) this.setPaintProperty(u, t.paint[u], {
                validate: !1
              });
              for (const u in t.layout) this.setLayoutProperty(u, t.layout[u], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Xo(n.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Ys(t, this._globalState)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const n in this._unevaluatedLayout._values) {
                const o = this._unevaluatedLayout._values[n];
                for (const u of o.getGlobalStateRefs()) t.add(u)
              }
            for (const n of this._featureFilter.getGlobalStateRefs()) t.add(n);
            return t
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const n = new globalThis.Map;
            if (this._transitionablePaint)
              for (const o in this._transitionablePaint._values) {
                const u = this._transitionablePaint._values[o].value;
                for (const _ of u.getGlobalStateRefs()) {
                  const m = (t = n.get(_)) !== null && t !== void 0 ? t : [];
                  m.push({
                    name: o,
                    value: u.value
                  }), n.set(_, m)
                }
              }
            return n
          }
          setLayoutProperty(t, n, o = {}) {
            n != null && this._validate(du, `layers.${this.id}.layout.${t}`, t, n, o) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n)
          }
          getPaintProperty(t) {
            return t.endsWith(xu) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, n, o = {}) {
            if (n != null && this._validate(pd, `layers.${this.id}.paint.${t}`, t, n, o)) return !1;
            if (t.endsWith(xu)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1;
            {
              const u = this._transitionablePaint._values[t],
                _ = u.property.specification["property-type"] === "cross-faded-data-driven",
                m = u.value.isDataDriven(),
                y = u.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const b = this._transitionablePaint._values[t].value;
              return b.isDataDriven() || m || _ || this._handleOverridablePaintPropertyUpdate(t, y, b)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, n, o) {
            return !1
          }
          isHidden(t, n = !1) {
            return !!(this.minzoom && t < (n ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, n) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Qt(t, ((n, o) => !(n === void 0 || o === "layout" && !Object.keys(n).length || o === "paint" && !Object.keys(n).length)))
          }
          _validate(t, n, o, u, _ = {}) {
            return (!_ || _.validate !== !1) && fd(this, t.call(Ps, {
              key: n,
              layerType: this.type,
              objectKey: o,
              value: u,
              styleSpec: J,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof Za && ws(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0
            }
            return !1
          }
        }
        let Pd;
        var tf = {
          get paint() {
            return Pd = Pd || new oa({
              "raster-opacity": new Xr(J.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new Xr(J.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new Xr(J.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new Xr(J.paint_raster["raster-brightness-max"]),
              "raster-saturation": new Xr(J.paint_raster["raster-saturation"]),
              "raster-contrast": new Xr(J.paint_raster["raster-contrast"]),
              "raster-resampling": new Xr(J.paint_raster["raster-resampling"]),
              "raster-fade-duration": new Xr(J.paint_raster["raster-fade-duration"])
            })
          }
        };
        class rf extends Ga {
          constructor(t, n) {
            super(t, tf, n)
          }
        }
        const nf = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class no {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class _i {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function wi(i, t = 1) {
          let n = 0,
            o = 0;
          return {
            members: i.map((u => {
              const _ = nf[u.type].BYTES_PER_ELEMENT,
                m = n = Md(n, Math.max(t, _)),
                y = u.components || 1;
              return o = Math.max(o, _), n += _ * y, {
                name: u.name,
                type: u.type,
                components: y,
                offset: m
              }
            })),
            size: Md(n, Math.max(o, t)),
            alignment: t
          }
        }

        function Md(i, t) {
          return Math.ceil(i / t) * t
        }
        class Is extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, n)
          }
          emplace(t, n, o) {
            const u = 2 * t;
            return this.int16[u + 0] = n, this.int16[u + 1] = o, t
          }
        }
        Is.prototype.bytesPerElement = 4, Mr("StructArrayLayout2i4", Is);
        class $l extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.int16[_ + 0] = n, this.int16[_ + 1] = o, this.int16[_ + 2] = u, t
          }
        }
        $l.prototype.bytesPerElement = 6, Mr("StructArrayLayout3i6", $l);
        class wu extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, n, o, u)
          }
          emplace(t, n, o, u, _) {
            const m = 4 * t;
            return this.int16[m + 0] = n, this.int16[m + 1] = o, this.int16[m + 2] = u, this.int16[m + 3] = _, t
          }
        }
        wu.prototype.bytesPerElement = 8, Mr("StructArrayLayout4i8", wu);
        class fo extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 6 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = o, this.int16[b + 2] = u, this.int16[b + 3] = _, this.int16[b + 4] = m, this.int16[b + 5] = y, t
          }
        }
        fo.prototype.bytesPerElement = 12, Mr("StructArrayLayout2i4i12", fo);
        class Xl extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 4 * t,
              P = 8 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = o, this.uint8[P + 4] = u, this.uint8[P + 5] = _, this.uint8[P + 6] = m, this.uint8[P + 7] = y, t
          }
        }
        Xl.prototype.bytesPerElement = 8, Mr("StructArrayLayout2i4ub8", Xl);
        class Yo extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, n)
          }
          emplace(t, n, o) {
            const u = 2 * t;
            return this.float32[u + 0] = n, this.float32[u + 1] = o, t
          }
        }
        Yo.prototype.bytesPerElement = 8, Mr("StructArrayLayout2f8", Yo);
        class Yl extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, P, I) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, t, n, o, u, _, m, y, b, P, I)
          }
          emplace(t, n, o, u, _, m, y, b, P, I, L) {
            const B = 10 * t;
            return this.uint16[B + 0] = n, this.uint16[B + 1] = o, this.uint16[B + 2] = u, this.uint16[B + 3] = _, this.uint16[B + 4] = m, this.uint16[B + 5] = y, this.uint16[B + 6] = b, this.uint16[B + 7] = P, this.uint16[B + 8] = I, this.uint16[B + 9] = L, t
          }
        }
        Yl.prototype.bytesPerElement = 20, Mr("StructArrayLayout10ui20", Yl);
        class al extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b) {
            const P = this.length;
            return this.resize(P + 1), this.emplace(P, t, n, o, u, _, m, y, b)
          }
          emplace(t, n, o, u, _, m, y, b, P) {
            const I = 8 * t;
            return this.uint16[I + 0] = n, this.uint16[I + 1] = o, this.uint16[I + 2] = u, this.uint16[I + 3] = _, this.uint16[I + 4] = m, this.uint16[I + 5] = y, this.uint16[I + 6] = b, this.uint16[I + 7] = P, t
          }
        }
        al.prototype.bytesPerElement = 16, Mr("StructArrayLayout8ui16", al);
        class ku extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, P, I, L, B) {
            const U = this.length;
            return this.resize(U + 1), this.emplace(U, t, n, o, u, _, m, y, b, P, I, L, B)
          }
          emplace(t, n, o, u, _, m, y, b, P, I, L, B, U) {
            const G = 12 * t;
            return this.int16[G + 0] = n, this.int16[G + 1] = o, this.int16[G + 2] = u, this.int16[G + 3] = _, this.uint16[G + 4] = m, this.uint16[G + 5] = y, this.uint16[G + 6] = b, this.uint16[G + 7] = P, this.int16[G + 8] = I, this.int16[G + 9] = L, this.int16[G + 10] = B, this.int16[G + 11] = U, t
          }
        }
        ku.prototype.bytesPerElement = 24, Mr("StructArrayLayout4i4ui4i24", ku);
        class Cs extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.float32[_ + 0] = n, this.float32[_ + 1] = o, this.float32[_ + 2] = u, t
          }
        }
        Cs.prototype.bytesPerElement = 12, Mr("StructArrayLayout3f12", Cs);
        class Ko extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t)
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t
          }
        }
        Ko.prototype.bytesPerElement = 4, Mr("StructArrayLayout1ul4", Ko);
        class Tu extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, P) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, n, o, u, _, m, y, b, P)
          }
          emplace(t, n, o, u, _, m, y, b, P, I) {
            const L = 10 * t,
              B = 5 * t;
            return this.int16[L + 0] = n, this.int16[L + 1] = o, this.int16[L + 2] = u, this.int16[L + 3] = _, this.int16[L + 4] = m, this.int16[L + 5] = y, this.uint32[B + 3] = b, this.uint16[L + 8] = P, this.uint16[L + 9] = I, t
          }
        }
        Tu.prototype.bytesPerElement = 20, Mr("StructArrayLayout6i1ul2ui20", Tu);
        class Kl extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 6 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = o, this.int16[b + 2] = u, this.int16[b + 3] = _, this.int16[b + 4] = m, this.int16[b + 5] = y, t
          }
        }
        Kl.prototype.bytesPerElement = 12, Mr("StructArrayLayout2i2i2i12", Kl);
        class Jo extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, n, o, u, _)
          }
          emplace(t, n, o, u, _, m) {
            const y = 4 * t,
              b = 8 * t;
            return this.float32[y + 0] = n, this.float32[y + 1] = o, this.float32[y + 2] = u, this.int16[b + 6] = _, this.int16[b + 7] = m, t
          }
        }
        Jo.prototype.bytesPerElement = 16, Mr("StructArrayLayout2f1f2i16", Jo);
        class Su extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, o, u, _, m)
          }
          emplace(t, n, o, u, _, m, y) {
            const b = 16 * t,
              P = 4 * t,
              I = 8 * t;
            return this.uint8[b + 0] = n, this.uint8[b + 1] = o, this.float32[P + 1] = u, this.float32[P + 2] = _, this.int16[I + 6] = m, this.int16[I + 7] = y, t
          }
        }
        Su.prototype.bytesPerElement = 16, Mr("StructArrayLayout2ub2f2i16", Su);
        class Jl extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.uint16[_ + 0] = n, this.uint16[_ + 1] = o, this.uint16[_ + 2] = u, t
          }
        }
        Jl.prototype.bytesPerElement = 6, Mr("StructArrayLayout3ui6", Jl);
        class Ql extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, P, I, L, B, U, G, K, ne, pe) {
            const Ze = this.length;
            return this.resize(Ze + 1), this.emplace(Ze, t, n, o, u, _, m, y, b, P, I, L, B, U, G, K, ne, pe)
          }
          emplace(t, n, o, u, _, m, y, b, P, I, L, B, U, G, K, ne, pe, Ze) {
            const ye = 24 * t,
              ze = 12 * t,
              at = 48 * t;
            return this.int16[ye + 0] = n, this.int16[ye + 1] = o, this.uint16[ye + 2] = u, this.uint16[ye + 3] = _, this.uint32[ze + 2] = m, this.uint32[ze + 3] = y, this.uint32[ze + 4] = b, this.uint16[ye + 10] = P, this.uint16[ye + 11] = I, this.uint16[ye + 12] = L, this.float32[ze + 7] = B, this.float32[ze + 8] = U, this.uint8[at + 36] = G, this.uint8[at + 37] = K, this.uint8[at + 38] = ne, this.uint32[ze + 10] = pe, this.int16[ye + 22] = Ze, t
          }
        }
        Ql.prototype.bytesPerElement = 48, Mr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ql);
        class Pu extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u, _, m, y, b, P, I, L, B, U, G, K, ne, pe, Ze, ye, ze, at, gt, Ht, xr, dr, vr, en, gr) {
            const yr = this.length;
            return this.resize(yr + 1), this.emplace(yr, t, n, o, u, _, m, y, b, P, I, L, B, U, G, K, ne, pe, Ze, ye, ze, at, gt, Ht, xr, dr, vr, en, gr)
          }
          emplace(t, n, o, u, _, m, y, b, P, I, L, B, U, G, K, ne, pe, Ze, ye, ze, at, gt, Ht, xr, dr, vr, en, gr, yr) {
            const Lt = 32 * t,
              hn = 16 * t;
            return this.int16[Lt + 0] = n, this.int16[Lt + 1] = o, this.int16[Lt + 2] = u, this.int16[Lt + 3] = _, this.int16[Lt + 4] = m, this.int16[Lt + 5] = y, this.int16[Lt + 6] = b, this.int16[Lt + 7] = P, this.uint16[Lt + 8] = I, this.uint16[Lt + 9] = L, this.uint16[Lt + 10] = B, this.uint16[Lt + 11] = U, this.uint16[Lt + 12] = G, this.uint16[Lt + 13] = K, this.uint16[Lt + 14] = ne, this.uint16[Lt + 15] = pe, this.uint16[Lt + 16] = Ze, this.uint16[Lt + 17] = ye, this.uint16[Lt + 18] = ze, this.uint16[Lt + 19] = at, this.uint16[Lt + 20] = gt, this.uint16[Lt + 21] = Ht, this.uint16[Lt + 22] = xr, this.uint32[hn + 12] = dr, this.float32[hn + 13] = vr, this.float32[hn + 14] = en, this.uint16[Lt + 30] = gr, this.uint16[Lt + 31] = yr, t
          }
        }
        Pu.prototype.bytesPerElement = 64, Mr("StructArrayLayout8i15ui1ul2f2ui64", Pu);
        class d extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t)
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t
          }
        }
        d.prototype.bytesPerElement = 4, Mr("StructArrayLayout1f4", d);
        class e extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[_ + 1] = o, this.float32[_ + 2] = u, t
          }
        }
        e.prototype.bytesPerElement = 12, Mr("StructArrayLayout1ui2f12", e);
        class a extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n, o)
          }
          emplace(t, n, o, u) {
            const _ = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[_ + 2] = o, this.uint16[_ + 3] = u, t
          }
        }
        a.prototype.bytesPerElement = 8, Mr("StructArrayLayout1ul2ui8", a);
        class c extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, n) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, t, n)
          }
          emplace(t, n, o) {
            const u = 2 * t;
            return this.uint16[u + 0] = n, this.uint16[u + 1] = o, t
          }
        }
        c.prototype.bytesPerElement = 4, Mr("StructArrayLayout2ui4", c);
        class h extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t)
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t
          }
        }
        h.prototype.bytesPerElement = 2, Mr("StructArrayLayout1ui2", h);
        class f extends _i {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, n, o, u) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, n, o, u)
          }
          emplace(t, n, o, u, _) {
            const m = 4 * t;
            return this.float32[m + 0] = n, this.float32[m + 1] = o, this.float32[m + 2] = u, this.float32[m + 3] = _, t
          }
        }
        f.prototype.bytesPerElement = 16, Mr("StructArrayLayout4f16", f);
        class v extends no {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new F(this.anchorPointX, this.anchorPointY)
          }
        }
        v.prototype.size = 20;
        class w extends Tu {
          get(t) {
            return new v(this, t)
          }
        }
        Mr("CollisionBoxArray", w);
        class T extends no {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        T.prototype.size = 48;
        class C extends Ql {
          get(t) {
            return new T(this, t)
          }
        }
        Mr("PlacedSymbolArray", C);
        class A extends no {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        A.prototype.size = 64;
        class j extends Pu {
          get(t) {
            return new A(this, t)
          }
        }
        Mr("SymbolInstanceArray", j);
        class R extends d {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        Mr("GlyphOffsetArray", R);
        class Z extends $l {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        Mr("SymbolLineVertexArray", Z);
        class Y extends no {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        Y.prototype.size = 12;
        class oe extends e {
          get(t) {
            return new Y(this, t)
          }
        }
        Mr("TextAnchorOffsetArray", oe);
        class le extends no {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        le.prototype.size = 8;
        class ce extends a {
          get(t) {
            return new le(this, t)
          }
        }
        Mr("FeatureIndexArray", ce);
        class me extends Is {}
        class Se extends Is {}
        class fe extends Is {}
        class Pe extends fo {}
        class Ae extends Xl {}
        class ve extends Yo {}
        class Oe extends Yl {}
        class ct extends al {}
        class it extends ku {}
        class st extends Cs {}
        class ut extends Ko {}
        class or extends Kl {}
        class cr extends Su {}
        class Bt extends Jl {}
        class Nr extends c {}
        const xn = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Xn
          } = xn;
        class zn {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, n, o, u) {
            const _ = this.segments[this.segments.length - 1];
            return t > zn.MAX_VERTEX_ARRAY_LENGTH && zt(`Max vertices per segment is ${zn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${zn.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !_ || _.vertexLength + t > zn.MAX_VERTEX_ARRAY_LENGTH || _.sortKey !== u ? this.createNewSegment(n, o, u) : _
          }
          createNewSegment(t, n, o) {
            const u = {
              vertexOffset: t.length,
              primitiveOffset: n.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return o !== void 0 && (u.sortKey = o), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(u), u
          }
          getOrCreateLatestSegment(t, n, o) {
            return this.prepareSegment(0, t, n, o)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const n in t.vaos) t.vaos[n].destroy()
          }
          static simpleSegment(t, n, o, u) {
            return new zn([{
              vertexOffset: t,
              primitiveOffset: n,
              vertexLength: o,
              primitiveLength: u,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function ti(i, t) {
          return 256 * (i = Yt(Math.floor(i), 0, 255)) + Yt(Math.floor(t), 0, 255)
        }
        zn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Mr("SegmentVector", zn);
        const mi = wi([{
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
          }]),
          ni = wi([{
            name: "a_dasharray_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_dasharray_to",
            components: 4,
            type: "Uint16"
          }]);
        var Ei, ci, Ui, ui = {
            exports: {}
          },
          Ci = {
            exports: {}
          },
          ha = {
            exports: {}
          },
          Qo = (function() {
            if (Ui) return ui.exports;
            Ui = 1;
            var i = (Ei || (Ei = 1, Ci.exports = function(n, o) {
                var u, _, m, y, b, P, I, L;
                for (_ = n.length - (u = 3 & n.length), m = o, b = 3432918353, P = 461845907, L = 0; L < _;) I = 255 & n.charCodeAt(L) | (255 & n.charCodeAt(++L)) << 8 | (255 & n.charCodeAt(++L)) << 16 | (255 & n.charCodeAt(++L)) << 24, ++L, m = 27492 + (65535 & (y = 5 * (65535 & (m = (m ^= I = (65535 & (I = (I = (65535 & I) * b + (((I >>> 16) * b & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * P + (((I >>> 16) * P & 65535) << 16) & 4294967295) << 13 | m >>> 19)) + ((5 * (m >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (y >>> 16) & 65535) << 16);
                switch (I = 0, u) {
                  case 3:
                    I ^= (255 & n.charCodeAt(L + 2)) << 16;
                  case 2:
                    I ^= (255 & n.charCodeAt(L + 1)) << 8;
                  case 1:
                    m ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & n.charCodeAt(L))) * b + (((I >>> 16) * b & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * P + (((I >>> 16) * P & 65535) << 16) & 4294967295
                }
                return m ^= n.length, m = 2246822507 * (65535 & (m ^= m >>> 16)) + ((2246822507 * (m >>> 16) & 65535) << 16) & 4294967295, m = 3266489909 * (65535 & (m ^= m >>> 13)) + ((3266489909 * (m >>> 16) & 65535) << 16) & 4294967295, (m ^= m >>> 16) >>> 0
              }), Ci.exports),
              t = (ci || (ci = 1, ha.exports = function(n, o) {
                for (var u, _ = n.length, m = o ^ _, y = 0; _ >= 4;) u = 1540483477 * (65535 & (u = 255 & n.charCodeAt(y) | (255 & n.charCodeAt(++y)) << 8 | (255 & n.charCodeAt(++y)) << 16 | (255 & n.charCodeAt(++y)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16), m = 1540483477 * (65535 & m) + ((1540483477 * (m >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)), _ -= 4, ++y;
                switch (_) {
                  case 3:
                    m ^= (255 & n.charCodeAt(y + 2)) << 16;
                  case 2:
                    m ^= (255 & n.charCodeAt(y + 1)) << 8;
                  case 1:
                    m = 1540483477 * (65535 & (m ^= 255 & n.charCodeAt(y))) + ((1540483477 * (m >>> 16) & 65535) << 16)
                }
                return m = 1540483477 * (65535 & (m ^= m >>> 13)) + ((1540483477 * (m >>> 16) & 65535) << 16), (m ^= m >>> 15) >>> 0
              }), ha.exports);
            return ui.exports = i, ui.exports.murmur3 = i, ui.exports.murmur2 = t, ui.exports
          })(),
          _o = W(Qo);
        class io {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, n, o, u) {
            this.ids.push(es(t)), this.positions.push(n, o, u)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = es(t);
            let o = 0,
              u = this.ids.length - 1;
            for (; o < u;) {
              const m = o + u >> 1;
              this.ids[m] >= n ? u = m : o = m + 1
            }
            const _ = [];
            for (; this.ids[o] === n;) _.push({
              index: this.positions[3 * o],
              start: this.positions[3 * o + 1],
              end: this.positions[3 * o + 2]
            }), o++;
            return _
          }
          static serialize(t, n) {
            const o = new Float64Array(t.ids),
              u = new Uint32Array(t.positions);
            return zs(o, u, 0, o.length - 1), n && n.push(o.buffer, u.buffer), {
              ids: o,
              positions: u
            }
          }
          static deserialize(t) {
            const n = new io;
            return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n
          }
        }

        function es(i) {
          const t = +i;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : _o(String(i))
        }

        function zs(i, t, n, o) {
          for (; n < o;) {
            const u = i[n + o >> 1];
            let _ = n - 1,
              m = o + 1;
            for (;;) {
              do _++; while (i[_] < u);
              do m--; while (i[m] > u);
              if (_ >= m) break;
              ts(i, _, m), ts(t, 3 * _, 3 * m), ts(t, 3 * _ + 1, 3 * m + 1), ts(t, 3 * _ + 2, 3 * m + 2)
            }
            m - n < o - m ? (zs(i, t, n, m), n = m + 1) : (zs(i, t, m + 1, o), o = m)
          }
        }

        function ts(i, t, n) {
          const o = i[t];
          i[t] = i[n], i[n] = o
        }
        Mr("FeaturePositionMap", io);
        class va {
          constructor(t, n) {
            this.gl = t.gl, this.location = n
          }
        }
        class da extends va {
          constructor(t, n) {
            super(t, n), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class mo extends va {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class Io extends va {
          constructor(t, n) {
            super(t, n), this.current = Ir.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const ol = new Float32Array(16);

        function zi(i) {
          return [ti(255 * i.r, 255 * i.g), ti(255 * i.b, 255 * i.a)]
        }
        class ki {
          constructor(t, n, o) {
            this.value = t, this.uniformNames = n.map((u => `u_${u}`)), this.type = o
          }
          setUniform(t, n, o) {
            t.set(o.constantOr(this.value))
          }
          getBinding(t, n, o) {
            return this.type === "color" ? new Io(t, n) : new da(t, n)
          }
        }
        class Zi {
          constructor(t, n) {
            this.uniformNames = n.map((o => `u_${o}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr
          }
          setConstantDashPositions(t, n) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, n.y, n.height, n.width]
          }
          setUniform(t, n, o, u) {
            let _ = null;
            u === "u_pattern_to" ? _ = this.patternTo : u === "u_pattern_from" ? _ = this.patternFrom : u === "u_dasharray_to" ? _ = this.dashTo : u === "u_dasharray_from" ? _ = this.dashFrom : u === "u_pixel_ratio_to" ? _ = this.pixelRatioTo : u === "u_pixel_ratio_from" && (_ = this.pixelRatioFrom), _ !== null && t.set(_)
          }
          getBinding(t, n, o) {
            return o.substr(0, 9) === "u_pattern" || o.substr(0, 12) === "u_dasharray_" ? new mo(t, n) : new da(t, n)
          }
        }
        class ai {
          constructor(t, n, o, u) {
            this.expression = t, this.type = o, this.maxValue = 0, this.paintVertexAttributes = n.map((_ => ({
              name: `a_${_}`,
              type: "Float32",
              components: o === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new u
          }
          populatePaintArray(t, n, o) {
            const u = this.paintVertexArray.length,
              _ = this.expression.evaluate(new ei(0, o), n, {}, o.canonical, [], o.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(u, t, _)
          }
          updatePaintArray(t, n, o, u, _) {
            const m = this.expression.evaluate(new ei(0, _), o, u);
            this._setPaintValue(t, n, m)
          }
          _setPaintValue(t, n, o) {
            if (this.type === "color") {
              const u = zi(o);
              for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, u[0], u[1])
            } else {
              for (let u = t; u < n; u++) this.paintVertexArray.emplace(u, o);
              this.maxValue = Math.max(this.maxValue, Math.abs(o))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Wa {
          constructor(t, n, o, u, _, m) {
            this.expression = t, this.uniformNames = n.map((y => `u_${y}_t`)), this.type = o, this.useIntegerZoom = u, this.zoom = _, this.maxValue = 0, this.paintVertexAttributes = n.map((y => ({
              name: `a_${y}`,
              type: "Float32",
              components: o === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new m
          }
          populatePaintArray(t, n, o) {
            const u = this.expression.evaluate(new ei(this.zoom, o), n, {}, o.canonical, [], o.formattedSection),
              _ = this.expression.evaluate(new ei(this.zoom + 1, o), n, {}, o.canonical, [], o.formattedSection),
              m = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(m, t, u, _)
          }
          updatePaintArray(t, n, o, u, _) {
            const m = this.expression.evaluate(new ei(this.zoom, _), o, u),
              y = this.expression.evaluate(new ei(this.zoom + 1, _), o, u);
            this._setPaintValue(t, n, m, y)
          }
          _setPaintValue(t, n, o, u) {
            if (this.type === "color") {
              const _ = zi(o),
                m = zi(u);
              for (let y = t; y < n; y++) this.paintVertexArray.emplace(y, _[0], _[1], m[0], m[1])
            } else {
              for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, o, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(u))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, n) {
            const o = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom,
              u = Yt(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
            t.set(u)
          }
          getBinding(t, n, o) {
            return new da(t, n)
          }
        }
        class Co {
          constructor(t, n, o, u, _, m) {
            this.expression = t, this.type = n, this.useIntegerZoom = o, this.zoom = u, this.layerId = m, this.zoomInPaintVertexArray = new _, this.zoomOutPaintVertexArray = new _
          }
          populatePaintArray(t, n, o) {
            const u = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(u, t, this.getPositionIds(n), o)
          }
          updatePaintArray(t, n, o, u, _) {
            this._setPaintValues(t, n, this.getPositionIds(o), _)
          }
          _setPaintValues(t, n, o, u) {
            const _ = this.getPositions(u);
            if (!_ || !o) return;
            const m = _[o.min],
              y = _[o.mid],
              b = _[o.max];
            if (m && y && b)
              for (let P = t; P < n; P++) this.emplace(this.zoomInPaintVertexArray, P, y, m), this.emplace(this.zoomOutPaintVertexArray, P, y, b)
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const n = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, n, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, n, this.expression.isStateDependent)
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Id extends Co {
          getPositions(t) {
            return t.imagePositions
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId]
          }
          getVertexAttributes() {
            return mi.members
          }
          emplace(t, n, o, u) {
            t.emplace(n, o.tlbr[0], o.tlbr[1], o.tlbr[2], o.tlbr[3], u.tlbr[0], u.tlbr[1], u.tlbr[2], u.tlbr[3], o.pixelRatio, u.pixelRatio)
          }
        }
        class Cd extends Co {
          getPositions(t) {
            return t.dashPositions
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId]
          }
          getVertexAttributes() {
            return ni.members
          }
          emplace(t, n, o, u) {
            t.emplace(n, 0, o.y, o.height, o.width, 0, u.y, u.height, u.width)
          }
        }
        class zd {
          constructor(t, n, o) {
            this.binders = {}, this._buffers = [];
            const u = [];
            for (const _ in t.paint._values) {
              if (!o(_)) continue;
              const m = t.paint.get(_);
              if (!(m instanceof Za && ws(m.property.specification))) continue;
              const y = ns(_, t.type),
                b = m.value,
                P = m.property.specification.type,
                I = m.property.useIntegerZoom,
                L = m.property.specification["property-type"],
                B = L === "cross-faded" || L === "cross-faded-data-driven";
              if (b.kind === "constant") this.binders[_] = B ? new Zi(b.value, y) : new ki(b.value, y, P), u.push(`/u_${_}`);
              else if (b.kind === "source" || B) {
                const U = Mu(_, P, "source");
                this.binders[_] = B ? _ === "line-dasharray" ? new Cd(b, P, I, n, U, t.id) : new Id(b, P, I, n, U, t.id) : new ai(b, y, P, U), u.push(`/a_${_}`)
              } else {
                const U = Mu(_, P, "composite");
                this.binders[_] = new Wa(b, y, P, I, n, U), u.push(`/z_${_}`)
              }
            }
            this.cacheKey = u.sort().join("")
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof ai || n instanceof Wa ? n.maxValue : 0
          }
          populatePaintArrays(t, n, o) {
            for (const u in this.binders) {
              const _ = this.binders[u];
              (_ instanceof ai || _ instanceof Wa || _ instanceof Co) && _.populatePaintArray(t, n, o)
            }
          }
          setConstantPatternPositions(t, n) {
            for (const o in this.binders) {
              const u = this.binders[o];
              u instanceof Zi && u.setConstantPatternPositions(t, n)
            }
          }
          setConstantDashPositions(t, n) {
            for (const o in this.binders) {
              const u = this.binders[o];
              u instanceof Zi && u.setConstantDashPositions(t, n)
            }
          }
          updatePaintArrays(t, n, o, u, _) {
            let m = !1;
            for (const y in t) {
              const b = n.getPositions(y);
              for (const P of b) {
                const I = o.feature(P.index);
                for (const L in this.binders) {
                  const B = this.binders[L];
                  if ((B instanceof ai || B instanceof Wa || B instanceof Co) && B.expression.isStateDependent === !0) {
                    const U = u.paint.get(L);
                    B.expression = U.value, B.updatePaintArray(P.start, P.end, I, t[y], _), m = !0
                  }
                }
              }
            }
            return m
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              (o instanceof ki || o instanceof Zi) && t.push(...o.uniformNames.map((u => `#define HAS_UNIFORM_${u}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              if (o instanceof ai || o instanceof Wa)
                for (let u = 0; u < o.paintVertexAttributes.length; u++) t.push(o.paintVertexAttributes[u].name);
              else if (o instanceof Co) {
                const u = o.getVertexAttributes();
                for (const _ of u) t.push(_.name)
              }
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              if (o instanceof ki || o instanceof Zi || o instanceof Wa)
                for (const u of o.uniformNames) t.push(u)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, n) {
            const o = [];
            for (const u in this.binders) {
              const _ = this.binders[u];
              if (_ instanceof ki || _ instanceof Zi || _ instanceof Wa) {
                for (const m of _.uniformNames)
                  if (n[m]) {
                    const y = _.getBinding(t, n[m], m);
                    o.push({
                      name: m,
                      property: u,
                      binding: y
                    })
                  }
              }
            }
            return o
          }
          setUniforms(t, n, o, u) {
            for (const {
                name: _,
                property: m,
                binding: y
              }
              of n) this.binders[m].setUniform(y, u, o.get(m), _)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const o = this.binders[n];
              if (t && o instanceof Co) {
                const u = t.fromScale === 2 ? o.zoomInPaintVertexBuffer : o.zoomOutPaintVertexBuffer;
                u && this._buffers.push(u)
              } else(o instanceof ai || o instanceof Wa) && o.paintVertexBuffer && this._buffers.push(o.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const o = this.binders[n];
              (o instanceof ai || o instanceof Wa || o instanceof Co) && o.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof ai || n instanceof Wa || n instanceof Co) && n.destroy()
            }
          }
        }
        class rs {
          constructor(t, n, o = () => !0) {
            this.programConfigurations = {};
            for (const u of t) this.programConfigurations[u.id] = new zd(u, n, o);
            this.needsUpload = !1, this._featureMap = new io, this._bufferOffset = 0
          }
          populatePaintArrays(t, n, o, u) {
            for (const _ in this.programConfigurations) this.programConfigurations[_].populatePaintArrays(t, n, u);
            n.id !== void 0 && this._featureMap.add(n.id, o, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, n, o, u) {
            for (const _ of o) this.needsUpload = this.programConfigurations[_.id].updatePaintArrays(t, this._featureMap, n, _, u) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function ns(i, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-dasharray": ["dasharray_to", "dasharray_from"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [i] || [i.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function Mu(i, t, n) {
          const o = {
              color: {
                source: Yo,
                composite: f
              },
              number: {
                source: d,
                composite: Yo
              }
            },
            u = (function(_) {
              return {
                "line-pattern": {
                  source: Oe,
                  composite: Oe
                },
                "fill-pattern": {
                  source: Oe,
                  composite: Oe
                },
                "fill-extrusion-pattern": {
                  source: Oe,
                  composite: Oe
                },
                "line-dasharray": {
                  source: ct,
                  composite: ct
                }
              } [_]
            })(i);
          return u && u[n] || o[t][n]
        }
        Mr("ConstantBinder", ki), Mr("CrossFadedConstantBinder", Zi), Mr("SourceExpressionBinder", ai), Mr("CrossFadedPatternBinder", Id), Mr("CrossFadedDasharrayBinder", Cd), Mr("CompositeExpressionBinder", Wa), Mr("ProgramConfiguration", zd, {
          omit: ["_buffers"]
        }), Mr("ProgramConfigurationSet", rs);
        const ec = Math.pow(2, 14) - 1,
          Iu = -ec - 1;

        function go(i) {
          const t = lt / i.extent,
            n = i.loadGeometry();
          for (let o = 0; o < n.length; o++) {
            const u = n[o];
            for (let _ = 0; _ < u.length; _++) {
              const m = u[_],
                y = Math.round(m.x * t),
                b = Math.round(m.y * t);
              m.x = Yt(y, Iu, ec), m.y = Yt(b, Iu, ec), (y < m.x || y > m.x + 1 || b < m.y || b > m.y + 1) && zt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return n
        }

        function zo(i, t) {
          return {
            type: i.type,
            id: i.id,
            properties: i.properties,
            geometry: t ? go(i) : []
          }
        }
        const tc = -32768;

        function Ty(i, t, n, o, u) {
          i.emplaceBack(tc + 8 * t + o, tc + 8 * n + u)
        }
        class af {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Se, this.indexArray = new Bt, this.segments = new zn, this.programConfigurations = new rs(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            const u = this.layers[0],
              _ = [];
            let m = null,
              y = !1,
              b = u.type === "heatmap";
            if (u.type === "circle") {
              const I = u;
              m = I.layout.get("circle-sort-key"), y = !m.isConstant(), b = b || I.paint.get("circle-pitch-alignment") === "map"
            }
            const P = b ? n.subdivisionGranularity.circle : 1;
            for (const {
                feature: I,
                id: L,
                index: B,
                sourceLayerIndex: U
              }
              of t) {
              const G = this.layers[0]._featureFilter.needGeometry,
                K = zo(I, G);
              if (!this.layers[0]._featureFilter.filter(new ei(this.zoom), K, o)) continue;
              const ne = y ? m.evaluate(K, {}, o) : void 0,
                pe = {
                  id: L,
                  properties: I.properties,
                  type: I.type,
                  sourceLayerIndex: U,
                  index: B,
                  geometry: G ? K.geometry : go(I),
                  patterns: {},
                  sortKey: ne
                };
              _.push(pe)
            }
            y && _.sort(((I, L) => I.sortKey - L.sortKey));
            for (const I of _) {
              const {
                geometry: L,
                index: B,
                sourceLayerIndex: U
              } = I, G = t[B].feature;
              this.addFeature(I, L, B, o, P), n.featureIndex.insert(G, L, B, U, this.index)
            }
          }
          update(t, n, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Xn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, n, o, u, _ = 1) {
            let m;
            switch (_) {
              case 1:
                m = [0, 7];
                break;
              case 3:
                m = [0, 2, 5, 7];
                break;
              case 5:
                m = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                m = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${_}; valid values are 1, 3, 5, 7.`)
            }
            const y = m.length;
            for (const b of n)
              for (const P of b) {
                const I = P.x,
                  L = P.y;
                if (I < 0 || I >= lt || L < 0 || L >= lt) continue;
                const B = this.segments.prepareSegment(y * y, this.layoutVertexArray, this.indexArray, t.sortKey),
                  U = B.vertexLength;
                for (let G = 0; G < y; G++)
                  for (let K = 0; K < y; K++) Ty(this.layoutVertexArray, I, L, m[K], m[G]);
                for (let G = 0; G < y - 1; G++)
                  for (let K = 0; K < y - 1; K++) {
                    const ne = U + G * y + K,
                      pe = U + (G + 1) * y + K;
                    this.indexArray.emplaceBack(ne, pe + 1, ne + 1), this.indexArray.emplaceBack(ne, pe, pe + 1)
                  }
                B.vertexLength += y * y, B.primitiveLength += (y - 1) * (y - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: {},
              canonical: u
            })
          }
        }

        function Sm(i, t) {
          for (let n = 0; n < i.length; n++)
            if (rc(t, i[n])) return !0;
          for (let n = 0; n < t.length; n++)
            if (rc(i, t[n])) return !0;
          return !!of(i, t)
        }

        function Ad(i, t, n) {
          return !!rc(i, t) || !!sf(t, i, n)
        }

        function Pm(i, t) {
          if (i.length === 1) return Im(t, i[0]);
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            for (let u = 0; u < o.length; u++)
              if (rc(i, o[u])) return !0
          }
          for (let n = 0; n < i.length; n++)
            if (Im(t, i[n])) return !0;
          for (let n = 0; n < t.length; n++)
            if (of(i, t[n])) return !0;
          return !1
        }

        function Sy(i, t, n) {
          if (i.length > 1) {
            if (of(i, t)) return !0;
            for (let o = 0; o < t.length; o++)
              if (sf(t[o], i, n)) return !0
          }
          for (let o = 0; o < i.length; o++)
            if (sf(i[o], t, n)) return !0;
          return !1
        }

        function of(i, t) {
          if (i.length === 0 || t.length === 0) return !1;
          for (let n = 0; n < i.length - 1; n++) {
            const o = i[n],
              u = i[n + 1];
            for (let _ = 0; _ < t.length - 1; _++)
              if (Py(o, u, t[_], t[_ + 1])) return !0
          }
          return !1
        }

        function Py(i, t, n, o) {
          return Mt(i, n, o) !== Mt(t, n, o) && Mt(i, t, n) !== Mt(i, t, o)
        }

        function sf(i, t, n) {
          const o = n * n;
          if (t.length === 1) return i.distSqr(t[0]) < o;
          for (let u = 1; u < t.length; u++)
            if (Mm(i, t[u - 1], t[u]) < o) return !0;
          return !1
        }

        function Mm(i, t, n) {
          const o = t.distSqr(n);
          if (o === 0) return i.distSqr(t);
          const u = ((i.x - t.x) * (n.x - t.x) + (i.y - t.y) * (n.y - t.y)) / o;
          return i.distSqr(u < 0 ? t : u > 1 ? n : n.sub(t)._mult(u)._add(t))
        }

        function Im(i, t) {
          let n, o, u, _ = !1;
          for (let m = 0; m < i.length; m++) {
            n = i[m];
            for (let y = 0, b = n.length - 1; y < n.length; b = y++) o = n[y], u = n[b], o.y > t.y != u.y > t.y && t.x < (u.x - o.x) * (t.y - o.y) / (u.y - o.y) + o.x && (_ = !_)
          }
          return _
        }

        function rc(i, t) {
          let n = !1;
          for (let o = 0, u = i.length - 1; o < i.length; u = o++) {
            const _ = i[o],
              m = i[u];
            _.y > t.y != m.y > t.y && t.x < (m.x - _.x) * (t.y - _.y) / (m.y - _.y) + _.x && (n = !n)
          }
          return n
        }

        function My(i, t, n) {
          const o = n[0],
            u = n[2];
          if (i.x < o.x && t.x < o.x || i.x > u.x && t.x > u.x || i.y < o.y && t.y < o.y || i.y > u.y && t.y > u.y) return !1;
          const _ = Mt(i, t, n[0]);
          return _ !== Mt(i, t, n[1]) || _ !== Mt(i, t, n[2]) || _ !== Mt(i, t, n[3])
        }

        function nc(i, t, n) {
          const o = t.paint.get(i).value;
          return o.kind === "constant" ? o.value : n.programConfigurations.get(t.id).getMaxValue(i)
        }

        function Ed(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1])
        }

        function Ld(i, t, n, o, u) {
          if (!t[0] && !t[1]) return i;
          const _ = F.convert(t)._mult(u);
          n === "viewport" && _._rotate(-o);
          const m = [];
          for (let y = 0; y < i.length; y++) m.push(i[y].sub(_));
          return m
        }

        function Iy({
          queryGeometry: i,
          size: t
        }, n) {
          return Ad(i, n, t)
        }

        function Cy({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u
        }, _) {
          return Ad(i, _, t * (n.projectTileCoordinates(_.x, _.y, o, u).signedDistanceFromCamera / n.cameraToCenterDistance))
        }

        function zy({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u
        }, _) {
          const m = n.projectTileCoordinates(_.x, _.y, o, u).signedDistanceFromCamera,
            y = t * (n.cameraToCenterDistance / m);
          return Ad(i, lf(_, n, o, u), y)
        }

        function Ay({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u
        }, _) {
          return Ad(i, lf(_, n, o, u), t)
        }

        function Cm({
          queryGeometry: i,
          size: t,
          transform: n,
          unwrappedTileID: o,
          getElevation: u,
          pitchAlignment: _ = "map",
          pitchScale: m = "map"
        }, y) {
          const b = _ === "map" ? m === "map" ? Iy : Cy : m === "map" ? zy : Ay,
            P = {
              queryGeometry: i,
              size: t,
              transform: n,
              unwrappedTileID: o,
              getElevation: u
            };
          for (const I of y)
            for (const L of I)
              if (b(P, L)) return !0;
          return !1
        }

        function lf(i, t, n, o) {
          const u = t.projectTileCoordinates(i.x, i.y, n, o).point;
          return new F((.5 * u.x + .5) * t.width, (.5 * -u.y + .5) * t.height)
        }
        let zm, Am;
        Mr("CircleBucket", af, {
          omit: ["layers"]
        });
        var Ey = {
          get paint() {
            return Am = Am || new oa({
              "circle-radius": new ln(J.paint_circle["circle-radius"]),
              "circle-color": new ln(J.paint_circle["circle-color"]),
              "circle-blur": new ln(J.paint_circle["circle-blur"]),
              "circle-opacity": new ln(J.paint_circle["circle-opacity"]),
              "circle-translate": new Xr(J.paint_circle["circle-translate"]),
              "circle-translate-anchor": new Xr(J.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new Xr(J.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new Xr(J.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new ln(J.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new ln(J.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new ln(J.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return zm = zm || new oa({
              "circle-sort-key": new ln(J.layout_circle["circle-sort-key"])
            })
          }
        };
        class Ly extends Ga {
          constructor(t, n) {
            super(t, Ey, n)
          }
          createBucket(t) {
            return new af(t)
          }
          queryRadius(t) {
            const n = t;
            return nc("circle-radius", this, n) + nc("circle-stroke-width", this, n) + Ed(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m,
            unwrappedTileID: y,
            getElevation: b
          }) {
            const P = Ld(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -_.bearingInRadians, m),
              I = this.paint.get("circle-radius").evaluate(n, o) + this.paint.get("circle-stroke-width").evaluate(n, o),
              L = this.paint.get("circle-pitch-scale"),
              B = this.paint.get("circle-pitch-alignment");
            let U, G;
            return B === "map" ? (U = P, G = I * m) : (U = (function(K, ne, pe, Ze) {
              return K.map((ye => lf(ye, ne, pe, Ze)))
            })(P, _, y, b), G = I), Cm({
              queryGeometry: U,
              size: G,
              transform: _,
              unwrappedTileID: y,
              getElevation: b,
              pitchAlignment: B,
              pitchScale: L
            }, u)
          }
        }
        class Em extends af {}
        let Lm;
        Mr("HeatmapBucket", Em, {
          omit: ["layers"]
        });
        var Dy = {
          get paint() {
            return Lm = Lm || new oa({
              "heatmap-radius": new ln(J.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new ln(J.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new Xr(J.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new il(J.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new Xr(J.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function cf(i, {
          width: t,
          height: n
        }, o, u) {
          if (u) {
            if (u instanceof Uint8ClampedArray) u = new Uint8Array(u.buffer);
            else if (u.length !== t * n * o) throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${t*n*o}`)
          } else u = new Uint8Array(t * n * o);
          return i.width = t, i.height = n, i.data = u, i
        }

        function Dm(i, {
          width: t,
          height: n
        }, o) {
          if (t === i.width && n === i.height) return;
          const u = cf({}, {
            width: t,
            height: n
          }, o);
          uf(i, u, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(i.width, t),
            height: Math.min(i.height, n)
          }, o), i.width = t, i.height = n, i.data = u.data
        }

        function uf(i, t, n, o, u, _) {
          if (u.width === 0 || u.height === 0) return t;
          if (u.width > i.width || u.height > i.height || n.x > i.width - u.width || n.y > i.height - u.height) throw new RangeError("out of range source coordinates for image copy");
          if (u.width > t.width || u.height > t.height || o.x > t.width - u.width || o.y > t.height - u.height) throw new RangeError("out of range destination coordinates for image copy");
          const m = i.data,
            y = t.data;
          if (m === y) throw new Error("srcData equals dstData, so image is already copied");
          for (let b = 0; b < u.height; b++) {
            const P = ((n.y + b) * i.width + n.x) * _,
              I = ((o.y + b) * t.width + o.x) * _;
            for (let L = 0; L < u.width * _; L++) y[I + L] = m[P + L]
          }
          return t
        }
        class Cu {
          constructor(t, n) {
            cf(this, t, 1, n)
          }
          resize(t) {
            Dm(this, t, 1)
          }
          clone() {
            return new Cu({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, n, o, u, _) {
            uf(t, n, o, u, _, 1)
          }
        }
        class Ta {
          constructor(t, n) {
            cf(this, t, 4, n)
          }
          resize(t) {
            Dm(this, t, 4)
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new Ta({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, n, o, u, _) {
            uf(t, n, o, u, _, 4)
          }
          setPixel(t, n, o) {
            const u = 4 * (t * this.width + n);
            this.data[u + 0] = Math.round(255 * o.r / o.a), this.data[u + 1] = Math.round(255 * o.g / o.a), this.data[u + 2] = Math.round(255 * o.b / o.a), this.data[u + 3] = Math.round(255 * o.a)
          }
        }

        function Rm(i) {
          const t = {},
            n = i.resolution || 256,
            o = i.clips ? i.clips.length : 1,
            u = i.image || new Ta({
              width: n,
              height: o
            });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const _ = (m, y, b) => {
            t[i.evaluationKey] = b;
            const P = i.expression.evaluate(t);
            u.setPixel(m / 4 / n, y / 4, P)
          };
          if (i.clips)
            for (let m = 0, y = 0; m < o; ++m, y += 4 * n)
              for (let b = 0, P = 0; b < n; b++, P += 4) {
                const I = b / (n - 1),
                  {
                    start: L,
                    end: B
                  } = i.clips[m];
                _(y, P, L * (1 - I) + B * I)
              } else
                for (let m = 0, y = 0; m < n; m++, y += 4) _(0, y, m / (n - 1));
          return u
        }
        Mr("AlphaImage", Cu), Mr("RGBAImage", Ta);
        const hf = "big-fb";
        class Ry extends Ga {
          createBucket(t) {
            return new Em(t)
          }
          constructor(t, n) {
            super(t, Dy, n), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = Rm({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(hf) && this.heatmapFbos.delete(hf)
          }
          queryRadius(t) {
            return nc("heatmap-radius", this, t)
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m,
            unwrappedTileID: y,
            getElevation: b
          }) {
            return Cm({
              queryGeometry: t,
              size: this.paint.get("heatmap-radius").evaluate(n, o) * m,
              transform: _,
              unwrappedTileID: y,
              getElevation: b
            }, u)
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let jm;
        var jy = {
          get paint() {
            return jm = jm || new oa({
              "hillshade-illumination-direction": new Xr(J.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new Xr(J.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new Xr(J.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new Xr(J.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new Xr(J.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new Xr(J.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new Xr(J.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new Xr(J.paint_hillshade["hillshade-method"])
            })
          }
        };
        class Fy extends Ga {
          constructor(t, n) {
            super(t, jy, n), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              n = this.paint.get("hillshade-illumination-altitude").values,
              o = this.paint.get("hillshade-highlight-color").values,
              u = this.paint.get("hillshade-shadow-color").values;
            const _ = Math.max(t.length, n.length, o.length, u.length);
            t = t.concat(Array(_ - t.length).fill(t.at(-1))), n = n.concat(Array(_ - n.length).fill(n.at(-1))), o = o.concat(Array(_ - o.length).fill(o.at(-1))), u = u.concat(Array(_ - u.length).fill(u.at(-1)));
            const m = n.map(Zr);
            return {
              directionRadians: t.map(Zr),
              altitudeRadians: m,
              shadowColor: u,
              highlightColor: o
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let Fm;
        var By = {
          get paint() {
            return Fm = Fm || new oa({
              "color-relief-opacity": new Xr(J["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new il(J["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class df {
          constructor(t, n, o, u) {
            this.context = t, this.format = o, this.texture = t.gl.createTexture(), this.update(n, u)
          }
          update(t, n, o) {
            const {
              width: u,
              height: _
            } = t, m = !(this.size && this.size[0] === u && this.size[1] === _ || o), {
              context: y
            } = this, {
              gl: b
            } = y;
            if (this.useMipmap = !!(n && n.useMipmap), b.bindTexture(b.TEXTURE_2D, this.texture), y.pixelStoreUnpackFlipY.set(!1), y.pixelStoreUnpack.set(1), y.pixelStoreUnpackPremultiplyAlpha.set(this.format === b.RGBA && (!n || n.premultiply !== !1)), m) this.size = [u, _], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ht(t) ? b.texImage2D(b.TEXTURE_2D, 0, this.format, this.format, b.UNSIGNED_BYTE, t) : b.texImage2D(b.TEXTURE_2D, 0, this.format, u, _, 0, this.format, b.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: P,
                y: I
              } = o || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ht(t) ? b.texSubImage2D(b.TEXTURE_2D, 0, P, I, b.RGBA, b.UNSIGNED_BYTE, t) : b.texSubImage2D(b.TEXTURE_2D, 0, P, I, u, _, b.RGBA, b.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && b.generateMipmap(b.TEXTURE_2D), y.pixelStoreUnpackFlipY.setDefault(), y.pixelStoreUnpack.setDefault(), y.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, n, o) {
            const {
              context: u
            } = this, {
              gl: _
            } = u;
            _.bindTexture(_.TEXTURE_2D, this.texture), o !== _.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (o = _.LINEAR), t !== this.filter && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, t), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, o || t), this.filter = t), n !== this.wrap && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, n), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, n), this.wrap = n)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class Bm {
          constructor(t, n, o, u = 1, _ = 1, m = 1, y = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (o && !["mapbox", "terrarium", "custom"].includes(o)) return void zt(`"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const b = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), o) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = u, this.greenFactor = _, this.blueFactor = m, this.baseShift = y;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let P = 0; P < b; P++) this.data[this._idx(-1, P)] = this.data[this._idx(0, P)], this.data[this._idx(b, P)] = this.data[this._idx(b - 1, P)], this.data[this._idx(P, -1)] = this.data[this._idx(P, 0)], this.data[this._idx(P, b)] = this.data[this._idx(P, b - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(b, -1)] = this.data[this._idx(b - 1, 0)], this.data[this._idx(-1, b)] = this.data[this._idx(0, b - 1)], this.data[this._idx(b, b)] = this.data[this._idx(b - 1, b - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let P = 0; P < b; P++)
              for (let I = 0; I < b; I++) {
                const L = this.get(P, I);
                L > this.max && (this.max = L), L < this.min && (this.min = L)
              }
          }
          get(t, n) {
            const o = new Uint8Array(this.data.buffer),
              u = 4 * this._idx(t, n);
            return this.unpack(o[u], o[u + 1], o[u + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1)
          }
          unpack(t, n, o) {
            return t * this.redFactor + n * this.greenFactor + o * this.blueFactor - this.baseShift
          }
          pack(t) {
            return Om(t, this.getUnpackVector())
          }
          getPixels() {
            return new Ta({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, n, o) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let u = n * this.dim,
              _ = n * this.dim + this.dim,
              m = o * this.dim,
              y = o * this.dim + this.dim;
            switch (n) {
              case -1:
                u = _ - 1;
                break;
              case 1:
                _ = u + 1
            }
            switch (o) {
              case -1:
                m = y - 1;
                break;
              case 1:
                y = m + 1
            }
            const b = -n * this.dim,
              P = -o * this.dim;
            for (let I = m; I < y; I++)
              for (let L = u; L < _; L++) this.data[this._idx(L, I)] = t.data[this._idx(L + b, I + P)]
          }
        }

        function Om(i, t) {
          const n = t[0],
            o = t[1],
            u = t[2],
            _ = t[3],
            m = Math.min(n, o, u),
            y = Math.round((i + _) / m);
          return {
            r: Math.floor(y * m / n) % 256,
            g: Math.floor(y * m / o) % 256,
            b: Math.floor(y * m / u) % 256
          }
        }
        Mr("DEMData", Bm);
        class Oy extends Ga {
          constructor(t, n) {
            super(t, By, n)
          }
          _createColorRamp(t) {
            const n = {
                elevationStops: [],
                colorStops: []
              },
              o = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (o instanceof Xs && o._styleExpression.expression instanceof Hn) {
              this.colorRampExpression = o;
              const m = o._styleExpression.expression;
              n.elevationStops = m.labels, n.colorStops = [];
              for (const y of n.elevationStops) n.colorStops.push(m.evaluate({
                globals: {
                  elevation: y
                }
              }))
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [Ir.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= t) return n;
            const u = {
                elevationStops: [],
                colorStops: []
              },
              _ = (n.elevationStops.length - 1) / (t - 1);
            for (let m = 0; m < n.elevationStops.length - .5; m += _) u.elevationStops.push(n.elevationStops[Math.round(m)]), u.colorStops.push(n.colorStops[Math.round(m)]);
            return zt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${n.elevationStops.length}`), u
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, n, o) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const u = this._createColorRamp(n),
              _ = new Ta({
                width: u.colorStops.length,
                height: 1
              }),
              m = new Ta({
                width: u.colorStops.length,
                height: 1
              });
            for (let y = 0; y < u.elevationStops.length; y++) {
              const b = Om(u.elevationStops[y], o);
              m.setPixel(0, y, new Ir(b.r / 255, b.g / 255, b.b / 255, 1)), _.setPixel(0, y, u.colorStops[y])
            }
            return this.colorRampTextures = {
              elevationTexture: new df(t, m, t.gl.RGBA),
              colorTexture: new df(t, _, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const qy = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Ny
          } = qy;

        function Dd(i, t, n) {
          const o = n.patternDependencies;
          let u = !1;
          for (const _ of t) {
            const m = _.paint.get(`${i}-pattern`);
            m.isConstant() || (u = !0);
            const y = m.constantOr(null);
            y && (u = !0, o[y.to] = !0, o[y.from] = !0)
          }
          return u
        }

        function pf(i, t, n, o, u) {
          const {
            zoom: _
          } = o, m = u.patternDependencies;
          for (const y of t) {
            const b = y.paint.get(`${i}-pattern`).value;
            if (b.kind !== "constant") {
              let P = b.evaluate({
                  zoom: _ - 1
                }, n, {}, u.availableImages),
                I = b.evaluate({
                  zoom: _
                }, n, {}, u.availableImages),
                L = b.evaluate({
                  zoom: _ + 1
                }, n, {}, u.availableImages);
              P = P && P.name ? P.name : P, I = I && I.name ? I.name : I, L = L && L.name ? L.name : L, m[P] = !0, m[I] = !0, m[L] = !0, n.patterns[y.id] = {
                min: P,
                mid: I,
                max: L
              }
            }
          }
          return n
        }

        function qm(i, t, n, o, u) {
          let _;
          if (u === (function(m, y, b, P) {
              let I = 0;
              for (let L = y, B = b - P; L < b; L += P) I += (m[B] - m[L]) * (m[L + 1] + m[B + 1]), B = L;
              return I
            })(i, t, n, o) > 0)
            for (let m = t; m < n; m += o) _ = Zm(m / o | 0, i[m], i[m + 1], _);
          else
            for (let m = n - o; m >= t; m -= o) _ = Zm(m / o | 0, i[m], i[m + 1], _);
          return _ && ic(_, _.next) && (Lu(_), _ = _.next), _
        }

        function sl(i, t) {
          if (!i) return i;
          t || (t = i);
          let n, o = i;
          do
            if (n = !1, o.steiner || !ic(o, o.next) && Ai(o.prev, o, o.next) !== 0) o = o.next;
            else {
              if (Lu(o), o = t = o.prev, o === o.next) break;
              n = !0
            } while (n || o !== t);
          return t
        }

        function zu(i, t, n, o, u, _, m) {
          if (!i) return;
          !m && _ && (function(b, P, I, L) {
            let B = b;
            do B.z === 0 && (B.z = ff(B.x, B.y, P, I, L)), B.prevZ = B.prev, B.nextZ = B.next, B = B.next; while (B !== b);
            B.prevZ.nextZ = null, B.prevZ = null, (function(U) {
              let G, K = 1;
              do {
                let ne, pe = U;
                U = null;
                let Ze = null;
                for (G = 0; pe;) {
                  G++;
                  let ye = pe,
                    ze = 0;
                  for (let gt = 0; gt < K && (ze++, ye = ye.nextZ, ye); gt++);
                  let at = K;
                  for (; ze > 0 || at > 0 && ye;) ze !== 0 && (at === 0 || !ye || pe.z <= ye.z) ? (ne = pe, pe = pe.nextZ, ze--) : (ne = ye, ye = ye.nextZ, at--), Ze ? Ze.nextZ = ne : U = ne, ne.prevZ = Ze, Ze = ne;
                  pe = ye
                }
                Ze.nextZ = null, K *= 2
              } while (G > 1)
            })(B)
          })(i, o, u, _);
          let y = i;
          for (; i.prev !== i.next;) {
            const b = i.prev,
              P = i.next;
            if (_ ? Uy(i, o, u, _) : Vy(i)) t.push(b.i, i.i, P.i), Lu(i), i = P.next, y = P.next;
            else if ((i = P) === y) {
              m ? m === 1 ? zu(i = Zy(sl(i), t), t, n, o, u, _, 2) : m === 2 && Gy(i, t, n, o, u, _) : zu(sl(i), t, n, o, u, _, 1);
              break
            }
          }
        }

        function Vy(i) {
          const t = i.prev,
            n = i,
            o = i.next;
          if (Ai(t, n, o) >= 0) return !1;
          const u = t.x,
            _ = n.x,
            m = o.x,
            y = t.y,
            b = n.y,
            P = o.y,
            I = Math.min(u, _, m),
            L = Math.min(y, b, P),
            B = Math.max(u, _, m),
            U = Math.max(y, b, P);
          let G = o.next;
          for (; G !== t;) {
            if (G.x >= I && G.x <= B && G.y >= L && G.y <= U && Au(u, y, _, b, m, P, G.x, G.y) && Ai(G.prev, G, G.next) >= 0) return !1;
            G = G.next
          }
          return !0
        }

        function Uy(i, t, n, o) {
          const u = i.prev,
            _ = i,
            m = i.next;
          if (Ai(u, _, m) >= 0) return !1;
          const y = u.x,
            b = _.x,
            P = m.x,
            I = u.y,
            L = _.y,
            B = m.y,
            U = Math.min(y, b, P),
            G = Math.min(I, L, B),
            K = Math.max(y, b, P),
            ne = Math.max(I, L, B),
            pe = ff(U, G, t, n, o),
            Ze = ff(K, ne, t, n, o);
          let ye = i.prevZ,
            ze = i.nextZ;
          for (; ye && ye.z >= pe && ze && ze.z <= Ze;) {
            if (ye.x >= U && ye.x <= K && ye.y >= G && ye.y <= ne && ye !== u && ye !== m && Au(y, I, b, L, P, B, ye.x, ye.y) && Ai(ye.prev, ye, ye.next) >= 0 || (ye = ye.prevZ, ze.x >= U && ze.x <= K && ze.y >= G && ze.y <= ne && ze !== u && ze !== m && Au(y, I, b, L, P, B, ze.x, ze.y) && Ai(ze.prev, ze, ze.next) >= 0)) return !1;
            ze = ze.nextZ
          }
          for (; ye && ye.z >= pe;) {
            if (ye.x >= U && ye.x <= K && ye.y >= G && ye.y <= ne && ye !== u && ye !== m && Au(y, I, b, L, P, B, ye.x, ye.y) && Ai(ye.prev, ye, ye.next) >= 0) return !1;
            ye = ye.prevZ
          }
          for (; ze && ze.z <= Ze;) {
            if (ze.x >= U && ze.x <= K && ze.y >= G && ze.y <= ne && ze !== u && ze !== m && Au(y, I, b, L, P, B, ze.x, ze.y) && Ai(ze.prev, ze, ze.next) >= 0) return !1;
            ze = ze.nextZ
          }
          return !0
        }

        function Zy(i, t) {
          let n = i;
          do {
            const o = n.prev,
              u = n.next.next;
            !ic(o, u) && Vm(o, n, n.next, u) && Eu(o, u) && Eu(u, o) && (t.push(o.i, n.i, u.i), Lu(n), Lu(n.next), n = i = u), n = n.next
          } while (n !== i);
          return sl(n)
        }

        function Gy(i, t, n, o, u, _) {
          let m = i;
          do {
            let y = m.next.next;
            for (; y !== m.prev;) {
              if (m.i !== y.i && Yy(m, y)) {
                let b = Um(m, y);
                return m = sl(m, m.next), b = sl(b, b.next), zu(m, t, n, o, u, _, 0), void zu(b, t, n, o, u, _, 0)
              }
              y = y.next
            }
            m = m.next
          } while (m !== i)
        }

        function Wy(i, t) {
          let n = i.x - t.x;
          return n === 0 && (n = i.y - t.y, n === 0) && (n = (i.next.y - i.y) / (i.next.x - i.x) - (t.next.y - t.y) / (t.next.x - t.x)), n
        }

        function Hy(i, t) {
          const n = (function(u, _) {
            let m = _;
            const y = u.x,
              b = u.y;
            let P, I = -1 / 0;
            if (ic(u, m)) return m;
            do {
              if (ic(u, m.next)) return m.next;
              if (b <= m.y && b >= m.next.y && m.next.y !== m.y) {
                const K = m.x + (b - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
                if (K <= y && K > I && (I = K, P = m.x < m.next.x ? m : m.next, K === y)) return P
              }
              m = m.next
            } while (m !== _);
            if (!P) return null;
            const L = P,
              B = P.x,
              U = P.y;
            let G = 1 / 0;
            m = P;
            do {
              if (y >= m.x && m.x >= B && y !== m.x && Nm(b < U ? y : I, b, B, U, b < U ? I : y, b, m.x, m.y)) {
                const K = Math.abs(b - m.y) / (y - m.x);
                Eu(m, u) && (K < G || K === G && (m.x > P.x || m.x === P.x && $y(P, m))) && (P = m, G = K)
              }
              m = m.next
            } while (m !== L);
            return P
          })(i, t);
          if (!n) return t;
          const o = Um(n, i);
          return sl(o, o.next), sl(n, n.next)
        }

        function $y(i, t) {
          return Ai(i.prev, i, t.prev) < 0 && Ai(t.next, i, i.next) < 0
        }

        function ff(i, t, n, o, u) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * u | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - o) * u | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function Xy(i) {
          let t = i,
            n = i;
          do(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== i);
          return n
        }

        function Nm(i, t, n, o, u, _, m, y) {
          return (u - m) * (t - y) >= (i - m) * (_ - y) && (i - m) * (o - y) >= (n - m) * (t - y) && (n - m) * (_ - y) >= (u - m) * (o - y)
        }

        function Au(i, t, n, o, u, _, m, y) {
          return !(i === m && t === y) && Nm(i, t, n, o, u, _, m, y)
        }

        function Yy(i, t) {
          return i.next.i !== t.i && i.prev.i !== t.i && !(function(n, o) {
            let u = n;
            do {
              if (u.i !== n.i && u.next.i !== n.i && u.i !== o.i && u.next.i !== o.i && Vm(u, u.next, n, o)) return !0;
              u = u.next
            } while (u !== n);
            return !1
          })(i, t) && (Eu(i, t) && Eu(t, i) && (function(n, o) {
            let u = n,
              _ = !1;
            const m = (n.x + o.x) / 2,
              y = (n.y + o.y) / 2;
            do u.y > y != u.next.y > y && u.next.y !== u.y && m < (u.next.x - u.x) * (y - u.y) / (u.next.y - u.y) + u.x && (_ = !_), u = u.next; while (u !== n);
            return _
          })(i, t) && (Ai(i.prev, i, t.prev) || Ai(i, t.prev, t)) || ic(i, t) && Ai(i.prev, i, i.next) > 0 && Ai(t.prev, t, t.next) > 0)
        }

        function Ai(i, t, n) {
          return (t.y - i.y) * (n.x - t.x) - (t.x - i.x) * (n.y - t.y)
        }

        function ic(i, t) {
          return i.x === t.x && i.y === t.y
        }

        function Vm(i, t, n, o) {
          const u = jd(Ai(i, t, n)),
            _ = jd(Ai(i, t, o)),
            m = jd(Ai(n, o, i)),
            y = jd(Ai(n, o, t));
          return u !== _ && m !== y || !(u !== 0 || !Rd(i, n, t)) || !(_ !== 0 || !Rd(i, o, t)) || !(m !== 0 || !Rd(n, i, o)) || !(y !== 0 || !Rd(n, t, o))
        }

        function Rd(i, t, n) {
          return t.x <= Math.max(i.x, n.x) && t.x >= Math.min(i.x, n.x) && t.y <= Math.max(i.y, n.y) && t.y >= Math.min(i.y, n.y)
        }

        function jd(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0
        }

        function Eu(i, t) {
          return Ai(i.prev, i, i.next) < 0 ? Ai(i, t, i.next) >= 0 && Ai(i, i.prev, t) >= 0 : Ai(i, t, i.prev) < 0 || Ai(i, i.next, t) < 0
        }

        function Um(i, t) {
          const n = _f(i.i, i.x, i.y),
            o = _f(t.i, t.x, t.y),
            u = i.next,
            _ = t.prev;
          return i.next = t, t.prev = i, n.next = u, u.prev = n, o.next = n, n.prev = o, _.next = o, o.prev = _, o
        }

        function Zm(i, t, n, o) {
          const u = _f(i, t, n);
          return o ? (u.next = o.next, u.prev = o, o.next.prev = u, o.next = u) : (u.prev = u, u.next = u), u
        }

        function Lu(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
        }

        function _f(i, t, n) {
          return {
            i,
            x: t,
            y: n,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class ac {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class Fd {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        Fd.noSubdivision = new Fd({
          fill: new ac(0, 0),
          line: new ac(0, 0),
          tile: new ac(0, 0),
          stencil: new ac(0, 0),
          circle: 1
        }), Mr("SubdivisionGranularityExpression", ac), Mr("SubdivisionGranularitySetting", Fd);
        const oc = -32768,
          Du = 32767;
        class Ky {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = lt / t, this._canonical = n
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | n + 32768
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const o = 0 | Math.round(t),
              u = 0 | Math.round(n),
              _ = this._getKey(o, u);
            if (this._vertexDictionary.has(_)) return this._vertexDictionary.get(_);
            const m = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(_, m), this._vertexBuffer.push(o, u), m
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(u, _) {
              const m = [];
              for (let y = 0; y < _.length; y += 3) {
                const b = _[y],
                  P = _[y + 1],
                  I = _[y + 2],
                  L = u[2 * b],
                  B = u[2 * b + 1];
                (u[2 * P] - L) * (u[2 * I + 1] - B) - (u[2 * P + 1] - B) * (u[2 * I] - L) > 0 ? (m.push(b), m.push(I), m.push(P)) : (m.push(b), m.push(P), m.push(I))
              }
              return m
            })(this._vertexBuffer, t);
            const n = [],
              o = t.length;
            for (let u = 0; u < o; u += 3) {
              const _ = [t[u + 0], t[u + 1], t[u + 2]],
                m = [this._vertexBuffer[2 * t[u + 0] + 0], this._vertexBuffer[2 * t[u + 0] + 1], this._vertexBuffer[2 * t[u + 1] + 0], this._vertexBuffer[2 * t[u + 1] + 1], this._vertexBuffer[2 * t[u + 2] + 0], this._vertexBuffer[2 * t[u + 2] + 1]];
              let y = 1 / 0,
                b = 1 / 0,
                P = -1 / 0,
                I = -1 / 0;
              for (let K = 0; K < 3; K++) {
                const ne = m[2 * K],
                  pe = m[2 * K + 1];
                y = Math.min(y, ne), P = Math.max(P, ne), b = Math.min(b, pe), I = Math.max(I, pe)
              }
              if (y === P || b === I) continue;
              const L = Math.floor(y / this._granularityCellSize),
                B = Math.ceil(P / this._granularityCellSize),
                U = Math.floor(b / this._granularityCellSize),
                G = Math.ceil(I / this._granularityCellSize);
              if (L !== B || U !== G)
                for (let K = U; K < G; K++) {
                  const ne = this._scanlineGenerateVertexRingForCellRow(K, m, _);
                  Jy(this._vertexBuffer, ne, n)
                } else n.push(..._)
            }
            return n
          }
          _scanlineGenerateVertexRingForCellRow(t, n, o) {
            const u = t * this._granularityCellSize,
              _ = u + this._granularityCellSize,
              m = [];
            for (let y = 0; y < 3; y++) {
              const b = n[2 * y],
                P = n[2 * y + 1],
                I = n[2 * (y + 1) % 6],
                L = n[(2 * (y + 1) + 1) % 6],
                B = n[2 * (y + 2) % 6],
                U = n[(2 * (y + 2) + 1) % 6],
                G = I - b,
                K = L - P,
                ne = G === 0,
                pe = K === 0,
                Ze = (u - P) / K,
                ye = (_ - P) / K,
                ze = Math.min(Ze, ye),
                at = Math.max(Ze, ye);
              if (!pe && (ze >= 1 || at <= 0) || pe && (P < u || P > _)) {
                L >= u && L <= _ && m.push(o[(y + 1) % 3]);
                continue
              }!pe && ze > 0 && m.push(this._vertexToIndex(b + G * ze, P + K * ze));
              const gt = b + G * Math.max(ze, 0),
                Ht = b + G * Math.min(at, 1);
              ne || this._generateIntraEdgeVertices(m, b, P, I, L, gt, Ht), !pe && at < 1 && m.push(this._vertexToIndex(b + G * at, P + K * at)), (pe || L >= u && L <= _) && m.push(o[(y + 1) % 3]), !pe && (L <= u || L >= _) && this._generateInterEdgeVertices(m, b, P, I, L, B, U, Ht, u, _)
            }
            return m
          }
          _generateIntraEdgeVertices(t, n, o, u, _, m, y) {
            const b = u - n,
              P = _ - o,
              I = P === 0,
              L = I ? Math.min(n, u) : Math.min(m, y),
              B = I ? Math.max(n, u) : Math.max(m, y),
              U = Math.floor(L / this._granularityCellSize) + 1,
              G = Math.ceil(B / this._granularityCellSize) - 1;
            if (I ? n < u : m < y)
              for (let K = U; K <= G; K++) {
                const ne = K * this._granularityCellSize;
                t.push(this._vertexToIndex(ne, o + P * (ne - n) / b))
              } else
                for (let K = G; K >= U; K--) {
                  const ne = K * this._granularityCellSize;
                  t.push(this._vertexToIndex(ne, o + P * (ne - n) / b))
                }
          }
          _generateInterEdgeVertices(t, n, o, u, _, m, y, b, P, I) {
            const L = _ - o,
              B = m - u,
              U = y - _,
              G = (P - _) / U,
              K = (I - _) / U,
              ne = Math.min(G, K),
              pe = Math.max(G, K),
              Ze = u + B * ne;
            let ye = Math.floor(Math.min(Ze, b) / this._granularityCellSize) + 1,
              ze = Math.ceil(Math.max(Ze, b) / this._granularityCellSize) - 1,
              at = b < Ze;
            const gt = U === 0;
            if (gt && (y === P || y === I)) return;
            if (gt || ne >= 1 || pe <= 0) {
              const xr = o - y,
                dr = m + (n - m) * Math.min((P - y) / xr, (I - y) / xr);
              ye = Math.floor(Math.min(dr, b) / this._granularityCellSize) + 1, ze = Math.ceil(Math.max(dr, b) / this._granularityCellSize) - 1, at = b < dr
            }
            const Ht = L > 0 ? I : P;
            if (at)
              for (let xr = ye; xr <= ze; xr++) t.push(this._vertexToIndex(xr * this._granularityCellSize, Ht));
            else
              for (let xr = ze; xr >= ye; xr--) t.push(this._vertexToIndex(xr * this._granularityCellSize, Ht))
          }
          _generateOutline(t) {
            const n = [];
            for (const o of t) {
              const u = ll(o, this._granularity, !0),
                _ = this._pointArrayToIndices(u),
                m = [];
              for (let y = 1; y < _.length; y++) m.push(_[y - 1]), m.push(_[y]);
              n.push(m)
            }
            return n
          }
          _handlePoles(t) {
            let n = !1,
              o = !1;
            this._canonical && (this._canonical.y === 0 && (n = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (o = !0)), (n || o) && this._fillPoles(t, n, o)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const o = t[n + 1];
              o === oc && (t[n + 1] = -32767), o === Du && (t[n + 1] = 32766)
            }
          }
          _generatePoleQuad(t, n, o, u, _, m) {
            u > _ != (m === oc) ? (t.push(n), t.push(o), t.push(this._vertexToIndex(u, m)), t.push(o), t.push(this._vertexToIndex(_, m)), t.push(this._vertexToIndex(u, m))) : (t.push(o), t.push(n), t.push(this._vertexToIndex(u, m)), t.push(this._vertexToIndex(_, m)), t.push(o), t.push(this._vertexToIndex(u, m)))
          }
          _fillPoles(t, n, o) {
            const u = this._vertexBuffer,
              _ = lt,
              m = t.length;
            for (let y = 2; y < m; y += 3) {
              const b = t[y - 2],
                P = t[y - 1],
                I = t[y],
                L = u[2 * b],
                B = u[2 * b + 1],
                U = u[2 * P],
                G = u[2 * P + 1],
                K = u[2 * I],
                ne = u[2 * I + 1];
              n && (B === 0 && G === 0 && this._generatePoleQuad(t, b, P, L, U, oc), G === 0 && ne === 0 && this._generatePoleQuad(t, P, I, U, K, oc), ne === 0 && B === 0 && this._generatePoleQuad(t, I, b, K, L, oc)), o && (B === _ && G === _ && this._generatePoleQuad(t, b, P, L, U, Du), G === _ && ne === _ && this._generatePoleQuad(t, P, I, U, K, Du), ne === _ && B === _ && this._generatePoleQuad(t, I, b, K, L, Du))
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1])
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: o,
              holeIndices: u
            } = (function(y) {
              const b = [],
                P = [];
              for (const I of y)
                if (I.length !== 0) {
                  I !== y[0] && b.push(P.length / 2);
                  for (let L = 0; L < I.length; L++) P.push(I[L].x), P.push(I[L].y)
                } return {
                flattened: P,
                holeIndices: b
              }
            })(t);
            let _;
            this._initializeVertices(o);
            try {
              const y = (function(P, I, L = 2) {
                  const B = I && I.length,
                    U = B ? I[0] * L : P.length;
                  let G = qm(P, 0, U, L, !0);
                  const K = [];
                  if (!G || G.next === G.prev) return K;
                  let ne, pe, Ze;
                  if (B && (G = (function(ye, ze, at, gt) {
                      const Ht = [];
                      for (let xr = 0, dr = ze.length; xr < dr; xr++) {
                        const vr = qm(ye, ze[xr] * gt, xr < dr - 1 ? ze[xr + 1] * gt : ye.length, gt, !1);
                        vr === vr.next && (vr.steiner = !0), Ht.push(Xy(vr))
                      }
                      Ht.sort(Wy);
                      for (let xr = 0; xr < Ht.length; xr++) at = Hy(Ht[xr], at);
                      return at
                    })(P, I, G, L)), P.length > 80 * L) {
                    ne = P[0], pe = P[1];
                    let ye = ne,
                      ze = pe;
                    for (let at = L; at < U; at += L) {
                      const gt = P[at],
                        Ht = P[at + 1];
                      gt < ne && (ne = gt), Ht < pe && (pe = Ht), gt > ye && (ye = gt), Ht > ze && (ze = Ht)
                    }
                    Ze = Math.max(ye - ne, ze - pe), Ze = Ze !== 0 ? 32767 / Ze : 0
                  }
                  return zu(G, K, L, ne, pe, Ze, 0), K
                })(o, u),
                b = this._convertIndices(o, y);
              _ = this._subdivideTrianglesScanline(b)
            } catch (y) {
              console.error(y)
            }
            let m = [];
            return n && (m = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(_), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: _,
              indicesLineList: m
            }
          }
          _convertIndices(t, n) {
            const o = [];
            for (let u = 0; u < n.length; u++) o.push(this._vertexToIndex(t[2 * n[u]], t[2 * n[u] + 1]));
            return o
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let o = 0; o < t.length; o++) {
              const u = t[o];
              n.push(this._vertexToIndex(u.x, u.y))
            }
            return n
          }
        }

        function Gm(i, t, n, o = !0) {
          return new Ky(n, t).subdividePolygonInternal(i, o)
        }

        function ll(i, t, n = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const o = i[0],
            u = i[i.length - 1],
            _ = n && (o.x !== u.x || o.y !== u.y);
          if (t < 2) return _ ? [...i, i[0]] : [...i];
          const m = Math.floor(lt / t),
            y = [];
          y.push(new F(i[0].x, i[0].y));
          const b = i.length,
            P = _ ? b : b - 1;
          for (let I = 0; I < P; I++) {
            const L = i[I],
              B = I < b - 1 ? i[I + 1] : i[0],
              U = L.x,
              G = L.y,
              K = B.x,
              ne = B.y,
              pe = U !== K,
              Ze = G !== ne;
            if (!pe && !Ze) continue;
            const ye = K - U,
              ze = ne - G,
              at = Math.abs(ye),
              gt = Math.abs(ze);
            let Ht = U,
              xr = G;
            for (;;) {
              const vr = ye > 0 ? (Math.floor(Ht / m) + 1) * m : (Math.ceil(Ht / m) - 1) * m,
                en = ze > 0 ? (Math.floor(xr / m) + 1) * m : (Math.ceil(xr / m) - 1) * m,
                gr = Math.abs(Ht - vr),
                yr = Math.abs(xr - en),
                Lt = Math.abs(Ht - K),
                hn = Math.abs(xr - ne),
                _n = pe ? gr / at : Number.POSITIVE_INFINITY,
                on = Ze ? yr / gt : Number.POSITIVE_INFINITY;
              if ((Lt <= gr || !pe) && (hn <= yr || !Ze)) break;
              if (_n < on && pe || !Ze) {
                Ht = vr, xr += ze * _n;
                const $r = new F(Ht, Math.round(xr));
                y[y.length - 1].x === $r.x && y[y.length - 1].y === $r.y || y.push($r)
              } else {
                Ht += ye * on, xr = en;
                const $r = new F(Math.round(Ht), xr);
                y[y.length - 1].x === $r.x && y[y.length - 1].y === $r.y || y.push($r)
              }
            }
            const dr = new F(K, ne);
            y[y.length - 1].x === dr.x && y[y.length - 1].y === dr.y || y.push(dr)
          }
          return y
        }

        function Jy(i, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let o = 0,
            u = i[2 * t[0]];
          for (let b = 1; b < t.length; b++) {
            const P = i[2 * t[b]];
            P < u && (u = P, o = b)
          }
          const _ = t.length;
          let m = o,
            y = (m + 1) % _;
          for (;;) {
            const b = m - 1 >= 0 ? m - 1 : _ - 1,
              P = (y + 1) % _,
              I = i[2 * t[b]],
              L = i[2 * t[P]],
              B = i[2 * t[m]],
              U = i[2 * t[m] + 1],
              G = i[2 * t[y] + 1];
            let K = !1;
            if (I < L) K = !0;
            else if (I > L) K = !1;
            else {
              const ne = G - U,
                pe = -(i[2 * t[y]] - B),
                Ze = U < G ? 1 : -1;
              ((I - B) * ne + (i[2 * t[b] + 1] - U) * pe) * Ze > ((L - B) * ne + (i[2 * t[P] + 1] - U) * pe) * Ze && (K = !0)
            }
            if (K) {
              const ne = t[b],
                pe = t[m],
                Ze = t[y];
              ne !== pe && ne !== Ze && pe !== Ze && n.push(Ze, pe, ne), m--, m < 0 && (m = _ - 1)
            } else {
              const ne = t[P],
                pe = t[m],
                Ze = t[y];
              ne !== pe && ne !== Ze && pe !== Ze && n.push(Ze, pe, ne), y++, y >= _ && (y = 0)
            }
            if (b === P) break
          }
        }

        function Wm(i, t, n, o, u, _, m, y, b) {
          const P = u.length / 2,
            I = m && y && b;
          if (P < zn.MAX_VERTEX_ARRAY_LENGTH) {
            const L = t.prepareSegment(P, n, o),
              B = L.vertexLength;
            for (let K = 0; K < _.length; K += 3) o.emplaceBack(B + _[K], B + _[K + 1], B + _[K + 2]);
            let U, G;
            L.vertexLength += P, L.primitiveLength += _.length / 3, I && (G = m.prepareSegment(P, n, y), U = G.vertexLength, G.vertexLength += P);
            for (let K = 0; K < u.length; K += 2) i(u[K], u[K + 1]);
            if (I)
              for (let K = 0; K < b.length; K++) {
                const ne = b[K];
                for (let pe = 1; pe < ne.length; pe += 2) y.emplaceBack(U + ne[pe - 1], U + ne[pe]);
                G.primitiveLength += ne.length / 2
              }
          } else(function(L, B, U, G, K, ne) {
            const pe = [];
            for (let gt = 0; gt < G.length / 2; gt++) pe.push(-1);
            const Ze = {
              count: 0
            };
            let ye = 0,
              ze = L.getOrCreateLatestSegment(B, U),
              at = ze.vertexLength;
            for (let gt = 2; gt < K.length; gt += 3) {
              const Ht = K[gt - 2],
                xr = K[gt - 1],
                dr = K[gt];
              let vr = pe[Ht] < ye,
                en = pe[xr] < ye,
                gr = pe[dr] < ye;
              ze.vertexLength + ((vr ? 1 : 0) + (en ? 1 : 0) + (gr ? 1 : 0)) > zn.MAX_VERTEX_ARRAY_LENGTH && (ze = L.createNewSegment(B, U), ye = Ze.count, vr = !0, en = !0, gr = !0, at = 0);
              const yr = Ru(pe, G, ne, Ze, Ht, vr, ze),
                Lt = Ru(pe, G, ne, Ze, xr, en, ze),
                hn = Ru(pe, G, ne, Ze, dr, gr, ze);
              U.emplaceBack(at + yr - ye, at + Lt - ye, at + hn - ye), ze.primitiveLength++
            }
          })(t, n, o, u, _, i), I && (function(L, B, U, G, K, ne) {
            const pe = [];
            for (let gt = 0; gt < G.length / 2; gt++) pe.push(-1);
            const Ze = {
              count: 0
            };
            let ye = 0,
              ze = L.getOrCreateLatestSegment(B, U),
              at = ze.vertexLength;
            for (let gt = 0; gt < K.length; gt++) {
              const Ht = K[gt];
              for (let xr = 1; xr < K[gt].length; xr += 2) {
                const dr = Ht[xr - 1],
                  vr = Ht[xr];
                let en = pe[dr] < ye,
                  gr = pe[vr] < ye;
                ze.vertexLength + ((en ? 1 : 0) + (gr ? 1 : 0)) > zn.MAX_VERTEX_ARRAY_LENGTH && (ze = L.createNewSegment(B, U), ye = Ze.count, en = !0, gr = !0, at = 0);
                const yr = Ru(pe, G, ne, Ze, dr, en, ze),
                  Lt = Ru(pe, G, ne, Ze, vr, gr, ze);
                U.emplaceBack(at + yr - ye, at + Lt - ye), ze.primitiveLength++
              }
            }
          })(m, n, y, u, b, i), t.forceNewSegmentOnNextPrepare(), m == null || m.forceNewSegmentOnNextPrepare()
        }

        function Ru(i, t, n, o, u, _, m) {
          if (_) {
            const y = o.count;
            return n(t[2 * u], t[2 * u + 1]), i[u] = o.count, o.count++, m.vertexLength++, y
          }
          return i[u]
        }
        class mf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new fe, this.indexArray = new Bt, this.indexArray2 = new Nr, this.programConfigurations = new rs(t.layers, t.zoom), this.segments = new zn, this.segments2 = new zn, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            this.hasDependencies = Dd("fill", this.layers, n);
            const u = this.layers[0].layout.get("fill-sort-key"),
              _ = !u.isConstant(),
              m = [];
            for (const {
                feature: y,
                id: b,
                index: P,
                sourceLayerIndex: I
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                B = zo(y, L);
              if (!this.layers[0]._featureFilter.filter(new ei(this.zoom), B, o)) continue;
              const U = _ ? u.evaluate(B, {}, o, n.availableImages) : void 0,
                G = {
                  id: b,
                  properties: y.properties,
                  type: y.type,
                  sourceLayerIndex: I,
                  index: P,
                  geometry: L ? B.geometry : go(y),
                  patterns: {},
                  sortKey: U
                };
              m.push(G)
            }
            _ && m.sort(((y, b) => y.sortKey - b.sortKey));
            for (const y of m) {
              const {
                geometry: b,
                index: P,
                sourceLayerIndex: I
              } = y;
              if (this.hasDependencies) {
                const L = pf("fill", this.layers, y, {
                  zoom: this.zoom
                }, n);
                this.patternFeatures.push(L)
              } else this.addFeature(y, b, P, o, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[P].feature, b, P, I, this.index)
            }
          }
          update(t, n, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          addFeatures(t, n, o) {
            for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, o, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ny), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, n, o, u, _, m) {
            for (const y of Pl(n, 500)) {
              const b = Gm(y, u, m.fill.getGranularityForZoomLevel(u.z)),
                P = this.layoutVertexArray;
              Wm(((I, L) => {
                P.emplaceBack(I, L)
              }), this.segments, this.layoutVertexArray, this.indexArray, b.verticesFlattened, b.indicesTriangles, this.segments2, this.indexArray2, b.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: _,
              canonical: u
            })
          }
        }
        let Hm, $m;
        Mr("FillBucket", mf, {
          omit: ["layers", "patternFeatures"]
        });
        var Qy = {
          get paint() {
            return $m = $m || new oa({
              "fill-antialias": new Xr(J.paint_fill["fill-antialias"]),
              "fill-opacity": new ln(J.paint_fill["fill-opacity"]),
              "fill-color": new ln(J.paint_fill["fill-color"]),
              "fill-outline-color": new ln(J.paint_fill["fill-outline-color"]),
              "fill-translate": new Xr(J.paint_fill["fill-translate"]),
              "fill-translate-anchor": new Xr(J.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new nl(J.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return Hm = Hm || new oa({
              "fill-sort-key": new ln(J.layout_fill["fill-sort-key"])
            })
          }
        };
        class eb extends Ga {
          constructor(t, n) {
            super(t, Qy, n)
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const o = this.paint._values["fill-outline-color"];
            o.value.kind === "constant" && o.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new mf(t)
          }
          queryRadius() {
            return Ed(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: n,
            transform: o,
            pixelsToTileUnits: u
          }) {
            return Pm(Ld(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -o.bearingInRadians, u), n)
          }
          isTileClipped() {
            return !0
          }
        }
        const tb = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          rb = wi([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: nb
          } = tb;
        class sc {
          constructor(t, n, o, u, _) {
            this.properties = {}, this.extent = o, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = u, this._values = _, t.readFields(ib, this, n)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos,
              o = [];
            let u, _ = 1,
              m = 0,
              y = 0,
              b = 0;
            for (; t.pos < n;) {
              if (m <= 0) {
                const P = t.readVarint();
                _ = 7 & P, m = P >> 3
              }
              if (m--, _ === 1 || _ === 2) y += t.readSVarint(), b += t.readSVarint(), _ === 1 && (u && o.push(u), u = []), u && u.push(new F(y, b));
              else {
                if (_ !== 7) throw new Error(`unknown command ${_}`);
                u && u.push(u[0].clone())
              }
            }
            return u && o.push(u), o
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos;
            let o = 1,
              u = 0,
              _ = 0,
              m = 0,
              y = 1 / 0,
              b = -1 / 0,
              P = 1 / 0,
              I = -1 / 0;
            for (; t.pos < n;) {
              if (u <= 0) {
                const L = t.readVarint();
                o = 7 & L, u = L >> 3
              }
              if (u--, o === 1 || o === 2) _ += t.readSVarint(), m += t.readSVarint(), _ < y && (y = _), _ > b && (b = _), m < P && (P = m), m > I && (I = m);
              else if (o !== 7) throw new Error(`unknown command ${o}`)
            }
            return [y, P, b, I]
          }
          toGeoJSON(t, n, o) {
            const u = this.extent * Math.pow(2, o),
              _ = this.extent * t,
              m = this.extent * n,
              y = this.loadGeometry();

            function b(B) {
              return [360 * (B.x + _) / u - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (B.y + m) / u) * Math.PI)) - 90]
            }

            function P(B) {
              return B.map(b)
            }
            let I;
            if (this.type === 1) {
              const B = [];
              for (const G of y) B.push(G[0]);
              const U = P(B);
              I = B.length === 1 ? {
                type: "Point",
                coordinates: U[0]
              } : {
                type: "MultiPoint",
                coordinates: U
              }
            } else if (this.type === 2) {
              const B = y.map(P);
              I = B.length === 1 ? {
                type: "LineString",
                coordinates: B[0]
              } : {
                type: "MultiLineString",
                coordinates: B
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const B = (function(G) {
                    const K = G.length;
                    if (K <= 1) return [G];
                    const ne = [];
                    let pe, Ze;
                    for (let ye = 0; ye < K; ye++) {
                      const ze = ab(G[ye]);
                      ze !== 0 && (Ze === void 0 && (Ze = ze < 0), Ze === ze < 0 ? (pe && ne.push(pe), pe = [G[ye]]) : pe && pe.push(G[ye]))
                    }
                    return pe && ne.push(pe), ne
                  })(y),
                  U = [];
                for (const G of B) U.push(G.map(P));
                I = U.length === 1 ? {
                  type: "Polygon",
                  coordinates: U[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: U
                }
              }
            }
            const L = {
              type: "Feature",
              geometry: I,
              properties: this.properties
            };
            return this.id != null && (L.id = this.id), L
          }
        }

        function ib(i, t, n) {
          i === 1 ? t.id = n.readVarint() : i === 2 ? (function(o, u) {
            const _ = o.readVarint() + o.pos;
            for (; o.pos < _;) {
              const m = u._keys[o.readVarint()],
                y = u._values[o.readVarint()];
              u.properties[m] = y
            }
          })(n, t) : i === 3 ? t.type = n.readVarint() : i === 4 && (t._geometry = n.pos)
        }

        function ab(i) {
          let t = 0;
          for (let n, o, u = 0, _ = i.length, m = _ - 1; u < _; m = u++) n = i[u], o = i[m], t += (o.x - n.x) * (n.y + o.y);
          return t
        }
        sc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Xm {
          constructor(t, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(ob, this, n), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new sc(this._pbf, n, this.extent, this._keys, this._values)
          }
        }

        function ob(i, t, n) {
          i === 15 ? t.version = n.readVarint() : i === 1 ? t.name = n.readString() : i === 5 ? t.extent = n.readVarint() : i === 2 ? t._features.push(n.pos) : i === 3 ? t._keys.push(n.readString()) : i === 4 && t._values.push((function(o) {
            let u = null;
            const _ = o.readVarint() + o.pos;
            for (; o.pos < _;) {
              const m = o.readVarint() >> 3;
              u = m === 1 ? o.readString() : m === 2 ? o.readFloat() : m === 3 ? o.readDouble() : m === 4 ? o.readVarint64() : m === 5 ? o.readVarint() : m === 6 ? o.readSVarint() : m === 7 ? o.readBoolean() : null
            }
            if (u == null) throw new Error("unknown feature value");
            return u
          })(n))
        }
        class Ym {
          constructor(t, n) {
            this.layers = t.readFields(sb, {}, n)
          }
        }

        function sb(i, t, n) {
          if (i === 3) {
            const o = new Xm(n, n.readVarint() + n.pos);
            o.length && (t[o.name] = o)
          }
        }
        const gf = Math.pow(2, 13);

        function ju(i, t, n, o, u, _, m, y) {
          i.emplaceBack(t, n, 2 * Math.floor(o * gf) + m, u * gf * 2, _ * gf * 2, Math.round(y))
        }
        class vf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Pe, this.centroidVertexArray = new me, this.indexArray = new Bt, this.programConfigurations = new rs(t.layers, t.zoom), this.segments = new zn, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            this.features = [], this.hasDependencies = Dd("fill-extrusion", this.layers, n);
            for (const {
                feature: u,
                id: _,
                index: m,
                sourceLayerIndex: y
              }
              of t) {
              const b = this.layers[0]._featureFilter.needGeometry,
                P = zo(u, b);
              if (!this.layers[0]._featureFilter.filter(new ei(this.zoom), P, o)) continue;
              const I = {
                id: _,
                sourceLayerIndex: y,
                index: m,
                geometry: b ? P.geometry : go(u),
                properties: u.properties,
                type: u.type,
                patterns: {}
              };
              this.hasDependencies ? this.features.push(pf("fill-extrusion", this.layers, I, {
                zoom: this.zoom
              }, n)) : this.addFeature(I, I.geometry, m, o, {}, n.subdivisionGranularity), n.featureIndex.insert(u, I.geometry, m, y, this.index, !0)
            }
          }
          addFeatures(t, n, o) {
            for (const u of this.features) {
              const {
                geometry: _
              } = u;
              this.addFeature(u, _, u.index, n, o, t.subdivisionGranularity)
            }
          }
          update(t, n, o) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, nb), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, rb.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, n, o, u, _, m) {
            for (const y of Pl(n, 500)) {
              const b = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                P = this.layoutVertexArray.length;
              this.processPolygon(b, u, t, y, m);
              const I = this.layoutVertexArray.length - P,
                L = Math.floor(b.x / b.sampleCount),
                B = Math.floor(b.y / b.sampleCount);
              for (let U = 0; U < I; U++) this.centroidVertexArray.emplaceBack(L, B)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: _,
              canonical: u
            })
          }
          processPolygon(t, n, o, u, _) {
            if (u.length < 1 || Km(u[0])) return;
            for (const L of u) L.length !== 0 && lb(t, L);
            const m = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              y = _.fill.getGranularityForZoomLevel(n.z),
              b = sc.types[o.type] === "Polygon";
            for (const L of u) {
              if (L.length === 0 || Km(L)) continue;
              const B = ll(L, y, b);
              this._generateSideFaces(B, m)
            }
            if (!b) return;
            const P = Gm(u, n, y, !1),
              I = this.layoutVertexArray;
            Wm(((L, B) => {
              ju(I, L, B, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, P.verticesFlattened, P.indicesTriangles)
          }
          _generateSideFaces(t, n) {
            let o = 0;
            for (let u = 1; u < t.length; u++) {
              const _ = t[u],
                m = t[u - 1];
              if (cb(_, m)) continue;
              n.segment.vertexLength + 4 > zn.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const y = _.sub(m)._perp()._unit(),
                b = m.dist(_);
              o + b > 32768 && (o = 0), ju(this.layoutVertexArray, _.x, _.y, y.x, y.y, 0, 0, o), ju(this.layoutVertexArray, _.x, _.y, y.x, y.y, 0, 1, o), o += b, ju(this.layoutVertexArray, m.x, m.y, y.x, y.y, 0, 0, o), ju(this.layoutVertexArray, m.x, m.y, y.x, y.y, 0, 1, o);
              const P = n.segment.vertexLength;
              this.indexArray.emplaceBack(P, P + 2, P + 1), this.indexArray.emplaceBack(P + 1, P + 2, P + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2
            }
          }
        }

        function lb(i, t) {
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            n === t.length - 1 && t[0].x === o.x && t[0].y === o.y || (i.x += o.x, i.y += o.y, i.sampleCount++)
          }
        }

        function cb(i, t) {
          return i.x === t.x && (i.x < 0 || i.x > lt) || i.y === t.y && (i.y < 0 || i.y > lt)
        }

        function Km(i) {
          return i.every((t => t.x < 0)) || i.every((t => t.x > lt)) || i.every((t => t.y < 0)) || i.every((t => t.y > lt))
        }
        let Jm;
        Mr("FillExtrusionBucket", vf, {
          omit: ["layers", "features"]
        });
        var ub = {
          get paint() {
            return Jm = Jm || new oa({
              "fill-extrusion-opacity": new Xr(J["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new ln(J["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new Xr(J["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new Xr(J["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new nl(J["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new ln(J["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new ln(J["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new Xr(J["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class hb extends Ga {
          constructor(t, n) {
            super(t, ub, n)
          }
          createBucket(t) {
            return new vf(t)
          }
          queryRadius() {
            return Ed(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m,
            pixelPosMatrix: y
          }) {
            const b = Ld(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -_.bearingInRadians, m),
              P = this.paint.get("fill-extrusion-height").evaluate(n, o),
              I = this.paint.get("fill-extrusion-base").evaluate(n, o),
              L = (function(U, G) {
                const K = [];
                for (const ne of U) {
                  const pe = [ne.x, ne.y, 0, 1];
                  We(pe, pe, G), K.push(new F(pe[0] / pe[3], pe[1] / pe[3]))
                }
                return K
              })(b, y),
              B = (function(U, G, K, ne) {
                const pe = [],
                  Ze = [],
                  ye = ne[8] * G,
                  ze = ne[9] * G,
                  at = ne[10] * G,
                  gt = ne[11] * G,
                  Ht = ne[8] * K,
                  xr = ne[9] * K,
                  dr = ne[10] * K,
                  vr = ne[11] * K;
                for (const en of U) {
                  const gr = [],
                    yr = [];
                  for (const Lt of en) {
                    const hn = Lt.x,
                      _n = Lt.y,
                      on = ne[0] * hn + ne[4] * _n + ne[12],
                      $r = ne[1] * hn + ne[5] * _n + ne[13],
                      Bn = ne[2] * hn + ne[6] * _n + ne[14],
                      bi = ne[3] * hn + ne[7] * _n + ne[15],
                      Fi = Bn + at,
                      la = bi + gt,
                      $a = on + Ht,
                      Sa = $r + xr,
                      Qi = Bn + dr,
                      gi = bi + vr,
                      Wi = new F((on + ye) / la, ($r + ze) / la);
                    Wi.z = Fi / la, gr.push(Wi);
                    const ea = new F($a / gi, Sa / gi);
                    ea.z = Qi / gi, yr.push(ea)
                  }
                  pe.push(gr), Ze.push(yr)
                }
                return [pe, Ze]
              })(u, I, P, y);
            return (function(U, G, K) {
              let ne = 1 / 0;
              Pm(K, G) && (ne = Qm(K, G[0]));
              for (let pe = 0; pe < G.length; pe++) {
                const Ze = G[pe],
                  ye = U[pe];
                for (let ze = 0; ze < Ze.length - 1; ze++) {
                  const at = Ze[ze],
                    gt = [at, Ze[ze + 1], ye[ze + 1], ye[ze], at];
                  Sm(K, gt) && (ne = Math.min(ne, Qm(K, gt)))
                }
              }
              return ne !== 1 / 0 && ne
            })(B[0], B[1], L)
          }
        }

        function Fu(i, t) {
          return i.x * t.x + i.y * t.y
        }

        function Qm(i, t) {
          if (i.length === 1) {
            let n = 0;
            const o = t[n++];
            let u;
            for (; !u || o.equals(u);)
              if (u = t[n++], !u) return 1 / 0;
            for (; n < t.length; n++) {
              const _ = t[n],
                m = i[0],
                y = u.sub(o),
                b = _.sub(o),
                P = m.sub(o),
                I = Fu(y, y),
                L = Fu(y, b),
                B = Fu(b, b),
                U = Fu(P, y),
                G = Fu(P, b),
                K = I * B - L * L,
                ne = (B * U - L * G) / K,
                pe = (I * G - L * U) / K,
                Ze = o.z * (1 - ne - pe) + u.z * ne + _.z * pe;
              if (isFinite(Ze)) return Ze
            }
            return 1 / 0
          } {
            let n = 1 / 0;
            for (const o of t) n = Math.min(n, o.z);
            return n
          }
        }
        const db = wi([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: pb
          } = db,
          fb = wi([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: _b
          } = fb,
          mb = Math.cos(Math.PI / 180 * 37.5),
          eg = Math.pow(2, 14) / .5;
        class yf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n => n.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n => {
              this.gradients[n.id] = {}
            })), this.layoutVertexArray = new Ae, this.layoutVertexArray2 = new ve, this.indexArray = new Bt, this.programConfigurations = new rs(t.layers, t.zoom), this.segments = new zn, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(t, n, o) {
            this.hasDependencies = Dd("line", this.layers, n) || this.hasLineDasharray(this.layers);
            const u = this.layers[0].layout.get("line-sort-key"),
              _ = !u.isConstant(),
              m = [];
            for (const {
                feature: y,
                id: b,
                index: P,
                sourceLayerIndex: I
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                B = zo(y, L);
              if (!this.layers[0]._featureFilter.filter(new ei(this.zoom), B, o)) continue;
              const U = _ ? u.evaluate(B, {}, o) : void 0,
                G = {
                  id: b,
                  properties: y.properties,
                  type: y.type,
                  sourceLayerIndex: I,
                  index: P,
                  geometry: L ? B.geometry : go(y),
                  patterns: {},
                  dashes: {},
                  sortKey: U
                };
              m.push(G)
            }
            _ && m.sort(((y, b) => y.sortKey - b.sortKey));
            for (const y of m) {
              const {
                geometry: b,
                index: P,
                sourceLayerIndex: I
              } = y;
              this.hasDependencies ? (Dd("line", this.layers, n) ? pf("line", this.layers, y, {
                zoom: this.zoom
              }, n) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, y, this.zoom, n), this.patternFeatures.push(y)) : this.addFeature(y, b, P, o, {}, {}, n.subdivisionGranularity), n.featureIndex.insert(t[P].feature, b, P, I, this.index)
            }
          }
          update(t, n, o, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, {
              imagePositions: o,
              dashPositions: u
            })
          }
          addFeatures(t, n, o, u) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, n, o, u, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, _b)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, pb), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, n, o, u, _, m, y) {
            const b = this.layers[0].layout,
              P = b.get("line-join").evaluate(t, {}),
              I = b.get("line-cap"),
              L = b.get("line-miter-limit"),
              B = b.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const U of n) this.addLine(U, t, P, I, L, B, u, y);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {
              imagePositions: _,
              dashPositions: m,
              canonical: u
            })
          }
          addLine(t, n, o, u, _, m, y, b) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ll(t, y ? b.line.getGranularityForZoomLevel(y.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ye = 0; ye < t.length - 1; ye++) this.totalDistance += t[ye].dist(t[ye + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const P = sc.types[n.type] === "Polygon";
            let I = t.length;
            for (; I >= 2 && t[I - 1].equals(t[I - 2]);) I--;
            let L = 0;
            for (; L < I - 1 && t[L].equals(t[L + 1]);) L++;
            if (I < (P ? 3 : 2)) return;
            o === "bevel" && (_ = 1.05);
            const B = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              U = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
            let G, K, ne, pe, Ze;
            this.e1 = this.e2 = -1, P && (G = t[I - 2], Ze = t[L].sub(G)._unit()._perp());
            for (let ye = L; ye < I; ye++) {
              if (ne = ye === I - 1 ? P ? t[L + 1] : void 0 : t[ye + 1], ne && t[ye].equals(ne)) continue;
              Ze && (pe = Ze), G && (K = G), G = t[ye], Ze = ne ? ne.sub(G)._unit()._perp() : pe, pe = pe || Ze;
              let ze = pe.add(Ze);
              ze.x === 0 && ze.y === 0 || ze._unit();
              const at = pe.x * Ze.x + pe.y * Ze.y,
                gt = ze.x * Ze.x + ze.y * Ze.y,
                Ht = gt !== 0 ? 1 / gt : 1 / 0,
                xr = 2 * Math.sqrt(2 - 2 * gt),
                dr = gt < mb && K && ne,
                vr = pe.x * Ze.y - pe.y * Ze.x > 0;
              if (dr && ye > L) {
                const yr = G.dist(K);
                if (yr > 2 * B) {
                  const Lt = G.sub(G.sub(K)._mult(B / yr)._round());
                  this.updateDistance(K, Lt), this.addCurrentVertex(Lt, pe, 0, 0, U), K = Lt
                }
              }
              const en = K && ne;
              let gr = en ? o : P ? "butt" : u;
              if (en && gr === "round" && (Ht < m ? gr = "miter" : Ht <= 2 && (gr = "fakeround")), gr === "miter" && Ht > _ && (gr = "bevel"), gr === "bevel" && (Ht > 2 && (gr = "flipbevel"), Ht < _ && (gr = "miter")), K && this.updateDistance(K, G), gr === "miter") ze._mult(Ht), this.addCurrentVertex(G, ze, 0, 0, U);
              else if (gr === "flipbevel") {
                if (Ht > 100) ze = Ze.mult(-1);
                else {
                  const yr = Ht * pe.add(Ze).mag() / pe.sub(Ze).mag();
                  ze._perp()._mult(yr * (vr ? -1 : 1))
                }
                this.addCurrentVertex(G, ze, 0, 0, U), this.addCurrentVertex(G, ze.mult(-1), 0, 0, U)
              } else if (gr === "bevel" || gr === "fakeround") {
                const yr = -Math.sqrt(Ht * Ht - 1),
                  Lt = vr ? yr : 0,
                  hn = vr ? 0 : yr;
                if (K && this.addCurrentVertex(G, pe, Lt, hn, U), gr === "fakeround") {
                  const _n = Math.round(180 * xr / Math.PI / 20);
                  for (let on = 1; on < _n; on++) {
                    let $r = on / _n;
                    if ($r !== .5) {
                      const bi = $r - .5;
                      $r += $r * bi * ($r - 1) * ((1.0904 + at * (at * (3.55645 - 1.43519 * at) - 3.2452)) * bi * bi + (.848013 + at * (.215638 * at - 1.06021)))
                    }
                    const Bn = Ze.sub(pe)._mult($r)._add(pe)._unit()._mult(vr ? -1 : 1);
                    this.addHalfVertex(G, Bn.x, Bn.y, !1, vr, 0, U)
                  }
                }
                ne && this.addCurrentVertex(G, Ze, -Lt, -hn, U)
              } else if (gr === "butt") this.addCurrentVertex(G, ze, 0, 0, U);
              else if (gr === "square") {
                const yr = K ? 1 : -1;
                this.addCurrentVertex(G, ze, yr, yr, U)
              } else gr === "round" && (K && (this.addCurrentVertex(G, pe, 0, 0, U), this.addCurrentVertex(G, pe, 1, 1, U, !0)), ne && (this.addCurrentVertex(G, Ze, -1, -1, U, !0), this.addCurrentVertex(G, Ze, 0, 0, U)));
              if (dr && ye < I - 1) {
                const yr = G.dist(ne);
                if (yr > 2 * B) {
                  const Lt = G.add(ne.sub(G)._mult(B / yr)._round());
                  this.updateDistance(G, Lt), this.addCurrentVertex(Lt, Ze, 0, 0, U), G = Lt
                }
              }
            }
          }
          addCurrentVertex(t, n, o, u, _, m = !1) {
            const y = n.y * u - n.x,
              b = -n.y - n.x * u;
            this.addHalfVertex(t, n.x + n.y * o, n.y - n.x * o, m, !1, o, _), this.addHalfVertex(t, y, b, m, !0, -u, _), this.distance > eg / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, o, u, _, m))
          }
          addHalfVertex({
            x: t,
            y: n
          }, o, u, _, m, y, b) {
            const P = .5 * (this.lineClips ? this.scaledDistance * (eg - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (_ ? 1 : 0), (n << 1) + (m ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * u) + 128, 1 + (y === 0 ? 0 : y < 0 ? -1 : 1) | (63 & P) << 2, P >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const I = b.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2), b.primitiveLength++), m ? this.e2 = I : this.e1 = I
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance()
          }
          hasLineDasharray(t) {
            for (const n of t) {
              const o = n.paint.get("line-dasharray");
              if (o && !o.isConstant()) return !0
            }
            return !1
          }
          addLineDashDependencies(t, n, o, u) {
            for (const _ of t) {
              const m = _.paint.get("line-dasharray");
              if (!m || m.value.kind === "constant") continue;
              const y = _.layout.get("line-cap") === "round",
                b = {
                  dasharray: m.value.evaluate({
                    zoom: o - 1
                  }, n, {}),
                  round: y
                },
                P = {
                  dasharray: m.value.evaluate({
                    zoom: o
                  }, n, {}),
                  round: y
                },
                I = {
                  dasharray: m.value.evaluate({
                    zoom: o + 1
                  }, n, {}),
                  round: y
                },
                L = `${b.dasharray.join(",")},${b.round}`,
                B = `${P.dasharray.join(",")},${P.round}`,
                U = `${I.dasharray.join(",")},${I.round}`;
              u.dashDependencies[L] = b, u.dashDependencies[B] = P, u.dashDependencies[U] = I, n.dashes[_.id] = {
                min: L,
                mid: B,
                max: U
              }
            }
          }
        }
        let tg, rg;
        Mr("LineBucket", yf, {
          omit: ["layers", "patternFeatures"]
        });
        var ng = {
          get paint() {
            return rg = rg || new oa({
              "line-opacity": new ln(J.paint_line["line-opacity"]),
              "line-color": new ln(J.paint_line["line-color"]),
              "line-translate": new Xr(J.paint_line["line-translate"]),
              "line-translate-anchor": new Xr(J.paint_line["line-translate-anchor"]),
              "line-width": new ln(J.paint_line["line-width"]),
              "line-gap-width": new ln(J.paint_line["line-gap-width"]),
              "line-offset": new ln(J.paint_line["line-offset"]),
              "line-blur": new ln(J.paint_line["line-blur"]),
              "line-dasharray": new nl(J.paint_line["line-dasharray"]),
              "line-pattern": new nl(J.paint_line["line-pattern"]),
              "line-gradient": new il(J.paint_line["line-gradient"])
            })
          },
          get layout() {
            return tg = tg || new oa({
              "line-cap": new Xr(J.layout_line["line-cap"]),
              "line-join": new ln(J.layout_line["line-join"]),
              "line-miter-limit": new Xr(J.layout_line["line-miter-limit"]),
              "line-round-limit": new Xr(J.layout_line["line-round-limit"]),
              "line-sort-key": new ln(J.layout_line["line-sort-key"])
            })
          }
        };
        class gb extends ln {
          possiblyEvaluate(t, n) {
            return n = new ei(Math.floor(n.zoom), {
              now: n.now,
              fadeDuration: n.fadeDuration,
              zoomHistory: n.zoomHistory,
              transition: n.transition
            }), super.possiblyEvaluate(t, n)
          }
          evaluate(t, n, o, u) {
            return n = ot({}, n, {
              zoom: Math.floor(n.zoom)
            }), super.evaluate(t, n, o, u)
          }
        }
        let Bd;
        class vb extends Ga {
          constructor(t, n) {
            super(t, ng, n), this.gradientVersion = 0, Bd || (Bd = new gb(ng.paint.properties["line-width"].specification), Bd.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(o) {
                return o._styleExpression !== void 0
              })(n) && n._styleExpression.expression instanceof Ii, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = Bd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new yf(t)
          }
          queryRadius(t) {
            const n = t,
              o = ig(nc("line-width", this, n), nc("line-gap-width", this, n)),
              u = nc("line-offset", this, n);
            return o / 2 + Math.abs(u) + Ed(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: n,
            featureState: o,
            geometry: u,
            transform: _,
            pixelsToTileUnits: m
          }) {
            const y = Ld(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -_.bearingInRadians, m),
              b = m / 2 * ig(this.paint.get("line-width").evaluate(n, o), this.paint.get("line-gap-width").evaluate(n, o)),
              P = this.paint.get("line-offset").evaluate(n, o);
            return P && (u = (function(I, L) {
              const B = [];
              for (let U = 0; U < I.length; U++) {
                const G = I[U],
                  K = [];
                for (let ne = 0; ne < G.length; ne++) {
                  const pe = G[ne - 1],
                    Ze = G[ne],
                    ye = G[ne + 1],
                    ze = ne === 0 ? new F(0, 0) : Ze.sub(pe)._unit()._perp(),
                    at = ne === G.length - 1 ? new F(0, 0) : ye.sub(Ze)._unit()._perp(),
                    gt = ze._add(at)._unit(),
                    Ht = gt.x * at.x + gt.y * at.y;
                  Ht !== 0 && gt._mult(1 / Ht), K.push(gt._mult(L)._add(Ze))
                }
                B.push(K)
              }
              return B
            })(u, P * m)), (function(I, L, B) {
              for (let U = 0; U < L.length; U++) {
                const G = L[U];
                if (I.length >= 3) {
                  for (let K = 0; K < G.length; K++)
                    if (rc(I, G[K])) return !0
                }
                if (Sy(I, G, B)) return !0
              }
              return !1
            })(y, u, b)
          }
          isTileClipped() {
            return !0
          }
        }

        function ig(i, t) {
          return t > 0 ? t + 2 * i : i
        }
        const yb = wi([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          bb = wi([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        wi([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const xb = wi([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        wi([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const ag = wi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          wb = wi([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function kb(i, t, n) {
          return i.sections.forEach((o => {
            o.text = (function(u, _, m) {
              const y = _.layout.get("text-transform").evaluate(m, {});
              return y === "uppercase" ? u = u.toLocaleUpperCase() : y === "lowercase" && (u = u.toLocaleLowerCase()), po.applyArabicShaping && (u = po.applyArabicShaping(u)), u
            })(o.text, t, n)
          })), i
        }
        wi([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), wi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), wi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), wi([{
          type: "Float32",
          name: "offsetX"
        }]), wi([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), wi([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const Bu = {
          "!": "ï¸•",
          "#": "ï¼ƒ",
          $: "ï¼„",
          "%": "ï¼…",
          "&": "ï¼†",
          "(": "ï¸µ",
          ")": "ï¸¶",
          "*": "ï¼Š",
          "+": "ï¼‹",
          ",": "ï¸",
          "-": "ï¸²",
          ".": "ãƒ»",
          "/": "ï¼",
          ":": "ï¸“",
          ";": "ï¸”",
          "<": "ï¸¿",
          "=": "ï¼",
          ">": "ï¹€",
          "?": "ï¸–",
          "@": "ï¼ ",
          "[": "ï¹‡",
          "\\": "ï¼¼",
          "]": "ï¹ˆ",
          "^": "ï¼¾",
          _: "ï¸³",
          "`": "ï½€",
          "{": "ï¸·",
          "|": "â€•",
          "}": "ï¸¸",
          "~": "ï½ž",
          "Â¢": "ï¿ ",
          "Â£": "ï¿¡",
          "Â¥": "ï¿¥",
          "Â¦": "ï¿¤",
          "Â¬": "ï¿¢",
          "Â¯": "ï¿£",
          "â€“": "ï¸²",
          "â€”": "ï¸±",
          "â€˜": "ï¹ƒ",
          "â€™": "ï¹„",
          "â€œ": "ï¹",
          "â€": "ï¹‚",
          "â€¦": "ï¸™",
          "â€§": "ãƒ»",
          "â‚©": "ï¿¦",
          "ã€": "ï¸‘",
          "ã€‚": "ï¸’",
          "ã€ˆ": "ï¸¿",
          "ã€‰": "ï¹€",
          "ã€Š": "ï¸½",
          "ã€‹": "ï¸¾",
          "ã€Œ": "ï¹",
          "ã€": "ï¹‚",
          "ã€Ž": "ï¹ƒ",
          "ã€": "ï¹„",
          "ã€": "ï¸»",
          "ã€‘": "ï¸¼",
          "ã€”": "ï¸¹",
          "ã€•": "ï¸º",
          "ã€–": "ï¸—",
          "ã€—": "ï¸˜",
          "ï¼": "ï¸•",
          "ï¼ˆ": "ï¸µ",
          "ï¼‰": "ï¸¶",
          "ï¼Œ": "ï¸",
          "ï¼": "ï¸²",
          "ï¼Ž": "ãƒ»",
          "ï¼š": "ï¸“",
          "ï¼›": "ï¸”",
          "ï¼œ": "ï¸¿",
          "ï¼ž": "ï¹€",
          "ï¼Ÿ": "ï¸–",
          "ï¼»": "ï¹‡",
          "ï¼½": "ï¹ˆ",
          "ï¼¿": "ï¸³",
          "ï½›": "ï¸·",
          "ï½œ": "â€•",
          "ï½": "ï¸¸",
          "ï½Ÿ": "ï¸µ",
          "ï½ ": "ï¸¶",
          "ï½¡": "ï¸’",
          "ï½¢": "ï¹",
          "ï½£": "ï¹‚"
        };
        var Gi = 24;
        const bf = 4294967296,
          og = 1 / bf,
          sg = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class xf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, n, o = this.length) {
            for (; this.pos < o;) {
              const u = this.readVarint(),
                _ = u >> 3,
                m = this.pos;
              this.type = 7 & u, t(_, n, this), this.pos === m && this.skip(u)
            }
            return n
          }
          readMessage(t, n) {
            return this.readFields(t, n, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * bf;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * bf;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const n = this.buf;
            let o, u;
            return u = n[this.pos++], o = 127 & u, u < 128 ? o : (u = n[this.pos++], o |= (127 & u) << 7, u < 128 ? o : (u = n[this.pos++], o |= (127 & u) << 14, u < 128 ? o : (u = n[this.pos++], o |= (127 & u) << 21, u < 128 ? o : (u = n[this.pos], o |= (15 & u) << 28, (function(_, m, y) {
              const b = y.buf;
              let P, I;
              if (I = b[y.pos++], P = (112 & I) >> 4, I < 128 || (I = b[y.pos++], P |= (127 & I) << 3, I < 128) || (I = b[y.pos++], P |= (127 & I) << 10, I < 128) || (I = b[y.pos++], P |= (127 & I) << 17, I < 128) || (I = b[y.pos++], P |= (127 & I) << 24, I < 128) || (I = b[y.pos++], P |= (1 & I) << 31, I < 128)) return lc(_, P, m);
              throw new Error("Expected varint not more than 10 bytes")
            })(o, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              n = this.pos;
            return this.pos = t, t - n >= 12 && sg ? sg.decode(this.buf.subarray(n, t)) : (function(o, u, _) {
              let m = "",
                y = u;
              for (; y < _;) {
                const b = o[y];
                let P, I, L, B = null,
                  U = b > 239 ? 4 : b > 223 ? 3 : b > 191 ? 2 : 1;
                if (y + U > _) break;
                U === 1 ? b < 128 && (B = b) : U === 2 ? (P = o[y + 1], (192 & P) == 128 && (B = (31 & b) << 6 | 63 & P, B <= 127 && (B = null))) : U === 3 ? (P = o[y + 1], I = o[y + 2], (192 & P) == 128 && (192 & I) == 128 && (B = (15 & b) << 12 | (63 & P) << 6 | 63 & I, (B <= 2047 || B >= 55296 && B <= 57343) && (B = null))) : U === 4 && (P = o[y + 1], I = o[y + 2], L = o[y + 3], (192 & P) == 128 && (192 & I) == 128 && (192 & L) == 128 && (B = (15 & b) << 18 | (63 & P) << 12 | (63 & I) << 6 | 63 & L, (B <= 65535 || B >= 1114112) && (B = null))), B === null ? (B = 65533, U = 1) : B > 65535 && (B -= 65536, m += String.fromCharCode(B >>> 10 & 1023 | 55296), B = 56320 | 1023 & B), m += String.fromCharCode(B), y += U
              }
              return m
            })(this.buf, n, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              n = this.buf.subarray(this.pos, t);
            return this.pos = t, n
          }
          readPackedVarint(t = [], n) {
            const o = this.readPackedEnd();
            for (; this.pos < o;) t.push(this.readVarint(n));
            return t
          }
          readPackedSVarint(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const n = 7 & t;
            if (n === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8
            }
          }
          writeTag(t, n) {
            this.writeVarint(t << 3 | n)
          }
          realloc(t) {
            let n = this.length || 16;
            for (; n < this.pos + t;) n *= 2;
            if (n !== this.length) {
              const o = new Uint8Array(n);
              o.set(this.buf), this.buf = o, this.dataView = new DataView(o.buffer), this.length = n
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * og), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * og), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(n, o) {
              let u, _;
              if (n >= 0 ? (u = n % 4294967296 | 0, _ = n / 4294967296 | 0) : (u = ~(-n % 4294967296), _ = ~(-n / 4294967296), 4294967295 ^ u ? u = u + 1 | 0 : (u = 0, _ = _ + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              o.realloc(10), (function(m, y, b) {
                b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, b.buf[b.pos] = 127 & (m >>>= 7)
              })(u, 0, o), (function(m, y) {
                const b = (7 & m) << 4;
                y.buf[y.pos++] |= b | ((m >>>= 3) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (y.buf[y.pos++] = 127 & m)))))
              })(_, o)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const n = this.pos;
            this.pos = (function(u, _, m) {
              for (let y, b, P = 0; P < _.length; P++) {
                if (y = _.charCodeAt(P), y > 55295 && y < 57344) {
                  if (!b) {
                    y > 56319 || P + 1 === _.length ? (u[m++] = 239, u[m++] = 191, u[m++] = 189) : b = y;
                    continue
                  }
                  if (y < 56320) {
                    u[m++] = 239, u[m++] = 191, u[m++] = 189, b = y;
                    continue
                  }
                  y = b - 55296 << 10 | y - 56320 | 65536, b = null
                } else b && (u[m++] = 239, u[m++] = 191, u[m++] = 189, b = null);
                y < 128 ? u[m++] = y : (y < 2048 ? u[m++] = y >> 6 | 192 : (y < 65536 ? u[m++] = y >> 12 | 224 : (u[m++] = y >> 18 | 240, u[m++] = y >> 12 & 63 | 128), u[m++] = y >> 6 & 63 | 128), u[m++] = 63 & y | 128)
              }
              return m
            })(this.buf, t, this.pos);
            const o = this.pos - n;
            o >= 128 && lg(n, o, this), this.pos = n - 1, this.writeVarint(o), this.pos += o
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const n = t.length;
            this.writeVarint(n), this.realloc(n);
            for (let o = 0; o < n; o++) this.buf[this.pos++] = t[o]
          }
          writeRawMessage(t, n) {
            this.pos++;
            const o = this.pos;
            t(n, this);
            const u = this.pos - o;
            u >= 128 && lg(o, u, this), this.pos = o - 1, this.writeVarint(u), this.pos += u
          }
          writeMessage(t, n, o) {
            this.writeTag(t, 2), this.writeRawMessage(n, o)
          }
          writePackedVarint(t, n) {
            n.length && this.writeMessage(t, Tb, n)
          }
          writePackedSVarint(t, n) {
            n.length && this.writeMessage(t, Sb, n)
          }
          writePackedBoolean(t, n) {
            n.length && this.writeMessage(t, Ib, n)
          }
          writePackedFloat(t, n) {
            n.length && this.writeMessage(t, Pb, n)
          }
          writePackedDouble(t, n) {
            n.length && this.writeMessage(t, Mb, n)
          }
          writePackedFixed32(t, n) {
            n.length && this.writeMessage(t, Cb, n)
          }
          writePackedSFixed32(t, n) {
            n.length && this.writeMessage(t, zb, n)
          }
          writePackedFixed64(t, n) {
            n.length && this.writeMessage(t, Ab, n)
          }
          writePackedSFixed64(t, n) {
            n.length && this.writeMessage(t, Eb, n)
          }
          writeBytesField(t, n) {
            this.writeTag(t, 2), this.writeBytes(n)
          }
          writeFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeFixed32(n)
          }
          writeSFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeSFixed32(n)
          }
          writeFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeFixed64(n)
          }
          writeSFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeSFixed64(n)
          }
          writeVarintField(t, n) {
            this.writeTag(t, 0), this.writeVarint(n)
          }
          writeSVarintField(t, n) {
            this.writeTag(t, 0), this.writeSVarint(n)
          }
          writeStringField(t, n) {
            this.writeTag(t, 2), this.writeString(n)
          }
          writeFloatField(t, n) {
            this.writeTag(t, 5), this.writeFloat(n)
          }
          writeDoubleField(t, n) {
            this.writeTag(t, 1), this.writeDouble(n)
          }
          writeBooleanField(t, n) {
            this.writeVarintField(t, +n)
          }
        }

        function lc(i, t, n) {
          return n ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0)
        }

        function lg(i, t, n) {
          const o = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          n.realloc(o);
          for (let u = n.pos - 1; u >= i; u--) n.buf[u + o] = n.buf[u]
        }

        function Tb(i, t) {
          for (let n = 0; n < i.length; n++) t.writeVarint(i[n])
        }

        function Sb(i, t) {
          for (let n = 0; n < i.length; n++) t.writeSVarint(i[n])
        }

        function Pb(i, t) {
          for (let n = 0; n < i.length; n++) t.writeFloat(i[n])
        }

        function Mb(i, t) {
          for (let n = 0; n < i.length; n++) t.writeDouble(i[n])
        }

        function Ib(i, t) {
          for (let n = 0; n < i.length; n++) t.writeBoolean(i[n])
        }

        function Cb(i, t) {
          for (let n = 0; n < i.length; n++) t.writeFixed32(i[n])
        }

        function zb(i, t) {
          for (let n = 0; n < i.length; n++) t.writeSFixed32(i[n])
        }

        function Ab(i, t) {
          for (let n = 0; n < i.length; n++) t.writeFixed64(i[n])
        }

        function Eb(i, t) {
          for (let n = 0; n < i.length; n++) t.writeSFixed64(i[n])
        }

        function Lb(i, t, n) {
          i === 1 && n.readMessage(Db, t)
        }

        function Db(i, t, n) {
          if (i === 3) {
            const {
              id: o,
              bitmap: u,
              width: _,
              height: m,
              left: y,
              top: b,
              advance: P
            } = n.readMessage(Rb, {});
            t.push({
              id: o,
              bitmap: new Cu({
                width: _ + 6,
                height: m + 6
              }, u),
              metrics: {
                width: _,
                height: m,
                left: y,
                top: b,
                advance: P
              }
            })
          }
        }

        function Rb(i, t, n) {
          i === 1 ? t.id = n.readVarint() : i === 2 ? t.bitmap = n.readBytes() : i === 3 ? t.width = n.readVarint() : i === 4 ? t.height = n.readVarint() : i === 5 ? t.left = n.readSVarint() : i === 6 ? t.top = n.readSVarint() : i === 7 && (t.advance = n.readVarint())
        }

        function cg(i) {
          let t = 0,
            n = 0;
          for (const m of i) t += m.w * m.h, n = Math.max(n, m.w);
          i.sort(((m, y) => y.h - m.h));
          const o = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), n),
            h: 1 / 0
          }];
          let u = 0,
            _ = 0;
          for (const m of i)
            for (let y = o.length - 1; y >= 0; y--) {
              const b = o[y];
              if (!(m.w > b.w || m.h > b.h)) {
                if (m.x = b.x, m.y = b.y, _ = Math.max(_, m.y + m.h), u = Math.max(u, m.x + m.w), m.w === b.w && m.h === b.h) {
                  const P = o.pop();
                  P && y < o.length && (o[y] = P)
                } else m.h === b.h ? (b.x += m.w, b.w -= m.w) : m.w === b.w ? (b.y += m.h, b.h -= m.h) : (o.push({
                  x: b.x + m.w,
                  y: b.y,
                  w: b.w - m.w,
                  h: m.h
                }), b.y += m.h, b.h -= m.h);
                break
              }
            }
          return {
            w: u,
            h: _,
            fill: t / (u * _) || 0
          }
        }
        class wf {
          constructor(t, {
            pixelRatio: n,
            version: o,
            stretchX: u,
            stretchY: _,
            content: m,
            textFitWidth: y,
            textFitHeight: b
          }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = u, this.stretchY = _, this.content = m, this.version = o, this.textFitWidth = y, this.textFitHeight = b
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class ug {
          constructor(t, n) {
            const o = {},
              u = {};
            this.haveRenderCallbacks = [];
            const _ = [];
            this.addImages(t, o, _), this.addImages(n, u, _);
            const {
              w: m,
              h: y
            } = cg(_), b = new Ta({
              width: m || 1,
              height: y || 1
            });
            for (const P in t) {
              const I = t[P],
                L = o[P].paddedRect;
              Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: L.x + 1,
                y: L.y + 1
              }, I.data)
            }
            for (const P in n) {
              const I = n[P],
                L = u[P].paddedRect,
                B = L.x + 1,
                U = L.y + 1,
                G = I.data.width,
                K = I.data.height;
              Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: B,
                y: U
              }, I.data), Ta.copy(I.data, b, {
                x: 0,
                y: K - 1
              }, {
                x: B,
                y: U - 1
              }, {
                width: G,
                height: 1
              }), Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: B,
                y: U + K
              }, {
                width: G,
                height: 1
              }), Ta.copy(I.data, b, {
                x: G - 1,
                y: 0
              }, {
                x: B - 1,
                y: U
              }, {
                width: 1,
                height: K
              }), Ta.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: B + G,
                y: U
              }, {
                width: 1,
                height: K
              })
            }
            this.image = b, this.iconPositions = o, this.patternPositions = u
          }
          addImages(t, n, o) {
            for (const u in t) {
              const _ = t[u],
                m = {
                  x: 0,
                  y: 0,
                  w: _.data.width + 2,
                  h: _.data.height + 2
                };
              o.push(m), n[u] = new wf(m, _), _.hasRenderCallback && this.haveRenderCallbacks.push(u)
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const o in t.updatedImages) this.patchUpdatedImage(this.iconPositions[o], t.getImage(o), n), this.patchUpdatedImage(this.patternPositions[o], t.getImage(o), n)
          }
          patchUpdatedImage(t, n, o) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [u, _] = t.tl;
            o.update(n.data, void 0, {
              x: u,
              y: _
            })
          }
        }
        var As;
        Mr("ImagePosition", wf), Mr("ImageAtlas", ug), k.as = void 0, (As = k.as || (k.as = {}))[As.none = 0] = "none", As[As.horizontal = 1] = "horizontal", As[As.vertical = 2] = "vertical", As[As.horizontalOnly = 3] = "horizontalOnly";
        class Ou {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, n, o) {
            const u = new Ou;
            return u.scale = t || 1, u.fontStack = n, u.verticalAlign = o || "bottom", u
          }
          static forImage(t, n) {
            const o = new Ou;
            return o.imageName = t, o.verticalAlign = n || "bottom", o
          }
        }
        class cc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, n) {
            const o = new cc;
            for (let u = 0; u < t.sections.length; u++) {
              const _ = t.sections[u];
              _.image ? o.addImageSection(_) : o.addTextSection(_, n)
            }
            return o
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let n = "";
              for (let o = 0; o < t.length; o++) {
                const u = t.charCodeAt(o + 1) || null,
                  _ = t.charCodeAt(o - 1) || null;
                n += u && Hl(u) && !Bu[t[o + 1]] || _ && Hl(_) && !Bu[t[o - 1]] || !Bu[t[o]] ? t[o] : Bu[t[o]]
              }
              return n
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let o = 0; o < this.text.length && qd[this.text.charCodeAt(o)]; o++) t++;
            let n = this.text.length;
            for (let o = this.text.length - 1; o >= 0 && o >= t && qd[this.text.charCodeAt(o)]; o--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n)
          }
          substring(t, n) {
            const o = new cc;
            return o.text = this.text.substring(t, n), o.sectionIndex = this.sectionIndex.slice(t, n), o.sections = this.sections, o
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, n) => Math.max(t, this.sections[n].scale)), 0)
          }
          getMaxImageSize(t) {
            let n = 0,
              o = 0;
            for (let u = 0; u < this.length(); u++) {
              const _ = this.getSection(u);
              if (_.imageName) {
                const m = t[_.imageName];
                if (!m) continue;
                const y = m.displaySize;
                n = Math.max(n, y[0]), o = Math.max(o, y[1])
              }
            }
            return {
              maxImageWidth: n,
              maxImageHeight: o
            }
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(Ou.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const o = this.sections.length - 1;
            for (let u = 0; u < t.text.length; ++u) this.sectionIndex.push(o)
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void zt("Can't add FormattedSection with an empty image.");
            const o = this.getNextImageSectionCharCode();
            o ? (this.text += String.fromCharCode(o), this.sections.push(Ou.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : zt("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function Od(i, t, n, o, u, _, m, y, b, P, I, L, B, U, G) {
          const K = cc.fromFeature(i, u);
          let ne;
          L === k.as.vertical && K.verticalizePunctuation();
          const {
            processBidirectionalText: pe,
            processStyledBidirectionalText: Ze
          } = po;
          if (pe && K.sections.length === 1) {
            ne = [];
            const at = pe(K.toString(), kf(K, P, _, t, o, U));
            for (const gt of at) {
              const Ht = new cc;
              Ht.text = gt, Ht.sections = K.sections;
              for (let xr = 0; xr < gt.length; xr++) Ht.sectionIndex.push(0);
              ne.push(Ht)
            }
          } else if (Ze) {
            ne = [];
            const at = Ze(K.text, K.sectionIndex, kf(K, P, _, t, o, U));
            for (const gt of at) {
              const Ht = new cc;
              Ht.text = gt[0], Ht.sectionIndex = gt[1], Ht.sections = K.sections, ne.push(Ht)
            }
          } else ne = (function(at, gt) {
            const Ht = [],
              xr = at.text;
            let dr = 0;
            for (const vr of gt) Ht.push(at.substring(dr, vr)), dr = vr;
            return dr < xr.length && Ht.push(at.substring(dr, xr.length)), Ht
          })(K, kf(K, P, _, t, o, U));
          const ye = [],
            ze = {
              positionedLines: ye,
              text: K.toString(),
              top: I[1],
              bottom: I[1],
              left: I[0],
              right: I[0],
              writingMode: L,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(at, gt, Ht, xr, dr, vr, en, gr, yr, Lt, hn, _n) {
            let on = 0,
              $r = 0,
              Bn = 0,
              bi = 0;
            const Fi = gr === "right" ? 1 : gr === "left" ? 0 : .5,
              la = Gi / _n;
            let $a = 0;
            for (const gi of dr) {
              gi.trim();
              const Wi = gi.getMaxScale(),
                ea = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              at.positionedLines[$a] = ea;
              const ta = ea.positionedGlyphs;
              let ya = 0;
              if (!gi.length()) {
                $r += vr, ++$a;
                continue
              }
              const Xa = Ob(xr, gi, la);
              for (let Pa = 0; Pa < gi.length(); Pa++) {
                const Bi = gi.getSection(Pa),
                  $i = gi.getSectionIndex(Pa),
                  Xi = gi.getCharCode(Pa),
                  Li = qb(yr, hn, Xi);
                let oi;
                if (Bi.imageName) {
                  if (at.iconsInText = !0, Bi.scale = Bi.scale * la, oi = Vb(Bi, Li, Wi, Xa, xr), !oi) continue;
                  ya = Math.max(ya, oi.imageOffset)
                } else if (oi = Nb(Bi, Xi, Li, Xa, gt, Ht), !oi) continue;
                const {
                  rect: vo,
                  metrics: pc,
                  baselineOffset: yo
                } = oi;
                ta.push({
                  glyph: Xi,
                  imageName: Bi.imageName,
                  x: on,
                  y: $r + yo + -17,
                  vertical: Li,
                  scale: Bi.scale,
                  fontStack: Bi.fontStack,
                  sectionIndex: $i,
                  metrics: pc,
                  rect: vo
                }), Li ? (at.verticalizable = !0, on += (Bi.imageName ? pc.advance : Gi) * Bi.scale + Lt) : on += pc.advance * Bi.scale + Lt
              }
              ta.length !== 0 && (Bn = Math.max(on - Lt, Bn), Ub(ta, 0, ta.length - 1, Fi)), on = 0, ea.lineOffset = Math.max(ya, (Wi - 1) * Gi);
              const Hi = vr * Wi + ya;
              $r += Hi, bi = Math.max(Hi, bi), ++$a
            }
            const {
              horizontalAlign: Sa,
              verticalAlign: Qi
            } = Tf(en);
            (function(gi, Wi, ea, ta, ya, Xa, Hi, Pa, Bi) {
              const $i = (Wi - ea) * ya;
              let Xi = 0;
              Xi = Xa !== Hi ? -Pa * ta - -17 : -ta * Bi * Hi + .5 * Hi;
              for (const Li of gi)
                for (const oi of Li.positionedGlyphs) oi.x += $i, oi.y += Xi
            })(at.positionedLines, Fi, Sa, Qi, Bn, bi, vr, $r, dr.length), at.top += -Qi * $r, at.bottom = at.top + $r, at.left += -Sa * Bn, at.right = at.left + Bn
          })(ze, t, n, o, ne, m, y, b, L, P, B, G), !(function(at) {
            for (const gt of at)
              if (gt.positionedGlyphs.length !== 0) return !1;
            return !0
          })(ye) && ze
        }
        const qd = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          jb = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          Fb = {
            40: !0
          };

        function hg(i, t, n, o, u, _) {
          if (t.imageName) {
            const m = o[t.imageName];
            return m ? m.displaySize[0] * t.scale * Gi / _ + u : 0
          } {
            const m = n[t.fontStack],
              y = m && m[i];
            return y ? y.metrics.advance * t.scale + u : 0
          }
        }

        function dg(i, t, n, o) {
          const u = Math.pow(i - t, 2);
          return o ? i < t ? u / 2 : 2 * u : u + Math.abs(n) * n
        }

        function Bb(i, t, n) {
          let o = 0;
          return i === 10 && (o -= 1e4), n && (o += 150), i !== 40 && i !== 65288 || (o += 50), t !== 41 && t !== 65289 || (o += 50), o
        }

        function pg(i, t, n, o, u, _) {
          let m = null,
            y = dg(t, n, u, _);
          for (const b of o) {
            const P = dg(t - b.x, n, u, _) + b.badness;
            P <= y && (m = b, y = P)
          }
          return {
            index: i,
            x: t,
            priorBreak: m,
            badness: y
          }
        }

        function fg(i) {
          return i ? fg(i.priorBreak).concat(i.index) : []
        }

        function kf(i, t, n, o, u, _) {
          if (!i) return [];
          const m = [],
            y = (function(L, B, U, G, K, ne) {
              let pe = 0;
              for (let Ze = 0; Ze < L.length(); Ze++) {
                const ye = L.getSection(Ze);
                pe += hg(L.getCharCode(Ze), ye, G, K, B, ne)
              }
              return pe / Math.max(1, Math.ceil(pe / U))
            })(i, t, n, o, u, _),
            b = i.text.indexOf("â€‹") >= 0;
          let P = 0;
          for (let L = 0; L < i.length(); L++) {
            const B = i.getSection(L),
              U = i.getCharCode(L);
            if (qd[U] || (P += hg(U, B, o, u, t, _)), L < i.length() - 1) {
              const G = !((I = U) < 11904) && (!!jn["CJK Compatibility Forms"](I) || !!jn["CJK Compatibility"](I) || !!jn["CJK Strokes"](I) || !!jn["CJK Symbols and Punctuation"](I) || !!jn["Enclosed CJK Letters and Months"](I) || !!jn["Halfwidth and Fullwidth Forms"](I) || !!jn["Ideographic Description Characters"](I) || !!jn["Vertical Forms"](I) || gu.test(String.fromCodePoint(I)));
              (jb[U] || G || B.imageName || L !== i.length() - 2 && Fb[i.getCharCode(L + 1)]) && m.push(pg(L + 1, P, y, m, Bb(U, i.getCharCode(L + 1), G && b), !1))
            }
          }
          var I;
          return fg(pg(i.length(), P, y, m, 0, !0))
        }

        function Tf(i) {
          let t = .5,
            n = .5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: n
          }
        }

        function Ob(i, t, n) {
          const o = t.getMaxScale() * Gi,
            {
              maxImageWidth: u,
              maxImageHeight: _
            } = t.getMaxImageSize(i),
            m = Math.max(o, _ * n);
          return {
            verticalLineContentWidth: Math.max(o, u * n),
            horizontalLineContentHeight: m
          }
        }

        function _g(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function qb(i, t, n) {
          return !(i === k.as.horizontal || !t && !Wl(n) || t && (qd[n] || (o = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(o)))));
          var o
        }

        function Nb(i, t, n, o, u, _) {
          const m = _[i.fontStack],
            y = (function(P, I, L, B) {
              if (P && P.rect) return P;
              const U = I[L.fontStack],
                G = U && U[B];
              return G ? {
                rect: null,
                metrics: G.metrics
              } : null
            })(m && m[t], u, i, t);
          if (y === null) return null;
          let b;
          if (n) b = o.verticalLineContentWidth - i.scale * Gi;
          else {
            const P = _g(i.verticalAlign);
            b = (o.horizontalLineContentHeight - i.scale * Gi) * P
          }
          return {
            rect: y.rect,
            metrics: y.metrics,
            baselineOffset: b
          }
        }

        function Vb(i, t, n, o, u) {
          const _ = u[i.imageName];
          if (!_) return null;
          const m = _.paddedRect,
            y = _.displaySize,
            b = {
              width: y[0],
              height: y[1],
              left: 1,
              top: -3,
              advance: t ? y[1] : y[0]
            };
          let P;
          if (t) P = o.verticalLineContentWidth - y[1] * i.scale;
          else {
            const I = _g(i.verticalAlign);
            P = (o.horizontalLineContentHeight - y[1] * i.scale) * I
          }
          return {
            rect: m,
            metrics: b,
            baselineOffset: P,
            imageOffset: (t ? y[0] : y[1]) * i.scale - Gi * n
          }
        }

        function Ub(i, t, n, o) {
          if (o === 0) return;
          const u = i[n],
            _ = (i[n].x + u.metrics.advance * u.scale) * o;
          for (let m = t; m <= n; m++) i[m].x -= _
        }

        function Zb(i, t, n) {
          const {
            horizontalAlign: o,
            verticalAlign: u
          } = Tf(n), _ = t[0] - i.displaySize[0] * o, m = t[1] - i.displaySize[1] * u;
          return {
            image: i,
            top: m,
            bottom: m + i.displaySize[1],
            left: _,
            right: _ + i.displaySize[0]
          }
        }

        function mg(i) {
          var t, n;
          let o = i.left,
            u = i.top,
            _ = i.right - o,
            m = i.bottom - u;
          const y = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            b = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink",
            P = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (b === "proportional") {
            if (y === "stretchOnly" && _ / m < P || y === "proportional") {
              const I = Math.ceil(m * P);
              o *= I / _, _ = I
            }
          } else if (y === "proportional" && b === "stretchOnly" && P !== 0 && _ / m > P) {
            const I = Math.ceil(_ / P);
            u *= I / m, m = I
          }
          return {
            x1: o,
            y1: u,
            x2: o + _,
            y2: u + m
          }
        }

        function gg(i, t, n, o, u, _) {
          const m = i.image;
          let y;
          if (m.content) {
            const ne = m.content,
              pe = m.pixelRatio || 1;
            y = [ne[0] / pe, ne[1] / pe, m.displaySize[0] - ne[2] / pe, m.displaySize[1] - ne[3] / pe]
          }
          const b = t.left * _,
            P = t.right * _;
          let I, L, B, U;
          n === "width" || n === "both" ? (U = u[0] + b - o[3], L = u[0] + P + o[1]) : (U = u[0] + (b + P - m.displaySize[0]) / 2, L = U + m.displaySize[0]);
          const G = t.top * _,
            K = t.bottom * _;
          return n === "height" || n === "both" ? (I = u[1] + G - o[0], B = u[1] + K + o[2]) : (I = u[1] + (G + K - m.displaySize[1]) / 2, B = I + m.displaySize[1]), {
            image: m,
            top: I,
            right: L,
            bottom: B,
            left: U,
            collisionPadding: y
          }
        }
        const is = 128,
          Es = 32640;

        function vg(i, t) {
          const {
            expression: n
          } = t;
          if (n.kind === "constant") return {
            kind: "constant",
            layoutSize: n.evaluate(new ei(i + 1))
          };
          if (n.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: o,
              interpolationType: u
            } = n;
            let _ = 0;
            for (; _ < o.length && o[_] <= i;) _++;
            _ = Math.max(0, _ - 1);
            let m = _;
            for (; m < o.length && o[m] < i + 1;) m++;
            m = Math.min(o.length - 1, m);
            const y = o[_],
              b = o[m];
            return n.kind === "composite" ? {
              kind: "composite",
              minZoom: y,
              maxZoom: b,
              interpolationType: u
            } : {
              kind: "camera",
              minZoom: y,
              maxZoom: b,
              minSize: n.evaluate(new ei(y)),
              maxSize: n.evaluate(new ei(b)),
              interpolationType: u
            }
          }
        }

        function Sf(i, t, n) {
          let o = "never";
          const u = i.get(t);
          return u ? o = u : i.get(n) && (o = "always"), o
        }
        const Gb = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function Nd(i, t, n, o, u, _, m, y, b, P, I, L, B) {
          const U = y ? Math.min(Es, Math.round(y[0])) : 0,
            G = y ? Math.min(Es, Math.round(y[1])) : 0;
          i.emplaceBack(t, n, Math.round(32 * o), Math.round(32 * u), _, m, (U << 1) + (b ? 1 : 0), G, 16 * P, 16 * I, 256 * L, 256 * B)
        }

        function Pf(i, t, n) {
          i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n)
        }

        function Wb(i) {
          for (const t of i.sections)
            if (ef(t.text)) return !0;
          return !1
        }
        class Mf {
          constructor(t) {
            this.layoutVertexArray = new it, this.indexArray = new Bt, this.programConfigurations = t, this.segments = new zn, this.dynamicLayoutVertexArray = new st, this.opacityVertexArray = new ut, this.hasVisibleVertices = !1, this.placedSymbolArray = new C
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, n, o, u) {
            this.isEmpty() || (o && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, yb.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, bb.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Gb, !0), this.opacityVertexBuffer.itemSize = 1), (o || u) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Mr("SymbolBuffers", Mf);
        class If {
          constructor(t, n, o) {
            this.layoutVertexArray = new t, this.layoutAttributes = n, this.indexArray = new o, this.segments = new zn, this.collisionVertexArray = new cr
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, xb.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Mr("CollisionBuffers", If);
        class uc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = Gt(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((m => m.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = vg(this.zoom, n["text-size"]), this.iconSizeData = vg(this.zoom, n["icon-size"]);
            const o = this.layers[0].layout,
              u = o.get("symbol-sort-key"),
              _ = o.get("symbol-z-order");
            this.canOverlap = Sf(o, "text-overlap", "text-allow-overlap") !== "never" || Sf(o, "icon-overlap", "icon-allow-overlap") !== "never" || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = _ !== "viewport-y" && !u.isConstant(), this.sortFeaturesByY = (_ === "viewport-y" || _ === "auto" && !this.sortFeaturesByKey) && this.canOverlap, o.get("symbol-placement") === "point" && (this.writingModes = o.get("text-writing-mode").map((m => k.as[m]))), this.stateDependentLayerIds = this.layers.filter((m => m.isStateDependent())).map((m => m.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new Mf(new rs(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new Mf(new rs(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new R, this.lineVertexArray = new Z, this.symbolInstances = new j, this.textAnchorOffsets = new oe
          }
          calculateGlyphDependencies(t, n, o, u, _) {
            for (let m = 0; m < t.length; m++)
              if (n[t.charCodeAt(m)] = !0, (o || u) && _) {
                const y = Bu[t.charAt(m)];
                y && (n[y.charCodeAt(0)] = !0)
              }
          }
          populate(t, n, o) {
            const u = this.layers[0],
              _ = u.layout,
              m = _.get("text-font"),
              y = _.get("text-field"),
              b = _.get("icon-image"),
              P = (y.value.kind !== "constant" || y.value.value instanceof Ln && !y.value.value.isEmpty() || y.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0),
              I = b.value.kind !== "constant" || !!b.value.value || Object.keys(b.parameters).length > 0,
              L = _.get("symbol-sort-key");
            if (this.features = [], !P && !I) return;
            const B = n.iconDependencies,
              U = n.glyphDependencies,
              G = n.availableImages,
              K = new ei(this.zoom);
            for (const {
                feature: ne,
                id: pe,
                index: Ze,
                sourceLayerIndex: ye
              }
              of t) {
              const ze = u._featureFilter.needGeometry,
                at = zo(ne, ze);
              if (!u._featureFilter.filter(K, at, o)) continue;
              let gt, Ht;
              if (ze || (at.geometry = go(ne)), P) {
                const dr = u.getValueAndResolveTokens("text-field", at, o, G),
                  vr = Ln.factory(dr),
                  en = this.hasRTLText = this.hasRTLText || Wb(vr);
                (!en || po.getRTLTextPluginStatus() === "unavailable" || en && po.isParsed()) && (gt = kb(vr, u, at))
              }
              if (I) {
                const dr = u.getValueAndResolveTokens("icon-image", at, o, G);
                Ht = dr instanceof ii ? dr : ii.fromString(dr)
              }
              if (!gt && !Ht) continue;
              const xr = this.sortFeaturesByKey ? L.evaluate(at, {}, o) : void 0;
              if (this.features.push({
                  id: pe,
                  text: gt,
                  icon: Ht,
                  index: Ze,
                  sourceLayerIndex: ye,
                  geometry: at.geometry,
                  properties: ne.properties,
                  type: sc.types[ne.type],
                  sortKey: xr
                }), Ht && (B[Ht.name] = !0), gt) {
                const dr = m.evaluate(at, {}, o).join(","),
                  vr = _.get("text-rotation-alignment") !== "viewport" && _.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(k.as.vertical) >= 0;
                for (const en of gt.sections)
                  if (en.image) B[en.image.name] = !0;
                  else {
                    const gr = _u(gt.toString()),
                      yr = en.fontStack || dr,
                      Lt = U[yr] = U[yr] || {};
                    this.calculateGlyphDependencies(en.text, Lt, vr, this.allowVerticalPlacement, gr)
                  }
              }
            }
            _.get("symbol-placement") === "line" && (this.features = (function(ne) {
              const pe = {},
                Ze = {},
                ye = [];
              let ze = 0;

              function at(dr) {
                ye.push(ne[dr]), ze++
              }

              function gt(dr, vr, en) {
                const gr = Ze[dr];
                return delete Ze[dr], Ze[vr] = gr, ye[gr].geometry[0].pop(), ye[gr].geometry[0] = ye[gr].geometry[0].concat(en[0]), gr
              }

              function Ht(dr, vr, en) {
                const gr = pe[vr];
                return delete pe[vr], pe[dr] = gr, ye[gr].geometry[0].shift(), ye[gr].geometry[0] = en[0].concat(ye[gr].geometry[0]), gr
              }

              function xr(dr, vr, en) {
                const gr = en ? vr[0][vr[0].length - 1] : vr[0][0];
                return `${dr}:${gr.x}:${gr.y}`
              }
              for (let dr = 0; dr < ne.length; dr++) {
                const vr = ne[dr],
                  en = vr.geometry,
                  gr = vr.text ? vr.text.toString() : null;
                if (!gr) {
                  at(dr);
                  continue
                }
                const yr = xr(gr, en),
                  Lt = xr(gr, en, !0);
                if (yr in Ze && Lt in pe && Ze[yr] !== pe[Lt]) {
                  const hn = Ht(yr, Lt, en),
                    _n = gt(yr, Lt, ye[hn].geometry);
                  delete pe[yr], delete Ze[Lt], Ze[xr(gr, ye[_n].geometry, !0)] = _n, ye[hn].geometry = null
                } else yr in Ze ? gt(yr, Lt, en) : Lt in pe ? Ht(yr, Lt, en) : (at(dr), pe[yr] = ze - 1, Ze[Lt] = ze - 1)
              }
              return ye.filter((dr => dr.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((ne, pe) => ne.sortKey - pe.sortKey))
          }
          update(t, n, o) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, {
              imagePositions: o
            }), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, {
              imagePositions: o
            }))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, n) {
            const o = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let u = t.dist(n[t.segment + 1]),
                _ = t.dist(n[t.segment]);
              const m = {};
              for (let y = t.segment + 1; y < n.length; y++) m[y] = {
                x: n[y].x,
                y: n[y].y,
                tileUnitDistanceFromAnchor: u
              }, y < n.length - 1 && (u += n[y + 1].dist(n[y]));
              for (let y = t.segment || 0; y >= 0; y--) m[y] = {
                x: n[y].x,
                y: n[y].y,
                tileUnitDistanceFromAnchor: _
              }, y > 0 && (_ += n[y - 1].dist(n[y]));
              for (let y = 0; y < n.length; y++) {
                const b = m[y];
                this.lineVertexArray.emplaceBack(b.x, b.y, b.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: o,
              lineLength: this.lineVertexArray.length - o
            }
          }
          addSymbols(t, n, o, u, _, m, y, b, P, I, L, B) {
            const U = t.indexArray,
              G = t.layoutVertexArray,
              K = t.segments.prepareSegment(4 * n.length, G, U, this.canOverlap ? m.sortKey : void 0),
              ne = this.glyphOffsetArray.length,
              pe = K.vertexLength,
              Ze = this.allowVerticalPlacement && y === k.as.vertical ? Math.PI / 2 : 0,
              ye = m.text && m.text.sections;
            for (let ze = 0; ze < n.length; ze++) {
              const {
                tl: at,
                tr: gt,
                bl: Ht,
                br: xr,
                tex: dr,
                pixelOffsetTL: vr,
                pixelOffsetBR: en,
                minFontScaleX: gr,
                minFontScaleY: yr,
                glyphOffset: Lt,
                isSDF: hn,
                sectionIndex: _n
              } = n[ze], on = K.vertexLength, $r = Lt[1];
              Nd(G, b.x, b.y, at.x, $r + at.y, dr.x, dr.y, o, hn, vr.x, vr.y, gr, yr), Nd(G, b.x, b.y, gt.x, $r + gt.y, dr.x + dr.w, dr.y, o, hn, en.x, vr.y, gr, yr), Nd(G, b.x, b.y, Ht.x, $r + Ht.y, dr.x, dr.y + dr.h, o, hn, vr.x, en.y, gr, yr), Nd(G, b.x, b.y, xr.x, $r + xr.y, dr.x + dr.w, dr.y + dr.h, o, hn, en.x, en.y, gr, yr), Pf(t.dynamicLayoutVertexArray, b, Ze), U.emplaceBack(on, on + 2, on + 1), U.emplaceBack(on + 1, on + 2, on + 3), K.vertexLength += 4, K.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Lt[0]), ze !== n.length - 1 && _n === n[ze + 1].sectionIndex || t.programConfigurations.populatePaintArrays(G.length, m, m.index, {
                imagePositions: {},
                canonical: B,
                formattedSection: ye && ye[_n]
              })
            }
            t.placedSymbolArray.emplaceBack(b.x, b.y, ne, this.glyphOffsetArray.length - ne, pe, P, I, b.segment, o ? o[0] : 0, o ? o[1] : 0, u[0], u[1], y, 0, !1, 0, L)
          }
          _addCollisionDebugVertex(t, n, o, u, _, m) {
            return n.emplaceBack(0, 0), t.emplaceBack(o.x, o.y, u, _, Math.round(m.x), Math.round(m.y))
          }
          addCollisionDebugVertices(t, n, o, u, _, m, y) {
            const b = _.segments.prepareSegment(4, _.layoutVertexArray, _.indexArray),
              P = b.vertexLength,
              I = _.layoutVertexArray,
              L = _.collisionVertexArray,
              B = y.anchorX,
              U = y.anchorY;
            this._addCollisionDebugVertex(I, L, m, B, U, new F(t, n)), this._addCollisionDebugVertex(I, L, m, B, U, new F(o, n)), this._addCollisionDebugVertex(I, L, m, B, U, new F(o, u)), this._addCollisionDebugVertex(I, L, m, B, U, new F(t, u)), b.vertexLength += 4;
            const G = _.indexArray;
            G.emplaceBack(P, P + 1), G.emplaceBack(P + 1, P + 2), G.emplaceBack(P + 2, P + 3), G.emplaceBack(P + 3, P), b.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, n, o, u) {
            for (let _ = t; _ < n; _++) {
              const m = this.collisionBoxArray.get(_);
              this.addCollisionDebugVertices(m.x1, m.y1, m.x2, m.y2, u ? this.textCollisionBox : this.iconCollisionBox, m.anchorPoint, o)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new If(or, ag.members, Nr), this.iconCollisionBox = new If(or, ag.members, Nr);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, o, u, _, m, y, b, P) {
            const I = {};
            for (let L = n; L < o; L++) {
              const B = t.get(L);
              I.textBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.textFeatureIndex = B.featureIndex;
              break
            }
            for (let L = u; L < _; L++) {
              const B = t.get(L);
              I.verticalTextBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.verticalTextFeatureIndex = B.featureIndex;
              break
            }
            for (let L = m; L < y; L++) {
              const B = t.get(L);
              I.iconBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.iconFeatureIndex = B.featureIndex;
              break
            }
            for (let L = b; L < P; L++) {
              const B = t.get(L);
              I.verticalIconBox = {
                x1: B.x1,
                y1: B.y1,
                x2: B.x2,
                y2: B.y2,
                anchorPointX: B.anchorPointX,
                anchorPointY: B.anchorPointY
              }, I.verticalIconFeatureIndex = B.featureIndex;
              break
            }
            return I
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const o = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, n) {
            const o = t.placedSymbolArray.get(n),
              u = o.vertexStartIndex + 4 * o.numGlyphs;
            for (let _ = o.vertexStartIndex; _ < u; _ += 4) t.indexArray.emplaceBack(_, _ + 2, _ + 1), t.indexArray.emplaceBack(_ + 1, _ + 2, _ + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t),
              o = Math.cos(t),
              u = [],
              _ = [],
              m = [];
            for (let y = 0; y < this.symbolInstances.length; ++y) {
              m.push(y);
              const b = this.symbolInstances.get(y);
              u.push(0 | Math.round(n * b.anchorX + o * b.anchorY)), _.push(b.featureIndex)
            }
            return m.sort(((y, b) => u[y] - u[b] || _[b] - _[y])), m
          }
          addToSortKeyRanges(t, n) {
            const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            o && o.sortKey === n ? o.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: n,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const o = this.symbolInstances.get(n);
                this.featureSortOrder.push(o.featureIndex), [o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach(((u, _, m) => {
                  u >= 0 && m.indexOf(u) === _ && this.addIndicesForPlacedSymbol(this.text, u)
                })), o.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, o.verticalPlacedTextSymbolIndex), o.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.placedIconSymbolIndex), o.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let yg, bg;
        Mr("SymbolBucket", uc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), uc.MAX_GLYPHS = 65535, uc.addDynamicAttributes = Pf;
        var Cf = {
          get paint() {
            return bg = bg || new oa({
              "icon-opacity": new ln(J.paint_symbol["icon-opacity"]),
              "icon-color": new ln(J.paint_symbol["icon-color"]),
              "icon-halo-color": new ln(J.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new ln(J.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new ln(J.paint_symbol["icon-halo-blur"]),
              "icon-translate": new Xr(J.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new Xr(J.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new ln(J.paint_symbol["text-opacity"]),
              "text-color": new ln(J.paint_symbol["text-color"], {
                runtimeType: Tr,
                getOverride: i => i.textColor,
                hasOverride: i => !!i.textColor
              }),
              "text-halo-color": new ln(J.paint_symbol["text-halo-color"]),
              "text-halo-width": new ln(J.paint_symbol["text-halo-width"]),
              "text-halo-blur": new ln(J.paint_symbol["text-halo-blur"]),
              "text-translate": new Xr(J.paint_symbol["text-translate"]),
              "text-translate-anchor": new Xr(J.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return yg = yg || new oa({
              "symbol-placement": new Xr(J.layout_symbol["symbol-placement"]),
              "symbol-spacing": new Xr(J.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new Xr(J.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new ln(J.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new Xr(J.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new Xr(J.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new Xr(J.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new Xr(J.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new Xr(J.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new Xr(J.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new ln(J.layout_symbol["icon-size"]),
              "icon-text-fit": new Xr(J.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new Xr(J.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new ln(J.layout_symbol["icon-image"]),
              "icon-rotate": new ln(J.layout_symbol["icon-rotate"]),
              "icon-padding": new ln(J.layout_symbol["icon-padding"]),
              "icon-keep-upright": new Xr(J.layout_symbol["icon-keep-upright"]),
              "icon-offset": new ln(J.layout_symbol["icon-offset"]),
              "icon-anchor": new ln(J.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new Xr(J.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new Xr(J.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new Xr(J.layout_symbol["text-rotation-alignment"]),
              "text-field": new ln(J.layout_symbol["text-field"]),
              "text-font": new ln(J.layout_symbol["text-font"]),
              "text-size": new ln(J.layout_symbol["text-size"]),
              "text-max-width": new ln(J.layout_symbol["text-max-width"]),
              "text-line-height": new Xr(J.layout_symbol["text-line-height"]),
              "text-letter-spacing": new ln(J.layout_symbol["text-letter-spacing"]),
              "text-justify": new ln(J.layout_symbol["text-justify"]),
              "text-radial-offset": new ln(J.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new Xr(J.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new ln(J.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new ln(J.layout_symbol["text-anchor"]),
              "text-max-angle": new Xr(J.layout_symbol["text-max-angle"]),
              "text-writing-mode": new Xr(J.layout_symbol["text-writing-mode"]),
              "text-rotate": new ln(J.layout_symbol["text-rotate"]),
              "text-padding": new Xr(J.layout_symbol["text-padding"]),
              "text-keep-upright": new Xr(J.layout_symbol["text-keep-upright"]),
              "text-transform": new ln(J.layout_symbol["text-transform"]),
              "text-offset": new ln(J.layout_symbol["text-offset"]),
              "text-allow-overlap": new Xr(J.layout_symbol["text-allow-overlap"]),
              "text-overlap": new Xr(J.layout_symbol["text-overlap"]),
              "text-ignore-placement": new Xr(J.layout_symbol["text-ignore-placement"]),
              "text-optional": new Xr(J.layout_symbol["text-optional"])
            })
          }
        };
        class xg {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : _r, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Mr("FormatSectionOverride", xg, {
          omit: ["defaultValue"]
        });
        class Vd extends Ga {
          constructor(t, n) {
            super(t, Cf, n)
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const o = this.layout.get("text-writing-mode");
              if (o) {
                const u = [];
                for (const _ of o) u.indexOf(_) < 0 && u.push(_);
                this.layout._values["text-writing-mode"] = u
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, n, o, u) {
            const _ = this.layout.get(t).evaluate(n, {}, o, u),
              m = this._unevaluatedLayout._values[t];
            return m.isDataDriven() || jl(m.value) || !_ ? _ : (function(y, b) {
              return b.replace(/{([^{}]+)}/g, ((P, I) => y && I in y ? String(y[I]) : ""))
            })(n.properties, _)
          }
          createBucket(t) {
            return new uc(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Cf.paint.overridableProperties) {
              if (!Vd.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t),
                o = new xg(n),
                u = new tu(o, n.property.specification);
              let _ = null;
              _ = n.value.kind === "constant" || n.value.kind === "source" ? new Xs("source", u) : new ru("composite", u, n.value.zoomStops), this.paint._values[t] = new Za(n.property, _, n.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, o) {
            return !(!this.layout || n.isDataDriven() || o.isDataDriven()) && Vd.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, n) {
            const o = t.get("text-field"),
              u = Cf.paint.properties[n];
            let _ = !1;
            const m = y => {
              for (const b of y)
                if (u.overrides && u.overrides.hasOverride(b)) return void(_ = !0)
            };
            if (o.value.kind === "constant" && o.value.value instanceof Ln) m(o.value.value.sections);
            else if (o.value.kind === "source" || o.value.kind === "composite") {
              const y = P => {
                  _ || (P instanceof Mi && Qn(P.value) === wt ? m(P.value.sections) : P instanceof Sl ? m(P.sections) : P.eachChild(y))
                },
                b = o.value;
              b._styleExpression && y(b._styleExpression.expression)
            }
            return _
          }
        }
        let wg;
        var Hb = {
          get paint() {
            return wg = wg || new oa({
              "background-color": new Xr(J.paint_background["background-color"]),
              "background-pattern": new Sd(J.paint_background["background-pattern"]),
              "background-opacity": new Xr(J.paint_background["background-opacity"])
            })
          }
        };
        class $b extends Ga {
          constructor(t, n) {
            super(t, Hb, n)
          }
        }
        class Xb extends Ga {
          constructor(t, n) {
            super(t, {}, n), this.onAdd = o => {
              this.implementation.onAdd && this.implementation.onAdd(o, o.painter.context.gl)
            }, this.onRemove = o => {
              this.implementation.onRemove && this.implementation.onRemove(o, o.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class Yb {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const Kb = {
            once: !0
          },
          zf = 63710088e-1;
        class Ls {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new Ls(lr(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const n = Math.PI / 180,
              o = this.lat * n,
              u = t.lat * n,
              _ = Math.sin(o) * Math.sin(u) + Math.cos(o) * Math.cos(u) * Math.cos((t.lng - this.lng) * n);
            return zf * Math.acos(Math.min(_, 1))
          }
          static convert(t) {
            if (t instanceof Ls) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Ls(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Ls(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const kg = 2 * Math.PI * zf;

        function Tg(i) {
          return kg * Math.cos(i * Math.PI / 180)
        }

        function Sg(i) {
          return (180 + i) / 360
        }

        function Pg(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
        }

        function Mg(i, t) {
          return i / Tg(t)
        }

        function Ig(i) {
          return 360 * i - 180
        }

        function Ud(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
        }

        function Cg(i, t) {
          return i * Tg(Ud(t))
        }
        class qu {
          constructor(t, n, o = 0) {
            this.x = +t, this.y = +n, this.z = +o
          }
          static fromLngLat(t, n = 0) {
            const o = Ls.convert(t);
            return new qu(Sg(o.lng), Pg(o.lat), Mg(n, o.lat))
          }
          toLngLat() {
            return new Ls(Ig(this.x), Ud(this.y))
          }
          toAltitude() {
            return Cg(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / kg * (t = Ud(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function zg(i, t, n) {
          var o = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [i * o - 2 * Math.PI * 6378137 / 2, t * o - 2 * Math.PI * 6378137 / 2]
        }
        class Af {
          constructor(t, n, o) {
            if (!(function(u, _, m) {
                return !(u < 0 || u > 25 || m < 0 || m >= Math.pow(2, u) || _ < 0 || _ >= Math.pow(2, u))
              })(t, n, o)) throw new Error(`x=${n}, y=${o}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = o, this.key = hc(0, t, t, n, o)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, n, o) {
            const u = (m = this.y, y = this.z, b = zg(256 * (_ = this.x), 256 * (m = Math.pow(2, y) - m - 1), y), P = zg(256 * (_ + 1), 256 * (m + 1), y), b[0] + "," + b[1] + "," + P[0] + "," + P[1]);
            var _, m, y, b, P;
            const I = (function(L, B, U) {
              let G, K = "";
              for (let ne = L; ne > 0; ne--) G = 1 << ne - 1, K += (B & G ? 1 : 0) + (U & G ? 2 : 0);
              return K
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, u)
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new F((t.x * n - this.x) * lt, (t.y * n - this.y) * lt)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class Ag {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = hc(t, n.z, n.z, n.x, n.y)
          }
        }
        class Ha {
          constructor(t, n, o, u, _) {
            if (this.terrainRttPosMatrix32f = null, t < o) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${o}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new Af(o, +u, +_), this.key = hc(n, t, o, u, _)
          }
          clone() {
            return new Ha(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new Ha(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ha(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n)
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const o = this.canonical.z - t;
            return t > this.canonical.z ? hc(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : hc(this.wrap * +n, t, t, this.canonical.x >> o, this.canonical.y >> o)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return !1;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const n = this.canonical.z - t.canonical.z;
            return !(n < 0) && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Ha(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1,
              o = 2 * this.canonical.x,
              u = 2 * this.canonical.y;
            return [new Ha(n, this.wrap, n, o, u), new Ha(n, this.wrap, n, o + 1, u), new Ha(n, this.wrap, n, o, u + 1), new Ha(n, this.wrap, n, o + 1, u + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new Ha(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new Ha(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new Ag(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new qu(t.x - this.wrap, t.y))
          }
        }

        function hc(i, t, n, o, u) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const _ = 1 << n;
          return (_ * _ * i + _ * u + o).toString(36) + n.toString(36) + t.toString(36)
        }

        function Nu(i, t) {
          return t ? i.properties[t] : i.id
        }
        Mr("CanonicalTileID", Af), Mr("OverscaledTileID", Ha, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class cl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const n = new cl;
            return n.extend(t(new F(this.minX, this.minY))), n.extend(t(new F(this.maxX, this.minY))), n.extend(t(new F(this.minX, this.maxY))), n.extend(t(new F(this.maxX, this.maxY))), n
          }
          static fromPoints(t) {
            const n = new cl;
            for (const o of t) n.extend(o);
            return n
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class Eg {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const o = t[n];
              this._stringToNumber[o] = n, this._numberToString[n] = o
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class Lg {
          constructor(t, n, o, u, _) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = o, t._y = u, this.properties = t.properties, this.id = _
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t
          }
        }
        class Dg {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new $o(lt, 16, 0), this.grid3D = new $o(lt, 16, 0), this.featureIndexArray = new ce, this.promoteId = n
          }
          insert(t, n, o, u, _, m) {
            const y = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(o, u, _);
            const b = m ? this.grid3D : this.grid;
            for (let P = 0; P < n.length; P++) {
              const I = n[P],
                L = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let B = 0; B < I.length; B++) {
                const U = I[B];
                L[0] = Math.min(L[0], U.x), L[1] = Math.min(L[1], U.y), L[2] = Math.max(L[2], U.x), L[3] = Math.max(L[3], U.y)
              }
              L[0] < lt && L[1] < lt && L[2] >= 0 && L[3] >= 0 && b.insert(y, L[0], L[1], L[2], L[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Ym(new xf(this.rawTileData)).layers, this.sourceLayerCoder = new Eg(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, n, o, u) {
            this.loadVTLayers();
            const _ = t.params,
              m = lt / t.tileSize / t.scale,
              y = Ys(_.filter, _.globalState),
              b = t.queryGeometry,
              P = t.queryPadding * m,
              I = cl.fromPoints(b),
              L = this.grid.query(I.minX - P, I.minY - P, I.maxX + P, I.maxY + P),
              B = cl.fromPoints(t.cameraQueryGeometry).expandBy(P),
              U = this.grid3D.query(B.minX, B.minY, B.maxX, B.maxY, ((ne, pe, Ze, ye) => (function(ze, at, gt, Ht, xr) {
                for (const vr of ze)
                  if (at <= vr.x && gt <= vr.y && Ht >= vr.x && xr >= vr.y) return !0;
                const dr = [new F(at, gt), new F(at, xr), new F(Ht, xr), new F(Ht, gt)];
                if (ze.length > 2) {
                  for (const vr of dr)
                    if (rc(ze, vr)) return !0
                }
                for (let vr = 0; vr < ze.length - 1; vr++)
                  if (My(ze[vr], ze[vr + 1], dr)) return !0;
                return !1
              })(t.cameraQueryGeometry, ne - P, pe - P, Ze + P, ye + P)));
            for (const ne of U) L.push(ne);
            L.sort(Jb);
            const G = {};
            let K;
            for (let ne = 0; ne < L.length; ne++) {
              const pe = L[ne];
              if (pe === K) continue;
              K = pe;
              const Ze = this.featureIndexArray.get(pe);
              let ye = null;
              this.loadMatchingFeature(G, Ze.bucketIndex, Ze.sourceLayerIndex, Ze.featureIndex, y, _.layers, _.availableImages, n, o, u, ((ze, at, gt) => (ye || (ye = go(ze)), at.queryIntersectsFeature({
                queryGeometry: b,
                feature: ze,
                featureState: gt,
                geometry: ye,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: m,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return G
          }
          loadMatchingFeature(t, n, o, u, _, m, y, b, P, I, L) {
            const B = this.bucketLayerIDs[n];
            if (m && !B.some((ne => m.has(ne)))) return;
            const U = this.sourceLayerCoder.decode(o),
              G = this.vtLayers[U].feature(u);
            if (_.needGeometry) {
              const ne = zo(G, !0);
              if (!_.filter(new ei(this.tileID.overscaledZ), ne, this.tileID.canonical)) return
            } else if (!_.filter(new ei(this.tileID.overscaledZ), G)) return;
            const K = this.getId(G, U);
            for (let ne = 0; ne < B.length; ne++) {
              const pe = B[ne];
              if (m && !m.has(pe)) continue;
              const Ze = b[pe];
              if (!Ze) continue;
              let ye = {};
              K && I && (ye = I.getState(Ze.sourceLayer || "_geojsonTileLayer", K));
              const ze = ot({}, P[pe]);
              ze.paint = Rg(ze.paint, Ze.paint, G, ye, y), ze.layout = Rg(ze.layout, Ze.layout, G, ye, y);
              const at = !L || L(G, Ze, ye);
              if (!at) continue;
              const gt = new Lg(G, this.z, this.x, this.y, K);
              gt.layer = ze;
              let Ht = t[pe];
              Ht === void 0 && (Ht = t[pe] = []), Ht.push({
                featureIndex: u,
                feature: gt,
                intersectionZ: at
              })
            }
          }
          lookupSymbolFeatures(t, n, o, u, _, m, y, b) {
            const P = {};
            this.loadVTLayers();
            const I = Ys(_.filterSpec, _.globalState);
            for (const L of t) this.loadMatchingFeature(P, o, u, L, I, m, y, b, n);
            return P
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs)
              for (const o of n)
                if (t === o) return !0;
            return !1
          }
          getId(t, n) {
            var o;
            let u = t.id;
            return this.promoteId && (u = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof u == "boolean" && (u = Number(u)), u === void 0 && (!((o = t.properties) === null || o === void 0) && o.cluster) && this.promoteId && (u = Number(t.properties.cluster_id))), u
          }
        }

        function Rg(i, t, n, o, u) {
          return Ut(i, ((_, m) => {
            const y = t instanceof Xo ? t.get(m) : null;
            return y && y.evaluate ? y.evaluate(n, o, u) : y
          }))
        }

        function Jb(i, t) {
          return t - i
        }

        function jg(i, t, n, o, u) {
          const _ = [];
          for (let m = 0; m < i.length; m++) {
            const y = i[m];
            let b;
            for (let P = 0; P < y.length - 1; P++) {
              let I = y[P],
                L = y[P + 1];
              I.x < t && L.x < t || (I.x < t ? I = new F(t, I.y + (t - I.x) / (L.x - I.x) * (L.y - I.y))._round() : L.x < t && (L = new F(t, I.y + (t - I.x) / (L.x - I.x) * (L.y - I.y))._round()), I.y < n && L.y < n || (I.y < n ? I = new F(I.x + (n - I.y) / (L.y - I.y) * (L.x - I.x), n)._round() : L.y < n && (L = new F(I.x + (n - I.y) / (L.y - I.y) * (L.x - I.x), n)._round()), I.x >= o && L.x >= o || (I.x >= o ? I = new F(o, I.y + (o - I.x) / (L.x - I.x) * (L.y - I.y))._round() : L.x >= o && (L = new F(o, I.y + (o - I.x) / (L.x - I.x) * (L.y - I.y))._round()), I.y >= u && L.y >= u || (I.y >= u ? I = new F(I.x + (u - I.y) / (L.y - I.y) * (L.x - I.x), u)._round() : L.y >= u && (L = new F(I.x + (u - I.y) / (L.y - I.y) * (L.x - I.x), u)._round()), b && I.equals(b[b.length - 1]) || (b = [I], _.push(b)), b.push(L)))))
            }
          }
          return _
        }
        Mr("FeatureIndex", Dg, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class Ds extends F {
          constructor(t, n, o, u) {
            super(t, n), this.angle = o, u !== void 0 && (this.segment = u)
          }
          clone() {
            return new Ds(this.x, this.y, this.angle, this.segment)
          }
        }

        function Fg(i, t, n, o, u) {
          if (t.segment === void 0 || n === 0) return !0;
          let _ = t,
            m = t.segment + 1,
            y = 0;
          for (; y > -n / 2;) {
            if (m--, m < 0) return !1;
            y -= i[m].dist(_), _ = i[m]
          }
          y += i[m].dist(i[m + 1]), m++;
          const b = [];
          let P = 0;
          for (; y < n / 2;) {
            const I = i[m],
              L = i[m + 1];
            if (!L) return !1;
            let B = i[m - 1].angleTo(I) - I.angleTo(L);
            for (B = Math.abs((B + 3 * Math.PI) % (2 * Math.PI) - Math.PI), b.push({
                distance: y,
                angleDelta: B
              }), P += B; y - b[0].distance > o;) P -= b.shift().angleDelta;
            if (P > u) return !1;
            m++, y += I.dist(L)
          }
          return !0
        }

        function Bg(i) {
          let t = 0;
          for (let n = 0; n < i.length - 1; n++) t += i[n].dist(i[n + 1]);
          return t
        }

        function Og(i, t, n) {
          return i ? .6 * t * n : 0
        }

        function qg(i, t) {
          return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0)
        }

        function Qb(i, t, n, o, u, _) {
          const m = Og(n, u, _),
            y = qg(n, o) * _;
          let b = 0;
          const P = Bg(i) / 2;
          for (let I = 0; I < i.length - 1; I++) {
            const L = i[I],
              B = i[I + 1],
              U = L.dist(B);
            if (b + U > P) {
              const G = (P - b) / U,
                K = La.number(L.x, B.x, G),
                ne = La.number(L.y, B.y, G),
                pe = new Ds(K, ne, B.angleTo(L), I);
              return pe._round(), !m || Fg(i, pe, y, m, t) ? pe : void 0
            }
            b += U
          }
        }

        function ex(i, t, n, o, u, _, m, y, b) {
          const P = Og(o, _, m),
            I = qg(o, u),
            L = I * m,
            B = i[0].x === 0 || i[0].x === b || i[0].y === 0 || i[0].y === b;
          return t - L < t / 4 && (t = L + t / 4), Ng(i, B ? t / 2 * y % t : (I / 2 + 2 * _) * m * y % t, t, P, n, L, B, !1, b)
        }

        function Ng(i, t, n, o, u, _, m, y, b) {
          const P = _ / 2,
            I = Bg(i);
          let L = 0,
            B = t - n,
            U = [];
          for (let G = 0; G < i.length - 1; G++) {
            const K = i[G],
              ne = i[G + 1],
              pe = K.dist(ne),
              Ze = ne.angleTo(K);
            for (; B + n < L + pe;) {
              B += n;
              const ye = (B - L) / pe,
                ze = La.number(K.x, ne.x, ye),
                at = La.number(K.y, ne.y, ye);
              if (ze >= 0 && ze < b && at >= 0 && at < b && B - P >= 0 && B + P <= I) {
                const gt = new Ds(ze, at, Ze, G);
                gt._round(), o && !Fg(i, gt, _, o, u) || U.push(gt)
              }
            }
            L += pe
          }
          return y || U.length || m || (U = Ng(i, L / 2, n, o, u, _, m, !0, b)), U
        }

        function Vg(i, t, n, o) {
          const u = [],
            _ = i.image,
            m = _.pixelRatio,
            y = _.paddedRect.w - 2,
            b = _.paddedRect.h - 2;
          let P = {
            x1: i.left,
            y1: i.top,
            x2: i.right,
            y2: i.bottom
          };
          const I = _.stretchX || [
              [0, y]
            ],
            L = _.stretchY || [
              [0, b]
            ],
            B = (Lt, hn) => Lt + hn[1] - hn[0],
            U = I.reduce(B, 0),
            G = L.reduce(B, 0),
            K = y - U,
            ne = b - G;
          let pe = 0,
            Ze = U,
            ye = 0,
            ze = G,
            at = 0,
            gt = K,
            Ht = 0,
            xr = ne;
          if (_.content && o) {
            const Lt = _.content,
              hn = Lt[2] - Lt[0],
              _n = Lt[3] - Lt[1];
            (_.textFitWidth || _.textFitHeight) && (P = mg(i)), pe = Zd(I, 0, Lt[0]), ye = Zd(L, 0, Lt[1]), Ze = Zd(I, Lt[0], Lt[2]), ze = Zd(L, Lt[1], Lt[3]), at = Lt[0] - pe, Ht = Lt[1] - ye, gt = hn - Ze, xr = _n - ze
          }
          const dr = P.x1,
            vr = P.y1,
            en = P.x2 - dr,
            gr = P.y2 - vr,
            yr = (Lt, hn, _n, on) => {
              const $r = Gd(Lt.stretch - pe, Ze, en, dr),
                Bn = Wd(Lt.fixed - at, gt, Lt.stretch, U),
                bi = Gd(hn.stretch - ye, ze, gr, vr),
                Fi = Wd(hn.fixed - Ht, xr, hn.stretch, G),
                la = Gd(_n.stretch - pe, Ze, en, dr),
                $a = Wd(_n.fixed - at, gt, _n.stretch, U),
                Sa = Gd(on.stretch - ye, ze, gr, vr),
                Qi = Wd(on.fixed - Ht, xr, on.stretch, G),
                gi = new F($r, bi),
                Wi = new F(la, bi),
                ea = new F(la, Sa),
                ta = new F($r, Sa),
                ya = new F(Bn / m, Fi / m),
                Xa = new F($a / m, Qi / m),
                Hi = t * Math.PI / 180;
              if (Hi) {
                const $i = Math.sin(Hi),
                  Xi = Math.cos(Hi),
                  Li = [Xi, -$i, $i, Xi];
                gi._matMult(Li), Wi._matMult(Li), ta._matMult(Li), ea._matMult(Li)
              }
              const Pa = Lt.stretch + Lt.fixed,
                Bi = hn.stretch + hn.fixed;
              return {
                tl: gi,
                tr: Wi,
                bl: ta,
                br: ea,
                tex: {
                  x: _.paddedRect.x + 1 + Pa,
                  y: _.paddedRect.y + 1 + Bi,
                  w: _n.stretch + _n.fixed - Pa,
                  h: on.stretch + on.fixed - Bi
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: ya,
                pixelOffsetBR: Xa,
                minFontScaleX: gt / m / en,
                minFontScaleY: xr / m / gr,
                isSDF: n
              }
            };
          if (o && (_.stretchX || _.stretchY)) {
            const Lt = Ug(I, K, U),
              hn = Ug(L, ne, G);
            for (let _n = 0; _n < Lt.length - 1; _n++) {
              const on = Lt[_n],
                $r = Lt[_n + 1];
              for (let Bn = 0; Bn < hn.length - 1; Bn++) u.push(yr(on, hn[Bn], $r, hn[Bn + 1]))
            }
          } else u.push(yr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: y + 1
          }, {
            fixed: 0,
            stretch: b + 1
          }));
          return u
        }

        function Zd(i, t, n) {
          let o = 0;
          for (const u of i) o += Math.max(t, Math.min(n, u[1])) - Math.max(t, Math.min(n, u[0]));
          return o
        }

        function Ug(i, t, n) {
          const o = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [u, _] of i) {
            const m = o[o.length - 1];
            o.push({
              fixed: u - m.stretch,
              stretch: m.stretch
            }), o.push({
              fixed: u - m.stretch,
              stretch: m.stretch + (_ - u)
            })
          }
          return o.push({
            fixed: t + 1,
            stretch: n
          }), o
        }

        function Gd(i, t, n, o) {
          return i / t * n + o
        }

        function Wd(i, t, n, o) {
          return i - t * n / o
        }
        Mr("Anchor", Ds);
        class Hd {
          constructor(t, n, o, u, _, m, y, b, P, I) {
            var L;
            if (this.boxStartIndex = t.length, P) {
              let B = m.top,
                U = m.bottom;
              const G = m.collisionPadding;
              G && (B -= G[1], U += G[3]);
              let K = U - B;
              K > 0 && (K = Math.max(10, K), this.circleDiameter = K)
            } else {
              const B = !((L = m.image) === null || L === void 0) && L.content && (m.image.textFitWidth || m.image.textFitHeight) ? mg(m) : {
                x1: m.left,
                y1: m.top,
                x2: m.right,
                y2: m.bottom
              };
              B.y1 = B.y1 * y - b[0], B.y2 = B.y2 * y + b[2], B.x1 = B.x1 * y - b[3], B.x2 = B.x2 * y + b[1];
              const U = m.collisionPadding;
              if (U && (B.x1 -= U[0] * y, B.y1 -= U[1] * y, B.x2 += U[2] * y, B.y2 += U[3] * y), I) {
                const G = new F(B.x1, B.y1),
                  K = new F(B.x2, B.y1),
                  ne = new F(B.x1, B.y2),
                  pe = new F(B.x2, B.y2),
                  Ze = I * Math.PI / 180;
                G._rotate(Ze), K._rotate(Ze), ne._rotate(Ze), pe._rotate(Ze), B.x1 = Math.min(G.x, K.x, ne.x, pe.x), B.x2 = Math.max(G.x, K.x, ne.x, pe.x), B.y1 = Math.min(G.y, K.y, ne.y, pe.y), B.y2 = Math.max(G.y, K.y, ne.y, pe.y)
              }
              t.emplaceBack(n.x, n.y, B.x1, B.y1, B.x2, B.y2, o, u, _)
            }
            this.boxEndIndex = t.length
          }
        }
        class tx {
          constructor(t = [], n = (o, u) => o < u ? -1 : o > u ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0)
              for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: n,
              compare: o
            } = this, u = n[t];
            for (; t > 0;) {
              const _ = t - 1 >> 1,
                m = n[_];
              if (o(u, m) >= 0) break;
              n[t] = m, t = _
            }
            n[t] = u
          }
          _down(t) {
            const {
              data: n,
              compare: o
            } = this, u = this.length >> 1, _ = n[t];
            for (; t < u;) {
              let m = 1 + (t << 1);
              const y = m + 1;
              if (y < this.length && o(n[y], n[m]) < 0 && (m = y), o(n[m], _) >= 0) break;
              n[t] = n[m], t = m
            }
            n[t] = _
          }
        }

        function rx(i, t = 1, n = !1) {
          const o = cl.fromPoints(i[0]),
            u = Math.min(o.width(), o.height());
          let _ = u / 2;
          const m = new tx([], nx),
            {
              minX: y,
              minY: b,
              maxX: P,
              maxY: I
            } = o;
          if (u === 0) return new F(y, b);
          for (let U = y; U < P; U += u)
            for (let G = b; G < I; G += u) m.push(new dc(U + _, G + _, _, i));
          let L = (function(U) {
              let G = 0,
                K = 0,
                ne = 0;
              const pe = U[0];
              for (let Ze = 0, ye = pe.length, ze = ye - 1; Ze < ye; ze = Ze++) {
                const at = pe[Ze],
                  gt = pe[ze],
                  Ht = at.x * gt.y - gt.x * at.y;
                K += (at.x + gt.x) * Ht, ne += (at.y + gt.y) * Ht, G += 3 * Ht
              }
              return new dc(K / G, ne / G, 0, U)
            })(i),
            B = m.length;
          for (; m.length;) {
            const U = m.pop();
            (U.d > L.d || !L.d) && (L = U, n && console.log("found best %d after %d probes", Math.round(1e4 * U.d) / 1e4, B)), U.max - L.d <= t || (_ = U.h / 2, m.push(new dc(U.p.x - _, U.p.y - _, _, i)), m.push(new dc(U.p.x + _, U.p.y - _, _, i)), m.push(new dc(U.p.x - _, U.p.y + _, _, i)), m.push(new dc(U.p.x + _, U.p.y + _, _, i)), B += 4)
          }
          return n && (console.log(`num probes: ${B}`), console.log(`best distance: ${L.d}`)), L.p
        }

        function nx(i, t) {
          return t.max - i.max
        }

        function dc(i, t, n, o) {
          this.p = new F(i, t), this.h = n, this.d = (function(u, _) {
            let m = !1,
              y = 1 / 0;
            for (let b = 0; b < _.length; b++) {
              const P = _[b];
              for (let I = 0, L = P.length, B = L - 1; I < L; B = I++) {
                const U = P[I],
                  G = P[B];
                U.y > u.y != G.y > u.y && u.x < (G.x - U.x) * (u.y - U.y) / (G.y - U.y) + U.x && (m = !m), y = Math.min(y, Mm(u, U, G))
              }
            }
            return (m ? 1 : -1) * Math.sqrt(y)
          })(this.p, o), this.max = this.d + this.h * Math.SQRT2
        }
        var sa;
        k.aI = void 0, (sa = k.aI || (k.aI = {}))[sa.center = 1] = "center", sa[sa.left = 2] = "left", sa[sa.right = 3] = "right", sa[sa.top = 4] = "top", sa[sa.bottom = 5] = "bottom", sa[sa["top-left"] = 6] = "top-left", sa[sa["top-right"] = 7] = "top-right", sa[sa["bottom-left"] = 8] = "bottom-left", sa[sa["bottom-right"] = 9] = "bottom-right";
        const Ef = Number.POSITIVE_INFINITY;

        function Zg(i, t) {
          return t[1] !== Ef ? (function(n, o, u) {
            let _ = 0,
              m = 0;
            switch (o = Math.abs(o), u = Math.abs(u), n) {
              case "top-right":
              case "top-left":
              case "top":
                m = u - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                m = 7 - u
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                _ = -o;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                _ = o
            }
            return [_, m]
          })(i, t[0], t[1]) : (function(n, o) {
            let u = 0,
              _ = 0;
            o < 0 && (o = 0);
            const m = o / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                _ = m - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                _ = 7 - m;
                break;
              case "bottom":
                _ = 7 - o;
                break;
              case "top":
                _ = o - 7
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                u = -m;
                break;
              case "top-left":
              case "bottom-left":
                u = m;
                break;
              case "left":
                u = o;
                break;
              case "right":
                u = -o
            }
            return [u, _]
          })(i, t[0])
        }

        function Gg(i, t, n) {
          var o;
          const u = i.layout,
            _ = (o = u.get("text-variable-anchor-offset")) === null || o === void 0 ? void 0 : o.evaluate(t, {}, n);
          if (_) {
            const y = _.values,
              b = [];
            for (let P = 0; P < y.length; P += 2) {
              const I = b[P] = y[P],
                L = y[P + 1].map((B => B * Gi));
              I.startsWith("top") ? L[1] -= 7 : I.startsWith("bottom") && (L[1] += 7), b[P + 1] = L
            }
            return new Wn(b)
          }
          const m = u.get("text-variable-anchor");
          if (m) {
            let y;
            y = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(t, {}, n) * Gi, Ef] : u.get("text-offset").evaluate(t, {}, n).map((P => P * Gi));
            const b = [];
            for (const P of m) b.push(P, Zg(P, y));
            return new Wn(b)
          }
          return null
        }

        function Lf(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function ix(i, t, n, o, u, _, m, y, b, P, I, L) {
          let B = _.textMaxSize.evaluate(t, {});
          B === void 0 && (B = m);
          const U = i.layers[0].layout,
            G = U.get("icon-offset").evaluate(t, {}, I),
            K = Hg(n.horizontal),
            ne = m / 24,
            pe = i.tilePixelRatio * ne,
            Ze = i.tilePixelRatio * B / 24,
            ye = i.tilePixelRatio * y,
            ze = i.tilePixelRatio * U.get("symbol-spacing"),
            at = U.get("text-padding") * i.tilePixelRatio,
            gt = (function(_n, on, $r, Bn = 1) {
              const bi = _n.get("icon-padding").evaluate(on, {}, $r),
                Fi = bi && bi.values;
              return [Fi[0] * Bn, Fi[1] * Bn, Fi[2] * Bn, Fi[3] * Bn]
            })(U, t, I, i.tilePixelRatio),
            Ht = U.get("text-max-angle") / 180 * Math.PI,
            xr = U.get("text-rotation-alignment") !== "viewport" && U.get("symbol-placement") !== "point",
            dr = U.get("icon-rotation-alignment") === "map" && U.get("symbol-placement") !== "point",
            vr = U.get("symbol-placement"),
            en = ze / 2,
            gr = U.get("icon-text-fit");
          let yr;
          o && gr !== "none" && (i.allowVerticalPlacement && n.vertical && (yr = gg(o, n.vertical, gr, U.get("icon-text-fit-padding"), G, ne)), K && (o = gg(o, K, gr, U.get("icon-text-fit-padding"), G, ne)));
          const Lt = I ? L.line.getGranularityForZoomLevel(I.z) : 1,
            hn = (_n, on) => {
              on.x < 0 || on.x >= lt || on.y < 0 || on.y >= lt || (function($r, Bn, bi, Fi, la, $a, Sa, Qi, gi, Wi, ea, ta, ya, Xa, Hi, Pa, Bi, $i, Xi, Li, oi, vo, pc, yo, sx) {
                const fc = $r.addToLineVertexArray(Bn, bi);
                let ul, _c, mc, gc, Kg = 0,
                  Jg = 0,
                  Qg = 0,
                  ev = 0,
                  Nf = -1,
                  Vf = -1;
                const as = {};
                let tv = _o("");
                if ($r.allowVerticalPlacement && Fi.vertical) {
                  const pa = Qi.layout.get("text-rotate").evaluate(oi, {}, yo) + 90;
                  mc = new Hd(gi, Bn, Wi, ea, ta, Fi.vertical, ya, Xa, Hi, pa), Sa && (gc = new Hd(gi, Bn, Wi, ea, ta, Sa, Bi, $i, Hi, pa))
                }
                if (la) {
                  const pa = Qi.layout.get("icon-rotate").evaluate(oi, {}),
                    Ya = Qi.layout.get("icon-text-fit") !== "none",
                    hl = Vg(la, pa, pc, Ya),
                    xo = Sa ? Vg(Sa, pa, pc, Ya) : void 0;
                  _c = new Hd(gi, Bn, Wi, ea, ta, la, Bi, $i, !1, pa), Kg = 4 * hl.length;
                  const dl = $r.iconSizeData;
                  let Ao = null;
                  dl.kind === "source" ? (Ao = [is * Qi.layout.get("icon-size").evaluate(oi, {})], Ao[0] > Es && zt(`${$r.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : dl.kind === "composite" && (Ao = [is * vo.compositeIconSizes[0].evaluate(oi, {}, yo), is * vo.compositeIconSizes[1].evaluate(oi, {}, yo)], (Ao[0] > Es || Ao[1] > Es) && zt(`${$r.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), $r.addSymbols($r.icon, hl, Ao, Li, Xi, oi, k.as.none, Bn, fc.lineStartIndex, fc.lineLength, -1, yo), Nf = $r.icon.placedSymbolArray.length - 1, xo && (Jg = 4 * xo.length, $r.addSymbols($r.icon, xo, Ao, Li, Xi, oi, k.as.vertical, Bn, fc.lineStartIndex, fc.lineLength, -1, yo), Vf = $r.icon.placedSymbolArray.length - 1)
                }
                const rv = Object.keys(Fi.horizontal);
                for (const pa of rv) {
                  const Ya = Fi.horizontal[pa];
                  if (!ul) {
                    tv = _o(Ya.text);
                    const xo = Qi.layout.get("text-rotate").evaluate(oi, {}, yo);
                    ul = new Hd(gi, Bn, Wi, ea, ta, Ya, ya, Xa, Hi, xo)
                  }
                  const hl = Ya.positionedLines.length === 1;
                  if (Qg += Wg($r, Bn, Ya, $a, Qi, Hi, oi, Pa, fc, Fi.vertical ? k.as.horizontal : k.as.horizontalOnly, hl ? rv : [pa], as, Nf, vo, yo), hl) break
                }
                Fi.vertical && (ev += Wg($r, Bn, Fi.vertical, $a, Qi, Hi, oi, Pa, fc, k.as.vertical, ["vertical"], as, Vf, vo, yo));
                const lx = ul ? ul.boxStartIndex : $r.collisionBoxArray.length,
                  cx = ul ? ul.boxEndIndex : $r.collisionBoxArray.length,
                  ux = mc ? mc.boxStartIndex : $r.collisionBoxArray.length,
                  hx = mc ? mc.boxEndIndex : $r.collisionBoxArray.length,
                  dx = _c ? _c.boxStartIndex : $r.collisionBoxArray.length,
                  px = _c ? _c.boxEndIndex : $r.collisionBoxArray.length,
                  fx = gc ? gc.boxStartIndex : $r.collisionBoxArray.length,
                  _x = gc ? gc.boxEndIndex : $r.collisionBoxArray.length;
                let bo = -1;
                const Xd = (pa, Ya) => pa && pa.circleDiameter ? Math.max(pa.circleDiameter, Ya) : Ya;
                bo = Xd(ul, bo), bo = Xd(mc, bo), bo = Xd(_c, bo), bo = Xd(gc, bo);
                const nv = bo > -1 ? 1 : 0;
                nv && (bo *= sx / Gi), $r.glyphOffsetArray.length >= uc.MAX_GLYPHS && zt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), oi.sortKey !== void 0 && $r.addToSortKeyRanges($r.symbolInstances.length, oi.sortKey);
                const mx = Gg(Qi, oi, yo),
                  [gx, vx] = (function(pa, Ya) {
                    const hl = pa.length,
                      xo = Ya == null ? void 0 : Ya.values;
                    if ((xo == null ? void 0 : xo.length) > 0)
                      for (let dl = 0; dl < xo.length; dl += 2) {
                        const Ao = xo[dl + 1];
                        pa.emplaceBack(k.aI[xo[dl]], Ao[0], Ao[1])
                      }
                    return [hl, pa.length]
                  })($r.textAnchorOffsets, mx);
                $r.symbolInstances.emplaceBack(Bn.x, Bn.y, as.right >= 0 ? as.right : -1, as.center >= 0 ? as.center : -1, as.left >= 0 ? as.left : -1, as.vertical || -1, Nf, Vf, tv, lx, cx, ux, hx, dx, px, fx, _x, Wi, Qg, ev, Kg, Jg, nv, 0, ya, bo, gx, vx)
              })(i, on, _n, n, o, u, yr, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, pe, [at, at, at, at], xr, b, ye, gt, dr, G, t, _, P, I, m)
            };
          if (vr === "line")
            for (const _n of jg(t.geometry, 0, 0, lt, lt)) {
              const on = ll(_n, Lt),
                $r = ex(on, ze, Ht, n.vertical || K, o, 24, Ze, i.overscaling, lt);
              for (const Bn of $r) K && ax(i, K.text, en, Bn) || hn(on, Bn)
            } else if (vr === "line-center") {
              for (const _n of t.geometry)
                if (_n.length > 1) {
                  const on = ll(_n, Lt),
                    $r = Qb(on, Ht, n.vertical || K, o, 24, Ze);
                  $r && hn(on, $r)
                }
            } else if (t.type === "Polygon")
            for (const _n of Pl(t.geometry, 0)) {
              const on = rx(_n, 16);
              hn(ll(_n[0], Lt, !0), new Ds(on.x, on.y, 0))
            } else if (t.type === "LineString")
              for (const _n of t.geometry) {
                const on = ll(_n, Lt);
                hn(on, new Ds(on[0].x, on[0].y, 0))
              } else if (t.type === "Point")
                for (const _n of t.geometry)
                  for (const on of _n) hn([on], new Ds(on.x, on.y, 0))
        }

        function Wg(i, t, n, o, u, _, m, y, b, P, I, L, B, U, G) {
          const K = (function(Ze, ye, ze, at, gt, Ht, xr, dr) {
              const vr = at.layout.get("text-rotate").evaluate(Ht, {}) * Math.PI / 180,
                en = [];
              for (const gr of ye.positionedLines)
                for (const yr of gr.positionedGlyphs) {
                  if (!yr.rect) continue;
                  const Lt = yr.rect || {};
                  let hn = 4,
                    _n = !0,
                    on = 1,
                    $r = 0;
                  const Bn = (gt || dr) && yr.vertical,
                    bi = yr.metrics.advance * yr.scale / 2;
                  if (dr && ye.verticalizable && ($r = gr.lineOffset / 2 - (yr.imageName ? -(Gi - yr.metrics.width * yr.scale) / 2 : (yr.scale - 1) * Gi)), yr.imageName) {
                    const $i = xr[yr.imageName];
                    _n = $i.sdf, on = $i.pixelRatio, hn = 1 / on
                  }
                  const Fi = gt ? [yr.x + bi, yr.y] : [0, 0];
                  let la = gt ? [0, 0] : [yr.x + bi + ze[0], yr.y + ze[1] - $r],
                    $a = [0, 0];
                  Bn && ($a = la, la = [0, 0]);
                  const Sa = yr.metrics.isDoubleResolution ? 2 : 1,
                    Qi = (yr.metrics.left - hn) * yr.scale - bi + la[0],
                    gi = (-yr.metrics.top - hn) * yr.scale + la[1],
                    Wi = Qi + Lt.w / Sa * yr.scale / on,
                    ea = gi + Lt.h / Sa * yr.scale / on,
                    ta = new F(Qi, gi),
                    ya = new F(Wi, gi),
                    Xa = new F(Qi, ea),
                    Hi = new F(Wi, ea);
                  if (Bn) {
                    const $i = new F(-bi, bi - -17),
                      Xi = -Math.PI / 2,
                      Li = 12 - bi,
                      oi = new F(22 - Li, -(yr.imageName ? Li : 0)),
                      vo = new F(...$a);
                    ta._rotateAround(Xi, $i)._add(oi)._add(vo), ya._rotateAround(Xi, $i)._add(oi)._add(vo), Xa._rotateAround(Xi, $i)._add(oi)._add(vo), Hi._rotateAround(Xi, $i)._add(oi)._add(vo)
                  }
                  if (vr) {
                    const $i = Math.sin(vr),
                      Xi = Math.cos(vr),
                      Li = [Xi, -$i, $i, Xi];
                    ta._matMult(Li), ya._matMult(Li), Xa._matMult(Li), Hi._matMult(Li)
                  }
                  const Pa = new F(0, 0),
                    Bi = new F(0, 0);
                  en.push({
                    tl: ta,
                    tr: ya,
                    bl: Xa,
                    br: Hi,
                    tex: Lt,
                    writingMode: ye.writingMode,
                    glyphOffset: Fi,
                    sectionIndex: yr.sectionIndex,
                    isSDF: _n,
                    pixelOffsetTL: Pa,
                    pixelOffsetBR: Bi,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return en
            })(0, n, y, u, _, m, o, i.allowVerticalPlacement),
            ne = i.textSizeData;
          let pe = null;
          ne.kind === "source" ? (pe = [is * u.layout.get("text-size").evaluate(m, {})], pe[0] > Es && zt(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ne.kind === "composite" && (pe = [is * U.compositeTextSizes[0].evaluate(m, {}, G), is * U.compositeTextSizes[1].evaluate(m, {}, G)], (pe[0] > Es || pe[1] > Es) && zt(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, K, pe, y, _, m, P, t, b.lineStartIndex, b.lineLength, B, G);
          for (const Ze of I) L[Ze] = i.text.placedSymbolArray.length - 1;
          return 4 * K.length
        }

        function Hg(i) {
          for (const t in i) return i[t];
          return null
        }

        function ax(i, t, n, o) {
          const u = i.compareText;
          if (t in u) {
            const _ = u[t];
            for (let m = _.length - 1; m >= 0; m--)
              if (o.dist(_[m]) < n) return !0
          } else u[t] = [];
          return u[t].push(o), !1
        }
        const $g = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Df {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, o] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const u = o >> 4;
            if (u !== 1) throw new Error(`Got v${u} data when expected v1.`);
            const _ = $g[15 & o];
            if (!_) throw new Error("Unrecognized array type.");
            const [m] = new Uint16Array(t, 2, 1), [y] = new Uint32Array(t, 4, 1);
            return new Df(y, m, _, t)
          }
          constructor(t, n = 64, o = Float64Array, u) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = o, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const _ = $g.indexOf(this.ArrayType),
              m = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              y = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              b = (8 - y % 8) % 8;
            if (_ < 0) throw new Error(`Unexpected typed array class: ${o}.`);
            u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + y + b, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + y + b), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + y + b, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + _]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, n) {
            const o = this._pos >> 1;
            return this.ids[o] = o, this.coords[this._pos++] = t, this.coords[this._pos++] = n, o
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Rf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, n, o, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: _,
              coords: m,
              nodeSize: y
            } = this, b = [0, _.length - 1, 0], P = [];
            for (; b.length;) {
              const I = b.pop() || 0,
                L = b.pop() || 0,
                B = b.pop() || 0;
              if (L - B <= y) {
                for (let ne = B; ne <= L; ne++) {
                  const pe = m[2 * ne],
                    Ze = m[2 * ne + 1];
                  pe >= t && pe <= o && Ze >= n && Ze <= u && P.push(_[ne])
                }
                continue
              }
              const U = B + L >> 1,
                G = m[2 * U],
                K = m[2 * U + 1];
              G >= t && G <= o && K >= n && K <= u && P.push(_[U]), (I === 0 ? t <= G : n <= K) && (b.push(B), b.push(U - 1), b.push(1 - I)), (I === 0 ? o >= G : u >= K) && (b.push(U + 1), b.push(L), b.push(1 - I))
            }
            return P
          }
          within(t, n, o) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: u,
              coords: _,
              nodeSize: m
            } = this, y = [0, u.length - 1, 0], b = [], P = o * o;
            for (; y.length;) {
              const I = y.pop() || 0,
                L = y.pop() || 0,
                B = y.pop() || 0;
              if (L - B <= m) {
                for (let ne = B; ne <= L; ne++) Yg(_[2 * ne], _[2 * ne + 1], t, n) <= P && b.push(u[ne]);
                continue
              }
              const U = B + L >> 1,
                G = _[2 * U],
                K = _[2 * U + 1];
              Yg(G, K, t, n) <= P && b.push(u[U]), (I === 0 ? t - o <= G : n - o <= K) && (y.push(B), y.push(U - 1), y.push(1 - I)), (I === 0 ? t + o >= G : n + o >= K) && (y.push(U + 1), y.push(L), y.push(1 - I))
            }
            return b
          }
        }

        function Rf(i, t, n, o, u, _) {
          if (u - o <= n) return;
          const m = o + u >> 1;
          Xg(i, t, m, o, u, _), Rf(i, t, n, o, m - 1, 1 - _), Rf(i, t, n, m + 1, u, 1 - _)
        }

        function Xg(i, t, n, o, u, _) {
          for (; u > o;) {
            if (u - o > 600) {
              const P = u - o + 1,
                I = n - o + 1,
                L = Math.log(P),
                B = .5 * Math.exp(2 * L / 3),
                U = .5 * Math.sqrt(L * B * (P - B) / P) * (I - P / 2 < 0 ? -1 : 1);
              Xg(i, t, n, Math.max(o, Math.floor(n - I * B / P + U)), Math.min(u, Math.floor(n + (P - I) * B / P + U)), _)
            }
            const m = t[2 * n + _];
            let y = o,
              b = u;
            for (Vu(i, t, o, n), t[2 * u + _] > m && Vu(i, t, o, u); y < b;) {
              for (Vu(i, t, y, b), y++, b--; t[2 * y + _] < m;) y++;
              for (; t[2 * b + _] > m;) b--
            }
            t[2 * o + _] === m ? Vu(i, t, o, b) : (b++, Vu(i, t, b, u)), b <= n && (o = b + 1), n <= b && (u = b - 1)
          }
        }

        function Vu(i, t, n, o) {
          jf(i, n, o), jf(t, 2 * n, 2 * o), jf(t, 2 * n + 1, 2 * o + 1)
        }

        function jf(i, t, n) {
          const o = i[t];
          i[t] = i[n], i[n] = o
        }

        function Yg(i, t, n, o) {
          const u = i - n,
            _ = t - o;
          return u * u + _ * _
        }
        var Ff;
        k.cA = void 0, (Ff = k.cA || (k.cA = {})).create = "create", Ff.load = "load", Ff.fullLoad = "fullLoad";
        let $d = null,
          Uu = [];
        const Bf = 1e3 / 60,
          Of = "loadTime",
          qf = "fullLoadTime",
          ox = {
            mark(i) {
              performance.mark(i)
            },
            frame(i) {
              const t = i;
              $d != null && Uu.push(t - $d), $d = t
            },
            clearMetrics() {
              $d = null, Uu = [], performance.clearMeasures(Of), performance.clearMeasures(qf);
              for (const i in k.cA) performance.clearMarks(k.cA[i])
            },
            getPerformanceMetrics() {
              performance.measure(Of, k.cA.create, k.cA.load), performance.measure(qf, k.cA.create, k.cA.fullLoad);
              const i = performance.getEntriesByName(Of)[0].duration,
                t = performance.getEntriesByName(qf)[0].duration,
                n = Uu.length,
                o = 1 / (Uu.reduce(((_, m) => _ + m), 0) / n / 1e3),
                u = Uu.filter((_ => _ > Bf)).reduce(((_, m) => _ + (m - Bf) / Bf), 0);
              return {
                loadTime: i,
                fullLoadTime: t,
                fps: o,
                percentDroppedFrames: u / (n + u) * 100,
                totalFrames: n
              }
            }
          };
        k.$ = wr, k.A = be, k.B = Ps, k.C = function([i, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, {
            x: i * Math.cos(t) * Math.sin(n),
            y: i * Math.sin(t) * Math.sin(n),
            z: i * Math.cos(n)
          }
        }, k.D = Xr, k.E = ie, k.F = La, k.G = ei, k.H = el, k.I = wf, k.J = Gt, k.K = class {
          constructor(i, t) {
            this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Yb((() => this.process())), this.subscription = kr(this.target, "message", (n => this.receive(n)), !1), this.globalScope = kt(self) ? i : window
          }
          registerMessageHandler(i, t) {
            this.messageHandlers[i] = t
          }
          sendAsync(i, t) {
            return new Promise(((n, o) => {
              const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                _ = t ? kr(t.signal, "abort", (() => {
                  _ == null || _.unsubscribe(), delete this.resolveRejects[u];
                  const b = {
                    id: u,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: i.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(b)
                }), Kb) : null;
              this.resolveRejects[u] = {
                resolve: b => {
                  _ == null || _.unsubscribe(), n(b)
                },
                reject: b => {
                  _ == null || _.unsubscribe(), o(b)
                }
              };
              const m = [],
                y = Object.assign(Object.assign({}, i), {
                  id: u,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: ho(i.data, m)
                });
              this.target.postMessage(y, {
                transfer: m
              })
            }))
          }
          receive(i) {
            const t = i.data,
              n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const o = this.abortControllers[n];
                return delete this.abortControllers[n], void(o && o.abort())
              }
              if (kt(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(),
              t = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t)
          }
          processTask(i, t) {
            return l(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const u = this.resolveRejects[i];
                return delete this.resolveRejects[i], u ? void(t.error ? u.reject(tl(t.error)) : u.resolve(tl(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = tl(t.data),
                o = new AbortController;
              this.abortControllers[i] = o;
              try {
                const u = yield this.messageHandlers[t.type](t.sourceMapId, n, o);
                this.completeTask(i, null, u)
              } catch (u) {
                this.completeTask(i, u)
              }
            }))
          }
          completeTask(i, t, n) {
            const o = [];
            delete this.abortControllers[i];
            const u = {
              id: i,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? ho(t) : null,
              data: ho(n, o)
            };
            this.target.postMessage(u, {
              transfer: o
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, k.L = X, k.M = function() {
          var i = new be(16);
          return be != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i
        }, k.N = function(i, t, n) {
          var o, u, _, m, y, b, P, I, L, B, U, G, K = n[0],
            ne = n[1],
            pe = n[2];
          return t === i ? (i[12] = t[0] * K + t[4] * ne + t[8] * pe + t[12], i[13] = t[1] * K + t[5] * ne + t[9] * pe + t[13], i[14] = t[2] * K + t[6] * ne + t[10] * pe + t[14], i[15] = t[3] * K + t[7] * ne + t[11] * pe + t[15]) : (u = t[1], _ = t[2], m = t[3], y = t[4], b = t[5], P = t[6], I = t[7], L = t[8], B = t[9], U = t[10], G = t[11], i[0] = o = t[0], i[1] = u, i[2] = _, i[3] = m, i[4] = y, i[5] = b, i[6] = P, i[7] = I, i[8] = L, i[9] = B, i[10] = U, i[11] = G, i[12] = o * K + y * ne + L * pe + t[12], i[13] = u * K + b * ne + B * pe + t[13], i[14] = _ * K + P * ne + U * pe + t[14], i[15] = m * K + I * ne + G * pe + t[15]), i
        }, k.O = function(i, t, n) {
          var o = n[0],
            u = n[1],
            _ = n[2];
          return i[0] = t[0] * o, i[1] = t[1] * o, i[2] = t[2] * o, i[3] = t[3] * o, i[4] = t[4] * u, i[5] = t[5] * u, i[6] = t[6] * u, i[7] = t[7] * u, i[8] = t[8] * _, i[9] = t[9] * _, i[10] = t[10] * _, i[11] = t[11] * _, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, k.P = F, k.Q = function(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = t[3],
            y = t[4],
            b = t[5],
            P = t[6],
            I = t[7],
            L = t[8],
            B = t[9],
            U = t[10],
            G = t[11],
            K = t[12],
            ne = t[13],
            pe = t[14],
            Ze = t[15],
            ye = n[0],
            ze = n[1],
            at = n[2],
            gt = n[3];
          return i[0] = ye * o + ze * y + at * L + gt * K, i[1] = ye * u + ze * b + at * B + gt * ne, i[2] = ye * _ + ze * P + at * U + gt * pe, i[3] = ye * m + ze * I + at * G + gt * Ze, i[4] = (ye = n[4]) * o + (ze = n[5]) * y + (at = n[6]) * L + (gt = n[7]) * K, i[5] = ye * u + ze * b + at * B + gt * ne, i[6] = ye * _ + ze * P + at * U + gt * pe, i[7] = ye * m + ze * I + at * G + gt * Ze, i[8] = (ye = n[8]) * o + (ze = n[9]) * y + (at = n[10]) * L + (gt = n[11]) * K, i[9] = ye * u + ze * b + at * B + gt * ne, i[10] = ye * _ + ze * P + at * U + gt * pe, i[11] = ye * m + ze * I + at * G + gt * Ze, i[12] = (ye = n[12]) * o + (ze = n[13]) * y + (at = n[14]) * L + (gt = n[15]) * K, i[13] = ye * u + ze * b + at * B + gt * ne, i[14] = ye * _ + ze * P + at * U + gt * pe, i[15] = ye * m + ze * I + at * G + gt * Ze, i
        }, k.R = Ta, k.S = function(i, t) {
          const n = {};
          for (let o = 0; o < t.length; o++) {
            const u = t[o];
            u in i && (n[u] = i[u])
          }
          return n
        }, k.T = df, k.U = Ls, k.V = lr, k.W = Pg, k.X = Sg, k.Y = Me, k.Z = we, k._ = l, k.a = O, k.a$ = function(i, t, n) {
          return i[0] = t[0] * n[0], i[1] = t[1] * n[1], i[2] = t[2] * n[2], i[3] = t[3] * n[3], i
        }, k.a0 = Ha, k.a1 = Ig, k.a2 = Ud, k.a3 = lt, k.a4 = function(i, t) {
          var n, o, u, _, m;
          if (!i) return t ?? {};
          if (!t) return i;
          let y = Object.assign({}, i);
          if (t.removeAll && (y = {
              removeAll: !0
            }), t.remove) {
            const b = new Set(t.remove);
            y.add && (y.add = y.add.filter((I => !b.has(I.id)))), y.update && (y.update = y.update.filter((I => !b.has(I.id))));
            const P = new Set(((n = i.add) !== null && n !== void 0 ? n : []).map((I => I.id)));
            t.remove = t.remove.filter((I => !P.has(I)))
          }
          if (t.remove) {
            const b = new Set(y.remove ? y.remove.concat(t.remove) : t.remove);
            y.remove = Array.from(b.values())
          }
          if (t.add) {
            const b = y.add ? y.add.concat(t.add) : t.add,
              P = new Map(b.map((I => [I.id, I])));
            y.add = Array.from(P.values())
          }
          if (t.update) {
            const b = new Map((o = y.update) === null || o === void 0 ? void 0 : o.map((P => [P.id, P])));
            for (const P of t.update) {
              const I = (u = b.get(P.id)) !== null && u !== void 0 ? u : {
                id: P.id
              };
              P.newGeometry && (I.newGeometry = P.newGeometry), P.addOrUpdateProperties && (I.addOrUpdateProperties = ((_ = I.addOrUpdateProperties) !== null && _ !== void 0 ? _ : []).concat(P.addOrUpdateProperties)), P.removeProperties && (I.removeProperties = ((m = I.removeProperties) !== null && m !== void 0 ? m : []).concat(P.removeProperties)), P.removeAllProperties && (I.removeAllProperties = !0), b.set(P.id, I)
            }
            y.update = Array.from(b.values())
          }
          return y.remove && y.add && (y.remove = y.remove.filter((b => y.add.findIndex((P => P.id === b)) === -1))), y
        }, k.a5 = qu, k.a6 = cl, k.a7 = 25, k.a8 = Af, k.a9 = i => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((n => {
            t.onloadstart = () => {
              n(t)
            };
            for (const o of i) {
              const u = window.document.createElement("source");
              ke(o) || (t.crossOrigin = "Anonymous"), u.src = o, t.appendChild(u)
            }
          }))
        }, k.aA = We, k.aB = function(i, t, n, o) {
          const u = t.y - i.y,
            _ = t.x - i.x,
            m = o.y - n.y,
            y = o.x - n.x,
            b = m * _ - y * u;
          if (b === 0) return null;
          const P = (y * (i.y - n.y) - m * (i.x - n.x)) / b;
          return new F(i.x + P * _, i.y + P * u)
        }, k.aC = jg, k.aD = Sm, k.aE = function(i) {
          let t = 1 / 0,
            n = 1 / 0,
            o = -1 / 0,
            u = -1 / 0;
          for (const _ of i) t = Math.min(t, _.x), n = Math.min(n, _.y), o = Math.max(o, _.x), u = Math.max(u, _.y);
          return [t, n, o, u]
        }, k.aF = Gi, k.aG = $t, k.aH = function(i, t, n, o, u = !1) {
          if (!n[0] && !n[1]) return [0, 0];
          const _ = u ? o === "map" ? -i.bearingInRadians : 0 : o === "viewport" ? i.bearingInRadians : 0;
          if (_) {
            const m = Math.sin(_),
              y = Math.cos(_);
            n = [n[0] * y - n[1] * m, n[0] * m + n[1] * y]
          }
          return [u ? n[0] : $t(t, n[0], i.zoom), u ? n[1] : $t(t, n[1], i.zoom)]
        }, k.aJ = Sf, k.aK = Lf, k.aL = Tf, k.aM = Df, k.aN = wi, k.aO = Fd, k.aP = me, k.aQ = zn, k.aR = Bt, k.aS = Wr, k.aT = Cg, k.aU = Le, k.aV = Ke, k.aW = function(i) {
          var t = new be(3);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t
        }, k.aX = function(i, t, n) {
          return i[0] = t[0] - n[0], i[1] = t[1] - n[1], i[2] = t[2] - n[2], i
        }, k.aY = function(i, t) {
          var n = t[0],
            o = t[1],
            u = t[2],
            _ = n * n + o * o + u * u;
          return _ > 0 && (_ = 1 / Math.sqrt(_)), i[0] = t[0] * _, i[1] = t[1] * _, i[2] = t[2] * _, i
        }, k.aZ = Ne, k.a_ = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2]
        }, k.aa = qe, k.ab = function() {
          return nt++
        }, k.ac = w, k.ad = uc, k.ae = Ys, k.af = zo, k.ag = Lg, k.ah = function(i) {
          const t = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, o, u, _) => {
              const m = u || _;
              return t[o] = !m || m.toLowerCase(), ""
            })), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n
          }
          return t
        }, k.ai = Yt, k.aj = 85.051129, k.ak = Zr, k.al = function(i) {
          return Math.pow(2, i)
        }, k.am = tt, k.an = Mg, k.ao = function(i) {
          return Math.log(i) / Math.LN2
        }, k.ap = function(i) {
          var t = i[0],
            n = i[1];
          return t * t + n * n
        }, k.aq = function(i) {
          if (!i.length) return new Set;
          const t = Math.max(...i.map((b => b.canonical.z)));
          let n = 1 / 0,
            o = -1 / 0,
            u = 1 / 0,
            _ = -1 / 0;
          const m = [];
          for (const b of i) {
            const {
              x: P,
              y: I,
              z: L
            } = b.canonical, B = Math.pow(2, t - L), U = P * B, G = I * B;
            m.push({
              id: b,
              x: U,
              y: G
            }), U < n && (n = U), U > o && (o = U), G < u && (u = G), G > _ && (_ = G)
          }
          const y = new Set;
          for (const b of m) b.x !== n && b.x !== o && b.y !== u && b.y !== _ || y.add(b.id);
          return y
        }, k.ar = function(i, t) {
          let n = 0,
            o = 0;
          if (i.kind === "constant") o = i.layoutSize;
          else if (i.kind !== "source") {
            const {
              interpolationType: u,
              minZoom: _,
              maxZoom: m
            } = i, y = u ? Yt(Hn.interpolationFactor(u, t, _, m), 0, 1) : 0;
            i.kind === "camera" ? o = La.number(i.minSize, i.maxSize, y) : n = y
          }
          return {
            uSizeT: n,
            uSize: o
          }
        }, k.at = function(i, {
          uSize: t,
          uSizeT: n
        }, {
          lowerSize: o,
          upperSize: u
        }) {
          return i.kind === "source" ? o / is : i.kind === "composite" ? La.number(o / is, u / is, n) : t
        }, k.au = function(i, t) {
          var n = t[0],
            o = t[1],
            u = t[2],
            _ = t[3],
            m = t[4],
            y = t[5],
            b = t[6],
            P = t[7],
            I = t[8],
            L = t[9],
            B = t[10],
            U = t[11],
            G = t[12],
            K = t[13],
            ne = t[14],
            pe = t[15],
            Ze = n * y - o * m,
            ye = n * b - u * m,
            ze = n * P - _ * m,
            at = o * b - u * y,
            gt = o * P - _ * y,
            Ht = u * P - _ * b,
            xr = I * K - L * G,
            dr = I * ne - B * G,
            vr = I * pe - U * G,
            en = L * ne - B * K,
            gr = L * pe - U * K,
            yr = B * pe - U * ne,
            Lt = Ze * yr - ye * gr + ze * en + at * vr - gt * dr + Ht * xr;
          return Lt ? (i[0] = (y * yr - b * gr + P * en) * (Lt = 1 / Lt), i[1] = (u * gr - o * yr - _ * en) * Lt, i[2] = (K * Ht - ne * gt + pe * at) * Lt, i[3] = (B * gt - L * Ht - U * at) * Lt, i[4] = (b * vr - m * yr - P * dr) * Lt, i[5] = (n * yr - u * vr + _ * dr) * Lt, i[6] = (ne * ze - G * Ht - pe * ye) * Lt, i[7] = (I * Ht - B * ze + U * ye) * Lt, i[8] = (m * gr - y * vr + P * xr) * Lt, i[9] = (o * vr - n * gr - _ * xr) * Lt, i[10] = (G * gt - K * ze + pe * Ze) * Lt, i[11] = (L * ze - I * gt - U * Ze) * Lt, i[12] = (y * dr - m * en - b * xr) * Lt, i[13] = (n * en - o * dr + u * xr) * Lt, i[14] = (K * ye - G * at - ne * Ze) * Lt, i[15] = (I * at - L * ye + B * Ze) * Lt, i) : null
        }, k.av = Et, k.aw = function(i) {
          var t = i[0],
            n = i[1];
          return Math.sqrt(t * t + n * n)
        }, k.ax = function(i) {
          return i[0] = 0, i[1] = 0, i
        }, k.ay = function(i, t, n) {
          return i[0] = t[0] * n, i[1] = t[1] * n, i
        }, k.az = Pf, k.b = ht, k.b$ = function(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2];
          return i[0] = o * n[0] + u * n[3] + _ * n[6], i[1] = o * n[1] + u * n[4] + _ * n[7], i[2] = o * n[2] + u * n[5] + _ * n[8], i
        }, k.b0 = Ce, k.b1 = function(i, t, n) {
          const o = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
          return o === 0 ? null : (-(i[0] * n[0] + i[1] * n[1] + i[2] * n[2]) - n[3]) / o
        }, k.b2 = et, k.b3 = function(i, t, n) {
          return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i[3] = t[3] * n, i
        }, k.b4 = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3]
        }, k.b5 = Ag, k.b6 = hc, k.b7 = function(i, t, n, o, u) {
          var _ = 1 / Math.tan(t / 2);
          if (i[0] = _ / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = _, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, u != null && u !== 1 / 0) {
            var m = 1 / (o - u);
            i[10] = (u + o) * m, i[14] = 2 * u * o * m
          } else i[10] = -1, i[14] = -2 * o;
          return i
        }, k.b8 = function(i) {
          var t = new be(16);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t
        }, k.b9 = function(i, t, n) {
          var o = Math.sin(n),
            u = Math.cos(n),
            _ = t[0],
            m = t[1],
            y = t[2],
            b = t[3],
            P = t[4],
            I = t[5],
            L = t[6],
            B = t[7];
          return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = _ * u + P * o, i[1] = m * u + I * o, i[2] = y * u + L * o, i[3] = b * u + B * o, i[4] = P * u - _ * o, i[5] = I * u - m * o, i[6] = L * u - y * o, i[7] = B * u - b * o, i
        }, k.bA = function(i, t, n, o) {
          var u = [],
            _ = [];
          return u[0] = t[0] - n[0], u[1] = t[1] - n[1], u[2] = t[2] - n[2], _[0] = u[0], _[1] = u[1] * Math.cos(o) - u[2] * Math.sin(o), _[2] = u[1] * Math.sin(o) + u[2] * Math.cos(o), i[0] = _[0] + n[0], i[1] = _[1] + n[1], i[2] = _[2] + n[2], i
        }, k.bB = function(i, t, n, o) {
          var u = [],
            _ = [];
          return u[0] = t[0] - n[0], u[1] = t[1] - n[1], u[2] = t[2] - n[2], _[0] = u[2] * Math.sin(o) + u[0] * Math.cos(o), _[1] = u[1], _[2] = u[2] * Math.cos(o) - u[0] * Math.sin(o), i[0] = _[0] + n[0], i[1] = _[1] + n[1], i[2] = _[2] + n[2], i
        }, k.bC = function(i, t, n) {
          var o = Math.sin(n),
            u = Math.cos(n),
            _ = t[0],
            m = t[1],
            y = t[2],
            b = t[3],
            P = t[8],
            I = t[9],
            L = t[10],
            B = t[11];
          return t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = _ * u - P * o, i[1] = m * u - I * o, i[2] = y * u - L * o, i[3] = b * u - B * o, i[8] = _ * o + P * u, i[9] = m * o + I * u, i[10] = y * o + L * u, i[11] = b * o + B * u, i
        }, k.bD = function(i, t) {
          const n = yt(i, 360),
            o = yt(t, 360),
            u = o - n,
            _ = o > n ? u - 360 : u + 360;
          return Math.abs(u) < Math.abs(_) ? u : _
        }, k.bE = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i
        }, k.bF = function(i, t, n, o) {
          const u = Math.sqrt(i * i + t * t),
            _ = Math.sqrt(n * n + o * o);
          i /= u, t /= u, n /= _, o /= _;
          const m = Math.acos(i * n + t * o);
          return -t * n + i * o > 0 ? m : -m
        }, k.bG = function(i, t) {
          const n = yt(i, 2 * Math.PI),
            o = yt(t, 2 * Math.PI);
          return Math.min(Math.abs(n - o), Math.abs(n - o + 2 * Math.PI), Math.abs(n - o - 2 * Math.PI))
        }, k.bH = function() {
          const i = {},
            t = J.$version;
          for (const n in J.$root) {
            const o = J.$root[n];
            if (o.required) {
              let u = null;
              u = n === "version" ? t : o.type === "array" ? [] : {}, u != null && (i[n] = u)
            }
          }
          return i
        }, k.bI = fu, k.bJ = Q, k.bK = function i(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return !1;
            for (let o = 0; o < t.length; o++)
              if (!i(t[o], n[o])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
            for (const o in t)
              if (!i(t[o], n[o])) return !1;
            return !0
          }
          return t === n
        }, k.bL = function(i) {
          i = i.slice();
          const t = Object.create(null);
          for (let n = 0; n < i.length; n++) t[i[n].id] = i[n];
          for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = rt(i[n], t[i[n].ref]));
          return i
        }, k.bM = function(i, t) {
          if (i.type === "custom") return new Xb(i, t);
          switch (i.type) {
            case "background":
              return new $b(i, t);
            case "circle":
              return new Ly(i, t);
            case "color-relief":
              return new Oy(i, t);
            case "fill":
              return new eb(i, t);
            case "fill-extrusion":
              return new hb(i, t);
            case "heatmap":
              return new Ry(i, t);
            case "hillshade":
              return new Fy(i, t);
            case "line":
              return new vb(i, t);
            case "raster":
              return new rf(i, t);
            case "symbol":
              return new Vd(i, t)
          }
        }, k.bN = i => i.type === "raster", k.bO = Ot, k.bP = function(i, t) {
          if (!i) return [{
            command: "setStyle",
            args: [t]
          }];
          let n = [];
          try {
            if (!Ue(i.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            Ue(i.center, t.center) || n.push({
              command: "setCenter",
              args: [t.center]
            }), Ue(i.state, t.state) || n.push({
              command: "setGlobalState",
              args: [t.state]
            }), Ue(i.centerAltitude, t.centerAltitude) || n.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), Ue(i.zoom, t.zoom) || n.push({
              command: "setZoom",
              args: [t.zoom]
            }), Ue(i.bearing, t.bearing) || n.push({
              command: "setBearing",
              args: [t.bearing]
            }), Ue(i.pitch, t.pitch) || n.push({
              command: "setPitch",
              args: [t.pitch]
            }), Ue(i.roll, t.roll) || n.push({
              command: "setRoll",
              args: [t.roll]
            }), Ue(i.sprite, t.sprite) || n.push({
              command: "setSprite",
              args: [t.sprite]
            }), Ue(i.glyphs, t.glyphs) || n.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), Ue(i.transition, t.transition) || n.push({
              command: "setTransition",
              args: [t.transition]
            }), Ue(i.light, t.light) || n.push({
              command: "setLight",
              args: [t.light]
            }), Ue(i.terrain, t.terrain) || n.push({
              command: "setTerrain",
              args: [t.terrain]
            }), Ue(i.sky, t.sky) || n.push({
              command: "setSky",
              args: [t.sky]
            }), Ue(i.projection, t.projection) || n.push({
              command: "setProjection",
              args: [t.projection]
            });
            const o = {},
              u = [];
            (function(m, y, b, P) {
              let I;
              for (I in y = y || {}, m = m || {}) Object.prototype.hasOwnProperty.call(m, I) && (Object.prototype.hasOwnProperty.call(y, I) || $e(I, b, P));
              for (I in y) Object.prototype.hasOwnProperty.call(y, I) && (Object.prototype.hasOwnProperty.call(m, I) ? Ue(m[I], y[I]) || (m[I].type === "geojson" && y[I].type === "geojson" && Tt(m, y, I) ? ae(b, {
                command: "setGeoJSONSourceData",
                args: [I, y[I].data]
              }) : dt(I, y, b, P)) : Ie(I, y, b))
            })(i.sources, t.sources, u, o);
            const _ = [];
            i.layers && i.layers.forEach((m => {
              "source" in m && o[m.source] ? n.push({
                command: "removeLayer",
                args: [m.id]
              }) : _.push(m)
            })), n = n.concat(u), (function(m, y, b) {
              y = y || [];
              const P = (m = m || []).map(St),
                I = y.map(St),
                L = m.reduce(qt, {}),
                B = y.reduce(qt, {}),
                U = P.slice(),
                G = Object.create(null);
              let K, ne, pe, Ze, ye;
              for (let ze = 0, at = 0; ze < P.length; ze++) K = P[ze], Object.prototype.hasOwnProperty.call(B, K) ? at++ : (ae(b, {
                command: "removeLayer",
                args: [K]
              }), U.splice(U.indexOf(K, at), 1));
              for (let ze = 0, at = 0; ze < I.length; ze++) K = I[I.length - 1 - ze], U[U.length - 1 - ze] !== K && (Object.prototype.hasOwnProperty.call(L, K) ? (ae(b, {
                command: "removeLayer",
                args: [K]
              }), U.splice(U.lastIndexOf(K, U.length - at), 1)) : at++, Ze = U[U.length - ze], ae(b, {
                command: "addLayer",
                args: [B[K], Ze]
              }), U.splice(U.length - ze, 0, K), G[K] = !0);
              for (let ze = 0; ze < I.length; ze++)
                if (K = I[ze], ne = L[K], pe = B[K], !G[K] && !Ue(ne, pe))
                  if (Ue(ne.source, pe.source) && Ue(ne["source-layer"], pe["source-layer"]) && Ue(ne.type, pe.type)) {
                    for (ye in pt(ne.layout, pe.layout, b, K, null, "setLayoutProperty"), pt(ne.paint, pe.paint, b, K, null, "setPaintProperty"), Ue(ne.filter, pe.filter) || ae(b, {
                        command: "setFilter",
                        args: [K, pe.filter]
                      }), Ue(ne.minzoom, pe.minzoom) && Ue(ne.maxzoom, pe.maxzoom) || ae(b, {
                        command: "setLayerZoomRange",
                        args: [K, pe.minzoom, pe.maxzoom]
                      }), ne) Object.prototype.hasOwnProperty.call(ne, ye) && ye !== "layout" && ye !== "paint" && ye !== "filter" && ye !== "metadata" && ye !== "minzoom" && ye !== "maxzoom" && (ye.indexOf("paint.") === 0 ? pt(ne[ye], pe[ye], b, K, ye.slice(6), "setPaintProperty") : Ue(ne[ye], pe[ye]) || ae(b, {
                      command: "setLayerProperty",
                      args: [K, ye, pe[ye]]
                    }));
                    for (ye in pe) Object.prototype.hasOwnProperty.call(pe, ye) && !Object.prototype.hasOwnProperty.call(ne, ye) && ye !== "layout" && ye !== "paint" && ye !== "filter" && ye !== "metadata" && ye !== "minzoom" && ye !== "maxzoom" && (ye.indexOf("paint.") === 0 ? pt(ne[ye], pe[ye], b, K, ye.slice(6), "setPaintProperty") : Ue(ne[ye], pe[ye]) || ae(b, {
                      command: "setLayerProperty",
                      args: [K, ye, pe[ye]]
                    }))
                  } else ae(b, {
                    command: "removeLayer",
                    args: [K]
                  }), Ze = U[U.lastIndexOf(K) + 1], ae(b, {
                    command: "addLayer",
                    args: [pe, Ze]
                  })
            })(_, t.layers, n)
          } catch (o) {
            console.warn("Unable to compute style diff:", o), n = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return n
        }, k.bQ = function(i) {
          const t = [],
            n = i.id;
          return n === void 0 && t.push({
            message: `layers.${n}: missing required property "id"`
          }), i.render === void 0 && t.push({
            message: `layers.${n}: missing required method "render"`
          }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({
            message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, k.bR = Ut, k.bS = Qt, k.bT = class extends va {
          constructor(i, t) {
            super(i, t), this.current = 0
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i))
          }
        }, k.bU = Io, k.bV = class extends va {
          constructor(i, t) {
            super(i, t), this.current = ol
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let t = 1; t < 16; t++)
              if (i[t] !== this.current[t]) {
                this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
                break
              }
          }
        }, k.bW = mo, k.bX = class extends va {
          constructor(i, t) {
            super(i, t), this.current = [0, 0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]))
          }
        }, k.bY = class extends va {
          constructor(i, t) {
            super(i, t), this.current = [0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]))
          }
        }, k.bZ = Xe, k.b_ = function(i, t) {
          var n = Math.sin(t),
            o = Math.cos(t);
          return i[0] = o, i[1] = n, i[2] = 0, i[3] = -n, i[4] = o, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i
        }, k.ba = function(i, t, n) {
          var o = Math.sin(n),
            u = Math.cos(n),
            _ = t[4],
            m = t[5],
            y = t[6],
            b = t[7],
            P = t[8],
            I = t[9],
            L = t[10],
            B = t[11];
          return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = _ * u + P * o, i[5] = m * u + I * o, i[6] = y * u + L * o, i[7] = b * u + B * o, i[8] = P * u - _ * o, i[9] = I * u - m * o, i[10] = L * u - y * o, i[11] = B * u - b * o, i
        }, k.bb = function() {
          const i = new Float32Array(16);
          return tt(i), i
        }, k.bc = function() {
          const i = new Float64Array(16);
          return tt(i), i
        }, k.bd = function() {
          return new Float64Array(16)
        }, k.be = function(i, t, n) {
          const o = new Float64Array(4);
          return Vt(o, i, t - 90, n), o
        }, k.bf = function(i, t, n, o) {
          var u, _, m, y, b, P = t[0],
            I = t[1],
            L = t[2],
            B = t[3],
            U = n[0],
            G = n[1],
            K = n[2],
            ne = n[3];
          return (_ = P * U + I * G + L * K + B * ne) < 0 && (_ = -_, U = -U, G = -G, K = -K, ne = -ne), 1 - _ > Fe ? (u = Math.acos(_), m = Math.sin(u), y = Math.sin((1 - o) * u) / m, b = Math.sin(o * u) / m) : (y = 1 - o, b = o), i[0] = y * P + b * U, i[1] = y * I + b * G, i[2] = y * L + b * K, i[3] = y * B + b * ne, i
        }, k.bg = function(i) {
          const t = new Float64Array(9);
          var n, o, u, _, m, y, b, P, I, L, B, U, G, K, ne, pe, Ze, ye;
          L = (u = (o = i)[0]) * (b = u + u), B = (_ = o[1]) * b, G = (m = o[2]) * b, K = m * (P = _ + _), pe = (y = o[3]) * b, Ze = y * P, ye = y * (I = m + m), (n = t)[0] = 1 - (U = _ * P) - (ne = m * I), n[3] = B - ye, n[6] = G + Ze, n[1] = B + ye, n[4] = 1 - L - ne, n[7] = K - pe, n[2] = G - Ze, n[5] = K + pe, n[8] = 1 - L - U;
          const ze = Wr(-Math.asin(Yt(t[2], -1, 1)));
          let at, gt;
          return Math.hypot(t[5], t[8]) < .001 ? (at = 0, gt = -Wr(Math.atan2(t[3], t[4]))) : (at = Wr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), gt = Wr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: at,
            pitch: ze + 90,
            bearing: gt
          }
        }, k.bh = function(i, t) {
          return i.roll == t.roll && i.pitch == t.pitch && i.bearing == t.bearing
        }, k.bi = Ir, k.bj = da, k.bk = oc, k.bl = Du, k.bm = ac, k.bn = Rt, k.bo = jt, k.bp = li, k.bq = function(i, t, n, o, u) {
          return Rt(o, u, Yt((i - t) / (n - t), 0, 1))
        }, k.br = yt, k.bs = function() {
          return new Float64Array(3)
        }, k.bt = function(i, t, n, o) {
          return i[0] = t[0] + n[0] * o, i[1] = t[1] + n[1] * o, i[2] = t[2] + n[2] * o, i
        }, k.bu = Vt, k.bv = function(i, t, n) {
          var o = n[0],
            u = n[1],
            _ = n[2],
            m = n[3],
            y = t[0],
            b = t[1],
            P = t[2],
            I = u * P - _ * b,
            L = _ * y - o * P,
            B = o * b - u * y;
          return i[0] = y + m * (I += I) + u * (B += B) - _ * (L += L), i[1] = b + m * L + _ * I - o * B, i[2] = P + m * B + o * L - u * I, i
        }, k.bw = function(i, t, n) {
          const o = (u = [i[0], i[1], i[2], t[0], t[1], t[2], n[0], n[1], n[2]])[0] * ((I = u[8]) * (m = u[4]) - (y = u[5]) * (P = u[7])) + u[1] * (-I * (_ = u[3]) + y * (b = u[6])) + u[2] * (P * _ - m * b);
          var u, _, m, y, b, P, I;
          if (o === 0) return null;
          const L = Ne([], [t[0], t[1], t[2]], [n[0], n[1], n[2]]),
            B = Ne([], [n[0], n[1], n[2]], [i[0], i[1], i[2]]),
            U = Ne([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]),
            G = Le([], L, -i[3]);
          return Ke(G, G, Le([], B, -t[3])), Ke(G, G, Le([], U, -n[3])), Le(G, G, 1 / o), G
        }, k.bx = zf, k.by = function() {
          return new Float64Array(4)
        }, k.bz = function(i, t, n, o) {
          var u = [],
            _ = [];
          return u[0] = t[0] - n[0], u[1] = t[1] - n[1], u[2] = t[2] - n[2], _[0] = u[0] * Math.cos(o) - u[1] * Math.sin(o), _[1] = u[0] * Math.sin(o) + u[1] * Math.cos(o), _[2] = u[2], i[0] = _[0] + n[0], i[1] = _[1] + n[1], i[2] = _[2] + n[2], i
        }, k.c = de, k.c0 = function(i, t, n, o, u, _, m) {
          var y = 1 / (t - n),
            b = 1 / (o - u),
            P = 1 / (_ - m);
          return i[0] = -2 * y, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * b, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * P, i[11] = 0, i[12] = (t + n) * y, i[13] = (u + o) * b, i[14] = (m + _) * P, i[15] = 1, i
        }, k.c1 = class extends va {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(4 * i.length);
              for (let n = 0; n < i.length; n++) t[4 * n] = i[n].r, t[4 * n + 1] = i[n].g, t[4 * n + 2] = i[n].b, t[4 * n + 3] = i[n].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, k.c2 = class extends va {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(i);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, k.c3 = class extends Jo {}, k.c4 = wb, k.c5 = class extends Jl {}, k.c6 = hf, k.c7 = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
        }, k.c8 = Rm, k.c9 = function(i, t, n) {
          var o = t[0],
            u = t[1],
            _ = t[2],
            m = n[3] * o + n[7] * u + n[11] * _ + n[15];
          return i[0] = (n[0] * o + n[4] * u + n[8] * _ + n[12]) / (m = m || 1), i[1] = (n[1] * o + n[5] * u + n[9] * _ + n[13]) / m, i[2] = (n[2] * o + n[6] * u + n[10] * _ + n[14]) / m, i
        }, k.cB = function(i) {
          return i.message === sr
        }, k.cC = re, k.cD = function(i, t) {
          O.REGISTERED_PROTOCOLS[i] = t
        }, k.cE = function(i) {
          delete O.REGISTERED_PROTOCOLS[i]
        }, k.cF = function(i, t) {
          const n = {};
          for (let u = 0; u < i.length; u++) {
            const _ = t && t[i[u].id] || nd(i[u]);
            t && (t[i[u].id] = _);
            let m = n[_];
            m || (m = n[_] = []), m.push(i[u])
          }
          const o = [];
          for (const u in n) o.push(n[u]);
          return o
        }, k.cG = Mr, k.cH = Eg, k.cI = Dg, k.cJ = ug, k.cK = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = lt / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const t = i.bucket.layers[0],
            n = t.layout,
            o = t._unevaluatedLayout._values,
            u = {
              layoutIconSize: o["icon-size"].possiblyEvaluate(new ei(i.bucket.zoom + 1), i.canonical),
              layoutTextSize: o["text-size"].possiblyEvaluate(new ei(i.bucket.zoom + 1), i.canonical),
              textMaxSize: o["text-size"].possiblyEvaluate(new ei(18))
            };
          if (i.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: P,
              maxZoom: I
            } = i.bucket.textSizeData;
            u.compositeTextSizes = [o["text-size"].possiblyEvaluate(new ei(P), i.canonical), o["text-size"].possiblyEvaluate(new ei(I), i.canonical)]
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: P,
              maxZoom: I
            } = i.bucket.iconSizeData;
            u.compositeIconSizes = [o["icon-size"].possiblyEvaluate(new ei(P), i.canonical), o["icon-size"].possiblyEvaluate(new ei(I), i.canonical)]
          }
          const _ = n.get("text-line-height") * Gi,
            m = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point",
            y = n.get("text-keep-upright"),
            b = n.get("text-size");
          for (const P of i.bucket.features) {
            const I = n.get("text-font").evaluate(P, {}, i.canonical).join(","),
              L = b.evaluate(P, {}, i.canonical),
              B = u.layoutTextSize.evaluate(P, {}, i.canonical),
              U = u.layoutIconSize.evaluate(P, {}, i.canonical),
              G = {
                horizontal: {},
                vertical: void 0
              },
              K = P.text;
            let ne, pe = [0, 0];
            if (K) {
              const ze = K.toString(),
                at = n.get("text-letter-spacing").evaluate(P, {}, i.canonical) * Gi,
                gt = mu(ze) ? at : 0,
                Ht = n.get("text-anchor").evaluate(P, {}, i.canonical),
                xr = Gg(t, P, i.canonical);
              if (!xr) {
                const gr = n.get("text-radial-offset").evaluate(P, {}, i.canonical);
                pe = gr ? Zg(Ht, [gr * Gi, Ef]) : n.get("text-offset").evaluate(P, {}, i.canonical).map((yr => yr * Gi))
              }
              let dr = m ? "center" : n.get("text-justify").evaluate(P, {}, i.canonical);
              const vr = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(P, {}, i.canonical) * Gi : 1 / 0,
                en = () => {
                  i.bucket.allowVerticalPlacement && _u(ze) && (G.vertical = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, vr, _, Ht, "left", gt, pe, k.as.vertical, !0, B, L))
                };
              if (!m && xr) {
                const gr = new Set;
                if (dr === "auto")
                  for (let Lt = 0; Lt < xr.values.length; Lt += 2) gr.add(Lf(xr.values[Lt]));
                else gr.add(dr);
                let yr = !1;
                for (const Lt of gr)
                  if (!G.horizontal[Lt])
                    if (yr) G.horizontal[Lt] = G.horizontal[0];
                    else {
                      const hn = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, vr, _, "center", Lt, gt, pe, k.as.horizontal, !1, B, L);
                      hn && (G.horizontal[Lt] = hn, yr = hn.positionedLines.length === 1)
                    } en()
              } else {
                dr === "auto" && (dr = Lf(Ht));
                const gr = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, vr, _, Ht, dr, gt, pe, k.as.horizontal, !1, B, L);
                gr && (G.horizontal[dr] = gr), en(), _u(ze) && m && y && (G.vertical = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, I, vr, _, Ht, dr, gt, pe, k.as.vertical, !1, B, L))
              }
            }
            let Ze = !1;
            if (P.icon && P.icon.name) {
              const ze = i.imageMap[P.icon.name];
              ze && (ne = Zb(i.imagePositions[P.icon.name], n.get("icon-offset").evaluate(P, {}, i.canonical), n.get("icon-anchor").evaluate(P, {}, i.canonical)), Ze = !!ze.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Ze : i.bucket.sdfIcons !== Ze && zt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ze.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
            }
            const ye = Hg(G.horizontal) || G.vertical;
            i.bucket.iconsInText = !!ye && ye.iconsInText, (ye || ne) && ix(i.bucket, P, G, ne, i.imageMap, u, B, U, pe, Ze, i.canonical, i.subdivisionGranularity)
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
        }, k.cL = mf, k.cM = vf, k.cN = yf, k.cO = Ym, k.cP = xf, k.cQ = class {
          constructor(i) {
            this._marks = {
              start: [i.url, "start"].join("#"),
              end: [i.url, "end"].join("#"),
              measure: i.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i
          }
        }, k.cR = function(i, t, n, o, u) {
          return l(this, void 0, void 0, (function*() {
            if (we()) try {
              return yield wr(i, t, n, o, u)
            } catch {}
            return (function(_, m, y, b, P) {
              const I = _.width,
                L = _.height;
              ur && qr || (ur = new OffscreenCanvas(I, L), qr = ur.getContext("2d", {
                willReadFrequently: !0
              })), ur.width = I, ur.height = L, qr.drawImage(_, 0, 0, I, L);
              const B = qr.getImageData(m, y, b, P);
              return qr.clearRect(0, 0, I, L), B.data
            })(i, t, n, o, u)
          }))
        }, k.cS = Bm, k.cT = W, k.cU = Xm, k.cV = sc, k.cW = Wo, k.cX = function(i, t) {
          const n = new Map;
          if (i != null)
            if (i.type === "Feature") n.set(Nu(i, t), i);
            else
              for (const o of i.features) n.set(Nu(o, t), o);
          return n
        }, k.cY = function(i, t) {
          if (i == null) return !0;
          if (i.type === "Feature") return Nu(i, t) != null;
          if (i.type === "FeatureCollection") {
            const n = new Set;
            for (const o of i.features) {
              const u = Nu(o, t);
              if (u == null || n.has(u)) return !1;
              n.add(u)
            }
            return !0
          }
          return !1
        }, k.cZ = function(i, t, n) {
          var o, u, _, m;
          if (t.removeAll && i.clear(), t.remove)
            for (const y of t.remove) i.delete(y);
          if (t.add)
            for (const y of t.add) {
              const b = Nu(y, n);
              b != null && i.set(b, y)
            }
          if (t.update)
            for (const y of t.update) {
              let b = i.get(y.id);
              if (b == null) continue;
              const P = !y.removeAllProperties && (((o = y.removeProperties) === null || o === void 0 ? void 0 : o.length) > 0 || ((u = y.addOrUpdateProperties) === null || u === void 0 ? void 0 : u.length) > 0);
              if ((y.newGeometry || y.removeAllProperties || P) && (b = Object.assign({}, b), i.set(y.id, b), P && (b.properties = Object.assign({}, b.properties))), y.newGeometry && (b.geometry = y.newGeometry), y.removeAllProperties) b.properties = {};
              else if (((_ = y.removeProperties) === null || _ === void 0 ? void 0 : _.length) > 0)
                for (const I of y.removeProperties) Object.prototype.hasOwnProperty.call(b.properties, I) && delete b.properties[I];
              if (((m = y.addOrUpdateProperties) === null || m === void 0 ? void 0 : m.length) > 0)
                for (const {
                    key: I,
                    value: L
                  }
                  of y.addOrUpdateProperties) b.properties[I] = L
            }
        }, k.c_ = po, k.ca = class extends wu {}, k.cb = class extends h {}, k.cc = function(i, t) {
          return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15]
        }, k.cd = function(i, t) {
          var n = i[0],
            o = i[1],
            u = i[2],
            _ = i[3],
            m = i[4],
            y = i[5],
            b = i[6],
            P = i[7],
            I = i[8],
            L = i[9],
            B = i[10],
            U = i[11],
            G = i[12],
            K = i[13],
            ne = i[14],
            pe = i[15],
            Ze = t[0],
            ye = t[1],
            ze = t[2],
            at = t[3],
            gt = t[4],
            Ht = t[5],
            xr = t[6],
            dr = t[7],
            vr = t[8],
            en = t[9],
            gr = t[10],
            yr = t[11],
            Lt = t[12],
            hn = t[13],
            _n = t[14],
            on = t[15];
          return Math.abs(n - Ze) <= Fe * Math.max(1, Math.abs(n), Math.abs(Ze)) && Math.abs(o - ye) <= Fe * Math.max(1, Math.abs(o), Math.abs(ye)) && Math.abs(u - ze) <= Fe * Math.max(1, Math.abs(u), Math.abs(ze)) && Math.abs(_ - at) <= Fe * Math.max(1, Math.abs(_), Math.abs(at)) && Math.abs(m - gt) <= Fe * Math.max(1, Math.abs(m), Math.abs(gt)) && Math.abs(y - Ht) <= Fe * Math.max(1, Math.abs(y), Math.abs(Ht)) && Math.abs(b - xr) <= Fe * Math.max(1, Math.abs(b), Math.abs(xr)) && Math.abs(P - dr) <= Fe * Math.max(1, Math.abs(P), Math.abs(dr)) && Math.abs(I - vr) <= Fe * Math.max(1, Math.abs(I), Math.abs(vr)) && Math.abs(L - en) <= Fe * Math.max(1, Math.abs(L), Math.abs(en)) && Math.abs(B - gr) <= Fe * Math.max(1, Math.abs(B), Math.abs(gr)) && Math.abs(U - yr) <= Fe * Math.max(1, Math.abs(U), Math.abs(yr)) && Math.abs(G - Lt) <= Fe * Math.max(1, Math.abs(G), Math.abs(Lt)) && Math.abs(K - hn) <= Fe * Math.max(1, Math.abs(K), Math.abs(hn)) && Math.abs(ne - _n) <= Fe * Math.max(1, Math.abs(ne), Math.abs(_n)) && Math.abs(pe - on) <= Fe * Math.max(1, Math.abs(pe), Math.abs(on))
        }, k.ce = function(i, t) {
          return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, k.cf = i => i.type === "symbol", k.cg = i => i.type === "circle", k.ch = i => i.type === "heatmap", k.ci = i => i.type === "line", k.cj = i => i.type === "fill", k.ck = i => i.type === "fill-extrusion", k.cl = i => i.type === "hillshade", k.cm = i => i.type === "color-relief", k.cn = i => i.type === "background", k.co = i => i.type === "custom", k.cp = Xt, k.cq = function(i, t, n) {
          const o = Pt(t.x - n.x, t.y - n.y),
            u = Pt(i.x - n.x, i.y - n.y);
          var _, m;
          return Wr(Math.atan2(o[0] * u[1] - o[1] * u[0], (_ = o)[0] * (m = u)[0] + _[1] * m[1]))
        }, k.cr = fr, k.cs = function(i, t) {
          return Hr[t] && (i instanceof MouseEvent || i instanceof WheelEvent)
        }, k.ct = function(i, t) {
          return tr[t] && "touches" in i
        }, k.cu = function(i) {
          return tr[i] || Hr[i]
        }, k.cv = function(i, t, n) {
          var o = t[0],
            u = t[1];
          return i[0] = n[0] * o + n[4] * u + n[12], i[1] = n[1] * o + n[5] * u + n[13], i
        }, k.cw = function(i, t) {
          const {
            x: n,
            y: o
          } = qu.fromLngLat(t);
          return !(i < 0 || i > 25 || o < 0 || o >= 1 || n < 0 || n >= 1)
        }, k.cx = function(i, t) {
          return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }, k.cy = class extends $l {}, k.cz = ox, k.d = ke, k.e = ot, k.f = i => l(void 0, void 0, void 0, (function*() {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), k.g = N, k.h = i => new Promise(((t, n) => {
          const o = new Image;
          o.onload = () => {
            t(o), URL.revokeObjectURL(o.src), o.onload = null, window.requestAnimationFrame((() => {
              o.src = hr
            }))
          }, o.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const u = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          o.src = i.byteLength ? URL.createObjectURL(u) : hr
        })), k.i = kt, k.j = (i, t) => ue(ot(i, {
          type: "json"
        }), t), k.k = Be, k.l = He, k.m = ue, k.n = (i, t) => ue(ot(i, {
          type: "arrayBuffer"
        }), t), k.o = function(i) {
          return new xf(i).readFields(Lb, [])
        }, k.p = cg, k.q = Cu, k.r = oa, k.s = kr, k.t = J, k.u = jn, k.v = dd, k.w = zt, k.x = kd, k.y = Qp, k.z = fd
      })), z("worker", ["./shared"], (function(k) {
        class l {
          constructor(O, N) {
            this.keyCache = {}, O && this.replace(O, N)
          }
          replace(O, N) {
            this._layerConfigs = {}, this._layers = {}, this.update(O, [], N)
          }
          update(O, N, X) {
            for (const Q of O) {
              this._layerConfigs[Q.id] = Q;
              const ue = this._layers[Q.id] = k.bM(Q, X);
              ue._featureFilter = k.ae(ue.filter, X), this.keyCache[Q.id] && delete this.keyCache[Q.id]
            }
            for (const Q of N) delete this.keyCache[Q], delete this._layerConfigs[Q], delete this._layers[Q];
            this.familiesBySource = {};
            const re = k.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const Q of re) {
              const ue = Q.map((ie => this._layers[ie.id])),
                ke = ue[0];
              if (ke.visibility === "none") continue;
              const xe = ke.source || "";
              let Ee = this.familiesBySource[xe];
              Ee || (Ee = this.familiesBySource[xe] = {});
              const He = ke.sourceLayer || "_geojsonTileLayer";
              let Be = Ee[He];
              Be || (Be = Ee[He] = []), Be.push(ue)
            }
          }
        }
        class F {
          constructor(O) {
            const N = {},
              X = [];
            for (const ke in O) {
              const xe = O[ke],
                Ee = N[ke] = {};
              for (const He in xe) {
                const Be = xe[+He];
                if (!Be || Be.bitmap.width === 0 || Be.bitmap.height === 0) continue;
                const ie = {
                  x: 0,
                  y: 0,
                  w: Be.bitmap.width + 2,
                  h: Be.bitmap.height + 2
                };
                X.push(ie), Ee[He] = {
                  rect: ie,
                  metrics: Be.metrics
                }
              }
            }
            const {
              w: re,
              h: Q
            } = k.p(X), ue = new k.q({
              width: re || 1,
              height: Q || 1
            });
            for (const ke in O) {
              const xe = O[ke];
              for (const Ee in xe) {
                const He = xe[+Ee];
                if (!He || He.bitmap.width === 0 || He.bitmap.height === 0) continue;
                const Be = N[ke][Ee].rect;
                k.q.copy(He.bitmap, ue, {
                  x: 0,
                  y: 0
                }, {
                  x: Be.x + 1,
                  y: Be.y + 1
                }, He.bitmap)
              }
            }
            this.image = ue, this.positions = N
          }
        }
        k.cG("GlyphAtlas", F);
        class W {
          constructor(O) {
            this.tileID = new k.a0(O.tileID.overscaledZ, O.tileID.wrap, O.tileID.canonical.z, O.tileID.canonical.x, O.tileID.canonical.y), this.uid = O.uid, this.zoom = O.zoom, this.pixelRatio = O.pixelRatio, this.tileSize = O.tileSize, this.source = O.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = O.showCollisionBoxes, this.collectResourceTiming = !!O.collectResourceTiming, this.returnDependencies = !!O.returnDependencies, this.promoteId = O.promoteId, this.inFlightDependencies = []
          }
          parse(O, N, X, re, Q) {
            return k._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = O, this.collisionBoxArray = new k.ac;
              const ue = new k.cH(Object.keys(O.layers).sort()),
                ke = new k.cI(this.tileID, this.promoteId);
              ke.bucketLayerIDs = [];
              const xe = {},
                Ee = {
                  featureIndex: ke,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: X,
                  subdivisionGranularity: Q
                },
                He = N.familiesBySource[this.source];
              for (const qe in He) {
                const bt = O.layers[qe];
                if (!bt) continue;
                bt.version === 1 && k.w(`Vector tile source "${this.source}" layer "${qe}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Jt = ue.encode(qe),
                  Cr = [];
                for (let _r = 0; _r < bt.length; _r++) {
                  const Qe = bt.feature(_r),
                    rr = ke.getId(Qe, qe);
                  Cr.push({
                    feature: Qe,
                    id: rr,
                    index: _r,
                    sourceLayerIndex: Jt
                  })
                }
                for (const _r of He[qe]) {
                  const Qe = _r[0];
                  Qe.source !== this.source && k.w(`layer.source = ${Qe.source} does not equal this.source = ${this.source}`), Qe.isHidden(this.zoom, !0) || (ee(_r, this.zoom, X), (xe[Qe.id] = Qe.createBucket({
                    index: ke.bucketLayerIDs.length,
                    layers: _r,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: Jt,
                    sourceID: this.source
                  })).populate(Cr, Ee, this.tileID.canonical), ke.bucketLayerIDs.push(_r.map((rr => rr.id))))
                }
              }
              const Be = k.bR(Ee.glyphDependencies, (qe => Object.keys(qe).map(Number)));
              this.inFlightDependencies.forEach((qe => qe == null ? void 0 : qe.abort())), this.inFlightDependencies = [];
              let ie = Promise.resolve({});
              if (Object.keys(Be).length) {
                const qe = new AbortController;
                this.inFlightDependencies.push(qe), ie = re.sendAsync({
                  type: "GG",
                  data: {
                    stacks: Be,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, qe)
              }
              const J = Object.keys(Ee.iconDependencies);
              let Ve = Promise.resolve({});
              if (J.length) {
                const qe = new AbortController;
                this.inFlightDependencies.push(qe), Ve = re.sendAsync({
                  type: "GI",
                  data: {
                    icons: J,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, qe)
              }
              const rt = Object.keys(Ee.patternDependencies);
              let Ue = Promise.resolve({});
              if (rt.length) {
                const qe = new AbortController;
                this.inFlightDependencies.push(qe), Ue = re.sendAsync({
                  type: "GI",
                  data: {
                    icons: rt,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, qe)
              }
              const ae = Ee.dashDependencies;
              let Ie = Promise.resolve({});
              if (Object.keys(ae).length) {
                const qe = new AbortController;
                this.inFlightDependencies.push(qe), Ie = re.sendAsync({
                  type: "GDA",
                  data: {
                    dashes: ae
                  }
                }, qe)
              }
              const [$e, dt, Tt, pt] = yield Promise.all([ie, Ve, Ue, Ie]), St = new F($e), qt = new k.cJ(dt, Tt);
              for (const qe in xe) {
                const bt = xe[qe];
                bt instanceof k.ad ? (ee(bt.layers, this.zoom, X), k.cK({
                  bucket: bt,
                  glyphMap: $e,
                  glyphPositions: St.positions,
                  imageMap: dt,
                  imagePositions: qt.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Ee.subdivisionGranularity
                })) : bt.hasDependencies && (bt instanceof k.cL || bt instanceof k.cM || bt instanceof k.cN) && (ee(bt.layers, this.zoom, X), bt.addFeatures(Ee, this.tileID.canonical, qt.patternPositions, pt))
              }
              return this.status = "done", {
                buckets: Object.values(xe).filter((qe => !qe.isEmpty())),
                featureIndex: ke,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: St.image,
                imageAtlas: qt,
                dashPositions: pt,
                glyphMap: this.returnDependencies ? $e : null,
                iconMap: this.returnDependencies ? dt : null,
                glyphPositions: this.returnDependencies ? St.positions : null
              }
            }))
          }
        }

        function ee(de, O, N) {
          const X = new k.G(O);
          for (const re of de) re.recalculate(X, N)
        }
        class $ {
          constructor(O, N, X) {
            this.actor = O, this.layerIndex = N, this.availableImages = X, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(O, N) {
            return k._(this, void 0, void 0, (function*() {
              const X = yield k.n(O.request, N);
              try {
                return {
                  vectorTile: new k.cO(new k.cP(X.data)),
                  rawData: X.data,
                  cacheControl: X.cacheControl,
                  expires: X.expires
                }
              } catch (re) {
                const Q = new Uint8Array(X.data);
                let ue = `Unable to parse the tile at ${O.request.url}, `;
                throw ue += Q[0] === 31 && Q[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${re.message}`, new Error(ue)
              }
            }))
          }
          loadTile(O) {
            return k._(this, void 0, void 0, (function*() {
              const N = O.uid,
                X = !!(O && O.request && O.request.collectResourceTiming) && new k.cQ(O.request),
                re = new W(O);
              this.loading[N] = re;
              const Q = new AbortController;
              re.abort = Q;
              try {
                const ue = yield this.loadVectorTile(O, Q);
                if (delete this.loading[N], !ue) return null;
                const ke = ue.rawData,
                  xe = {};
                ue.expires && (xe.expires = ue.expires), ue.cacheControl && (xe.cacheControl = ue.cacheControl);
                const Ee = {};
                if (X) {
                  const Be = X.finish();
                  Be && (Ee.resourceTiming = JSON.parse(JSON.stringify(Be)))
                }
                re.vectorTile = ue.vectorTile;
                const He = re.parse(ue.vectorTile, this.layerIndex, this.availableImages, this.actor, O.subdivisionGranularity);
                this.loaded[N] = re, this.fetching[N] = {
                  rawTileData: ke,
                  cacheControl: xe,
                  resourceTiming: Ee
                };
                try {
                  const Be = yield He;
                  return k.e({
                    rawTileData: ke.slice(0)
                  }, Be, xe, Ee)
                } finally {
                  delete this.fetching[N]
                }
              } catch (ue) {
                throw delete this.loading[N], re.status = "done", this.loaded[N] = re, ue
              }
            }))
          }
          reloadTile(O) {
            return k._(this, void 0, void 0, (function*() {
              const N = O.uid;
              if (!this.loaded || !this.loaded[N]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const X = this.loaded[N];
              if (X.showCollisionBoxes = O.showCollisionBoxes, X.status === "parsing") {
                const re = yield X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, O.subdivisionGranularity);
                let Q;
                if (this.fetching[N]) {
                  const {
                    rawTileData: ue,
                    cacheControl: ke,
                    resourceTiming: xe
                  } = this.fetching[N];
                  delete this.fetching[N], Q = k.e({
                    rawTileData: ue.slice(0)
                  }, re, ke, xe)
                } else Q = re;
                return Q
              }
              if (X.status === "done" && X.vectorTile) return X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, O.subdivisionGranularity)
            }))
          }
          abortTile(O) {
            return k._(this, void 0, void 0, (function*() {
              const N = this.loading,
                X = O.uid;
              N && N[X] && N[X].abort && (N[X].abort.abort(), delete N[X])
            }))
          }
          removeTile(O) {
            return k._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[O.uid] && delete this.loaded[O.uid]
            }))
          }
        }
        class se {
          constructor() {
            this.loaded = {}
          }
          loadTile(O) {
            return k._(this, void 0, void 0, (function*() {
              const {
                uid: N,
                encoding: X,
                rawImageData: re,
                redFactor: Q,
                greenFactor: ue,
                blueFactor: ke,
                baseShift: xe
              } = O, Ee = re.width + 2, He = re.height + 2, Be = k.b(re) ? new k.R({
                width: Ee,
                height: He
              }, yield k.cR(re, -1, -1, Ee, He)) : re, ie = new k.cS(N, Be, X, Q, ue, ke, xe);
              return this.loaded = this.loaded || {}, this.loaded[N] = ie, ie
            }))
          }
          removeTile(O) {
            const N = this.loaded,
              X = O.uid;
            N && N[X] && delete N[X]
          }
        }
        var _e, ge, V = (function() {
            if (ge) return _e;

            function de(N, X) {
              if (N.length !== 0) {
                O(N[0], X);
                for (var re = 1; re < N.length; re++) O(N[re], !X)
              }
            }

            function O(N, X) {
              for (var re = 0, Q = 0, ue = 0, ke = N.length, xe = ke - 1; ue < ke; xe = ue++) {
                var Ee = (N[ue][0] - N[xe][0]) * (N[xe][1] + N[ue][1]),
                  He = re + Ee;
                Q += Math.abs(re) >= Math.abs(Ee) ? re - He + Ee : Ee - He + re, re = He
              }
              re + Q >= 0 != !!X && N.reverse()
            }
            return ge = 1, _e = function N(X, re) {
              var Q, ue = X && X.type;
              if (ue === "FeatureCollection")
                for (Q = 0; Q < X.features.length; Q++) N(X.features[Q], re);
              else if (ue === "GeometryCollection")
                for (Q = 0; Q < X.geometries.length; Q++) N(X.geometries[Q], re);
              else if (ue === "Feature") N(X.geometry, re);
              else if (ue === "Polygon") de(X.coordinates, re);
              else if (ue === "MultiPolygon")
                for (Q = 0; Q < X.coordinates.length; Q++) de(X.coordinates[Q], re);
              return X
            }
          })(),
          Me = k.cT(V);
        class we extends k.cV {
          constructor(O, N) {
            super(new k.cP, 0, N, [], []), this.feature = O, this.type = O.type, this.properties = O.tags ? O.tags : {}, "id" in O && (typeof O.id == "string" ? this.id = parseInt(O.id, 10) : typeof O.id != "number" || isNaN(O.id) || (this.id = O.id))
          }
          loadGeometry() {
            const O = [],
              N = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const X of N) {
              const re = [];
              for (const Q of X) re.push(new k.P(Q[0], Q[1]));
              O.push(re)
            }
            return O
          }
        }
        class Fe extends k.cU {
          constructor(O, N) {
            super(new k.cP), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = N ? N.version : 1, this.extent = N ? N.extent : 4096, this.length = O.length, this.features = O
          }
          feature(O) {
            return new we(this.features[O], this.extent)
          }
        }

        function be(de, O) {
          O.writeVarintField(15, de.version || 1), O.writeStringField(1, de.name || ""), O.writeVarintField(5, de.extent || 4096);
          const N = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let Q = 0; Q < de.length; Q++) N.feature = de.feature(Q), O.writeMessage(2, Xe, N);
          const X = N.keys;
          for (const Q of X) O.writeStringField(3, Q);
          const re = N.values;
          for (const Q of re) O.writeMessage(4, Ke, Q)
        }

        function Xe(de, O) {
          if (!de.feature) return;
          const N = de.feature;
          N.id !== void 0 && O.writeVarintField(1, N.id), O.writeMessage(2, tt, de), O.writeVarintField(3, N.type), O.writeMessage(4, De, N)
        }

        function tt(de, O) {
          var N;
          for (const X in (N = de.feature) == null ? void 0 : N.properties) {
            let re = de.feature.properties[X],
              Q = de.keycache[X];
            if (re === null) continue;
            Q === void 0 && (de.keys.push(X), Q = de.keys.length - 1, de.keycache[X] = Q), O.writeVarint(Q), typeof re != "string" && typeof re != "boolean" && typeof re != "number" && (re = JSON.stringify(re));
            const ue = typeof re + ":" + re;
            let ke = de.valuecache[ue];
            ke === void 0 && (de.values.push(re), ke = de.values.length - 1, de.valuecache[ue] = ke), O.writeVarint(ke)
          }
        }

        function Ye(de, O) {
          return (O << 3) + (7 & de)
        }

        function Ce(de) {
          return de << 1 ^ de >> 31
        }

        function De(de, O) {
          const N = de.loadGeometry(),
            X = de.type;
          let re = 0,
            Q = 0;
          for (const ue of N) {
            let ke = 1;
            X === 1 && (ke = ue.length), O.writeVarint(Ye(1, ke));
            const xe = X === 3 ? ue.length - 1 : ue.length;
            for (let Ee = 0; Ee < xe; Ee++) {
              Ee === 1 && X !== 1 && O.writeVarint(Ye(2, xe - 1));
              const He = ue[Ee].x - re,
                Be = ue[Ee].y - Q;
              O.writeVarint(Ce(He)), O.writeVarint(Ce(Be)), re += He, Q += Be
            }
            de.type === 3 && O.writeVarint(Ye(7, 1))
          }
        }

        function Ke(de, O) {
          const N = typeof de;
          N === "string" ? O.writeStringField(1, de) : N === "boolean" ? O.writeBooleanField(7, de) : N === "number" && (de % 1 != 0 ? O.writeDoubleField(3, de) : de < 0 ? O.writeSVarintField(6, de) : O.writeVarintField(5, de))
        }
        const Le = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: de => de
          },
          Ne = Math.fround || (vt = new Float32Array(1), de => (vt[0] = +de, vt[0]));
        var vt;
        class et {
          constructor(O) {
            this.options = Object.assign(Object.create(Le), O), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(O) {
            const {
              log: N,
              minZoom: X,
              maxZoom: re
            } = this.options;
            N && console.time("total time");
            const Q = `prepare ${O.length} points`;
            N && console.time(Q), this.points = O;
            const ue = [];
            for (let xe = 0; xe < O.length; xe++) {
              const Ee = O[xe];
              if (!Ee.geometry) continue;
              const [He, Be] = Ee.geometry.coordinates, ie = Ne(Vt(He)), J = Ne(Et(Be));
              ue.push(ie, J, 1 / 0, xe, -1, 1), this.options.reduce && ue.push(0)
            }
            let ke = this.trees[re + 1] = this._createTree(ue);
            N && console.timeEnd(Q);
            for (let xe = re; xe >= X; xe--) {
              const Ee = +Date.now();
              ke = this.trees[xe] = this._createTree(this._cluster(ke, xe)), N && console.log("z%d: %d clusters in %dms", xe, ke.numItems, +Date.now() - Ee)
            }
            return N && console.timeEnd("total time"), this
          }
          getClusters(O, N) {
            let X = ((O[0] + 180) % 360 + 360) % 360 - 180;
            const re = Math.max(-90, Math.min(90, O[1]));
            let Q = O[2] === 180 ? 180 : ((O[2] + 180) % 360 + 360) % 360 - 180;
            const ue = Math.max(-90, Math.min(90, O[3]));
            if (O[2] - O[0] >= 360) X = -180, Q = 180;
            else if (X > Q) {
              const Be = this.getClusters([X, re, 180, ue], N),
                ie = this.getClusters([-180, re, Q, ue], N);
              return Be.concat(ie)
            }
            const ke = this.trees[this._limitZoom(N)],
              xe = ke.range(Vt(X), Et(ue), Vt(Q), Et(re)),
              Ee = ke.data,
              He = [];
            for (const Be of xe) {
              const ie = this.stride * Be;
              He.push(Ee[ie + 5] > 1 ? We(Ee, ie, this.clusterProps) : this.points[Ee[ie + 3]])
            }
            return He
          }
          getChildren(O) {
            const N = this._getOriginId(O),
              X = this._getOriginZoom(O),
              re = "No cluster with the specified id.",
              Q = this.trees[X];
            if (!Q) throw new Error(re);
            const ue = Q.data;
            if (N * this.stride >= ue.length) throw new Error(re);
            const ke = this.options.radius / (this.options.extent * Math.pow(2, X - 1)),
              xe = Q.within(ue[N * this.stride], ue[N * this.stride + 1], ke),
              Ee = [];
            for (const He of xe) {
              const Be = He * this.stride;
              ue[Be + 4] === O && Ee.push(ue[Be + 5] > 1 ? We(ue, Be, this.clusterProps) : this.points[ue[Be + 3]])
            }
            if (Ee.length === 0) throw new Error(re);
            return Ee
          }
          getLeaves(O, N, X) {
            const re = [];
            return this._appendLeaves(re, O, N = N || 10, X = X || 0, 0), re
          }
          getTile(O, N, X) {
            const re = this.trees[this._limitZoom(O)],
              Q = Math.pow(2, O),
              {
                extent: ue,
                radius: ke
              } = this.options,
              xe = ke / ue,
              Ee = (X - xe) / Q,
              He = (X + 1 + xe) / Q,
              Be = {
                features: []
              };
            return this._addTileFeatures(re.range((N - xe) / Q, Ee, (N + 1 + xe) / Q, He), re.data, N, X, Q, Be), N === 0 && this._addTileFeatures(re.range(1 - xe / Q, Ee, 1, He), re.data, Q, X, Q, Be), N === Q - 1 && this._addTileFeatures(re.range(0, Ee, xe / Q, He), re.data, -1, X, Q, Be), Be.features.length ? Be : null
          }
          getClusterExpansionZoom(O) {
            let N = this._getOriginZoom(O) - 1;
            for (; N <= this.options.maxZoom;) {
              const X = this.getChildren(O);
              if (N++, X.length !== 1) break;
              O = X[0].properties.cluster_id
            }
            return N
          }
          _appendLeaves(O, N, X, re, Q) {
            const ue = this.getChildren(N);
            for (const ke of ue) {
              const xe = ke.properties;
              if (xe && xe.cluster ? Q + xe.point_count <= re ? Q += xe.point_count : Q = this._appendLeaves(O, xe.cluster_id, X, re, Q) : Q < re ? Q++ : O.push(ke), O.length === X) break
            }
            return Q
          }
          _createTree(O) {
            const N = new k.aM(O.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let X = 0; X < O.length; X += this.stride) N.add(O[X], O[X + 1]);
            return N.finish(), N.data = O, N
          }
          _addTileFeatures(O, N, X, re, Q, ue) {
            for (const ke of O) {
              const xe = ke * this.stride,
                Ee = N[xe + 5] > 1;
              let He, Be, ie;
              if (Ee) He = _t(N, xe, this.clusterProps), Be = N[xe], ie = N[xe + 1];
              else {
                const rt = this.points[N[xe + 3]];
                He = rt.properties;
                const [Ue, ae] = rt.geometry.coordinates;
                Be = Vt(Ue), ie = Et(ae)
              }
              const J = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (Be * Q - X)), Math.round(this.options.extent * (ie * Q - re))]
                ],
                tags: He
              };
              let Ve;
              Ve = Ee || this.options.generateId ? N[xe + 3] : this.points[N[xe + 3]].id, Ve !== void 0 && (J.id = Ve), ue.features.push(J)
            }
          }
          _limitZoom(O) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+O), this.options.maxZoom + 1))
          }
          _cluster(O, N) {
            const {
              radius: X,
              extent: re,
              reduce: Q,
              minPoints: ue
            } = this.options, ke = X / (re * Math.pow(2, N)), xe = O.data, Ee = [], He = this.stride;
            for (let Be = 0; Be < xe.length; Be += He) {
              if (xe[Be + 2] <= N) continue;
              xe[Be + 2] = N;
              const ie = xe[Be],
                J = xe[Be + 1],
                Ve = O.within(xe[Be], xe[Be + 1], ke),
                rt = xe[Be + 5];
              let Ue = rt;
              for (const ae of Ve) {
                const Ie = ae * He;
                xe[Ie + 2] > N && (Ue += xe[Ie + 5])
              }
              if (Ue > rt && Ue >= ue) {
                let ae, Ie = ie * rt,
                  $e = J * rt,
                  dt = -1;
                const Tt = (Be / He << 5) + (N + 1) + this.points.length;
                for (const pt of Ve) {
                  const St = pt * He;
                  if (xe[St + 2] <= N) continue;
                  xe[St + 2] = N;
                  const qt = xe[St + 5];
                  Ie += xe[St] * qt, $e += xe[St + 1] * qt, xe[St + 4] = Tt, Q && (ae || (ae = this._map(xe, Be, !0), dt = this.clusterProps.length, this.clusterProps.push(ae)), Q(ae, this._map(xe, St)))
                }
                xe[Be + 4] = Tt, Ee.push(Ie / Ue, $e / Ue, 1 / 0, Tt, -1, Ue), Q && Ee.push(dt)
              } else {
                for (let ae = 0; ae < He; ae++) Ee.push(xe[Be + ae]);
                if (Ue > 1)
                  for (const ae of Ve) {
                    const Ie = ae * He;
                    if (!(xe[Ie + 2] <= N)) {
                      xe[Ie + 2] = N;
                      for (let $e = 0; $e < He; $e++) Ee.push(xe[Ie + $e])
                    }
                  }
              }
            }
            return Ee
          }
          _getOriginId(O) {
            return O - this.points.length >> 5
          }
          _getOriginZoom(O) {
            return (O - this.points.length) % 32
          }
          _map(O, N, X) {
            if (O[N + 5] > 1) {
              const ue = this.clusterProps[O[N + 6]];
              return X ? Object.assign({}, ue) : ue
            }
            const re = this.points[O[N + 3]].properties,
              Q = this.options.map(re);
            return X && Q === re ? Object.assign({}, Q) : Q
          }
        }

        function We(de, O, N) {
          return {
            type: "Feature",
            id: de[O + 3],
            properties: _t(de, O, N),
            geometry: {
              type: "Point",
              coordinates: [(X = de[O], 360 * (X - .5)), Pt(de[O + 1])]
            }
          };
          var X
        }

        function _t(de, O, N) {
          const X = de[O + 5],
            re = X >= 1e4 ? `${Math.round(X/1e3)}k` : X >= 1e3 ? Math.round(X / 100) / 10 + "k" : X,
            Q = de[O + 6],
            ue = Q === -1 ? {} : Object.assign({}, N[Q]);
          return Object.assign(ue, {
            cluster: !0,
            cluster_id: de[O + 3],
            point_count: X,
            point_count_abbreviated: re
          })
        }

        function Vt(de) {
          return de / 360 + .5
        }

        function Et(de) {
          const O = Math.sin(de * Math.PI / 180),
            N = .5 - .25 * Math.log((1 + O) / (1 - O)) / Math.PI;
          return N < 0 ? 0 : N > 1 ? 1 : N
        }

        function Pt(de) {
          const O = (180 - 360 * de) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(O)) / Math.PI - 90
        }

        function lt(de, O, N, X) {
          let re = X;
          const Q = O + (N - O >> 1);
          let ue, ke = N - O;
          const xe = de[O],
            Ee = de[O + 1],
            He = de[N],
            Be = de[N + 1];
          for (let ie = O + 3; ie < N; ie += 3) {
            const J = $t(de[ie], de[ie + 1], xe, Ee, He, Be);
            if (J > re) ue = ie, re = J;
            else if (J === re) {
              const Ve = Math.abs(ie - Q);
              Ve < ke && (ue = ie, ke = Ve)
            }
          }
          re > X && (ue - O > 3 && lt(de, O, ue, X), de[ue + 2] = re, N - ue > 3 && lt(de, ue, N, X))
        }

        function $t(de, O, N, X, re, Q) {
          let ue = re - N,
            ke = Q - X;
          if (ue !== 0 || ke !== 0) {
            const xe = ((de - N) * ue + (O - X) * ke) / (ue * ue + ke * ke);
            xe > 1 ? (N = re, X = Q) : xe > 0 && (N += ue * xe, X += ke * xe)
          }
          return ue = de - N, ke = O - X, ue * ue + ke * ke
        }

        function yt(de, O, N, X) {
          const re = {
            id: de ?? null,
            type: O,
            geometry: N,
            tags: X,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (O === "Point" || O === "MultiPoint" || O === "LineString") Rt(re, N);
          else if (O === "Polygon") Rt(re, N[0]);
          else if (O === "MultiLineString")
            for (const Q of N) Rt(re, Q);
          else if (O === "MultiPolygon")
            for (const Q of N) Rt(re, Q[0]);
          return re
        }

        function Rt(de, O) {
          for (let N = 0; N < O.length; N += 3) de.minX = Math.min(de.minX, O[N]), de.minY = Math.min(de.minY, O[N + 1]), de.maxX = Math.max(de.maxX, O[N]), de.maxY = Math.max(de.maxY, O[N + 1])
        }

        function jt(de, O, N, X) {
          if (!O.geometry) return;
          const re = O.geometry.coordinates;
          if (re && re.length === 0) return;
          const Q = O.geometry.type,
            ue = Math.pow(N.tolerance / ((1 << N.maxZoom) * N.extent), 2);
          let ke = [],
            xe = O.id;
          if (N.promoteId ? xe = O.properties[N.promoteId] : N.generateId && (xe = X || 0), Q === "Point") Xt(re, ke);
          else if (Q === "MultiPoint")
            for (const Ee of re) Xt(Ee, ke);
          else if (Q === "LineString") fr(re, ke, ue, !1);
          else if (Q === "MultiLineString") {
            if (N.lineMetrics) {
              for (const Ee of re) ke = [], fr(Ee, ke, ue, !1), de.push(yt(xe, "LineString", ke, O.properties));
              return
            }
            Yt(re, ke, ue, !1)
          } else if (Q === "Polygon") Yt(re, ke, ue, !0);
          else {
            if (Q !== "MultiPolygon") {
              if (Q === "GeometryCollection") {
                for (const Ee of O.geometry.geometries) jt(de, {
                  id: xe,
                  geometry: Ee,
                  properties: O.properties
                }, N, X);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Ee of re) {
              const He = [];
              Yt(Ee, He, ue, !0), ke.push(He)
            }
          }
          de.push(yt(xe, Q, ke, O.properties))
        }

        function Xt(de, O) {
          O.push(lr(de[0]), ot(de[1]), 0)
        }

        function fr(de, O, N, X) {
          let re, Q, ue = 0;
          for (let xe = 0; xe < de.length; xe++) {
            const Ee = lr(de[xe][0]),
              He = ot(de[xe][1]);
            O.push(Ee, He, 0), xe > 0 && (ue += X ? (re * He - Ee * Q) / 2 : Math.sqrt(Math.pow(Ee - re, 2) + Math.pow(He - Q, 2))), re = Ee, Q = He
          }
          const ke = O.length - 3;
          O[2] = 1, lt(O, 0, ke, N), O[ke + 2] = 1, O.size = Math.abs(ue), O.start = 0, O.end = O.size
        }

        function Yt(de, O, N, X) {
          for (let re = 0; re < de.length; re++) {
            const Q = [];
            fr(de[re], Q, N, X), O.push(Q)
          }
        }

        function lr(de) {
          return de / 360 + .5
        }

        function ot(de) {
          const O = Math.sin(de * Math.PI / 180),
            N = .5 - .25 * Math.log((1 + O) / (1 - O)) / Math.PI;
          return N < 0 ? 0 : N > 1 ? 1 : N
        }

        function nt(de, O, N, X, re, Q, ue, ke) {
          if (X /= O, Q >= (N /= O) && ue < X) return de;
          if (ue < N || Q >= X) return null;
          const xe = [];
          for (const Ee of de) {
            const He = Ee.geometry;
            let Be = Ee.type;
            const ie = re === 0 ? Ee.minX : Ee.minY,
              J = re === 0 ? Ee.maxX : Ee.maxY;
            if (ie >= N && J < X) {
              xe.push(Ee);
              continue
            }
            if (J < N || ie >= X) continue;
            let Ve = [];
            if (Be === "Point" || Be === "MultiPoint") Ut(He, Ve, N, X, re);
            else if (Be === "LineString") Qt(He, Ve, N, X, re, !1, ke.lineMetrics);
            else if (Be === "MultiLineString") mr(He, Ve, N, X, re, !1);
            else if (Be === "Polygon") mr(He, Ve, N, X, re, !0);
            else if (Be === "MultiPolygon")
              for (const rt of He) {
                const Ue = [];
                mr(rt, Ue, N, X, re, !0), Ue.length && Ve.push(Ue)
              }
            if (Ve.length) {
              if (ke.lineMetrics && Be === "LineString") {
                for (const rt of Ve) xe.push(yt(Ee.id, Be, rt, Ee.tags));
                continue
              }
              Be !== "LineString" && Be !== "MultiLineString" || (Ve.length === 1 ? (Be = "LineString", Ve = Ve[0]) : Be = "MultiLineString"), Be !== "Point" && Be !== "MultiPoint" || (Be = Ve.length === 3 ? "Point" : "MultiPoint"), xe.push(yt(Ee.id, Be, Ve, Ee.tags))
            }
          }
          return xe.length ? xe : null
        }

        function Ut(de, O, N, X, re) {
          for (let Q = 0; Q < de.length; Q += 3) {
            const ue = de[Q + re];
            ue >= N && ue <= X && zt(O, de[Q], de[Q + 1], de[Q + 2])
          }
        }

        function Qt(de, O, N, X, re, Q, ue) {
          let ke = Ot(de);
          const xe = re === 0 ? Mt : kt;
          let Ee, He, Be = de.start;
          for (let Ue = 0; Ue < de.length - 3; Ue += 3) {
            const ae = de[Ue],
              Ie = de[Ue + 1],
              $e = de[Ue + 2],
              dt = de[Ue + 3],
              Tt = de[Ue + 4],
              pt = re === 0 ? ae : Ie,
              St = re === 0 ? dt : Tt;
            let qt = !1;
            ue && (Ee = Math.sqrt(Math.pow(ae - dt, 2) + Math.pow(Ie - Tt, 2))), pt < N ? St > N && (He = xe(ke, ae, Ie, dt, Tt, N), ue && (ke.start = Be + Ee * He)) : pt > X ? St < X && (He = xe(ke, ae, Ie, dt, Tt, X), ue && (ke.start = Be + Ee * He)) : zt(ke, ae, Ie, $e), St < N && pt >= N && (He = xe(ke, ae, Ie, dt, Tt, N), qt = !0), St > X && pt <= X && (He = xe(ke, ae, Ie, dt, Tt, X), qt = !0), !Q && qt && (ue && (ke.end = Be + Ee * He), O.push(ke), ke = Ot(de)), ue && (Be += Ee)
          }
          let ie = de.length - 3;
          const J = de[ie],
            Ve = de[ie + 1],
            rt = re === 0 ? J : Ve;
          rt >= N && rt <= X && zt(ke, J, Ve, de[ie + 2]), ie = ke.length - 3, Q && ie >= 3 && (ke[ie] !== ke[0] || ke[ie + 1] !== ke[1]) && zt(ke, ke[0], ke[1], ke[2]), ke.length && O.push(ke)
        }

        function Ot(de) {
          const O = [];
          return O.size = de.size, O.start = de.start, O.end = de.end, O
        }

        function mr(de, O, N, X, re, Q) {
          for (const ue of de) Qt(ue, O, N, X, re, Q, !1)
        }

        function zt(de, O, N, X) {
          de.push(O, N, X)
        }

        function Mt(de, O, N, X, re, Q) {
          const ue = (Q - O) / (X - O);
          return zt(de, Q, N + (re - N) * ue, 1), ue
        }

        function kt(de, O, N, X, re, Q) {
          const ue = (Q - N) / (re - N);
          return zt(de, O + (X - O) * ue, Q, 1), ue
        }

        function It(de, O) {
          const N = [];
          for (let X = 0; X < de.length; X++) {
            const re = de[X],
              Q = re.type;
            let ue;
            if (Q === "Point" || Q === "MultiPoint" || Q === "LineString") ue = Gt(re.geometry, O);
            else if (Q === "MultiLineString" || Q === "Polygon") {
              ue = [];
              for (const ke of re.geometry) ue.push(Gt(ke, O))
            } else if (Q === "MultiPolygon") {
              ue = [];
              for (const ke of re.geometry) {
                const xe = [];
                for (const Ee of ke) xe.push(Gt(Ee, O));
                ue.push(xe)
              }
            }
            N.push(yt(re.id, Q, ue, re.tags))
          }
          return N
        }

        function Gt(de, O) {
          const N = [];
          N.size = de.size, de.start !== void 0 && (N.start = de.start, N.end = de.end);
          for (let X = 0; X < de.length; X += 3) N.push(de[X] + O, de[X + 1], de[X + 2]);
          return N
        }

        function ht(de, O) {
          if (de.transformed) return de;
          const N = 1 << de.z,
            X = de.x,
            re = de.y;
          for (const Q of de.features) {
            const ue = Q.geometry,
              ke = Q.type;
            if (Q.geometry = [], ke === 1)
              for (let xe = 0; xe < ue.length; xe += 2) Q.geometry.push(hr(ue[xe], ue[xe + 1], O, N, X, re));
            else
              for (let xe = 0; xe < ue.length; xe++) {
                const Ee = [];
                for (let He = 0; He < ue[xe].length; He += 2) Ee.push(hr(ue[xe][He], ue[xe][He + 1], O, N, X, re));
                Q.geometry.push(Ee)
              }
          }
          return de.transformed = !0, de
        }

        function hr(de, O, N, X, re, Q) {
          return [Math.round(N * (de * X - re)), Math.round(N * (O * X - Q))]
        }

        function wr(de, O, N, X, re) {
          const Q = O === re.maxZoom ? 0 : re.tolerance / ((1 << O) * re.extent),
            ue = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: de.length,
              source: null,
              x: N,
              y: X,
              z: O,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const ke of de) ur(ue, ke, Q, re);
          return ue
        }

        function ur(de, O, N, X) {
          const re = O.geometry,
            Q = O.type,
            ue = [];
          if (de.minX = Math.min(de.minX, O.minX), de.minY = Math.min(de.minY, O.minY), de.maxX = Math.max(de.maxX, O.maxX), de.maxY = Math.max(de.maxY, O.maxY), Q === "Point" || Q === "MultiPoint")
            for (let ke = 0; ke < re.length; ke += 3) ue.push(re[ke], re[ke + 1]), de.numPoints++, de.numSimplified++;
          else if (Q === "LineString") qr(ue, re, de, N, !1, !1);
          else if (Q === "MultiLineString" || Q === "Polygon")
            for (let ke = 0; ke < re.length; ke++) qr(ue, re[ke], de, N, Q === "Polygon", ke === 0);
          else if (Q === "MultiPolygon")
            for (let ke = 0; ke < re.length; ke++) {
              const xe = re[ke];
              for (let Ee = 0; Ee < xe.length; Ee++) qr(ue, xe[Ee], de, N, !0, Ee === 0)
            }
          if (ue.length) {
            let ke = O.tags || null;
            if (Q === "LineString" && X.lineMetrics) {
              ke = {};
              for (const Ee in O.tags) ke[Ee] = O.tags[Ee];
              ke.mapbox_clip_start = re.start / re.size, ke.mapbox_clip_end = re.end / re.size
            }
            const xe = {
              geometry: ue,
              type: Q === "Polygon" || Q === "MultiPolygon" ? 3 : Q === "LineString" || Q === "MultiLineString" ? 2 : 1,
              tags: ke
            };
            O.id !== null && (xe.id = O.id), de.features.push(xe)
          }
        }

        function qr(de, O, N, X, re, Q) {
          const ue = X * X;
          if (X > 0 && O.size < (re ? ue : X)) return void(N.numPoints += O.length / 3);
          const ke = [];
          for (let xe = 0; xe < O.length; xe += 3)(X === 0 || O[xe + 2] > ue) && (N.numSimplified++, ke.push(O[xe], O[xe + 1])), N.numPoints++;
          re && (function(xe, Ee) {
            let He = 0;
            for (let Be = 0, ie = xe.length, J = ie - 2; Be < ie; J = Be, Be += 2) He += (xe[Be] - xe[J]) * (xe[Be + 1] + xe[J + 1]);
            if (He > 0 === Ee)
              for (let Be = 0, ie = xe.length; Be < ie / 2; Be += 2) {
                const J = xe[Be],
                  Ve = xe[Be + 1];
                xe[Be] = xe[ie - 2 - Be], xe[Be + 1] = xe[ie - 1 - Be], xe[ie - 2 - Be] = J, xe[ie - 1 - Be] = Ve
              }
          })(ke, Q), de.push(ke)
        }
        const kr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Zr {
          constructor(O, N) {
            const X = (N = this.options = (function(Q, ue) {
              for (const ke in ue) Q[ke] = ue[ke];
              return Q
            })(Object.create(kr), N)).debug;
            if (X && console.time("preprocess data"), N.maxZoom < 0 || N.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (N.promoteId && N.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let re = (function(Q, ue) {
              const ke = [];
              if (Q.type === "FeatureCollection")
                for (let xe = 0; xe < Q.features.length; xe++) jt(ke, Q.features[xe], ue, xe);
              else jt(ke, Q.type === "Feature" ? Q : {
                geometry: Q
              }, ue);
              return ke
            })(O, N);
            this.tiles = {}, this.tileCoords = [], X && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", N.indexMaxZoom, N.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), re = (function(Q, ue) {
              const ke = ue.buffer / ue.extent;
              let xe = Q;
              const Ee = nt(Q, 1, -1 - ke, ke, 0, -1, 2, ue),
                He = nt(Q, 1, 1 - ke, 2 + ke, 0, -1, 2, ue);
              return (Ee || He) && (xe = nt(Q, 1, -ke, 1 + ke, 0, -1, 2, ue) || [], Ee && (xe = It(Ee, 1).concat(xe)), He && (xe = xe.concat(It(He, -1)))), xe
            })(re, N), re.length && this.splitTile(re, 0, 0, 0), X && (re.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(O, N, X, re, Q, ue, ke) {
            const xe = [O, N, X, re],
              Ee = this.options,
              He = Ee.debug;
            for (; xe.length;) {
              re = xe.pop(), X = xe.pop(), N = xe.pop(), O = xe.pop();
              const Be = 1 << N,
                ie = Wr(N, X, re);
              let J = this.tiles[ie];
              if (!J && (He > 1 && console.time("creation"), J = this.tiles[ie] = wr(O, N, X, re, Ee), this.tileCoords.push({
                  z: N,
                  x: X,
                  y: re
                }), He)) {
                He > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", N, X, re, J.numFeatures, J.numPoints, J.numSimplified), console.timeEnd("creation"));
                const qt = `z${N}`;
                this.stats[qt] = (this.stats[qt] || 0) + 1, this.total++
              }
              if (J.source = O, Q == null) {
                if (N === Ee.indexMaxZoom || J.numPoints <= Ee.indexMaxPoints) continue
              } else {
                if (N === Ee.maxZoom || N === Q) continue;
                if (Q != null) {
                  const qt = Q - N;
                  if (X !== ue >> qt || re !== ke >> qt) continue
                }
              }
              if (J.source = null, O.length === 0) continue;
              He > 1 && console.time("clipping");
              const Ve = .5 * Ee.buffer / Ee.extent,
                rt = .5 - Ve,
                Ue = .5 + Ve,
                ae = 1 + Ve;
              let Ie = null,
                $e = null,
                dt = null,
                Tt = null,
                pt = nt(O, Be, X - Ve, X + Ue, 0, J.minX, J.maxX, Ee),
                St = nt(O, Be, X + rt, X + ae, 0, J.minX, J.maxX, Ee);
              O = null, pt && (Ie = nt(pt, Be, re - Ve, re + Ue, 1, J.minY, J.maxY, Ee), $e = nt(pt, Be, re + rt, re + ae, 1, J.minY, J.maxY, Ee), pt = null), St && (dt = nt(St, Be, re - Ve, re + Ue, 1, J.minY, J.maxY, Ee), Tt = nt(St, Be, re + rt, re + ae, 1, J.minY, J.maxY, Ee), St = null), He > 1 && console.timeEnd("clipping"), xe.push(Ie || [], N + 1, 2 * X, 2 * re), xe.push($e || [], N + 1, 2 * X, 2 * re + 1), xe.push(dt || [], N + 1, 2 * X + 1, 2 * re), xe.push(Tt || [], N + 1, 2 * X + 1, 2 * re + 1)
            }
          }
          getTile(O, N, X) {
            O = +O, N = +N, X = +X;
            const re = this.options,
              {
                extent: Q,
                debug: ue
              } = re;
            if (O < 0 || O > 24) return null;
            const ke = 1 << O,
              xe = Wr(O, N = N + ke & ke - 1, X);
            if (this.tiles[xe]) return ht(this.tiles[xe], Q);
            ue > 1 && console.log("drilling down to z%d-%d-%d", O, N, X);
            let Ee, He = O,
              Be = N,
              ie = X;
            for (; !Ee && He > 0;) He--, Be >>= 1, ie >>= 1, Ee = this.tiles[Wr(He, Be, ie)];
            return Ee && Ee.source ? (ue > 1 && (console.log("found parent tile z%d-%d-%d", He, Be, ie), console.time("drilling down")), this.splitTile(Ee.source, He, Be, ie, O, N, X), ue > 1 && console.timeEnd("drilling down"), this.tiles[xe] ? ht(this.tiles[xe], Q) : null) : null
          }
        }

        function Wr(de, O, N) {
          return 32 * ((1 << de) * N + O) + de
        }
        class tr extends $ {
          constructor(O, N, X, re = Hr) {
            super(O, N, X), this._dataUpdateable = new Map, this._createGeoJSONIndex = re
          }
          loadVectorTile(O, N) {
            return k._(this, void 0, void 0, (function*() {
              const X = O.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const re = this._geoJSONIndex.getTile(X.z, X.x, X.y);
              if (!re) return null;
              const Q = new Fe(re.features, {
                version: 2,
                extent: k.a3
              });
              let ue = (function(ke) {
                const xe = new k.cP;
                return (function(Ee, He) {
                  for (const Be in Ee.layers) He.writeMessage(3, be, Ee.layers[Be])
                })(ke, xe), xe.finish()
              })(Q);
              return ue.byteOffset === 0 && ue.byteLength === ue.buffer.byteLength || (ue = new Uint8Array(ue)), {
                vectorTile: Q,
                rawData: ue.buffer
              }
            }))
          }
          loadData(O) {
            return k._(this, void 0, void 0, (function*() {
              var N;
              (N = this._pendingRequest) === null || N === void 0 || N.abort();
              const X = !!(O && O.request && O.request.collectResourceTiming) && new k.cQ(O.request);
              this._pendingRequest = new AbortController;
              try {
                (!this._pendingData || O.request || O.data || O.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(O, this._pendingRequest));
                const re = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(re, O), this.loaded = {};
                const Q = {
                  data: re
                };
                if (X) {
                  const ue = X.finish();
                  ue && (Q.resourceTiming = {}, Q.resourceTiming[O.source] = JSON.parse(JSON.stringify(ue)))
                }
                return Q
              } catch (re) {
                if (delete this._pendingRequest, k.cB(re)) return {
                  abandoned: !0
                };
                throw re
              }
            }))
          }
          getData() {
            return k._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(O) {
            const N = this.loaded;
            return N && N[O.uid] ? super.reloadTile(O) : this.loadTile(O)
          }
          loadAndProcessGeoJSON(O, N) {
            return k._(this, void 0, void 0, (function*() {
              let X = yield this.loadGeoJSON(O, N);
              if (delete this._pendingRequest, typeof X != "object") throw new Error(`Input data given to '${O.source}' is not a valid GeoJSON object.`);
              if (Me(X, !0), O.filter) {
                const re = k.cW(O.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (re.result === "error") throw new Error(re.value.map((ue => `${ue.key}: ${ue.message}`)).join(", "));
                X = {
                  type: "FeatureCollection",
                  features: X.features.filter((ue => re.value.evaluate({
                    zoom: 0
                  }, ue)))
                }
              }
              return X
            }))
          }
          loadGeoJSON(O, N) {
            return k._(this, void 0, void 0, (function*() {
              const {
                promoteId: X
              } = O;
              if (O.request) {
                const re = yield k.j(O.request, N);
                return this._dataUpdateable = k.cY(re.data, X) ? k.cX(re.data, X) : void 0, re.data
              }
              if (typeof O.data == "string") try {
                const re = JSON.parse(O.data);
                return this._dataUpdateable = k.cY(re, X) ? k.cX(re, X) : void 0, re
              } catch {
                throw new Error(`Input data given to '${O.source}' is not a valid GeoJSON object.`)
              }
              if (!O.dataDiff) throw new Error(`Input data given to '${O.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${O.source}`);
              return k.cZ(this._dataUpdateable, O.dataDiff, X), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(O) {
            return k._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(O) {
            return this._geoJSONIndex.getClusterExpansionZoom(O.clusterId)
          }
          getClusterChildren(O) {
            return this._geoJSONIndex.getChildren(O.clusterId)
          }
          getClusterLeaves(O) {
            return this._geoJSONIndex.getLeaves(O.clusterId, O.limit, O.offset)
          }
        }

        function Hr(de, O) {
          return O.cluster ? new et((function({
            superclusterOptions: N,
            clusterProperties: X
          }) {
            if (!X || !N) return N;
            const re = {},
              Q = {},
              ue = {
                accumulated: null,
                zoom: 0
              },
              ke = {
                properties: null
              },
              xe = Object.keys(X);
            for (const Ee of xe) {
              const [He, Be] = X[Ee], ie = k.cW(Be), J = k.cW(typeof He == "string" ? [He, ["accumulated"],
                ["get", Ee]
              ] : He);
              re[Ee] = ie.value, Q[Ee] = J.value
            }
            return N.map = Ee => {
              ke.properties = Ee;
              const He = {};
              for (const Be of xe) He[Be] = re[Be].evaluate(ue, ke);
              return He
            }, N.reduce = (Ee, He) => {
              ke.properties = He;
              for (const Be of xe) ue.accumulated = Ee[Be], Ee[Be] = Q[Be].evaluate(ue, ke)
            }, N
          })(O)).load(de.features) : (function(N, X) {
            return new Zr(N, X)
          })(de, O.geojsonVtOptions)
        }
        class sr {
          constructor(O) {
            this.self = O, this.actor = new k.K(O), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (N, X) => {
              if (this.externalWorkerSourceTypes[N]) throw new Error(`Worker source with name "${N}" already registered.`);
              this.externalWorkerSourceTypes[N] = X
            }, this.self.addProtocol = k.cD, this.self.removeProtocol = k.cE, this.self.registerRTLTextPlugin = N => {
              k.c_.setMethods(N)
            }, this.actor.registerMessageHandler("LDT", ((N, X) => this._getDEMWorkerSource(N, X.source).loadTile(X))), this.actor.registerMessageHandler("RDT", ((N, X) => k._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(N, X.source).removeTile(X)
            })))), this.actor.registerMessageHandler("GCEZ", ((N, X) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(N, X.type, X.source).getClusterExpansionZoom(X)
            })))), this.actor.registerMessageHandler("GCC", ((N, X) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(N, X.type, X.source).getClusterChildren(X)
            })))), this.actor.registerMessageHandler("GCL", ((N, X) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(N, X.type, X.source).getClusterLeaves(X)
            })))), this.actor.registerMessageHandler("LD", ((N, X) => this._getWorkerSource(N, X.type, X.source).loadData(X))), this.actor.registerMessageHandler("GD", ((N, X) => this._getWorkerSource(N, X.type, X.source).getData())), this.actor.registerMessageHandler("LT", ((N, X) => this._getWorkerSource(N, X.type, X.source).loadTile(X))), this.actor.registerMessageHandler("RT", ((N, X) => this._getWorkerSource(N, X.type, X.source).reloadTile(X))), this.actor.registerMessageHandler("AT", ((N, X) => this._getWorkerSource(N, X.type, X.source).abortTile(X))), this.actor.registerMessageHandler("RMT", ((N, X) => this._getWorkerSource(N, X.type, X.source).removeTile(X))), this.actor.registerMessageHandler("RS", ((N, X) => k._(this, void 0, void 0, (function*() {
              if (!this.workerSources[N] || !this.workerSources[N][X.type] || !this.workerSources[N][X.type][X.source]) return;
              const re = this.workerSources[N][X.type][X.source];
              delete this.workerSources[N][X.type][X.source], re.removeSource !== void 0 && re.removeSource(X)
            })))), this.actor.registerMessageHandler("RM", (N => k._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[N], delete this.availableImages[N], delete this.workerSources[N], delete this.demWorkerSources[N], this.globalStates.delete(N)
            })))), this.actor.registerMessageHandler("SR", ((N, X) => k._(this, void 0, void 0, (function*() {
              this.referrer = X
            })))), this.actor.registerMessageHandler("SRPS", ((N, X) => this._syncRTLPluginState(N, X))), this.actor.registerMessageHandler("IS", ((N, X) => k._(this, void 0, void 0, (function*() {
              this.self.importScripts(X)
            })))), this.actor.registerMessageHandler("SI", ((N, X) => this._setImages(N, X))), this.actor.registerMessageHandler("UL", ((N, X) => k._(this, void 0, void 0, (function*() {
              this._getLayerIndex(N).update(X.layers, X.removedIds, this._getGlobalState(N))
            })))), this.actor.registerMessageHandler("UGS", ((N, X) => k._(this, void 0, void 0, (function*() {
              const re = this._getGlobalState(N);
              for (const Q in X) re[Q] = X[Q]
            })))), this.actor.registerMessageHandler("SL", ((N, X) => k._(this, void 0, void 0, (function*() {
              this._getLayerIndex(N).replace(X, this._getGlobalState(N))
            }))))
          }
          _getGlobalState(O) {
            let N = this.globalStates.get(O);
            return N || (N = {}, this.globalStates.set(O, N)), N
          }
          _setImages(O, N) {
            return k._(this, void 0, void 0, (function*() {
              this.availableImages[O] = N;
              for (const X in this.workerSources[O]) {
                const re = this.workerSources[O][X];
                for (const Q in re) re[Q].availableImages = N
              }
            }))
          }
          _syncRTLPluginState(O, N) {
            return k._(this, void 0, void 0, (function*() {
              return yield k.c_.syncState(N, this.self.importScripts)
            }))
          }
          _getAvailableImages(O) {
            let N = this.availableImages[O];
            return N || (N = []), N
          }
          _getLayerIndex(O) {
            let N = this.layerIndexes[O];
            return N || (N = this.layerIndexes[O] = new l), N
          }
          _getWorkerSource(O, N, X) {
            if (this.workerSources[O] || (this.workerSources[O] = {}), this.workerSources[O][N] || (this.workerSources[O][N] = {}), !this.workerSources[O][N][X]) {
              const re = {
                sendAsync: (Q, ue) => (Q.targetMapId = O, this.actor.sendAsync(Q, ue))
              };
              switch (N) {
                case "vector":
                  this.workerSources[O][N][X] = new $(re, this._getLayerIndex(O), this._getAvailableImages(O));
                  break;
                case "geojson":
                  this.workerSources[O][N][X] = new tr(re, this._getLayerIndex(O), this._getAvailableImages(O));
                  break;
                default:
                  this.workerSources[O][N][X] = new this.externalWorkerSourceTypes[N](re, this._getLayerIndex(O), this._getAvailableImages(O))
              }
            }
            return this.workerSources[O][N][X]
          }
          _getDEMWorkerSource(O, N) {
            return this.demWorkerSources[O] || (this.demWorkerSources[O] = {}), this.demWorkerSources[O][N] || (this.demWorkerSources[O][N] = new se), this.demWorkerSources[O][N]
          }
        }
        return k.i(self) && (self.worker = new sr(self)), sr
      })), z("index", ["exports", "./shared"], (function(k, l) {
        var F = "5.11.0";

        function W() {
          var d = new l.A(4);
          return l.A != Float32Array && (d[1] = 0, d[2] = 0), d[0] = 1, d[3] = 1, d
        }
        let ee, $;
        const se = {
            frame(d, e, a) {
              const c = requestAnimationFrame((f => {
                  h(), e(f)
                })),
                {
                  unsubscribe: h
                } = l.s(d.signal, "abort", (() => {
                  h(), cancelAnimationFrame(c), a(l.c())
                }), !1)
            },
            frameAsync(d) {
              return new Promise(((e, a) => {
                this.frame(d, e, a)
              }))
            },
            getImageData(d, e = 0) {
              return this.getImageCanvasContext(d).getImageData(-e, -e, d.width + 2 * e, d.height + 2 * e)
            },
            getImageCanvasContext(d) {
              const e = window.document.createElement("canvas"),
                a = e.getContext("2d", {
                  willReadFrequently: !0
                });
              if (!a) throw new Error("failed to create canvas 2d context");
              return e.width = d.width, e.height = d.height, a.drawImage(d, 0, 0, d.width, d.height), a
            },
            resolveURL: d => (ee || (ee = document.createElement("a")), ee.href = d, ee.href),
            hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && ($ == null && ($ = matchMedia("(prefers-reduced-motion: reduce)")), $.matches)
            }
          },
          _e = new class {
            constructor() {
              this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null
            }
            getCurrentTime() {
              return this._frozenAt !== null ? this._frozenAt : this._realTime()
            }
            setNow(d) {
              this._frozenAt = d
            }
            restoreNow() {
              this._frozenAt = null
            }
            isFrozen() {
              return this._frozenAt !== null
            }
          };

        function ge() {
          return _e.getCurrentTime()
        }
        class V {
          static testProp(e) {
            if (!V.docStyle) return e[0];
            for (let a = 0; a < e.length; a++)
              if (e[a] in V.docStyle) return e[a];
            return e[0]
          }
          static create(e, a, c) {
            const h = window.document.createElement(e);
            return a !== void 0 && (h.className = a), c && c.appendChild(h), h
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a)
          }
          static disableDrag() {
            V.docStyle && V.selectProp && (V.userSelect = V.docStyle[V.selectProp], V.docStyle[V.selectProp] = "none")
          }
          static enableDrag() {
            V.docStyle && V.selectProp && (V.docStyle[V.selectProp] = V.userSelect)
          }
          static setTransform(e, a) {
            e.style[V.transformProp] = a
          }
          static addEventListener(e, a, c, h = {}) {
            e.addEventListener(a, c, "passive" in h ? h : h.capture)
          }
          static removeEventListener(e, a, c, h = {}) {
            e.removeEventListener(a, c, "passive" in h ? h : h.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", V.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", V.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", V.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return {
              x: a.width / e.offsetWidth || 1,
              y: a.height / e.offsetHeight || 1,
              boundingClientRect: a
            }
          }
          static getPoint(e, a, c) {
            const h = a.boundingClientRect;
            return new l.P((c.clientX - h.left) / a.x - e.clientLeft, (c.clientY - h.top) / a.y - e.clientTop)
          }
          static mousePos(e, a) {
            const c = V.getScale(e);
            return V.getPoint(e, c, a)
          }
          static touchPos(e, a) {
            const c = [],
              h = V.getScale(e);
            for (let f = 0; f < a.length; f++) c.push(V.getPoint(e, h, a[f]));
            return c
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              c = a.querySelectorAll("script");
            for (const h of c) h.remove();
            return V.clean(a), a.innerHTML
          }
          static isPossiblyDangerous(e, a) {
            const c = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !c.includes("javascript:") && !c.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const a = e.children;
            for (const c of a) V.removeAttributes(c), V.clean(c)
          }
          static removeAttributes(e) {
            for (const {
                name: a,
                value: c
              }
              of e.attributes) V.isPossiblyDangerous(a, c) && e.removeAttribute(a)
          }
        }
        V.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, V.selectProp = V.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), V.transformProp = V.testProp(["transform", "WebkitTransform"]);
        const Me = {
          supported: !1,
          testSupport: function(d) {
            !be && Fe && (Xe ? tt(d) : we = d)
          }
        };
        let we, Fe, be = !1,
          Xe = !1;

        function tt(d) {
          const e = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, e);
          try {
            if (d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, d.RGBA, d.UNSIGNED_BYTE, Fe), d.isContextLost()) return;
            Me.supported = !0
          } catch {}
          d.deleteTexture(e), be = !0
        }
        var Ye;
        typeof document < "u" && (Fe = document.createElement("img"), Fe.onload = () => {
          we && tt(we), we = null, Xe = !0
        }, Fe.onerror = () => {
          be = !0, we = null
        }, Fe.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(d) {
          let e, a, c, h;
          d.resetRequestQueue = () => {
            e = [], a = 0, c = 0, h = {}
          }, d.addThrottleControl = T => {
            const C = c++;
            return h[C] = T, C
          }, d.removeThrottleControl = T => {
            delete h[T], v()
          }, d.getImage = (T, C, A = !0) => new Promise(((j, R) => {
            Me.supported && (T.headers || (T.headers = {}), T.headers.accept = "image/webp,*/*"), l.e(T, {
              type: "image"
            }), e.push({
              abortController: C,
              requestParameters: T,
              supportImageRefresh: A,
              state: "queued",
              onError: Z => {
                R(Z)
              },
              onSuccess: Z => {
                j(Z)
              }
            }), v()
          }));
          const f = T => l._(this, void 0, void 0, (function*() {
              T.state = "running";
              const {
                requestParameters: C,
                supportImageRefresh: A,
                onError: j,
                onSuccess: R,
                abortController: Z
              } = T, Y = A === !1 && !l.i(self) && !l.g(C.url) && (!C.headers || Object.keys(C.headers).reduce(((ce, me) => ce && me === "accept"), !0));
              a++;
              const oe = Y ? w(C, Z) : l.m(C, Z);
              try {
                const ce = yield oe;
                delete T.abortController, T.state = "completed", ce.data instanceof HTMLImageElement || l.b(ce.data) ? R(ce) : ce.data && R({
                  data: yield(le = ce.data, typeof createImageBitmap == "function" ? l.f(le) : l.h(le)),
                  cacheControl: ce.cacheControl,
                  expires: ce.expires
                })
              } catch (ce) {
                delete T.abortController, j(ce)
              } finally {
                a--, v()
              }
              var le
            })),
            v = () => {
              const T = (() => {
                for (const C of Object.keys(h))
                  if (h[C]()) return !0;
                return !1
              })() ? l.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : l.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let C = a; C < T && e.length > 0; C++) {
                const A = e.shift();
                A.abortController.signal.aborted ? C-- : f(A)
              }
            },
            w = (T, C) => new Promise(((A, j) => {
              const R = new Image,
                Z = T.url,
                Y = T.credentials;
              Y && Y === "include" ? R.crossOrigin = "use-credentials" : (Y && Y === "same-origin" || !l.d(Z)) && (R.crossOrigin = "anonymous"), C.signal.addEventListener("abort", (() => {
                R.src = "", j(l.c())
              })), R.fetchPriority = "high", R.onload = () => {
                R.onerror = R.onload = null, A({
                  data: R
                })
              }, R.onerror = () => {
                R.onerror = R.onload = null, C.signal.aborted || j(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, R.src = Z
            }))
        })(Ye || (Ye = {})), Ye.resetRequestQueue();
        class Ce {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function De(d) {
          const e = [];
          if (typeof d == "string") e.push({
            id: "default",
            url: d
          });
          else if (d && d.length > 0) {
            const a = [];
            for (const {
                id: c,
                url: h
              }
              of d) {
              const f = `${c}${h}`;
              a.indexOf(f) === -1 && (a.push(f), e.push({
                id: c,
                url: h
              }))
            }
          }
          return e
        }

        function Ke(d, e, a) {
          try {
            const c = new URL(d);
            return c.pathname += `${e}${a}`, c.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${d}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function Le(d) {
          const {
            userImage: e
          } = d;
          return !!(e && e.render && e.render()) && (d.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class Ne extends l.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new l.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: a,
                  promiseResolve: c
                }
                of this.requestors) c(this._getImagesForIds(a));
              this.requestors = []
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const c = a.spriteData;
              a.data = new l.R({
                width: c.width,
                height: c.height
              }, c.context.getImageData(c.x, c.y, c.width, c.height).data), a.spriteData = null
            }
            return a
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a)
          }
          _validate(e, a) {
            let c = !0;
            const h = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, h && h.width) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "stretchX" value`))), c = !1), this._validateStretch(a.stretchY, h && h.height) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "stretchY" value`))), c = !1), this._validateContent(a.content, a) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "content" value`))), c = !1), c
          }
          _validateStretch(e, a) {
            if (!e) return !0;
            let c = 0;
            for (const h of e) {
              if (h[0] < c || h[1] < h[0] || a < h[1]) return !1;
              c = h[1]
            }
            return !0
          }
          _validateContent(e, a) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const c = a.spriteData,
              h = c && c.width || a.data.width,
              f = c && c.height || a.data.height;
            return !(e[0] < 0 || h < e[0] || e[1] < 0 || f < e[1] || e[2] < 0 || h < e[2] || e[3] < 0 || f < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, a, c = !0) {
            const h = this.getImage(e);
            if (c && (h.data.width !== a.data.width || h.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${h.data.width}x${h.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = h.version + 1, this.images[e] = a, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((a, c) => {
              let h = !0;
              if (!this.isLoaded())
                for (const f of e) this.images[f] || (h = !1);
              this.isLoaded() || h ? a(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: a
              })
            }))
          }
          _getImagesForIds(e) {
            const a = {};
            for (const c of e) {
              let h = this.getImage(c);
              h || (this.fire(new l.l("styleimagemissing", {
                id: c
              })), h = this.getImage(c)), h ? a[c] = {
                data: h.data.clone(),
                pixelRatio: h.pixelRatio,
                sdf: h.sdf,
                version: h.version,
                stretchX: h.stretchX,
                stretchY: h.stretchY,
                content: h.content,
                textFitWidth: h.textFitWidth,
                textFitHeight: h.textFitHeight,
                hasRenderCallback: !!(h.userImage && h.userImage.render)
              } : l.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return a
          }
          getPixelSize() {
            const {
              width: e,
              height: a
            } = this.atlasImage;
            return {
              width: e,
              height: a
            }
          }
          getPattern(e) {
            const a = this.patterns[e],
              c = this.getImage(e);
            if (!c) return null;
            if (a && a.position.version === c.version) return a.position;
            if (a) a.position.version = c.version;
            else {
              const h = {
                  w: c.data.width + 2,
                  h: c.data.height + 2,
                  x: 0,
                  y: 0
                },
                f = new l.I(h, c);
              this.patterns[e] = {
                bin: h,
                position: f
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new l.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const f in this.patterns) e.push(this.patterns[f].bin);
            const {
              w: a,
              h: c
            } = l.p(e), h = this.atlasImage;
            h.resize({
              width: a || 1,
              height: c || 1
            });
            for (const f in this.patterns) {
              const {
                bin: v
              } = this.patterns[f], w = v.x + 1, T = v.y + 1, C = this.getImage(f).data, A = C.width, j = C.height;
              l.R.copy(C, h, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: T
              }, {
                width: A,
                height: j
              }), l.R.copy(C, h, {
                x: 0,
                y: j - 1
              }, {
                x: w,
                y: T - 1
              }, {
                width: A,
                height: 1
              }), l.R.copy(C, h, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: T + j
              }, {
                width: A,
                height: 1
              }), l.R.copy(C, h, {
                x: A - 1,
                y: 0
              }, {
                x: w - 1,
                y: T
              }, {
                width: 1,
                height: j
              }), l.R.copy(C, h, {
                x: 0,
                y: 0
              }, {
                x: w + A,
                y: T
              }, {
                width: 1,
                height: j
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = !0;
              const c = this.getImage(a);
              c || l.w(`Image with ID: "${a}" was not found`), Le(c) && this.updateImage(a, c)
            }
          }
        }
        const vt = 1e20;

        function et(d, e, a, c, h, f, v, w, T) {
          for (let C = e; C < e + c; C++) We(d, a * f + C, f, h, v, w, T);
          for (let C = a; C < a + h; C++) We(d, C * f + e, 1, c, v, w, T)
        }

        function We(d, e, a, c, h, f, v) {
          f[0] = 0, v[0] = -vt, v[1] = vt, h[0] = d[e];
          for (let w = 1, T = 0, C = 0; w < c; w++) {
            h[w] = d[e + w * a];
            const A = w * w;
            do {
              const j = f[T];
              C = (h[w] - h[j] + A - j * j) / (w - j) / 2
            } while (C <= v[T] && --T > -1);
            T++, f[T] = w, v[T] = C, v[T + 1] = vt
          }
          for (let w = 0, T = 0; w < c; w++) {
            for (; v[T + 1] < w;) T++;
            const C = f[T],
              A = w - C;
            d[e + w * a] = h[C] + A * A
          }
        }
        const _t = l.v.layout_symbol["text-font"].default.join(",");
        class Vt {
          constructor(e, a, c) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = c
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = [];
              for (const f in e)
                for (const v of e[f]) a.push(this._getAndCacheGlyphsPromise(f, v));
              const c = yield Promise.all(a), h = {};
              for (const {
                  stack: f,
                  id: v,
                  glyph: w
                }
                of c) h[f] || (h[f] = {}), h[f][v] = w && {
                id: w.id,
                bitmap: w.bitmap.clone(),
                metrics: w.metrics
              };
              return h
            }))
          }
          _getAndCacheGlyphsPromise(e, a) {
            return l._(this, void 0, void 0, (function*() {
              let c = this.entries[e];
              c || (c = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let h = c.glyphs[a];
              return h !== void 0 ? {
                stack: e,
                id: a,
                glyph: h
              } : !this.url || this._charUsesLocalIdeographFontFamily(a) ? (h = c.glyphs[a] = this._drawGlyph(c, e, a), {
                stack: e,
                id: a,
                glyph: h
              }) : yield this._downloadAndCacheRangePromise(e, a)
            }))
          }
          _downloadAndCacheRangePromise(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = Math.floor(a / 256);
              if (256 * c > 65535) throw new Error("glyphs > 65535 not supported");
              const h = this.entries[e];
              if (h.ranges[c]) return {
                stack: e,
                id: a,
                glyph: null
              };
              if (!h.requests[c]) {
                const f = Vt.loadGlyphRange(e, c, this.url, this.requestManager);
                h.requests[c] = f
              }
              try {
                const f = yield h.requests[c];
                for (const v in f) h.glyphs[+v] = f[+v];
                return h.ranges[c] = !0, {
                  stack: e,
                  id: a,
                  glyph: f[a] || null
                }
              } catch (f) {
                const v = h.glyphs[a] = this._drawGlyph(h, e, a);
                return this._warnOnMissingGlyphRange(v, c, a, f), {
                  stack: e,
                  id: a,
                  glyph: v
                }
              }
            }))
          }
          _warnOnMissingGlyphRange(e, a, c, h) {
            const f = 256 * a,
              v = f + 255,
              w = c.toString(16).padStart(4, "0").toUpperCase();
            l.w(`Unable to load glyph range ${a}, ${f}-${v}. Rendering codepoint U+${w} locally instead. ${h}`)
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || l.u["CJK Unified Ideographs"](e) || l.u["Hangul Syllables"](e) || l.u.Hiragana(e) || l.u.Katakana(e) || l.u["CJK Symbols and Punctuation"](e) || l.u["Halfwidth and Fullwidth Forms"](e))
          }
          _drawGlyph(e, a, c) {
            const h = a === _t && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(c),
              f = h ? "ideographTinySDF" : "tinySDF";
            e[f] || (e[f] = this._createTinySDF(h ? this.localIdeographFontFamily : a));
            const v = e[f].draw(String.fromCharCode(c));
            return {
              id: c,
              bitmap: new l.q({
                width: v.width || 60,
                height: v.height || 60
              }, v.data),
              metrics: {
                width: v.glyphWidth / 2 || 24,
                height: v.glyphHeight / 2 || 24,
                left: v.glyphLeft / 2 + .5 || 0,
                top: v.glyphTop / 2 - 27.5 || -8,
                advance: v.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
          _createTinySDF(e) {
            const a = e ? e.split(",") : [];
            a.push("sans-serif");
            const c = a.map((h => /[-\w]+/.test(h) ? h : `'${CSS.escape(h)}'`)).join(",");
            return new Vt.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: .25,
              fontFamily: c,
              fontWeight: this._fontWeight(a[0]),
              fontStyle: this._fontStyle(a[0]),
              lang: this.lang
            })
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal"
          }
          _fontWeight(e) {
            const a = {
              thin: 100,
              hairline: 100,
              "extra light": 200,
              "ultra light": 200,
              light: 300,
              normal: 400,
              regular: 400,
              medium: 500,
              semibold: 600,
              demibold: 600,
              bold: 700,
              "extra bold": 800,
              "ultra bold": 800,
              black: 900,
              heavy: 900,
              "extra black": 950,
              "ultra black": 950
            };
            let c;
            for (const [h, f] of Object.entries(a)) new RegExp(`\\b${h}\\b`, "i").test(e) && (c = `${f}`);
            return c
          }
        }
        Vt.loadGlyphRange = function(d, e, a, c) {
          return l._(this, void 0, void 0, (function*() {
            const h = 256 * e,
              f = h + 255,
              v = c.transformRequest(a.replace("{fontstack}", d).replace("{range}", `${h}-${f}`), "Glyphs"),
              w = yield l.n(v, new AbortController);
            if (!w || !w.data) throw new Error(`Could not load glyph range. range: ${e}, ${h}-${f}`);
            const T = {};
            for (const C of l.o(w.data)) T[C.id] = C;
            return T
          }))
        }, Vt.TinySDF = class {
          constructor({
            fontSize: d = 24,
            buffer: e = 3,
            radius: a = 8,
            cutoff: c = .25,
            fontFamily: h = "sans-serif",
            fontWeight: f = "normal",
            fontStyle: v = "normal",
            lang: w = null
          } = {}) {
            this.buffer = e, this.cutoff = c, this.radius = a, this.lang = w;
            const T = this.size = d + 4 * e,
              C = this._createCanvas(T),
              A = this.ctx = C.getContext("2d", {
                willReadFrequently: !0
              });
            A.font = `${v} ${f} ${d}px ${h}`, A.textBaseline = "alphabetic", A.textAlign = "left", A.fillStyle = "black", this.gridOuter = new Float64Array(T * T), this.gridInner = new Float64Array(T * T), this.f = new Float64Array(T), this.z = new Float64Array(T + 1), this.v = new Uint16Array(T)
          }
          _createCanvas(d) {
            const e = document.createElement("canvas");
            return e.width = e.height = d, e
          }
          draw(d) {
            const {
              width: e,
              actualBoundingBoxAscent: a,
              actualBoundingBoxDescent: c,
              actualBoundingBoxLeft: h,
              actualBoundingBoxRight: f
            } = this.ctx.measureText(d), v = Math.ceil(a), w = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(f - h))), T = Math.min(this.size - this.buffer, v + Math.ceil(c)), C = w + 2 * this.buffer, A = T + 2 * this.buffer, j = Math.max(C * A, 0), R = new Uint8ClampedArray(j), Z = {
              data: R,
              width: C,
              height: A,
              glyphWidth: w,
              glyphHeight: T,
              glyphTop: v,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (w === 0 || T === 0) return Z;
            const {
              ctx: Y,
              buffer: oe,
              gridInner: le,
              gridOuter: ce
            } = this;
            this.lang && (Y.lang = this.lang), Y.clearRect(oe, oe, w, T), Y.fillText(d, oe, oe + v);
            const me = Y.getImageData(oe, oe, w, T);
            ce.fill(vt, 0, j), le.fill(0, 0, j);
            for (let Se = 0; Se < T; Se++)
              for (let fe = 0; fe < w; fe++) {
                const Pe = me.data[4 * (Se * w + fe) + 3] / 255;
                if (Pe === 0) continue;
                const Ae = (Se + oe) * C + fe + oe;
                if (Pe === 1) ce[Ae] = 0, le[Ae] = vt;
                else {
                  const ve = .5 - Pe;
                  ce[Ae] = ve > 0 ? ve * ve : 0, le[Ae] = ve < 0 ? ve * ve : 0
                }
              }
            et(ce, 0, 0, C, A, C, this.f, this.v, this.z), et(le, oe, oe, w, T, C, this.f, this.v, this.z);
            for (let Se = 0; Se < j; Se++) {
              const fe = Math.sqrt(ce[Se]) - Math.sqrt(le[Se]);
              R[Se] = Math.round(255 - 255 * (fe / this.radius + this.cutoff))
            }
            return Z
          }
        };
        class Et {
          constructor() {
            this.specification = l.t.light.position
          }
          possiblyEvaluate(e, a) {
            return l.C(e.expression.evaluate(a))
          }
          interpolate(e, a, c) {
            return {
              x: l.F.number(e.x, a.x, c),
              y: l.F.number(e.y, a.y, c),
              z: l.F.number(e.z, a.z, c)
            }
          }
        }
        let Pt;
        class lt extends l.E {
          constructor(e) {
            super(), Pt = Pt || new l.r({
              anchor: new l.D(l.t.light.anchor),
              position: new Et,
              color: new l.D(l.t.light.color),
              intensity: new l.D(l.t.light.intensity)
            }), this._transitionable = new l.x(Pt, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, a = {}) {
            if (!this._validate(l.y, e, a))
              for (const c in e) {
                const h = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), h) : this._transitionable.setValue(c, h)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, c) {
            return (!c || c.validate !== !1) && l.z(this, e.call(l.B, {
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: l.t
            }))
          }
        }
        const $t = new l.r({
          "sky-color": new l.D(l.t.sky["sky-color"]),
          "horizon-color": new l.D(l.t.sky["horizon-color"]),
          "fog-color": new l.D(l.t.sky["fog-color"]),
          "fog-ground-blend": new l.D(l.t.sky["fog-ground-blend"]),
          "horizon-fog-blend": new l.D(l.t.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new l.D(l.t.sky["sky-horizon-blend"]),
          "atmosphere-blend": new l.D(l.t.sky["atmosphere-blend"])
        });
        class yt extends l.E {
          constructor(e) {
            super(), this._transitionable = new l.x($t, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new l.G(0))
          }
          setSky(e, a = {}) {
            if (!this._validate(l.H, e, a)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const c in e) {
                const h = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), h) : this._transitionable.setValue(c, h)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, c = {}) {
            return (c == null ? void 0 : c.validate) !== !1 && l.z(this, e.call(l.B, l.e({
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: l.t
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class Rt {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, a) {
            const c = e.join(",") + String(a);
            return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(e, a)), this.dashEntry[c]
          }
          getDashRanges(e, a, c) {
            const h = [];
            let f = e.length % 2 == 1 ? -e[e.length - 1] * c : 0,
              v = e[0] * c,
              w = !0;
            h.push({
              left: f,
              right: v,
              isDash: w,
              zeroLength: e[0] === 0
            });
            let T = e[0];
            for (let C = 1; C < e.length; C++) {
              w = !w;
              const A = e[C];
              f = T * c, T += A, v = T * c, h.push({
                left: f,
                right: v,
                isDash: w,
                zeroLength: A === 0
              })
            }
            return h
          }
          addRoundDash(e, a, c) {
            const h = a / 2;
            for (let f = -c; f <= c; f++) {
              const v = this.width * (this.nextRow + c + f);
              let w = 0,
                T = e[w];
              for (let C = 0; C < this.width; C++) {
                C / T.right > 1 && (T = e[++w]);
                const A = Math.abs(C - T.left),
                  j = Math.abs(C - T.right),
                  R = Math.min(A, j);
                let Z;
                const Y = f / c * (h + 1);
                if (T.isDash) {
                  const oe = h - Math.abs(Y);
                  Z = Math.sqrt(R * R + oe * oe)
                } else Z = h - Math.sqrt(R * R + Y * Y);
                this.data[v + C] = Math.max(0, Math.min(255, Z + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let w = e.length - 1; w >= 0; --w) {
              const T = e[w],
                C = e[w + 1];
              T.zeroLength ? e.splice(w, 1) : C && C.isDash === T.isDash && (C.left = T.left, e.splice(w, 1))
            }
            const a = e[0],
              c = e[e.length - 1];
            a.isDash === c.isDash && (a.left = c.left - this.width, c.right = a.right + this.width);
            const h = this.width * this.nextRow;
            let f = 0,
              v = e[f];
            for (let w = 0; w < this.width; w++) {
              w / v.right > 1 && (v = e[++f]);
              const T = Math.abs(w - v.left),
                C = Math.abs(w - v.right),
                A = Math.min(T, C);
              this.data[h + w] = Math.max(0, Math.min(255, (v.isDash ? A : -A) + 128))
            }
          }
          addDash(e, a) {
            const c = a ? 7 : 0,
              h = 2 * c + 1;
            if (this.nextRow + h > this.height) return l.w("LineAtlas out of space"), null;
            let f = 0;
            for (let w = 0; w < e.length; w++) f += e[w];
            if (f !== 0) {
              const w = this.width / f,
                T = this.getDashRanges(e, this.width, w);
              a ? this.addRoundDash(T, w, c) : this.addRegularDash(T)
            }
            const v = {
              y: this.nextRow + c,
              height: 2 * c,
              width: f
            };
            return this.nextRow += h, this.dirty = !0, v
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data))
          }
        }
        const jt = "maplibre_preloaded_worker_pool";
        class Xt {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Xt.workerCount;) this.workers.push(new Worker(l.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((a => {
              a.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[jt]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const fr = Math.floor(se.hardwareConcurrency / 2);
        let Yt, lr;

        function ot() {
          return Yt || (Yt = new Xt), Yt
        }
        Xt.workerCount = l.J(globalThis) ? Math.max(Math.min(fr, 3), 1) : 1;
        class nt {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const c = this.workerPool.acquire(a);
            for (let h = 0; h < c.length; h++) {
              const f = new l.K(c[h], a);
              f.name = `Worker ${h}`, this.actors.push(f)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, a) {
            const c = [];
            for (const h of this.actors) c.push(h.sendAsync({
              type: e,
              data: a
            }));
            return Promise.all(c)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((a => {
              a.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, a) {
            for (const c of this.actors) c.registerMessageHandler(e, a)
          }
        }

        function Ut() {
          return lr || (lr = new nt(ot(), l.L), lr.registerMessageHandler("GR", ((d, e, a) => l.m(e, a)))), lr
        }

        function Qt(d, e) {
          const a = l.M();
          return l.N(a, a, [1, 1, 0]), l.O(a, a, [.5 * d.width, .5 * d.height, 1]), d.calculatePosMatrix ? l.Q(a, a, d.calculatePosMatrix(e.toUnwrapped())) : a
        }

        function Ot(d, e, a, c, h, f, v) {
          var w;
          const T = (function(R, Z, Y) {
              if (R)
                for (const oe of R) {
                  const le = Z[oe];
                  if (le && le.source === Y && le.type === "fill-extrusion") return !0
                } else
                  for (const oe in Z) {
                    const le = Z[oe];
                    if (le.source === Y && le.type === "fill-extrusion") return !0
                  }
              return !1
            })((w = h == null ? void 0 : h.layers) !== null && w !== void 0 ? w : null, e, d.id),
            C = f.maxPitchScaleFactor(),
            A = d.tilesIn(c, C, T);
          A.sort(mr);
          const j = [];
          for (const R of A) j.push({
            wrappedTileID: R.tileID.wrapped().key,
            queryResults: R.tile.queryRenderedFeatures(e, a, d.getState(), R.queryGeometry, R.cameraQueryGeometry, R.scale, h, f, C, Qt(f, R.tileID), v ? (Z, Y) => v(R.tileID, Z, Y) : void 0)
          });
          return (function(R, Z) {
            for (const Y in R)
              for (const oe of R[Y]) zt(oe, Z);
            return R
          })((function(R) {
            const Z = {},
              Y = {};
            for (const oe of R) {
              const le = oe.queryResults,
                ce = oe.wrappedTileID,
                me = Y[ce] = Y[ce] || {};
              for (const Se in le) {
                const fe = le[Se],
                  Pe = me[Se] = me[Se] || {},
                  Ae = Z[Se] = Z[Se] || [];
                for (const ve of fe) Pe[ve.featureIndex] || (Pe[ve.featureIndex] = !0, Ae.push(ve))
              }
            }
            return Z
          })(j), d)
        }

        function mr(d, e) {
          const a = d.tileID,
            c = e.tileID;
          return a.overscaledZ - c.overscaledZ || a.canonical.y - c.canonical.y || a.wrap - c.wrap || a.canonical.x - c.canonical.x
        }

        function zt(d, e) {
          const a = d.feature,
            c = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = c
        }

        function Mt(d, e, a) {
          return l._(this, void 0, void 0, (function*() {
            let c = d;
            if (d.url ? c = (yield l.j(e.transformRequest(d.url, "Source"), a)).data : yield se.frameAsync(a), !c) return null;
            const h = l.S(l.e(c, d), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in c && c.vector_layers && (h.vectorLayerIds = c.vector_layers.map((f => f.id))), h
          }))
        }
        class kt {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof l.U ? new l.U(e.lng, e.lat) : l.U.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof l.U ? new l.U(e.lng, e.lat) : l.U.convert(e), this
          }
          extend(e) {
            const a = this._sw,
              c = this._ne;
            let h, f;
            if (e instanceof l.U) h = e, f = e;
            else {
              if (!(e instanceof kt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(kt.convert(e)) : this.extend(l.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(l.U.convert(e)) : this;
              if (h = e._sw, f = e._ne, !h || !f) return this
            }
            return a || c ? (a.lng = Math.min(h.lng, a.lng), a.lat = Math.min(h.lat, a.lat), c.lng = Math.max(f.lng, c.lng), c.lat = Math.max(f.lat, c.lat)) : (this._sw = new l.U(h.lng, h.lat), this._ne = new l.U(f.lng, f.lat)), this
          }
          getCenter() {
            return new l.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new l.U(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new l.U(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: a,
              lat: c
            } = l.U.convert(e);
            let h = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (h = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && h
          }
          intersects(e) {
            if ((e = kt.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const a = l.V(this.getWest(), -180, 180),
              c = l.V(this.getEast(), -180, 180),
              h = l.V(e.getWest(), -180, 180),
              f = l.V(e.getEast(), -180, 180),
              v = a > c,
              w = h > f;
            return !(!v || !w) || (v ? f >= a || h <= c : w ? c >= h || a <= f : !(h > c || f < a))
          }
          static convert(e) {
            return e instanceof kt ? e : e && new kt(e)
          }
          static fromLngLat(e, a = 0) {
            const c = 360 * a / 40075017,
              h = c / Math.cos(Math.PI / 180 * e.lat);
            return new kt(new l.U(e.lng - h, e.lat - c), new l.U(e.lng + h, e.lat + c))
          }
          adjustAntiMeridian() {
            const e = new l.U(this._sw.lng, this._sw.lat),
              a = new l.U(this._ne.lng, this._ne.lat);
            return new kt(e, e.lng > a.lng ? new l.U(a.lng + 360, a.lat) : a)
          }
        }
        class It {
          constructor(e, a, c) {
            this.bounds = kt.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = c || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const a = Math.pow(2, e.z),
              c = Math.floor(l.X(this.bounds.getWest()) * a),
              h = Math.floor(l.W(this.bounds.getNorth()) * a),
              f = Math.ceil(l.X(this.bounds.getEast()) * a),
              v = Math.ceil(l.W(this.bounds.getSouth()) * a);
            return e.x >= c && e.x < f && e.y >= h && e.y < v
          }
        }
        class Gt extends l.E {
          constructor(e, a, c, h) {
            if (super(), this.id = e, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, l.e(this, l.S(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = l.e({
                type: "vector"
              }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(h)
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new l.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield Mt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (l.e(this, e), e.bounds && (this.tileBounds = new It(e.bounds, this.minzoom, this.maxzoom)), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new l.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return l.e({}, this._options)
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                c = {
                  request: this.map._requestManager.transformRequest(a, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                };
              c.request.collectResourceTiming = this._collectResourceTiming;
              let h = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((f, v) => {
                  e.reloadPromise = {
                    resolve: f,
                    reject: v
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), h = "LT";
              e.abortController = new AbortController;
              try {
                const f = yield e.actor.sendAsync({
                  type: h,
                  data: c
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, f)
              } catch (f) {
                if (delete e.abortController, e.aborted) return;
                if (f && f.status !== 404) throw f;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const c = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(c.resolve).catch(c.reject)
            }
          }
          abortTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class ht extends l.E {
          constructor(e, a, c, h) {
            super(), this.id = e, this.dispatcher = c, this.setEventedParent(h), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = l.e({
              type: "raster"
            }, a), l.e(this, l.S(a, ["url", "scheme", "tileSize"]))
          }
          load() {
            return l._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new l.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const a = yield Mt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, a && (l.e(this, a), a.bounds && (this.tileBounds = new It(a.bounds, this.minzoom, this.maxzoom)), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new l.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new l.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return l.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const c = yield Ye.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (c && c.data) {
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({
                    cacheControl: c.cacheControl,
                    expires: c.expires
                  });
                  const h = this.map.painter.context,
                    f = h.gl,
                    v = c.data;
                  e.texture = this.map.painter.getTileTexture(v.width), e.texture ? e.texture.update(v, {
                    useMipmap: !0
                  }) : (e.texture = new l.T(h, v, f.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE, f.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c
              }
            }))
          }
          abortTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class hr extends ht {
          constructor(e, a, c, h) {
            super(e, a, c, h), this.type = "raster-dem", this.maxzoom = 22, this._options = l.e({
              type: "raster-dem"
            }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                c = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const h = yield Ye.getImage(c, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (h && h.data) {
                  const f = h.data;
                  this.map._refreshExpiredTiles && (h.cacheControl || h.expires) && e.setExpiryData({
                    cacheControl: h.cacheControl,
                    expires: h.expires
                  });
                  const v = l.b(f) && l.Y() ? f : yield this.readImageNow(f), w = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: v,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const T = yield e.actor.sendAsync({
                      type: "LDT",
                      data: w
                    });
                    e.dem = T, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (h) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (h) throw e.state = "errored", h
              }
            }))
          }
          readImageNow(e) {
            return l._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && l.Z()) {
                const a = e.width + 2,
                  c = e.height + 2;
                try {
                  return new l.R({
                    width: a,
                    height: c
                  }, yield l.$(e, -1, -1, a, c))
                } catch {}
              }
              return se.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const a = e.canonical,
              c = Math.pow(2, a.z),
              h = (a.x - 1 + c) % c,
              f = a.x === 0 ? e.wrap - 1 : e.wrap,
              v = (a.x + 1 + c) % c,
              w = a.x + 1 === c ? e.wrap + 1 : e.wrap,
              T = {};
            return T[new l.a0(e.overscaledZ, f, a.z, h, a.y).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, w, a.z, v, a.y).key] = {
              backfilled: !1
            }, a.y > 0 && (T[new l.a0(e.overscaledZ, f, a.z, h, a.y - 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, w, a.z, v, a.y - 1).key] = {
              backfilled: !1
            }), a.y + 1 < c && (T[new l.a0(e.overscaledZ, f, a.z, h, a.y + 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = {
              backfilled: !1
            }, T[new l.a0(e.overscaledZ, w, a.z, v, a.y + 1).key] = {
              backfilled: !1
            }), T
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }

        function wr(d) {
          return d.type === "GeometryCollection" ? d.geometries.map((e => e.coordinates)).flat(1 / 0) : d.coordinates.flat(1 / 0)
        }

        function ur(d) {
          const e = new kt;
          let a;
          switch (d.type) {
            case "FeatureCollection":
              a = d.features.map((c => wr(c.geometry))).flat(1 / 0);
              break;
            case "Feature":
              a = wr(d.geometry);
              break;
            default:
              a = wr(d)
          }
          if (a.length == 0) return e;
          for (let c = 0; c < a.length - 1; c += 2) e.extend([a[c], a[c + 1]]);
          return e
        }
        class qr extends l.E {
          constructor(e, a, c, h) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: a.data
            }, this.actor = c.getActor(), this.setEventedParent(h), this._data = a.data, this._options = l.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && l.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = l.e({
              source: this.id,
              cluster: a.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128),
                tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : .375),
                extent: l.a3,
                maxZoom: this.maxzoom,
                lineMetrics: a.lineMetrics || !1,
                generateId: a.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom),
                minPoints: Math.max(2, a.clusterMinPoints || 2),
                extent: l.a3,
                radius: this._pixelsToTileUnits(a.clusterRadius || 50),
                log: !1,
                generateId: a.generateId || !1
              },
              clusterProperties: a.clusterProperties,
              filter: a.filter
            }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged
          }
          _pixelsToTileUnits(e) {
            return e * (l.a3 / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || l.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = l.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return l._(this, void 0, void 0, (function*() {
              const e = l.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getBounds() {
            return l._(this, void 0, void 0, (function*() {
              return ur(yield this.getData())
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, a, c) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: a,
                offset: c
              }
            })
          }
          _updateWorkerData() {
            return l._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void l.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const {
                data: e,
                diff: a
              } = this._pendingWorkerUpdate, c = l.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (c.request = this.map._requestManager.transformRequest(se.resolveURL(e), "Source"), c.request.collectResourceTiming = this._collectResourceTiming) : c.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (c.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new l.l("dataloading", {
                dataType: "source"
              }));
              try {
                const h = yield this.actor.sendAsync({
                  type: "LD",
                  data: c
                });
                if (this._isUpdatingWorker = !1, this._removed || h.abandoned) return void this.fire(new l.l("dataabort", {
                  dataType: "source"
                }));
                this._data = h.data;
                let f = null;
                h.resourceTiming && h.resourceTiming[this.id] && (f = h.resourceTiming[this.id].slice(0));
                const v = {
                  dataType: "source"
                };
                this._collectResourceTiming && f && f.length > 0 && l.e(v, {
                  resourceTiming: f
                }), this.fire(new l.l("data", Object.assign(Object.assign({}, v), {
                  sourceDataType: "metadata"
                }))), this.fire(new l.l("data", Object.assign(Object.assign({}, v), {
                  sourceDataType: "content",
                  shouldReloadTileOptions: this._getShouldReloadTileOptions(a)
                })))
              } catch (h) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new l.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new l.k(h))
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData()
              }
            }))
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const {
              add: a = [],
              update: c = [],
              remove: h = []
            } = e || {}, f = new Set([...c.map((v => v.id)), ...h]);
            return {
              nextBounds: [...c.map((v => v.newGeometry)), ...a.map((v => v.geometry))].map((v => ur(v))),
              prevIds: f
            }
          }
          shouldReloadTile(e, {
            nextBounds: a,
            prevIds: c
          }) {
            const h = e.latestFeatureIndex.loadVTLayers();
            for (let T = 0; T < e.latestFeatureIndex.featureIndexArray.length; T++) {
              const C = e.latestFeatureIndex.featureIndexArray.get(T),
                A = h._geojsonTileLayer.feature(C.featureIndex);
              if (c.has(A.id)) return !0
            }
            const {
              buffer: f,
              extent: v
            } = this.workerOptions.geojsonVtOptions, w = (function({
              x: T,
              y: C,
              z: A
            }, j = 0) {
              const R = l.a1((T - j) / Math.pow(2, A)),
                Z = l.a2((C + 1 + j) / Math.pow(2, A)),
                Y = l.a1((T + 1 + j) / Math.pow(2, A)),
                oe = l.a2((C - j) / Math.pow(2, A));
              return new kt([R, Z], [Y, oe])
            })(e.tileID.canonical, f / v);
            for (const T of a)
              if (w.intersects(T)) return !0;
            return !1
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const c = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
              };
              e.abortController = new AbortController;
              const h = yield this.actor.sendAsync({
                type: a,
                data: c
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(h, this.map.painter, a === "RT")
            }))
          }
          abortTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return l.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class kr extends l.E {
          constructor(e, a, c, h) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = c, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(h), this.options = a
          }
          load(e) {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new l.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const a = yield Ye.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading())
              } catch (a) {
                this._request = null, this._loaded = !0, this.fire(new l.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(l.a5.fromLngLat);
            var c;
            return this.tileID = (function(h) {
              const f = l.a6.fromPoints(h),
                v = f.width(),
                w = f.height(),
                T = Math.max(v, w),
                C = Math.max(0, Math.floor(-Math.log(T) / Math.LN2)),
                A = Math.pow(2, C);
              return new l.a8(C, Math.floor((f.minX + f.maxX) / 2 * A), Math.floor((f.minY + f.maxY) / 2 * A))
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map((h => this.tileID.getTilePoint(h)._round())), this.flippedWindingOrder = ((c = this.tileCoords)[1].x - c[0].x) * (c[2].y - c[0].y) - (c[1].y - c[0].y) * (c[2].x - c[0].x) < 0, this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture || (this.texture = new l.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = !1;
            for (const h in this.tiles) {
              const f = this.tiles[h];
              f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, c = !0)
            }
            c && this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return l._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: a,
              minY: c,
              maxX: h,
              maxY: f
            } = l.a6.fromPoints(e), v = {};
            for (let w = 0; w <= l.a7; w++) {
              const T = Math.pow(2, w),
                C = Math.floor(a * T),
                A = Math.floor(c * T),
                j = Math.floor(h * T),
                R = Math.floor(f * T);
              v[w] = {
                minTileX: C,
                minTileY: A,
                maxTileX: j,
                maxTileY: R
              }
            }
            return v
          }
        }
        class Zr extends kr {
          constructor(e, a, c, h) {
            super(e, a, c, h), this.roundZoom = !0, this.type = "video", this.options = a
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield l.a9(this.urls);
                if (this._loaded = !0, !a) return;
                this.video = a, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (a) {
                this.fire(new l.k(a))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new l.k(new l.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new l.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = !1;
            for (const h in this.tiles) {
              const f = this.tiles[h];
              f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, c = !0)
            }
            c && this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class Wr extends kr {
          constructor(e, a, c, h) {
            super(e, a, c, h), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some((f => !Array.isArray(f) || f.length !== 2 || f.some((v => typeof v != "number")))) || this.fire(new l.k(new l.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new l.k(new l.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new l.k(new l.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new l.k(new l.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new l.k(new l.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate
          }
          load() {
            return l._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new l.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context,
              c = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new l.T(a, this.canvas, c.RGBA, {
              premultiply: !0
            });
            let h = !1;
            for (const f in this.tiles) {
              const v = this.tiles[f];
              v.state !== "loaded" && (v.state = "loaded", v.texture = this.texture, h = !0)
            }
            h && this.fire(new l.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const tr = {},
          Hr = d => {
            switch (d) {
              case "geojson":
                return qr;
              case "image":
                return kr;
              case "raster":
                return ht;
              case "raster-dem":
                return hr;
              case "vector":
                return Gt;
              case "video":
                return Zr;
              case "canvas":
                return Wr
            }
            return tr[d]
          },
          sr = "RTLPluginLoaded";
        class de extends l.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Ut()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((a => {
              throw this.status = "error", a
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return l._(this, arguments, void 0, (function*(a, c = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = se.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!c) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return l._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new l.l(sr))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let O = null;

        function N() {
          return O || (O = new de), O
        }
        var X, re;
        (function(d) {
          d[d.Base = 0] = "Base", d[d.Parent = 1] = "Parent"
        })(X || (X = {})), (function(d) {
          d[d.Departing = 0] = "Departing", d[d.Incoming = 1] = "Incoming"
        })(re || (re = {}));
        class Q {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = l.ab(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade())
          }
          setCrossFadeLogic({
            fadingRole: e,
            fadingDirection: a,
            fadingParentID: c,
            fadeEndTime: h
          }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = a, this.fadingParentID = c, this.fadeEndTime = h
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = ge(), this.fadeEndTime = 0, this.fadeOpacity = 1
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, a, c) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(h, f) {
                const v = {};
                if (!f) return v;
                for (const w of h) {
                  const T = w.layerIds.map((C => f.getLayer(C))).filter(Boolean);
                  if (T.length !== 0) {
                    w.layers = T, w.stateDependentLayerIds && (w.stateDependentLayers = w.stateDependentLayerIds.map((C => T.filter((A => A.id === C))[0])));
                    for (const C of T) v[C.id] = w
                  }
                }
                return v
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = !1;
              for (const h in this.buckets) {
                const f = this.buckets[h];
                if (f instanceof l.ad) {
                  if (this.hasSymbolBuckets = !0, !c) break;
                  f.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const h in this.buckets) {
                  const f = this.buckets[h];
                  if (f instanceof l.ad && f.hasRTLText) {
                    this.hasRTLText = !0, N().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const h in this.buckets) {
                const f = this.buckets[h];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(h).queryRadius(f))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions
            } else this.collisionBoxArray = new l.ac
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const c in this.buckets) {
              const h = this.buckets[c];
              h.uploadPending() && h.upload(e)
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new l.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new l.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, a, c, h, f, v, w, T, C, A, j) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: h,
              cameraQueryGeometry: f,
              scale: v,
              tileSize: this.tileSize,
              pixelPosMatrix: A,
              transform: T,
              params: w,
              queryPadding: this.queryPadding * C,
              getElevation: j
            }, e, a, c) : {}
          }
          querySourceFeatures(e, a) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const h = c.loadVTLayers(),
              f = a && a.sourceLayer ? a.sourceLayer : "",
              v = h._geojsonTileLayer || h[f];
            if (!v) return;
            const w = l.ae(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState),
              {
                z: T,
                x: C,
                y: A
              } = this.tileID.canonical,
              j = {
                z: T,
                x: C,
                y: A
              };
            for (let R = 0; R < v.length; R++) {
              const Z = v.feature(R);
              if (w.needGeometry) {
                const le = l.af(Z, !0);
                if (!w.filter(new l.G(this.tileID.overscaledZ), le, this.tileID.canonical)) continue
              } else if (!w.filter(new l.G(this.tileID.overscaledZ), Z)) continue;
              const Y = c.getId(Z, f),
                oe = new l.ag(Z, T, C, A, Y);
              oe.tile = j, e.push(oe)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const c = l.ah(e.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let h = !1;
              if (this.expirationTime > c) h = !1;
              else if (a)
                if (this.expirationTime < a) h = !0;
                else {
                  const f = this.expirationTime - a;
                  f ? this.expirationTime = c + Math.max(f, 3e4) : h = !0
                }
              else h = !0;
              h ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const c = this.latestFeatureIndex.loadVTLayers();
            for (const h in this.buckets) {
              if (!a.style.hasLayer(h)) continue;
              const f = this.buckets[h],
                v = f.layers[0].sourceLayer || "_geojsonTileLayer",
                w = c[v],
                T = e[v];
              if (!w || !T || Object.keys(T).length === 0) continue;
              f.update(T, w, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const C = a && a.style && a.style.getLayer(h);
              C && (this.queryPadding = Math.max(this.queryPadding, C.queryRadius(f)))
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < ge()
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = ge() + e
          }
          setDependencies(e, a) {
            const c = {};
            for (const h of a) c[h] = !0;
            this.dependencies[e] = c
          }
          hasDependency(e, a) {
            for (const c of e) {
              const h = this.dependencies[c];
              if (h) {
                for (const f of a)
                  if (h[f]) return !0
              }
            }
            return !1
          }
        }
        class ue {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this
          }
          add(e, a, c) {
            const h = e.wrapped().key;
            this.data[h] === void 0 && (this.data[h] = []);
            const f = {
              value: a,
              timeout: void 0
            };
            if (c !== void 0 && (f.timeout = setTimeout((() => {
                this.remove(e, f)
              }), c)), this.data[h].push(f), this.order.push(h), this.order.length > this.max) {
              const v = this._getAndRemoveByKey(this.order[0]);
              v && this.onRemove(v)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const c = e.wrapped().key,
              h = a === void 0 ? 0 : this.data[c].indexOf(a),
              f = this.data[c][h];
            return this.data[c].splice(h, 1), f.timeout && clearTimeout(f.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(f.value), this.order.splice(this.order.indexOf(c), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a)
            }
            return this
          }
          filter(e) {
            const a = [];
            for (const c in this.data)
              for (const h of this.data[c]) e(h.value) || a.push(h);
            for (const c of a) this.remove(c.value.tileID, c)
          }
        }
        class ke {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, a, c) {
            const h = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][h] = this.stateChanges[e][h] || {}, l.e(this.stateChanges[e][h], c), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const f in this.state[e]) f !== h && (this.deletedStates[e][f] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][h] === null) {
              this.deletedStates[e][h] = {};
              for (const f in this.state[e][h]) c[f] || (this.deletedStates[e][h][f] = null)
            } else
              for (const f in c) this.deletedStates[e] && this.deletedStates[e][h] && this.deletedStates[e][h][f] === null && delete this.deletedStates[e][h][f]
          }
          removeFeatureState(e, a, c) {
            if (this.deletedStates[e] === null) return;
            const h = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, c && a !== void 0) this.deletedStates[e][h] !== null && (this.deletedStates[e][h] = this.deletedStates[e][h] || {}, this.deletedStates[e][h][c] = null);
            else if (a !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][h])
                for (c in this.deletedStates[e][h] = {}, this.stateChanges[e][h]) this.deletedStates[e][h][c] = null;
              else this.deletedStates[e][h] = null;
            else this.deletedStates[e] = null
          }
          getState(e, a) {
            const c = String(a),
              h = l.e({}, (this.state[e] || {})[c], (this.stateChanges[e] || {})[c]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const f = this.deletedStates[e][a];
              if (f === null) return {};
              for (const v in f) delete h[v]
            }
            return h
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a)
          }
          coalesceChanges(e, a) {
            const c = {};
            for (const h in this.stateChanges) {
              this.state[h] = this.state[h] || {};
              const f = {};
              for (const v in this.stateChanges[h]) this.state[h][v] || (this.state[h][v] = {}), l.e(this.state[h][v], this.stateChanges[h][v]), f[v] = this.state[h][v];
              c[h] = f
            }
            for (const h in this.deletedStates) {
              this.state[h] = this.state[h] || {};
              const f = {};
              if (this.deletedStates[h] === null)
                for (const v in this.state[h]) f[v] = {}, this.state[h][v] = {};
              else
                for (const v in this.deletedStates[h]) {
                  if (this.deletedStates[h][v] === null) this.state[h][v] = {};
                  else
                    for (const w of Object.keys(this.deletedStates[h][v])) delete this.state[h][v][w];
                  f[v] = this.state[h][v]
                }
              c[h] = c[h] || {}, l.e(c[h], f)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0)
              for (const h in e) e[h].setFeatureState(c, a)
          }
        }
        const xe = 89.25;

        function Ee(d, e) {
          const a = l.ai(e.lat, -l.aj, l.aj);
          return new l.P(l.X(e.lng) * d, l.W(a) * d)
        }

        function He(d, e) {
          return new l.a5(e.x / d, e.y / d).toLngLat()
        }

        function Be(d) {
          return d.cameraToCenterDistance * Math.min(.85 * Math.tan(l.ak(90 - d.pitch)), Math.tan(l.ak(xe - d.pitch)))
        }

        function ie(d, e) {
          const a = d.canonical,
            c = e / l.al(a.z),
            h = a.x + Math.pow(2, a.z) * d.wrap,
            f = l.am(new Float64Array(16));
          return l.N(f, f, [h * c, a.y * c, 0]), l.O(f, f, [c / l.a3, c / l.a3, 1]), f
        }

        function J(d, e, a, c, h) {
          const f = l.a5.fromLngLat(d, e),
            v = h * l.an(1, d.lat),
            w = v * Math.cos(l.ak(a)),
            T = Math.sqrt(v * v - w * w),
            C = T * Math.sin(l.ak(-c)),
            A = T * Math.cos(l.ak(-c));
          return new l.a5(f.x + C, f.y + A, f.z + w)
        }

        function Ve(d, e, a) {
          const c = e.intersectsFrustum(d);
          if (!a || c === 0) return c;
          const h = e.intersectsPlane(a);
          return h === 0 ? 0 : c === 2 && h === 2 ? 2 : 1
        }

        function rt(d, e, a) {
          let c = 0;
          const h = (a - e) / 10;
          for (let f = 0; f < 10; f++) c += h * Math.pow(Math.cos(e + (f + .5) / 10 * (a - e)), d);
          return c
        }

        function Ue(d, e) {
          return function(a, c, h, f, v) {
            const w = 2 * ((d - 1) / l.ao(Math.cos(l.ak(xe - v)) / Math.cos(l.ak(xe))) - 1),
              T = Math.acos(h / f),
              C = 2 * rt(w - 1, 0, l.ak(v / 2)),
              A = Math.min(l.ak(xe), T + l.ak(v / 2)),
              j = rt(w - 1, Math.min(A, T - l.ak(v / 2)), A),
              R = Math.atan(c / h),
              Z = Math.hypot(c, h);
            let Y = a;
            return Y += l.ao(f / Z / Math.max(.5, Math.cos(l.ak(v / 2)))), Y += w * l.ao(Math.cos(R)) / 2, Y -= l.ao(Math.max(1, j / C / e)) / 2, Y
          }
        }
        const ae = Ue(9.314, 3);

        function Ie(d, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(d.zoom + l.ao(d.tileSize / e.tileSize));
          return Math.max(0, a)
        }

        function $e(d, e) {
          const a = d.getCameraFrustum(),
            c = d.getClippingPlane(),
            h = d.screenPointToMercatorCoordinate(d.getCameraPoint()),
            f = l.a5.fromLngLat(d.center, d.elevation);
          h.z = f.z + Math.cos(d.pitchInRadians) * d.cameraToCenterDistance / d.worldSize;
          const v = d.getCoveringTilesDetailsProvider(),
            w = v.allowVariableZoom(d, e),
            T = Ie(d, e),
            C = e.minzoom || 0,
            A = e.maxzoom !== void 0 ? e.maxzoom : d.maxZoom,
            j = Math.min(Math.max(0, T), A),
            R = Math.pow(2, j),
            Z = [R * h.x, R * h.y, 0],
            Y = [R * f.x, R * f.y, 0],
            oe = Math.hypot(f.x - h.x, f.y - h.y),
            le = Math.abs(f.z - h.z),
            ce = Math.hypot(oe, le),
            me = Pe => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: Pe,
              fullyVisible: !1
            }),
            Se = [],
            fe = [];
          if (d.renderWorldCopies && v.allowWorldCopies())
            for (let Pe = 1; Pe <= 3; Pe++) Se.push(me(-Pe)), Se.push(me(Pe));
          for (Se.push(me(0)); Se.length > 0;) {
            const Pe = Se.pop(),
              Ae = Pe.x,
              ve = Pe.y;
            let Oe = Pe.fullyVisible;
            const ct = {
                x: Ae,
                y: ve,
                z: Pe.zoom
              },
              it = v.getTileBoundingVolume(ct, Pe.wrap, d.elevation, e);
            if (!Oe) {
              const cr = Ve(a, it, c);
              if (cr === 0) continue;
              Oe = cr === 2
            }
            const st = v.distanceToTile2d(h.x, h.y, ct, it);
            let ut = T;
            w && (ut = (e.calculateTileZoom || ae)(d.zoom + l.ao(d.tileSize / e.tileSize), st, le, ce, d.fov)), ut = (e.roundZoom ? Math.round : Math.floor)(ut), ut = Math.max(0, ut);
            const or = Math.min(ut, A);
            if (Pe.wrap = v.getWrap(f, ct, Pe.wrap), Pe.zoom >= or) {
              if (Pe.zoom < C) continue;
              const cr = j - Pe.zoom,
                Bt = Z[0] - .5 - (Ae << cr),
                Nr = Z[1] - .5 - (ve << cr),
                xn = e.reparseOverscaled ? Math.max(Pe.zoom, ut) : Pe.zoom;
              fe.push({
                tileID: new l.a0(Pe.zoom === A ? xn : Pe.zoom, Pe.wrap, Pe.zoom, Ae, ve),
                distanceSq: l.ap([Y[0] - .5 - Ae, Y[1] - .5 - ve]),
                tileDistanceToCamera: Math.sqrt(Bt * Bt + Nr * Nr)
              })
            } else
              for (let cr = 0; cr < 4; cr++) Se.push({
                zoom: Pe.zoom + 1,
                x: (Ae << 1) + cr % 2,
                y: (ve << 1) + (cr >> 1),
                wrap: Pe.wrap,
                fullyVisible: Oe
              })
          }
          return fe.sort(((Pe, Ae) => Pe.distanceSq - Ae.distanceSq)).map((Pe => Pe.tileID))
        }
        const dt = l.a6.fromPoints([new l.P(0, 0), new l.P(l.a3, l.a3)]);
        class Tt extends l.E {
          constructor(e, a, c) {
            super(), this.id = e, this.dispatcher = c, this.on("data", (h => this._dataHandler(h))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((h, f, v, w) => {
              const T = new(Hr(f.type))(h, f, v, w);
              if (T.id !== h) throw new Error(`Expected Source id to be ${h} instead of ${T.id}`);
              return T
            })(e, a, c, this), this._tiles = {}, this._cache = new ue(0, (h => this._unloadTile(h))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new ke, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          getState() {
            return this._state
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, a, c) {
            return l._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, c)
              } catch (h) {
                e.state = "errored", h.status !== 404 ? this._source.fire(new l.k(h, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new l.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const c = this._tiles[a];
              c.upload(e), c.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(pt).map((e => e.key))
          }
          getRenderableIds(e) {
            const a = [];
            for (const c in this._tiles) this._isIdRenderable(c, e) && a.push(this._tiles[c]);
            return e ? a.sort(((c, h) => {
              const f = c.tileID,
                v = h.tileID,
                w = new l.P(f.canonical.x, f.canonical.y)._rotate(-this.transform.bearingInRadians),
                T = new l.P(v.canonical.x, v.canonical.y)._rotate(-this.transform.bearingInRadians);
              return f.overscaledZ - v.overscaledZ || T.y - w.y || T.x - w.x
            })).map((c => c.tileID.key)) : a.map((c => c.tileID)).sort(pt).map((c => c.key))
          }
          hasRenderableParent(e) {
            const a = e.overscaledZ - 1;
            if (a >= this._source.minzoom) {
              const c = this.getLoadedTile(e.scaledTo(a));
              if (c) return this._isIdRenderable(c.tileID.key)
            }
            return !1
          }
          _isIdRenderable(e, a = !1) {
            var c;
            return (c = this._tiles[e]) === null || c === void 0 ? void 0 : c.isRenderable(a)
          }
          reload(e, a = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const c in this._tiles) a && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[c], a) || (e ? this._reloadTile(c, "expired") : this._tiles[c].state !== "errored" && this._reloadTile(c, "reloading"))
            }
          }
          _reloadTile(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = this._tiles[e];
              c && (c.state !== "loading" && (c.state = a), yield this._loadTile(c, e, a))
            }))
          }
          _tileLoaded(e, a, c) {
            e.timeAdded = ge(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), c === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new l.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let h = 0; h < a.length; h++) {
              const f = a[h];
              if (e.neighboringTiles && e.neighboringTiles[f]) {
                const v = this.getTileByID(f);
                c(e, v), c(v, e)
              }
            }

            function c(h, f) {
              h.needsHillshadePrepare = !0, h.needsTerrainPrepare = !0;
              let v = f.tileID.canonical.x - h.tileID.canonical.x;
              const w = f.tileID.canonical.y - h.tileID.canonical.y,
                T = Math.pow(2, h.tileID.canonical.z),
                C = f.tileID.key;
              v === 0 && w === 0 || Math.abs(w) > 1 || (Math.abs(v) > 1 && (Math.abs(v + T) === 1 ? v += T : Math.abs(v - T) === 1 && (v -= T)), f.dem && h.dem && (h.dem.backfillBorder(f.dem, v, w), h.neighboringTiles && h.neighboringTiles[C] && (h.neighboringTiles[C].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, a) {
            const c = Object.values(e),
              h = this._getLoadedDescendents(c),
              f = {};
            for (const v of c) {
              const w = h[v.key];
              if (!(w != null && w.length)) {
                f[v.key] = v;
                continue
              }
              const T = v.overscaledZ + Tt.maxUnderzooming,
                C = w.filter((R => R.tileID.overscaledZ <= T));
              if (!C.length) {
                f[v.key] = v;
                continue
              }
              const A = Math.min(...C.map((R => R.tileID.overscaledZ))),
                j = C.filter((R => R.tileID.overscaledZ === A)).map((R => R.tileID));
              for (const R of j) a[R.key] = R;
              this._areDescendentsComplete(j, A, v.overscaledZ) || (f[v.key] = v)
            }
            return f
          }
          _getLoadedDescendents(e) {
            var a;
            const c = {};
            for (const h in this._tiles) {
              const f = this._tiles[h];
              if (f.hasData())
                for (const v of e) f.tileID.isChildOf(v) && (c[a = v.key] || (c[a] = [])).push(f)
            }
            return c
          }
          _areDescendentsComplete(e, a, c) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === a : Math.pow(4, a - c) === e.length
          }
          getLoadedTile(e) {
            const a = this._tiles[e.key];
            return a != null && a.hasData() ? a : null
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1,
              c = Math.ceil(e.height / this._source.tileSize) + 1,
              h = Math.floor(a * c * (this._maxTileCacheZoomLevels === null ? l.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              f = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, h) : h;
            this._cache.setMaxSize(f)
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const c = {};
              for (const h in this._tiles) {
                const f = this._tiles[h];
                f.tileID = f.tileID.unwrapTo(f.tileID.wrap + a), c[f.tileID.key] = f
              }
              this._tiles = c, this._resetTileReloadTimers()
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let c;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? c = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((T => new l.a0(T.canonical.z, T.wrap, T.canonical.z, T.canonical.x, T.canonical.y))) : (c = $e(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: a,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (c = c.filter((T => this._source.hasTile(T))))) : c = [], this.usedForTerrain && (c = this._addTerrainIdealTiles(c));
            const h = c.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, h && this.fire(new l.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const f = Ie(e, this._source),
              v = this._updateRetainedTiles(c, f),
              w = St(this._source.type);
            w && this._rasterFadeDuration > 0 && !a && this._updateFadingTiles(c, v), w ? this._cleanUpRasterTiles(v) : this._cleanUpVectorTiles(v)
          }
          _cleanUpRasterTiles(e) {
            for (const a in this._tiles) e[a] || this._removeTile(a)
          }
          _cleanUpVectorTiles(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              e[a] ? c.clearSymbolFadeHold() : c.hasSymbolBuckets ? c.holdingForSymbolFade() ? c.symbolFadeFinished() && this._removeTile(a) : c.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(a)
            }
          }
          _addTerrainIdealTiles(e) {
            const a = [];
            for (const c of e)
              if (c.canonical.z > this._source.minzoom) {
                const h = c.scaledTo(c.canonical.z - 1);
                a.push(h);
                const f = c.scaledTo(Math.max(this._source.minzoom, Math.min(c.canonical.z, 5)));
                a.push(f)
              } return e.concat(a)
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, a) {
            var c;
            const h = {},
              f = {},
              v = Math.max(a - Tt.maxOverzooming, this._source.minzoom);
            let w = {};
            for (const T of e) {
              const C = this._addTile(T);
              h[T.key] = T, C.hasData() || (w[T.key] = T)
            }
            w = this._retainLoadedChildren(w, h);
            for (const T in w) {
              const C = w[T];
              let A = this._tiles[T],
                j = A == null ? void 0 : A.wasRequested();
              for (let R = C.overscaledZ - 1; R >= v; --R) {
                const Z = C.scaledTo(R);
                if (f[Z.key]) break;
                if (f[Z.key] = !0, A = this.getTile(Z), !A && j && (A = this._addTile(Z)), A) {
                  const Y = A.hasData();
                  if ((Y || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || j) && (h[Z.key] = Z), j = A.wasRequested(), Y) break
                }
              }
            }
            return h
          }
          _updateFadingTiles(e, a) {
            const c = ge(),
              h = l.aq(e);
            for (const f of e) {
              const v = this._tiles[f.key];
              v.fadingDirection !== re.Departing && v.fadeOpacity !== 0 || v.resetFadeLogic(), this._updateFadingAncestor(v, a, c) || this._updateFadingDescendents(v, a, c) || this._updateFadingEdge(v, h, c) || v.resetFadeLogic()
            }
          }
          _updateFadingAncestor(e, a, c) {
            if (!e.hasData()) return !1;
            const {
              tileID: h,
              fadingRole: f,
              fadingDirection: v,
              fadingParentID: w
            } = e;
            if (f === X.Base && v === re.Incoming && w) return a[w.key] = w, !0;
            const T = Math.max(h.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let C = h.overscaledZ - 1; C >= T; C--) {
              const A = h.scaledTo(C),
                j = this.getLoadedTile(A);
              if (j) return e.setCrossFadeLogic({
                fadingRole: X.Base,
                fadingDirection: re.Incoming,
                fadingParentID: j.tileID,
                fadeEndTime: c + this._rasterFadeDuration
              }), j.setCrossFadeLogic({
                fadingRole: X.Parent,
                fadingDirection: re.Departing,
                fadeEndTime: c + this._rasterFadeDuration
              }), a[A.key] = A, !0
            }
            return !1
          }
          _updateFadingDescendents(e, a, c) {
            if (!e.hasData()) return !1;
            const h = e.tileID.children(this._source.maxzoom);
            let f = this._updateFadingChildren(e, h, a, c);
            if (f) return !0;
            for (const v of h) {
              const w = v.children(this._source.maxzoom);
              this._updateFadingChildren(e, w, a, c) && (f = !0)
            }
            return f
          }
          _updateFadingChildren(e, a, c, h) {
            if (a[0].overscaledZ >= this._source.maxzoom) return !1;
            let f = !1;
            for (const v of a) {
              const w = this.getLoadedTile(v);
              if (!w) continue;
              const {
                fadingRole: T,
                fadingDirection: C,
                fadingParentID: A
              } = w;
              T === X.Base && C === re.Departing && A || (w.setCrossFadeLogic({
                fadingRole: X.Base,
                fadingDirection: re.Departing,
                fadingParentID: e.tileID,
                fadeEndTime: h + this._rasterFadeDuration
              }), e.setCrossFadeLogic({
                fadingRole: X.Parent,
                fadingDirection: re.Incoming,
                fadeEndTime: h + this._rasterFadeDuration
              })), c[v.key] = v, f = !0
            }
            return f
          }
          _updateFadingEdge(e, a, c) {
            const h = e.tileID;
            return !!e.selfFading || !e.hasData() && !!a.has(h) && (e.setSelfFadeLogic(c + this._rasterFadeDuration), !0)
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (a.resetFadeLogic(), this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null));
            const c = a;
            return a || (a = new Q(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, c || this._source.fire(new l.l("dataloading", {
              tile: a,
              coord: a.tileID,
              dataType: "source"
            })), a
          }
          _setTileReloadTimer(e, a) {
            this._clearTileReloadTimer(e);
            const c = a.getExpiryTimeout();
            c && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), c))
          }
          _clearTileReloadTimer(e) {
            const a = this._timers[e];
            a && (clearTimeout(a), delete this._timers[e])
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e])
          }
          refreshTiles(e) {
            for (const a in this._tiles)(this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some((c => c.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired")
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = !0, this._abortTile(a), this._unloadTile(a))))
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, a, c) {
            const h = [],
              f = this.transform;
            if (!f) return h;
            const v = f.getCoveringTilesDetailsProvider().allowWorldCopies(),
              w = c ? f.getCameraQueryGeometry(e) : e,
              T = Z => f.screenPointToMercatorCoordinate(Z, this.terrain),
              C = this.transformBbox(e, T, !v),
              A = this.transformBbox(w, T, !v),
              j = this.getIds(),
              R = l.a6.fromPoints(A);
            for (let Z = 0; Z < j.length; Z++) {
              const Y = this._tiles[j[Z]];
              if (Y.holdingForSymbolFade()) continue;
              const oe = v ? [Y.tileID] : [Y.tileID.unwrapTo(-1), Y.tileID.unwrapTo(0)],
                le = Math.pow(2, f.zoom - Y.tileID.overscaledZ),
                ce = a * Y.queryPadding * l.a3 / Y.tileSize / le;
              for (const me of oe) {
                const Se = R.map((fe => me.getTilePoint(new l.a5(fe.x, fe.y))));
                if (Se.expandBy(ce), Se.intersects(dt)) {
                  const fe = C.map((Ae => me.getTilePoint(Ae))),
                    Pe = A.map((Ae => me.getTilePoint(Ae)));
                  h.push({
                    tile: Y,
                    tileID: v ? me : me.unwrapTo(0),
                    queryGeometry: fe,
                    cameraQueryGeometry: Pe,
                    scale: le
                  })
                }
              }
            }
            return h
          }
          transformBbox(e, a, c) {
            let h = e.map(a);
            if (c) {
              const f = l.a6.fromPoints(e);
              f.shrinkBy(.001 * Math.min(f.width(), f.height()));
              const v = f.map(a);
              l.a6.fromPoints(h).covers(v) || (h = h.map((w => w.x > .5 ? new l.a5(w.x - 1, w.y, w.z) : w)))
            }
            return h
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map((c => this._tiles[c].tileID));
            return this.transform && this.transform.populateCache(a), a
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (St(this._source.type) && this._rasterFadeDuration > 0) {
              const e = ge();
              for (const a in this._tiles)
                if (this._tiles[a].fadeEndTime >= e) return !0
            }
            return !1
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e
          }
          setFeatureState(e, a, c) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, c)
          }
          removeFeatureState(e, a, c) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, c)
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a)
          }
          setDependencies(e, a, c) {
            const h = this._tiles[e];
            h && h.setDependencies(a, c)
          }
          reloadTilesForDependencies(e, a) {
            for (const c in this._tiles) this._tiles[c].hasDependency(e, a) && this._reloadTile(c, "reloading");
            this._cache.filter((c => !c.hasDependency(e, a)))
          }
        }

        function pt(d, e) {
          const a = Math.abs(2 * d.wrap) - +(d.wrap < 0),
            c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return d.overscaledZ - e.overscaledZ || c - a || e.canonical.y - d.canonical.y || e.canonical.x - d.canonical.x
        }

        function St(d) {
          return d === "raster" || d === "image" || d === "video"
        }
        Tt.maxOverzooming = 10, Tt.maxUnderzooming = 3;
        class qt {
          constructor(e, a) {
            this.reset(e, a)
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = l.ai(e, 0, 1);
            let a = 1,
              c = this._distances[a];
            const h = e * this.paddedLength + this.padding;
            for (; c < h && a < this._distances.length;) c = this._distances[++a];
            const f = a - 1,
              v = this._distances[f],
              w = c - v,
              T = w > 0 ? (h - v) / w : 0;
            return this.points[f].mult(1 - T).add(this.points[a].mult(T))
          }
        }

        function qe(d, e) {
          let a = !0;
          return d === "always" || d !== "never" && e !== "never" || (a = !1), a
        }
        class bt {
          constructor(e, a, c) {
            const h = this.boxCells = [],
              f = this.circleCells = [];
            this.xCellCount = Math.ceil(e / c), this.yCellCount = Math.ceil(a / c);
            for (let v = 0; v < this.xCellCount * this.yCellCount; v++) h.push([]), f.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, a, c, h, f) {
            this._forEachCell(a, c, h, f, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(h), this.bboxes.push(f)
          }
          insertCircle(e, a, c, h) {
            this._forEachCell(a - h, c - h, a + h, c + h, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(c), this.circles.push(h)
          }
          _insertBoxCell(e, a, c, h, f, v) {
            this.boxCells[f].push(v)
          }
          _insertCircleCell(e, a, c, h, f, v) {
            this.circleCells[f].push(v)
          }
          _query(e, a, c, h, f, v, w) {
            if (c < 0 || e > this.width || h < 0 || a > this.height) return [];
            const T = [];
            if (e <= 0 && a <= 0 && this.width <= c && this.height <= h) {
              if (f) return [{
                key: null,
                x1: e,
                y1: a,
                x2: c,
                y2: h
              }];
              for (let C = 0; C < this.boxKeys.length; C++) T.push({
                key: this.boxKeys[C],
                x1: this.bboxes[4 * C],
                y1: this.bboxes[4 * C + 1],
                x2: this.bboxes[4 * C + 2],
                y2: this.bboxes[4 * C + 3]
              });
              for (let C = 0; C < this.circleKeys.length; C++) {
                const A = this.circles[3 * C],
                  j = this.circles[3 * C + 1],
                  R = this.circles[3 * C + 2];
                T.push({
                  key: this.circleKeys[C],
                  x1: A - R,
                  y1: j - R,
                  x2: A + R,
                  y2: j + R
                })
              }
            } else this._forEachCell(e, a, c, h, this._queryCell, T, {
              hitTest: f,
              overlapMode: v,
              seenUids: {
                box: {},
                circle: {}
              }
            }, w);
            return T
          }
          query(e, a, c, h) {
            return this._query(e, a, c, h, !1, null)
          }
          hitTest(e, a, c, h, f, v) {
            return this._query(e, a, c, h, !0, f, v).length > 0
          }
          hitTestCircle(e, a, c, h, f) {
            const v = e - c,
              w = e + c,
              T = a - c,
              C = a + c;
            if (w < 0 || v > this.width || C < 0 || T > this.height) return !1;
            const A = [];
            return this._forEachCell(v, T, w, C, this._queryCellCircle, A, {
              hitTest: !0,
              overlapMode: h,
              circle: {
                x: e,
                y: a,
                radius: c
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, f), A.length > 0
          }
          _queryCell(e, a, c, h, f, v, w, T) {
            const {
              seenUids: C,
              hitTest: A,
              overlapMode: j
            } = w, R = this.boxCells[f];
            if (R !== null) {
              const Y = this.bboxes;
              for (const oe of R)
                if (!C.box[oe]) {
                  C.box[oe] = !0;
                  const le = 4 * oe,
                    ce = this.boxKeys[oe];
                  if (e <= Y[le + 2] && a <= Y[le + 3] && c >= Y[le + 0] && h >= Y[le + 1] && (!T || T(ce)) && (!A || !qe(j, ce.overlapMode)) && (v.push({
                      key: ce,
                      x1: Y[le],
                      y1: Y[le + 1],
                      x2: Y[le + 2],
                      y2: Y[le + 3]
                    }), A)) return !0
                }
            }
            const Z = this.circleCells[f];
            if (Z !== null) {
              const Y = this.circles;
              for (const oe of Z)
                if (!C.circle[oe]) {
                  C.circle[oe] = !0;
                  const le = 3 * oe,
                    ce = this.circleKeys[oe];
                  if (this._circleAndRectCollide(Y[le], Y[le + 1], Y[le + 2], e, a, c, h) && (!T || T(ce)) && (!A || !qe(j, ce.overlapMode))) {
                    const me = Y[le],
                      Se = Y[le + 1],
                      fe = Y[le + 2];
                    if (v.push({
                        key: ce,
                        x1: me - fe,
                        y1: Se - fe,
                        x2: me + fe,
                        y2: Se + fe
                      }), A) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, a, c, h, f, v, w, T) {
            const {
              circle: C,
              seenUids: A,
              overlapMode: j
            } = w, R = this.boxCells[f];
            if (R !== null) {
              const Y = this.bboxes;
              for (const oe of R)
                if (!A.box[oe]) {
                  A.box[oe] = !0;
                  const le = 4 * oe,
                    ce = this.boxKeys[oe];
                  if (this._circleAndRectCollide(C.x, C.y, C.radius, Y[le + 0], Y[le + 1], Y[le + 2], Y[le + 3]) && (!T || T(ce)) && !qe(j, ce.overlapMode)) return v.push(!0), !0
                }
            }
            const Z = this.circleCells[f];
            if (Z !== null) {
              const Y = this.circles;
              for (const oe of Z)
                if (!A.circle[oe]) {
                  A.circle[oe] = !0;
                  const le = 3 * oe,
                    ce = this.circleKeys[oe];
                  if (this._circlesCollide(Y[le], Y[le + 1], Y[le + 2], C.x, C.y, C.radius) && (!T || T(ce)) && !qe(j, ce.overlapMode)) return v.push(!0), !0
                }
            }
          }
          _forEachCell(e, a, c, h, f, v, w, T) {
            const C = this._convertToXCellCoord(e),
              A = this._convertToYCellCoord(a),
              j = this._convertToXCellCoord(c),
              R = this._convertToYCellCoord(h);
            for (let Z = C; Z <= j; Z++)
              for (let Y = A; Y <= R; Y++)
                if (f.call(this, e, a, c, h, this.xCellCount * Y + Z, v, w, T)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, a, c, h, f, v) {
            const w = h - e,
              T = f - a,
              C = c + v;
            return C * C > w * w + T * T
          }
          _circleAndRectCollide(e, a, c, h, f, v, w) {
            const T = (v - h) / 2,
              C = Math.abs(e - (h + T));
            if (C > T + c) return !1;
            const A = (w - f) / 2,
              j = Math.abs(a - (f + A));
            if (j > A + c) return !1;
            if (C <= T || j <= A) return !0;
            const R = C - T,
              Z = j - A;
            return R * R + Z * Z <= c * c
          }
        }

        function Jt(d, e, a) {
          const c = l.M();
          if (!d) {
            const {
              vecSouth: j,
              vecEast: R
            } = _r(e), Z = W();
            Z[0] = R[0], Z[1] = R[1], Z[2] = j[0], Z[3] = j[1], h = Z, (A = (v = (f = Z)[0]) * (C = f[3]) - (T = f[2]) * (w = f[1])) && (h[0] = C * (A = 1 / A), h[1] = -w * A, h[2] = -T * A, h[3] = v * A), c[0] = Z[0], c[1] = Z[1], c[4] = Z[2], c[5] = Z[3]
          }
          var h, f, v, w, T, C, A;
          return l.O(c, c, [1 / a, 1 / a, 1]), c
        }

        function Cr(d, e, a, c) {
          if (d) {
            const h = l.M();
            if (!e) {
              const {
                vecSouth: f,
                vecEast: v
              } = _r(a);
              h[0] = v[0], h[1] = v[1], h[4] = f[0], h[5] = f[1]
            }
            return l.O(h, h, [c, c, 1]), h
          }
          return a.pixelsToClipSpaceMatrix
        }

        function _r(d) {
          const e = Math.cos(d.rollInRadians),
            a = Math.sin(d.rollInRadians),
            c = Math.cos(d.pitchInRadians),
            h = Math.cos(d.bearingInRadians),
            f = Math.sin(d.bearingInRadians),
            v = l.av();
          v[0] = -h * c * a - f * e, v[1] = -f * c * a + h * e;
          const w = l.aw(v);
          w < 1e-9 ? l.ax(v) : l.ay(v, v, 1 / w);
          const T = l.av();
          T[0] = h * c * e - f * a, T[1] = f * c * e + h * a;
          const C = l.aw(T);
          return C < 1e-9 ? l.ax(T) : l.ay(T, T, 1 / C), {
            vecEast: T,
            vecSouth: v
          }
        }

        function Qe(d, e, a, c) {
          let h;
          c ? (h = [d, e, c(d, e), 1], l.aA(h, h, a)) : (h = [d, e, 0, 1], jr(h, h, a));
          const f = h[3];
          return {
            point: new l.P(h[0] / f, h[1] / f),
            signedDistanceFromCamera: f,
            isOccluded: !1
          }
        }

        function rr(d, e) {
          return .5 + d / e * .5
        }

        function Kt(d, e) {
          return d.x >= -e[0] && d.x <= e[0] && d.y >= -e[1] && d.y <= e[1]
        }

        function Tr(d, e, a, c, h, f, v, w, T, C, A, j, R) {
          const Z = a ? d.textSizeData : d.iconSizeData,
            Y = l.ar(Z, e.transform.zoom),
            oe = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            le = a ? d.text.dynamicLayoutVertexArray : d.icon.dynamicLayoutVertexArray;
          le.clear();
          const ce = d.lineVertexArray,
            me = a ? d.text.placedSymbolArray : d.icon.placedSymbolArray,
            Se = e.transform.width / e.transform.height;
          let fe = !1;
          for (let Pe = 0; Pe < me.length; Pe++) {
            const Ae = me.get(Pe);
            if (Ae.hidden || Ae.writingMode === l.as.vertical && !fe) {
              Jr(Ae.numGlyphs, le);
              continue
            }
            fe = !1;
            const ve = new l.P(Ae.anchorX, Ae.anchorY),
              Oe = {
                getElevation: R,
                pitchedLabelPlaneMatrix: c,
                lineVertexArray: ce,
                pitchWithMap: f,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: ve,
                unwrappedTileID: T,
                width: C,
                height: A,
                translation: j
              },
              ct = Wt(Ae.anchorX, Ae.anchorY, Oe);
            if (!Kt(ct.point, oe)) {
              Jr(Ae.numGlyphs, le);
              continue
            }
            const it = rr(e.transform.cameraToCenterDistance, ct.signedDistanceFromCamera),
              st = l.at(Z, Y, Ae),
              ut = f ? st * e.transform.getPitchedTextCorrection(Ae.anchorX, Ae.anchorY, T) / it : st * it,
              or = br({
                projectionContext: Oe,
                pitchedLabelPlaneMatrixInverse: h,
                symbol: Ae,
                fontSize: ut,
                flip: !1,
                keepUpright: v,
                glyphOffsetArray: d.glyphOffsetArray,
                dynamicLayoutVertexArray: le,
                aspectRatio: Se,
                rotateToLine: w
              });
            fe = or.useVertical, (or.notEnoughRoom || fe || or.needsFlipping && br({
              projectionContext: Oe,
              pitchedLabelPlaneMatrixInverse: h,
              symbol: Ae,
              fontSize: ut,
              flip: !0,
              keepUpright: v,
              glyphOffsetArray: d.glyphOffsetArray,
              dynamicLayoutVertexArray: le,
              aspectRatio: Se,
              rotateToLine: w
            }).notEnoughRoom) && Jr(Ae.numGlyphs, le)
          }
          a ? d.text.dynamicLayoutVertexBuffer.updateData(le) : d.icon.dynamicLayoutVertexBuffer.updateData(le)
        }

        function Rr(d, e, a, c, h, f, v, w) {
          const T = f.glyphStartIndex + f.numGlyphs,
            C = f.lineStartIndex,
            A = f.lineStartIndex + f.lineLength,
            j = e.getoffsetX(f.glyphStartIndex),
            R = e.getoffsetX(T - 1),
            Z = ar(d * j, a, c, h, f.segment, C, A, w, v);
          if (!Z) return null;
          const Y = ar(d * R, a, c, h, f.segment, C, A, w, v);
          return Y ? w.projectionCache.anyProjectionOccluded ? null : {
            first: Z,
            last: Y
          } : null
        }

        function Qr(d, e, a, c) {
          return d === l.as.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * c ? {
            useVertical: !0
          } : (d === l.as.vertical ? e.y < a.y : e.x > a.x) ? {
            needsFlipping: !0
          } : null
        }

        function br(d) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: a,
            symbol: c,
            fontSize: h,
            flip: f,
            keepUpright: v,
            glyphOffsetArray: w,
            dynamicLayoutVertexArray: T,
            aspectRatio: C,
            rotateToLine: A
          } = d, j = h / 24, R = c.lineOffsetX * j, Z = c.lineOffsetY * j;
          let Y;
          if (c.numGlyphs > 1) {
            const oe = c.glyphStartIndex + c.numGlyphs,
              le = c.lineStartIndex,
              ce = c.lineStartIndex + c.lineLength,
              me = Rr(j, w, R, Z, f, c, A, e);
            if (!me) return {
              notEnoughRoom: !0
            };
            const Se = xt(me.first.point.x, me.first.point.y, e, a),
              fe = xt(me.last.point.x, me.last.point.y, e, a);
            if (v && !f) {
              const Pe = Qr(c.writingMode, Se, fe, C);
              if (Pe) return Pe
            }
            Y = [me.first];
            for (let Pe = c.glyphStartIndex + 1; Pe < oe - 1; Pe++) {
              const Ae = ar(j * w.getoffsetX(Pe), R, Z, f, c.segment, le, ce, e, A);
              if (!Ae) return {
                notEnoughRoom: !0
              };
              Y.push(Ae)
            }
            Y.push(me.last)
          } else {
            if (v && !f) {
              const le = Ge(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                ce = c.lineStartIndex + c.segment + 1,
                me = new l.P(e.lineVertexArray.getx(ce), e.lineVertexArray.gety(ce)),
                Se = Ge(me.x, me.y, e),
                fe = Se.signedDistanceFromCamera > 0 ? Se.point : Nt(e.tileAnchorPoint, me, le, 1, e),
                Pe = xt(le.x, le.y, e, a),
                Ae = xt(fe.x, fe.y, e, a),
                ve = Qr(c.writingMode, Pe, Ae, C);
              if (ve) return ve
            }
            const oe = ar(j * w.getoffsetX(c.glyphStartIndex), R, Z, f, c.segment, c.lineStartIndex, c.lineStartIndex + c.lineLength, e, A);
            if (!oe || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            Y = [oe]
          }
          for (const oe of Y) l.az(T, oe.point, oe.angle);
          return {}
        }

        function Nt(d, e, a, c, h) {
          const f = d.add(d.sub(e)._unit()),
            v = Ge(f.x, f.y, h).point,
            w = a.sub(v);
          return a.add(w._mult(c / w.mag()))
        }

        function wt(d, e, a) {
          const c = e.projectionCache;
          if (c.projections[d]) return c.projections[d];
          const h = new l.P(e.lineVertexArray.getx(d), e.lineVertexArray.gety(d)),
            f = Ge(h.x, h.y, e);
          if (f.signedDistanceFromCamera > 0) return c.projections[d] = f.point, c.anyProjectionOccluded = c.anyProjectionOccluded || f.isOccluded, f.point;
          const v = d - a.direction;
          return Nt(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new l.P(e.lineVertexArray.getx(v), e.lineVertexArray.gety(v)), h, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e)
        }

        function Ge(d, e, a) {
          const c = d + a.translation[0],
            h = e + a.translation[1];
          let f;
          return a.pitchWithMap ? (f = Qe(c, h, a.pitchedLabelPlaneMatrix, a.getElevation), f.isOccluded = !1) : (f = a.transform.projectTileCoordinates(c, h, a.unwrappedTileID, a.getElevation), f.point.x = (.5 * f.point.x + .5) * a.width, f.point.y = (.5 * -f.point.y + .5) * a.height), f
        }

        function xt(d, e, a, c) {
          if (a.pitchWithMap) {
            const h = [d, e, 0, 1];
            return l.aA(h, h, c), a.transform.projectTileCoordinates(h[0] / h[3], h[1] / h[3], a.unwrappedTileID, a.getElevation).point
          }
          return {
            x: d / a.width * 2 - 1,
            y: 1 - e / a.height * 2
          }
        }

        function Wt(d, e, a) {
          return a.transform.projectTileCoordinates(d, e, a.unwrappedTileID, a.getElevation)
        }

        function At(d, e, a) {
          return d._unit()._perp()._mult(e * a)
        }

        function pr(d, e, a, c, h, f, v, w, T) {
          if (w.projectionCache.offsets[d]) return w.projectionCache.offsets[d];
          const C = a.add(e);
          if (d + T.direction < c || d + T.direction >= h) return w.projectionCache.offsets[d] = C, C;
          const A = wt(d + T.direction, w, T),
            j = At(A.sub(a), v, T.direction),
            R = a.add(j),
            Z = A.add(j);
          return w.projectionCache.offsets[d] = l.aB(f, C, R, Z) || C, w.projectionCache.offsets[d]
        }

        function ar(d, e, a, c, h, f, v, w, T) {
          const C = c ? d - e : d + e;
          let A = C > 0 ? 1 : -1,
            j = 0;
          c && (A *= -1, j = Math.PI), A < 0 && (j += Math.PI);
          let R, Z = A > 0 ? f + h : f + h + 1;
          w.projectionCache.cachedAnchorPoint ? R = w.projectionCache.cachedAnchorPoint : (R = Ge(w.tileAnchorPoint.x, w.tileAnchorPoint.y, w).point, w.projectionCache.cachedAnchorPoint = R);
          let Y, oe, le = R,
            ce = R,
            me = 0,
            Se = 0;
          const fe = Math.abs(C),
            Pe = [];
          let Ae;
          for (; me + Se <= fe;) {
            if (Z += A, Z < f || Z >= v) return null;
            me += Se, ce = le, oe = Y;
            const ct = {
              absOffsetX: fe,
              direction: A,
              distanceFromAnchor: me,
              previousVertex: ce
            };
            if (le = wt(Z, w, ct), a === 0) Pe.push(ce), Ae = le.sub(ce);
            else {
              let it;
              const st = le.sub(ce);
              it = st.mag() === 0 ? At(wt(Z + A, w, ct).sub(le), a, A) : At(st, a, A), oe || (oe = ce.add(it)), Y = pr(Z, it, le, f, v, oe, a, w, ct), Pe.push(oe), Ae = Y.sub(oe)
            }
            Se = Ae.mag()
          }
          const ve = Ae._mult((fe - me) / Se)._add(oe || ce),
            Oe = j + Math.atan2(le.y - ce.y, le.x - ce.x);
          return Pe.push(ve), {
            point: ve,
            angle: T ? Oe : 0,
            path: Pe
          }
        }
        const zr = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function Jr(d, e) {
          for (let a = 0; a < d; a++) {
            const c = e.length;
            e.resize(c + 4), e.float32.set(zr, 3 * c)
          }
        }

        function jr(d, e, a) {
          const c = e[0],
            h = e[1];
          return d[0] = a[0] * c + a[4] * h + a[12], d[1] = a[1] * c + a[5] * h + a[13], d[3] = a[3] * c + a[7] * h + a[15], d
        }
        const Or = 100;
        class Fr {
          constructor(e, a = new bt(e.width + 200, e.height + 200, 25), c = new bt(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = c, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Or, this.screenBottomBoundary = e.height + Or, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, a, c, h, f, v, w, T, C, A, j, R) {
            const Z = this.projectAndGetPerspectiveRatio(e.anchorPointX + T[0], e.anchorPointY + T[1], f, A, R),
              Y = c * Z.perspectiveRatio;
            let oe;
            if (v || w) oe = this._projectCollisionBox(e, Y, h, f, v, w, T, Z, A, j, R);
            else {
              const Ae = Z.x + (j ? j.x * Y : 0),
                ve = Z.y + (j ? j.y * Y : 0);
              oe = {
                allPointsOccluded: !1,
                box: [Ae + e.x1 * Y, ve + e.y1 * Y, Ae + e.x2 * Y, ve + e.y2 * Y]
              }
            }
            const [le, ce, me, Se] = oe.box, fe = v ? oe.allPointsOccluded : Z.isOccluded;
            let Pe = fe;
            return Pe || (Pe = Z.perspectiveRatio < this.perspectiveRatioCutoff), Pe || (Pe = !this.isInsideGrid(le, ce, me, Se)), Pe || a !== "always" && this.grid.hitTest(le, ce, me, Se, a, C) ? {
              box: [le, ce, me, Se],
              placeable: !1,
              offscreen: !1,
              occluded: fe
            } : {
              box: [le, ce, me, Se],
              placeable: !0,
              offscreen: this.isOffscreen(le, ce, me, Se),
              occluded: fe
            }
          }
          placeCollisionCircles(e, a, c, h, f, v, w, T, C, A, j, R, Z, Y) {
            const oe = [],
              le = new l.P(a.anchorX, a.anchorY),
              ce = this.getPerspectiveRatio(le.x, le.y, v, Y),
              me = (C ? f * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, v) / ce : f * ce) / l.aF,
              Se = {
                getElevation: Y,
                pitchedLabelPlaneMatrix: w,
                lineVertexArray: c,
                pitchWithMap: C,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: le,
                unwrappedTileID: v,
                width: this.transform.width,
                height: this.transform.height,
                translation: Z
              },
              fe = Rr(me, h, a.lineOffsetX * me, a.lineOffsetY * me, !1, a, !1, Se);
            let Pe = !1,
              Ae = !1,
              ve = !0;
            if (fe) {
              const Oe = .5 * j * ce + R,
                ct = new l.P(-100, -100),
                it = new l.P(this.screenRightBoundary, this.screenBottomBoundary),
                st = new qt,
                ut = fe.first,
                or = fe.last;
              let cr = [];
              for (let xn = ut.path.length - 1; xn >= 1; xn--) cr.push(ut.path[xn]);
              for (let xn = 1; xn < or.path.length; xn++) cr.push(or.path[xn]);
              const Bt = 2.5 * Oe;
              if (C) {
                const xn = this.projectPathToScreenSpace(cr, Se);
                cr = xn.some((Xn => Xn.signedDistanceFromCamera <= 0)) ? [] : xn.map((Xn => Xn.point))
              }
              let Nr = [];
              if (cr.length > 0) {
                const xn = cr[0].clone(),
                  Xn = cr[0].clone();
                for (let zn = 1; zn < cr.length; zn++) xn.x = Math.min(xn.x, cr[zn].x), xn.y = Math.min(xn.y, cr[zn].y), Xn.x = Math.max(Xn.x, cr[zn].x), Xn.y = Math.max(Xn.y, cr[zn].y);
                Nr = xn.x >= ct.x && Xn.x <= it.x && xn.y >= ct.y && Xn.y <= it.y ? [cr] : Xn.x < ct.x || xn.x > it.x || Xn.y < ct.y || xn.y > it.y ? [] : l.aC([cr], ct.x, ct.y, it.x, it.y)
              }
              for (const xn of Nr) {
                st.reset(xn, .25 * Oe);
                let Xn = 0;
                Xn = st.length <= .5 * Oe ? 1 : Math.ceil(st.paddedLength / Bt) + 1;
                for (let zn = 0; zn < Xn; zn++) {
                  const ti = zn / Math.max(Xn - 1, 1),
                    mi = st.lerp(ti),
                    ni = mi.x + Or,
                    Ei = mi.y + Or;
                  oe.push(ni, Ei, Oe, 0);
                  const ci = ni - Oe,
                    Ui = Ei - Oe,
                    ui = ni + Oe,
                    Ci = Ei + Oe;
                  if (ve = ve && this.isOffscreen(ci, Ui, ui, Ci), Ae = Ae || this.isInsideGrid(ci, Ui, ui, Ci), e !== "always" && this.grid.hitTestCircle(ni, Ei, Oe, e, A) && (Pe = !0, !T)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: Pe
                  }
                }
              }
            }
            return {
              circles: !T && Pe || !Ae || ce < this.perspectiveRatioCutoff ? [] : oe,
              offscreen: ve,
              collisionDetected: Pe
            }
          }
          projectPathToScreenSpace(e, a) {
            const c = (function(h, f) {
              const v = l.M();
              return l.au(v, f.pitchedLabelPlaneMatrix), h.map((w => {
                const T = Qe(w.x, w.y, v, f.getElevation),
                  C = f.transform.projectTileCoordinates(T.point.x, T.point.y, f.unwrappedTileID, f.getElevation);
                return C.point.x = (.5 * C.point.x + .5) * f.width, C.point.y = (.5 * -C.point.y + .5) * f.height, C
              }))
            })(e, a);
            return (function(h) {
              let f = 0,
                v = 0,
                w = 0,
                T = 0;
              for (let C = 0; C < h.length; C++) h[C].isOccluded ? (w = C + 1, T = 0) : (T++, T > v && (v = T, f = w));
              return h.slice(f, f + v)
            })(c)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [],
              c = new l.a6;
            for (const j of e) {
              const R = new l.P(j.x + Or, j.y + Or);
              c.extend(R), a.push(R)
            }
            const {
              minX: h,
              minY: f,
              maxX: v,
              maxY: w
            } = c, T = this.grid.query(h, f, v, w).concat(this.ignoredGrid.query(h, f, v, w)), C = {}, A = {};
            for (const j of T) {
              const R = j.key;
              if (C[R.bucketInstanceId] === void 0 && (C[R.bucketInstanceId] = {}), C[R.bucketInstanceId][R.featureIndex]) continue;
              const Z = [new l.P(j.x1, j.y1), new l.P(j.x2, j.y1), new l.P(j.x2, j.y2), new l.P(j.x1, j.y2)];
              l.aD(a, Z) && (C[R.bucketInstanceId][R.featureIndex] = !0, A[R.bucketInstanceId] === void 0 && (A[R.bucketInstanceId] = []), A[R.bucketInstanceId].push(R.featureIndex))
            }
            return A
          }
          insertCollisionBox(e, a, c, h, f, v) {
            (c ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: h,
              featureIndex: f,
              collisionGroupID: v,
              overlapMode: a
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, a, c, h, f, v) {
            const w = c ? this.ignoredGrid : this.grid,
              T = {
                bucketInstanceId: h,
                featureIndex: f,
                collisionGroupID: v,
                overlapMode: a
              };
            for (let C = 0; C < e.length; C += 4) w.insertCircle(T, e[C], e[C + 1], e[C + 2])
          }
          projectAndGetPerspectiveRatio(e, a, c, h, f) {
            if (f) {
              let v;
              h ? (v = [e, a, h(e, a), 1], l.aA(v, v, f)) : (v = [e, a, 0, 1], jr(v, v, f));
              const w = v[3];
              return {
                x: (v[0] / w + 1) / 2 * this.transform.width + Or,
                y: (-v[1] / w + 1) / 2 * this.transform.height + Or,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / w * .5,
                isOccluded: !1,
                signedDistanceFromCamera: w
              }
            } {
              const v = this.transform.projectTileCoordinates(e, a, c, h);
              return {
                x: (v.point.x + 1) / 2 * this.transform.width + Or,
                y: (1 - v.point.y) / 2 * this.transform.height + Or,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / v.signedDistanceFromCamera * .5,
                isOccluded: v.isOccluded,
                signedDistanceFromCamera: v.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, a, c, h) {
            const f = this.transform.projectTileCoordinates(e, a, c, h);
            return .5 + this.transform.cameraToCenterDistance / f.signedDistanceFromCamera * .5
          }
          isOffscreen(e, a, c, h) {
            return c < Or || e >= this.screenRightBoundary || h < Or || a > this.screenBottomBoundary
          }
          isInsideGrid(e, a, c, h) {
            return c >= 0 && e < this.gridRightBoundary && h >= 0 && a < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = l.am([]);
            return l.N(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, a, c, h, f, v, w, T, C, A, j) {
            let R = 1,
              Z = 0,
              Y = 0,
              oe = 1;
            const le = e.anchorPointX + w[0],
              ce = e.anchorPointY + w[1];
            if (v && !f) {
              const cr = this.projectAndGetPerspectiveRatio(le + 1, ce, h, C, j),
                Bt = cr.x - T.x,
                Nr = Math.atan((cr.y - T.y) / Bt) + (Bt < 0 ? Math.PI : 0),
                xn = Math.sin(Nr),
                Xn = Math.cos(Nr);
              R = Xn, Z = xn, Y = -xn, oe = Xn
            } else if (!v && f) {
              const cr = _r(this.transform);
              R = cr.vecEast[0], Z = cr.vecEast[1], Y = cr.vecSouth[0], oe = cr.vecSouth[1]
            }
            let me = T.x,
              Se = T.y,
              fe = a;
            f && (me = le, Se = ce, fe = Math.pow(2, -(this.transform.zoom - c.overscaledZ)), fe *= this.transform.getPitchedTextCorrection(le, ce, h), A || (fe *= l.ai(.5 + T.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), A && (me += R * A.x * fe + Y * A.y * fe, Se += Z * A.x * fe + oe * A.y * fe);
            const Pe = e.x1 * fe,
              Ae = e.x2 * fe,
              ve = (Pe + Ae) / 2,
              Oe = e.y1 * fe,
              ct = e.y2 * fe,
              it = (Oe + ct) / 2,
              st = [{
                offsetX: Pe,
                offsetY: Oe
              }, {
                offsetX: ve,
                offsetY: Oe
              }, {
                offsetX: Ae,
                offsetY: Oe
              }, {
                offsetX: Ae,
                offsetY: it
              }, {
                offsetX: Ae,
                offsetY: ct
              }, {
                offsetX: ve,
                offsetY: ct
              }, {
                offsetX: Pe,
                offsetY: ct
              }, {
                offsetX: Pe,
                offsetY: it
              }];
            let ut = [];
            for (const {
                offsetX: cr,
                offsetY: Bt
              }
              of st) ut.push(new l.P(me + R * cr + Y * Bt, Se + Z * cr + oe * Bt));
            let or = !1;
            if (f) {
              const cr = ut.map((Bt => this.projectAndGetPerspectiveRatio(Bt.x, Bt.y, h, C, j)));
              or = cr.some((Bt => !Bt.isOccluded)), ut = cr.map((Bt => new l.P(Bt.x, Bt.y)))
            } else or = !0;
            return {
              box: l.aE(ut),
              allPointsOccluded: !or
            }
          }
        }
        class rn {
          constructor(e, a, c, h) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : h && c ? 1 : 0, this.placed = c
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class An {
          constructor(e, a, c, h, f) {
            this.text = new rn(e ? e.text : null, a, c, f), this.icon = new rn(e ? e.icon : null, a, h, f)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class kn {
          constructor(e, a, c) {
            this.text = e, this.icon = a, this.skipFade = c
          }
        }
        class Kr {
          constructor(e, a, c, h, f) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = c, this.bucketIndex = h, this.tileID = f
          }
        }
        class Ur {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: a,
                predicate: c => c.collisionGroupID === a
              }
            }
            return this.collisionGroups[e]
          }
        }

        function Cn(d, e, a, c, h) {
          const {
            horizontalAlign: f,
            verticalAlign: v
          } = l.aL(d);
          return new l.P(-(f - .5) * e + c[0] * h, -(v - .5) * a + c[1] * h)
        }
        class En {
          constructor(e, a, c, h, f) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new Fr(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = c, this.retainedQueryData = {}, this.collisionGroups = new Ur(h), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = f, f && (f.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (c, h) => a.getElevation(e, c, h) : null
          }
          getBucketParts(e, a, c, h) {
            const f = c.getBucket(a),
              v = c.latestFeatureIndex;
            if (!f || !v || a.id !== f.layerIds[0]) return;
            const w = c.collisionBoxArray,
              T = f.layers[0].layout,
              C = f.layers[0].paint,
              A = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ),
              j = c.tileSize / l.a3,
              R = c.tileID.toUnwrapped(),
              Z = T.get("text-rotation-alignment") === "map",
              Y = l.aG(c, 1, this.transform.zoom),
              oe = l.aH(this.collisionIndex.transform, c, C.get("text-translate"), C.get("text-translate-anchor")),
              le = l.aH(this.collisionIndex.transform, c, C.get("icon-translate"), C.get("icon-translate-anchor")),
              ce = Jt(Z, this.transform, Y);
            this.retainedQueryData[f.bucketInstanceId] = new Kr(f.bucketInstanceId, v, f.sourceLayerIndex, f.index, c.tileID);
            const me = {
              bucket: f,
              layout: T,
              translationText: oe,
              translationIcon: le,
              unwrappedTileID: R,
              pitchedLabelPlaneMatrix: ce,
              scale: A,
              textPixelRatio: j,
              holdingForFade: c.holdingForSymbolFade(),
              collisionBoxArray: w,
              partiallyEvaluatedTextSize: l.ar(f.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(f.sourceID)
            };
            if (h)
              for (const Se of f.sortKeyRanges) {
                const {
                  sortKey: fe,
                  symbolInstanceStart: Pe,
                  symbolInstanceEnd: Ae
                } = Se;
                e.push({
                  sortKey: fe,
                  symbolInstanceStart: Pe,
                  symbolInstanceEnd: Ae,
                  parameters: me
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: f.symbolInstances.length,
                parameters: me
              })
          }
          attemptAnchorPlacement(e, a, c, h, f, v, w, T, C, A, j, R, Z, Y, oe, le, ce, me, Se, fe) {
            const Pe = l.aI[e.textAnchor],
              Ae = [e.textOffset0, e.textOffset1],
              ve = Cn(Pe, c, h, Ae, f),
              Oe = this.collisionIndex.placeCollisionBox(a, R, T, C, A, w, v, le, j.predicate, Se, ve, fe);
            if ((!me || this.collisionIndex.placeCollisionBox(me, R, T, C, A, w, v, ce, j.predicate, Se, ve, fe).placeable) && Oe.placeable) {
              let ct;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[Z.crossTileID] && this.prevPlacement.placements[Z.crossTileID] && this.prevPlacement.placements[Z.crossTileID].text && (ct = this.prevPlacement.variableOffsets[Z.crossTileID].anchor), Z.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[Z.crossTileID] = {
                textOffset: Ae,
                width: c,
                height: h,
                anchor: Pe,
                textBoxScale: f,
                prevAnchor: ct
              }, this.markUsedJustification(Y, Pe, Z, oe), Y.allowVerticalPlacement && (this.markUsedOrientation(Y, oe, Z), this.placedOrientations[Z.crossTileID] = oe), {
                shift: ve,
                placedGlyphBoxes: Oe
              }
            }
          }
          placeLayerBucketPart(e, a, c) {
            const {
              bucket: h,
              layout: f,
              translationText: v,
              translationIcon: w,
              unwrappedTileID: T,
              pitchedLabelPlaneMatrix: C,
              textPixelRatio: A,
              holdingForFade: j,
              collisionBoxArray: R,
              partiallyEvaluatedTextSize: Z,
              collisionGroup: Y
            } = e.parameters, oe = f.get("text-optional"), le = f.get("icon-optional"), ce = l.aJ(f, "text-overlap", "text-allow-overlap"), me = ce === "always", Se = l.aJ(f, "icon-overlap", "icon-allow-overlap"), fe = Se === "always", Pe = f.get("text-rotation-alignment") === "map", Ae = f.get("text-pitch-alignment") === "map", ve = f.get("icon-text-fit") !== "none", Oe = f.get("symbol-z-order") === "viewport-y", ct = me && (fe || !h.hasIconData() || le), it = fe && (me || !h.hasTextData() || oe);
            !h.collisionArrays && R && h.deserializeCollisionBoxes(R);
            const st = this.retainedQueryData[h.bucketInstanceId].tileID,
              ut = this._getTerrainElevationFunc(st),
              or = this.transform.getFastPathSimpleProjectionMatrix(st),
              cr = (Bt, Nr, xn) => {
                var Xn, zn;
                if (a[Bt.crossTileID]) return;
                if (j) return void(this.placements[Bt.crossTileID] = new kn(!1, !1, !1));
                let ti = !1,
                  mi = !1,
                  ni = !0,
                  Ei = null,
                  ci = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Ui = {
                    placeable: !1
                  },
                  ui = null,
                  Ci = null,
                  ha = null,
                  Qo = 0,
                  _o = 0,
                  io = 0;
                Nr.textFeatureIndex ? Qo = Nr.textFeatureIndex : Bt.useRuntimeCollisionCircles && (Qo = Bt.featureIndex), Nr.verticalTextFeatureIndex && (_o = Nr.verticalTextFeatureIndex);
                const es = Nr.textBox;
                if (es) {
                  const da = zi => {
                      let ki = l.as.horizontal;
                      if (h.allowVerticalPlacement && !zi && this.prevPlacement) {
                        const Zi = this.prevPlacement.placedOrientations[Bt.crossTileID];
                        Zi && (this.placedOrientations[Bt.crossTileID] = Zi, ki = Zi, this.markUsedOrientation(h, ki, Bt))
                      }
                      return ki
                    },
                    mo = (zi, ki) => {
                      if (h.allowVerticalPlacement && Bt.numVerticalGlyphVertices > 0 && Nr.verticalTextBox) {
                        for (const Zi of h.writingModes)
                          if (Zi === l.as.vertical ? (ci = ki(), Ui = ci) : ci = zi(), ci && ci.placeable) break
                      } else ci = zi()
                    },
                    Io = Bt.textAnchorOffsetStartIndex,
                    ol = Bt.textAnchorOffsetEndIndex;
                  if (ol === Io) {
                    const zi = (ki, Zi) => {
                      const ai = this.collisionIndex.placeCollisionBox(ki, ce, A, st, T, Ae, Pe, v, Y.predicate, ut, void 0, or);
                      return ai && ai.placeable && (this.markUsedOrientation(h, Zi, Bt), this.placedOrientations[Bt.crossTileID] = Zi), ai
                    };
                    mo((() => zi(es, l.as.horizontal)), (() => {
                      const ki = Nr.verticalTextBox;
                      return h.allowVerticalPlacement && Bt.numVerticalGlyphVertices > 0 && ki ? zi(ki, l.as.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), da(ci && ci.placeable)
                  } else {
                    let zi = l.aI[(zn = (Xn = this.prevPlacement) === null || Xn === void 0 ? void 0 : Xn.variableOffsets[Bt.crossTileID]) === null || zn === void 0 ? void 0 : zn.anchor];
                    const ki = (ai, Wa, Co) => {
                      const Id = ai.x2 - ai.x1,
                        Cd = ai.y2 - ai.y1,
                        zd = Bt.textBoxScale,
                        rs = ve && Se === "never" ? Wa : null;
                      let ns = null,
                        Mu = ce === "never" ? 1 : 2,
                        ec = "never";
                      zi && Mu++;
                      for (let Iu = 0; Iu < Mu; Iu++) {
                        for (let go = Io; go < ol; go++) {
                          const zo = h.textAnchorOffsets.get(go);
                          if (zi && zo.textAnchor !== zi) continue;
                          const tc = this.attemptAnchorPlacement(zo, ai, Id, Cd, zd, Pe, Ae, A, st, T, Y, ec, Bt, h, Co, v, w, rs, ut);
                          if (tc && (ns = tc.placedGlyphBoxes, ns && ns.placeable)) return ti = !0, Ei = tc.shift, ns
                        }
                        zi ? zi = null : ec = ce
                      }
                      return c && !ns && (ns = {
                        box: this.collisionIndex.placeCollisionBox(es, "always", A, st, T, Ae, Pe, v, Y.predicate, ut, void 0, or).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), ns
                    };
                    mo((() => ki(es, Nr.iconBox, l.as.horizontal)), (() => {
                      const ai = Nr.verticalTextBox;
                      return h.allowVerticalPlacement && (!ci || !ci.placeable) && Bt.numVerticalGlyphVertices > 0 && ai ? ki(ai, Nr.verticalIconBox, l.as.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), ci && (ti = ci.placeable, ni = ci.offscreen);
                    const Zi = da(ci && ci.placeable);
                    if (!ti && this.prevPlacement) {
                      const ai = this.prevPlacement.variableOffsets[Bt.crossTileID];
                      ai && (this.variableOffsets[Bt.crossTileID] = ai, this.markUsedJustification(h, ai.anchor, Bt, Zi))
                    }
                  }
                }
                if (ui = ci, ti = ui && ui.placeable, ni = ui && ui.offscreen, Bt.useRuntimeCollisionCircles && Bt.centerJustifiedTextSymbolIndex >= 0) {
                  const da = h.text.placedSymbolArray.get(Bt.centerJustifiedTextSymbolIndex),
                    mo = l.at(h.textSizeData, Z, da),
                    Io = f.get("text-padding");
                  Ci = this.collisionIndex.placeCollisionCircles(ce, da, h.lineVertexArray, h.glyphOffsetArray, mo, T, C, c, Ae, Y.predicate, Bt.collisionCircleDiameter, Io, v, ut), Ci.circles.length && Ci.collisionDetected && !c && l.w("Collisions detected, but collision boxes are not shown"), ti = me || Ci.circles.length > 0 && !Ci.collisionDetected, ni = ni && Ci.offscreen
                }
                if (Nr.iconFeatureIndex && (io = Nr.iconFeatureIndex), Nr.iconBox) {
                  const da = mo => this.collisionIndex.placeCollisionBox(mo, Se, A, st, T, Ae, Pe, w, Y.predicate, ut, ve && Ei ? Ei : void 0, or);
                  Ui && Ui.placeable && Nr.verticalIconBox ? (ha = da(Nr.verticalIconBox), mi = ha.placeable) : (ha = da(Nr.iconBox), mi = ha.placeable), ni = ni && ha.offscreen
                }
                const zs = oe || Bt.numHorizontalGlyphVertices === 0 && Bt.numVerticalGlyphVertices === 0,
                  ts = le || Bt.numIconVertices === 0;
                zs || ts ? ts ? zs || (mi = mi && ti) : ti = mi && ti : mi = ti = mi && ti;
                const va = mi && ha.placeable;
                if (ti && ui.placeable && this.collisionIndex.insertCollisionBox(ui.box, ce, f.get("text-ignore-placement"), h.bucketInstanceId, Ui && Ui.placeable && _o ? _o : Qo, Y.ID), va && this.collisionIndex.insertCollisionBox(ha.box, Se, f.get("icon-ignore-placement"), h.bucketInstanceId, io, Y.ID), Ci && ti && this.collisionIndex.insertCollisionCircles(Ci.circles, ce, f.get("text-ignore-placement"), h.bucketInstanceId, Qo, Y.ID), c && this.storeCollisionData(h.bucketInstanceId, xn, Nr, ui, ha, Ci), Bt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (h.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[Bt.crossTileID] = new kn((ti || ct) && !(ui != null && ui.occluded), (mi || it) && !(ha != null && ha.occluded), ni || h.justReloaded), a[Bt.crossTileID] = !0
              };
            if (Oe) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Bt = h.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Nr = Bt.length - 1; Nr >= 0; --Nr) {
                const xn = Bt[Nr];
                cr(h.symbolInstances.get(xn), h.collisionArrays[xn], xn)
              }
            } else
              for (let Bt = e.symbolInstanceStart; Bt < e.symbolInstanceEnd; Bt++) cr(h.symbolInstances.get(Bt), h.collisionArrays[Bt], Bt);
            h.justReloaded = !1
          }
          storeCollisionData(e, a, c, h, f, v) {
            if (c.textBox || c.iconBox) {
              let w, T;
              this.collisionBoxArrays.has(e) ? w = this.collisionBoxArrays.get(e) : (w = new Map, this.collisionBoxArrays.set(e, w)), w.has(a) ? T = w.get(a) : (T = {
                text: null,
                icon: null
              }, w.set(a, T)), c.textBox && (T.text = h.box), c.iconBox && (T.icon = f.box)
            }
            if (v) {
              let w = this.collisionCircleArrays[e];
              w === void 0 && (w = this.collisionCircleArrays[e] = []);
              for (let T = 0; T < v.circles.length; T += 4) w.push(v.circles[T + 0] - Or), w.push(v.circles[T + 1] - Or), w.push(v.circles[T + 2]), w.push(v.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, a, c, h) {
            let f;
            f = h === l.as.vertical ? c.verticalPlacedTextSymbolIndex : {
              left: c.leftJustifiedTextSymbolIndex,
              center: c.centerJustifiedTextSymbolIndex,
              right: c.rightJustifiedTextSymbolIndex
            } [l.aK(a)];
            const v = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
            for (const w of v) w >= 0 && (e.text.placedSymbolArray.get(w).crossTileID = f >= 0 && w !== f ? 0 : c.crossTileID)
          }
          markUsedOrientation(e, a, c) {
            const h = a === l.as.horizontal || a === l.as.horizontalOnly ? a : 0,
              f = a === l.as.vertical ? a : 0,
              v = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
            for (const w of v) e.text.placedSymbolArray.get(w).placedOrientation = h;
            c.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = f)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let c = !1;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const h = a ? a.symbolFadeChange(e) : 1,
              f = a ? a.opacities : {},
              v = a ? a.variableOffsets : {},
              w = a ? a.placedOrientations : {};
            for (const T in this.placements) {
              const C = this.placements[T],
                A = f[T];
              A ? (this.opacities[T] = new An(A, h, C.text, C.icon), c = c || C.text !== A.text.placed || C.icon !== A.icon.placed) : (this.opacities[T] = new An(null, h, C.text, C.icon, C.skipFade), c = c || C.text || C.icon)
            }
            for (const T in f) {
              const C = f[T];
              if (!this.opacities[T]) {
                const A = new An(C, h, !1, !1);
                A.isHidden() || (this.opacities[T] = A, c = c || C.text.placed || C.icon.placed)
              }
            }
            for (const T in v) this.variableOffsets[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.variableOffsets[T] = v[T]);
            for (const T in w) this.placedOrientations[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.placedOrientations[T] = w[T]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            c ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, a) {
            const c = {};
            for (const h of a) {
              const f = h.getBucket(e);
              f && h.latestFeatureIndex && e.id === f.layerIds[0] && this.updateBucketOpacities(f, h.tileID, c, h.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, a, c, h) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const f = e.layers[0],
              v = f.layout,
              w = new An(null, 0, !1, !1, !0),
              T = v.get("text-allow-overlap"),
              C = v.get("icon-allow-overlap"),
              A = f._unevaluatedLayout.hasValue("text-variable-anchor") || f._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              j = v.get("text-rotation-alignment") === "map",
              R = v.get("text-pitch-alignment") === "map",
              Z = v.get("icon-text-fit") !== "none",
              Y = new An(null, 0, T && (C || !e.hasIconData() || v.get("icon-optional")), C && (T || !e.hasTextData() || v.get("text-optional")), !0);
            !e.collisionArrays && h && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(h);
            const oe = (ce, me, Se) => {
                for (let fe = 0; fe < me / 4; fe++) ce.opacityVertexArray.emplaceBack(Se);
                ce.hasVisibleVertices = ce.hasVisibleVertices || Se !== Kn
              },
              le = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ce = 0; ce < e.symbolInstances.length; ce++) {
              const me = e.symbolInstances.get(ce),
                {
                  numHorizontalGlyphVertices: Se,
                  numVerticalGlyphVertices: fe,
                  crossTileID: Pe
                } = me;
              let Ae = this.opacities[Pe];
              c[Pe] ? Ae = w : Ae || (Ae = Y, this.opacities[Pe] = Ae), c[Pe] = !0;
              const ve = me.numIconVertices > 0,
                Oe = this.placedOrientations[me.crossTileID],
                ct = Oe === l.as.vertical,
                it = Oe === l.as.horizontal || Oe === l.as.horizontalOnly;
              if (Se > 0 || fe > 0) {
                const ut = Si(Ae.text);
                oe(e.text, Se, ct ? Kn : ut), oe(e.text, fe, it ? Kn : ut);
                const or = Ae.text.isHidden();
                [me.rightJustifiedTextSymbolIndex, me.centerJustifiedTextSymbolIndex, me.leftJustifiedTextSymbolIndex].forEach((Nr => {
                  Nr >= 0 && (e.text.placedSymbolArray.get(Nr).hidden = or || ct ? 1 : 0)
                })), me.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(me.verticalPlacedTextSymbolIndex).hidden = or || it ? 1 : 0);
                const cr = this.variableOffsets[me.crossTileID];
                cr && this.markUsedJustification(e, cr.anchor, me, Oe);
                const Bt = this.placedOrientations[me.crossTileID];
                Bt && (this.markUsedJustification(e, "left", me, Bt), this.markUsedOrientation(e, Bt, me))
              }
              if (ve) {
                const ut = Si(Ae.icon),
                  or = !(Z && me.verticalPlacedIconSymbolIndex && ct);
                me.placedIconSymbolIndex >= 0 && (oe(e.icon, me.numIconVertices, or ? ut : Kn), e.icon.placedSymbolArray.get(me.placedIconSymbolIndex).hidden = Ae.icon.isHidden()), me.verticalPlacedIconSymbolIndex >= 0 && (oe(e.icon, me.numVerticalIconVertices, or ? Kn : ut), e.icon.placedSymbolArray.get(me.verticalPlacedIconSymbolIndex).hidden = Ae.icon.isHidden())
              }
              const st = le && le.has(ce) ? le.get(ce) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const ut = e.collisionArrays[ce];
                if (ut) {
                  let or = new l.P(0, 0);
                  if (ut.textBox || ut.verticalTextBox) {
                    let cr = !0;
                    if (A) {
                      const Bt = this.variableOffsets[Pe];
                      Bt ? (or = Cn(Bt.anchor, Bt.width, Bt.height, Bt.textOffset, Bt.textBoxScale), j && or._rotate(R ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : cr = !1
                    }
                    if (ut.textBox || ut.verticalTextBox) {
                      let Bt;
                      ut.textBox && (Bt = ct), ut.verticalTextBox && (Bt = it), Tn(e.textCollisionBox.collisionVertexArray, Ae.text.placed, !cr || Bt, st.text, or.x, or.y)
                    }
                  }
                  if (ut.iconBox || ut.verticalIconBox) {
                    const cr = !!(!it && ut.verticalIconBox);
                    let Bt;
                    ut.iconBox && (Bt = cr), ut.verticalIconBox && (Bt = !cr), Tn(e.iconCollisionBox.collisionVertexArray, Ae.icon.placed, Bt, st.icon, Z ? or.x : 0, Z ? or.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, a) {
            const c = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * c > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function Tn(d, e, a, c, h, f) {
          c && c.length !== 0 || (c = [0, 0, 0, 0]);
          const v = c[0] - Or,
            w = c[1] - Or,
            T = c[2] - Or,
            C = c[3] - Or;
          d.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, v, w), d.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, T, w), d.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, T, C), d.emplaceBack(e ? 1 : 0, a ? 1 : 0, h || 0, f || 0, v, C)
        }
        const Un = Math.pow(2, 25),
          Jn = Math.pow(2, 24),
          ft = Math.pow(2, 17),
          Ft = Math.pow(2, 16),
          Lr = Math.pow(2, 9),
          On = Math.pow(2, 8),
          Zn = Math.pow(2, 1);

        function Si(d) {
          if (d.opacity === 0 && !d.placed) return 0;
          if (d.opacity === 1 && d.placed) return 4294967295;
          const e = d.placed ? 1 : 0,
            a = Math.floor(127 * d.opacity);
          return a * Un + e * Jn + a * ft + e * Ft + a * Lr + e * On + a * Zn + e
        }
        const Kn = 0;
        class Nn {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, a, c, h, f) {
            const v = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (a.getBucketParts(v, h, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, f()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, v.sort(((w, T) => w.sortKey - T.sortKey))); this._currentPartIndex < v.length;)
              if (a.placeLayerBucketPart(v[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, f()) return !0;
            return !1
          }
        }
        class Ri {
          constructor(e, a, c, h, f, v, w, T) {
            this.placement = new En(e, a, v, w, T), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = f, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, a, c) {
            const h = ge(),
              f = () => !this._forceFullPlacement && ge() - h > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const v = a[e[this._currentPlacementIndex]],
                w = this.placement.collisionIndex.transform.zoom;
              if (v.type === "symbol" && (!v.minzoom || v.minzoom <= w) && (!v.maxzoom || v.maxzoom > w)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Nn(v)), this._inProgressLayer.continuePlacement(c[v.source], this.placement, this._showCollisionBoxes, v, f)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Br = 512 / l.a3 / 2;
        class Pr {
          constructor(e, a, c) {
            this.tileID = e, this.bucketInstanceId = c, this._symbolsByKey = {};
            const h = new Map;
            for (let f = 0; f < a.length; f++) {
              const v = a.get(f),
                w = v.key,
                T = h.get(w);
              T ? T.push(v) : h.set(w, [v])
            }
            for (const [f, v] of h) {
              const w = {
                positions: v.map((T => ({
                  x: Math.floor(T.anchorX * Br),
                  y: Math.floor(T.anchorY * Br)
                }))),
                crossTileIDs: v.map((T => T.crossTileID))
              };
              if (w.positions.length > 128) {
                const T = new l.aM(w.positions.length, 16, Uint16Array);
                for (const {
                    x: C,
                    y: A
                  }
                  of w.positions) T.add(C, A);
                T.finish(), delete w.positions, w.index = T
              }
              this._symbolsByKey[f] = w
            }
          }
          getScaledCoordinates(e, a) {
            const {
              x: c,
              y: h,
              z: f
            } = this.tileID.canonical, {
              x: v,
              y: w,
              z: T
            } = a.canonical, C = Br / Math.pow(2, T - f), A = (w * l.a3 + e.anchorY) * C, j = h * l.a3 * Br;
            return {
              x: Math.floor((v * l.a3 + e.anchorX) * C - c * l.a3 * Br),
              y: Math.floor(A - j)
            }
          }
          findMatches(e, a, c) {
            const h = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let f = 0; f < e.length; f++) {
              const v = e.get(f);
              if (v.crossTileID) continue;
              const w = this._symbolsByKey[v.key];
              if (!w) continue;
              const T = this.getScaledCoordinates(v, a);
              if (w.index) {
                const C = w.index.range(T.x - h, T.y - h, T.x + h, T.y + h).sort();
                for (const A of C) {
                  const j = w.crossTileIDs[A];
                  if (!c[j]) {
                    c[j] = !0, v.crossTileID = j;
                    break
                  }
                }
              } else if (w.positions)
                for (let C = 0; C < w.positions.length; C++) {
                  const A = w.positions[C],
                    j = w.crossTileIDs[C];
                  if (Math.abs(A.x - T.x) <= h && Math.abs(A.y - T.y) <= h && !c[j]) {
                    c[j] = !0, v.crossTileID = j;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class Dn {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class pn {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0)
              for (const c in this.indexes) {
                const h = this.indexes[c],
                  f = {};
                for (const v in h) {
                  const w = h[v];
                  w.tileID = w.tileID.unwrapTo(w.tileID.wrap + a), f[w.tileID.key] = w
                }
                this.indexes[c] = f
              }
            this.lng = e
          }
          addBucket(e, a, c) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let f = 0; f < a.symbolInstances.length; f++) a.symbolInstances.get(f).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const h = this.usedCrossTileIDs[e.overscaledZ];
            for (const f in this.indexes) {
              const v = this.indexes[f];
              if (Number(f) > e.overscaledZ)
                for (const w in v) {
                  const T = v[w];
                  T.tileID.isChildOf(e) && T.findMatches(a.symbolInstances, e, h)
                } else {
                  const w = v[e.scaledTo(Number(f)).key];
                  w && w.findMatches(a.symbolInstances, e, h)
                }
            }
            for (let f = 0; f < a.symbolInstances.length; f++) {
              const v = a.symbolInstances.get(f);
              v.crossTileID || (v.crossTileID = c.generate(), h[v.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Pr(e, a.symbolInstances, a.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, a) {
            for (const c of a.getCrossTileIDsLists())
              for (const h of c) delete this.usedCrossTileIDs[e][h]
          }
          removeStaleBuckets(e) {
            let a = !1;
            for (const c in this.indexes) {
              const h = this.indexes[c];
              for (const f in h) e[h[f].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, h[f]), delete h[f], a = !0)
            }
            return a
          }
        }
        class Ar {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Dn, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, a, c) {
            let h = this.layerIndexes[e.id];
            h === void 0 && (h = this.layerIndexes[e.id] = new pn);
            let f = !1;
            const v = {};
            h.handleWrapJump(c);
            for (const w of a) {
              const T = w.getBucket(e);
              T && e.id === T.layerIds[0] && (T.bucketInstanceId || (T.bucketInstanceId = ++this.maxBucketInstanceId), h.addBucket(w.tileID, T, this.crossTileIDs) && (f = !0), v[T.bucketInstanceId] = !0)
            }
            return h.removeStaleBuckets(v) && (f = !0), f
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach((c => {
              a[c] = !0
            }));
            for (const c in this.layerIndexes) a[c] || delete this.layerIndexes[c]
          }
        }
        var gn = "void main() {fragColor=vec4(1.0);}";
        const Ir = {
          prelude: tn(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: tn("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: tn("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: tn(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: tn(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: tn(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: tn(gn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: tn(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: tn(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: tn("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: tn("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: tn(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: tn("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: tn(gn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: tn(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: tn(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: tn(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: tn(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: tn(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: tn(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: tn(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: tn(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: tn(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: tn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: tn(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: tn(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          lineGradientSDF: tn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          raster: tn(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: tn(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: tn(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: tn(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: tn("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: tn("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: tn("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: tn("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: tn(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: tn("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function tn(d, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            c = e.match(/in ([\w]+) ([\w]+)/g),
            h = d.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            f = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            v = f ? f.concat(h) : h,
            w = {};
          return {
            fragmentSource: d = d.replace(a, ((T, C, A, j, R) => (w[R] = !0, C === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
in ${A} ${j} ${R};
#else
uniform ${A} ${j} u_${R};
#endif
` : `
#ifdef HAS_UNIFORM_u_${R}
    ${A} ${j} ${R} = u_${R};
#endif
`))),
            vertexSource: e = e.replace(a, ((T, C, A, j, R) => {
              const Z = j === "float" ? "vec2" : "vec4",
                Y = R.match(/color/) ? "color" : Z;
              return w[R] ? C === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${A} ${Z} a_${R};
out ${A} ${j} ${R};
#else
uniform ${A} ${j} u_${R};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = a_${R};
#else
    ${A} ${j} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = unpack_mix_${Y}(a_${R}, u_${R}_t);
#else
    ${A} ${j} ${R} = u_${R};
#endif
` : C === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${A} ${Z} a_${R};
#else
uniform ${A} ${j} u_${R};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${A} ${j} ${R} = a_${R};
#else
    ${A} ${j} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${A} ${j} ${R} = unpack_mix_${Y}(a_${R}, u_${R}_t);
#else
    ${A} ${j} ${R} = u_${R};
#endif
`
            })),
            staticAttributes: c,
            staticUniforms: v
          }
        }
        class Gn {
          constructor(e, a, c) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = c
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var qn = l.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const Ln = "#define PROJECTION_MERCATOR",
          Pn = "mercator";
        class Mn {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return Pn
          }
          get shaderDefine() {
            return Ln
          }
          get shaderPreludeCode() {
            return Ir.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return Ir.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return l.aO.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, a, c, h, f) {
            if (this._cachedMesh) return this._cachedMesh;
            const v = new l.aP;
            v.emplaceBack(0, 0), v.emplaceBack(l.a3, 0), v.emplaceBack(0, l.a3), v.emplaceBack(l.a3, l.a3);
            const w = e.createVertexBuffer(v, qn.members),
              T = l.aQ.simpleSegment(0, 0, 4, 2),
              C = new l.aR;
            C.emplaceBack(1, 0, 2), C.emplaceBack(1, 2, 3);
            const A = e.createIndexBuffer(C);
            return this._cachedMesh = new Gn(w, A, T), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class fn {
          constructor(e = 0, a = 0, c = 0, h = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(c) || c < 0 || isNaN(h) || h < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = c, this.right = h
          }
          interpolate(e, a, c) {
            return a.top != null && e.top != null && (this.top = l.F.number(e.top, a.top, c)), a.bottom != null && e.bottom != null && (this.bottom = l.F.number(e.bottom, a.bottom, c)), a.left != null && e.left != null && (this.left = l.F.number(e.left, a.left, c)), a.right != null && e.right != null && (this.right = l.F.number(e.right, a.right, c)), this
          }
          getCenter(e, a) {
            const c = l.ai((this.left + e - this.right) / 2, 0, e),
              h = l.ai((this.top + a - this.bottom) / 2, 0, a);
            return new l.P(c, h)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new fn(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function un(d, e) {
          if (!d.renderWorldCopies || d.lngRange) return;
          const a = e.lng - d.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0
        }

        function ia(d) {
          return Math.max(0, Math.floor(d))
        }
        class Wn {
          constructor(e, a) {
            var c;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (a == null ? void 0 : a.renderWorldCopies) === void 0 || !!(a != null && a.renderWorldCopies), this._minZoom = (a == null ? void 0 : a.minZoom) || 0, this._maxZoom = (a == null ? void 0 : a.maxZoom) || 22, this._minPitch = (a == null ? void 0 : a.minPitch) == null ? 0 : a == null ? void 0 : a.minPitch, this._maxPitch = (a == null ? void 0 : a.maxPitch) == null ? 60 : a == null ? void 0 : a.maxPitch, this._constrain = (c = a == null ? void 0 : a.constrain) !== null && c !== void 0 ? c : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new l.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = ia(this._zoom), this._scale = l.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new fn, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, a, c) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = ia(this._zoom), this._scale = l.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new fn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !c && e.autoCalculateNearFarZ, a && this.constrainInternal(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get constrain() {
            return this._constrain
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices()
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new l.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const a = l.V(e, -180, 180) * Math.PI / 180;
            var c, h, f, v, w, T, C, A, j;
            this._bearingInRadians !== a && (this._unmodified = !1, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = W(), c = this._rotationMatrix, f = -this._bearingInRadians, v = (h = this._rotationMatrix)[0], w = h[1], T = h[2], C = h[3], A = Math.sin(f), j = Math.cos(f), c[0] = v * j + T * A, c[1] = w * j + C * A, c[2] = v * -A + T * j, c[3] = w * -A + C * j)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const a = l.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = !1, this._pitchInRadians = a, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = !1, this._rollInRadians = a, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return l.aS(this._fovInRadians)
          }
          setFov(e) {
            e = l.ai(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = l.ak(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const a = this.constrain(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = !1, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = l.al(a), this.constrainInternal(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = a, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, a, c) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, a, c), this.constrainInternal(), this._calcMatrices()
          }
          resize(e, a, c = !0) {
            this._width = e, this._height = a, c && this.constrainInternal(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new kt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-l.aj, l.aj])
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const {
                minX: c,
                minY: h,
                maxX: f,
                maxY: v
              } = l.a6.fromPoints(a).extend(e);
              return [new l.P(c, h), new l.P(f, h), new l.P(f, v), new l.P(c, v), new l.P(c, h)]
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: a,
                zoom: c
              } = this.constrain(this.center, this.zoom);
            this.setCenter(a), this.setZoom(c), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = l.am(new Float64Array(16));
              l.O(e, e, [this._width / 2, -this._height / 2, 1]), l.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = l.am(new Float64Array(16)), l.O(e, e, [1, -1, 1]), l.N(e, e, [-1, -1, 0]), l.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            const f = c !== void 0 ? c : this.bearing,
              v = h = h !== void 0 ? h : this.pitch,
              w = l.a5.fromLngLat(e, a),
              T = -Math.cos(l.ak(v)),
              C = Math.sin(l.ak(v)),
              A = C * Math.sin(l.ak(f)),
              j = -C * Math.cos(l.ak(f));
            let R = this.elevation;
            const Z = a - R;
            let Y;
            T * Z >= 0 || Math.abs(T) < .1 ? (Y = 1e4, R = a + Y * T) : Y = -Z / T;
            let oe, le, ce = l.aT(1, w.y),
              me = 0;
            do {
              if (me += 1, me > 10) break;
              le = Y / ce, oe = new l.a5(w.x + A * le, w.y + j * le), ce = 1 / oe.meterInMercatorCoordinateUnits()
            } while (Math.abs(Y - le * ce) > 1e-12);
            return {
              center: oe.toLngLat(),
              elevation: R,
              zoom: l.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / le / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = l.an(1, this.center.lat) * this.worldSize,
              c = this.cameraToCenterDistance / a,
              h = l.a5.fromLngLat(this.center, this.elevation),
              f = J(this.center, this.elevation, this.pitch, this.bearing, c);
            this._elevation = e;
            const v = this.calculateCenterFromCameraLngLatAlt(f.toLngLat(), l.aT(f.z, h.y), this.bearing, this.pitch);
            this._elevation = v.elevation, this._center = v.center, this.setZoom(v.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new l.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = l.an(1, this.center.lat) * this.worldSize;
            return J(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / l.a3, 1 / a / l.a3]
          }
        }
        class ii {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = l.aU([], l.aV([], this.min, this.max), .5)
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2],
              c = l.aW(this.min),
              h = l.aW(this.max);
            for (let f = 0; f < a.length; f++) c[f] = a[f] ? this.min[f] : this.center[f], h[f] = a[f] ? this.center[f] : this.max[f];
            return h[2] = this.max[2], new ii(c, h)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let a = !0;
            for (let c = 0; c < e.planes.length; c++) {
              const h = this.intersectsPlane(e.planes[c]);
              if (h === 0) return 0;
              h === 1 && (a = !1)
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let a = e[3],
              c = e[3];
            for (let h = 0; h < 3; h++) e[h] > 0 ? (a += e[h] * this.min[h], c += e[h] * this.max[h]) : (c += e[h] * this.min[h], a += e[h] * this.max[h]);
            return a >= 0 ? 2 : c < 0 ? 0 : 1
          }
        }
        class li {
          distanceToTile2d(e, a, c, h) {
            const f = h.distanceX([e, a]),
              v = h.distanceY([e, a]);
            return Math.hypot(f, v)
          }
          getWrap(e, a, c) {
            return c
          }
          getTileBoundingVolume(e, a, c, h) {
            var f, v;
            let w = 0,
              T = 0;
            if (h != null && h.terrain) {
              const A = new l.a0(e.z, a, e.z, e.x, e.y),
                j = h.terrain.getMinMaxElevation(A);
              w = (f = j.minElevation) !== null && f !== void 0 ? f : Math.min(0, c), T = (v = j.maxElevation) !== null && v !== void 0 ? v : Math.max(0, c)
            }
            const C = 1 << e.z;
            return new ii([a + e.x / C, e.y / C, w], [a + (e.x + 1) / C, (e.y + 1) / C, T])
          }
          allowVariableZoom(e, a) {
            const c = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              h = l.ai(78.5 - c / 2, 0, 60);
            return !!a.terrain || e.pitch > h
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class ji {
          constructor(e, a, c) {
            this.points = e, this.planes = a, this.aabb = c
          }
          static fromInvProjectionMatrix(e, a = 1, c = 0, h, f) {
            const v = f ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              w = Math.pow(2, c),
              T = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((R => (function(Z, Y, oe, le) {
                const ce = l.aA([], Z, Y),
                  me = 1 / ce[3] / oe * le;
                return l.a$(ce, ce, [me, me, 1 / ce[3], me])
              })(R, e, a, w)));
            h && (function(R, Z, Y, oe) {
              const le = oe ? 4 : 0,
                ce = oe ? 0 : 4;
              let me = 0;
              const Se = [],
                fe = [];
              for (let ve = 0; ve < 4; ve++) {
                const Oe = l.aX([], R[ve + ce], R[ve + le]),
                  ct = l.b0(Oe);
                l.aU(Oe, Oe, 1 / ct), Se.push(ct), fe.push(Oe)
              }
              for (let ve = 0; ve < 4; ve++) {
                const Oe = l.b1(R[ve + le], fe[ve], Y);
                me = Oe !== null && Oe >= 0 ? Math.max(me, Oe) : Math.max(me, Se[ve])
              }
              const Pe = (function(ve, Oe) {
                  const ct = l.aX([], ve[Oe[0]], ve[Oe[1]]),
                    it = l.aX([], ve[Oe[2]], ve[Oe[1]]),
                    st = [0, 0, 0, 0];
                  return l.aY(st, l.aZ([], ct, it)), st[3] = -l.a_(st, ve[Oe[0]]), st
                })(R, Z),
                Ae = (function(ve, Oe) {
                  const ct = l.b2(ve),
                    it = l.b3([], ve, 1 / ct),
                    st = l.aX([], Oe, l.aU([], it, l.a_(Oe, it))),
                    ut = l.b2(st);
                  if (ut > 0) {
                    const or = Math.sqrt(1 - it[3] * it[3]),
                      cr = l.aU([], it, -it[3]),
                      Bt = l.aV([], cr, l.aU([], st, or / ut));
                    return l.b4(Oe, Bt)
                  }
                  return null
                })(Y, Pe);
              if (Ae !== null) {
                const ve = Ae / l.a_(fe[0], Pe);
                me = Math.min(me, ve)
              }
              for (let ve = 0; ve < 4; ve++) {
                const Oe = Math.min(me, Se[ve]);
                R[ve + ce] = [R[ve + le][0] + fe[ve][0] * Oe, R[ve + le][1] + fe[ve][1] * Oe, R[ve + le][2] + fe[ve][2] * Oe, 1]
              }
            })(T, v[0], h, f);
            const C = v.map((R => {
                const Z = l.aX([], T[R[0]], T[R[1]]),
                  Y = l.aX([], T[R[2]], T[R[1]]),
                  oe = l.aY([], l.aZ([], Z, Y)),
                  le = -l.a_(oe, T[R[1]]);
                return oe.concat(le)
              })),
              A = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              j = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const R of T)
              for (let Z = 0; Z < 3; Z++) A[Z] = Math.min(A[Z], R[Z]), j[Z] = Math.max(j[Z], R[Z]);
            return new ji(T, C, new ii(A, j))
          }
        }
        class Pi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, c = !0) {
            this._helper.resize(e, a, c)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, a) {}
          constructor(e) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (a, c) => {
              c = l.ai(+c, this.minZoom, this.maxZoom);
              const h = {
                center: new l.U(a.lng, a.lat),
                zoom: c
              };
              let f = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && f === null) {
                const fe = 179.9999999999;
                f = [-fe, fe]
              }
              const v = this.tileSize * l.al(h.zoom);
              let w = 0,
                T = v,
                C = 0,
                A = v,
                j = 0,
                R = 0;
              const {
                x: Z,
                y: Y
              } = this.size;
              if (this._helper._latRange) {
                const fe = this._helper._latRange;
                w = l.W(fe[1]) * v, T = l.W(fe[0]) * v, T - w < Y && (j = Y / (T - w))
              }
              f && (C = l.V(l.X(f[0]) * v, 0, v), A = l.V(l.X(f[1]) * v, 0, v), A < C && (A += v), A - C < Z && (R = Z / (A - C)));
              const {
                x: oe,
                y: le
              } = Ee(v, a);
              let ce, me;
              const Se = Math.max(R || 0, j || 0);
              if (Se) {
                const fe = new l.P(R ? (A + C) / 2 : oe, j ? (T + w) / 2 : le);
                return h.center = He(v, fe).wrap(), h.zoom += l.ao(Se), h
              }
              if (this._helper._latRange) {
                const fe = Y / 2;
                le - fe < w && (me = w + fe), le + fe > T && (me = T - fe)
              }
              if (f) {
                const fe = (C + A) / 2;
                let Pe = oe;
                this._helper._renderWorldCopies && (Pe = l.V(oe, fe - v / 2, fe + v / 2));
                const Ae = Z / 2;
                Pe - Ae < C && (ce = C + Ae), Pe + Ae > A && (ce = A - Ae)
              }
              if (ce !== void 0 || me !== void 0) {
                const fe = new l.P(ce ?? oe, me ?? le);
                h.center = He(v, fe).wrap()
              }
              return h
            }, this._helper = new Wn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, c) => this.defaultConstrain(a, c)
            }, e), this._coveringTilesDetailsProvider = new li
          }
          clone() {
            const e = new Pi;
            return e.apply(this), e
          }
          apply(e, a, c) {
            this._helper.apply(e, a, c)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new l.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const c = this.screenPointToMercatorCoordinate(new l.P(0, 0)),
                h = this.screenPointToMercatorCoordinate(new l.P(this._helper._width, 0)),
                f = this.screenPointToMercatorCoordinate(new l.P(this._helper._width, this._helper._height)),
                v = this.screenPointToMercatorCoordinate(new l.P(0, this._helper._height)),
                w = Math.floor(Math.min(c.x, h.x, f.x, v.x)),
                T = Math.floor(Math.max(c.x, h.x, f.x, v.x)),
                C = 1;
              for (let A = w - C; A <= T + C; A++) A !== 0 && a.push(new l.b5(A, e))
            }
            return a
          }
          getCameraFrustum() {
            return ji.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e),
              c = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(c)
          }
          setLocationAtPoint(e, a) {
            const c = l.an(this.elevation, this.center.lat),
              h = this.screenPointToMercatorCoordinateAtZ(a, c),
              f = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, c),
              v = l.a5.fromLngLat(e),
              w = new l.a5(v.x - (h.x - f.x), v.y - (h.y - f.y));
            this.setCenter(w == null ? void 0 : w.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(l.a5.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(l.a5.fromLngLat(e))
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat()
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c != null) return c
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const c = a || 0,
              h = [e.x, e.y, 0, 1],
              f = [e.x, e.y, 1, 1];
            l.aA(h, h, this._pixelMatrixInverse), l.aA(f, f, this._pixelMatrixInverse);
            const v = h[3],
              w = f[3],
              T = h[1] / v,
              C = f[1] / w,
              A = h[2] / v,
              j = f[2] / w,
              R = A === j ? 0 : (c - A) / (j - A);
            return new l.a5(l.F.number(h[0] / v, f[0] / w, R) / this.worldSize, l.F.number(T, C, R) / this.worldSize, c)
          }
          coordinatePoint(e, a = 0, c = this._pixelMatrix) {
            const h = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return l.aA(h, h, c), new l.P(h[0] / h[3], h[1] / h[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Be(this));
            return new kt().extend(this.screenPointToLocation(new l.P(0, e))).extend(this.screenPointToLocation(new l.P(this._helper._width, e))).extend(this.screenPointToLocation(new l.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new l.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - Be(this)
          }
          calculatePosMatrix(e, a = !1, c) {
            var h;
            const f = (h = e.key) !== null && h !== void 0 ? h : l.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              v = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (v.has(f)) {
              const C = v.get(f);
              return c ? C.f32 : C.f64
            }
            const w = ie(e, this.worldSize);
            l.Q(w, a ? this._alignedProjMatrix : this._viewProjMatrix, w);
            const T = {
              f64: w,
              f32: new Float32Array(w)
            };
            return v.set(f, T), c ? T.f32 : T.f64
          }
          calculateFogMatrix(e) {
            const a = e.key,
              c = this._fogMatrixCacheF32;
            if (c.has(a)) return c.get(a);
            const h = ie(e, this.worldSize);
            return l.Q(h, this._fogMatrix, h), c.set(a, new Float32Array(h)), c.get(a)
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, h)
          }
          _calculateNearFarZIfNeeded(e, a, c) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const h = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              f = e - h * this._helper._pixelPerMeter / Math.cos(a),
              v = h < 0 ? f : e,
              w = Math.PI / 2 + this.pitchInRadians,
              T = l.ak(this.fov) * (Math.abs(Math.cos(l.ak(this.roll))) * this.height + Math.abs(Math.sin(l.ak(this.roll))) * this.width) / this.height * (.5 + c.y / this.height),
              C = Math.sin(T) * v / Math.sin(l.ai(Math.PI - w - T, .01, Math.PI - .01)),
              A = Be(this),
              j = Math.atan(A / this._helper.cameraToCenterDistance),
              R = l.ak(.75),
              Z = j > R ? 2 * j * (.5 + c.y / (2 * A)) : R,
              Y = Math.sin(Z) * v / Math.sin(l.ai(Math.PI - w - Z, .01, Math.PI - .01)),
              oe = Math.min(C, Y);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * oe + v), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              a = Ee(this.worldSize, this.center),
              c = a.x,
              h = a.y;
            this._helper._pixelPerMeter = l.an(1, this.center.lat) * this.worldSize;
            const f = l.ak(Math.min(this.pitch, xe)),
              v = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(f));
            let w;
            this._calculateNearFarZIfNeeded(v, f, e), w = new Float64Array(16), l.b7(w, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), l.au(this._invProjMatrix, w), w[8] = 2 * -e.x / this._helper._width, w[9] = 2 * e.y / this._helper._height, this._projectionMatrix = l.b8(w), l.O(w, w, [1, -1, 1]), l.N(w, w, [0, 0, -this._helper.cameraToCenterDistance]), l.b9(w, w, -this.rollInRadians), l.ba(w, w, this.pitchInRadians), l.b9(w, w, -this.bearingInRadians), l.N(w, w, [-c, -h, 0]), this._mercatorMatrix = l.O([], w, [this.worldSize, this.worldSize, this.worldSize]), l.O(w, w, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = l.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w), l.N(w, w, [0, 0, -this.elevation]), this._viewProjMatrix = w, this._invViewProjMatrix = l.au([], w);
            const T = [0, 0, -1, 1];
            l.aA(T, T, this._invViewProjMatrix), this._cameraPosition = [T[0] / T[3], T[1] / T[3], T[2] / T[3]], this._fogMatrix = new Float64Array(16), l.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, v, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, l.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), l.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), l.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), l.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), l.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), l.N(this._fogMatrix, this._fogMatrix, [-c, -h, 0]), l.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), l.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = l.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w);
            const C = this._helper._width % 2 / 2,
              A = this._helper._height % 2 / 2,
              j = Math.cos(this.bearingInRadians),
              R = Math.sin(-this.bearingInRadians),
              Z = c - Math.round(c) + j * C + R * A,
              Y = h - Math.round(h) + j * A + R * C,
              oe = new Float64Array(w);
            if (l.N(oe, oe, [Z > .5 ? Z - 1 : Z, Y > .5 ? Y - 1 : Y, 0]), this._alignedProjMatrix = oe, w = l.au(new Float64Array(16), this._pixelMatrix), !w) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = w, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new l.P(0, 0)),
              a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return l.aA(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = l.an(1, this.center.lat) * this.worldSize;
            return J(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, a) {
            const c = l.a5.fromLngLat(e),
              h = [c.x * this.worldSize, c.y * this.worldSize, a, 1];
            return l.aA(h, h, this._viewProjMatrix), h[2] / h[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              aligned: c,
              applyTerrainMatrix: h
            } = e, f = this._helper.getMercatorTileCoordinates(a), v = a ? this.calculatePosMatrix(a, c, !0) : null;
            let w;
            return w = a && a.terrainRttPosMatrix32f && h ? a.terrainRttPosMatrix32f : v || l.bb(), {
              mainMatrix: w,
              tileMercatorCoords: f,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: w
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, a, c) {
            return 1
          }
          transformLightDirection(e) {
            return l.aW(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, a, c, h) {
            const f = this.calculatePosMatrix(c);
            let v;
            h ? (v = [e, a, h(e, a), 1], l.aA(v, v, f)) : (v = [e, a, 0, 1], jr(v, v, f));
            const w = v[3];
            return {
              point: new l.P(v[0] / w, v[1] / w),
              signedDistanceFromCamera: w,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a)
          }
          getMatrixForModel(e, a) {
            const c = l.a5.fromLngLat(e, a),
              h = c.meterInMercatorCoordinateUnits(),
              f = l.bc();
            return l.N(f, f, [c.x, c.y, c.z]), l.b9(f, f, Math.PI), l.ba(f, f, Math.PI / 2), l.O(f, f, [-h, h, h]), f
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = new l.a0(0, 0, 0, 0, 0),
              c = this.getProjectionData({
                overscaledTileID: a,
                applyGlobeMatrix: e
              }),
              h = ie(a, this.worldSize);
            l.Q(h, this._viewProjMatrix, h), c.tileMercatorCoords = [0, 0, 1, 1];
            const f = [l.a3, l.a3, this.worldSize / this._helper.pixelsPerMeter],
              v = l.bd();
            return l.O(v, h, f), c.fallbackMatrix = v, c.mainMatrix = v, c
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function Qn() {
          l.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function hi(d) {
          if (d.useSlerp)
            if (d.k < 1) {
              const e = l.be(d.startEulerAngles.roll, d.startEulerAngles.pitch, d.startEulerAngles.bearing),
                a = l.be(d.endEulerAngles.roll, d.endEulerAngles.pitch, d.endEulerAngles.bearing),
                c = new Float64Array(4);
              l.bf(c, e, a, d.k);
              const h = l.bg(c);
              d.tr.setRoll(h.roll), d.tr.setPitch(h.pitch), d.tr.setBearing(h.bearing)
            } else d.tr.setRoll(d.endEulerAngles.roll), d.tr.setPitch(d.endEulerAngles.pitch), d.tr.setBearing(d.endEulerAngles.bearing);
          else d.tr.setRoll(l.F.number(d.startEulerAngles.roll, d.endEulerAngles.roll, d.k)), d.tr.setPitch(l.F.number(d.startEulerAngles.pitch, d.endEulerAngles.pitch, d.k)), d.tr.setBearing(l.F.number(d.startEulerAngles.bearing, d.endEulerAngles.bearing, d.k))
        }

        function Mi(d, e, a, c, h) {
          const f = h.padding,
            v = Ee(h.worldSize, a.getNorthWest()),
            w = Ee(h.worldSize, a.getNorthEast()),
            T = Ee(h.worldSize, a.getSouthEast()),
            C = Ee(h.worldSize, a.getSouthWest()),
            A = l.ak(-c),
            j = v.rotate(A),
            R = w.rotate(A),
            Z = T.rotate(A),
            Y = C.rotate(A),
            oe = new l.P(Math.max(j.x, R.x, Y.x, Z.x), Math.max(j.y, R.y, Y.y, Z.y)),
            le = new l.P(Math.min(j.x, R.x, Y.x, Z.x), Math.min(j.y, R.y, Y.y, Z.y)),
            ce = oe.sub(le),
            me = (h.width - (f.left + f.right + e.left + e.right)) / ce.x,
            Se = (h.height - (f.top + f.bottom + e.top + e.bottom)) / ce.y;
          if (Se < 0 || me < 0) return void Qn();
          const fe = Math.min(l.ao(h.scale * Math.min(me, Se)), d.maxZoom),
            Pe = l.P.convert(d.offset),
            Ae = new l.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(l.ak(c)),
            ve = Pe.add(Ae).mult(h.scale / l.al(fe));
          return {
            center: He(h.worldSize, v.add(T).div(2).sub(ve)),
            zoom: fe,
            bearing: c
          }
        }
        class Ni {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, a) {
            const c = e.mag(),
              h = Math.abs(Be(a));
            return {
              easingOffset: e.mult(Math.min(.75 * h / c, 1)),
              easingCenter: a.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, a, c) {
            e.around.distSqr(a.centerPoint) < .01 || a.setLocationAtPoint(c, e.around)
          }
          cameraForBoxAndBearing(e, a, c, h, f) {
            return Mi(e, a, c, h, f)
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(l.U.convert(a.center))
          }
          handleEaseTo(e, a) {
            const c = e.zoom,
              h = e.padding,
              f = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              v = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              w = a.zoom !== void 0,
              T = !e.isPaddingEqual(a.padding);
            let C = !1;
            const A = w ? +a.zoom : e.zoom;
            let j = e.centerPoint.add(a.offsetAsPoint);
            const R = e.screenPointToLocation(j),
              {
                center: Z,
                zoom: Y
              } = e.constrain(l.U.convert(a.center || R), A ?? c);
            un(e, Z);
            const oe = Ee(e.worldSize, R),
              le = Ee(e.worldSize, Z).sub(oe),
              ce = l.al(Y - c);
            return C = Y !== c, {
              easeFunc: me => {
                if (C && e.setZoom(l.F.number(c, Y, me)), l.bh(f, v) || hi({
                    startEulerAngles: f,
                    endEulerAngles: v,
                    tr: e,
                    k: me,
                    useSlerp: f.roll != v.roll
                  }), T && (e.interpolatePadding(h, a.padding, me), j = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const Se = l.al(e.zoom - c),
                    fe = Y > c ? Math.min(2, ce) : Math.max(.5, ce),
                    Pe = Math.pow(fe, 1 - me),
                    Ae = He(e.worldSize, oe.add(le.mult(me * Pe)).mult(Se));
                  e.setLocationAtPoint(e.renderWorldCopies ? Ae.wrap() : Ae, j)
                }
              },
              isZooming: C,
              elevationCenter: Z
            }
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0,
              h = e.zoom,
              f = e.constrain(l.U.convert(a.center || a.locationAtOffset), c ? +a.zoom : h),
              v = f.center,
              w = f.zoom;
            un(e, v);
            const T = Ee(e.worldSize, a.locationAtOffset),
              C = Ee(e.worldSize, v).sub(T),
              A = C.mag(),
              j = l.al(w - h);
            let R;
            if (a.minZoom !== void 0) {
              const Z = Math.min(+a.minZoom, h, w),
                Y = e.constrain(v, Z).zoom;
              R = l.al(Y - h)
            }
            return {
              easeFunc: (Z, Y, oe, le) => {
                e.setZoom(Z === 1 ? w : h + l.ao(Y));
                const ce = Z === 1 ? v : He(e.worldSize, T.add(C.mult(oe)).mult(Y));
                e.setLocationAtPoint(e.renderWorldCopies ? ce.wrap() : ce, le)
              },
              scaleOfZoom: j,
              targetCenter: v,
              scaleOfMinZoom: R,
              pixelPathLength: A
            }
          }
        }
        class Sn {
          constructor(e, a, c) {
            this.blendFunction = e, this.blendColor = a, this.mask = c
          }
        }
        Sn.Replace = [1, 0], Sn.disabled = new Sn(Sn.Replace, l.bi.transparent, [!1, !1, !1, !1]), Sn.unblended = new Sn(Sn.Replace, l.bi.transparent, [!0, !0, !0, !0]), Sn.alphaBlended = new Sn([1, 771], l.bi.transparent, [!0, !0, !0, !0]);
        const wa = 2305;
        class vn {
          constructor(e, a, c) {
            this.enable = e, this.mode = a, this.frontFace = c
          }
        }
        vn.disabled = new vn(!1, 1029, wa), vn.backCCW = new vn(!0, 1029, wa), vn.frontCCW = new vn(!0, 1028, wa);
        class yn {
          constructor(e, a, c) {
            this.func = e, this.mask = a, this.range = c
          }
        }
        yn.ReadOnly = !1, yn.ReadWrite = !0, yn.disabled = new yn(519, yn.ReadOnly, [0, 1]);
        const Ba = 7680;
        class Rn {
          constructor(e, a, c, h, f, v) {
            this.test = e, this.ref = a, this.mask = c, this.fail = h, this.depthFail = f, this.pass = v
          }
        }
        Rn.disabled = new Rn({
          func: 519,
          mask: 0
        }, 0, 0, Ba, Ba, Ba);
        const Oa = new WeakMap;

        function Vi(d) {
          var e;
          if (Oa.has(d)) return Oa.get(d);
          {
            const a = (e = d.getParameter(d.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Oa.set(d, a), a
          }
        }
        class eo {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context,
              c = a.gl;
            this._texFormat = c.RGBA, this._texType = c.UNSIGNED_BYTE;
            const h = new l.aP;
            h.emplaceBack(-1, -1), h.emplaceBack(2, -1), h.emplaceBack(-1, 2);
            const f = new l.aR;
            f.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Gn(a.createVertexBuffer(h, qn.members), a.createIndexBuffer(f), l.aQ.simpleSegment(0, 0, h.length, f.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(c.TEXTURE1);
            const v = c.createTexture();
            c.bindTexture(c.TEXTURE_2D, v), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texImage2D(c.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(v), Vi(c) && (this._pbo = c.createBuffer(), c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.bufferData(c.PIXEL_PACK_BUFFER, 4, c.STREAM_READ), c.bindBuffer(c.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, a) {
            const c = this._updateCount;
            return this._readbackQueue ? c >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : c >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, a) {
            const c = this._cachedRenderContext.context,
              h = c.gl;
            if (this._bindFramebuffer(), c.viewport.set([0, 0, this._texWidth, this._texHeight]), c.clear({
                color: l.bi.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(c, h.TRIANGLES, yn.disabled, Rn.disabled, Sn.unblended, vn.disabled, ((f, v) => ({
                u_input: f,
                u_output_expected: v
              }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Vi(h)) {
              h.bindBuffer(h.PIXEL_PACK_BUFFER, this._pbo), h.readBuffer(h.COLOR_ATTACHMENT0), h.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), h.bindBuffer(h.PIXEL_PACK_BUFFER, null);
              const f = h.fenceSync(h.SYNC_GPU_COMMANDS_COMPLETE, 0);
              h.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: f
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Vi(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return l.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = eo._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128
          }
        }
        const qa = l.a3 / 128;

        function ka(d, e) {
          const a = d.granularity !== void 0 ? Math.max(d.granularity, 1) : 1,
            c = a + (d.generateBorders ? 2 : 0),
            h = a + (d.extendToNorthPole || d.generateBorders ? 1 : 0) + (d.extendToSouthPole || d.generateBorders ? 1 : 0),
            f = c + 1,
            v = h + 1,
            w = d.generateBorders ? -1 : 0,
            T = d.generateBorders || d.extendToNorthPole ? -1 : 0,
            C = a + (d.generateBorders ? 1 : 0),
            A = a + (d.generateBorders || d.extendToSouthPole ? 1 : 0),
            j = f * v,
            R = c * h * 6,
            Z = f * v > 65536;
          if (Z && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const Y = Z || e === "32bit",
            oe = new Int16Array(2 * j);
          let le = 0;
          for (let Se = T; Se <= A; Se++)
            for (let fe = w; fe <= C; fe++) {
              let Pe = fe / a * l.a3;
              fe === -1 && (Pe = -qa), fe === a + 1 && (Pe = l.a3 + qa);
              let Ae = Se / a * l.a3;
              Se === -1 && (Ae = d.extendToNorthPole ? l.bk : -qa), Se === a + 1 && (Ae = d.extendToSouthPole ? l.bl : l.a3 + qa), oe[le++] = Pe, oe[le++] = Ae
            }
          const ce = Y ? new Uint32Array(R) : new Uint16Array(R);
          let me = 0;
          for (let Se = 0; Se < h; Se++)
            for (let fe = 0; fe < c; fe++) {
              const Pe = fe + 1 + Se * f,
                Ae = fe + (Se + 1) * f,
                ve = fe + 1 + (Se + 1) * f;
              ce[me++] = fe + Se * f, ce[me++] = Ae, ce[me++] = Pe, ce[me++] = Pe, ce[me++] = Ae, ce[me++] = ve
            }
          return {
            vertices: oe.buffer.slice(0),
            indices: ce.buffer.slice(0),
            uses32bitIndices: Y
          }
        }
        const oo = new l.aO({
          fill: new l.bm(128, 2),
          line: new l.bm(512, 0),
          tile: new l.bm(128, 32),
          stencil: new l.bm(128, 1),
          circle: 3
        });
        class Na {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return Ir.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return Ir.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return oo
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new eo(e));
            const a = l.W(this._errorQueryLatitudeDegrees),
              c = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - .5 * Math.PI,
              h = this._errorMeasurement.updateErrorLoop(a, c),
              f = ge();
            h !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = h, this._errorMeasurementLastChangeTime = f);
            const v = Math.min(Math.max((f - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = l.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, l.bo(v))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, a, c, h, f) {
            const v = (f === "stencil" ? oo.stencil : oo.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, {
              granularity: v,
              generateBorders: c,
              extendToNorthPole: a.y === 0 && h,
              extendToSouthPole: a.y === (1 << a.z) - 1 && h
            })
          }
          _getMesh(e, a) {
            const c = this._getMeshKey(a);
            if (c in this._tileMeshCache) return this._tileMeshCache[c];
            const h = (function(f, v) {
              const w = ka(v, "16bit"),
                T = l.aP.deserialize({
                  arrayBuffer: w.vertices,
                  length: w.vertices.byteLength / 2 / 2
                }),
                C = l.aR.deserialize({
                  arrayBuffer: w.indices,
                  length: w.indices.byteLength / 2 / 3
                });
              return new Gn(f.createVertexBuffer(T, qn.members), f.createIndexBuffer(C), l.aQ.simpleSegment(0, 0, T.length, C.length))
            })(e, a);
            return this._tileMeshCache[c] = h, h
          }
          recalculate(e) {}
          hasTransition() {
            const e = ge();
            let a = !1;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const to = new l.r({
          type: new l.D(l.t.projection.type)
        });
        class di extends l.E {
          constructor(e) {
            super(), this._transitionable = new l.x(to, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new l.G(0)), this._mercatorProjection = new Mn, this._verticalPerspectiveProjection = new Na
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof l.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, a, c, h, f) {
            return this.currentProjection.getMeshFromTileID(e, a, c, h, f)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function Ii(d) {
          const e = Va(d.worldSize, d.center.lat);
          return 2 * Math.PI * e
        }

        function _a(d, e, a, c, h) {
          const f = 1 / (1 << h),
            v = e / l.a3 * f + c * f,
            w = l.br((d / l.a3 * f + a * f) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            T = 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI,
            C = Math.cos(T),
            A = new Float64Array(3);
          return A[0] = Math.sin(w) * C, A[1] = Math.sin(T), A[2] = Math.cos(w) * C, A
        }

        function pi(d) {
          return (function(e, a) {
            const c = Math.cos(a),
              h = new Float64Array(3);
            return h[0] = Math.sin(e) * c, h[1] = Math.sin(a), h[2] = Math.cos(e) * c, h
          })(d.lng * Math.PI / 180, d.lat * Math.PI / 180)
        }

        function Va(d, e) {
          return d / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function Bo(d) {
          const e = Math.asin(d[1]) / Math.PI * 180,
            a = Math.sqrt(d[0] * d[0] + d[2] * d[2]);
          if (a > 1e-6) {
            const c = d[0] / a,
              h = Math.acos(d[2] / a),
              f = (c > 0 ? h : -h) / Math.PI * 180;
            return new l.U(l.V(f, -180, 180), e)
          }
          return new l.U(0, e)
        }

        function vs(d) {
          return Math.cos(d * Math.PI / 180)
        }

        function Hn(d, e) {
          const a = vs(d),
            c = vs(e);
          return l.ao(c / a)
        }

        function wl(d, e) {
          const a = d.rotate(e.bearingInRadians),
            c = e.zoom + Hn(e.center.lat, 0),
            h = l.bn(1 / vs(e.center.lat), 1 / vs(Math.min(Math.abs(e.center.lat), 60)), l.bq(c, 7, 3, 0, 1)),
            f = 360 / Ii({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new l.U(e.center.lng - a.x * f * h, l.ai(e.center.lat + a.y * f, -l.aj, l.aj))
        }

        function La(d) {
          const e = .5 * d,
            a = Math.sin(e),
            c = Math.cos(e);
          return Math.log(a + c) - Math.log(c - a)
        }

        function Ns(d, e, a, c) {
          const h = d.lat + a * c;
          if (Math.abs(a) > 1) {
            const f = (Math.sign(d.lat + a) !== Math.sign(d.lat) ? -Math.abs(d.lat) : Math.abs(d.lat)) * Math.PI / 180,
              v = Math.abs(d.lat + a) * Math.PI / 180,
              w = La(f + c * (v - f)),
              T = La(f),
              C = La(v);
            return new l.U(d.lng + e * ((w - T) / (C - T)), h)
          }
          return new l.U(d.lng + e * c, h)
        }
        class Dh {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, a, c, h) {
            const f = `${e.z}_${e.x}_${e.y}_${h!=null&&h.terrain?"t":""}`,
              v = this._cache.get(f);
            if (v) return v;
            const w = this._cachePrevious.get(f);
            if (w) return this._cache.set(f, w), w;
            const T = this._boundingVolumeFactory(e, a, c, h);
            return this._cache.set(f, T), this._hadAnyChanges = !0, T
          }
        }
        class Oo {
          constructor(e, a, c, h) {
            this.min = c, this.max = h, this.points = e, this.planes = a
          }
          static fromAabb(e, a) {
            const c = [];
            for (let h = 0; h < 8; h++) c.push([1 & ~h ? e[0] : a[0], (h >> 1 & 1) == 1 ? a[1] : e[1], (h >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new Oo(c, [
              [-1, 0, 0, a[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, a[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, a[2]],
              [0, 0, 1, -e[2]]
            ], e, a)
          }
          static fromCenterSizeAngles(e, a, c) {
            const h = l.bu([], c[0], c[1], c[2]),
              f = l.bv([], [a[0], 0, 0], h),
              v = l.bv([], [0, a[1], 0], h),
              w = l.bv([], [0, 0, a[2]], h),
              T = [...e],
              C = [...e];
            for (let j = 0; j < 8; j++)
              for (let R = 0; R < 3; R++) {
                const Z = e[R] + f[R] * (1 & ~j ? -1 : 1) + v[R] * ((j >> 1 & 1) == 1 ? 1 : -1) + w[R] * ((j >> 2 & 1) == 1 ? 1 : -1);
                T[R] = Math.min(T[R], Z), C[R] = Math.max(C[R], Z)
              }
            const A = [];
            for (let j = 0; j < 8; j++) {
              const R = [...e];
              l.aV(R, R, l.aU([], f, 1 & ~j ? -1 : 1)), l.aV(R, R, l.aU([], v, (j >> 1 & 1) == 1 ? 1 : -1)), l.aV(R, R, l.aU([], w, (j >> 2 & 1) == 1 ? 1 : -1)), A.push(R)
            }
            return new Oo(A, [
              [...f, -l.a_(f, A[0])],
              [...v, -l.a_(v, A[0])],
              [...w, -l.a_(w, A[0])],
              [-f[0], -f[1], -f[2], -l.a_(f, A[7])],
              [-v[0], -v[1], -v[2], -l.a_(v, A[7])],
              [-w[0], -w[1], -w[2], -l.a_(w, A[7])]
            ], T, C)
          }
          intersectsFrustum(e) {
            let a = !0;
            const c = this.points.length,
              h = this.planes.length,
              f = e.planes.length,
              v = e.points.length;
            for (let w = 0; w < f; w++) {
              const T = e.planes[w];
              let C = 0;
              for (let A = 0; A < c; A++) {
                const j = this.points[A];
                T[0] * j[0] + T[1] * j[1] + T[2] * j[2] + T[3] >= 0 && C++
              }
              if (C === 0) return 0;
              C < c && (a = !1)
            }
            if (a) return 2;
            for (let w = 0; w < h; w++) {
              const T = this.planes[w];
              let C = 0;
              for (let A = 0; A < v; A++) {
                const j = e.points[A];
                T[0] * j[0] + T[1] * j[1] + T[2] * j[2] + T[3] >= 0 && C++
              }
              if (C === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let c = 0;
            for (let h = 0; h < a; h++) {
              const f = this.points[h];
              e[0] * f[0] + e[1] * f[1] + e[2] * f[2] + e[3] >= 0 && c++
            }
            return c === a ? 2 : c === 0 ? 0 : 1
          }
        }

        function so(d, e, a) {
          const c = d - e;
          return c < 0 ? -c : Math.max(0, c - a)
        }

        function Bc(d, e, a, c, h) {
          const f = d - a;
          let v;
          return v = f < 0 ? Math.min(-f, 1 + f - h) : f > 1 ? Math.min(Math.max(f - h, 0), 1 - f) : 0, Math.max(v, so(e, c, h))
        }
        class Fp {
          constructor() {
            this._boundingVolumeCache = new Dh(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, a, c, h) {
            const f = 1 << c.z,
              v = 1 / f,
              w = c.x / f,
              T = c.y / f;
            let C = 2;
            return C = Math.min(C, Bc(e, a, w, T, v)), C = Math.min(C, Bc(e, a, w + .5, -T - v, v)), C = Math.min(C, Bc(e, a, w + .5, 2 - T - v, v)), C
          }
          getWrap(e, a, c) {
            const h = 1 << a.z,
              f = 1 / h,
              v = a.x / h,
              w = so(e.x, v, f),
              T = so(e.x, v - 1, f),
              C = so(e.x, v + 1, f),
              A = Math.min(w, T, C);
            return A === C ? 1 : A === T ? -1 : 0
          }
          allowVariableZoom(e, a) {
            return Ie(e, a) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, a, c, h) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, c, h)
          }
          _computeTileBoundingVolume(e, a, c, h) {
            var f, v;
            let w = 0,
              T = 0;
            if (h != null && h.terrain) {
              const C = new l.a0(e.z, a, e.z, e.x, e.y),
                A = h.terrain.getMinMaxElevation(C);
              w = (f = A.minElevation) !== null && f !== void 0 ? f : Math.min(0, c), T = (v = A.maxElevation) !== null && v !== void 0 ? v : Math.max(0, c)
            }
            if (w /= l.bx, T /= l.bx, w += 1, T += 1, e.z <= 0) return Oo.fromAabb([-T, -T, -T], [T, T, T]);
            if (e.z === 1) return Oo.fromAabb([e.x === 0 ? -T : 0, e.y === 0 ? 0 : -T, -T], [e.x === 0 ? 0 : T, e.y === 0 ? T : 0, T]);
            {
              const C = [_a(0, 0, e.x, e.y, e.z), _a(l.a3, 0, e.x, e.y, e.z), _a(l.a3, l.a3, e.x, e.y, e.z), _a(0, l.a3, e.x, e.y, e.z)],
                A = [];
              for (const st of C) A.push(l.aU([], st, T));
              if (T !== w)
                for (const st of C) A.push(l.aU([], st, w));
              e.y === 0 && A.push([0, 1, 0]), e.y === (1 << e.z) - 1 && A.push([0, -1, 0]);
              const j = [1, 1, 1],
                R = [-1, -1, -1];
              for (const st of A)
                for (let ut = 0; ut < 3; ut++) j[ut] = Math.min(j[ut], st[ut]), R[ut] = Math.max(R[ut], st[ut]);
              const Z = _a(l.a3 / 2, l.a3 / 2, e.x, e.y, e.z),
                Y = l.aZ([], [0, 1, 0], Z);
              l.aY(Y, Y);
              const oe = l.aZ([], Z, Y);
              l.aY(oe, oe);
              const le = l.aZ([], C[2], C[1]);
              l.aY(le, le);
              const ce = l.aZ([], C[0], C[3]);
              l.aY(ce, ce), A.push(l.aU([], Z, T)), e.y >= (1 << e.z) / 2 && A.push(l.aU([], _a(l.a3 / 2, 0, e.x, e.y, e.z), T)), e.y < (1 << e.z) / 2 && A.push(l.aU([], _a(l.a3 / 2, l.a3, e.x, e.y, e.z), T));
              const me = Rh(Z, A),
                Se = Rh(oe, A),
                fe = [-Z[0], -Z[1], -Z[2], me.max],
                Pe = [Z[0], Z[1], Z[2], -me.min],
                Ae = [-oe[0], -oe[1], -oe[2], Se.max],
                ve = [oe[0], oe[1], oe[2], -Se.min],
                Oe = [...le, 0],
                ct = [...ce, 0],
                it = [];
              return e.y === 0 ? it.push(l.bw(ct, Oe, fe), l.bw(ct, Oe, Pe)) : it.push(l.bw(Ae, Oe, fe), l.bw(Ae, Oe, Pe), l.bw(Ae, ct, fe), l.bw(Ae, ct, Pe)), e.y === (1 << e.z) - 1 ? it.push(l.bw(ct, Oe, fe), l.bw(ct, Oe, Pe)) : it.push(l.bw(ve, Oe, fe), l.bw(ve, Oe, Pe), l.bw(ve, ct, fe), l.bw(ve, ct, Pe)), new Oo(it, [fe, Pe, Ae, ve, Oe, ct], j, R)
            }
          }
        }

        function Rh(d, e) {
          let a = 1 / 0,
            c = -1 / 0;
          for (const h of e) {
            const f = l.a_(d, h);
            a = Math.min(a, f), c = Math.max(c, f)
          }
          return {
            min: a,
            max: c
          }
        }
        class kl {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a) {
            this._helper.resize(e, a)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor(e) {
            this._cachedClippingPlane = l.by(), this._projectionMatrix = l.bc(), this._globeViewProjMatrix32f = l.bb(), this._globeViewProjMatrixNoCorrection = l.bc(), this._globeViewProjMatrixNoCorrectionInverted = l.bc(), this._globeProjMatrixInverted = l.bc(), this._cameraPosition = l.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (a, c) => {
              const h = l.ai(a.lat, -l.aj, l.aj),
                f = l.ai(+c, this.minZoom + Hn(0, h), this.maxZoom);
              return {
                center: new l.U(a.lng, h),
                zoom: f
              }
            }, this._helper = new Wn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, c) => this.defaultConstrain(a, c)
            }, e), this._coveringTilesDetailsProvider = new Fp
          }
          clone() {
            const e = new kl;
            return e.apply(this), e
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = l.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              applyGlobeMatrix: c
            } = e, h = this._helper.getMercatorTileCoordinates(a);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: h,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: c ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians,
              c = this.cameraToCenterDistance / e,
              h = Math.sin(a) * c,
              f = Math.cos(a) * c + 1,
              v = 1 / Math.sqrt(h * h + f * f) * 1;
            let w = -h,
              T = f;
            const C = Math.sqrt(w * w + T * T);
            w /= C, T /= C;
            const A = [0, w, T];
            l.bz(A, A, [0, 0, 0], -this.bearingInRadians), l.bA(A, A, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), l.bB(A, A, [0, 0, 0], this.center.lng * Math.PI / 180);
            const j = 1 / l.b0(A);
            return l.aU(A, A, j), [...A, -v * j]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(pi(e))
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180,
              c = this._helper._center.lat * Math.PI / 180,
              h = Math.cos(c),
              f = [Math.sin(a) * h, Math.sin(c), Math.cos(a) * h],
              v = [f[2], 0, -f[0]],
              w = [0, 0, 0];
            l.aZ(w, v, f), l.aY(v, v), l.aY(w, w);
            const T = [0, 0, 0];
            return l.aY(T, [v[0] * e[0] + w[0] * e[1] + f[0] * e[2], v[1] * e[0] + w[1] * e[1] + f[1] * e[2], v[2] * e[0] + w[2] * e[1] + f[2] * e[2]]), T
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, a, c) {
            const h = (function(w, T, C) {
                const A = 1 / (1 << C.z);
                return new l.a5(w / l.a3 * A + C.x * A, T / l.a3 * A + C.y * A)
              })(e, a, c.canonical),
              f = (v = h.y, [l.br(h.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI]);
            var v;
            return this.getCircleRadiusCorrection() / Math.cos(f[1])
          }
          projectTileCoordinates(e, a, c, h) {
            const f = c.canonical,
              v = _a(e, a, f.x, f.y, f.z),
              w = 1 + (h ? h(e, a) : 0) / l.bx,
              T = [v[0] * w, v[1] * w, v[2] * w, 1];
            l.aA(T, T, this._globeViewProjMatrixNoCorrection);
            const C = this._cachedClippingPlane,
              A = C[0] * v[0] + C[1] * v[1] + C[2] * v[2] + C[3] < 0;
            return {
              point: new l.P(T[0] / T[3], T[1] / T[3]),
              signedDistanceFromCamera: T[3],
              isOccluded: A
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Va(this.worldSize, this.center.lat),
              a = l.bd(),
              c = l.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), l.b7(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const h = this.centerOffset;
            a[8] = 2 * -h.x / this._helper._width, a[9] = 2 * h.y / this._helper._height, this._projectionMatrix = l.b8(a), this._globeProjMatrixInverted = l.bd(), l.au(this._globeProjMatrixInverted, a), l.N(a, a, [0, 0, -this.cameraToCenterDistance]), l.b9(a, a, this.rollInRadians), l.ba(a, a, -this.pitchInRadians), l.b9(a, a, this.bearingInRadians), l.N(a, a, [0, 0, -e]);
            const f = l.bs();
            f[0] = e, f[1] = e, f[2] = e, l.ba(c, a, this.center.lat * Math.PI / 180), l.bC(c, c, -this.center.lng * Math.PI / 180), l.O(c, c, f), this._globeViewProjMatrixNoCorrection = c, l.ba(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), l.bC(a, a, -this.center.lng * Math.PI / 180), l.O(a, a, f), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = l.bd(), l.au(this._globeViewProjMatrixNoCorrectionInverted, c);
            const v = l.bs();
            this._cameraPosition = l.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, l.bz(this._cameraPosition, this._cameraPosition, v, -this.rollInRadians), l.bA(this._cameraPosition, this._cameraPosition, v, this.pitchInRadians), l.bz(this._cameraPosition, this._cameraPosition, v, -this.bearingInRadians), l.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), l.bA(this._cameraPosition, this._cameraPosition, v, -this.center.lat * Math.PI / 180), l.bB(this._cameraPosition, this._cameraPosition, v, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const w = l.b8(this._globeViewProjMatrixNoCorrectionInverted);
            l.O(w, w, [1, 1, -1]), this._cachedFrustum = ji.fromInvProjectionMatrix(w, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            l.w("calculateFogMatrix is not supported on globe projection.");
            const a = l.bd();
            return l.am(a), a
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new l.b5(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && l.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const c = pi(e);
            l.aU(c, c, 1 + a / l.bx);
            const h = l.by();
            return l.aA(h, [c[0], c[1], c[2], 1], this._globeViewProjMatrixNoCorrection), h[2] / h[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              a = .5 * this.height,
              c = [new l.P(0, 0), new l.P(e, 0), new l.P(this.width, 0), new l.P(this.width, a), new l.P(this.width, this.height), new l.P(e, this.height), new l.P(0, this.height), new l.P(0, a)],
              h = [];
            for (const j of c) h.push(this.unprojectScreenPoint(j));
            let f = 0,
              v = 0,
              w = 0,
              T = 0;
            const C = this.center;
            for (const j of h) {
              const R = l.bD(C.lng, j.lng),
                Z = l.bD(C.lat, j.lat);
              R < v && (v = R), R > f && (f = R), Z < T && (T = Z), Z > w && (w = Z)
            }
            const A = [C.lng + v, C.lat + T, C.lng + f, C.lat + w];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (A[3] = 90, A[0] = -180, A[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (A[1] = -90, A[0] = -180, A[2] = 180), new kt(A)
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, h)
          }
          setLocationAtPoint(e, a) {
            const c = pi(this.unprojectScreenPoint(a)),
              h = pi(e),
              f = l.bs();
            l.bE(f);
            const v = l.bs();
            l.bB(v, c, f, -this.center.lng * Math.PI / 180), l.bA(v, v, f, this.center.lat * Math.PI / 180);
            const w = h[0] * h[0] + h[2] * h[2],
              T = v[0] * v[0];
            if (w < T) return;
            const C = Math.sqrt(w - T),
              A = -C,
              j = l.bF(h[0], h[2], v[0], C),
              R = l.bF(h[0], h[2], v[0], A),
              Z = l.bs();
            l.bB(Z, h, f, -j);
            const Y = l.bF(Z[1], Z[2], v[1], v[2]),
              oe = l.bs();
            l.bB(oe, h, f, -R);
            const le = l.bF(oe[1], oe[2], v[1], v[2]),
              ce = .5 * Math.PI,
              me = Y >= -ce && Y <= ce,
              Se = le >= -ce && le <= ce;
            let fe, Pe;
            if (me && Se) {
              const ct = this.center.lng * Math.PI / 180,
                it = this.center.lat * Math.PI / 180;
              l.bG(j, ct) + l.bG(Y, it) < l.bG(R, ct) + l.bG(le, it) ? (fe = j, Pe = Y) : (fe = R, Pe = le)
            } else if (me) fe = j, Pe = Y;
            else {
              if (!Se) return;
              fe = R, Pe = le
            }
            const Ae = fe / Math.PI * 180,
              ve = Pe / Math.PI * 180,
              Oe = this.center.lat;
            this.setCenter(new l.U(Ae, l.ai(ve, -90, 90))), this.setZoom(this.zoom + Hn(Oe, this.center.lat))
          }
          locationToScreenPoint(e, a) {
            const c = pi(e);
            if (a) {
              const h = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              l.aU(c, c, 1 + h / l.bx)
            }
            return this._projectSurfacePointToScreen(c)
          }
          _projectSurfacePointToScreen(e) {
            const a = l.by();
            return l.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new l.P((.5 * a[0] + .5) * this.width, (.5 * -a[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c) return c
            }
            return l.a5.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat()
          }
          isPointOnMapSurface(e, a) {
            const c = this._cameraPosition,
              h = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(c, h)
          }
          getRayDirectionFromPixel(e) {
            const a = l.by();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, l.aA(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const c = l.bs();
            c[0] = a[0] - this._cameraPosition[0], c[1] = a[1] - this._cameraPosition[1], c[2] = a[2] - this._cameraPosition[2];
            const h = l.bs();
            return l.aY(h, c), h
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const a = l.by();
            return l.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1
          }
          rayPlanetIntersection(e, a) {
            const c = l.a_(e, a),
              h = l.bs(),
              f = l.bs();
            l.aU(f, a, c), l.aX(h, e, f);
            const v = 1 - l.a_(h, h);
            if (v < 0) return null;
            const w = l.a_(e, e) - 1,
              T = -c + (c < 0 ? 1 : -1) * Math.sqrt(v),
              C = w / T,
              A = T;
            return {
              tMin: Math.min(C, A),
              tMax: Math.max(C, A)
            }
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition,
              c = this.getRayDirectionFromPixel(e),
              h = this.rayPlanetIntersection(a, c);
            if (h) {
              const A = l.bs();
              l.aV(A, a, [c[0] * h.tMin, c[1] * h.tMin, c[2] * h.tMin]);
              const j = l.bs();
              return l.aY(j, A), Bo(j)
            }
            const f = this._cachedClippingPlane,
              v = f[0] * c[0] + f[1] * c[1] + f[2] * c[2],
              w = -l.b4(f, a) / v,
              T = l.bs();
            if (w > 0) l.aV(T, a, [c[0] * w, c[1] * w, c[2] * w]);
            else {
              const A = l.bs();
              l.aV(A, a, [2 * c[0], 2 * c[1], 2 * c[2]]);
              const j = l.b4(this._cachedClippingPlane, A);
              l.aX(T, A, [this._cachedClippingPlane[0] * j, this._cachedClippingPlane[1] * j, this._cachedClippingPlane[2] * j])
            }
            const C = (function(A) {
              const j = l.bs();
              return j[0] = A[0] * -A[3], j[1] = A[1] * -A[3], j[2] = A[2] * -A[3], {
                center: j,
                radius: Math.sqrt(1 - A[3] * A[3])
              }
            })(f);
            return Bo((function(A, j, R) {
              const Z = l.bs();
              l.aX(Z, R, A);
              const Y = l.bs();
              return l.bt(Y, A, Z, j / l.b2(Z)), Y
            })(C.center, C.radius, T))
          }
          getMatrixForModel(e, a) {
            const c = l.U.convert(e),
              h = 1 / l.bx,
              f = l.bc();
            return l.bC(f, f, c.lng / 180 * Math.PI), l.ba(f, f, -c.lat / 180 * Math.PI), l.N(f, f, [0, 0, 1 + a / l.bx]), l.ba(f, f, .5 * Math.PI), l.O(f, f, [h, h, h]), f
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this.getProjectionData({
              overscaledTileID: new l.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return a.tileMercatorCoords = [0, 0, 1, 1], a
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class Tl {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, c = !0) {
            this._helper.resize(e, a, c)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (a, c) => this.currentTransform.defaultConstrain(a, c), this._helper = new Wn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, c) => this.defaultConstrain(a, c)
            }, e), this._globeness = 1, this._mercatorTransform = new Pi, this._verticalPerspectiveTransform = new kl
          }
          clone() {
            const e = new Tl;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e),
              c = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? c.mainMatrix : a.mainMatrix,
              clippingPlane: c.clippingPlane,
              tileMercatorCoords: c.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: a.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return l.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return l.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, a, c) {
            const h = this._mercatorTransform.getPitchedTextCorrection(e, a, c),
              f = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, c);
            return l.bn(h, f, this._globeness)
          }
          projectTileCoordinates(e, a, c, h) {
            return this.currentTransform.projectTileCoordinates(e, a, c, h)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, h)
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a)
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a)
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a)
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const c = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return c.fallbackMatrix = a.mainMatrix, c
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Ua {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, a) {
            const c = wl(e, a);
            return Math.abs(c.lng - a.center.lng) > 180 && (c.lng = a.center.lng + 179.5 * Math.sign(c.lng - a.center.lng)), {
              easingCenter: c,
              easingOffset: new l.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const c = e.around,
              h = a.screenPointToLocation(c);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const f = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const v = a.zoom - f;
            if (v === 0) return;
            const w = l.bD(a.center.lng, h.lng),
              T = w / (Math.abs(w / 180) + 1),
              C = l.bD(a.center.lat, h.lat),
              A = a.getRayDirectionFromPixel(c),
              j = a.cameraPosition,
              R = -1 * l.a_(j, A),
              Z = l.bs();
            l.aV(Z, j, [A[0] * R, A[1] * R, A[2] * R]);
            const Y = l.b0(Z) - 1,
              oe = Math.exp(.5 * -Math.max(Y - .3, 0)),
              le = Va(a.worldSize, a.center.lat) / Math.min(a.width, a.height),
              ce = l.bq(le, .9, .5, 1, .25),
              me = (1 - l.al(-v)) * Math.min(oe, ce),
              Se = a.center.lat,
              fe = a.zoom,
              Pe = new l.U(a.center.lng + T * me, l.ai(a.center.lat + C * me, -l.aj, l.aj));
            a.setLocationAtPoint(h, c);
            const Ae = a.center,
              ve = l.bq(Math.abs(w), 45, 85, 0, 1),
              Oe = l.bq(le, .75, .35, 0, 1),
              ct = Math.pow(Math.max(ve, Oe), .25),
              it = l.bD(Ae.lng, Pe.lng),
              st = l.bD(Ae.lat, Pe.lat);
            a.setCenter(new l.U(Ae.lng + it * ct, Ae.lat + st * ct).wrap()), a.setZoom(fe + Hn(Se, a.center.lat))
          }
          handleMapControlsPan(e, a, c) {
            if (!e.panDelta) return;
            const h = a.center.lat,
              f = a.zoom;
            a.setCenter(wl(e.panDelta, a).wrap()), a.setZoom(f + Hn(h, a.center.lat))
          }
          cameraForBoxAndBearing(e, a, c, h, f) {
            const v = Mi(e, a, c, h, f),
              w = a.left / f.width * 2 - 1,
              T = (f.width - a.right) / f.width * 2 - 1,
              C = a.top / f.height * -2 + 1,
              A = (f.height - a.bottom) / f.height * -2 + 1,
              j = l.bD(c.getWest(), c.getEast()) < 0,
              R = j ? c.getEast() : c.getWest(),
              Z = j ? c.getWest() : c.getEast(),
              Y = Math.max(c.getNorth(), c.getSouth()),
              oe = Math.min(c.getNorth(), c.getSouth()),
              le = R + .5 * l.bD(R, Z),
              ce = Y + .5 * l.bD(Y, oe),
              me = f.clone();
            me.setCenter(v.center), me.setBearing(v.bearing), me.setPitch(0), me.setRoll(0), me.setZoom(v.zoom);
            const Se = me.modelViewProjectionMatrix,
              fe = [pi(c.getNorthWest()), pi(c.getNorthEast()), pi(c.getSouthWest()), pi(c.getSouthEast()), pi(new l.U(Z, ce)), pi(new l.U(R, ce)), pi(new l.U(le, Y)), pi(new l.U(le, oe))],
              Pe = pi(v.center);
            let Ae = Number.POSITIVE_INFINITY;
            for (const ve of fe) w < 0 && (Ae = Ua.getLesserNonNegativeNonNull(Ae, Ua.solveVectorScale(ve, Pe, Se, "x", w))), T > 0 && (Ae = Ua.getLesserNonNegativeNonNull(Ae, Ua.solveVectorScale(ve, Pe, Se, "x", T))), C > 0 && (Ae = Ua.getLesserNonNegativeNonNull(Ae, Ua.solveVectorScale(ve, Pe, Se, "y", C))), A < 0 && (Ae = Ua.getLesserNonNegativeNonNull(Ae, Ua.solveVectorScale(ve, Pe, Se, "y", A)));
            if (Number.isFinite(Ae) && Ae !== 0) return v.zoom = me.zoom + l.ao(Ae), v;
            Qn()
          }
          handleJumpToCenterZoom(e, a) {
            const c = e.center.lat,
              h = e.constrain(a.center ? l.U.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(h.wrap());
            const f = a.zoom !== void 0 ? +a.zoom : e.zoom + Hn(c, h.lat);
            e.zoom !== f && e.setZoom(f)
          }
          handleEaseTo(e, a) {
            const c = e.zoom,
              h = e.center,
              f = e.padding,
              v = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              w = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              T = a.zoom !== void 0,
              C = !e.isPaddingEqual(a.padding);
            let A = !1;
            const j = a.center ? l.U.convert(a.center) : h,
              R = e.constrain(j, c).center;
            un(e, R);
            const Z = e.clone();
            Z.setCenter(R), Z.setZoom(T ? +a.zoom : c + Hn(h.lat, j.lat)), Z.setBearing(a.bearing);
            const Y = new l.P(l.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), l.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            Z.setLocationAtPoint(R, Y);
            const oe = (a.offset && a.offsetAsPoint.mag()) > 0 ? Z.center : R,
              le = T ? +a.zoom : c + Hn(h.lat, oe.lat),
              ce = c + Hn(h.lat, 0),
              me = le + Hn(oe.lat, 0),
              Se = l.bD(h.lng, oe.lng),
              fe = l.bD(h.lat, oe.lat),
              Pe = l.al(me - ce);
            return A = le !== c, {
              easeFunc: Ae => {
                if (l.bh(v, w) || hi({
                    startEulerAngles: v,
                    endEulerAngles: w,
                    tr: e,
                    k: Ae,
                    useSlerp: v.roll != w.roll
                  }), C && e.interpolatePadding(f, a.padding, Ae), a.around) l.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const ve = me > ce ? Math.min(2, Pe) : Math.max(.5, Pe),
                    Oe = Math.pow(ve, 1 - Ae),
                    ct = Ns(h, Se, fe, Ae * Oe);
                  e.setCenter(ct.wrap())
                }
                if (A) {
                  const ve = l.F.number(ce, me, Ae) + Hn(0, e.center.lat);
                  e.setZoom(ve)
                }
              },
              isZooming: A,
              elevationCenter: oe
            }
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0,
              h = e.center,
              f = e.zoom,
              v = e.padding,
              w = !e.isPaddingEqual(a.padding),
              T = e.constrain(l.U.convert(a.center || a.locationAtOffset), f).center,
              C = c ? +a.zoom : e.zoom + Hn(e.center.lat, T.lat),
              A = e.clone();
            A.setCenter(T), A.setZoom(C), A.setBearing(a.bearing);
            const j = new l.P(l.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), l.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            A.setLocationAtPoint(T, j);
            const R = A.center;
            un(e, R);
            const Z = (function(fe, Pe, Ae) {
                const ve = pi(Pe),
                  Oe = pi(Ae),
                  ct = l.a_(ve, Oe),
                  it = Math.acos(ct),
                  st = Ii(fe);
                return it / (2 * Math.PI) * st
              })(e, h, R),
              Y = f + Hn(h.lat, 0),
              oe = C + Hn(R.lat, 0),
              le = l.al(oe - Y);
            let ce;
            if (typeof a.minZoom == "number") {
              const fe = +a.minZoom + Hn(R.lat, 0),
                Pe = Math.min(fe, Y, oe) + Hn(0, R.lat),
                Ae = e.constrain(R, Pe).zoom + Hn(R.lat, 0);
              ce = l.al(Ae - Y)
            }
            const me = l.bD(h.lng, R.lng),
              Se = l.bD(h.lat, R.lat);
            return {
              easeFunc: (fe, Pe, Ae, ve) => {
                const Oe = Ns(h, me, Se, Ae);
                w && e.interpolatePadding(v, a.padding, fe);
                const ct = fe === 1 ? R : Oe;
                e.setCenter(ct.wrap());
                const it = Y + l.ao(Pe);
                e.setZoom(fe === 1 ? C : it + Hn(0, ct.lat))
              },
              scaleOfZoom: le,
              targetCenter: R,
              scaleOfMinZoom: ce,
              pixelPathLength: Z
            }
          }
          static solveVectorScale(e, a, c, h, f) {
            const v = h === "x" ? [c[0], c[4], c[8], c[12]] : [c[1], c[5], c[9], c[13]],
              w = [c[3], c[7], c[11], c[15]],
              T = e[0] * v[0] + e[1] * v[1] + e[2] * v[2],
              C = e[0] * w[0] + e[1] * w[1] + e[2] * w[2],
              A = a[0] * v[0] + a[1] * v[1] + a[2] * v[2],
              j = a[0] * w[0] + a[1] * w[1] + a[2] * w[2];
            return A + f * C === T + f * j || w[3] * (T - A) + v[3] * (j - C) + T * j == A * C ? null : (A + v[3] - f * j - f * w[3]) / (A - T - f * j + f * C)
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e
          }
        }
        class Vs {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new Ni, this._verticalPerspectiveCameraHelper = new Ua
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a)
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a)
          }
          handleMapControlsPan(e, a, c) {
            this.currentHelper.handleMapControlsPan(e, a, c)
          }
          cameraForBoxAndBearing(e, a, c, h, f) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, c, h, f)
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a)
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a)
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a)
          }
        }
        const ys = (d, e) => l.z(d, e && e.filter((a => a.identifier !== "source.canvas"))),
          Sl = l.bH();
        class Us extends l.E {
          constructor(e, a = {}) {
            var c, h;
            super(), this._rtlPluginLoaded = () => {
              for (const v in this.tileManagers) {
                const w = this.tileManagers[v].getSource().type;
                w !== "vector" && w !== "geojson" || this.tileManagers[v].reload()
              }
            }, this.map = e, this.dispatcher = new nt(ot(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((v, w) => this.getGlyphs(v, w))), this.dispatcher.registerMessageHandler("GI", ((v, w) => this.getImages(v, w))), this.dispatcher.registerMessageHandler("GDA", ((v, w) => this.getDashes(v, w))), this.imageManager = new Ne, this.imageManager.setEventedParent(this);
            const f = ((c = e._container) === null || c === void 0 ? void 0 : c.lang) || typeof document < "u" && ((h = document.documentElement) === null || h === void 0 ? void 0 : h.lang) || void 0;
            this.glyphManager = new Vt(e._requestManager, a.localIdeographFontFamily, f), this.lineAtlas = new Rt(256, 512), this.crossTileSymbolIndex = new Ar, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new l.bI, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", l.bJ()), N().on(sr, this._rtlPluginLoaded), this.on("data", (v => {
              if (v.dataType !== "source" || v.sourceDataType !== "metadata") return;
              const w = this.tileManagers[v.sourceId];
              if (!w) return;
              const T = w.getSource();
              if (T && T.vectorLayerIds)
                for (const C in this._layers) {
                  const A = this._layers[C];
                  A.source === T.id && this._validateLayer(A)
                }
            }))
          }
          setGlobalStateProperty(e, a) {
            var c, h, f;
            this._checkLoaded();
            const v = a === null ? (f = (h = (c = this.stylesheet.state) === null || c === void 0 ? void 0 : c[e]) === null || h === void 0 ? void 0 : h.default) !== null && f !== void 0 ? f : null : a;
            if (l.bK(v, this._globalState[e])) return this;
            this._globalState[e] = v, this._applyGlobalStateChanges([e])
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const c in e) !l.bK(this._globalState[c], e[c].default) && (a.push(c), this._globalState[c] = e[c].default);
            this._applyGlobalStateChanges(a)
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = new Set,
              c = {};
            for (const h of e) {
              c[h] = this._globalState[h];
              for (const f in this._layers) {
                const v = this._layers[f],
                  w = v.getLayoutAffectingGlobalStateRefs(),
                  T = v.getPaintAffectingGlobalStateRefs();
                if (w.has(h) && a.add(v.source), T.has(h))
                  for (const {
                      name: C,
                      value: A
                    }
                    of T.get(h)) this._updatePaintProperty(v, C, A)
              }
            }
            this.dispatcher.broadcast("UGS", c);
            for (const h in this.tileManagers) a.has(h) && (this._reloadSource(h), this._changed = !0)
          }
          loadURL(e, a = {}, c) {
            this.fire(new l.l("dataloading", {
              dataType: "style"
            })), a.validate = typeof a.validate != "boolean" || a.validate;
            const h = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const f = this._loadStyleRequest;
            l.j(h, this._loadStyleRequest).then((v => {
              this._loadStyleRequest = null, this._load(v.data, a, c)
            })).catch((v => {
              this._loadStyleRequest = null, v && !f.signal.aborted && this.fire(new l.k(v))
            }))
          }
          loadJSON(e, a = {}, c) {
            this.fire(new l.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, se.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== !1, this._load(e, a, c)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new l.l("dataloading", {
              dataType: "style"
            })), this._load(Sl, {
              validate: !1
            })
          }
          _load(e, a, c) {
            var h, f;
            let v = a.transformStyle ? a.transformStyle(c, e) : e;
            if (!a.validate || !ys(this, l.B(v))) {
              v = Object.assign({}, v), this._loaded = !0, this.stylesheet = v;
              for (const w in v.sources) this.addSource(w, v.sources[w], {
                validate: !1
              });
              v.sprite ? this._loadSprite(v.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(v.glyphs), this._createLayers(), this.light = new lt(this.stylesheet.light), this._setProjectionInternal(((h = this.stylesheet.projection) === null || h === void 0 ? void 0 : h.type) || "mercator"), this.sky = new yt(this.stylesheet.sky), this.map.setTerrain((f = this.stylesheet.terrain) !== null && f !== void 0 ? f : null), this.fire(new l.l("data", {
                dataType: "style"
              })), this.fire(new l.l("style.load"))
            }
          }
          _createLayers() {
            var e, a, c;
            const h = l.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", h), this._order = h.map((f => f.id)), this._layers = {}, this._serializedLayers = null;
            for (const f of h) {
              const v = l.bM(f, this._globalState);
              if (v.setEventedParent(this, {
                  layer: {
                    id: f.id
                  }
                }), this._layers[f.id] = v, l.bN(v) && this.tileManagers[v.source]) {
                const w = (c = (a = f.paint) === null || a === void 0 ? void 0 : a["raster-fade-duration"]) !== null && c !== void 0 ? c : v.paint.get("raster-fade-duration");
                this.tileManagers[v.source].setRasterFadeDuration(w)
              }
            }
          }
          _loadSprite(e, a = !1, c = void 0) {
            let h;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(f, v, w, T) {
              return l._(this, void 0, void 0, (function*() {
                const C = De(f),
                  A = w > 1 ? "@2x" : "",
                  j = {},
                  R = {};
                for (const {
                    id: Z,
                    url: Y
                  }
                  of C) {
                  const oe = v.transformRequest(Ke(Y, A, ".json"), "SpriteJSON");
                  j[Z] = l.j(oe, T);
                  const le = v.transformRequest(Ke(Y, A, ".png"), "SpriteImage");
                  R[Z] = Ye.getImage(le, T)
                }
                return yield Promise.all([...Object.values(j), ...Object.values(R)]), (function(Z, Y) {
                  return l._(this, void 0, void 0, (function*() {
                    const oe = {};
                    for (const le in Z) {
                      oe[le] = {};
                      const ce = se.getImageCanvasContext((yield Y[le]).data),
                        me = (yield Z[le]).data;
                      for (const Se in me) {
                        const {
                          width: fe,
                          height: Pe,
                          x: Ae,
                          y: ve,
                          sdf: Oe,
                          pixelRatio: ct,
                          stretchX: it,
                          stretchY: st,
                          content: ut,
                          textFitWidth: or,
                          textFitHeight: cr
                        } = me[Se];
                        oe[le][Se] = {
                          data: null,
                          pixelRatio: ct,
                          sdf: Oe,
                          stretchX: it,
                          stretchY: st,
                          content: ut,
                          textFitWidth: or,
                          textFitHeight: cr,
                          spriteData: {
                            width: fe,
                            height: Pe,
                            x: Ae,
                            y: ve,
                            context: ce
                          }
                        }
                      }
                    }
                    return oe
                  }))
                })(j, R)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((f => {
              if (this._spriteRequest = null, f)
                for (const v in f) {
                  this._spritesImagesIds[v] = [];
                  const w = this._spritesImagesIds[v] ? this._spritesImagesIds[v].filter((T => !(T in f))) : [];
                  for (const T of w) this.imageManager.removeImage(T), this._changedImages[T] = !0;
                  for (const T in f[v]) {
                    const C = v === "default" ? T : `${v}:${T}`;
                    this._spritesImagesIds[v].push(C), C in this.imageManager.images ? this.imageManager.updateImage(C, f[v][T], !1) : this.imageManager.addImage(C, f[v][T]), a && (this._changedImages[C] = !0)
                  }
                }
            })).catch((f => {
              this._spriteRequest = null, h = f, this.fire(new l.k(h))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), a && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
                dataType: "style"
              })), c && c(h)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const a = this.tileManagers[e.source];
            if (!a) return;
            const c = e.sourceLayer;
            if (!c) return;
            const h = a.getSource();
            (h.type === "geojson" || h.vectorLayerIds && h.vectorLayerIds.indexOf(c) === -1) && this.fire(new l.k(new Error(`Source layer "${c}" does not exist on source "${h.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers)
              if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, a = !1) {
            const c = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? l.bO(c) : c);
            const h = [];
            for (const f of e)
              if (c[f]) {
                const v = a ? l.bO(c[f]) : c[f];
                h.push(v)
              } return h
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const c of a) {
              const h = this._layers[c];
              h.type !== "custom" && (e[c] = h.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, a, c;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((c = this.projection) === null || c === void 0) && c.hasTransition()) return !0;
            for (const h in this.tileManagers)
              if (this.tileManagers[h].hasTransition()) return !0;
            for (const h in this._layers)
              if (this._layers[h].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const h = Object.keys(this._updatedLayers),
                f = Object.keys(this._removedLayers);
              (h.length || f.length) && this._updateWorkerLayers(h, f);
              for (const v in this._updatedSources) {
                const w = this._updatedSources[v];
                if (w === "reload") this._reloadSource(v);
                else {
                  if (w !== "clear") throw new Error(`Invalid action ${w}`);
                  this._clearSource(v)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const v in this._updatedPaintProps) this._layers[v].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const c = {};
            for (const h in this.tileManagers) {
              const f = this.tileManagers[h];
              c[h] = f.used, f.used = !1
            }
            for (const h of this._order) {
              const f = this._layers[h];
              f.recalculate(e, this._availableImages), !f.isHidden(e.zoom) && f.source && (this.tileManagers[f.source].used = !0)
            }
            for (const h in c) {
              const f = this.tileManagers[h];
              !!c[h] != !!f.used && f.fire(new l.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: h
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new l.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.tileManagers) this.tileManagers[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: a
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, a = {}) {
            var c;
            this._checkLoaded();
            const h = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(h, e) : e, ((c = a.validate) === null || c === void 0 || c) && ys(this, l.B(e))) return !1;
            (e = l.bO(e)).layers = l.bL(e.layers);
            const f = l.bP(h, e),
              v = this._getOperationsToPerform(f);
            if (v.unimplemented.length > 0) throw new Error(`Unimplemented: ${v.unimplemented.join(", ")}.`);
            if (v.operations.length === 0) return !1;
            for (const w of v.operations) w();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const a = [],
              c = [];
            for (const h of e) switch (h.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, h.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, h.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, h.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, h.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, h.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, h.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, h.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, h.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, h.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, h.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, h.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, h.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, h.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, h.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, h.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, h.args)));
                break;
              case "setTransition":
                a.push((() => {}));
                break;
              default:
                c.push(h.command)
            }
            return {
              operations: a,
              unimplemented: c
            }
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new l.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e)
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new l.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, a, c = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(l.B.source, `sources.${e}`, a, null, c)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = !0);
            const h = this.tileManagers[e] = new Tt(e, a, this.dispatcher);
            h.style = this, h.setEventedParent(this, (() => ({
              isSourceLoaded: h.loaded(),
              source: h.serialize(),
              sourceId: e
            }))), h.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const c in this._layers)
              if (this._layers[c].source === e) return this.fire(new l.k(new Error(`Source "${e}" cannot be removed while layer "${c}" is using it.`)));
            const a = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], a.fire(new l.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), a.setEventedParent(null), a.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const c = this.tileManagers[e].getSource();
            if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
            c.setData(a), this._changed = !0
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource()
          }
          addLayer(e, a, c = {}) {
            this._checkLoaded();
            const h = e.id;
            if (this.getLayer(h)) return void this.fire(new l.k(new Error(`Layer "${h}" already exists on this map.`)));
            let f;
            if (e.type === "custom") {
              if (ys(this, l.bQ(e))) return;
              f = l.bM(e, this._globalState)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(h, e.source), e = l.bO(e), e = l.e(e, {
                  source: h
                })), this._validate(l.B.layer, `layers.${h}`, e, {
                  arrayIndex: -1
                }, c)) return;
              f = l.bM(e, this._globalState), this._validateLayer(f), f.setEventedParent(this, {
                layer: {
                  id: h
                }
              })
            }
            const v = a ? this._order.indexOf(a) : this._order.length;
            if (a && v === -1) this.fire(new l.k(new Error(`Cannot add layer "${h}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(v, 0, h), this._layerOrderChanged = !0, this._layers[h] = f, this._removedLayers[h] && f.source && f.type !== "custom") {
                const w = this._removedLayers[h];
                delete this._removedLayers[h], w.type !== f.type ? this._updatedSources[f.source] = "clear" : (this._updatedSources[f.source] = "reload", this.tileManagers[f.source].pause())
              }
              this._updateLayer(f), f.onAdd && f.onAdd(this.map)
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new l.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const c = this._order.indexOf(e);
            this._order.splice(c, 1);
            const h = a ? this._order.indexOf(a) : this._order.length;
            a && h === -1 ? this.fire(new l.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(h, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new l.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const c = this._order.indexOf(e);
            this._order.splice(c, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, a, c) {
            this._checkLoaded();
            const h = this.getLayer(e);
            h ? h.minzoom === a && h.maxzoom === c || (a != null && (h.minzoom = a), c != null && (h.maxzoom = c), this._updateLayer(h)) : this.fire(new l.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, a, c = {}) {
            this._checkLoaded();
            const h = this.getLayer(e);
            if (h) {
              if (!l.bK(h.filter, a)) return a == null ? (h.setFilter(void 0), void this._updateLayer(h)) : void(this._validate(l.B.filter, `layers.${h.id}.filter`, a, null, c) || (h.setFilter(l.bO(a)), this._updateLayer(h)))
            } else this.fire(new l.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return l.bO(this.getLayer(e).filter)
          }
          setLayoutProperty(e, a, c, h = {}) {
            this._checkLoaded();
            const f = this.getLayer(e);
            f ? l.bK(f.getLayoutProperty(a), c) || (f.setLayoutProperty(a, c, h), this._updateLayer(f)) : this.fire(new l.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, a) {
            const c = this.getLayer(e);
            if (c) return c.getLayoutProperty(a);
            this.fire(new l.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, a, c, h = {}) {
            this._checkLoaded();
            const f = this.getLayer(e);
            f ? l.bK(f.getPaintProperty(a), c) || this._updatePaintProperty(f, a, c, h) : this.fire(new l.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          _updatePaintProperty(e, a, c, h = {}) {
            e.setPaintProperty(a, c, h) && this._updateLayer(e), l.bN(e) && a === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(c), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a)
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source,
              h = e.sourceLayer,
              f = this.tileManagers[c];
            if (f === void 0) return void this.fire(new l.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const v = f.getSource().type;
            v === "geojson" && h ? this.fire(new l.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : v !== "vector" || h ? (e.id === void 0 && this.fire(new l.k(new Error("The feature id parameter must be provided."))), f.setFeatureState(h, e.id, a)) : this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source,
              h = this.tileManagers[c];
            if (h === void 0) return void this.fire(new l.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const f = h.getSource().type,
              v = f === "vector" ? e.sourceLayer : void 0;
            f !== "vector" || v ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new l.k(new Error("A feature id is required to remove its specific state property."))) : h.removeFeatureState(v, e.id, a) : this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source,
              c = e.sourceLayer,
              h = this.tileManagers[a];
            if (h !== void 0) return h.getSource().type !== "vector" || c ? (e.id === void 0 && this.fire(new l.k(new Error("The feature id parameter must be provided."))), h.getFeatureState(c, e.id)) : void this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new l.k(new Error(`The source '${a}' does not exist in the map's style.`)))
          }
          getTransition() {
            return l.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = l.bR(this.tileManagers, (f => f.serialize())),
              a = this._serializeByIds(this._order, !0),
              c = this.map.getTerrain() || void 0,
              h = this.stylesheet;
            return l.bS({
              version: h.version,
              name: h.name,
              metadata: h.metadata,
              light: h.light,
              sky: h.sky,
              center: h.center,
              zoom: h.zoom,
              bearing: h.bearing,
              pitch: h.pitch,
              sprite: h.sprite,
              glyphs: h.glyphs,
              transition: h.transition,
              projection: h.projection,
              sources: e,
              layers: a,
              terrain: c
            }, (f => f !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = v => this._layers[v].type === "fill-extrusion",
              c = {},
              h = [];
            for (let v = this._order.length - 1; v >= 0; v--) {
              const w = this._order[v];
              if (a(w)) {
                c[w] = v;
                for (const T of e) {
                  const C = T[w];
                  if (C)
                    for (const A of C) h.push(A)
                }
              }
            }
            h.sort(((v, w) => w.intersectionZ - v.intersectionZ));
            const f = [];
            for (let v = this._order.length - 1; v >= 0; v--) {
              const w = this._order[v];
              if (a(w))
                for (let T = h.length - 1; T >= 0; T--) {
                  const C = h[T].feature;
                  if (c[C.layer.id] < v) break;
                  f.push(C), h.pop()
                } else
                  for (const T of e) {
                    const C = T[w];
                    if (C)
                      for (const A of C) f.push(A.feature)
                  }
            }
            return f
          }
          queryRenderedFeatures(e, a, c) {
            a && a.filter && this._validate(l.B.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const h = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new l.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const C of a.layers) {
                const A = this._layers[C];
                if (!A) return this.fire(new l.k(new Error(`The layer '${C}' does not exist in the map's style and cannot be queried for features.`))), [];
                h[A.source] = !0
              }
            }
            const f = [];
            a.availableImages = this._availableImages;
            const v = this._serializedAllLayers(),
              w = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null,
              T = Object.assign(Object.assign({}, a), {
                layers: w,
                globalState: this._globalState
              });
            for (const C in this.tileManagers) a.layers && !h[C] || f.push(Ot(this.tileManagers[C], this._layers, v, e, T, c, this.map.terrain ? (A, j, R) => this.map.terrain.getElevation(A, j, R) : void 0));
            return this.placement && f.push((function(C, A, j, R, Z, Y, oe) {
              const le = {},
                ce = Y.queryRenderedSymbols(R),
                me = [];
              for (const Se of Object.keys(ce).map(Number)) me.push(oe[Se]);
              me.sort(mr);
              for (const Se of me) {
                const fe = Se.featureIndex.lookupSymbolFeatures(ce[Se.bucketInstanceId], A, Se.bucketIndex, Se.sourceLayerIndex, {
                  filterSpec: Z.filter,
                  globalState: Z.globalState
                }, Z.layers, Z.availableImages, C);
                for (const Pe in fe) {
                  const Ae = le[Pe] = le[Pe] || [],
                    ve = fe[Pe];
                  ve.sort(((Oe, ct) => {
                    const it = Se.featureSortOrder;
                    if (it) {
                      const st = it.indexOf(Oe.featureIndex);
                      return it.indexOf(ct.featureIndex) - st
                    }
                    return ct.featureIndex - Oe.featureIndex
                  }));
                  for (const Oe of ve) Ae.push(Oe)
                }
              }
              return (function(Se, fe, Pe) {
                for (const Ae in Se)
                  for (const ve of Se[Ae]) zt(ve, Pe[fe[Ae].source]);
                return Se
              })(le, C, j)
            })(this._layers, v, this.tileManagers, e, T, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(f)
          }
          querySourceFeatures(e, a) {
            a != null && a.filter && this._validate(l.B.filter, "querySourceFeatures.filter", a.filter, null, a);
            const c = this.tileManagers[e];
            return c ? (function(h, f) {
              const v = h.getRenderableIds().map((C => h.getTileByID(C))),
                w = [],
                T = {};
              for (let C = 0; C < v.length; C++) {
                const A = v[C],
                  j = A.tileID.canonical.key;
                T[j] || (T[j] = !0, A.querySourceFeatures(w, f))
              }
              return w
            })(c, a ? Object.assign(Object.assign({}, a), {
              globalState: this._globalState
            }) : {
              globalState: this._globalState
            }) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const c = this.light.getLight();
            let h = !1;
            for (const v in e)
              if (!l.bK(e[v], c[v])) {
                h = !0;
                break
              } if (!h) return;
            const f = {
              now: ge(),
              transition: l.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, a), this.light.updateTransitions(f)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const c = this.getSky();
            let h = !1;
            if (!e && !c) return;
            if (e && !c) h = !0;
            else if (!e && c) h = !0;
            else
              for (const v in e)
                if (!l.bK(e[v], c[v])) {
                  h = !0;
                  break
                } if (!h) return;
            const f = {
              now: ge(),
              transition: l.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(f)
          }
          _setProjectionInternal(e) {
            const a = (function(c, h) {
              const f = {
                constrain: h
              };
              if (Array.isArray(c)) {
                const v = new di({
                  type: c
                });
                return {
                  projection: v,
                  transform: new Tl(f),
                  cameraHelper: new Vs(v)
                }
              }
              switch (c) {
                case "mercator":
                  return {
                    projection: new Mn, transform: new Pi(f), cameraHelper: new Ni
                  };
                case "globe": {
                  const v = new di({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: v,
                    transform: new Tl(f),
                    cameraHelper: new Vs(v)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new Na, transform: new kl(f), cameraHelper: new Ua
                  };
                default:
                  return l.w(`Unknown projection name: ${c}. Falling back to mercator projection.`), {
                    projection: new Mn,
                    transform: new Pi(f),
                    cameraHelper: new Ni
                  }
              }
            })(e, this.map.transformConstrain);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const c in this.tileManagers) this.tileManagers[c].reload()
          }
          _validate(e, a, c, h, f = {}) {
            return (!f || f.validate !== !1) && ys(this, e.call(l.B, l.e({
              key: a,
              style: this.serialize(),
              value: c,
              styleSpec: l.t
            }, h)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), N().off(sr, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.tileManagers) {
              const c = this.tileManagers[a];
              c.setEventedParent(null), c.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles()
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload()
          }
          _updateSources(e) {
            for (const a in this.tileManagers) this.tileManagers[a].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e)
          }
          _updatePlacement(e, a, c, h, f = !1) {
            let v = !1,
              w = !1;
            const T = {};
            for (const C of this._order) {
              const A = this._layers[C];
              if (A.type !== "symbol") continue;
              if (!T[A.source]) {
                const R = this.tileManagers[A.source];
                T[A.source] = R.getRenderableIds(!0).map((Z => R.getTileByID(Z))).sort(((Z, Y) => Y.tileID.overscaledZ - Z.tileID.overscaledZ || (Z.tileID.isLessThan(Y.tileID) ? -1 : 1)))
              }
              const j = this.crossTileSymbolIndex.addLayer(A, T[A.source], e.center.lng);
              v = v || j
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((f = f || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(ge(), e.zoom)) && (this.pauseablePlacement = new Ri(e, this.map.terrain, this._order, f, a, c, h, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, T), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(ge()), w = !0), v && this.pauseablePlacement.placement.setStale()), w || v)
              for (const C of this._order) {
                const A = this._layers[C];
                A.type === "symbol" && this.placement.updateLayerOpacities(A, T[A.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(ge())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles()
          }
          getImages(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const h = this.tileManagers[a.source];
              return h && h.setDependencies(a.tileID.key, a.type, a.icons), c
            }))
          }
          getGlyphs(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = yield this.glyphManager.getGlyphs(a.stacks), h = this.tileManagers[a.source];
              return h && h.setDependencies(a.tileID.key, a.type, [""]), c
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(l.B.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          getDashes(e, a) {
            return l._(this, void 0, void 0, (function*() {
              const c = {};
              for (const [h, f] of Object.entries(a.dashes)) c[h] = this.lineAtlas.getDash(f.dasharray, f.round);
              return c
            }))
          }
          addSprite(e, a, c = {}, h) {
            this._checkLoaded();
            const f = [{
                id: e,
                url: a
              }],
              v = [...De(this.stylesheet.sprite), ...f];
            this._validate(l.B.sprite, "sprite", v, null, c) || (this.stylesheet.sprite = v, this._loadSprite(f, !0, h))
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = De(this.stylesheet.sprite);
            if (a.find((c => c.id === e))) {
              if (this._spritesImagesIds[e])
                for (const c of this._spritesImagesIds[e]) this.imageManager.removeImage(c), this._changedImages[c] = !0;
              a.splice(a.findIndex((c => c.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.l("data", {
                dataType: "style"
              }))
            } else this.fire(new l.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return De(this.stylesheet.sprite)
          }
          setSprite(e, a = {}, c) {
            this._checkLoaded(), e && this._validate(l.B.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, c) : (this._unloadSprite(), c && c(null)))
          }
        }
        var Oc = l.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class ro {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, a, c, h, f, v, w, T, C) {
            this.context = e;
            let A = this.boundPaintVertexBuffers.length !== h.length;
            for (let j = 0; !A && j < h.length; j++) this.boundPaintVertexBuffers[j] !== h[j] && (A = !0);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== c || A || this.boundIndexBuffer !== f || this.boundVertexOffset !== v || this.boundDynamicVertexBuffer !== w || this.boundDynamicVertexBuffer2 !== T || this.boundDynamicVertexBuffer3 !== C ? this.freshBind(a, c, h, f, v, w, T, C) : (e.bindVertexArray.set(this.vao), w && w.bind(), f && f.dynamicDraw && f.bind(), T && T.bind(), C && C.bind())
          }
          freshBind(e, a, c, h, f, v, w, T) {
            const C = e.numAttributes,
              A = this.context,
              j = A.gl;
            this.vao && this.destroy(), this.vao = A.createVertexArray(), A.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = h, this.boundVertexOffset = f, this.boundDynamicVertexBuffer = v, this.boundDynamicVertexBuffer2 = w, this.boundDynamicVertexBuffer3 = T, a.enableAttributes(j, e);
            for (const R of c) R.enableAttributes(j, e);
            v && v.enableAttributes(j, e), w && w.enableAttributes(j, e), T && T.enableAttributes(j, e), a.bind(), a.setVertexAttribPointers(j, e, f);
            for (const R of c) R.bind(), R.setVertexAttribPointers(j, e, f);
            v && (v.bind(), v.setVertexAttribPointers(j, e, f)), h && h.bind(), w && (w.bind(), w.setVertexAttribPointers(j, e, f)), T && (T.bind(), T.setVertexAttribPointers(j, e, f)), A.currentNumAttributes = C
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const Bp = (d, e, a, c, h) => ({
            u_texture: 0,
            u_ele_delta: d,
            u_fog_matrix: e,
            u_fog_color: a ? a.properties.get("fog-color") : l.bi.white,
            u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: h ? 0 : a ? a.calculateFogBlendOpacity(c) : 0,
            u_horizon_color: a ? a.properties.get("horizon-color") : l.bi.white,
            u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: h ? 1 : 0
          }),
          qc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function So(d) {
          const e = [];
          for (let a = 0; a < d.length; a++) {
            if (d[a] === null) continue;
            const c = d[a].split(" ");
            e.push(c.pop())
          }
          return e
        }
        class Zs {
          constructor(e, a, c, h, f, v, w, T, C = []) {
            const A = e.gl;
            this.program = A.createProgram();
            const j = So(a.staticAttributes),
              R = c ? c.getBinderAttributes() : [],
              Z = j.concat(R),
              Y = Ir.prelude.staticUniforms ? So(Ir.prelude.staticUniforms) : [],
              oe = w.staticUniforms ? So(w.staticUniforms) : [],
              le = a.staticUniforms ? So(a.staticUniforms) : [],
              ce = c ? c.getBinderUniforms() : [],
              me = Y.concat(oe).concat(le).concat(ce),
              Se = [];
            for (const it of me) Se.indexOf(it) < 0 && Se.push(it);
            const fe = c ? c.defines() : [];
            Vi(A) && fe.unshift("#version 300 es"), f && fe.push("#define OVERDRAW_INSPECTOR;"), v && fe.push("#define TERRAIN3D;"), T && fe.push(T), C && fe.push(...C);
            let Pe = fe.concat(Ir.prelude.fragmentSource, w.fragmentSource, a.fragmentSource).join(`
`),
              Ae = fe.concat(Ir.prelude.vertexSource, w.vertexSource, a.vertexSource).join(`
`);
            Vi(A) || (Pe = (function(it) {
              return it.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(Pe), Ae = (function(it) {
              return it.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Ae));
            const ve = A.createShader(A.FRAGMENT_SHADER);
            if (A.isContextLost()) return void(this.failedToCreate = !0);
            if (A.shaderSource(ve, Pe), A.compileShader(ve), !A.getShaderParameter(ve, A.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${A.getShaderInfoLog(ve)}`);
            A.attachShader(this.program, ve);
            const Oe = A.createShader(A.VERTEX_SHADER);
            if (A.isContextLost()) return void(this.failedToCreate = !0);
            if (A.shaderSource(Oe, Ae), A.compileShader(Oe), !A.getShaderParameter(Oe, A.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${A.getShaderInfoLog(Oe)}`);
            A.attachShader(this.program, Oe), this.attributes = {};
            const ct = {};
            this.numAttributes = Z.length;
            for (let it = 0; it < this.numAttributes; it++) Z[it] && (A.bindAttribLocation(this.program, it, Z[it]), this.attributes[Z[it]] = it);
            if (A.linkProgram(this.program), !A.getProgramParameter(this.program, A.LINK_STATUS)) throw new Error(`Program failed to link: ${A.getProgramInfoLog(this.program)}`);
            A.deleteShader(Oe), A.deleteShader(ve);
            for (let it = 0; it < Se.length; it++) {
              const st = Se[it];
              if (st && !ct[st]) {
                const ut = A.getUniformLocation(this.program, st);
                ut && (ct[st] = ut)
              }
            }
            this.fixedUniforms = h(e, ct), this.terrainUniforms = ((it, st) => ({
              u_depth: new l.bT(it, st.u_depth),
              u_terrain: new l.bT(it, st.u_terrain),
              u_terrain_dim: new l.bj(it, st.u_terrain_dim),
              u_terrain_matrix: new l.bV(it, st.u_terrain_matrix),
              u_terrain_unpack: new l.bW(it, st.u_terrain_unpack),
              u_terrain_exaggeration: new l.bj(it, st.u_terrain_exaggeration)
            }))(e, ct), this.projectionUniforms = ((it, st) => ({
              u_projection_matrix: new l.bV(it, st.u_projection_matrix),
              u_projection_tile_mercator_coords: new l.bW(it, st.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new l.bW(it, st.u_projection_clipping_plane),
              u_projection_transition: new l.bj(it, st.u_projection_transition),
              u_projection_fallback_matrix: new l.bV(it, st.u_projection_fallback_matrix)
            }))(e, ct), this.binderUniforms = c ? c.getUniforms(e, ct) : []
          }
          draw(e, a, c, h, f, v, w, T, C, A, j, R, Z, Y, oe, le, ce, me, Se) {
            const fe = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(c), e.setStencilMode(h), e.setColorMode(f), e.setCullFace(v), T) {
              e.activeTexture.set(fe.TEXTURE2), fe.bindTexture(fe.TEXTURE_2D, T.depthTexture), e.activeTexture.set(fe.TEXTURE3), fe.bindTexture(fe.TEXTURE_2D, T.texture);
              for (const Ae in this.terrainUniforms) this.terrainUniforms[Ae].set(T[Ae])
            }
            if (C)
              for (const Ae in C) this.projectionUniforms[qc[Ae]].set(C[Ae]);
            if (w)
              for (const Ae in this.fixedUniforms) this.fixedUniforms[Ae].set(w[Ae]);
            le && le.setUniforms(e, this.binderUniforms, Y, {
              zoom: oe
            });
            let Pe = 0;
            switch (a) {
              case fe.LINES:
                Pe = 2;
                break;
              case fe.TRIANGLES:
                Pe = 3;
                break;
              case fe.LINE_STRIP:
                Pe = 1
            }
            for (const Ae of Z.get()) {
              const ve = Ae.vaos || (Ae.vaos = {});
              (ve[A] || (ve[A] = new ro)).bind(e, this, j, le ? le.getPaintVertexBuffers() : [], R, Ae.vertexOffset, ce, me, Se), fe.drawElements(a, Ae.primitiveLength * Pe, fe.UNSIGNED_SHORT, Ae.primitiveOffset * Pe * 2)
            }
          }
        }

        function jh(d, e, a) {
          const c = 1 / l.aG(a, 1, e.transform.tileZoom),
            h = Math.pow(2, a.tileID.overscaledZ),
            f = a.tileSize * Math.pow(2, e.transform.tileZoom) / h,
            v = f * (a.tileID.canonical.x + a.tileID.wrap * h),
            w = f * a.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: a.imageAtlasTexture.size,
            u_scale: [c, d.fromScale, d.toScale],
            u_fade: d.t,
            u_pixel_coord_upper: [v >> 16, w >> 16],
            u_pixel_coord_lower: [65535 & v, 65535 & w]
          }
        }
        const Gs = (d, e, a, c) => {
            const h = d.style.light,
              f = h.properties.get("position"),
              v = [f.x, f.y, f.z],
              w = l.bZ();
            h.properties.get("anchor") === "viewport" && l.b_(w, d.transform.bearingInRadians), l.b$(v, v, w);
            const T = d.transform.transformLightDirection(v),
              C = h.properties.get("color");
            return {
              u_lightpos: v,
              u_lightpos_globe: T,
              u_lightintensity: h.properties.get("intensity"),
              u_lightcolor: [C.r, C.g, C.b],
              u_vertical_gradient: +e,
              u_opacity: a,
              u_fill_translate: c
            }
          },
          Op = (d, e, a, c, h, f, v) => l.e(Gs(d, e, a, c), jh(f, d, v), {
            u_height_factor: -Math.pow(2, h.overscaledZ) / v.tileSize / 8
          }),
          qo = (d, e, a, c) => l.e(jh(e, d, a), {
            u_fill_translate: c
          }),
          qp = (d, e) => ({
            u_world: d,
            u_fill_translate: e
          }),
          Fh = (d, e, a, c, h) => l.e(qo(d, e, a, h), {
            u_world: c
          }),
          Np = (d, e, a, c, h) => {
            const f = d.transform;
            let v, w, T = 0;
            if (a.paint.get("circle-pitch-alignment") === "map") {
              const C = l.aG(e, 1, f.zoom);
              v = !0, w = [C, C], T = C / (l.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * h
            } else v = !1, w = f.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: f.cameraToCenterDistance,
              u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +v,
              u_device_pixel_ratio: d.pixelRatio,
              u_extrude_scale: w,
              u_globe_extrude_scale: T,
              u_translate: c
            }
          },
          Bh = d => ({
            u_pixel_extrude_scale: [1 / d.width, 1 / d.height]
          }),
          Nc = d => ({
            u_viewport_size: [d.width, d.height]
          }),
          Vc = (d, e = 1) => ({
            u_color: d,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Uc = (d, e, a, c) => {
            const h = l.aG(d, 1, e) / (l.a3 * Math.pow(2, d.tileID.overscaledZ)) * 2 * Math.PI * c;
            return {
              u_extrude_scale: l.aG(d, 1, e),
              u_intensity: a,
              u_globe_extrude_scale: h
            }
          },
          Zc = (d, e, a, c) => {
            const h = l.M();
            l.c0(h, 0, d.width, d.height, 0, 0, 1);
            const f = d.context.gl;
            return {
              u_matrix: h,
              u_world: [f.drawingBufferWidth, f.drawingBufferHeight],
              u_image: a,
              u_color_ramp: c,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          Oh = (d, e, a) => {
            const c = a.paint.get("hillshade-accent-color");
            let h;
            switch (a.paint.get("hillshade-method")) {
              case "basic":
                h = 4;
                break;
              case "combined":
                h = 1;
                break;
              case "igor":
                h = 2;
                break;
              case "multidirectional":
                h = 3;
                break;
              default:
                h = 0
            }
            const f = a.getIlluminationProperties();
            for (let v = 0; v < f.directionRadians.length; v++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (f.directionRadians[v] += d.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: qh(0, e.tileID),
              u_exaggeration: a.paint.get("hillshade-exaggeration"),
              u_altitudes: f.altitudeRadians,
              u_azimuths: f.directionRadians,
              u_accent: c,
              u_method: h,
              u_highlights: f.highlightColor,
              u_shadows: f.shadowColor
            }
          },
          No = (d, e) => {
            const a = e.stride,
              c = l.M();
            return l.c0(c, 0, l.a3, -l.a3, 0, 0, 1), l.N(c, c, [0, -l.a3, 0]), {
              u_matrix: c,
              u_image: 1,
              u_dimension: [a, a],
              u_zoom: d.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function qh(d, e) {
          const a = Math.pow(2, e.canonical.z),
            c = e.canonical.y;
          return [new l.a5(0, c / a).toLngLat().lat, new l.a5(0, (c + 1) / a).toLngLat().lat]
        }
        const Nh = (d, e, a = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: a,
            u_opacity: d.paint.get("color-relief-opacity")
          }),
          Po = (d, e, a, c) => {
            const h = d.transform;
            return {
              u_translation: Gc(d, e, a),
              u_ratio: c / l.aG(e, 1, h.zoom),
              u_device_pixel_ratio: d.pixelRatio,
              u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]]
            }
          },
          Vp = (d, e, a, c, h) => l.e(Po(d, e, a, c), {
            u_image: 0,
            u_image_height: h
          }),
          Pl = (d, e, a, c, h) => {
            const f = d.transform,
              v = Ml(e, f);
            return {
              u_translation: Gc(d, e, a),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: c / l.aG(e, 1, f.zoom),
              u_device_pixel_ratio: d.pixelRatio,
              u_image: 0,
              u_scale: [v, h.fromScale, h.toScale],
              u_fade: h.t,
              u_units_to_pixels: [1 / f.pixelsToGLUnits[0], 1 / f.pixelsToGLUnits[1]]
            }
          },
          Up = (d, e, a, c, h) => {
            const f = Ml(e, d.transform);
            return l.e(Po(d, e, a, c), {
              u_tileratio: f,
              u_crossfade_from: h.fromScale,
              u_crossfade_to: h.toScale,
              u_image: 0,
              u_mix: h.t,
              u_lineatlas_width: d.lineAtlas.width,
              u_lineatlas_height: d.lineAtlas.height
            })
          },
          Zp = (d, e, a, c, h, f) => {
            const v = Ml(e, d.transform);
            return l.e(Po(d, e, a, c), {
              u_image: 0,
              u_image_height: f,
              u_tileratio: v,
              u_crossfade_from: h.fromScale,
              u_crossfade_to: h.toScale,
              u_image_dash: 1,
              u_mix: h.t,
              u_lineatlas_width: d.lineAtlas.width,
              u_lineatlas_height: d.lineAtlas.height
            })
          };

        function Ml(d, e) {
          return 1 / l.aG(d, 1, e.tileZoom)
        }

        function Gc(d, e, a) {
          return l.aH(d.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"))
        }
        const Vh = (d, e, a, c, h) => {
          return {
            u_tl_parent: d,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: a.mix,
            u_opacity: a.opacity * c.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: c.paint.get("raster-brightness-min"),
            u_brightness_high: c.paint.get("raster-brightness-max"),
            u_saturation_factor: (v = c.paint.get("raster-saturation"), v > 0 ? 1 - 1 / (1.001 - v) : -v),
            u_contrast_factor: (f = c.paint.get("raster-contrast"), f > 0 ? 1 / (1 - f) : 1 + f),
            u_spin_weights: Wc(c.paint.get("raster-hue-rotate")),
            u_coords_top: [h[0].x, h[0].y, h[1].x, h[1].y],
            u_coords_bottom: [h[3].x, h[3].y, h[2].x, h[2].y]
          };
          var f, v
        };

        function Wc(d) {
          d *= Math.PI / 180;
          const e = Math.sin(d),
            a = Math.cos(d);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3]
        }
        const Hc = (d, e, a, c, h, f, v, w, T, C, A, j, R) => {
            const Z = v.transform;
            return {
              u_is_size_zoom_constant: +(d === "constant" || d === "source"),
              u_is_size_feature_constant: +(d === "constant" || d === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: Z.cameraToCenterDistance,
              u_pitch: Z.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +a,
              u_aspect_ratio: Z.width / Z.height,
              u_fade_change: v.options.fadeDuration ? v.symbolFadeChange : 1,
              u_label_plane_matrix: w,
              u_coord_matrix: T,
              u_is_text: +A,
              u_pitch_with_map: +c,
              u_is_along_line: h,
              u_is_variable_anchor: f,
              u_texsize: j,
              u_texture: 0,
              u_translation: C,
              u_pitched_scale: R
            }
          },
          Ws = (d, e, a, c, h, f, v, w, T, C, A, j, R, Z) => {
            const Y = v.transform;
            return l.e(Hc(d, e, a, c, h, f, v, w, T, C, A, j, Z), {
              u_gamma_scale: c ? Math.cos(Y.pitch * Math.PI / 180) * Y.cameraToCenterDistance : 1,
              u_device_pixel_ratio: v.pixelRatio,
              u_is_halo: 1
            })
          },
          lo = (d, e, a, c, h, f, v, w, T, C, A, j, R) => l.e(Ws(d, e, a, c, h, f, v, w, T, C, !0, A, 0, R), {
            u_texsize_icon: j,
            u_texture_icon: 1
          }),
          $c = (d, e) => ({
            u_opacity: d,
            u_color: e
          }),
          Xc = (d, e, a, c, h) => l.e((function(f, v, w, T) {
            const C = w.imageManager.getPattern(f.from.toString()),
              A = w.imageManager.getPattern(f.to.toString()),
              {
                width: j,
                height: R
              } = w.imageManager.getPixelSize(),
              Z = Math.pow(2, T.tileID.overscaledZ),
              Y = T.tileSize * Math.pow(2, w.transform.tileZoom) / Z,
              oe = Y * (T.tileID.canonical.x + T.tileID.wrap * Z),
              le = Y * T.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: C.tl,
              u_pattern_br_a: C.br,
              u_pattern_tl_b: A.tl,
              u_pattern_br_b: A.br,
              u_texsize: [j, R],
              u_mix: v.t,
              u_pattern_size_a: C.displaySize,
              u_pattern_size_b: A.displaySize,
              u_scale_a: v.fromScale,
              u_scale_b: v.toScale,
              u_tile_units_to_pixels: 1 / l.aG(T, 1, w.transform.tileZoom),
              u_pixel_coord_upper: [oe >> 16, le >> 16],
              u_pixel_coord_lower: [65535 & oe, 65535 & le]
            }
          })(a, h, e, c), {
            u_opacity: d
          }),
          Il = (d, e) => {},
          Uh = {
            fillExtrusion: (d, e) => ({
              u_lightpos: new l.bX(d, e.u_lightpos),
              u_lightpos_globe: new l.bX(d, e.u_lightpos_globe),
              u_lightintensity: new l.bj(d, e.u_lightintensity),
              u_lightcolor: new l.bX(d, e.u_lightcolor),
              u_vertical_gradient: new l.bj(d, e.u_vertical_gradient),
              u_opacity: new l.bj(d, e.u_opacity),
              u_fill_translate: new l.bY(d, e.u_fill_translate)
            }),
            fillExtrusionPattern: (d, e) => ({
              u_lightpos: new l.bX(d, e.u_lightpos),
              u_lightpos_globe: new l.bX(d, e.u_lightpos_globe),
              u_lightintensity: new l.bj(d, e.u_lightintensity),
              u_lightcolor: new l.bX(d, e.u_lightcolor),
              u_vertical_gradient: new l.bj(d, e.u_vertical_gradient),
              u_height_factor: new l.bj(d, e.u_height_factor),
              u_opacity: new l.bj(d, e.u_opacity),
              u_fill_translate: new l.bY(d, e.u_fill_translate),
              u_image: new l.bT(d, e.u_image),
              u_texsize: new l.bY(d, e.u_texsize),
              u_pixel_coord_upper: new l.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(d, e.u_pixel_coord_lower),
              u_scale: new l.bX(d, e.u_scale),
              u_fade: new l.bj(d, e.u_fade)
            }),
            fill: (d, e) => ({
              u_fill_translate: new l.bY(d, e.u_fill_translate)
            }),
            fillPattern: (d, e) => ({
              u_image: new l.bT(d, e.u_image),
              u_texsize: new l.bY(d, e.u_texsize),
              u_pixel_coord_upper: new l.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(d, e.u_pixel_coord_lower),
              u_scale: new l.bX(d, e.u_scale),
              u_fade: new l.bj(d, e.u_fade),
              u_fill_translate: new l.bY(d, e.u_fill_translate)
            }),
            fillOutline: (d, e) => ({
              u_world: new l.bY(d, e.u_world),
              u_fill_translate: new l.bY(d, e.u_fill_translate)
            }),
            fillOutlinePattern: (d, e) => ({
              u_world: new l.bY(d, e.u_world),
              u_image: new l.bT(d, e.u_image),
              u_texsize: new l.bY(d, e.u_texsize),
              u_pixel_coord_upper: new l.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(d, e.u_pixel_coord_lower),
              u_scale: new l.bX(d, e.u_scale),
              u_fade: new l.bj(d, e.u_fade),
              u_fill_translate: new l.bY(d, e.u_fill_translate)
            }),
            circle: (d, e) => ({
              u_camera_to_center_distance: new l.bj(d, e.u_camera_to_center_distance),
              u_scale_with_map: new l.bT(d, e.u_scale_with_map),
              u_pitch_with_map: new l.bT(d, e.u_pitch_with_map),
              u_extrude_scale: new l.bY(d, e.u_extrude_scale),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new l.bj(d, e.u_globe_extrude_scale),
              u_translate: new l.bY(d, e.u_translate)
            }),
            collisionBox: (d, e) => ({
              u_pixel_extrude_scale: new l.bY(d, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (d, e) => ({
              u_viewport_size: new l.bY(d, e.u_viewport_size)
            }),
            debug: (d, e) => ({
              u_color: new l.bU(d, e.u_color),
              u_overlay: new l.bT(d, e.u_overlay),
              u_overlay_scale: new l.bj(d, e.u_overlay_scale)
            }),
            depth: Il,
            clippingMask: Il,
            heatmap: (d, e) => ({
              u_extrude_scale: new l.bj(d, e.u_extrude_scale),
              u_intensity: new l.bj(d, e.u_intensity),
              u_globe_extrude_scale: new l.bj(d, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (d, e) => ({
              u_matrix: new l.bV(d, e.u_matrix),
              u_world: new l.bY(d, e.u_world),
              u_image: new l.bT(d, e.u_image),
              u_color_ramp: new l.bT(d, e.u_color_ramp),
              u_opacity: new l.bj(d, e.u_opacity)
            }),
            hillshade: (d, e) => ({
              u_image: new l.bT(d, e.u_image),
              u_latrange: new l.bY(d, e.u_latrange),
              u_exaggeration: new l.bj(d, e.u_exaggeration),
              u_altitudes: new l.c2(d, e.u_altitudes),
              u_azimuths: new l.c2(d, e.u_azimuths),
              u_accent: new l.bU(d, e.u_accent),
              u_method: new l.bT(d, e.u_method),
              u_shadows: new l.c1(d, e.u_shadows),
              u_highlights: new l.c1(d, e.u_highlights)
            }),
            hillshadePrepare: (d, e) => ({
              u_matrix: new l.bV(d, e.u_matrix),
              u_image: new l.bT(d, e.u_image),
              u_dimension: new l.bY(d, e.u_dimension),
              u_zoom: new l.bj(d, e.u_zoom),
              u_unpack: new l.bW(d, e.u_unpack)
            }),
            colorRelief: (d, e) => ({
              u_image: new l.bT(d, e.u_image),
              u_unpack: new l.bW(d, e.u_unpack),
              u_dimension: new l.bY(d, e.u_dimension),
              u_elevation_stops: new l.bT(d, e.u_elevation_stops),
              u_color_stops: new l.bT(d, e.u_color_stops),
              u_color_ramp_size: new l.bT(d, e.u_color_ramp_size),
              u_opacity: new l.bj(d, e.u_opacity)
            }),
            line: (d, e) => ({
              u_translation: new l.bY(d, e.u_translation),
              u_ratio: new l.bj(d, e.u_ratio),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(d, e.u_units_to_pixels)
            }),
            lineGradient: (d, e) => ({
              u_translation: new l.bY(d, e.u_translation),
              u_ratio: new l.bj(d, e.u_ratio),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(d, e.u_units_to_pixels),
              u_image: new l.bT(d, e.u_image),
              u_image_height: new l.bj(d, e.u_image_height)
            }),
            linePattern: (d, e) => ({
              u_translation: new l.bY(d, e.u_translation),
              u_texsize: new l.bY(d, e.u_texsize),
              u_ratio: new l.bj(d, e.u_ratio),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_image: new l.bT(d, e.u_image),
              u_units_to_pixels: new l.bY(d, e.u_units_to_pixels),
              u_scale: new l.bX(d, e.u_scale),
              u_fade: new l.bj(d, e.u_fade)
            }),
            lineSDF: (d, e) => ({
              u_translation: new l.bY(d, e.u_translation),
              u_ratio: new l.bj(d, e.u_ratio),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(d, e.u_units_to_pixels),
              u_image: new l.bT(d, e.u_image),
              u_mix: new l.bj(d, e.u_mix),
              u_tileratio: new l.bj(d, e.u_tileratio),
              u_crossfade_from: new l.bj(d, e.u_crossfade_from),
              u_crossfade_to: new l.bj(d, e.u_crossfade_to),
              u_lineatlas_width: new l.bj(d, e.u_lineatlas_width),
              u_lineatlas_height: new l.bj(d, e.u_lineatlas_height)
            }),
            lineGradientSDF: (d, e) => ({
              u_translation: new l.bY(d, e.u_translation),
              u_ratio: new l.bj(d, e.u_ratio),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new l.bY(d, e.u_units_to_pixels),
              u_image: new l.bT(d, e.u_image),
              u_image_height: new l.bj(d, e.u_image_height),
              u_tileratio: new l.bj(d, e.u_tileratio),
              u_crossfade_from: new l.bj(d, e.u_crossfade_from),
              u_crossfade_to: new l.bj(d, e.u_crossfade_to),
              u_image_dash: new l.bT(d, e.u_image_dash),
              u_mix: new l.bj(d, e.u_mix),
              u_lineatlas_width: new l.bj(d, e.u_lineatlas_width),
              u_lineatlas_height: new l.bj(d, e.u_lineatlas_height)
            }),
            raster: (d, e) => ({
              u_tl_parent: new l.bY(d, e.u_tl_parent),
              u_scale_parent: new l.bj(d, e.u_scale_parent),
              u_buffer_scale: new l.bj(d, e.u_buffer_scale),
              u_fade_t: new l.bj(d, e.u_fade_t),
              u_opacity: new l.bj(d, e.u_opacity),
              u_image0: new l.bT(d, e.u_image0),
              u_image1: new l.bT(d, e.u_image1),
              u_brightness_low: new l.bj(d, e.u_brightness_low),
              u_brightness_high: new l.bj(d, e.u_brightness_high),
              u_saturation_factor: new l.bj(d, e.u_saturation_factor),
              u_contrast_factor: new l.bj(d, e.u_contrast_factor),
              u_spin_weights: new l.bX(d, e.u_spin_weights),
              u_coords_top: new l.bW(d, e.u_coords_top),
              u_coords_bottom: new l.bW(d, e.u_coords_bottom)
            }),
            symbolIcon: (d, e) => ({
              u_is_size_zoom_constant: new l.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new l.bT(d, e.u_is_size_feature_constant),
              u_size_t: new l.bj(d, e.u_size_t),
              u_size: new l.bj(d, e.u_size),
              u_camera_to_center_distance: new l.bj(d, e.u_camera_to_center_distance),
              u_pitch: new l.bj(d, e.u_pitch),
              u_rotate_symbol: new l.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new l.bj(d, e.u_aspect_ratio),
              u_fade_change: new l.bj(d, e.u_fade_change),
              u_label_plane_matrix: new l.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new l.bV(d, e.u_coord_matrix),
              u_is_text: new l.bT(d, e.u_is_text),
              u_pitch_with_map: new l.bT(d, e.u_pitch_with_map),
              u_is_along_line: new l.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new l.bT(d, e.u_is_variable_anchor),
              u_texsize: new l.bY(d, e.u_texsize),
              u_texture: new l.bT(d, e.u_texture),
              u_translation: new l.bY(d, e.u_translation),
              u_pitched_scale: new l.bj(d, e.u_pitched_scale)
            }),
            symbolSDF: (d, e) => ({
              u_is_size_zoom_constant: new l.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new l.bT(d, e.u_is_size_feature_constant),
              u_size_t: new l.bj(d, e.u_size_t),
              u_size: new l.bj(d, e.u_size),
              u_camera_to_center_distance: new l.bj(d, e.u_camera_to_center_distance),
              u_pitch: new l.bj(d, e.u_pitch),
              u_rotate_symbol: new l.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new l.bj(d, e.u_aspect_ratio),
              u_fade_change: new l.bj(d, e.u_fade_change),
              u_label_plane_matrix: new l.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new l.bV(d, e.u_coord_matrix),
              u_is_text: new l.bT(d, e.u_is_text),
              u_pitch_with_map: new l.bT(d, e.u_pitch_with_map),
              u_is_along_line: new l.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new l.bT(d, e.u_is_variable_anchor),
              u_texsize: new l.bY(d, e.u_texsize),
              u_texture: new l.bT(d, e.u_texture),
              u_gamma_scale: new l.bj(d, e.u_gamma_scale),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_is_halo: new l.bT(d, e.u_is_halo),
              u_translation: new l.bY(d, e.u_translation),
              u_pitched_scale: new l.bj(d, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (d, e) => ({
              u_is_size_zoom_constant: new l.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new l.bT(d, e.u_is_size_feature_constant),
              u_size_t: new l.bj(d, e.u_size_t),
              u_size: new l.bj(d, e.u_size),
              u_camera_to_center_distance: new l.bj(d, e.u_camera_to_center_distance),
              u_pitch: new l.bj(d, e.u_pitch),
              u_rotate_symbol: new l.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new l.bj(d, e.u_aspect_ratio),
              u_fade_change: new l.bj(d, e.u_fade_change),
              u_label_plane_matrix: new l.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new l.bV(d, e.u_coord_matrix),
              u_is_text: new l.bT(d, e.u_is_text),
              u_pitch_with_map: new l.bT(d, e.u_pitch_with_map),
              u_is_along_line: new l.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new l.bT(d, e.u_is_variable_anchor),
              u_texsize: new l.bY(d, e.u_texsize),
              u_texsize_icon: new l.bY(d, e.u_texsize_icon),
              u_texture: new l.bT(d, e.u_texture),
              u_texture_icon: new l.bT(d, e.u_texture_icon),
              u_gamma_scale: new l.bj(d, e.u_gamma_scale),
              u_device_pixel_ratio: new l.bj(d, e.u_device_pixel_ratio),
              u_is_halo: new l.bT(d, e.u_is_halo),
              u_translation: new l.bY(d, e.u_translation),
              u_pitched_scale: new l.bj(d, e.u_pitched_scale)
            }),
            background: (d, e) => ({
              u_opacity: new l.bj(d, e.u_opacity),
              u_color: new l.bU(d, e.u_color)
            }),
            backgroundPattern: (d, e) => ({
              u_opacity: new l.bj(d, e.u_opacity),
              u_image: new l.bT(d, e.u_image),
              u_pattern_tl_a: new l.bY(d, e.u_pattern_tl_a),
              u_pattern_br_a: new l.bY(d, e.u_pattern_br_a),
              u_pattern_tl_b: new l.bY(d, e.u_pattern_tl_b),
              u_pattern_br_b: new l.bY(d, e.u_pattern_br_b),
              u_texsize: new l.bY(d, e.u_texsize),
              u_mix: new l.bj(d, e.u_mix),
              u_pattern_size_a: new l.bY(d, e.u_pattern_size_a),
              u_pattern_size_b: new l.bY(d, e.u_pattern_size_b),
              u_scale_a: new l.bj(d, e.u_scale_a),
              u_scale_b: new l.bj(d, e.u_scale_b),
              u_pixel_coord_upper: new l.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new l.bY(d, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new l.bj(d, e.u_tile_units_to_pixels)
            }),
            terrain: (d, e) => ({
              u_texture: new l.bT(d, e.u_texture),
              u_ele_delta: new l.bj(d, e.u_ele_delta),
              u_fog_matrix: new l.bV(d, e.u_fog_matrix),
              u_fog_color: new l.bU(d, e.u_fog_color),
              u_fog_ground_blend: new l.bj(d, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new l.bj(d, e.u_fog_ground_blend_opacity),
              u_horizon_color: new l.bU(d, e.u_horizon_color),
              u_horizon_fog_blend: new l.bj(d, e.u_horizon_fog_blend),
              u_is_globe_mode: new l.bj(d, e.u_is_globe_mode)
            }),
            terrainDepth: (d, e) => ({
              u_ele_delta: new l.bj(d, e.u_ele_delta)
            }),
            terrainCoords: (d, e) => ({
              u_texture: new l.bT(d, e.u_texture),
              u_terrain_coords_id: new l.bj(d, e.u_terrain_coords_id),
              u_ele_delta: new l.bj(d, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (d, e) => ({
              u_input: new l.bj(d, e.u_input),
              u_output_expected: new l.bj(d, e.u_output_expected)
            }),
            atmosphere: (d, e) => ({
              u_sun_pos: new l.bX(d, e.u_sun_pos),
              u_atmosphere_blend: new l.bj(d, e.u_atmosphere_blend),
              u_globe_position: new l.bX(d, e.u_globe_position),
              u_globe_radius: new l.bj(d, e.u_globe_radius),
              u_inv_proj_matrix: new l.bV(d, e.u_inv_proj_matrix)
            }),
            sky: (d, e) => ({
              u_sky_color: new l.bU(d, e.u_sky_color),
              u_horizon_color: new l.bU(d, e.u_horizon_color),
              u_horizon: new l.bY(d, e.u_horizon),
              u_horizon_normal: new l.bY(d, e.u_horizon_normal),
              u_sky_horizon_blend: new l.bj(d, e.u_sky_horizon_blend),
              u_sky_blend: new l.bj(d, e.u_sky_blend)
            })
          };
        class Yc {
          constructor(e, a, c) {
            this.context = e;
            const h = e.gl;
            this.buffer = h.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), h.bufferData(h.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const Vo = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Kc {
          constructor(e, a, c, h) {
            this.length = a.length, this.attributes = c, this.itemSize = a.bytesPerElement, this.dynamicDraw = h, this.context = e;
            const f = e.gl;
            this.buffer = f.createBuffer(), e.bindVertexBuffer.set(this.buffer), f.bufferData(f.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? f.DYNAMIC_DRAW : f.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, a) {
            for (let c = 0; c < this.attributes.length; c++) {
              const h = a.attributes[this.attributes[c].name];
              h !== void 0 && e.enableVertexAttribArray(h)
            }
          }
          setVertexAttribPointers(e, a, c) {
            for (let h = 0; h < this.attributes.length; h++) {
              const f = this.attributes[h],
                v = a.attributes[f.name];
              v !== void 0 && e.vertexAttribPointer(v, f.components, e[Vo[f.type]], !1, this.itemSize, f.offset + this.itemSize * (c || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class $n {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class Gp extends $n {
          getDefault() {
            return l.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Wp extends $n {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class Hp extends $n {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Zh extends $n {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class $p extends $n {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Gh extends $n {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Cl extends $n {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class zl extends $n {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class Al extends $n {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class Jc extends $n {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Uo extends $n {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Hs extends $n {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class bs extends $n {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Da extends $n {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Wh extends $n {
          getDefault() {
            return l.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Hh extends $n {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class Qc extends $n {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class Zo extends $n {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class El extends $n {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Ll extends $n {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class $s extends $n {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Dl extends $n {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class $h extends $n {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class xs extends $n {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ws extends $n {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class Xh extends $n {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class eu extends $n {
          getDefault() {
            return null
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Fn extends $n {
          getDefault() {
            return null
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const c = this.gl;
            Vi(c) ? c.bindVertexArray(e) : (a = c.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class Rl extends $n {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class Xp extends $n {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Yh extends $n {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Go extends $n {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a
          }
          getDefault() {
            return null
          }
        }
        class Yp extends Go {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class Kp extends Go {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Kh extends Go {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const Jh = "Framebuffer is not complete";
        class tu {
          constructor(e, a, c, h, f) {
            this.context = e, this.width = a, this.height = c;
            const v = e.gl,
              w = this.framebuffer = v.createFramebuffer();
            if (this.colorAttachment = new Yp(e, w), h) this.depthAttachment = f ? new Kh(e, w) : new Kp(e, w);
            else if (f) throw new Error("Stencil cannot be set without depth");
            if (v.checkFramebufferStatus(v.FRAMEBUFFER) !== v.FRAMEBUFFER_COMPLETE) throw new Error(Jh)
          }
          destroy() {
            const e = this.context.gl,
              a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const c = this.depthAttachment.get();
              c && e.deleteRenderbuffer(c)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class jl {
          constructor(e) {
            var a, c;
            if (this.gl = e, this.clearColor = new Gp(this), this.clearDepth = new Wp(this), this.clearStencil = new Hp(this), this.colorMask = new Zh(this), this.depthMask = new $p(this), this.stencilMask = new Gh(this), this.stencilFunc = new Cl(this), this.stencilOp = new zl(this), this.stencilTest = new Al(this), this.depthRange = new Jc(this), this.depthTest = new Uo(this), this.depthFunc = new Hs(this), this.blend = new bs(this), this.blendFunc = new Da(this), this.blendColor = new Wh(this), this.blendEquation = new Hh(this), this.cullFace = new Qc(this), this.cullFaceSide = new Zo(this), this.frontFace = new El(this), this.program = new Ll(this), this.activeTexture = new $s(this), this.viewport = new Dl(this), this.bindFramebuffer = new $h(this), this.bindRenderbuffer = new xs(this), this.bindTexture = new ws(this), this.bindVertexBuffer = new Xh(this), this.bindElementBuffer = new eu(this), this.bindVertexArray = new Fn(this), this.pixelStoreUnpack = new Rl(this), this.pixelStoreUnpackPremultiplyAlpha = new Xp(this), this.pixelStoreUnpackFlipY = new Yh(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Vi(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const h = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : h == null ? void 0 : h.RGBA16F_EXT, this.RGB16F = (c = e.RGB16F) !== null && c !== void 0 ? c : h == null ? void 0 : h.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const h = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = h == null ? void 0 : h.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, a) {
            return new Yc(this, e, a)
          }
          createVertexBuffer(e, a, c) {
            return new Kc(this, e, a, c)
          }
          createRenderbuffer(e, a, c) {
            const h = this.gl,
              f = h.createRenderbuffer();
            return this.bindRenderbuffer.set(f), h.renderbufferStorage(h.RENDERBUFFER, e, a, c), this.bindRenderbuffer.set(null), f
          }
          createFramebuffer(e, a, c, h) {
            return new tu(this, e, a, c, h)
          }
          clear({
            color: e,
            depth: a,
            stencil: c
          }) {
            const h = this.gl;
            let f = 0;
            e && (f |= h.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), a !== void 0 && (f |= h.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(!0)), c !== void 0 && (f |= h.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), h.clear(f)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            l.bK(e.blendFunction, Sn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return Vi(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var a;
            return Vi(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let Wo;

        function Xs(d, e, a, c, h) {
          const f = d.context,
            v = d.transform,
            w = f.gl,
            T = d.useProgram("collisionBox"),
            C = [];
          let A = 0,
            j = 0;
          for (let ce = 0; ce < c.length; ce++) {
            const me = c[ce],
              Se = e.getTile(me).getBucket(a);
            if (!Se) continue;
            const fe = h ? Se.textCollisionBox : Se.iconCollisionBox,
              Pe = Se.collisionCircleArray;
            Pe.length > 0 && (C.push({
              circleArray: Pe,
              circleOffset: j,
              coord: me
            }), A += Pe.length / 4, j = A), fe && T.draw(f, w.LINES, yn.disabled, Rn.disabled, d.colorModeForRenderPass(), vn.disabled, Bh(d.transform), d.style.map.terrain && d.style.map.terrain.getTerrainData(me), v.getProjectionData({
              overscaledTileID: me,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), a.id, fe.layoutVertexBuffer, fe.indexBuffer, fe.segments, null, d.transform.zoom, null, null, fe.collisionVertexBuffer)
          }
          if (!h || !C.length) return;
          const R = d.useProgram("collisionCircle"),
            Z = new l.c3;
          Z.resize(4 * A), Z._trim();
          let Y = 0;
          for (const ce of C)
            for (let me = 0; me < ce.circleArray.length / 4; me++) {
              const Se = 4 * me,
                fe = ce.circleArray[Se + 0],
                Pe = ce.circleArray[Se + 1],
                Ae = ce.circleArray[Se + 2],
                ve = ce.circleArray[Se + 3];
              Z.emplace(Y++, fe, Pe, Ae, ve, 0), Z.emplace(Y++, fe, Pe, Ae, ve, 1), Z.emplace(Y++, fe, Pe, Ae, ve, 2), Z.emplace(Y++, fe, Pe, Ae, ve, 3)
            }(!Wo || Wo.length < 2 * A) && (Wo = (function(ce) {
              const me = 2 * ce,
                Se = new l.c5;
              Se.resize(me), Se._trim();
              for (let fe = 0; fe < me; fe++) {
                const Pe = 6 * fe;
                Se.uint16[Pe + 0] = 4 * fe + 0, Se.uint16[Pe + 1] = 4 * fe + 1, Se.uint16[Pe + 2] = 4 * fe + 2, Se.uint16[Pe + 3] = 4 * fe + 2, Se.uint16[Pe + 4] = 4 * fe + 3, Se.uint16[Pe + 5] = 4 * fe + 0
              }
              return Se
            })(A));
          const oe = f.createIndexBuffer(Wo, !0),
            le = f.createVertexBuffer(Z, l.c4.members, !0);
          for (const ce of C) {
            const me = Nc(d.transform);
            R.draw(f, w.TRIANGLES, yn.disabled, Rn.disabled, d.colorModeForRenderPass(), vn.disabled, me, d.style.map.terrain && d.style.map.terrain.getTerrainData(ce.coord), null, a.id, le, oe, l.aQ.simpleSegment(0, 2 * ce.circleOffset, ce.circleArray.length, ce.circleArray.length / 2), null, d.transform.zoom, null, null, null)
          }
          le.destroy(), oe.destroy()
        }
        const ru = l.am(new Float32Array(16));

        function Qh(d, e, a, c, h, f) {
          const {
            horizontalAlign: v,
            verticalAlign: w
          } = l.aL(d);
          return new l.P((-(v - .5) * e / h + c[0]) * f, (-(w - .5) * a / h + c[1]) * f)
        }

        function Fl(d, e, a, c, h, f) {
          const v = e.tileAnchorPoint.add(new l.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let w = c.mult(f);
            a || (w = w.rotate(-h));
            const T = v.add(w);
            return Qe(T.x, T.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (a) {
            const w = Ge(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(d),
              T = Math.atan(w.y / w.x) + (w.x < 0 ? Math.PI : 0);
            return d.add(c.rotate(T))
          }
          return d.add(c)
        }

        function Bl(d, e, a, c, h, f, v, w, T, C, A, j) {
          const R = d.text.placedSymbolArray,
            Z = d.text.dynamicLayoutVertexArray,
            Y = d.icon.dynamicLayoutVertexArray,
            oe = {};
          Z.clear();
          for (let le = 0; le < R.length; le++) {
            const ce = R.get(le),
              me = ce.hidden || !ce.crossTileID || d.allowVerticalPlacement && !ce.placedOrientation ? null : c[ce.crossTileID];
            if (me) {
              const Se = new l.P(ce.anchorX, ce.anchorY),
                fe = {
                  getElevation: j,
                  width: h.width,
                  height: h.height,
                  pitchedLabelPlaneMatrix: f,
                  pitchWithMap: a,
                  transform: h,
                  tileAnchorPoint: Se,
                  translation: C,
                  unwrappedTileID: A
                },
                Pe = a ? Wt(Se.x, Se.y, fe) : Ge(Se.x, Se.y, fe),
                Ae = rr(h.cameraToCenterDistance, Pe.signedDistanceFromCamera);
              let ve = l.at(d.textSizeData, w, ce) * Ae / l.aF;
              a && (ve *= d.tilePixelRatio / v);
              const {
                width: Oe,
                height: ct,
                anchor: it,
                textOffset: st,
                textBoxScale: ut
              } = me, or = Qh(it, Oe, ct, st, ut, ve), cr = h.getPitchedTextCorrection(Se.x + C[0], Se.y + C[1], A), Bt = Fl(Pe.point, fe, e, or, -h.bearingInRadians, cr), Nr = d.allowVerticalPlacement && ce.placedOrientation === l.as.vertical ? Math.PI / 2 : 0;
              for (let xn = 0; xn < ce.numGlyphs; xn++) l.az(Z, Bt, Nr);
              T && ce.associatedIconIndex >= 0 && (oe[ce.associatedIconIndex] = {
                shiftedAnchor: Bt,
                angle: Nr
              })
            } else Jr(ce.numGlyphs, Z)
          }
          if (T) {
            Y.clear();
            const le = d.icon.placedSymbolArray;
            for (let ce = 0; ce < le.length; ce++) {
              const me = le.get(ce);
              if (me.hidden) Jr(me.numGlyphs, Y);
              else {
                const Se = oe[ce];
                if (Se)
                  for (let fe = 0; fe < me.numGlyphs; fe++) l.az(Y, Se.shiftedAnchor, Se.angle);
                else Jr(me.numGlyphs, Y)
              }
            }
            d.icon.dynamicLayoutVertexBuffer.updateData(Y)
          }
          d.text.dynamicLayoutVertexBuffer.updateData(Z)
        }

        function Ol(d, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : d ? "symbolSDF" : "symbolIcon"
        }

        function Ho(d, e, a, c, h, f, v, w, T, C, A, j, R) {
          const Z = d.context,
            Y = Z.gl,
            oe = d.transform,
            le = w === "map",
            ce = T === "map",
            me = w !== "viewport" && a.layout.get("symbol-placement") !== "point",
            Se = le && !ce && !me,
            fe = !a.layout.get("symbol-sort-key").isConstant();
          let Pe = !1;
          const Ae = d.getDepthModeForSublayer(0, yn.ReadOnly),
            ve = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Oe = [],
            ct = oe.getCircleRadiusCorrection();
          for (const it of c) {
            const st = e.getTile(it),
              ut = st.getBucket(a);
            if (!ut) continue;
            const or = h ? ut.text : ut.icon;
            if (!or || !or.segments.get().length || !or.hasVisibleVertices) continue;
            const cr = or.programConfigurations.get(a.id),
              Bt = h || ut.sdfIcons,
              Nr = h ? ut.textSizeData : ut.iconSizeData,
              xn = ce || oe.pitch !== 0,
              Xn = d.useProgram(Ol(Bt, h, ut), cr),
              zn = l.ar(Nr, oe.zoom),
              ti = d.style.map.terrain && d.style.map.terrain.getTerrainData(it);
            let mi, ni, Ei, ci, Ui = [0, 0],
              ui = null;
            if (h) ni = st.glyphAtlasTexture, Ei = Y.LINEAR, mi = st.glyphAtlasTexture.size, ut.iconsInText && (Ui = st.imageAtlasTexture.size, ui = st.imageAtlasTexture, ci = xn || d.options.rotating || d.options.zooming || Nr.kind === "composite" || Nr.kind === "camera" ? Y.LINEAR : Y.NEAREST);
            else {
              const zi = a.layout.get("icon-size").constantOr(0) !== 1 || ut.iconsNeedLinear;
              ni = st.imageAtlasTexture, Ei = Bt || d.options.rotating || d.options.zooming || zi || xn ? Y.LINEAR : Y.NEAREST, mi = st.imageAtlasTexture.size
            }
            const Ci = l.aG(st, 1, d.transform.zoom),
              ha = Jt(le, d.transform, Ci),
              Qo = l.M();
            l.au(Qo, ha);
            const _o = Cr(ce, le, d.transform, Ci),
              io = l.aH(oe, st, f, v),
              es = oe.getProjectionData({
                overscaledTileID: it,
                applyGlobeMatrix: !R,
                applyTerrainMatrix: !0
              }),
              zs = ve && ut.hasTextData(),
              ts = a.layout.get("icon-text-fit") !== "none" && zs && ut.hasIconData();
            if (me) {
              const zi = d.style.map.terrain ? (Zi, ai) => d.style.map.terrain.getElevation(it, Zi, ai) : null,
                ki = a.layout.get("text-rotation-alignment") === "map";
              Tr(ut, d, h, ha, Qo, ce, C, ki, it.toUnwrapped(), oe.width, oe.height, io, zi)
            }
            const va = h && ve || ts,
              da = me || va ? ru : ce ? ha : d.transform.clipSpaceToPixelsMatrix,
              mo = Bt && a.paint.get(h ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Io;
            Io = Bt ? ut.iconsInText ? lo(Nr.kind, zn, Se, ce, me, va, d, da, _o, io, mi, Ui, ct) : Ws(Nr.kind, zn, Se, ce, me, va, d, da, _o, io, h, mi, 0, ct) : Hc(Nr.kind, zn, Se, ce, me, va, d, da, _o, io, h, mi, ct);
            const ol = {
              program: Xn,
              buffers: or,
              uniformValues: Io,
              projectionData: es,
              atlasTexture: ni,
              atlasTextureIcon: ui,
              atlasInterpolation: Ei,
              atlasInterpolationIcon: ci,
              isSDF: Bt,
              hasHalo: mo
            };
            if (fe && ut.canOverlap) {
              Pe = !0;
              const zi = or.segments.get();
              for (const ki of zi) Oe.push({
                segments: new l.aQ([ki]),
                sortKey: ki.sortKey,
                state: ol,
                terrainData: ti
              })
            } else Oe.push({
              segments: or.segments,
              sortKey: 0,
              state: ol,
              terrainData: ti
            })
          }
          Pe && Oe.sort(((it, st) => it.sortKey - st.sortKey));
          for (const it of Oe) {
            const st = it.state;
            if (Z.activeTexture.set(Y.TEXTURE0), st.atlasTexture.bind(st.atlasInterpolation, Y.CLAMP_TO_EDGE), st.atlasTextureIcon && (Z.activeTexture.set(Y.TEXTURE1), st.atlasTextureIcon && st.atlasTextureIcon.bind(st.atlasInterpolationIcon, Y.CLAMP_TO_EDGE)), st.isSDF) {
              const ut = st.uniformValues;
              st.hasHalo && (ut.u_is_halo = 1, ql(st.buffers, it.segments, a, d, st.program, Ae, A, j, ut, st.projectionData, it.terrainData)), ut.u_is_halo = 0
            }
            ql(st.buffers, it.segments, a, d, st.program, Ae, A, j, st.uniformValues, st.projectionData, it.terrainData)
          }
        }

        function ql(d, e, a, c, h, f, v, w, T, C, A) {
          const j = c.context;
          h.draw(j, j.gl.TRIANGLES, f, v, w, vn.backCCW, T, A, C, a.id, d.layoutVertexBuffer, d.indexBuffer, e, a.paint, c.transform.zoom, d.programConfigurations.get(a.id), d.dynamicLayoutVertexBuffer, d.opacityVertexBuffer)
        }

        function Jp(d, e, a, c, h) {
          const f = d.context,
            v = f.gl,
            w = Rn.disabled,
            T = new Sn([v.ONE, v.ONE], l.bi.transparent, [!0, !0, !0, !0]),
            C = e.getBucket(a);
          if (!C) return;
          const A = c.key;
          let j = a.heatmapFbos.get(A);
          j || (j = ed(f, e.tileSize, e.tileSize), a.heatmapFbos.set(A, j)), f.bindFramebuffer.set(j.framebuffer), f.viewport.set([0, 0, e.tileSize, e.tileSize]), f.clear({
            color: l.bi.transparent
          });
          const R = C.programConfigurations.get(a.id),
            Z = d.useProgram("heatmap", R, !h),
            Y = d.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            oe = d.style.map.terrain.getTerrainData(c);
          Z.draw(f, v.TRIANGLES, yn.disabled, w, T, vn.disabled, Uc(e, d.transform.zoom, a.paint.get("heatmap-intensity"), 1), oe, Y, a.id, C.layoutVertexBuffer, C.indexBuffer, C.segments, a.paint, d.transform.zoom, R)
        }

        function Ys(d, e, a, c, h) {
          const f = d.context,
            v = f.gl,
            w = d.transform;
          f.setColorMode(d.colorModeForRenderPass());
          const T = nu(f, e),
            C = a.key,
            A = e.heatmapFbos.get(C);
          if (!A) return;
          f.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, A.colorAttachment.get()), f.activeTexture.set(v.TEXTURE1), T.bind(v.LINEAR, v.CLAMP_TO_EDGE);
          const j = w.getProjectionData({
            overscaledTileID: a,
            applyTerrainMatrix: h,
            applyGlobeMatrix: !c
          });
          d.useProgram("heatmapTexture").draw(f, v.TRIANGLES, yn.disabled, Rn.disabled, d.colorModeForRenderPass(), vn.disabled, Zc(d, e, 0, 1), null, j, e.id, d.rasterBoundsBuffer, d.quadTriangleIndexBuffer, d.rasterBoundsSegments, e.paint, w.zoom), A.destroy(), e.heatmapFbos.delete(C)
        }

        function ed(d, e, a) {
          var c, h;
          const f = d.gl,
            v = f.createTexture();
          f.bindTexture(f.TEXTURE_2D, v), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR);
          const w = (c = d.HALF_FLOAT) !== null && c !== void 0 ? c : f.UNSIGNED_BYTE,
            T = (h = d.RGBA16F) !== null && h !== void 0 ? h : f.RGBA;
          f.texImage2D(f.TEXTURE_2D, 0, T, e, a, 0, f.RGBA, w, null);
          const C = d.createFramebuffer(e, a, !1, !1);
          return C.colorAttachment.set(v), C
        }

        function nu(d, e) {
          return e.colorRampTexture || (e.colorRampTexture = new l.T(d, e.colorRamp, d.gl.RGBA)), e.colorRampTexture
        }

        function Ks(d, e, a, c, h, f, v, w) {
          let T = 256;
          if (h.stepInterpolant) {
            const C = e.getSource().maxzoom,
              A = v.canonical.z === C ? Math.ceil(1 << d.transform.maxZoom - v.canonical.z) : 1;
            T = l.ai(l.c7(f.maxLineLength / l.a3 * 1024 * A), 256, a.maxTextureSize)
          }
          return w.gradient = l.c8({
            expression: h.gradientExpression(),
            evaluationKey: "lineProgress",
            resolution: T,
            image: w.gradient || void 0,
            clips: f.lineClipsArray
          }), w.texture ? w.texture.update(w.gradient) : w.texture = new l.T(a, w.gradient, c.RGBA), w.version = h.gradientVersion, w.texture
        }

        function iu(d, e, a, c, h) {
          d.activeTexture.set(e.TEXTURE0), a.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), c.updatePaintBuffers(h)
        }

        function td(d, e, a, c, h, f) {
          (h || d.lineAtlas.dirty) && (e.activeTexture.set(a.TEXTURE0), d.lineAtlas.bind(e)), c.updatePaintBuffers(f)
        }

        function rd(d, e, a, c, h, f, v) {
          const w = f.gradients[h.id];
          let T = w.texture;
          h.gradientVersion !== w.version && (T = Ks(d, e, a, c, h, f, v, w)), a.activeTexture.set(c.TEXTURE0), T.bind(h.stepInterpolant ? c.NEAREST : c.LINEAR, c.CLAMP_TO_EDGE)
        }

        function Nl(d, e, a, c, h, f, v, w, T) {
          const C = f.gradients[h.id];
          let A = C.texture;
          h.gradientVersion !== C.version && (A = Ks(d, e, a, c, h, f, v, C)), a.activeTexture.set(c.TEXTURE0), A.bind(h.stepInterpolant ? c.NEAREST : c.LINEAR, c.CLAMP_TO_EDGE), a.activeTexture.set(c.TEXTURE1), d.lineAtlas.bind(a), w.updatePaintBuffers(T)
        }

        function Vl(d, e, a, c, h) {
          if (!a || !c || !c.imageAtlas) return;
          const f = c.imageAtlas.patternPositions;
          let v = f[a.to.toString()],
            w = f[a.from.toString()];
          if (!v && w && (v = w), !w && v && (w = v), !v || !w) {
            const T = h.getPaintProperty(e);
            v = f[T], w = f[T]
          }
          v && w && d.setConstantPatternPositions(v, w)
        }

        function nd(d, e, a, c, h, f, v, w) {
          const T = d.context.gl,
            C = "fill-pattern",
            A = a.paint.get(C),
            j = A && A.constantOr(1),
            R = a.getCrossfadeParameters();
          let Z, Y, oe, le, ce;
          const me = d.transform,
            Se = a.paint.get("fill-translate"),
            fe = a.paint.get("fill-translate-anchor");
          v ? (Y = j && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", Z = T.LINES) : (Y = j ? "fillPattern" : "fill", Z = T.TRIANGLES);
          const Pe = A.constantOr(null);
          for (const Ae of c) {
            const ve = e.getTile(Ae);
            if (j && !ve.patternsLoaded()) continue;
            const Oe = ve.getBucket(a);
            if (!Oe) continue;
            const ct = Oe.programConfigurations.get(a.id),
              it = d.useProgram(Y, ct),
              st = d.style.map.terrain && d.style.map.terrain.getTerrainData(Ae);
            j && (d.context.activeTexture.set(T.TEXTURE0), ve.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE), ct.updatePaintBuffers(R)), Vl(ct, C, Pe, ve, a);
            const ut = me.getProjectionData({
                overscaledTileID: Ae,
                applyGlobeMatrix: !w,
                applyTerrainMatrix: !0
              }),
              or = l.aH(me, ve, Se, fe);
            if (v) {
              le = Oe.indexBuffer2, ce = Oe.segments2;
              const Bt = [T.drawingBufferWidth, T.drawingBufferHeight];
              oe = Y === "fillOutlinePattern" && j ? Fh(d, R, ve, Bt, or) : qp(Bt, or)
            } else le = Oe.indexBuffer, ce = Oe.segments, oe = j ? qo(d, R, ve, or) : {
              u_fill_translate: or
            };
            const cr = d.stencilModeForClipping(Ae);
            it.draw(d.context, Z, h, cr, f, vn.backCCW, oe, st, ut, a.id, Oe.layoutVertexBuffer, le, ce, a.paint, d.transform.zoom, ct)
          }
        }

        function Ul(d, e, a, c, h, f, v, w) {
          const T = d.context,
            C = T.gl,
            A = "fill-extrusion-pattern",
            j = a.paint.get(A),
            R = j.constantOr(1),
            Z = a.getCrossfadeParameters(),
            Y = a.paint.get("fill-extrusion-opacity"),
            oe = j.constantOr(null),
            le = d.transform;
          for (const ce of c) {
            const me = e.getTile(ce),
              Se = me.getBucket(a);
            if (!Se) continue;
            const fe = d.style.map.terrain && d.style.map.terrain.getTerrainData(ce),
              Pe = Se.programConfigurations.get(a.id),
              Ae = d.useProgram(R ? "fillExtrusionPattern" : "fillExtrusion", Pe);
            R && (d.context.activeTexture.set(C.TEXTURE0), me.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE), Pe.updatePaintBuffers(Z));
            const ve = le.getProjectionData({
              overscaledTileID: ce,
              applyGlobeMatrix: !w,
              applyTerrainMatrix: !0
            });
            Vl(Pe, A, oe, me, a);
            const Oe = l.aH(le, me, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")),
              ct = a.paint.get("fill-extrusion-vertical-gradient"),
              it = R ? Op(d, ct, Y, Oe, ce, Z, me) : Gs(d, ct, Y, Oe);
            Ae.draw(T, T.gl.TRIANGLES, h, f, v, vn.backCCW, it, fe, ve, a.id, Se.layoutVertexBuffer, Se.indexBuffer, Se.segments, a.paint, d.transform.zoom, Pe, d.style.map.terrain && Se.centroidVertexBuffer)
          }
        }

        function fi(d, e, a, c, h, f, v, w, T) {
          var C;
          const A = d.style.projection,
            j = d.context,
            R = d.transform,
            Z = j.gl,
            Y = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`],
            oe = d.useProgram("hillshade", null, !1, Y),
            le = !d.options.moving;
          for (const ce of c) {
            const me = e.getTile(ce),
              Se = me.fbo;
            if (!Se) continue;
            const fe = A.getMeshFromTileID(j, ce.canonical, w, !0, "raster"),
              Pe = (C = d.style.map.terrain) === null || C === void 0 ? void 0 : C.getTerrainData(ce);
            j.activeTexture.set(Z.TEXTURE0), Z.bindTexture(Z.TEXTURE_2D, Se.colorAttachment.get());
            const Ae = R.getProjectionData({
              overscaledTileID: ce,
              aligned: le,
              applyGlobeMatrix: !T,
              applyTerrainMatrix: !0
            });
            oe.draw(j, Z.TRIANGLES, f, h[ce.overscaledZ], v, vn.backCCW, Oh(d, me, a), Pe, Ae, a.id, fe.vertexBuffer, fe.indexBuffer, fe.segments)
          }
        }

        function co(d, e, a, c, h, f, v, w, T) {
          var C;
          const A = d.style.projection,
            j = d.context,
            R = d.transform,
            Z = j.gl,
            Y = d.useProgram("colorRelief"),
            oe = !d.options.moving;
          let le = !0,
            ce = 0;
          for (const me of c) {
            const Se = e.getTile(me),
              fe = Se.dem;
            if (le) {
              const it = Z.getParameter(Z.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: st,
                  colorTexture: ut
                } = a.getColorRampTextures(j, it, fe.getUnpackVector());
              j.activeTexture.set(Z.TEXTURE1), st.bind(Z.NEAREST, Z.CLAMP_TO_EDGE), j.activeTexture.set(Z.TEXTURE4), ut.bind(Z.LINEAR, Z.CLAMP_TO_EDGE), le = !1, ce = st.size[0]
            }
            if (!fe || !fe.data) continue;
            const Pe = fe.stride,
              Ae = fe.getPixels();
            if (j.activeTexture.set(Z.TEXTURE0), j.pixelStoreUnpackPremultiplyAlpha.set(!1), Se.demTexture = Se.demTexture || d.getTileTexture(Pe), Se.demTexture) {
              const it = Se.demTexture;
              it.update(Ae, {
                premultiply: !1
              }), it.bind(Z.LINEAR, Z.CLAMP_TO_EDGE)
            } else Se.demTexture = new l.T(j, Ae, Z.RGBA, {
              premultiply: !1
            }), Se.demTexture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE);
            const ve = A.getMeshFromTileID(j, me.canonical, w, !0, "raster"),
              Oe = (C = d.style.map.terrain) === null || C === void 0 ? void 0 : C.getTerrainData(me),
              ct = R.getProjectionData({
                overscaledTileID: me,
                aligned: oe,
                applyGlobeMatrix: !T,
                applyTerrainMatrix: !0
              });
            Y.draw(j, Z.TRIANGLES, f, h[me.overscaledZ], v, vn.backCCW, Nh(a, Se.dem, ce), Oe, ct, a.id, ve.vertexBuffer, ve.indexBuffer, ve.segments)
          }
        }
        const ma = [new l.P(0, 0), new l.P(l.a3, 0), new l.P(l.a3, l.a3), new l.P(0, l.a3)];

        function ks(d, e, a, c, h, f, v, w, T = !1, C = !1) {
          const A = c[c.length - 1].overscaledZ,
            j = d.context,
            R = j.gl,
            Z = d.useProgram("raster"),
            Y = d.transform,
            oe = d.style.projection,
            le = d.colorModeForRenderPass(),
            ce = !d.options.moving,
            me = a.paint.get("raster-opacity"),
            Se = a.paint.get("raster-resampling"),
            fe = a.paint.get("raster-fade-duration"),
            Pe = !!d.style.map.terrain;
          for (const Ae of c) {
            const ve = d.getDepthModeForSublayer(Ae.overscaledZ - A, me === 1 ? yn.ReadWrite : yn.ReadOnly, R.LESS),
              Oe = e.getTile(Ae),
              ct = Se === "nearest" ? R.NEAREST : R.LINEAR;
            j.activeTexture.set(R.TEXTURE0), Oe.texture.bind(ct, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), j.activeTexture.set(R.TEXTURE1);
            const {
              parentTile: it,
              parentScaleBy: st,
              parentTopLeft: ut,
              fadeValues: or
            } = Zl(Oe, e, fe, Pe);
            Oe.fadeOpacity = or.tileOpacity, it ? (it.fadeOpacity = or.parentTileOpacity, it.texture.bind(ct, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST)) : Oe.texture.bind(ct, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), Oe.texture.useMipmap && j.extTextureFilterAnisotropic && d.transform.pitch > 20 && R.texParameterf(R.TEXTURE_2D, j.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, j.extTextureFilterAnisotropicMax);
            const cr = d.style.map.terrain && d.style.map.terrain.getTerrainData(Ae),
              Bt = Y.getProjectionData({
                overscaledTileID: Ae,
                aligned: ce,
                applyGlobeMatrix: !C,
                applyTerrainMatrix: !0
              }),
              Nr = Vh(ut, st, or.fadeMix, a, w),
              xn = oe.getMeshFromTileID(j, Ae.canonical, f, v, "raster");
            Z.draw(j, R.TRIANGLES, ve, h ? h[Ae.overscaledZ] : Rn.disabled, le, T ? vn.frontCCW : vn.backCCW, Nr, cr, Bt, a.id, xn.vertexBuffer, xn.indexBuffer, xn.segments)
          }
        }

        function Zl(d, e, a, c) {
          const h = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: {
                opacity: 1,
                mix: 0
              }
            }
          };
          if (a === 0 || c) return h;
          if (d.fadingParentID) {
            const f = e.getLoadedTile(d.fadingParentID);
            if (!f) return h;
            const v = Math.pow(2, f.tileID.overscaledZ - d.tileID.overscaledZ),
              w = [d.tileID.canonical.x * v % 1, d.tileID.canonical.y * v % 1],
              T = (function(C, A, j) {
                const R = ge(),
                  Z = (R - A.timeAdded) / j,
                  Y = C.fadingDirection === re.Incoming,
                  oe = l.ai((R - C.timeAdded) / j, 0, 1),
                  le = l.ai(1 - Z, 0, 1),
                  ce = Y ? oe : le;
                return {
                  tileOpacity: ce,
                  parentTileOpacity: Y ? le : oe,
                  fadeMix: {
                    opacity: 1,
                    mix: 1 - ce
                  }
                }
              })(d, f, a);
            return {
              parentTile: f,
              parentScaleBy: v,
              parentTopLeft: w,
              fadeValues: T
            }
          }
          if (d.selfFading) {
            const f = (function(v, w) {
              const T = (ge() - v.timeAdded) / w,
                C = l.ai(T, 0, 1);
              return {
                tileOpacity: C,
                fadeMix: {
                  opacity: C,
                  mix: 0
                }
              }
            })(d, a);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: f
            }
          }
          return h
        }
        const id = new l.bi(1, 0, 0, 1),
          Ts = new l.bi(0, 1, 0, 1),
          au = new l.bi(0, 0, 1, 1),
          Js = new l.bi(1, 0, 1, 1),
          ou = new l.bi(0, 1, 1, 1);

        function su(d, e, a, c) {
          Qs(d, 0, e + a / 2, d.transform.width, a, c)
        }

        function lu(d, e, a, c) {
          Qs(d, e - a / 2, 0, a, d.transform.height, c)
        }

        function Qs(d, e, a, c, h, f) {
          const v = d.context,
            w = v.gl;
          w.enable(w.SCISSOR_TEST), w.scissor(e * d.pixelRatio, a * d.pixelRatio, c * d.pixelRatio, h * d.pixelRatio), v.clear({
            color: f
          }), w.disable(w.SCISSOR_TEST)
        }

        function ad(d, e, a) {
          const c = d.context,
            h = c.gl,
            f = d.useProgram("debug"),
            v = yn.disabled,
            w = Rn.disabled,
            T = d.colorModeForRenderPass(),
            C = "$debug",
            A = d.style.map.terrain && d.style.map.terrain.getTerrainData(a);
          c.activeTexture.set(h.TEXTURE0);
          const j = e.getTileByID(a.key).latestRawTileData,
            R = Math.floor((j && j.byteLength || 0) / 1024),
            Z = e.getTile(a).tileSize,
            Y = 512 / Math.min(Z, 512) * (a.overscaledZ / d.transform.zoom) * .5;
          let oe = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (oe += ` => ${a.overscaledZ}`), (function(ce, me) {
            ce.initDebugOverlayCanvas();
            const Se = ce.debugOverlayCanvas,
              fe = ce.context.gl,
              Pe = ce.debugOverlayCanvas.getContext("2d");
            Pe.clearRect(0, 0, Se.width, Se.height), Pe.shadowColor = "white", Pe.shadowBlur = 2, Pe.lineWidth = 1.5, Pe.strokeStyle = "white", Pe.textBaseline = "top", Pe.font = "bold 36px Open Sans, sans-serif", Pe.fillText(me, 5, 5), Pe.strokeText(me, 5, 5), ce.debugOverlayTexture.update(Se), ce.debugOverlayTexture.bind(fe.LINEAR, fe.CLAMP_TO_EDGE)
          })(d, `${oe} ${R}kB`);
          const le = d.transform.getProjectionData({
            overscaledTileID: a,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          f.draw(c, h.TRIANGLES, v, w, Sn.alphaBlended, vn.disabled, Vc(l.bi.transparent, Y), null, le, C, d.debugBuffer, d.quadTriangleIndexBuffer, d.debugSegments), f.draw(c, h.LINE_STRIP, v, w, T, vn.disabled, Vc(l.bi.red), A, le, C, d.debugBuffer, d.tileBorderIndexBuffer, d.debugSegments)
        }

        function cu(d, e, a, c) {
          const {
            isRenderingGlobe: h
          } = c, f = d.context, v = f.gl, w = d.transform, T = d.colorModeForRenderPass(), C = d.getDepthModeFor3D(), A = d.useProgram("terrain");
          f.bindFramebuffer.set(null), f.viewport.set([0, 0, d.width, d.height]);
          for (const j of a) {
            const R = e.getTerrainMesh(j.tileID),
              Z = d.renderToTexture.getTexture(j),
              Y = e.getTerrainData(j.tileID);
            f.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, Z.texture);
            const oe = e.getMeshFrameDelta(w.zoom),
              le = w.calculateFogMatrix(j.tileID.toUnwrapped()),
              ce = Bp(oe, le, d.style.sky, w.pitch, h),
              me = w.getProjectionData({
                overscaledTileID: j.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            A.draw(f, v.TRIANGLES, C, Rn.disabled, T, vn.backCCW, ce, Y, me, "terrain", R.vertexBuffer, R.indexBuffer, R.segments)
          }
        }

        function Mo(d, e) {
          if (!e.mesh) {
            const a = new l.aP;
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const c = new l.aR;
            c.emplaceBack(0, 1, 2), c.emplaceBack(0, 2, 3), e.mesh = new Gn(d.createVertexBuffer(a, qn.members), d.createIndexBuffer(c), l.aQ.simpleSegment(0, 0, a.length, c.length))
          }
          return e.mesh
        }
        class od {
          constructor(e, a) {
            this.context = new jl(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: l.am(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Tt.maxUnderzooming + Tt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ar
          }
          resize(e, a, c) {
            if (this.width = Math.floor(e * c), this.height = Math.floor(a * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const h of this.style._order) this.style._layers[h].resize()
          }
          setup() {
            const e = this.context,
              a = new l.aP;
            a.emplaceBack(0, 0), a.emplaceBack(l.a3, 0), a.emplaceBack(0, l.a3), a.emplaceBack(l.a3, l.a3), this.tileExtentBuffer = e.createVertexBuffer(a, qn.members), this.tileExtentSegments = l.aQ.simpleSegment(0, 0, 4, 2);
            const c = new l.aP;
            c.emplaceBack(0, 0), c.emplaceBack(l.a3, 0), c.emplaceBack(0, l.a3), c.emplaceBack(l.a3, l.a3), this.debugBuffer = e.createVertexBuffer(c, qn.members), this.debugSegments = l.aQ.simpleSegment(0, 0, 4, 5);
            const h = new l.ca;
            h.emplaceBack(0, 0, 0, 0), h.emplaceBack(l.a3, 0, l.a3, 0), h.emplaceBack(0, l.a3, 0, l.a3), h.emplaceBack(l.a3, l.a3, l.a3, l.a3), this.rasterBoundsBuffer = e.createVertexBuffer(h, Oc.members), this.rasterBoundsSegments = l.aQ.simpleSegment(0, 0, 4, 2);
            const f = new l.aP;
            f.emplaceBack(0, 0), f.emplaceBack(l.a3, 0), f.emplaceBack(0, l.a3), f.emplaceBack(l.a3, l.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(f, qn.members), this.rasterBoundsSegmentsPosOnly = l.aQ.simpleSegment(0, 0, 4, 5);
            const v = new l.aP;
            v.emplaceBack(0, 0), v.emplaceBack(1, 0), v.emplaceBack(0, 1), v.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(v, qn.members), this.viewportSegments = l.aQ.simpleSegment(0, 0, 4, 2);
            const w = new l.cb;
            w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(w);
            const T = new l.aR;
            T.emplaceBack(1, 0, 2), T.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(T);
            const C = this.context.gl;
            this.stencilClearMode = new Rn({
              func: C.ALWAYS,
              mask: 0
            }, 0, 255, C.ZERO, C.ZERO, C.ZERO), this.tileExtentMesh = new Gn(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const c = l.M();
            l.c0(c, 0, this.width, this.height, 0, 0, 1), l.O(c, c, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const h = {
              mainMatrix: c,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: c
            };
            this.useProgram("clippingMask", null, !0).draw(e, a.TRIANGLES, yn.disabled, this.stencilClearMode, Sn.disabled, vn.disabled, null, null, h, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, a, c) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const h = this.context;
            h.setColorMode(Sn.disabled), h.setDepthMode(yn.disabled);
            const f = {};
            for (const v of a) f[v.key] = this.nextStencilID++;
            this._renderTileMasks(f, a, c, !0), this._renderTileMasks(f, a, c, !1), this._tileClippingMaskIDs = f
          }
          _renderTileMasks(e, a, c, h) {
            const f = this.context,
              v = f.gl,
              w = this.style.projection,
              T = this.transform,
              C = this.useProgram("clippingMask");
            for (const A of a) {
              const j = e[A.key],
                R = this.style.map.terrain && this.style.map.terrain.getTerrainData(A),
                Z = w.getMeshFromTileID(this.context, A.canonical, h, !0, "stencil"),
                Y = T.getProjectionData({
                  overscaledTileID: A,
                  applyGlobeMatrix: !c,
                  applyTerrainMatrix: !0
                });
              C.draw(f, v.TRIANGLES, yn.disabled, new Rn({
                func: v.ALWAYS,
                mask: 0
              }, j, 255, v.KEEP, v.KEEP, v.REPLACE), Sn.disabled, c ? vn.disabled : vn.backCCW, null, R, Y, "$clipping", Z.vertexBuffer, Z.indexBuffer, Z.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              a = e.gl,
              c = this.style.projection,
              h = this.transform,
              f = this.useProgram("depth"),
              v = this.getDepthModeFor3D(),
              w = $e(h, {
                tileSize: h.tileSize
              });
            for (const T of w) {
              const C = this.style.map.terrain && this.style.map.terrain.getTerrainData(T),
                A = c.getMeshFromTileID(this.context, T.canonical, !0, !0, "raster"),
                j = h.getProjectionData({
                  overscaledTileID: T,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              f.draw(e, a.TRIANGLES, v, Rn.disabled, Sn.disabled, vn.backCCW, null, C, j, "$clipping", A.vertexBuffer, A.indexBuffer, A.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              a = this.context.gl;
            return new Rn({
              func: a.NOTEQUAL,
              mask: 255
            }, e, 255, a.KEEP, a.KEEP, a.REPLACE)
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new Rn({
              func: a.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl,
              c = e.sort(((v, w) => w.overscaledZ - v.overscaledZ)),
              h = c[c.length - 1].overscaledZ,
              f = c[0].overscaledZ - h + 1;
            if (f > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + f > 256 && this.clearStencil();
              const v = {};
              for (let w = 0; w < f; w++) v[w + h] = new Rn({
                func: a.GEQUAL,
                mask: 255
              }, w + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += f, [v, c]
            }
            return [{
              [h]: Rn.disabled
            }, c]
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl,
              c = e.sort(((v, w) => w.overscaledZ - v.overscaledZ)),
              h = c[c.length - 1].overscaledZ,
              f = c[0].overscaledZ - h + 1;
            if (this.clearStencil(), f > 1) {
              const v = {},
                w = {};
              for (let T = 0; T < f; T++) v[T + h] = new Rn({
                func: a.GREATER,
                mask: 255
              }, f + 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE), w[T + h] = new Rn({
                func: a.GREATER,
                mask: 255
              }, 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * f + 1, [v, w, c]
            }
            return this.nextStencilID = 3, [{
              [h]: new Rn({
                func: a.GREATER,
                mask: 255
              }, 2, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, {
              [h]: new Rn({
                func: a.GREATER,
                mask: 255
              }, 1, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, c]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Sn([e.CONSTANT_COLOR, e.ONE], new l.bi(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Sn.unblended : Sn.alphaBlended
          }
          getDepthModeForSublayer(e, a, c) {
            if (!this.opaquePassEnabledForLayer()) return yn.disabled;
            const h = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new yn(c || this.context.gl.LEQUAL, a, [h, h])
          }
          getDepthModeFor3D() {
            return new yn(this.context.gl.LEQUAL, yn.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, a) {
            var c, h;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(ge()), this.imageManager.beginFrame();
            const f = this.style._order,
              v = this.style.tileManagers,
              w = {},
              T = {},
              C = {},
              A = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((c = e.projection) === null || c === void 0 ? void 0 : c.transitionState) > 0
              };
            for (const R in v) {
              const Z = v[R];
              Z.used && Z.prepare(this.context), w[R] = Z.getVisibleCoordinates(!1), T[R] = w[R].slice().reverse(), C[R] = Z.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let R = 0; R < f.length; R++)
              if (this.style._layers[f[R]].is3D()) {
                this.opaquePassCutoff = R;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const R of f) {
              const Z = this.style._layers[R];
              if (!Z.hasOffscreenPass() || Z.isHidden(this.transform.zoom)) continue;
              const Y = T[Z.source];
              (Z.type === "custom" || Y.length) && this.renderLayer(this, v[Z.source], Z, Y, A)
            }
            if ((h = this.style.projection) === null || h === void 0 || h.updateGPUdependent({
                context: this.context,
                useProgram: R => this.useProgram(R)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: a.showOverdrawInspector ? l.bi.black : l.bi.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(R, Z) {
                const Y = R.context,
                  oe = Y.gl,
                  le = ((Ae, ve, Oe) => {
                    const ct = Math.cos(ve.rollInRadians),
                      it = Math.sin(ve.rollInRadians),
                      st = Be(ve),
                      ut = ve.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Ae.properties.get("sky-color"),
                      u_horizon_color: Ae.properties.get("horizon-color"),
                      u_horizon: [(ve.width / 2 - st * it) * Oe, (ve.height / 2 + st * ct) * Oe],
                      u_horizon_normal: [-it, ct],
                      u_sky_horizon_blend: Ae.properties.get("sky-horizon-blend") * ve.height / 2 * Oe,
                      u_sky_blend: ut
                    }
                  })(Z, R.style.map.transform, R.pixelRatio),
                  ce = new yn(oe.LEQUAL, yn.ReadWrite, [0, 1]),
                  me = Rn.disabled,
                  Se = R.colorModeForRenderPass(),
                  fe = R.useProgram("sky"),
                  Pe = Mo(Y, Z);
                fe.draw(Y, oe.TRIANGLES, ce, me, Se, vn.disabled, le, null, void 0, "sky", Pe.vertexBuffer, Pe.indexBuffer, Pe.segments)
              })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = f.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const R = this.style._layers[f[this.currentLayer]],
                  Z = v[R.source],
                  Y = w[R.source];
                this._renderTileClippingMasks(R, Y, !1), this.renderLayer(this, Z, R, Y, A)
              }
            this.renderPass = "translucent";
            let j = !1;
            for (this.currentLayer = 0; this.currentLayer < f.length; this.currentLayer++) {
              const R = this.style._layers[f[this.currentLayer]],
                Z = v[R.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(R, A)) continue;
              this.opaquePassEnabledForLayer() || j || (j = !0, A.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const Y = (R.type === "symbol" ? C : T)[R.source];
              this._renderTileClippingMasks(R, w[R.source], !!this.renderToTexture), this.renderLayer(this, Z, R, Y, A)
            }
            if (A.isRenderingGlobe && (function(R, Z, Y) {
                const oe = R.context,
                  le = oe.gl,
                  ce = R.useProgram("atmosphere"),
                  me = new yn(le.LEQUAL, yn.ReadOnly, [0, 1]),
                  Se = R.transform,
                  fe = (function(ut, or) {
                    const cr = ut.properties.get("position"),
                      Bt = [-cr.x, -cr.y, -cr.z],
                      Nr = l.am(new Float64Array(16));
                    return ut.properties.get("anchor") === "map" && (l.b9(Nr, Nr, or.rollInRadians), l.ba(Nr, Nr, -or.pitchInRadians), l.b9(Nr, Nr, or.bearingInRadians), l.ba(Nr, Nr, or.center.lat * Math.PI / 180), l.bC(Nr, Nr, -or.center.lng * Math.PI / 180)), l.c9(Bt, Bt, Nr), Bt
                  })(Y, R.transform),
                  Pe = Se.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Ae = Z.properties.get("atmosphere-blend") * Pe.projectionTransition;
                if (Ae === 0) return;
                const ve = Va(Se.worldSize, Se.center.lat),
                  Oe = Se.inverseProjectionMatrix,
                  ct = new Float64Array(4);
                ct[3] = 1, l.aA(ct, ct, Se.modelViewProjectionMatrix), ct[0] /= ct[3], ct[1] /= ct[3], ct[2] /= ct[3], ct[3] = 1, l.aA(ct, ct, Oe), ct[0] /= ct[3], ct[1] /= ct[3], ct[2] /= ct[3], ct[3] = 1;
                const it = ((ut, or, cr, Bt, Nr) => ({
                    u_sun_pos: ut,
                    u_atmosphere_blend: or,
                    u_globe_position: cr,
                    u_globe_radius: Bt,
                    u_inv_proj_matrix: Nr
                  }))(fe, Ae, [ct[0], ct[1], ct[2]], ve, Oe),
                  st = Mo(oe, Z);
                ce.draw(oe, le.TRIANGLES, me, Rn.disabled, Sn.alphaBlended, vn.disabled, it, null, null, "atmosphere", st.vertexBuffer, st.indexBuffer, st.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const R = (function(Z, Y) {
                let oe = null;
                const le = Object.values(Z._layers).flatMap((fe => fe.source && !fe.isHidden(Y) ? [Z.tileManagers[fe.source]] : [])),
                  ce = le.filter((fe => fe.getSource().type === "vector")),
                  me = le.filter((fe => fe.getSource().type !== "vector")),
                  Se = fe => {
                    (!oe || oe.getSource().maxzoom < fe.getSource().maxzoom) && (oe = fe)
                  };
                return ce.forEach((fe => Se(fe))), oe || me.forEach((fe => Se(fe))), oe
              })(this.style, this.transform.zoom);
              R && (function(Z, Y, oe) {
                for (let le = 0; le < oe.length; le++) ad(Z, Y, oe[le])
              })(this, R, R.getVisibleCoordinates())
            }
            this.options.showPadding && (function(R) {
              const Z = R.transform.padding;
              su(R, R.transform.height - (Z.top || 0), 3, id), su(R, Z.bottom || 0, 3, Ts), lu(R, Z.left || 0, 3, au), lu(R, R.transform.width - (Z.right || 0), 3, Js);
              const Y = R.transform.centerPoint;
              (function(oe, le, ce, me) {
                Qs(oe, le - 1, ce - 10, 2, 20, me), Qs(oe, le - 10, ce - 1, 20, 2, me)
              })(R, Y.x, R.transform.height - Y.y, ou)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix,
              c = this.transform.modelViewProjectionMatrix;
            let h = this.terrainFacilitator.dirty;
            h || (h = e ? !l.cc(a, c) : !l.cd(a, c)), h || (h = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), h && (l.ce(a, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(f, v) {
              const w = f.context,
                T = w.gl,
                C = f.transform,
                A = Sn.unblended,
                j = new yn(T.LEQUAL, yn.ReadWrite, [0, 1]),
                R = v.tileManager.getRenderableTiles(),
                Z = f.useProgram("terrainDepth");
              w.bindFramebuffer.set(v.getFramebuffer("depth").framebuffer), w.viewport.set([0, 0, f.width / devicePixelRatio, f.height / devicePixelRatio]), w.clear({
                color: l.bi.transparent,
                depth: 1
              });
              for (const Y of R) {
                const oe = v.getTerrainMesh(Y.tileID),
                  le = v.getTerrainData(Y.tileID),
                  ce = C.getProjectionData({
                    overscaledTileID: Y.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  me = {
                    u_ele_delta: v.getMeshFrameDelta(C.zoom)
                  };
                Z.draw(w, T.TRIANGLES, j, Rn.disabled, A, vn.backCCW, me, le, ce, "terrain", oe.vertexBuffer, oe.indexBuffer, oe.segments)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, f.width, f.height])
            })(this, this.style.map.terrain), (function(f, v) {
              const w = f.context,
                T = w.gl,
                C = f.transform,
                A = Sn.unblended,
                j = new yn(T.LEQUAL, yn.ReadWrite, [0, 1]),
                R = v.getCoordsTexture(),
                Z = v.tileManager.getRenderableTiles(),
                Y = f.useProgram("terrainCoords");
              w.bindFramebuffer.set(v.getFramebuffer("coords").framebuffer), w.viewport.set([0, 0, f.width / devicePixelRatio, f.height / devicePixelRatio]), w.clear({
                color: l.bi.transparent,
                depth: 1
              }), v.coordsIndex = [];
              for (const oe of Z) {
                const le = v.getTerrainMesh(oe.tileID),
                  ce = v.getTerrainData(oe.tileID);
                w.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, R.texture);
                const me = {
                    u_terrain_coords_id: (255 - v.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: v.getMeshFrameDelta(C.zoom)
                  },
                  Se = C.getProjectionData({
                    overscaledTileID: oe.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                Y.draw(w, T.TRIANGLES, j, Rn.disabled, A, vn.backCCW, me, ce, Se, "terrain", le.vertexBuffer, le.indexBuffer, le.segments), v.coordsIndex.push(oe.tileID.key)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, f.width, f.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, a, c, h, f) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || (h || []).length) && (this.id = c.id, l.cf(c) ? (function(v, w, T, C, A, j) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = j, Z = Rn.disabled, Y = v.colorModeForRenderPass();
              (T._unevaluatedLayout.hasValue("text-variable-anchor") || T._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(oe, le, ce, me, Se, fe, Pe, Ae, ve) {
                const Oe = le.transform,
                  ct = le.style.map.terrain,
                  it = Se === "map",
                  st = fe === "map";
                for (const ut of oe) {
                  const or = me.getTile(ut),
                    cr = or.getBucket(ce);
                  if (!cr || !cr.text || !cr.text.segments.get().length) continue;
                  const Bt = l.ar(cr.textSizeData, Oe.zoom),
                    Nr = l.aG(or, 1, le.transform.zoom),
                    xn = Jt(it, le.transform, Nr),
                    Xn = ce.layout.get("icon-text-fit") !== "none" && cr.hasIconData();
                  if (Bt) {
                    const zn = Math.pow(2, Oe.zoom - or.tileID.overscaledZ),
                      ti = ct ? (mi, ni) => ct.getElevation(ut, mi, ni) : null;
                    Bl(cr, it, st, ve, Oe, xn, zn, Bt, Xn, l.aH(Oe, or, Pe, Ae), ut.toUnwrapped(), ti)
                  }
                }
              })(C, v, T, w, T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), A), T.paint.get("icon-opacity").constantOr(1) !== 0 && Ho(v, w, T, C, !1, T.paint.get("icon-translate"), T.paint.get("icon-translate-anchor"), T.layout.get("icon-rotation-alignment"), T.layout.get("icon-pitch-alignment"), T.layout.get("icon-keep-upright"), Z, Y, R), T.paint.get("text-opacity").constantOr(1) !== 0 && Ho(v, w, T, C, !0, T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.layout.get("text-keep-upright"), Z, Y, R), w.map.showCollisionBoxes && (Xs(v, w, T, C, !0), Xs(v, w, T, C, !1))
            })(e, a, c, h, this.style.placement.variableOffsets, f) : l.cg(c) ? (function(v, w, T, C, A) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: j
              } = A, R = T.paint.get("circle-opacity"), Z = T.paint.get("circle-stroke-width"), Y = T.paint.get("circle-stroke-opacity"), oe = !T.layout.get("circle-sort-key").isConstant();
              if (R.constantOr(1) === 0 && (Z.constantOr(1) === 0 || Y.constantOr(1) === 0)) return;
              const le = v.context,
                ce = le.gl,
                me = v.transform,
                Se = v.getDepthModeForSublayer(0, yn.ReadOnly),
                fe = Rn.disabled,
                Pe = v.colorModeForRenderPass(),
                Ae = [],
                ve = me.getCircleRadiusCorrection();
              for (let Oe = 0; Oe < C.length; Oe++) {
                const ct = C[Oe],
                  it = w.getTile(ct),
                  st = it.getBucket(T);
                if (!st) continue;
                const ut = T.paint.get("circle-translate"),
                  or = T.paint.get("circle-translate-anchor"),
                  cr = l.aH(me, it, ut, or),
                  Bt = st.programConfigurations.get(T.id),
                  Nr = v.useProgram("circle", Bt),
                  xn = st.layoutVertexBuffer,
                  Xn = st.indexBuffer,
                  zn = v.style.map.terrain && v.style.map.terrain.getTerrainData(ct),
                  ti = {
                    programConfiguration: Bt,
                    program: Nr,
                    layoutVertexBuffer: xn,
                    indexBuffer: Xn,
                    uniformValues: Np(v, it, T, cr, ve),
                    terrainData: zn,
                    projectionData: me.getProjectionData({
                      overscaledTileID: ct,
                      applyGlobeMatrix: !j,
                      applyTerrainMatrix: !0
                    })
                  };
                if (oe) {
                  const mi = st.segments.get();
                  for (const ni of mi) Ae.push({
                    segments: new l.aQ([ni]),
                    sortKey: ni.sortKey,
                    state: ti
                  })
                } else Ae.push({
                  segments: st.segments,
                  sortKey: 0,
                  state: ti
                })
              }
              oe && Ae.sort(((Oe, ct) => Oe.sortKey - ct.sortKey));
              for (const Oe of Ae) {
                const {
                  programConfiguration: ct,
                  program: it,
                  layoutVertexBuffer: st,
                  indexBuffer: ut,
                  uniformValues: or,
                  terrainData: cr,
                  projectionData: Bt
                } = Oe.state;
                it.draw(le, ce.TRIANGLES, Se, fe, Pe, vn.backCCW, or, cr, Bt, T.id, st, ut, Oe.segments, T.paint, v.transform.zoom, ct)
              }
            })(e, a, c, h, f) : l.ch(c) ? (function(v, w, T, C, A) {
              if (T.paint.get("heatmap-opacity") === 0) return;
              const j = v.context,
                {
                  isRenderingToTexture: R,
                  isRenderingGlobe: Z
                } = A;
              if (v.style.map.terrain) {
                for (const Y of C) {
                  const oe = w.getTile(Y);
                  w.hasRenderableParent(Y) || (v.renderPass === "offscreen" ? Jp(v, oe, T, Y, Z) : v.renderPass === "translucent" && Ys(v, T, Y, R, Z))
                }
                j.viewport.set([0, 0, v.width, v.height])
              } else v.renderPass === "offscreen" ? (function(Y, oe, le, ce) {
                const me = Y.context,
                  Se = me.gl,
                  fe = Y.transform,
                  Pe = Rn.disabled,
                  Ae = new Sn([Se.ONE, Se.ONE], l.bi.transparent, [!0, !0, !0, !0]);
                (function(ve, Oe, ct) {
                  const it = ve.gl;
                  ve.activeTexture.set(it.TEXTURE1), ve.viewport.set([0, 0, Oe.width / 4, Oe.height / 4]);
                  let st = ct.heatmapFbos.get(l.c6);
                  st ? (it.bindTexture(it.TEXTURE_2D, st.colorAttachment.get()), ve.bindFramebuffer.set(st.framebuffer)) : (st = ed(ve, Oe.width / 4, Oe.height / 4), ct.heatmapFbos.set(l.c6, st))
                })(me, Y, le), me.clear({
                  color: l.bi.transparent
                });
                for (let ve = 0; ve < ce.length; ve++) {
                  const Oe = ce[ve];
                  if (oe.hasRenderableParent(Oe)) continue;
                  const ct = oe.getTile(Oe),
                    it = ct.getBucket(le);
                  if (!it) continue;
                  const st = it.programConfigurations.get(le.id),
                    ut = Y.useProgram("heatmap", st),
                    or = fe.getProjectionData({
                      overscaledTileID: Oe,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    cr = fe.getCircleRadiusCorrection();
                  ut.draw(me, Se.TRIANGLES, yn.disabled, Pe, Ae, vn.backCCW, Uc(ct, fe.zoom, le.paint.get("heatmap-intensity"), cr), null, or, le.id, it.layoutVertexBuffer, it.indexBuffer, it.segments, le.paint, fe.zoom, st)
                }
                me.viewport.set([0, 0, Y.width, Y.height])
              })(v, w, T, C) : v.renderPass === "translucent" && (function(Y, oe) {
                const le = Y.context,
                  ce = le.gl;
                le.setColorMode(Y.colorModeForRenderPass());
                const me = oe.heatmapFbos.get(l.c6);
                me && (le.activeTexture.set(ce.TEXTURE0), ce.bindTexture(ce.TEXTURE_2D, me.colorAttachment.get()), le.activeTexture.set(ce.TEXTURE1), nu(le, oe).bind(ce.LINEAR, ce.CLAMP_TO_EDGE), Y.useProgram("heatmapTexture").draw(le, ce.TRIANGLES, yn.disabled, Rn.disabled, Y.colorModeForRenderPass(), vn.disabled, Zc(Y, oe, 0, 1), null, null, oe.id, Y.viewportBuffer, Y.quadTriangleIndexBuffer, Y.viewportSegments, oe.paint, Y.transform.zoom))
              })(v, T)
            })(e, a, c, h, f) : l.ci(c) ? (function(v, w, T, C, A) {
              if (v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: j
              } = A, R = T.paint.get("line-opacity"), Z = T.paint.get("line-width");
              if (R.constantOr(1) === 0 || Z.constantOr(1) === 0) return;
              const Y = v.getDepthModeForSublayer(0, yn.ReadOnly),
                oe = v.colorModeForRenderPass(),
                le = T.paint.get("line-dasharray"),
                ce = le.constantOr(1),
                me = T.paint.get("line-pattern"),
                Se = me.constantOr(1),
                fe = T.paint.get("line-gradient"),
                Pe = T.getCrossfadeParameters();
              let Ae;
              Ae = Se ? "linePattern" : ce && fe ? "lineGradientSDF" : ce ? "lineSDF" : fe ? "lineGradient" : "line";
              const ve = v.context,
                Oe = ve.gl,
                ct = v.transform;
              let it = !0;
              for (const st of C) {
                const ut = w.getTile(st);
                if (Se && !ut.patternsLoaded()) continue;
                const or = ut.getBucket(T);
                if (!or) continue;
                const cr = or.programConfigurations.get(T.id),
                  Bt = v.context.program.get(),
                  Nr = v.useProgram(Ae, cr),
                  xn = it || Nr.program !== Bt,
                  Xn = v.style.map.terrain && v.style.map.terrain.getTerrainData(st),
                  zn = me.constantOr(null),
                  ti = le && le.constantOr(null);
                if (zn && ut.imageAtlas) {
                  const Ui = ut.imageAtlas,
                    ui = Ui.patternPositions[zn.to.toString()],
                    Ci = Ui.patternPositions[zn.from.toString()];
                  ui && Ci && cr.setConstantPatternPositions(ui, Ci)
                } else if (ti) {
                  const Ui = T.layout.get("line-cap") === "round",
                    ui = v.lineAtlas.getDash(ti.to, Ui),
                    Ci = v.lineAtlas.getDash(ti.from, Ui);
                  cr.setConstantDashPositions(ui, Ci)
                }
                const mi = ct.getProjectionData({
                    overscaledTileID: st,
                    applyGlobeMatrix: !j,
                    applyTerrainMatrix: !0
                  }),
                  ni = ct.getPixelScale();
                let Ei;
                Se ? (Ei = Pl(v, ut, T, ni, Pe), iu(ve, Oe, ut, cr, Pe)) : ce && fe ? (Ei = Zp(v, ut, T, ni, Pe, or.lineClipsArray.length), Nl(v, w, ve, Oe, T, or, st, cr, Pe)) : ce ? (Ei = Up(v, ut, T, ni, Pe), td(v, ve, Oe, cr, xn, Pe)) : fe ? (Ei = Vp(v, ut, T, ni, or.lineClipsArray.length), rd(v, w, ve, Oe, T, or, st)) : Ei = Po(v, ut, T, ni);
                const ci = v.stencilModeForClipping(st);
                Nr.draw(ve, Oe.TRIANGLES, Y, ci, oe, vn.disabled, Ei, Xn, mi, T.id, or.layoutVertexBuffer, or.indexBuffer, or.segments, T.paint, v.transform.zoom, cr, or.layoutVertexBuffer2), it = !1
              }
            })(e, a, c, h, f) : l.cj(c) ? (function(v, w, T, C, A) {
              const j = T.paint.get("fill-color"),
                R = T.paint.get("fill-opacity");
              if (R.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: Z
              } = A, Y = v.colorModeForRenderPass(), oe = T.paint.get("fill-pattern"), le = v.opaquePassEnabledForLayer() && !oe.constantOr(1) && j.constantOr(l.bi.transparent).a === 1 && R.constantOr(0) === 1 ? "opaque" : "translucent";
              if (v.renderPass === le) {
                const ce = v.getDepthModeForSublayer(1, v.renderPass === "opaque" ? yn.ReadWrite : yn.ReadOnly);
                nd(v, w, T, C, ce, Y, !1, Z)
              }
              if (v.renderPass === "translucent" && T.paint.get("fill-antialias")) {
                const ce = v.getDepthModeForSublayer(T.getPaintProperty("fill-outline-color") ? 2 : 0, yn.ReadOnly);
                nd(v, w, T, C, ce, Y, !0, Z)
              }
            })(e, a, c, h, f) : l.ck(c) ? (function(v, w, T, C, A) {
              const j = T.paint.get("fill-extrusion-opacity");
              if (j === 0) return;
              const {
                isRenderingToTexture: R
              } = A;
              if (v.renderPass === "translucent") {
                const Z = new yn(v.context.gl.LEQUAL, yn.ReadWrite, v.depthRangeFor3D);
                if (j !== 1 || T.paint.get("fill-extrusion-pattern").constantOr(1)) Ul(v, w, T, C, Z, Rn.disabled, Sn.disabled, R), Ul(v, w, T, C, Z, v.stencilModeFor3D(), v.colorModeForRenderPass(), R);
                else {
                  const Y = v.colorModeForRenderPass();
                  Ul(v, w, T, C, Z, Rn.disabled, Y, R)
                }
              }
            })(e, a, c, h, f) : l.cl(c) ? (function(v, w, T, C, A) {
              if (v.renderPass !== "offscreen" && v.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: j
              } = A, R = v.context, Z = v.style.projection.useSubdivision, Y = v.getDepthModeForSublayer(0, yn.ReadOnly), oe = v.colorModeForRenderPass();
              if (v.renderPass === "offscreen")(function(le, ce, me, Se, fe, Pe, Ae) {
                const ve = le.context,
                  Oe = ve.gl;
                for (const ct of me) {
                  const it = ce.getTile(ct),
                    st = it.dem;
                  if (!st || !st.data || !it.needsHillshadePrepare) continue;
                  const ut = st.dim,
                    or = st.stride,
                    cr = st.getPixels();
                  if (ve.activeTexture.set(Oe.TEXTURE1), ve.pixelStoreUnpackPremultiplyAlpha.set(!1), it.demTexture = it.demTexture || le.getTileTexture(or), it.demTexture) {
                    const Nr = it.demTexture;
                    Nr.update(cr, {
                      premultiply: !1
                    }), Nr.bind(Oe.NEAREST, Oe.CLAMP_TO_EDGE)
                  } else it.demTexture = new l.T(ve, cr, Oe.RGBA, {
                    premultiply: !1
                  }), it.demTexture.bind(Oe.NEAREST, Oe.CLAMP_TO_EDGE);
                  ve.activeTexture.set(Oe.TEXTURE0);
                  let Bt = it.fbo;
                  if (!Bt) {
                    const Nr = new l.T(ve, {
                      width: ut,
                      height: ut,
                      data: null
                    }, Oe.RGBA);
                    Nr.bind(Oe.LINEAR, Oe.CLAMP_TO_EDGE), Bt = it.fbo = ve.createFramebuffer(ut, ut, !0, !1), Bt.colorAttachment.set(Nr.texture)
                  }
                  ve.bindFramebuffer.set(Bt.framebuffer), ve.viewport.set([0, 0, ut, ut]), le.useProgram("hillshadePrepare").draw(ve, Oe.TRIANGLES, fe, Pe, Ae, vn.disabled, No(it.tileID, st), null, null, Se.id, le.rasterBoundsBuffer, le.quadTriangleIndexBuffer, le.rasterBoundsSegments), it.needsHillshadePrepare = !1
                }
              })(v, w, C, T, Y, Rn.disabled, oe), R.viewport.set([0, 0, v.width, v.height]);
              else if (v.renderPass === "translucent")
                if (Z) {
                  const [le, ce, me] = v.stencilConfigForOverlapTwoPass(C);
                  fi(v, w, T, me, le, Y, oe, !1, j), fi(v, w, T, me, ce, Y, oe, !0, j)
                } else {
                  const [le, ce] = v.getStencilConfigForOverlapAndUpdateStencilID(C);
                  fi(v, w, T, ce, le, Y, oe, !1, j)
                }
            })(e, a, c, h, f) : l.cm(c) ? (function(v, w, T, C, A) {
              if (v.renderPass !== "translucent" || !C.length) return;
              const {
                isRenderingToTexture: j
              } = A, R = v.style.projection.useSubdivision, Z = v.getDepthModeForSublayer(0, yn.ReadOnly), Y = v.colorModeForRenderPass();
              if (R) {
                const [oe, le, ce] = v.stencilConfigForOverlapTwoPass(C);
                co(v, w, T, ce, oe, Z, Y, !1, j), co(v, w, T, ce, le, Z, Y, !0, j)
              } else {
                const [oe, le] = v.getStencilConfigForOverlapAndUpdateStencilID(C);
                co(v, w, T, le, oe, Z, Y, !1, j)
              }
            })(e, a, c, h, f) : l.bN(c) ? (function(v, w, T, C, A) {
              if (v.renderPass !== "translucent" || T.paint.get("raster-opacity") === 0 || !C.length) return;
              const {
                isRenderingToTexture: j
              } = A, R = w.getSource(), Z = v.style.projection.useSubdivision;
              if (R instanceof kr) ks(v, w, T, C, null, !1, !1, R.tileCoords, R.flippedWindingOrder, j);
              else if (Z) {
                const [Y, oe, le] = v.stencilConfigForOverlapTwoPass(C);
                ks(v, w, T, le, Y, !1, !0, ma, !1, j), ks(v, w, T, le, oe, !0, !0, ma, !1, j)
              } else {
                const [Y, oe] = v.getStencilConfigForOverlapAndUpdateStencilID(C);
                ks(v, w, T, oe, Y, !1, !0, ma, !1, j)
              }
            })(e, a, c, h, f) : l.cn(c) ? (function(v, w, T, C, A) {
              const j = T.paint.get("background-color"),
                R = T.paint.get("background-opacity");
              if (R === 0) return;
              const {
                isRenderingToTexture: Z
              } = A, Y = v.context, oe = Y.gl, le = v.style.projection, ce = v.transform, me = ce.tileSize, Se = T.paint.get("background-pattern");
              if (v.isPatternMissing(Se)) return;
              const fe = !Se && j.a === 1 && R === 1 && v.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (v.renderPass !== fe) return;
              const Pe = Rn.disabled,
                Ae = v.getDepthModeForSublayer(0, fe === "opaque" ? yn.ReadWrite : yn.ReadOnly),
                ve = v.colorModeForRenderPass(),
                Oe = v.useProgram(Se ? "backgroundPattern" : "background"),
                ct = C || $e(ce, {
                  tileSize: me,
                  terrain: v.style.map.terrain
                });
              Se && (Y.activeTexture.set(oe.TEXTURE0), v.imageManager.bind(v.context));
              const it = T.getCrossfadeParameters();
              for (const st of ct) {
                const ut = ce.getProjectionData({
                    overscaledTileID: st,
                    applyGlobeMatrix: !Z,
                    applyTerrainMatrix: !0
                  }),
                  or = Se ? Xc(R, v, Se, {
                    tileID: st,
                    tileSize: me
                  }, it) : $c(R, j),
                  cr = v.style.map.terrain && v.style.map.terrain.getTerrainData(st),
                  Bt = le.getMeshFromTileID(Y, st.canonical, !1, !0, "raster");
                Oe.draw(Y, oe.TRIANGLES, Ae, Pe, ve, vn.backCCW, or, cr, ut, T.id, Bt.vertexBuffer, Bt.indexBuffer, Bt.segments)
              }
            })(e, 0, c, h, f) : l.co(c) && (function(v, w, T, C) {
              const {
                isRenderingGlobe: A
              } = C, j = v.context, R = T.implementation, Z = v.style.projection, Y = v.transform, oe = Y.getProjectionDataForCustomLayer(A), le = {
                farZ: Y.farZ,
                nearZ: Y.nearZ,
                fov: Y.fov * Math.PI / 180,
                modelViewProjectionMatrix: Y.modelViewProjectionMatrix,
                projectionMatrix: Y.projectionMatrix,
                shaderData: {
                  variantName: Z.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${Z.shaderPreludeCode.vertexSource}`,
                  define: Z.shaderDefine
                },
                defaultProjectionData: oe
              }, ce = R.renderingMode ? R.renderingMode : "2d";
              if (v.renderPass === "offscreen") {
                const me = R.prerender;
                me && (v.setCustomLayerDefaults(), j.setColorMode(v.colorModeForRenderPass()), me.call(R, j.gl, le), j.setDirty(), v.setBaseState())
              } else if (v.renderPass === "translucent") {
                v.setCustomLayerDefaults(), j.setColorMode(v.colorModeForRenderPass()), j.setStencilMode(Rn.disabled);
                const me = ce === "3d" ? v.getDepthModeFor3D() : v.getDepthModeForSublayer(0, yn.ReadOnly);
                j.setDepthMode(me), R.render(j.gl, le), j.setDirty(), v.setBaseState(), j.bindFramebuffer.set(null)
              }
            })(e, 0, c, f))
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const a = this.imageManager.getPattern(e.from.toString()),
              c = this.imageManager.getPattern(e.to.toString());
            return !a || !c
          }
          useProgram(e, a, c = !1, h = []) {
            this.cache = this.cache || {};
            const f = !!this.style.map.terrain,
              v = this.style.projection,
              w = c ? Ir.projectionMercator : v.shaderPreludeCode,
              T = c ? Ln : v.shaderDefine,
              C = e + (a ? a.cacheKey : "") + `/${c?Pn:v.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (f ? "/terrain" : "") + (h ? `/${h.join("/")}` : "");
            return this.cache[C] || (this.cache[C] = new Zs(this.context, Ir[e], a, Uh[e], this._showOverdrawInspector, f, w, T, h)), this.cache[C]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new l.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: a
            } = this.context.gl;
            return this.width !== e || this.height !== a
          }
        }

        function uu(d, e) {
          let a, c = !1,
            h = null,
            f = null;
          const v = () => {
            h = null, c && (d.apply(f, a), h = setTimeout(v, e), c = !1)
          };
          return (...w) => (c = !0, f = this, a = w, h || v(), h)
        }
        class hu {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let c;
                return a.split("&").map((h => h.split("="))).forEach((h => {
                  h[0] === this._hashName && (c = h)
                })), (c && c[1] || "").split("/")
              }
              return a.split("/")
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return !1;
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+a[2], +a[1]],
                zoom: +a[0],
                bearing: c,
                pitch: +(a[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a)
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const c = a.join("/");
              let h = c;
              h.split("&").length > 0 && (h = h.split("&")[0]), this._hashName && (h = `${this._hashName}=${c}`);
              let f = window.location.hash.replace(h, "");
              f.startsWith("#&") ? f = f.slice(0, 1) + f.slice(2) : f === "#" && (f = "");
              let v = window.location.href.replace(/(#.+)?$/, f);
              v = v.replace("&&", "&"), window.history.replaceState(window.history.state, null, v)
            }, this._updateHash = uu(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const a = this._map.getCenter(),
              c = Math.round(100 * this._map.getZoom()) / 100,
              h = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              f = Math.pow(10, h),
              v = Math.round(a.lng * f) / f,
              w = Math.round(a.lat * f) / f,
              T = this._map.getBearing(),
              C = this._map.getPitch();
            let A = "";
            if (A += e ? `/${v}/${w}/${c}` : `${c}/${w}/${v}`, (T || C) && (A += "/" + Math.round(10 * T) / 10), C && (A += `/${Math.round(C)}`), this._hashName) {
              const j = this._hashName;
              let R = !1;
              const Z = window.location.hash.slice(1).split("&").map((Y => {
                const oe = Y.split("=")[0];
                return oe === j ? (R = !0, `${oe}=${A}`) : Y
              })).filter((Y => Y));
              return R || Z.push(`${j}=${A}`), `#${Z.join("&")}`
            }
            return `#${A}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new l.U(+e[2], +e[1])
            } catch {
              return !1
            }
            const a = +e[0],
              c = +(e[3] || 0),
              h = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && c >= -180 && c <= 180 && h >= this._map.getMinPitch() && h <= this._map.getMaxPitch()
          }
        }
        const Ss = {
            linearity: .3,
            easing: l.cp(0, 0, .3, 1)
          },
          sd = l.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, Ss),
          ld = l.e({
            deceleration: 20,
            maxSpeed: 1400
          }, Ss),
          cd = l.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Ss),
          ud = l.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, Ss),
          Gl = l.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Ss);
        class hd {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: ge(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              a = ge();
            for (; e.length > 0 && a - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new l.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: f
              }
              of this._inertiaBuffer) a.zoom += f.zoomDelta || 0, a.bearing += f.bearingDelta || 0, a.pitch += f.pitchDelta || 0, a.roll += f.rollDelta || 0, f.panDelta && a.pan._add(f.panDelta), f.around && (a.around = f.around), f.pinchAround && (a.pinchAround = f.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              h = {};
            if (a.pan.mag()) {
              const f = ca(a.pan.mag(), c, l.e({}, sd, e || {})),
                v = a.pan.mult(f.amount / a.pan.mag()),
                w = this._map.cameraHelper.handlePanInertia(v, this._map.transform);
              h.center = w.easingCenter, h.offset = w.easingOffset, aa(h, f)
            }
            if (a.zoom) {
              const f = ca(a.zoom, c, ld);
              h.zoom = this._map.transform.zoom + f.amount, aa(h, f)
            }
            if (a.bearing) {
              const f = ca(a.bearing, c, cd);
              h.bearing = this._map.transform.bearing + l.ai(f.amount, -179, 179), aa(h, f)
            }
            if (a.pitch) {
              const f = ca(a.pitch, c, ud);
              h.pitch = this._map.transform.pitch + f.amount, aa(h, f)
            }
            if (a.roll) {
              const f = ca(a.roll, c, Gl);
              h.roll = this._map.transform.roll + l.ai(f.amount, -179, 179), aa(h, f)
            }
            if (h.zoom || h.bearing) {
              const f = a.pinchAround === void 0 ? a.around : a.pinchAround;
              h.around = f ? this._map.unproject(f) : this._map.getCenter()
            }
            return this.clear(), l.e(h, {
              noMoveStart: !0
            })
          }
        }

        function aa(d, e) {
          (!d.duration || d.duration < e.duration) && (d.duration = e.duration, d.easing = e.easing)
        }

        function ca(d, e, a) {
          const {
            maxSpeed: c,
            linearity: h,
            deceleration: f
          } = a, v = l.ai(d * h / (e / 1e3), -c, c), w = Math.abs(v) / (f * h);
          return {
            easing: a.easing,
            duration: 1e3 * w,
            amount: v * (w / 2)
          }
        }
        class ga extends l.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, c, h = {}) {
            c = c instanceof MouseEvent ? c : new MouseEvent(e, c);
            const f = V.mousePos(a.getCanvas(), c),
              v = a.unproject(f);
            super(e, l.e({
              point: f,
              lngLat: v,
              originalEvent: c
            }, h)), this._defaultPrevented = !1, this.target = a
          }
        }
        class ua extends l.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, c) {
            const h = e === "touchend" ? c.changedTouches : c.touches,
              f = V.touchPos(a.getCanvasContainer(), h),
              v = f.map((T => a.unproject(T))),
              w = f.reduce(((T, C, A, j) => T.add(C.div(j.length))), new l.P(0, 0));
            super(e, {
              points: f,
              point: w,
              lngLats: v,
              lngLat: a.unproject(w),
              originalEvent: c
            }), this._defaultPrevented = !1
          }
        }
        class dd extends l.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, c) {
            super(e, {
              originalEvent: c
            }), this._defaultPrevented = !1
          }
        }
        class Ps {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new dd(e.type, this._map, e))
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new ga(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new ga(e.type, this._map, e))
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new ga(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new ga(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new ga(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new ga(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new ua(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new ua(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new ua(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new ua(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Qp {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new ga(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ga("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new ga(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class el {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(l.P.convert(e), this._map.terrain)
          }
        }
        class pd {
          constructor(e, a) {
            this._map = e, this._tr = new el(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (V.disableDrag(), this._startPos = this._lastPos = a, this._active = !0)
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const c = a;
            if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
            const h = this._startPos;
            this._lastPos = c, this._box || (this._box = V.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const f = Math.min(h.x, c.x),
              v = Math.max(h.x, c.x),
              w = Math.min(h.y, c.y),
              T = Math.max(h.y, c.y);
            V.setTransform(this._box, `translate(${f}px,${w}px)`), this._box.style.width = v - f + "px", this._box.style.height = T - w + "px"
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const c = this._startPos,
              h = a;
            if (this.reset(), V.suppressClick(), c.x !== h.x || c.y !== h.y) return this._map.fire(new l.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: f => f.fitScreenCoordinates(c, h, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (V.remove(this._box), this._box = null), V.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, a) {
            return this._map.fire(new l.l(e, {
              originalEvent: a
            }))
          }
        }

        function du(d, e) {
          if (d.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${d.length}, points ${e.length}`);
          const a = {};
          for (let c = 0; c < d.length; c++) a[d[c].identifier] = e[c];
          return a
        }
        class fd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, a, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), c.length === this.numTouches && (this.centroid = (function(h) {
              const f = new l.P(0, 0);
              for (const v of h) f._add(v);
              return f.div(h.length)
            })(a), this.touches = du(c, a)))
          }
          touchmove(e, a, c) {
            if (this.aborted || !this.centroid) return;
            const h = du(c, a);
            for (const f in this.touches) {
              const v = h[f];
              (!v || v.dist(this.touches[f]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, a, c) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
              const h = !this.aborted && this.centroid;
              if (this.reset(), h) return h
            }
          }
        }
        class $o {
          constructor(e) {
            this.singleTap = new fd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, a, c) {
            this.singleTap.touchstart(e, a, c)
          }
          touchmove(e, a, c) {
            this.singleTap.touchmove(e, a, c)
          }
          touchend(e, a, c) {
            const h = this.singleTap.touchend(e, a, c);
            if (h) {
              const f = e.timeStamp - this.lastTime < 500,
                v = !this.lastTap || this.lastTap.dist(h) < 30;
              if (f && v || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = h, this.count === this.numTaps) return this.reset(), h
            }
          }
        }
        class uo {
          constructor(e) {
            this._tr = new el(e), this._zoomIn = new $o({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new $o({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, a, c) {
            this._zoomIn.touchstart(e, a, c), this._zoomOut.touchstart(e, a, c)
          }
          touchmove(e, a, c) {
            this._zoomIn.touchmove(e, a, c), this._zoomOut.touchmove(e, a, c)
          }
          touchend(e, a, c) {
            const h = this._zoomIn.touchend(e, a, c),
              f = this._zoomOut.touchend(e, a, c),
              v = this._tr;
            return h ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: v.zoom + 1,
                around: v.unproject(h)
              }, {
                originalEvent: e
              })
            }) : f ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: v.zoom - 1,
                around: v.unproject(f)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Mr {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = !0, a
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const c = this._lastPoint;
            if (!c) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const h = Array.isArray(a) ? a[0] : a;
            return !this._moved && h.dist(c) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = h, this._move(c, h))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && V.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const _d = 0,
          pu = 2,
          md = {
            [_d]: 1,
            [pu]: 2
          };
        class ho {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const a = V.mouseButton(e);
            this._eventButton = a
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(a, c) {
              const h = md[c];
              return a.buttons === void 0 || (a.buttons & h) !== h
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return V.mouseButton(e) === this._eventButton
          }
        }
        class tl {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class fu {
          constructor(e = new ho({
            checkCorrectEvent: () => !0
          }), a = new tl) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a
          }
          _executeRelevantHandler(e, a, c) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? c(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.startMove(a)), (a => this.oneFingerTouchMoveStateManager.startMove(a)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.endMove(a)), (a => this.oneFingerTouchMoveStateManager.endMove(a)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidStartEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidMoveEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidEndEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)))
          }
        }
        const jn = d => {
          d.mousedown = d.dragStart, d.mousemoveWindow = d.dragMove, d.mouseup = d.dragEnd, d.contextmenu = e => {
            e.preventDefault()
          }
        };
        class _u {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new l.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, a, c) {
            return this._calculateTransform(e, a, c)
          }
          touchmove(e, a, c) {
            if (this._active) {
              if (!this._shouldBePrevented(c.length)) return e.preventDefault(), this._calculateTransform(e, a, c);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, a, c) {
            this._calculateTransform(e, a, c), this._active && this._shouldBePrevented(c.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, a, c) {
            c.length > 0 && (this._active = !0);
            const h = du(c, a),
              f = new l.P(0, 0),
              v = new l.P(0, 0);
            let w = 0;
            for (const C in h) {
              const A = h[C],
                j = this._touches[C];
              j && (f._add(A), v._add(A.sub(j)), w++, h[C] = A)
            }
            if (this._touches = h, this._shouldBePrevented(w) || !v.mag()) return;
            const T = v.div(w);
            return this._sum._add(T), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: f.div(w),
              panDelta: T
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class mu {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, a, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([a[0], a[1]]))
          }
          touchmove(e, a, c) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [h, f] = this._firstTwoTouches, v = Ms(c, a, h), w = Ms(c, a, f);
            if (!v || !w) return;
            const T = this._aroundCenter ? null : v.add(w).div(2);
            return this._move([v, w], T, e)
          }
          touchend(e, a, c) {
            if (!this._firstTwoTouches) return;
            const [h, f] = this._firstTwoTouches, v = Ms(c, a, h), w = Ms(c, a, f);
            v && w || (this._active && V.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Ms(d, e, a) {
          for (let c = 0; c < d.length; c++)
            if (d[c].identifier === a) return e[c]
        }

        function gd(d, e) {
          return Math.log(d / e) / Math.LN2
        }
        class vd extends mu {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, a) {
            const c = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(gd(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: gd(this._distance, c),
              pinchAround: a
            }
          }
        }

        function gu(d, e) {
          return 180 * d.angleWith(e) / Math.PI
        }
        class Wl extends mu {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, a, c) {
            const h = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: gu(this._vector, h),
              pinchAround: a
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360,
              c = gu(e, this._startVector);
            return Math.abs(c) < a
          }
        }

        function Hl(d) {
          return Math.abs(d.y) > Math.abs(d.x)
        }
        class yd extends mu {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, a, c) {
            super.touchstart(e, a, c), this._currentTouchCount = c.length
          }
          _start(e) {
            this._lastPoints = e, Hl(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, a, c) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const h = e[0].sub(this._lastPoints[0]),
              f = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(h, f, c.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (h.y + f.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, a, c) {
            if (this._valid !== void 0) return this._valid;
            const h = e.mag() >= 2,
              f = a.mag() >= 2;
            if (!h && !f) return;
            if (!h || !f) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const v = e.y > 0 == a.y > 0;
            return Hl(e) && Hl(a) && v
          }
        }
        const bd = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class xd {
          constructor(e) {
            this._tr = new el(e);
            const a = bd;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0,
              c = 0,
              h = 0,
              f = 0,
              v = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? c = -1 : (e.preventDefault(), f = -1);
                break;
              case 39:
                e.shiftKey ? c = 1 : (e.preventDefault(), f = 1);
                break;
              case 38:
                e.shiftKey ? h = 1 : (e.preventDefault(), v = -1);
                break;
              case 40:
                e.shiftKey ? h = -1 : (e.preventDefault(), v = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (c = 0, h = 0), {
              cameraAnimation: w => {
                const T = this._tr;
                w.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: ef,
                  zoom: a ? Math.round(T.zoom) + a * (e.shiftKey ? 2 : 1) : T.zoom,
                  bearing: T.bearing + c * this._bearingStep,
                  pitch: T.pitch + h * this._pitchStep,
                  offset: [-f * this._panStep, -v * this._panStep],
                  center: T.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function ef(d) {
          return d * (2 - d)
        }
        const po = 4.000244140625,
          ei = 1 / 450;
        class wd {
          constructor(e, a) {
            this._onTimeout = c => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c)
            }, this._map = e, this._tr = new el(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = ei
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const c = ge(),
              h = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, a !== 0 && a % po == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : h > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(h * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = V.mousePos(this._map.getCanvas(), e),
              c = this._tr;
            this._aroundPoint = this._aroundCenter ? c.transform.locationToScreenPoint(l.U.convert(c.center)) : a, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const w = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += w), typeof this._targetZoom == "number" && (this._targetZoom += w)
            }
            if (this._delta !== 0) {
              const w = this._type === "wheel" && Math.abs(this._delta) > po ? this._wheelZoomRate : this._defaultZoomRate;
              let T = 2 / (1 + Math.exp(-Math.abs(this._delta * w)));
              this._delta < 0 && T !== 0 && (T = 1 / T);
              const C = typeof this._targetZoom != "number" ? e.scale : l.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), l.ao(C * T)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              c = this._startZoom,
              h = this._easing;
            let f, v = !1;
            if (this._type === "wheel" && c && h) {
              const w = ge() - this._lastWheelEventTime,
                T = Math.min((w + 5) / 200, 1),
                C = h(T);
              f = l.F.number(c, a, C), T < 1 ? this._frameId || (this._frameId = !0) : v = !0
            } else f = a, v = !0;
            return this._active = !0, v && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = f, {
              noInertia: !0,
              needsRenderFrame: !v,
              zoomDelta: f - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let a = l.cr;
            if (this._prevEase) {
              const c = this._prevEase,
                h = (ge() - c.start) / c.duration,
                f = c.easing(h + .01) - c.easing(h),
                v = .27 / Math.sqrt(f * f + 1e-4) * .01,
                w = Math.sqrt(.0729 - v * v);
              a = l.cp(v, w, .25, 1)
            }
            return this._prevEase = {
              start: ge(),
              duration: e,
              easing: a
            }, a
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class rl {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class vu {
          constructor(e) {
            this._tr = new el(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, a) {
            return e.preventDefault(), {
              cameraAnimation: c => {
                c.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(a)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class kd {
          constructor() {
            this._tap = new $o({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, a, c) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const h = a[0],
                  f = e.timeStamp - this._tapTime < 500,
                  v = this._tapPoint.dist(h) < 30;
                f && v ? c.length > 0 && (this._swipePoint = h, this._swipeTouch = c[0].identifier) : this.reset()
              } else this._tap.touchstart(e, a, c)
          }
          touchmove(e, a, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const h = a[0],
                  f = h.y - this._swipePoint.y;
                return this._swipePoint = h, e.preventDefault(), this._active = !0, {
                  zoomDelta: f / 128
                }
              }
            } else this._tap.touchmove(e, a, c)
          }
          touchend(e, a, c) {
            if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
            else {
              const h = this._tap.touchend(e, a, c);
              h && (this._tapTime = e.timeStamp, this._tapPoint = h)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class yu {
          constructor(e, a, c) {
            this._el = e, this._mousePan = a, this._touchPan = c
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class bu {
          constructor(e, a, c, h) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = c, this._mouseRoll = h
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Td {
          constructor(e, a, c, h) {
            this._el = e, this._touchZoom = a, this._touchRotate = c, this._tapDragZoom = h, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Za {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = V.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              h = document.createElement("div");
            h.className = "maplibregl-desktop-message", h.textContent = a, this._container.appendChild(h);
            const f = document.createElement("div");
            f.className = "maplibregl-mobile-message", f.textContent = c, this._container.appendChild(f), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (V.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new l.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: a
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Xo = d => d.zoom || d.drag || d.roll || d.pitch || d.rotate;
        class Xr extends l.l {}

        function ln(d) {
          return d.panDelta && d.panDelta.mag() || d.zoomDelta || d.bearingDelta || d.pitchDelta || d.rollDelta
        }
        class nl {
          constructor(e, a) {
            this.handleWindowEvent = h => {
              this.handleEvent(h, `${h.type}Window`)
            }, this.handleEvent = (h, f) => {
              if (h.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const v = h.type === "renderFrame" ? void 0 : h,
                w = {
                  needsRenderFrame: !1
                },
                T = {},
                C = {};
              for (const {
                  handlerName: R,
                  handler: Z,
                  allowed: Y
                }
                of this._handlers) {
                if (!Z.isEnabled()) continue;
                let oe;
                if (this._blockedByActive(C, Y, R)) Z.reset();
                else if (Z[f || h.type]) {
                  if (l.cs(h, f || h.type)) {
                    const le = V.mousePos(this._map.getCanvas(), h);
                    oe = Z[f || h.type](h, le)
                  } else if (l.ct(h, f || h.type)) {
                    const le = this._getMapTouches(h.touches),
                      ce = V.touchPos(this._map.getCanvas(), le);
                    oe = Z[f || h.type](h, ce, le)
                  } else l.cu(f || h.type) || (oe = Z[f || h.type](h));
                  this.mergeHandlerResult(w, T, oe, R, v), oe && oe.needsRenderFrame && this._triggerRenderFrame()
                }(oe || Z.isActive()) && (C[R] = Z)
              }
              const A = {};
              for (const R in this._previousActiveHandlers) C[R] || (A[R] = v);
              this._previousActiveHandlers = C, (Object.keys(A).length || ln(w)) && (this._changes.push([w, T, A]), this._triggerRenderFrame()), (Object.keys(C).length || ln(w)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: j
              } = w;
              j && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], j(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new hd(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const c = this._el;
            this._listeners = [
              [c, "touchstart", {
                passive: !0
              }],
              [c, "touchmove", {
                passive: !1
              }],
              [c, "touchend", void 0],
              [c, "touchcancel", void 0],
              [c, "mousedown", void 0],
              [c, "mousemove", void 0],
              [c, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [c, "mouseover", void 0],
              [c, "mouseout", void 0],
              [c, "dblclick", void 0],
              [c, "click", void 0],
              [c, "keydown", {
                capture: !1
              }],
              [c, "keyup", void 0],
              [c, "wheel", {
                passive: !1
              }],
              [c, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [h, f, v] of this._listeners) V.addEventListener(h, f, h === document ? this.handleWindowEvent : this.handleEvent, v)
          }
          destroy() {
            for (const [e, a, c] of this._listeners) V.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, c)
          }
          _addDefaultHandlers(e) {
            const a = this._map,
              c = a.getCanvasContainer();
            this._add("mapEvent", new Ps(a, e));
            const h = a.boxZoom = new pd(a, e);
            this._add("boxZoom", h), e.interactive && e.boxZoom && h.enable();
            const f = a.cooperativeGestures = new Za(a, e.cooperativeGestures);
            this._add("cooperativeGestures", f), e.cooperativeGestures && f.enable();
            const v = new uo(a),
              w = new vu(a);
            a.doubleClickZoom = new rl(w, v), this._add("tapZoom", v), this._add("clickZoom", w), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const T = new kd;
            this._add("tapDragZoom", T);
            const C = a.touchPitch = new yd(a);
            this._add("touchPitch", C), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const A = () => a.project(a.getCenter()),
              j = (function({
                enable: fe,
                clickTolerance: Pe,
                aroundCenter: Ae = !0,
                minPixelCenterThreshold: ve = 100,
                rotateDegreesPerPixelMoved: Oe = .8
              }, ct) {
                const it = new ho({
                  checkCorrectEvent: st => V.mouseButton(st) === 0 && st.ctrlKey || V.mouseButton(st) === 2 && !st.ctrlKey
                });
                return new Mr({
                  clickTolerance: Pe,
                  move: (st, ut) => {
                    const or = ct();
                    if (Ae && Math.abs(or.y - st.y) > ve) return {
                      bearingDelta: l.cq(new l.P(st.x, ut.y), ut, or)
                    };
                    let cr = (ut.x - st.x) * Oe;
                    return Ae && ut.y < or.y && (cr = -cr), {
                      bearingDelta: cr
                    }
                  },
                  moveStateManager: it,
                  enable: fe,
                  assignEvents: jn
                })
              })(e, A),
              R = (function({
                enable: fe,
                clickTolerance: Pe,
                pitchDegreesPerPixelMoved: Ae = -.5
              }) {
                const ve = new ho({
                  checkCorrectEvent: Oe => V.mouseButton(Oe) === 0 && Oe.ctrlKey || V.mouseButton(Oe) === 2
                });
                return new Mr({
                  clickTolerance: Pe,
                  move: (Oe, ct) => ({
                    pitchDelta: (ct.y - Oe.y) * Ae
                  }),
                  moveStateManager: ve,
                  enable: fe,
                  assignEvents: jn
                })
              })(e),
              Z = (function({
                enable: fe,
                clickTolerance: Pe,
                rollDegreesPerPixelMoved: Ae = .3
              }, ve) {
                const Oe = new ho({
                  checkCorrectEvent: ct => V.mouseButton(ct) === 2 && ct.ctrlKey
                });
                return new Mr({
                  clickTolerance: Pe,
                  move: (ct, it) => {
                    const st = ve();
                    let ut = (it.x - ct.x) * Ae;
                    return it.y < st.y && (ut = -ut), {
                      rollDelta: ut
                    }
                  },
                  moveStateManager: Oe,
                  enable: fe,
                  assignEvents: jn
                })
              })(e, A);
            a.dragRotate = new bu(e, j, R, Z), this._add("mouseRotate", j, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", Z, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const Y = (function({
                enable: fe,
                clickTolerance: Pe
              }) {
                const Ae = new ho({
                  checkCorrectEvent: ve => V.mouseButton(ve) === 0 && !ve.ctrlKey
                });
                return new Mr({
                  clickTolerance: Pe,
                  move: (ve, Oe) => ({
                    around: Oe,
                    panDelta: Oe.sub(ve)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Ae,
                  enable: fe,
                  assignEvents: jn
                })
              })(e),
              oe = new _u(e, a);
            a.dragPan = new yu(c, Y, oe), this._add("mousePan", Y), this._add("touchPan", oe, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const le = new Wl,
              ce = new vd;
            a.touchZoomRotate = new Td(c, ce, le, T), this._add("touchRotate", le, ["touchPan", "touchZoom"]), this._add("touchZoom", ce, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new Qp(a));
            const me = a.scrollZoom = new wd(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", me, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const Se = a.keyboard = new xd(a);
            this._add("keyboard", Se), e.interactive && e.keyboard && a.keyboard.enable()
          }
          _add(e, a, c) {
            this._handlers.push({
              handlerName: e,
              handler: a,
              allowed: c
            }), this._handlersById[e] = a
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: a
                }
                of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Xo(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, a, c) {
            for (const h in e)
              if (h !== c && (!a || a.indexOf(h) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const a = [];
            for (const c of e) this._el.contains(c.target) && a.push(c);
            return a
          }
          mergeHandlerResult(e, a, c, h, f) {
            if (!c) return;
            l.e(e, c);
            const v = {
              handlerName: h,
              originalEvent: c.originalEvent || f
            };
            c.zoomDelta !== void 0 && (a.zoom = v), c.panDelta !== void 0 && (a.drag = v), c.rollDelta !== void 0 && (a.roll = v), c.pitchDelta !== void 0 && (a.pitch = v), c.bearingDelta !== void 0 && (a.rotate = v)
          }
          _applyChanges() {
            const e = {},
              a = {},
              c = {};
            for (const [h, f, v] of this._changes) h.panDelta && (e.panDelta = (e.panDelta || new l.P(0, 0))._add(h.panDelta)), h.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + h.zoomDelta), h.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + h.bearingDelta), h.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + h.pitchDelta), h.rollDelta && (e.rollDelta = (e.rollDelta || 0) + h.rollDelta), h.around !== void 0 && (e.around = h.around), h.pinchAround !== void 0 && (e.pinchAround = h.pinchAround), h.noInertia && (e.noInertia = h.noInertia), l.e(a, f), l.e(c, v);
            this._updateMapTransform(e, a, c), this._changes = []
          }
          _updateMapTransform(e, a, c) {
            const h = this._map,
              f = h._getTransformForUpdate(),
              v = h.terrain;
            if (!(ln(e) || v && this._terrainMovement)) return this._fireEvents(a, c, !0);
            h._stop(!0);
            let {
              panDelta: w,
              zoomDelta: T,
              bearingDelta: C,
              pitchDelta: A,
              rollDelta: j,
              around: R,
              pinchAround: Z
            } = e;
            Z !== void 0 && (R = Z), R = R || h.transform.centerPoint, v && !f.isPointOnMapSurface(R) && (R = f.centerPoint);
            const Y = {
              panDelta: w,
              zoomDelta: T,
              rollDelta: j,
              pitchDelta: A,
              bearingDelta: C,
              around: R
            };
            this._map.cameraHelper.useGlobeControls && !f.isPointOnMapSurface(R) && (R = f.centerPoint);
            const oe = R.distSqr(f.centerPoint) < .01 ? f.center : f.screenPointToLocation(w ? R.sub(w) : R);
            this._handleMapControls({
              terrain: v,
              tr: f,
              deltasForHelper: Y,
              preZoomAroundLoc: oe,
              combinedEventsInProgress: a,
              panDelta: w
            }), h._applyUpdatedTransform(f), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, c, !0)
          }
          _handleMapControls({
            terrain: e,
            tr: a,
            deltasForHelper: c,
            preZoomAroundLoc: h,
            combinedEventsInProgress: f,
            panDelta: v
          }) {
            const w = this._map.cameraHelper;
            if (w.handleMapControlsRollPitchBearingZoom(c, a), e) return w.useGlobeControls ? (this._terrainMovement || !f.drag && !f.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void w.handleMapControlsPan(c, a, h)) : this._terrainMovement || !f.drag && !f.zoom ? void(f.drag && this._terrainMovement && v ? a.setCenter(a.screenPointToLocation(a.centerPoint.sub(v))) : w.handleMapControlsPan(c, a, h)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void w.handleMapControlsPan(c, a, h));
            w.handleMapControlsPan(c, a, h)
          }
          _fireEvents(e, a, c) {
            const h = Xo(this._eventsInProgress),
              f = Xo(e),
              v = {};
            for (const j in e) {
              const {
                originalEvent: R
              } = e[j];
              this._eventsInProgress[j] || (v[`${j}start`] = R), this._eventsInProgress[j] = e[j]
            }!h && f && this._fireEvent("movestart", f.originalEvent);
            for (const j in v) this._fireEvent(j, v[j]);
            f && this._fireEvent("move", f.originalEvent);
            for (const j in e) {
              const {
                originalEvent: R
              } = e[j];
              this._fireEvent(j, R)
            }
            const w = {};
            let T;
            for (const j in this._eventsInProgress) {
              const {
                handlerName: R,
                originalEvent: Z
              } = this._eventsInProgress[j];
              this._handlersById[R].isActive() || (delete this._eventsInProgress[j], T = a[R] || Z, w[`${j}end`] = T)
            }
            for (const j in w) this._fireEvent(j, w[j]);
            const C = Xo(this._eventsInProgress),
              A = (h || f) && !C;
            if (A && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const j = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && j.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(j)
            }
            if (c && A) {
              this._updatingCamera = !0;
              const j = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                R = Z => Z !== 0 && -this._bearingSnap < Z && Z < this._bearingSnap;
              !j || !j.essential && se.prefersReducedMotion ? (this._map.fire(new l.l("moveend", {
                originalEvent: T
              })), R(this._map.getBearing()) && this._map.resetNorth()) : (R(j.bearing || this._map.getBearing()) && (j.bearing = 0), j.freezeElevation = !0, this._map.easeTo(j, {
                originalEvent: T
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new l.l(e, a ? {
              originalEvent: a
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new Xr("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Sd extends l.E {
          constructor(e, a, c) {
            super(), this._renderFrameCallback = () => {
              const h = Math.min((ge() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(h)), h < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = c.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a
          }
          getCenter() {
            return new l.U(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, a) {
            return this.jumpTo({
              center: e
            }, a)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, a) {
            return this.jumpTo({
              elevation: e
            }, a), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, a, c) {
            return e = l.P.convert(e).mult(-1), this.panTo(this.transform.center, l.e({
              offset: e
            }, a), c)
          }
          panTo(e, a, c) {
            return this.easeTo(l.e({
              center: e
            }, a), c)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, a) {
            return this.jumpTo({
              zoom: e
            }, a), this
          }
          zoomTo(e, a, c) {
            return this.easeTo(l.e({
              zoom: e
            }, a), c)
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new l.l("movestart", a)).fire(new l.l("move", a)).fire(new l.l("moveend", a))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, a) {
            return this.jumpTo({
              bearing: e
            }, a), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, a) {
            return this.jumpTo({
              padding: e
            }, a), this
          }
          rotateTo(e, a, c) {
            return this.easeTo(l.e({
              bearing: e
            }, a), c)
          }
          resetNorth(e, a) {
            return this.rotateTo(0, l.e({
              duration: 1e3
            }, e), a), this
          }
          resetNorthPitch(e, a) {
            return this.easeTo(l.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), a), this
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, a) {
            return this.jumpTo({
              pitch: e
            }, a), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, a) {
            return this.jumpTo({
              roll: e
            }, a), this
          }
          cameraForBounds(e, a) {
            e = kt.convert(e).adjustAntiMeridian();
            const c = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), c, a)
          }
          _cameraForBoxAndBearing(e, a, c, h) {
            const f = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(h = l.e({
                padding: f,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, h)).padding == "number") {
              const C = h.padding;
              h.padding = {
                top: C,
                bottom: C,
                right: C,
                left: C
              }
            }
            const v = l.e(f, h.padding);
            h.padding = v;
            const w = this.transform,
              T = new kt(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(h, v, T, c, w)
          }
          fitBounds(e, a, c) {
            return this._fitInternal(this.cameraForBounds(e, a), a, c)
          }
          fitScreenCoordinates(e, a, c, h, f) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(l.P.convert(e)), this.transform.screenPointToLocation(l.P.convert(a)), c, h), h, f)
          }
          _fitInternal(e, a, c) {
            return e ? (delete(a = l.e(e, a)).padding, a.linear ? this.easeTo(a, c) : this.flyTo(a, c)) : this
          }
          jumpTo(e, a) {
            this.stop();
            const c = this._getTransformForUpdate();
            let h = !1,
              f = !1,
              v = !1;
            const w = c.zoom;
            this.cameraHelper.handleJumpToCenterZoom(c, e);
            const T = c.zoom !== w;
            return "elevation" in e && c.elevation !== +e.elevation && c.setElevation(+e.elevation), "bearing" in e && c.bearing !== +e.bearing && (h = !0, c.setBearing(+e.bearing)), "pitch" in e && c.pitch !== +e.pitch && (f = !0, c.setPitch(+e.pitch)), "roll" in e && c.roll !== +e.roll && (v = !0, c.setRoll(+e.roll)), e.padding == null || c.isPaddingEqual(e.padding) || c.setPadding(e.padding), this._applyUpdatedTransform(c), this.fire(new l.l("movestart", a)).fire(new l.l("move", a)), T && this.fire(new l.l("zoomstart", a)).fire(new l.l("zoom", a)).fire(new l.l("zoomend", a)), h && this.fire(new l.l("rotatestart", a)).fire(new l.l("rotate", a)).fire(new l.l("rotateend", a)), f && this.fire(new l.l("pitchstart", a)).fire(new l.l("pitch", a)).fire(new l.l("pitchend", a)), v && this.fire(new l.l("rollstart", a)).fire(new l.l("roll", a)).fire(new l.l("rollend", a)), this.fire(new l.l("moveend", a))
          }
          calculateCameraOptionsFromTo(e, a, c, h = 0) {
            const f = l.a5.fromLngLat(e, a),
              v = l.a5.fromLngLat(c, h),
              w = v.x - f.x,
              T = v.y - f.y,
              C = v.z - f.z,
              A = Math.hypot(w, T, C);
            if (A === 0) throw new Error("Can't calculate camera options with same From and To");
            const j = Math.hypot(w, T),
              R = l.ao(this.transform.cameraToCenterDistance / A / this.transform.tileSize),
              Z = 180 * Math.atan2(w, -T) / Math.PI;
            let Y = 180 * Math.acos(j / A) / Math.PI;
            return Y = C < 0 ? 90 - Y : 90 + Y, {
              center: v.toLngLat(),
              elevation: h,
              zoom: R,
              pitch: Y,
              bearing: Z
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, c, h, f) {
            const v = this.transform.calculateCenterFromCameraLngLatAlt(e, a, c, h);
            return {
              center: v.center,
              elevation: v.elevation,
              zoom: v.zoom,
              bearing: c,
              pitch: h,
              roll: f
            }
          }
          easeTo(e, a) {
            this._stop(!1, e.easeId), ((e = l.e({
              offset: [0, 0],
              duration: 500,
              easing: l.cr
            }, e)).animate === !1 || !e.essential && se.prefersReducedMotion) && (e.duration = 0);
            const c = this._getTransformForUpdate(),
              h = this.getBearing(),
              f = c.pitch,
              v = c.roll,
              w = "bearing" in e ? this._normalizeBearing(e.bearing, h) : h,
              T = "pitch" in e ? +e.pitch : f,
              C = "roll" in e ? this._normalizeBearing(e.roll, v) : v,
              A = "padding" in e ? e.padding : c.padding,
              j = l.P.convert(e.offset);
            let R, Z;
            e.around && (R = l.U.convert(e.around), Z = c.locationToScreenPoint(R));
            const Y = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              oe = this.cameraHelper.handleEaseTo(c, {
                bearing: w,
                pitch: T,
                roll: C,
                padding: A,
                around: R,
                aroundPoint: Z,
                offsetAsPoint: j,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || h !== w, this._pitching = this._pitching || T !== f, this._rolling = this._rolling || C !== v, this._padding = !c.isPaddingEqual(A), this._zooming = this._zooming || oe.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, Y), this.terrain && this._prepareElevation(oe.elevationCenter), this._ease((le => {
              oe.easeFunc(le), this.terrain && !e.freezeElevation && this._updateElevation(le), this._applyUpdatedTransform(c), this._fireMoveEvents(a)
            }), (le => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, le)
            }), e), this
          }
          _prepareEase(e, a, c = {}) {
            this._moving = !0, a || c.moving || this.fire(new l.l("movestart", e)), this._zooming && !c.zooming && this.fire(new l.l("zoomstart", e)), this._rotating && !c.rotating && this.fire(new l.l("rotatestart", e)), this._pitching && !c.pitching && this.fire(new l.l("pitchstart", e)), this._rolling && !c.rolling && this.fire(new l.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const c = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (c - (a - (c * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a
            }
            this.transform.setElevation(l.F.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(),
              c = e.getCameraAltitude(),
              h = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (c < h) {
              const f = this.calculateCameraOptionsFromTo(a, h, e.center, e.elevation);
              return {
                pitch: f.pitch,
                zoom: f.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push((h => this._elevateCameraIfInsideTerrain(h))), this.transformCameraUpdate && a.push((h => this.transformCameraUpdate(h))), !a.length) return;
            const c = e.clone();
            for (const h of a) {
              const f = c.clone(),
                {
                  center: v,
                  zoom: w,
                  roll: T,
                  pitch: C,
                  bearing: A,
                  elevation: j
                } = h(f);
              v && f.setCenter(v), j !== void 0 && f.setElevation(j), w !== void 0 && f.setZoom(w), T !== void 0 && f.setRoll(T), C !== void 0 && f.setPitch(C), A !== void 0 && f.setBearing(A), c.apply(f)
            }
            this.transform.apply(c)
          }
          _fireMoveEvents(e) {
            this.fire(new l.l("move", e)), this._zooming && this.fire(new l.l("zoom", e)), this._rotating && this.fire(new l.l("rotate", e)), this._pitching && this.fire(new l.l("pitch", e)), this._rolling && this.fire(new l.l("roll", e))
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const c = this._zooming,
              h = this._rotating,
              f = this._pitching,
              v = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, c && this.fire(new l.l("zoomend", e)), h && this.fire(new l.l("rotateend", e)), f && this.fire(new l.l("pitchend", e)), v && this.fire(new l.l("rollend", e)), this.fire(new l.l("moveend", e))
          }
          flyTo(e, a) {
            if (!e.essential && se.prefersReducedMotion) {
              const ut = l.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(ut, a)
            }
            this.stop(), e = l.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: l.cr
            }, e);
            const c = this._getTransformForUpdate(),
              h = c.bearing,
              f = c.pitch,
              v = c.roll,
              w = c.padding,
              T = "bearing" in e ? this._normalizeBearing(e.bearing, h) : h,
              C = "pitch" in e ? +e.pitch : f,
              A = "roll" in e ? this._normalizeBearing(e.roll, v) : v,
              j = "padding" in e ? e.padding : c.padding,
              R = l.P.convert(e.offset);
            let Z = c.centerPoint.add(R);
            const Y = c.screenPointToLocation(Z),
              oe = this.cameraHelper.handleFlyTo(c, {
                bearing: T,
                pitch: C,
                roll: A,
                padding: j,
                locationAtOffset: Y,
                offsetAsPoint: R,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let le = e.curve;
            const ce = Math.max(c.width, c.height),
              me = ce / oe.scaleOfZoom,
              Se = oe.pixelPathLength;
            typeof oe.scaleOfMinZoom == "number" && (le = Math.sqrt(ce / oe.scaleOfMinZoom / Se * 2));
            const fe = le * le;

            function Pe(ut) {
              const or = (me * me - ce * ce + (ut ? -1 : 1) * fe * fe * Se * Se) / (2 * (ut ? me : ce) * fe * Se);
              return Math.log(Math.sqrt(or * or + 1) - or)
            }

            function Ae(ut) {
              return (Math.exp(ut) - Math.exp(-ut)) / 2
            }

            function ve(ut) {
              return (Math.exp(ut) + Math.exp(-ut)) / 2
            }
            const Oe = Pe(!1);
            let ct = function(ut) {
                return ve(Oe) / ve(Oe + le * ut)
              },
              it = function(ut) {
                return ce * ((ve(Oe) * (Ae(or = Oe + le * ut) / ve(or)) - Ae(Oe)) / fe) / Se;
                var or
              },
              st = (Pe(!0) - Oe) / le;
            if (Math.abs(Se) < 2e-6 || !isFinite(st)) {
              if (Math.abs(ce - me) < 1e-6) return this.easeTo(e, a);
              const ut = me < ce ? -1 : 1;
              st = Math.abs(Math.log(me / ce)) / le, it = () => 0, ct = or => Math.exp(ut * le * or)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * st / ("screenSpeed" in e ? +e.screenSpeed / le : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = h !== T, this._pitching = C !== f, this._rolling = A !== v, this._padding = !c.isPaddingEqual(j), this._prepareEase(a, !1), this.terrain && this._prepareElevation(oe.targetCenter), this._ease((ut => {
              const or = ut * st,
                cr = 1 / ct(or),
                Bt = it(or);
              this._rotating && c.setBearing(l.F.number(h, T, ut)), this._pitching && c.setPitch(l.F.number(f, C, ut)), this._rolling && c.setRoll(l.F.number(v, A, ut)), this._padding && (c.interpolatePadding(w, j, ut), Z = c.centerPoint.add(R)), oe.easeFunc(ut, cr, Bt, Z), this.terrain && !e.freezeElevation && this._updateElevation(ut), this._applyUpdatedTransform(c), this._fireMoveEvents(a)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, a) {
            var c;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const h = this._onEaseEnd;
              delete this._onEaseEnd, h.call(this, a)
            }
            return e || (c = this.handlers) === null || c === void 0 || c.stop(!1), this
          }
          _ease(e, a, c) {
            c.animate === !1 || c.duration === 0 ? (e(1), a()) : (this._easeStart = ge(), this._easeOptions = c, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, a) {
            e = l.V(e, -180, 180);
            const c = Math.abs(e - a);
            return Math.abs(e - 360 - a) < c && (e -= 360), Math.abs(e + 360 - a) < c && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(l.U.convert(e), this.transform.tileZoom) : null
          }
        }
        const il = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class oa {
          constructor(e = il) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = a => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = V.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = V.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = V.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            V.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, a) {
            const c = this._map._getUIString(`AttributionControl.${a}`);
            e.title = c, e.setAttribute("aria-label", c)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((h => typeof h != "string" ? "" : h))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const h = this._map.style.stylesheet;
              this.styleOwner = h.owner, this.styleId = h.id
            }
            const a = this._map.style.tileManagers;
            for (const h in a) {
              const f = a[h];
              if (f.used || f.usedForTerrain) {
                const v = f.getSource();
                v.attribution && e.indexOf(v.attribution) < 0 && e.push(v.attribution)
              }
            }
            e = e.filter((h => String(h).trim())), e.sort(((h, f) => h.length - f.length)), e = e.filter(((h, f) => {
              for (let v = f + 1; v < e.length; v++)
                if (e[v].indexOf(h) >= 0) return !1;
              return !0
            }));
            const c = e.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, e.length ? (this._innerContainer.innerHTML = V.sanitize(c), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class xu {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const c = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = V.create("div", "maplibregl-ctrl");
            const a = V.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            V.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Ga {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({
              callback: e,
              id: a,
              cancelled: !1
            }), a
          }
          remove(e) {
            const a = this._currentlyRunning,
              c = a ? this._queue.concat(a) : this._queue;
            for (const h of c)
              if (h.id === e) return void(h.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of a)
              if (!c.cancelled && (c.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Pd = l.aN([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class tf extends l.E {
          constructor(e) {
            super(), this._lastTilesetChange = ge(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null
          }
          getSource() {
            return this.tileManager._source
          }
          update(e, a) {
            this.tileManager.update(e, a), this._renderableTilesKeys = [];
            const c = {};
            for (const h of $e(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: a,
                calculateTileZoom: this.tileManager._source.calculateTileZoom
              })) c[h.key] = !0, this._renderableTilesKeys.push(h.key), this._tiles[h.key] || (h.terrainRttPosMatrix32f = new Float64Array(16), l.c0(h.terrainRttPosMatrix32f, 0, l.a3, l.a3, 0, 0, 1), this._tiles[h.key] = new Q(h, this.tileSize), this._lastTilesetChange = ge());
            for (const h in this._tiles) c[h] || delete this._tiles[h]
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              (!e || c.tileID.equals(e) || c.tileID.isChildOf(e) || e.isChildOf(c.tileID)) && (c.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const c of this._renderableTilesKeys) {
              const h = this._tiles[c].tileID,
                f = e.clone(),
                v = l.bd();
              if (h.canonical.equals(e.canonical)) l.c0(v, 0, l.a3, l.a3, 0, 0, 1);
              else if (h.canonical.isChildOf(e.canonical)) {
                const w = h.canonical.z - e.canonical.z,
                  T = h.canonical.x - (h.canonical.x >> w << w),
                  C = h.canonical.y - (h.canonical.y >> w << w),
                  A = l.a3 >> w;
                l.c0(v, 0, A, A, 0, 0, 1), l.N(v, v, [-T * A, -C * A, 0])
              } else {
                if (!e.canonical.isChildOf(h.canonical)) continue;
                {
                  const w = e.canonical.z - h.canonical.z,
                    T = e.canonical.x - (e.canonical.x >> w << w),
                    C = e.canonical.y - (e.canonical.y >> w << w),
                    A = l.a3 >> w;
                  l.c0(v, 0, l.a3, l.a3, 0, 0, 1), l.N(v, v, [T * A, C * A, 0]), l.O(v, v, [1 / 2 ** w, 1 / 2 ** w, 0])
                }
              }
              f.terrainRttPosMatrix32f = new Float32Array(v), a[c] = f
            }
            return a
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const c = {};
            for (const h of this._renderableTilesKeys) {
              const f = this._tiles[h].tileID;
              if (!this._isWithinTileRanges(f, a)) continue;
              const v = e.clone(),
                w = l.bd();
              if (f.canonical.z === e.canonical.z) {
                const T = e.canonical.x - f.canonical.x,
                  C = e.canonical.y - f.canonical.y;
                l.c0(w, 0, l.a3, l.a3, 0, 0, 1), l.N(w, w, [T * l.a3, C * l.a3, 0])
              } else if (f.canonical.z > e.canonical.z) {
                const T = f.canonical.z - e.canonical.z,
                  C = f.canonical.x - (f.canonical.x >> T << T),
                  A = f.canonical.y - (f.canonical.y >> T << T),
                  j = e.canonical.x - (f.canonical.x >> T),
                  R = e.canonical.y - (f.canonical.y >> T),
                  Z = l.a3 >> T;
                l.c0(w, 0, Z, Z, 0, 0, 1), l.N(w, w, [-C * Z + j * l.a3, -A * Z + R * l.a3, 0])
              } else {
                const T = e.canonical.z - f.canonical.z,
                  C = e.canonical.x - (e.canonical.x >> T << T),
                  A = e.canonical.y - (e.canonical.y >> T << T),
                  j = (e.canonical.x >> T) - f.canonical.x,
                  R = (e.canonical.y >> T) - f.canonical.y,
                  Z = l.a3 << T;
                l.c0(w, 0, Z, Z, 0, 0, 1), l.N(w, w, [C * l.a3 + j * Z, A * l.a3 + R * Z, 0])
              }
              v.terrainRttPosMatrix32f = new Float32Array(w), c[h] = v
            }
            return c
          }
          getSourceTile(e, a) {
            const c = this.tileManager._source;
            let h = e.overscaledZ - this.deltaZoom;
            if (h > c.maxzoom && (h = c.maxzoom), h < c.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(h).key);
            let f = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!f || !f.dem) && a)
              for (; h >= c.minzoom && (!f || !f.dem);) f = this.tileManager.getTileByID(e.scaledTo(h--).key);
            return f
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY
          }
        }
        class rf {
          constructor(e, a, c) {
            this._meshCache = {}, this.painter = e, this.tileManager = new tf(a), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, a, c, h = l.a3) {
            var f;
            if (!(a >= 0 && a < h && c >= 0 && c < h)) return 0;
            const v = this.getTerrainData(e),
              w = (f = v.tile) === null || f === void 0 ? void 0 : f.dem;
            if (!w) return 0;
            const T = l.cv([], [a / h * l.a3, c / h * l.a3], v.u_terrain_matrix),
              C = [T[0] * w.dim, T[1] * w.dim],
              A = Math.floor(C[0]),
              j = Math.floor(C[1]),
              R = C[0] - A,
              Z = C[1] - j;
            return w.get(A, j) * (1 - R) * (1 - Z) + w.get(A + 1, j) * R * (1 - Z) + w.get(A, j + 1) * (1 - R) * Z + w.get(A + 1, j + 1) * R * Z
          }
          getElevationForLngLatZoom(e, a) {
            if (!l.cw(a, e.wrap())) return 0;
            const {
              tileID: c,
              mercatorX: h,
              mercatorY: f
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(c, h % l.a3, f % l.a3, l.a3)
          }
          getElevation(e, a, c, h = l.a3) {
            return this.getDEMElevation(e, a, c, h) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const h = this.painter.context,
                f = new l.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new l.T(h, f, h.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new l.T(h, new l.R({
                width: 1,
                height: 1
              }), h.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = l.am([])
            }
            const a = this.tileManager.getSourceTile(e, !0);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const h = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), {
                premultiply: !1
              }) : a.demTexture = new l.T(h, a.dem.getPixels(), h.gl.RGBA, {
                premultiply: !1
              }), a.demTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = !1
            }
            const c = a && a + a.tileID.key + e.key;
            if (c && !this._demMatrixCache[c]) {
              const h = this.tileManager.getSource().maxzoom;
              let f = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= h ? f = e.canonical.z - h : l.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const v = e.canonical.x - (e.canonical.x >> f << f),
                w = e.canonical.y - (e.canonical.y >> f << f),
                T = l.cx(new Float64Array(16), [1 / (l.a3 << f), 1 / (l.a3 << f), 0]);
              l.N(T, T, [v * l.a3, w * l.a3, 0]), this._demMatrixCache[e.key] = {
                matrix: T,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: a && a.dem && a.dem.dim || 1,
              u_terrain_matrix: c ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (a && a.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: a
            }
          }
          getFramebuffer(e) {
            const a = this.painter,
              c = a.width / devicePixelRatio,
              h = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === c && this._fbo.height === h || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new l.T(a.context, {
              width: c,
              height: h,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new l.T(a.context, {
              width: c,
              height: h,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(c, h, !0, !1), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, c, h))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let f = 0, v = 0; f < this._coordsTextureSize; f++)
              for (let w = 0; w < this._coordsTextureSize; w++, v += 4) a[v + 0] = 255 & w, a[v + 1] = 255 & f, a[v + 2] = w >> 8 << 4 | f >> 8, a[v + 3] = 0;
            const c = new l.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(a.buffer)),
              h = new l.T(e, c, e.gl.RGBA, {
                premultiply: !1
              });
            return h.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = h, h
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const a = new Uint8Array(4),
              c = this.painter.context,
              h = c.gl,
              f = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              v = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              w = Math.round(this.painter.height / devicePixelRatio);
            c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), h.readPixels(f, w - v - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null);
            const T = a[0] + (a[2] >> 4 << 8),
              C = a[1] + ((15 & a[2]) << 8),
              A = this.coordsIndex[255 - a[3]],
              j = A && this.tileManager.getTileByID(A);
            if (!j) return null;
            const R = this._coordsTextureSize,
              Z = (1 << j.tileID.canonical.z) * R;
            return new l.a5((j.tileID.canonical.x * R + T) / Z + j.tileID.wrap, (j.tileID.canonical.y * R + C) / Z, this.getElevation(j.tileID, T, C, R))
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4),
              c = this.painter.context,
              h = c.gl;
            return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), h.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256
          }
          getTerrainMesh(e) {
            var a;
            const c = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0,
              h = c && e.canonical.y === 0,
              f = c && e.canonical.y === (1 << e.canonical.z) - 1,
              v = `m_${h?"n":""}_${f?"s":""}`;
            if (this._meshCache[v]) return this._meshCache[v];
            const w = this.painter.context,
              T = new l.cy,
              C = new l.aR,
              A = this.meshSize,
              j = l.a3 / A,
              R = A * A;
            for (let ve = 0; ve <= A; ve++)
              for (let Oe = 0; Oe <= A; Oe++) T.emplaceBack(Oe * j, ve * j, 0);
            for (let ve = 0; ve < R; ve += A + 1)
              for (let Oe = 0; Oe < A; Oe++) C.emplaceBack(Oe + ve, A + Oe + ve + 1, A + Oe + ve + 2), C.emplaceBack(Oe + ve, A + Oe + ve + 2, Oe + ve + 1);
            const Z = T.length,
              Y = Z + (A + 1),
              oe = (A + 1) * A,
              le = h ? l.bk : 0,
              ce = h ? 0 : 1,
              me = f ? l.bl : l.a3,
              Se = f ? 0 : 1;
            for (let ve = 0; ve <= A; ve++) T.emplaceBack(ve * j, le, ce);
            for (let ve = 0; ve <= A; ve++) T.emplaceBack(ve * j, me, Se);
            for (let ve = 0; ve < A; ve++) C.emplaceBack(oe + ve, Y + ve, Y + ve + 1), C.emplaceBack(oe + ve, Y + ve + 1, oe + ve + 1), C.emplaceBack(0 + ve, Z + ve + 1, Z + ve), C.emplaceBack(0 + ve, 0 + ve + 1, Z + ve + 1);
            const fe = T.length,
              Pe = fe + 2 * (A + 1);
            for (const ve of [0, 1])
              for (let Oe = 0; Oe <= A; Oe++)
                for (const ct of [0, 1]) T.emplaceBack(ve * l.a3, Oe * j, ct);
            for (let ve = 0; ve < 2 * A; ve += 2) C.emplaceBack(fe + ve, fe + ve + 1, fe + ve + 3), C.emplaceBack(fe + ve, fe + ve + 3, fe + ve + 2), C.emplaceBack(Pe + ve, Pe + ve + 3, Pe + ve + 1), C.emplaceBack(Pe + ve, Pe + ve + 2, Pe + ve + 3);
            const Ae = new Gn(w.createVertexBuffer(T, Pd.members), w.createIndexBuffer(C), l.aQ.simpleSegment(0, 0, T.length, C.length));
            return this._meshCache[v] = Ae, Ae
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * l.bx / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var c;
            const {
              tileID: h
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (c = this.getMinMaxElevation(h).minElevation) !== null && c !== void 0 ? c : 0
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile,
              c = {
                minElevation: null,
                maxElevation: null
              };
            return a && a.dem && (c.minElevation = a.dem.min * this.exaggeration, c.maxElevation = a.dem.max * this.exaggeration), c
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const c = l.a5.fromLngLat(e.wrap()),
              h = (1 << a) * l.a3,
              f = c.x * h,
              v = c.y * h,
              w = Math.floor(f / l.a3),
              T = Math.floor(v / l.a3);
            return {
              tileID: new l.a0(a, 0, a, w, T),
              mercatorX: f,
              mercatorY: v
            }
          }
        }
        class nf {
          constructor(e, a, c) {
            this._context = e, this._size = a, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              c = new l.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(c.texture), {
              id: e,
              fbo: a,
              texture: c,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((a => e.id !== a)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed)
              if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const no = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class _i {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new nf(e.context, 30, a.tileManager.tileSize * a.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter((c => !e._layers[c].isHidden(a))), this._coordsAscending = {};
            for (const c in e.tileManagers) {
              this._coordsAscending[c] = {};
              const h = e.tileManagers[c].getVisibleCoordinates(),
                f = e.tileManagers[c].getSource(),
                v = f instanceof kr ? f.terrainTileRanges : null;
              for (const w of h) {
                const T = this.terrain.tileManager.getTerrainCoords(w, v);
                for (const C in T) this._coordsAscending[c][C] || (this._coordsAscending[c][C] = []), this._coordsAscending[c][C].push(T[C])
              }
            }
            this._coordsAscendingStr = {};
            for (const c of e._order) {
              const h = e._layers[c],
                f = h.source;
              if (no[h.type] && !this._coordsAscendingStr[f]) {
                this._coordsAscendingStr[f] = {};
                for (const v in this._coordsAscending[f]) this._coordsAscendingStr[f][v] = this._coordsAscending[f][v].map((w => w.key)).sort().join()
              }
            }
            for (const c of this._renderableTiles)
              for (const h in this._coordsAscendingStr) {
                const f = this._coordsAscendingStr[h][c.tileID.key];
                f && f !== c.rttCoords[h] && (c.rtt = [])
              }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const c = Object.assign(Object.assign({}, a), {
                isRenderingToTexture: !0
              }),
              h = e.type,
              f = this.painter,
              v = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (no[h] && (this._prevType && no[this._prevType] || this._stacks.push([]), this._prevType = h, this._stacks[this._stacks.length - 1].push(e.id), !v)) return !0;
            if (no[this._prevType] || no[h] && v) {
              this._prevType = h;
              const w = this._stacks.length - 1,
                T = this._stacks[w] || [];
              for (const C of this._renderableTiles) {
                if (this.pool.isFull() && (cu(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(C), C.rtt[w]) {
                  const j = this.pool.getObjectForId(C.rtt[w].id);
                  if (j.stamp === C.rtt[w].stamp) {
                    this.pool.useObject(j);
                    continue
                  }
                }
                const A = this.pool.getOrCreateFreeObject();
                this.pool.useObject(A), this.pool.stampObject(A), C.rtt[w] = {
                  id: A.id,
                  stamp: A.stamp
                }, f.context.bindFramebuffer.set(A.fbo.framebuffer), f.context.clear({
                  color: l.bi.transparent,
                  stencil: 0
                }), f.currentStencilSource = void 0;
                for (let j = 0; j < T.length; j++) {
                  const R = f.style._layers[T[j]],
                    Z = R.source ? this._coordsAscending[R.source][C.tileID.key] : [C.tileID];
                  f.context.viewport.set([0, 0, A.fbo.width, A.fbo.height]), f._renderTileClippingMasks(R, Z, !0), f.renderLayer(f, f.style.tileManagers[R.source], R, Z, c), R.source && (C.rttCoords[R.source] = this._coordsAscendingStr[R.source][C.tileID.key])
                }
              }
              return cu(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects(), no[h]
            }
            return !1
          }
        }
        const wi = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use âŒ˜ + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Md = F,
          Is = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: il,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: l.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          $l = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class wu {
          constructor(e, a, c = !1) {
            this.mousedown = f => {
              this.startMove(f, V.mousePos(this.element, f)), V.addEventListener(window, "mousemove", this.mousemove), V.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = f => {
              this.move(f, V.mousePos(this.element, f))
            }, this.mouseup = f => {
              this._rotatePitchHandler.dragEnd(f), this.offTemp()
            }, this.touchstart = f => {
              f.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = V.touchPos(this.element, f.targetTouches)[0], this.startMove(f, this._startPos), V.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), V.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = f => {
              f.targetTouches.length !== 1 ? this.reset() : (this._lastPos = V.touchPos(this.element, f.targetTouches)[0], this.move(f, this._lastPos))
            }, this.touchend = f => {
              f.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = a;
            const h = new fu;
            this._rotatePitchHandler = new Mr({
              clickTolerance: 3,
              move: (f, v) => {
                const w = a.getBoundingClientRect(),
                  T = new l.P((w.bottom - w.top) / 2, (w.right - w.left) / 2);
                return {
                  bearingDelta: l.cq(new l.P(f.x, v.y), v, T),
                  pitchDelta: c ? -.5 * (v.y - f.y) : void 0
                }
              },
              moveStateManager: h,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, V.addEventListener(a, "mousedown", this.mousedown), V.addEventListener(a, "touchstart", this.touchstart, {
              passive: !1
            }), V.addEventListener(a, "touchcancel", this.reset)
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), V.disableDrag()
          }
          move(e, a) {
            const c = this.map,
              {
                bearingDelta: h,
                pitchDelta: f
              } = this._rotatePitchHandler.dragMove(e, a) || {};
            h && c.setBearing(c.getBearing() + h), f && c.setPitch(c.getPitch() + f)
          }
          off() {
            const e = this.element;
            V.removeEventListener(e, "mousedown", this.mousedown), V.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), V.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), V.removeEventListener(window, "touchend", this.touchend), V.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            V.enableDrag(), V.removeEventListener(window, "mousemove", this.mousemove), V.removeEventListener(window, "mouseup", this.mouseup), V.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), V.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let fo;

        function Xl(d, e, a, c = !1) {
          if (c || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return d == null ? void 0 : d.wrap();
          const h = new l.U(d.lng, d.lat);
          if (d = new l.U(d.lng, d.lat), e) {
            const f = new l.U(d.lng - 360, d.lat),
              v = new l.U(d.lng + 360, d.lat),
              w = a.locationToScreenPoint(d).distSqr(e);
            a.locationToScreenPoint(f).distSqr(e) < w ? d = f : a.locationToScreenPoint(v).distSqr(e) < w && (d = v)
          }
          for (; Math.abs(d.lng - a.center.lng) > 180;) {
            const f = a.locationToScreenPoint(d);
            if (f.x >= 0 && f.y >= 0 && f.x <= a.width && f.y <= a.height) break;
            d.lng > a.center.lng ? d.lng -= 360 : d.lng += 360
          }
          return d.lng !== h.lng && a.isPointOnMapSurface(a.locationToScreenPoint(d)) ? d : h
        }
        const Yo = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function Yl(d, e, a) {
          const c = d.classList;
          for (const h in Yo) c.remove(`maplibregl-${a}-anchor-${h}`);
          c.add(`maplibregl-${a}-anchor-${e}`)
        }
        class al extends l.E {
          constructor(e) {
            if (super(), this._onKeyPress = a => {
                const c = a.code,
                  h = a.charCode || a.keyCode;
                c !== "Space" && c !== "Enter" && h !== 32 && h !== 13 || this.togglePopup()
              }, this._onMapClick = a => {
                const c = a.originalEvent.target,
                  h = this._element;
                this._popup && (c === h || h.contains(c)) && this.togglePopup()
              }, this._update = a => {
                if (!this._map) return;
                const c = this._map.loaded() && !this._map.isMoving();
                ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !c) && this._map.once("render", this._update), this._lngLat = Xl(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let h = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? h = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (h = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let f = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? f = "rotateX(0deg)" : this._pitchAlignment === "map" && (f = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), V.setTransform(this._element, `${Yo[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${f} ${h}`), se.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(a && a.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = a => {
                if (!this._isDragging) {
                  const c = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = a.point.dist(this._pointerdownPos) >= c
                }
                this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new l.l("dragstart"))), this.fire(new l.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new l.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = a => {
                this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = l.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = V.create("div");
              const a = V.createNS("http://www.w3.org/2000/svg", "svg"),
                c = 41,
                h = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${c}px`), a.setAttributeNS(null, "width", `${h}px`), a.setAttributeNS(null, "viewBox", `0 0 ${h} ${c}`);
              const f = V.createNS("http://www.w3.org/2000/svg", "g");
              f.setAttributeNS(null, "stroke", "none"), f.setAttributeNS(null, "stroke-width", "1"), f.setAttributeNS(null, "fill", "none"), f.setAttributeNS(null, "fill-rule", "evenodd");
              const v = V.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "fill-rule", "nonzero");
              const w = V.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), w.setAttributeNS(null, "fill", "#000000");
              const T = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const ce of T) {
                const me = V.createNS("http://www.w3.org/2000/svg", "ellipse");
                me.setAttributeNS(null, "opacity", "0.04"), me.setAttributeNS(null, "cx", "10.5"), me.setAttributeNS(null, "cy", "5.80029008"), me.setAttributeNS(null, "rx", ce.rx), me.setAttributeNS(null, "ry", ce.ry), w.appendChild(me)
              }
              const C = V.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "fill", this._color);
              const A = V.createNS("http://www.w3.org/2000/svg", "path");
              A.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), C.appendChild(A);
              const j = V.createNS("http://www.w3.org/2000/svg", "g");
              j.setAttributeNS(null, "opacity", "0.25"), j.setAttributeNS(null, "fill", "#000000");
              const R = V.createNS("http://www.w3.org/2000/svg", "path");
              R.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), j.appendChild(R);
              const Z = V.createNS("http://www.w3.org/2000/svg", "g");
              Z.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Z.setAttributeNS(null, "fill", "#FFFFFF");
              const Y = V.createNS("http://www.w3.org/2000/svg", "g");
              Y.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const oe = V.createNS("http://www.w3.org/2000/svg", "circle");
              oe.setAttributeNS(null, "fill", "#000000"), oe.setAttributeNS(null, "opacity", "0.25"), oe.setAttributeNS(null, "cx", "5.5"), oe.setAttributeNS(null, "cy", "5.5"), oe.setAttributeNS(null, "r", "5.4999962");
              const le = V.createNS("http://www.w3.org/2000/svg", "circle");
              le.setAttributeNS(null, "fill", "#FFFFFF"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962"), Y.appendChild(oe), Y.appendChild(le), v.appendChild(w), v.appendChild(C), v.appendChild(j), v.appendChild(Z), v.appendChild(Y), a.appendChild(v), a.setAttributeNS(null, "height", c * this._scale + "px"), a.setAttributeNS(null, "width", h * this._scale + "px"), this._element.appendChild(a), this._offset = l.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (a => {
                a.preventDefault()
              })), this._element.addEventListener("mousedown", (a => {
                a.preventDefault()
              })), Yl(this._element, this._anchor, "marker"), e && e.className)
              for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), V.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = l.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const h = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [h, -1 * (38.1 - 13.5 + h)],
                  "bottom-right": [-h, -1 * (38.1 - 13.5 + h)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var a, c;
            const h = (a = this._map) === null || a === void 0 ? void 0 : a.terrain,
              f = this._map.transform.isLocationOccluded(this._lngLat);
            if (!h || f) {
              const Z = f ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== Z && (this._element.style.opacity = Z))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const v = this._map,
              w = v.terrain.depthAtPoint(this._pos),
              T = v.terrain.getElevationForLngLatZoom(this._lngLat, v.transform.tileZoom);
            if (v.transform.lngLatToCameraDepth(this._lngLat, T) - w < .006) return void(this._element.style.opacity = this._opacity);
            const C = -this._offset.y / v.transform.pixelsPerMeter,
              A = Math.sin(v.getPitch() * Math.PI / 180) * C,
              j = v.terrain.depthAtPoint(new l.P(this._pos.x, this._pos.y - this._offset.y)),
              R = v.transform.lngLatToCameraDepth(this._lngLat, T + A) - j > .006;
            !((c = this._popup) === null || c === void 0) && c.isOpen() && R && this._popup.remove(), this._element.style.opacity = R ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = l.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(!0), this
          }
        }
        const ku = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let Cs = 0,
          Ko = !1;
        const Tu = {
          maxWidth: 100,
          unit: "metric"
        };

        function Kl(d, e, a) {
          const c = a && a.maxWidth || 100,
            h = d._container.clientHeight / 2,
            f = d._container.clientWidth / 2,
            v = d.unproject([f - c / 2, h]),
            w = d.unproject([f + c / 2, h]),
            T = Math.round(d.project(w).x - d.project(v).x),
            C = Math.min(c, T, d._container.clientWidth),
            A = v.distanceTo(w);
          if (a && a.unit === "imperial") {
            const j = 3.2808 * A;
            j > 5280 ? Jo(e, C, j / 5280, d._getUIString("ScaleControl.Miles")) : Jo(e, C, j, d._getUIString("ScaleControl.Feet"))
          } else a && a.unit === "nautical" ? Jo(e, C, A / 1852, d._getUIString("ScaleControl.NauticalMiles")) : A >= 1e3 ? Jo(e, C, A / 1e3, d._getUIString("ScaleControl.Kilometers")) : Jo(e, C, A, d._getUIString("ScaleControl.Meters"))
        }

        function Jo(d, e, a, c) {
          const h = (function(f) {
            const v = Math.pow(10, `${Math.floor(f)}`.length - 1);
            let w = f / v;
            return w = w >= 10 ? 10 : w >= 5 ? 5 : w >= 3 ? 3 : w >= 2 ? 2 : w >= 1 ? 1 : (function(T) {
              const C = Math.pow(10, Math.ceil(-Math.log(T) / Math.LN10));
              return Math.round(T * C) / C
            })(w), v * w
          })(a);
          d.style.width = e * (h / a) + "px", d.innerHTML = `${h}&nbsp;${c}`
        }
        const Su = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          Jl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function Ql(d) {
          if (d) {
            if (typeof d == "number") {
              const e = Math.round(Math.abs(d) / Math.SQRT2);
              return {
                center: new l.P(0, 0),
                top: new l.P(0, d),
                "top-left": new l.P(e, e),
                "top-right": new l.P(-e, e),
                bottom: new l.P(0, -d),
                "bottom-left": new l.P(e, -e),
                "bottom-right": new l.P(-e, -e),
                left: new l.P(d, 0),
                right: new l.P(-d, 0)
              }
            }
            if (d instanceof l.P || Array.isArray(d)) {
              const e = l.P.convert(d);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: l.P.convert(d.center || [0, 0]),
              top: l.P.convert(d.top || [0, 0]),
              "top-left": l.P.convert(d["top-left"] || [0, 0]),
              "top-right": l.P.convert(d["top-right"] || [0, 0]),
              bottom: l.P.convert(d.bottom || [0, 0]),
              "bottom-left": l.P.convert(d["bottom-left"] || [0, 0]),
              "bottom-right": l.P.convert(d["bottom-right"] || [0, 0]),
              left: l.P.convert(d.left || [0, 0]),
              right: l.P.convert(d.right || [0, 0])
            }
          }
          return Ql(new l.P(0, 0))
        }
        const Pu = F;
        k.AJAXError = l.cC, k.Event = l.l, k.Evented = l.E, k.LngLat = l.U, k.MercatorCoordinate = l.a5, k.Point = l.P, k.addProtocol = l.cD, k.config = l.a, k.removeProtocol = l.cE, k.AttributionControl = oa, k.BoxZoomHandler = pd, k.CanvasSource = Wr, k.CooperativeGesturesHandler = Za, k.DoubleClickZoomHandler = rl, k.DragPanHandler = yu, k.DragRotateHandler = bu, k.EdgeInsets = fn, k.FullscreenControl = class extends l.E {
          constructor(d = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement;) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, d && d.container && (d.container instanceof HTMLElement ? this._container = d.container : l.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(d) {
            return this._map = d, this._container || (this._container = this._map.getContainer()), this._controlContainer = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            V.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const d = this._fullscreenButton = V.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            V.create("span", "maplibregl-ctrl-icon", d).setAttribute("aria-hidden", "true"), d.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const d = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", d), this._fullscreenButton.title = d
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new l.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new l.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, k.GeoJSONSource = qr, k.GeolocateControl = class extends l.E {
          constructor(d) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new l.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new l.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const a = new l.U(e.coords.longitude, e.coords.latitude),
                c = e.coords.accuracy,
                h = this._map.getBearing(),
                f = l.e({
                  bearing: h
                }, this.options.fitBoundsOptions),
                v = kt.fromLngLat(a, c);
              this._map.fitBounds(v, f, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const a = new l.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Ko) return;
                  this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new l.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = V.create("button", "maplibregl-ctrl-geolocate", this._container), V.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  l.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = V.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new al({
                  element: this._dotElement
                }), this._circleElement = V.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new al({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (a => {
                  const c = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || c || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new l.l("trackuserlocationend")), this.fire(new l.l("userlocationlostfocus")))
                }))
              }
            }, this.options = l.e({}, ku, d)
          }
          onAdd(d) {
            return this._map = d, this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return l._(this, arguments, void 0, (function*(e = !1) {
                if (fo !== void 0 && !e) return fo;
                if (window.navigator.permissions === void 0) return fo = !!window.navigator.geolocation, fo;
                try {
                  fo = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  fo = !!window.navigator.geolocation
                }
                return fo
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), V.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Cs = 0, Ko = !1
          }
          _isOutOfMapMaxBounds(d) {
            const e = this._map.getMaxBounds(),
              a = d.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadiusIfNeeded() {
            const d = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && d)) return;
            const e = this._map.project(d),
              a = this._map.unproject([e.x + 100, e.y]),
              c = d.distanceTo(a) / 100,
              h = 2 * this._accuracy / c;
            this._circleElement.style.width = `${h.toFixed(2)}px`, this._circleElement.style.height = `${h.toFixed(2)}px`
          }
          trigger() {
            if (!this._setup) return l.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new l.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Cs--, Ko = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new l.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new l.l("trackuserlocationstart")), this.fire(new l.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let d;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Cs++, Cs > 1 ? (d = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Ko = !0) : (d = this.options.positionOptions, Ko = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, d)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, k.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var d;
              const e = (d = this._map.getProjection()) === null || d === void 0 ? void 0 : d.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var d;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((d = this._map.getProjection()) === null || d === void 0 ? void 0 : d.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(d) {
            return this._map = d, this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = V.create("button", "maplibregl-ctrl-globe", this._container), V.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            V.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, k.Hash = hu, k.ImageSource = kr, k.KeyboardHandler = xd, k.LngLatBounds = kt, k.LogoControl = xu, k.Map = class extends Sd {
          constructor(d) {
            var e, a;
            l.cz.mark(l.cA.create);
            const c = Object.assign(Object.assign(Object.assign({}, Is), d), {
              canvasContextAttributes: Object.assign(Object.assign({}, Is.canvasContextAttributes), d.canvasContextAttributes)
            });
            if (c.minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (c.minPitch != null && c.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (c.maxPitch != null && c.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const h = new Pi,
              f = new Ni;
            if (c.minZoom !== void 0 && h.setMinZoom(c.minZoom), c.maxZoom !== void 0 && h.setMaxZoom(c.maxZoom), c.minPitch !== void 0 && h.setMinPitch(c.minPitch), c.maxPitch !== void 0 && h.setMaxPitch(c.maxPitch), c.renderWorldCopies !== void 0 && h.setRenderWorldCopies(c.renderWorldCopies), c.transformConstrain !== null && h.setConstrain(c.transformConstrain), super(h, f, {
                bearingSnap: c.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Ga, this._controls = [], this._mapId = l.ab(), this._contextLost = w => {
                w.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new l.l("webglcontextlost", {
                  originalEvent: w
                }))
              }, this._contextRestored = w => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new l.l("webglcontextrestored", {
                  originalEvent: w
                }))
              }, this._onMapScroll = w => {
                if (w.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = c.interactive, this._maxTileCacheSize = c.maxTileCacheSize, this._maxTileCacheZoomLevels = c.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, c.canvasContextAttributes), this._trackResize = c.trackResize === !0, this._bearingSnap = c.bearingSnap, this._centerClampedToGround = c.centerClampedToGround, this._refreshExpiredTiles = c.refreshExpiredTiles === !0, this._fadeDuration = c.fadeDuration, this._crossSourceCollisions = c.crossSourceCollisions === !0, this._collectResourceTiming = c.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, wi), c.locale), this._clickTolerance = c.clickTolerance, this._overridePixelRatio = c.pixelRatio, this._maxCanvasSize = c.maxCanvasSize, this.transformCameraUpdate = c.transformCameraUpdate, this.transformConstrain = c.transformConstrain, this.cancelPendingTileRequestsWhileZooming = c.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Ye.addThrottleControl((() => this.isMoving())), this._requestManager = new Ce(c.transformRequest), typeof c.container == "string") {
              if (this._container = document.getElementById(c.container), !this._container) throw new Error(`Container '${c.container}' not found.`)
            } else {
              if (!(c.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = c.container
            }
            if (c.maxBounds && this.setMaxBounds(c.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let w = !1;
              const T = uu((C => {
                this._trackResize && !this._removed && (this.resize(C), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((C => {
                w ? T(C) : w = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new nl(this, c), this._hash = c.hash && new hu(typeof c.hash == "string" && c.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: c.center,
              elevation: c.elevation,
              zoom: c.zoom,
              bearing: c.bearing,
              pitch: c.pitch,
              roll: c.roll
            }), c.bounds && (this.resize(), this.fitBounds(c.bounds, l.e({}, c.fitBoundsOptions, {
              duration: 0
            }))));
            const v = typeof c.style == "string" || ((a = (e = c.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, v), this._localIdeographFontFamily = c.localIdeographFontFamily, this._validateStyle = c.validateStyle, c.style && this.setStyle(c.style, {
              localIdeographFontFamily: c.localIdeographFontFamily
            }), c.attributionControl && this.addControl(new oa(typeof c.attributionControl == "boolean" ? void 0 : c.attributionControl)), c.maplibreLogo && this.addControl(new xu, c.logoPosition), this.on("style.load", (() => {
              if (v || this._resizeTransform(), this.transform.unmodified) {
                const w = l.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(w)
              }
            })), this.on("data", (w => {
              this._update(w.dataType === "style"), this.fire(new l.l(`${w.dataType}data`, w))
            })), this.on("dataloading", (w => {
              this.fire(new l.l(`${w.dataType}dataloading`, w))
            })), this.on("dataabort", (w => {
              this.fire(new l.l("sourcedataabort", w))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(d, e) {
            return this.style.setGlobalStateProperty(d, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(d, e) {
            if (e === void 0 && (e = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd) return this.fire(new l.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = d.onAdd(this);
            this._controls.push(d);
            const c = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? c.insertBefore(a, c.firstChild) : c.appendChild(a), this
          }
          removeControl(d) {
            if (!d || !d.onRemove) return this.fire(new l.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(d);
            return e > -1 && this._controls.splice(e, 1), d.onRemove(this), this
          }
          hasControl(d) {
            return this._controls.indexOf(d) > -1
          }
          coveringTiles(d) {
            return $e(this.transform, d)
          }
          calculateCameraOptionsFromTo(d, e, a, c) {
            return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(d, e, a, c)
          }
          resize(d, e = !0) {
            const [a, c] = this._containerDimensions(), h = this._getClampedPixelRatio(a, c);
            if (this._resizeCanvas(a, c, h), this.painter.resize(a, c, h), this.painter.overLimit()) {
              const v = this.painter.context.gl;
              this._maxCanvasSize = [v.drawingBufferWidth, v.drawingBufferHeight];
              const w = this._getClampedPixelRatio(a, c);
              this._resizeCanvas(a, c, w), this.painter.resize(a, c, w)
            }
            this._resizeTransform(e);
            const f = !this._moving;
            return f && (this.stop(), this.fire(new l.l("movestart", d)).fire(new l.l("move", d))), this.fire(new l.l("resize", d)), f && this.fire(new l.l("moveend", d)), this
          }
          _resizeTransform(d = !0) {
            var e;
            const [a, c] = this._containerDimensions();
            this.transform.resize(a, c, d), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, c, d)
          }
          _getClampedPixelRatio(d, e) {
            const {
              0: a,
              1: c
            } = this._maxCanvasSize, h = this.getPixelRatio(), f = d * h, v = e * h;
            return Math.min(f > a ? a / f : 1, v > c ? c / v : 1) * h
          }
          getPixelRatio() {
            var d;
            return (d = this._overridePixelRatio) !== null && d !== void 0 ? d : devicePixelRatio
          }
          setPixelRatio(d) {
            this._overridePixelRatio = d, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(d) {
            return this.transform.setMaxBounds(kt.convert(d)), this._update()
          }
          setMinZoom(d) {
            if ((d = d ?? -2) >= -2 && d <= this.transform.maxZoom) return this.transform.setMinZoom(d), this._update(), this.getZoom() < d && this.setZoom(d), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(d) {
            if ((d = d ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(d), this._update(), this.getZoom() > d && this.setZoom(d), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(d) {
            if ((d = d ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (d >= 0 && d <= this.transform.maxPitch) return this.transform.setMinPitch(d), this._update(), this.getPitch() < d && this.setPitch(d), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(d) {
            if ((d = d ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (d >= this.transform.minPitch) return this.transform.setMaxPitch(d), this._update(), this.getPitch() > d && this.setPitch(d), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(d) {
            return this.transform.setRenderWorldCopies(d), this._update()
          }
          setTransformConstrain(d) {
            return this.transform.setConstrain(d), this._update()
          }
          project(d) {
            return this.transform.locationToScreenPoint(l.U.convert(d), this.style && this.terrain)
          }
          unproject(d) {
            return this.transform.screenPointToLocation(l.P.convert(d), this.terrain)
          }
          isMoving() {
            var d;
            return this._moving || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isMoving())
          }
          isZooming() {
            var d;
            return this._zooming || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isZooming())
          }
          isRotating() {
            var d;
            return this._rotating || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isRotating())
          }
          _createDelegatedListener(d, e, a) {
            if (d === "mouseenter" || d === "mouseover") {
              let c = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: f => {
                    const v = e.filter((T => this.getLayer(T))),
                      w = v.length !== 0 ? this.queryRenderedFeatures(f.point, {
                        layers: v
                      }) : [];
                    w.length ? c || (c = !0, a.call(this, new ga(d, this, f.originalEvent, {
                      features: w
                    }))) : c = !1
                  },
                  mouseout: () => {
                    c = !1
                  }
                }
              }
            }
            if (d === "mouseleave" || d === "mouseout") {
              let c = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: v => {
                    const w = e.filter((T => this.getLayer(T)));
                    (w.length !== 0 ? this.queryRenderedFeatures(v.point, {
                      layers: w
                    }) : []).length ? c = !0 : c && (c = !1, a.call(this, new ga(d, this, v.originalEvent)))
                  },
                  mouseout: v => {
                    c && (c = !1, a.call(this, new ga(d, this, v.originalEvent)))
                  }
                }
              }
            } {
              const c = h => {
                const f = e.filter((w => this.getLayer(w))),
                  v = f.length !== 0 ? this.queryRenderedFeatures(h.point, {
                    layers: f
                  }) : [];
                v.length && (h.features = v, a.call(this, h), delete h.features)
              };
              return {
                layers: e,
                listener: a,
                delegates: {
                  [d]: c
                }
              }
            }
          }
          _saveDelegatedListener(d, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(e)
          }
          _removeDelegatedListener(d, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[d]) return;
            const c = this._delegatedListeners[d];
            for (let h = 0; h < c.length; h++) {
              const f = c[h];
              if (f.listener === a && f.layers.length === e.length && f.layers.every((v => e.includes(v)))) {
                for (const v in f.delegates) this.off(v, f.delegates[v]);
                return void c.splice(h, 1)
              }
            }
          }
          on(d, e, a) {
            if (a === void 0) return super.on(d, e);
            const c = typeof e == "string" ? [e] : e,
              h = this._createDelegatedListener(d, c, a);
            this._saveDelegatedListener(d, h);
            for (const f in h.delegates) this.on(f, h.delegates[f]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(d, c, a)
              }
            }
          }
          once(d, e, a) {
            if (a === void 0) return super.once(d, e);
            const c = typeof e == "string" ? [e] : e,
              h = this._createDelegatedListener(d, c, a);
            for (const f in h.delegates) {
              const v = h.delegates[f];
              h.delegates[f] = (...w) => {
                this._removeDelegatedListener(d, c, a), v(...w)
              }
            }
            this._saveDelegatedListener(d, h);
            for (const f in h.delegates) this.once(f, h.delegates[f]);
            return this
          }
          off(d, e, a) {
            return a === void 0 ? super.off(d, e) : (this._removeDelegatedListener(d, typeof e == "string" ? [e] : e, a), this)
          }
          queryRenderedFeatures(d, e) {
            if (!this.style) return [];
            let a;
            const c = d instanceof l.P || Array.isArray(d),
              h = c ? d : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (c ? {} : d) || {}, h instanceof l.P || typeof h[0] == "number") a = [l.P.convert(h)];
            else {
              const f = l.P.convert(h[0]),
                v = l.P.convert(h[1]);
              a = [f, new l.P(v.x, f.y), v, new l.P(f.x, v.y), f]
            }
            return this.style.queryRenderedFeatures(a, e, this.transform)
          }
          querySourceFeatures(d, e) {
            return this.style.querySourceFeatures(d, e)
          }
          setStyle(d, e) {
            return (e = l.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && d ? (this._diffStyle(d, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(d, e))
          }
          setTransformRequest(d) {
            return this._requestManager.setTransformRequest(d), this
          }
          _getUIString(d) {
            const e = this._locale[d];
            if (e == null) throw new Error(`Missing UI string '${d}'`);
            return e
          }
          _updateStyle(d, e) {
            var a, c;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(d, e)));
            const h = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!d)), d ? (this.style = new Us(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof d == "string" ? this.style.loadURL(d, e, h) : this.style.loadJSON(d, e, h), this) : ((c = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || c === void 0 || c.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Us(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(d, e) {
            if (typeof d == "string") {
              const a = this._requestManager.transformRequest(d, "Style");
              l.j(a, new AbortController).then((c => {
                this._updateDiff(c.data, e)
              })).catch((c => {
                c && this.fire(new l.k(c))
              }))
            } else typeof d == "object" && this._updateDiff(d, e)
          }
          _updateDiff(d, e) {
            try {
              this.style.setState(d, e) && this._update(!0)
            } catch (a) {
              l.w(`Unable to perform style diff: ${a.message||a.error||a}.  Rebuilding the style from scratch.`), this._updateStyle(d, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : l.w("There is no style added to the map.")
          }
          addSource(d, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(d, e), this._update(!0)
          }
          isSourceLoaded(d) {
            const e = this.style && this.style.tileManagers[d];
            if (e !== void 0) return e.loaded();
            this.fire(new l.k(new Error(`There is no tile manager with ID '${d}'`)))
          }
          setTerrain(d) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), d) {
              const e = this.style.tileManagers[d.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${d.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const c = this.style._layers[a];
                c.type === "hillshade" && c.source === d.source && l.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), c.type === "color-relief" && c.source === d.source && l.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new rf(this.painter, e, d), this.painter.renderToTexture = new _i(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = a => {
                var c;
                a.dataType === "style" ? this.terrain.tileManager.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== d.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((c = a.source) === null || c === void 0 ? void 0 : c.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(a.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new l.l("terrain", {
              terrain: d
            })), this
          }
          getTerrain() {
            var d, e;
            return (e = (d = this.terrain) === null || d === void 0 ? void 0 : d.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const d = this.style && this.style.tileManagers;
            for (const e in d) {
              const a = d[e]._tiles;
              for (const c in a) {
                const h = a[c];
                if (h.state !== "loaded" && h.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(d) {
            return this.style.removeSource(d), this._update(!0)
          }
          getSource(d) {
            return this.style.getSource(d)
          }
          setSourceTileLodParams(d, e, a) {
            if (a) {
              const c = this.getSource(a);
              if (!c) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              c.calculateTileZoom = Ue(Math.max(1, d), Math.max(1, e))
            } else
              for (const c in this.style.tileManagers) this.style.tileManagers[c].getSource().calculateTileZoom = Ue(Math.max(1, d), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(d, e) {
            const a = this.style.tileManagers[d];
            if (!a) throw new Error(`There is no tile manager with ID "${d}", cannot refresh tile`);
            e === void 0 ? a.reload(!0) : a.refreshTiles(e.map((c => new l.a8(c.z, c.x, c.y))))
          }
          addImage(d, e, a = {}) {
            const {
              pixelRatio: c = 1,
              sdf: h = !1,
              stretchX: f,
              stretchY: v,
              content: w,
              textFitWidth: T,
              textFitHeight: C
            } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || l.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new l.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: A,
                  height: j,
                  data: R
                } = e, Z = e;
                return this.style.addImage(d, {
                  data: new l.R({
                    width: A,
                    height: j
                  }, new Uint8Array(R)),
                  pixelRatio: c,
                  stretchX: f,
                  stretchY: v,
                  content: w,
                  textFitWidth: T,
                  textFitHeight: C,
                  sdf: h,
                  version: 0,
                  userImage: Z
                }), Z.onAdd && Z.onAdd(this, d), this
              }
            } {
              const {
                width: A,
                height: j,
                data: R
              } = se.getImageData(e);
              this.style.addImage(d, {
                data: new l.R({
                  width: A,
                  height: j
                }, R),
                pixelRatio: c,
                stretchX: f,
                stretchY: v,
                content: w,
                textFitWidth: T,
                textFitHeight: C,
                sdf: h,
                version: 0
              })
            }
          }
          updateImage(d, e) {
            const a = this.style.getImage(d);
            if (!a) return this.fire(new l.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = e instanceof HTMLImageElement || l.b(e) ? se.getImageData(e) : e,
              {
                width: h,
                height: f,
                data: v
              } = c;
            if (h === void 0 || f === void 0) return this.fire(new l.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (h !== a.data.width || f !== a.data.height) return this.fire(new l.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const w = !(e instanceof HTMLImageElement || l.b(e));
            return a.data.replace(v, w), this.style.updateImage(d, a), this
          }
          getImage(d) {
            return this.style.getImage(d)
          }
          hasImage(d) {
            return d ? !!this.style.getImage(d) : (this.fire(new l.k(new Error("Missing required image id"))), !1)
          }
          removeImage(d) {
            this.style.removeImage(d)
          }
          loadImage(d) {
            return Ye.getImage(this._requestManager.transformRequest(d, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(d, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(d, e), this._update(!0)
          }
          moveLayer(d, e) {
            return this.style.moveLayer(d, e), this._update(!0)
          }
          removeLayer(d) {
            return this.style.removeLayer(d), this._update(!0)
          }
          getLayer(d) {
            return this.style.getLayer(d)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(d, e, a) {
            return this.style.setLayerZoomRange(d, e, a), this._update(!0)
          }
          setFilter(d, e, a = {}) {
            return this.style.setFilter(d, e, a), this._update(!0)
          }
          getFilter(d) {
            return this.style.getFilter(d)
          }
          setPaintProperty(d, e, a, c = {}) {
            return this.style.setPaintProperty(d, e, a, c), this._update(!0)
          }
          getPaintProperty(d, e) {
            return this.style.getPaintProperty(d, e)
          }
          setLayoutProperty(d, e, a, c = {}) {
            return this.style.setLayoutProperty(d, e, a, c), this._update(!0)
          }
          getLayoutProperty(d, e) {
            return this.style.getLayoutProperty(d, e)
          }
          setGlyphs(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(d, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(d, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(d, e, a, (c => {
              c || this._update(!0)
            })), this
          }
          removeSprite(d) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(d), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(d, e, (a => {
              a || this._update(!0)
            })), this
          }
          setLight(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(d, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(d, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(d, e) {
            return this.style.setFeatureState(d, e), this._update()
          }
          removeFeatureState(d, e) {
            return this.style.removeFeatureState(d, e), this._update()
          }
          getFeatureState(d) {
            return this.style.getFeatureState(d)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let d = 0,
              e = 0;
            return this._container && (d = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [d, e]
          }
          _setupContainer() {
            const d = this._container;
            d.classList.add("maplibregl-map");
            const e = this._canvasContainer = V.create("div", "maplibregl-canvas-container", d);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = V.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(),
              c = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], c);
            const h = this._controlContainer = V.create("div", "maplibregl-control-container", d),
              f = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((v => {
              f[v] = V.create("div", `maplibregl-ctrl-${v} `, h)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(d, e, a) {
            this._canvas.width = Math.floor(a * d), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${d}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const d = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (c => {
              e = {
                requestedAttributes: d
              }, c && (e.statusMessage = c.statusMessage, e.type = c.type)
            }), {
              once: !0
            });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, d) : this._canvas.getContext("webgl2", d) || this._canvas.getContext("webgl", d), !a) {
              const c = "Failed to initialize WebGL";
              throw e ? (e.message = c, new Error(JSON.stringify(e))) : new Error(c)
            }
            this.painter = new od(a, this.transform), Me.testSupport(a)
          }
          migrateProjection(d, e) {
            super.migrateProjection(d, e), this.painter.transform = d, this.fire(new l.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(d) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(d) {
            return this._update(), this._renderTaskQueue.add(d)
          }
          _cancelRenderFrame(d) {
            this._renderTaskQueue.remove(d)
          }
          _render(d) {
            var e, a, c, h, f;
            const v = this._idleTriggered ? this._fadeDuration : 0,
              w = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(d), this._removed) return;
            let T = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const j = this.transform.zoom,
                R = ge();
              this.style.zoomHistory.update(j, R);
              const Z = new l.G(j, {
                  now: R,
                  fadeDuration: v,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition()
                }),
                Y = Z.crossFadingFactor();
              Y === 1 && Y === this._crossFadingFactor || (T = !0, this._crossFadingFactor = Y), this.style.update(Z)
            }
            const C = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== w;
            (c = this.style.projection) === null || c === void 0 || c.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((h = this.style.projection) === null || h === void 0 ? void 0 : h.transitionState, (f = this.style.projection) === null || f === void 0 ? void 0 : f.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || C) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, v, this._crossSourceCollisions, C), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: v,
              showPadding: this.showPadding
            }), this.fire(new l.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, l.cz.mark(l.cA.load), this.fire(new l.l("load"))), this.style && (this.style.hasTransitions() || T) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const A = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return A || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new l.l("idle")), !this._loaded || this._fullyLoaded || A || (this._fullyLoaded = !0, l.cz.mark(l.cA.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var d;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Ye.removeThrottleControl(this._imageQueueHandle), (d = this._resizeObserver) === null || d === void 0 || d.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), V.remove(this._canvasContainer), V.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), l.cz.clearMetrics(), this._removed = !0, this.fire(new l.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, se.frame(this._frameRequest, (d => {
              l.cz.frame(d), this._frameRequest = null;
              try {
                this._render(d)
              } catch (e) {
                if (!l.cB(e) && !(function(a) {
                    return a.message === Jh
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(d) {
            this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(d) {
            this._showPadding !== d && (this._showPadding = d, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(d) {
            this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, d ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(d) {
            this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(d) {
            this._repaint !== d && (this._repaint = d, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(d) {
            this._vertices = d, this._update()
          }
          get version() {
            return Md
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(d) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(d), this._update(!0)
          }
        }, k.MapMouseEvent = ga, k.MapTouchEvent = ua, k.MapWheelEvent = dd, k.Marker = al, k.NavigationControl = class {
          constructor(d) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                a = e === this._map.getMaxZoom(),
                c = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, a) => {
              const c = this._map._getUIString(`NavigationControl.${a}`);
              e.title = c, e.setAttribute("aria-label", c)
            }, this.options = l.e({}, $l, d), this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), V.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), V.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = V.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(d) {
            return this._map = d, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new wu(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            V.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(d, e) {
            const a = V.create("button", d, this._container);
            return a.type = "button", a.addEventListener("click", e), a
          }
        }, k.Popup = class extends l.E {
          constructor(d) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && V.remove(this._content), this._container && (V.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new l.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = V.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = V.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const v of this.options.className.split(" ")) this._container.classList.add(v);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Xl(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let c = this.options.anchor;
              const h = Ql(this.options.offset);
              if (!c) {
                const v = this._container.offsetWidth,
                  w = this._container.offsetHeight;
                let T;
                T = a.y + h.bottom.y < w ? ["top"] : a.y > this._map.transform.height - w ? ["bottom"] : [], a.x < v / 2 ? T.push("left") : a.x > this._map.transform.width - v / 2 && T.push("right"), c = T.length === 0 ? "bottom" : T.join("-")
              }
              let f = a.add(h[c]);
              this.options.subpixelPositioning || (f = f.round()), V.setTransform(this._container, `${Yo[c]} translate(${f.x}px,${f.y}px)`), Yl(this._container, c, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = l.e(Object.create(Su), d)
          }
          addTo(d) {
            return this._map && this.remove(), this._map = d, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new l.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(d) {
            return this._lngLat = l.U.convert(d), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(d) {
            return this.setDOMContent(document.createTextNode(d))
          }
          setHTML(d) {
            const e = document.createDocumentFragment(),
              a = document.createElement("body");
            let c;
            for (a.innerHTML = d; c = a.firstChild, c;) e.appendChild(c);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var d;
            return (d = this._container) === null || d === void 0 ? void 0 : d.style.maxWidth
          }
          setMaxWidth(d) {
            return this.options.maxWidth = d, this._update(), this
          }
          setDOMContent(d) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = V.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(d), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(d) {
            return this._container && this._container.classList.add(d), this
          }
          removeClassName(d) {
            return this._container && this._container.classList.remove(d), this
          }
          setOffset(d) {
            return this.options.offset = d, this._update(), this
          }
          toggleClassName(d) {
            if (this._container) return this._container.classList.toggle(d)
          }
          setSubpixelPositioning(d) {
            this.options.subpixelPositioning = d
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = V.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const d = this._container.querySelector(Jl);
            d && d.focus()
          }
        }, k.RasterDEMTileSource = hr, k.RasterTileSource = ht, k.ScaleControl = class {
          constructor(d) {
            this._onMove = () => {
              Kl(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, Kl(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Tu), d)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(d) {
            return this._map = d, this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", d.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            V.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, k.ScrollZoomHandler = wd, k.Style = Us, k.TerrainControl = class {
          constructor(d) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = d
          }
          onAdd(d) {
            return this._map = d, this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = V.create("button", "maplibregl-ctrl-terrain", this._container), V.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            V.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, k.TwoFingersTouchPitchHandler = yd, k.TwoFingersTouchRotateHandler = Wl, k.TwoFingersTouchZoomHandler = vd, k.TwoFingersTouchZoomRotateHandler = Td, k.VectorTileSource = Gt, k.VideoSource = Zr, k.addSourceType = (d, e) => l._(void 0, void 0, void 0, (function*() {
          if (Hr(d)) throw new Error(`A source type called "${d}" already exists.`);
          ((a, c) => {
            tr[a] = c
          })(d, e)
        })), k.clearPrewarmedResources = function() {
          const d = Yt;
          d && (d.isPreloaded() && d.numActive() === 1 ? (d.release(jt), Yt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, k.createTileMesh = ka, k.getMaxParallelImageRequests = function() {
          return l.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, k.getRTLTextPluginStatus = function() {
          return N().getRTLTextPluginStatus()
        }, k.getVersion = function() {
          return Pu
        }, k.getWorkerCount = function() {
          return Xt.workerCount
        }, k.getWorkerUrl = function() {
          return l.a.WORKER_URL
        }, k.importScriptInWorkers = function(d) {
          return Ut().broadcast("IS", d)
        }, k.isTimeFrozen = function() {
          return _e.isFrozen()
        }, k.now = ge, k.prewarm = function() {
          ot().acquire(jt)
        }, k.restoreNow = function() {
          _e.restoreNow()
        }, k.setMaxParallelImageRequests = function(d) {
          l.a.MAX_PARALLEL_IMAGE_REQUESTS = d
        }, k.setNow = function(d) {
          _e.setNow(d)
        }, k.setRTLTextPlugin = function(d, e) {
          return N().setRTLTextPlugin(d, e)
        }, k.setWorkerCount = function(d) {
          Xt.workerCount = d
        }, k.setWorkerUrl = function(d) {
          l.a.WORKER_URL = d
        }
      }));
      var E = r;
      return E
    }))
  })(sp)), sp.exports
}
var tde = ede();
const Kd = Jhe(tde);
class Sv {
  constructor(s) {
    mn(this, "gm");
    mn(this, "markers", new Map);
    mn(this, "canvases", new Map);
    mn(this, "canvasSize");
    mn(this, "canvasOpacity", .8);
    this.input = s, this.gm = new Aa(this.input.tileSize);
    const r = L0(s.img);
    this.canvasSize = Math.ceil(2e3 / r)
  }
  place([s, r]) {
    const x = this.gm.latLonToPixelsFloor(s, r, this.input.zoom),
      z = this.getMarkerId(x),
      E = this.gm.latLonToPixelBoundsLatLon(s, r, this.input.zoom),
      k = this.input.map;
    if (this.input.markerFn && !this.markers.has(z)) {
      const $ = this.input.markerFn();
      $.setLngLat({
        lat: E.min[0],
        lng: (E.max[1] + E.min[1]) / 2
      }).addTo(k), this.markers.set(z, $)
    }
    const {
      key: l,
      pos: F,
      innerPos: W
    } = this.getCanvasPos(x);
    let ee = this.canvases.get(l);
    if (!ee) {
      const $ = this.canvasSize,
        se = F.x * $,
        _e = F.y * $,
        ge = se + $ - 1,
        V = _e + $ - 1,
        Me = this.gm.pixelsToLatLon(se, V + 1, this.input.zoom),
        we = this.gm.pixelsToLatLon(ge + 1, _e, this.input.zoom);
      ee = new rde({
        id: `${this.input.id}-${l}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: nm({
          min: Me,
          max: we
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), ee.addTo(this.input.map), this.canvases.set(l, ee)
    }
    ee.place(W.x, W.y)
  }
  clear() {
    const s = this.input.map;
    for (const r of this.canvases.values()) r.removeFrom(s), r.removeDOM();
    this.canvases.clear();
    for (const r of this.markers.values()) r.remove();
    this.markers.clear()
  }
  clearAndPlace(s) {
    this.clear(), this.place(s)
  }
  remove([s, r]) {
    let x = !1;
    const z = this.gm.latLonToPixelsFloor(s, r, this.input.zoom),
      {
        key: E,
        innerPos: k
      } = this.getCanvasPos(z),
      l = this.canvases.get(E);
    l && (x = l.remove(k.x, k.y), l.annotationsCount() === 0 && (this.canvases.delete(E), l.removeFrom(this.input.map), l.removeDOM()));
    const F = this.getMarkerId(z),
      W = this.markers.get(F);
    return W == null || W.remove(), this.markers.delete(F), x
  }
  setCanvasOpacity(s) {
    this.canvasOpacity = s;
    for (const r of this.canvases.values()) r.setOpacity(s)
  }
  getMarkerId([s, r]) {
    return `${this.input.id}:${s},${r}`
  }
  getCanvasPos([s, r]) {
    const x = {
        x: Math.floor(s / this.canvasSize),
        y: Math.floor(r / this.canvasSize)
      },
      z = {
        x: s % this.canvasSize,
        y: r % this.canvasSize
      },
      E = `${x.x},${x.y}`;
    return {
      pos: x,
      innerPos: z,
      key: E
    }
  }
}
class rde {
  constructor(s) {
    mn(this, "annotations", new Set);
    mn(this, "canvas");
    mn(this, "imgSize");
    mn(this, "maps", new Set);
    mn(this, "pendingRepaint", !1);
    this.input = s, this.imgSize = L0(s.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(s, r) {
    const x = this.getPixelKey(s, r);
    if (this.annotations.has(x)) return !1;
    const z = this.canvas.getContext("2d");
    if (z) {
      const E = s * this.imgSize,
        k = r * this.imgSize;
      z.drawImage(this.input.img, E, k)
    }
    return this.annotations.add(x), this.triggerRepaint(), !0
  }
  remove(s, r) {
    const x = this.getPixelKey(s, r);
    if (!this.annotations.has(x)) return !1;
    const z = this.canvas.getContext("2d");
    if (z) {
      const E = s * this.imgSize,
        k = r * this.imgSize;
      z.clearRect(E, k, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(x), this.triggerRepaint(), !0
  }
  addTo(s) {
    const r = this.input.id;
    s.getSource(r) || s.addSource(r, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates,
      animate: !1
    }), s.getLayer(r) || s.addLayer({
      id: r,
      type: "raster",
      source: r,
      paint: this.input.layerPaint
    }), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: r
    } = this.input;
    s.getLayer(r) && s.removeLayer(r), s.getSource(r) && s.removeSource(r), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(s) {
    for (const r of this.maps.values()) r.setPaintProperty(this.input.id, "raster-opacity", s)
  }
  getPixelKey(s, r) {
    return `${s},${r}`
  }
  triggerRepaint() {
    this.pendingRepaint || (this.pendingRepaint = !0, requestAnimationFrame(() => {
      for (const s of this.maps.values()) {
        const r = s.getSource(this.input.id);
        r.play(), s.once("render", () => {
          r.pause(), this.pendingRepaint = !1
        })
      }
    }))
  }
}

function L0(p) {
  return Math.max(p.naturalWidth, p.naturalHeight)
}

function nde() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function ide(p) {
  const s = {
      opaque: !0
    },
    r = p.searchParams.get("lat"),
    x = p.searchParams.get("lng");
  r && x && (s.pos = {
    lat: parseFloat(r),
    lng: parseFloat(x)
  });
  const z = p.searchParams.get("zoom");
  z && (s.zoom = parseFloat(z));
  const E = p.searchParams.get("season");
  E && (s.season = parseInt(E));
  const k = p.searchParams.get("opaque");
  return k && (s.opaque = k !== "0"), p.searchParams.get("select") && (s.select = !0), p.searchParams.get("twitch-migration") && (s.twitchMigration = !0), s.newUser = !!p.searchParams.get("new-user"), s.discordLinked = !!p.searchParams.get("discord-linked"), s.alliance = !!p.searchParams.get("alliance"), s
}

function ade(p, s) {
  return p = new URL(p), s.pos !== void 0 && (p.searchParams.set("lat", s.pos.lat.toString()), p.searchParams.set("lng", s.pos.lng.toString())), s.zoom !== void 0 && p.searchParams.set("zoom", s.zoom.toString()), s.season !== void 0 && p.searchParams.set("season", s.season.toString()), s.opaque !== void 0 && p.searchParams.set("opaque", s.opaque ? "1" : "0"), s.newUser !== void 0 && p.searchParams.set("new-user", s.newUser ? "1" : "0"), s.alliance !== void 0 && p.searchParams.set("alliance", s.alliance ? "1" : "0"), s.select && p.searchParams.set("alliance", "1"), p
}
var c_ = function() {
  return c_ = Object.assign || function(s) {
    for (var r, x = 1, z = arguments.length; x < z; x++) {
      r = arguments[x];
      for (var E in r) Object.prototype.hasOwnProperty.call(r, E) && (s[E] = r[E])
    }
    return s
  }, c_.apply(this, arguments)
};

function jo(p, s, r, x) {
  function z(E) {
    return E instanceof r ? E : new r(function(k) {
      k(E)
    })
  }
  return new(r || (r = Promise))(function(E, k) {
    function l(ee) {
      try {
        W(x.next(ee))
      } catch ($) {
        k($)
      }
    }

    function F(ee) {
      try {
        W(x.throw(ee))
      } catch ($) {
        k($)
      }
    }

    function W(ee) {
      ee.done ? E(ee.value) : z(ee.value).then(l, F)
    }
    W((x = x.apply(p, s || [])).next())
  })
}

function Fo(p, s) {
  var r = {
      label: 0,
      sent: function() {
        if (E[0] & 1) throw E[1];
        return E[1]
      },
      trys: [],
      ops: []
    },
    x, z, E, k = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return k.next = l(0), k.throw = l(1), k.return = l(2), typeof Symbol == "function" && (k[Symbol.iterator] = function() {
    return this
  }), k;

  function l(W) {
    return function(ee) {
      return F([W, ee])
    }
  }

  function F(W) {
    if (x) throw new TypeError("Generator is already executing.");
    for (; k && (k = 0, W[0] && (r = 0)), r;) try {
      if (x = 1, z && (E = W[0] & 2 ? z.return : W[0] ? z.throw || ((E = z.return) && E.call(z), 0) : z.next) && !(E = E.call(z, W[1])).done) return E;
      switch (z = 0, E && (W = [W[0] & 2, E.value]), W[0]) {
        case 0:
        case 1:
          E = W;
          break;
        case 4:
          return r.label++, {
            value: W[1],
            done: !1
          };
        case 5:
          r.label++, z = W[1], W = [0];
          continue;
        case 7:
          W = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (E = r.trys, !(E = E.length > 0 && E[E.length - 1]) && (W[0] === 6 || W[0] === 2)) {
            r = 0;
            continue
          }
          if (W[0] === 3 && (!E || W[1] > E[0] && W[1] < E[3])) {
            r.label = W[1];
            break
          }
          if (W[0] === 6 && r.label < E[1]) {
            r.label = E[1], E = W;
            break
          }
          if (E && r.label < E[2]) {
            r.label = E[2], r.ops.push(W);
            break
          }
          E[2] && r.ops.pop(), r.trys.pop();
          continue
      }
      W = s.call(p, r)
    } catch (ee) {
      W = [6, ee], z = 0
    } finally {
      x = E = 0
    }
    if (W[0] & 5) throw W[1];
    return {
      value: W[0] ? W[1] : void 0,
      done: !0
    }
  }
}

function D0(p, s, r) {
  if (r || arguments.length === 2)
    for (var x = 0, z = s.length, E; x < z; x++)(E || !(x in s)) && (E || (E = Array.prototype.slice.call(s, 0, x)), E[x] = s[x]);
  return p.concat(E || Array.prototype.slice.call(s))
}
var R0 = "4.6.2";

function xp(p, s) {
  return new Promise(function(r) {
    return setTimeout(r, p, s)
  })
}

function ode() {
  return new Promise(function(p) {
    var s = new MessageChannel;
    s.port1.onmessage = function() {
      return p()
    }, s.port2.postMessage(null)
  })
}

function sde(p, s) {
  s === void 0 && (s = 1 / 0);
  var r = window.requestIdleCallback;
  return r ? new Promise(function(x) {
    return r.call(window, function() {
      return x()
    }, {
      timeout: s
    })
  }) : xp(Math.min(p, s))
}

function j0(p) {
  return !!p && typeof p.then == "function"
}

function Pv(p, s) {
  try {
    var r = p();
    j0(r) ? r.then(function(x) {
      return s(!0, x)
    }, function(x) {
      return s(!1, x)
    }) : s(!0, r)
  } catch (x) {
    s(!1, x)
  }
}

function Mv(p, s, r) {
  return r === void 0 && (r = 16), jo(this, void 0, void 0, function() {
    var x, z, E, k;
    return Fo(this, function(l) {
      switch (l.label) {
        case 0:
          x = Array(p.length), z = Date.now(), E = 0, l.label = 1;
        case 1:
          return E < p.length ? (x[E] = s(p[E], E), k = Date.now(), k >= z + r ? (z = k, [4, ode()]) : [3, 3]) : [3, 4];
        case 2:
          l.sent(), l.label = 3;
        case 3:
          return ++E, [3, 1];
        case 4:
          return [2, x]
      }
    })
  })
}

function Ku(p) {
  return p.then(void 0, function() {}), p
}

function lde(p, s) {
  for (var r = 0, x = p.length; r < x; ++r)
    if (p[r] === s) return !0;
  return !1
}

function cde(p, s) {
  return !lde(p, s)
}

function am(p) {
  return parseInt(p)
}

function wo(p) {
  return parseFloat(p)
}

function ls(p, s) {
  return typeof p == "number" && isNaN(p) ? s : p
}

function Ea(p) {
  return p.reduce(function(s, r) {
    return s + (r ? 1 : 0)
  }, 0)
}

function F0(p, s) {
  if (s === void 0 && (s = 1), Math.abs(s) >= 1) return Math.round(p / s) * s;
  var r = 1 / s;
  return Math.round(p * r) / r
}

function ude(p) {
  for (var s, r, x = "Unexpected syntax '".concat(p, "'"), z = /^\s*([a-z-]*)(.*)$/i.exec(p), E = z[1] || void 0, k = {}, l = /([.:#][\w-]+|\[.+?\])/gi, F = function(se, _e) {
      k[se] = k[se] || [], k[se].push(_e)
    };;) {
    var W = l.exec(z[2]);
    if (!W) break;
    var ee = W[0];
    switch (ee[0]) {
      case ".":
        F("class", ee.slice(1));
        break;
      case "#":
        F("id", ee.slice(1));
        break;
      case "[": {
        var $ = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(ee);
        if ($) F($[1], (r = (s = $[4]) !== null && s !== void 0 ? s : $[5]) !== null && r !== void 0 ? r : "");
        else throw new Error(x);
        break
      }
      default:
        throw new Error(x)
    }
  }
  return [E, k]
}

function hde(p) {
  for (var s = new Uint8Array(p.length), r = 0; r < p.length; r++) {
    var x = p.charCodeAt(r);
    if (x > 127) return new TextEncoder().encode(p);
    s[r] = x
  }
  return s
}

function Rs(p, s) {
  var r = p[0] >>> 16,
    x = p[0] & 65535,
    z = p[1] >>> 16,
    E = p[1] & 65535,
    k = s[0] >>> 16,
    l = s[0] & 65535,
    F = s[1] >>> 16,
    W = s[1] & 65535,
    ee = 0,
    $ = 0,
    se = 0,
    _e = 0;
  _e += E + W, se += _e >>> 16, _e &= 65535, se += z + F, $ += se >>> 16, se &= 65535, $ += x + l, ee += $ >>> 16, $ &= 65535, ee += r + k, ee &= 65535, p[0] = ee << 16 | $, p[1] = se << 16 | _e
}

function ao(p, s) {
  var r = p[0] >>> 16,
    x = p[0] & 65535,
    z = p[1] >>> 16,
    E = p[1] & 65535,
    k = s[0] >>> 16,
    l = s[0] & 65535,
    F = s[1] >>> 16,
    W = s[1] & 65535,
    ee = 0,
    $ = 0,
    se = 0,
    _e = 0;
  _e += E * W, se += _e >>> 16, _e &= 65535, se += z * W, $ += se >>> 16, se &= 65535, se += E * F, $ += se >>> 16, se &= 65535, $ += x * W, ee += $ >>> 16, $ &= 65535, $ += z * F, ee += $ >>> 16, $ &= 65535, $ += E * l, ee += $ >>> 16, $ &= 65535, ee += r * W + x * F + z * l + E * k, ee &= 65535, p[0] = ee << 16 | $, p[1] = se << 16 | _e
}

function vc(p, s) {
  var r = p[0];
  s %= 64, s === 32 ? (p[0] = p[1], p[1] = r) : s < 32 ? (p[0] = r << s | p[1] >>> 32 - s, p[1] = p[1] << s | r >>> 32 - s) : (s -= 32, p[0] = p[1] << s | r >>> 32 - s, p[1] = r << s | p[1] >>> 32 - s)
}

function Ka(p, s) {
  s %= 64, s !== 0 && (s < 32 ? (p[0] = p[1] >>> 32 - s, p[1] = p[1] << s) : (p[0] = p[1] << s - 32, p[1] = 0))
}

function Ti(p, s) {
  p[0] ^= s[0], p[1] ^= s[1]
}
var dde = [4283543511, 3981806797],
  pde = [3301882366, 444984403];

function Iv(p) {
  var s = [0, p[0] >>> 1];
  Ti(p, s), ao(p, dde), s[1] = p[0] >>> 1, Ti(p, s), ao(p, pde), s[1] = p[0] >>> 1, Ti(p, s)
}
var Jd = [2277735313, 289559509],
  Qd = [1291169091, 658871167],
  Cv = [0, 5],
  fde = [0, 1390208809],
  _de = [0, 944331445];

function mde(p, s) {
  var r = hde(p);
  s = s || 0;
  var x = [0, r.length],
    z = x[1] % 16,
    E = x[1] - z,
    k = [0, s],
    l = [0, s],
    F = [0, 0],
    W = [0, 0],
    ee;
  for (ee = 0; ee < E; ee = ee + 16) F[0] = r[ee + 4] | r[ee + 5] << 8 | r[ee + 6] << 16 | r[ee + 7] << 24, F[1] = r[ee] | r[ee + 1] << 8 | r[ee + 2] << 16 | r[ee + 3] << 24, W[0] = r[ee + 12] | r[ee + 13] << 8 | r[ee + 14] << 16 | r[ee + 15] << 24, W[1] = r[ee + 8] | r[ee + 9] << 8 | r[ee + 10] << 16 | r[ee + 11] << 24, ao(F, Jd), vc(F, 31), ao(F, Qd), Ti(k, F), vc(k, 27), Rs(k, l), ao(k, Cv), Rs(k, fde), ao(W, Qd), vc(W, 33), ao(W, Jd), Ti(l, W), vc(l, 31), Rs(l, k), ao(l, Cv), Rs(l, _de);
  F[0] = 0, F[1] = 0, W[0] = 0, W[1] = 0;
  var $ = [0, 0];
  switch (z) {
    case 15:
      $[1] = r[ee + 14], Ka($, 48), Ti(W, $);
    case 14:
      $[1] = r[ee + 13], Ka($, 40), Ti(W, $);
    case 13:
      $[1] = r[ee + 12], Ka($, 32), Ti(W, $);
    case 12:
      $[1] = r[ee + 11], Ka($, 24), Ti(W, $);
    case 11:
      $[1] = r[ee + 10], Ka($, 16), Ti(W, $);
    case 10:
      $[1] = r[ee + 9], Ka($, 8), Ti(W, $);
    case 9:
      $[1] = r[ee + 8], Ti(W, $), ao(W, Qd), vc(W, 33), ao(W, Jd), Ti(l, W);
    case 8:
      $[1] = r[ee + 7], Ka($, 56), Ti(F, $);
    case 7:
      $[1] = r[ee + 6], Ka($, 48), Ti(F, $);
    case 6:
      $[1] = r[ee + 5], Ka($, 40), Ti(F, $);
    case 5:
      $[1] = r[ee + 4], Ka($, 32), Ti(F, $);
    case 4:
      $[1] = r[ee + 3], Ka($, 24), Ti(F, $);
    case 3:
      $[1] = r[ee + 2], Ka($, 16), Ti(F, $);
    case 2:
      $[1] = r[ee + 1], Ka($, 8), Ti(F, $);
    case 1:
      $[1] = r[ee], Ti(F, $), ao(F, Jd), vc(F, 31), ao(F, Qd), Ti(k, F)
  }
  return Ti(k, x), Ti(l, x), Rs(k, l), Rs(l, k), Iv(k), Iv(l), Rs(k, l), Rs(l, k), ("00000000" + (k[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (k[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (l[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (l[1] >>> 0).toString(16)).slice(-8)
}

function gde(p) {
  var s;
  return c_({
    name: p.name,
    message: p.message,
    stack: (s = p.stack) === null || s === void 0 ? void 0 : s.split(`
`)
  }, p)
}

function vde(p) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(p))
}

function yde(p) {
  return typeof p != "function"
}

function bde(p, s) {
  var r = Ku(new Promise(function(x) {
    var z = Date.now();
    Pv(p.bind(null, s), function() {
      for (var E = [], k = 0; k < arguments.length; k++) E[k] = arguments[k];
      var l = Date.now() - z;
      if (!E[0]) return x(function() {
        return {
          error: E[1],
          duration: l
        }
      });
      var F = E[1];
      if (yde(F)) return x(function() {
        return {
          value: F,
          duration: l
        }
      });
      x(function() {
        return new Promise(function(W) {
          var ee = Date.now();
          Pv(F, function() {
            for (var $ = [], se = 0; se < arguments.length; se++) $[se] = arguments[se];
            var _e = l + Date.now() - ee;
            if (!$[0]) return W({
              error: $[1],
              duration: _e
            });
            W({
              value: $[1],
              duration: _e
            })
          })
        })
      })
    })
  }));
  return function() {
    return r.then(function(z) {
      return z()
    })
  }
}

function xde(p, s, r, x) {
  var z = Object.keys(p).filter(function(k) {
      return cde(r, k)
    }),
    E = Ku(Mv(z, function(k) {
      return bde(p[k], s)
    }, x));
  return function() {
    return jo(this, void 0, void 0, function() {
      var l, F, W, ee, $;
      return Fo(this, function(se) {
        switch (se.label) {
          case 0:
            return [4, E];
          case 1:
            return l = se.sent(), [4, Mv(l, function(_e) {
              return Ku(_e())
            }, x)];
          case 2:
            return F = se.sent(), [4, Promise.all(F)];
          case 3:
            for (W = se.sent(), ee = {}, $ = 0; $ < z.length; ++$) ee[z[$]] = W[$];
            return [2, ee]
        }
      })
    })
  }
}

function B0() {
  var p = window,
    s = navigator;
  return Ea(["MSCSSMatrix" in p, "msSetImmediate" in p, "msIndexedDB" in p, "msMaxTouchPoints" in s, "msPointerEnabled" in s]) >= 4
}

function wde() {
  var p = window,
    s = navigator;
  return Ea(["msWriteProfilerMark" in p, "MSStream" in p, "msLaunchUri" in s, "msSaveBlob" in s]) >= 3 && !B0()
}

function zh() {
  var p = window,
    s = navigator;
  return Ea(["webkitPersistentStorage" in s, "webkitTemporaryStorage" in s, (s.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in p, "BatteryManager" in p, "webkitMediaStream" in p, "webkitSpeechGrammar" in p]) >= 5
}

function To() {
  var p = window,
    s = navigator;
  return Ea(["ApplePayError" in p, "CSSPrimitiveValue" in p, "Counter" in p, s.vendor.indexOf("Apple") === 0, "RGBColor" in p, "WebKitMediaKeys" in p]) >= 4
}

function om() {
  var p = window,
    s = p.HTMLElement,
    r = p.Document;
  return Ea(["safari" in p, !("ongestureend" in p), !("TouchEvent" in p), !("orientation" in p), s && !("autocapitalize" in s.prototype), r && "pointerLockElement" in r.prototype]) >= 4
}

function Ah() {
  var p = window;
  return vde(p.print) && String(p.browser) === "[object WebPageNamespace]"
}

function O0() {
  var p, s, r = window;
  return Ea(["buildID" in navigator, "MozAppearance" in ((s = (p = document.documentElement) === null || p === void 0 ? void 0 : p.style) !== null && s !== void 0 ? s : {}), "onmozfullscreenchange" in r, "mozInnerScreenX" in r, "CSSMozDocumentRule" in r, "CanvasCaptureMediaStream" in r]) >= 4
}

function kde() {
  var p = window;
  return Ea([!("MediaSettingsRange" in p), "RTCEncodedAudioFrame" in p, "" + p.Intl == "[object Intl]", "" + p.Reflect == "[object Reflect]"]) >= 3
}

function Tde() {
  var p = window,
    s = p.URLPattern;
  return Ea(["union" in Set.prototype, "Iterator" in p, s && "hasRegExpGroups" in s.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function Sde() {
  var p = window;
  return Ea(["DOMRectList" in p, "RTCPeerConnectionIceEvent" in p, "SVGGeometryElement" in p, "ontransitioncancel" in p]) >= 3
}

function Eh() {
  var p = window,
    s = navigator,
    r = p.CSS,
    x = p.HTMLButtonElement;
  return Ea([!("getStorageUpdates" in s), x && "popover" in x.prototype, "CSSCounterStyleRule" in p, r.supports("font-size-adjust: ex-height 0.5"), r.supports("text-transform: full-width")]) >= 4
}

function Pde() {
  if (navigator.platform === "iPad") return !0;
  var p = screen,
    s = p.width / p.height;
  return Ea(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, s > .65 && s < 1.53]) >= 2
}

function Mde() {
  var p = document;
  return p.fullscreenElement || p.msFullscreenElement || p.mozFullScreenElement || p.webkitFullscreenElement || null
}

function Ide() {
  var p = document;
  return (p.exitFullscreen || p.msExitFullscreen || p.mozCancelFullScreen || p.webkitExitFullscreen).call(p)
}

function sm() {
  var p = zh(),
    s = O0(),
    r = window,
    x = navigator,
    z = "connection";
  return p ? Ea([!("SharedWorker" in r), x[z] && "ontypechange" in x[z], !("sinkId" in new Audio)]) >= 2 : s ? Ea(["onorientationchange" in r, "orientation" in r, /android/i.test(x.appVersion)]) >= 2 : !1
}

function Cde() {
  var p = navigator,
    s = window,
    r = Audio.prototype,
    x = s.visualViewport;
  return Ea(["srLatency" in r, "srChannelCount" in r, "devicePosture" in p, x && "segments" in x, "getTextInformation" in Image.prototype]) >= 3
}

function zde() {
  return Lde() ? -4 : Ade()
}

function Ade() {
  var p = window,
    s = p.OfflineAudioContext || p.webkitOfflineAudioContext;
  if (!s) return -2;
  if (Ede()) return -1;
  var r = 4500,
    x = 5e3,
    z = new s(1, x, 44100),
    E = z.createOscillator();
  E.type = "triangle", E.frequency.value = 1e4;
  var k = z.createDynamicsCompressor();
  k.threshold.value = -50, k.knee.value = 40, k.ratio.value = 12, k.attack.value = 0, k.release.value = .25, E.connect(k), k.connect(z.destination), E.start(0);
  var l = Dde(z),
    F = l[0],
    W = l[1],
    ee = Ku(F.then(function($) {
      return Rde($.getChannelData(0).subarray(r))
    }, function($) {
      if ($.name === "timeout" || $.name === "suspended") return -3;
      throw $
    }));
  return function() {
    return W(), ee
  }
}

function Ede() {
  return To() && !om() && !Sde()
}

function Lde() {
  return To() && Eh() && Ah() || zh() && Cde() && Tde()
}

function Dde(p) {
  var s = 3,
    r = 500,
    x = 500,
    z = 5e3,
    E = function() {},
    k = new Promise(function(l, F) {
      var W = !1,
        ee = 0,
        $ = 0;
      p.oncomplete = function(ge) {
        return l(ge.renderedBuffer)
      };
      var se = function() {
          setTimeout(function() {
            return F(zv("timeout"))
          }, Math.min(x, $ + z - Date.now()))
        },
        _e = function() {
          try {
            var ge = p.startRendering();
            switch (j0(ge) && Ku(ge), p.state) {
              case "running":
                $ = Date.now(), W && se();
                break;
              case "suspended":
                document.hidden || ee++, W && ee >= s ? F(zv("suspended")) : setTimeout(_e, r);
                break
            }
          } catch (V) {
            F(V)
          }
        };
      _e(), E = function() {
        W || (W = !0, $ > 0 && se())
      }
    });
  return [k, E]
}

function Rde(p) {
  for (var s = 0, r = 0; r < p.length; ++r) s += Math.abs(p[r]);
  return s
}

function zv(p) {
  var s = new Error(p);
  return s.name = p, s
}

function q0(p, s, r) {
  var x, z, E;
  return r === void 0 && (r = 50), jo(this, void 0, void 0, function() {
    var k, l;
    return Fo(this, function(F) {
      switch (F.label) {
        case 0:
          k = document, F.label = 1;
        case 1:
          return k.body ? [3, 3] : [4, xp(r)];
        case 2:
          return F.sent(), [3, 1];
        case 3:
          l = k.createElement("iframe"), F.label = 4;
        case 4:
          return F.trys.push([4, , 10, 11]), [4, new Promise(function(W, ee) {
            var $ = !1,
              se = function() {
                $ = !0, W()
              },
              _e = function(Me) {
                $ = !0, ee(Me)
              };
            l.onload = se, l.onerror = _e;
            var ge = l.style;
            ge.setProperty("display", "block", "important"), ge.position = "absolute", ge.top = "0", ge.left = "0", ge.visibility = "hidden", s && "srcdoc" in l ? l.srcdoc = s : l.src = "about:blank", k.body.appendChild(l);
            var V = function() {
              var Me, we;
              $ || (((we = (Me = l.contentWindow) === null || Me === void 0 ? void 0 : Me.document) === null || we === void 0 ? void 0 : we.readyState) === "complete" ? se() : setTimeout(V, 10))
            };
            V()
          })];
        case 5:
          F.sent(), F.label = 6;
        case 6:
          return !((z = (x = l.contentWindow) === null || x === void 0 ? void 0 : x.document) === null || z === void 0) && z.body ? [3, 8] : [4, xp(r)];
        case 7:
          return F.sent(), [3, 6];
        case 8:
          return [4, p(l, l.contentWindow)];
        case 9:
          return [2, F.sent()];
        case 10:
          return (E = l.parentNode) === null || E === void 0 || E.removeChild(l), [7];
        case 11:
          return [2]
      }
    })
  })
}

function jde(p) {
  for (var s = ude(p), r = s[0], x = s[1], z = document.createElement(r ?? "div"), E = 0, k = Object.keys(x); E < k.length; E++) {
    var l = k[E],
      F = x[l].join(" ");
    l === "style" ? Fde(z.style, F) : z.setAttribute(l, F)
  }
  return z
}

function Fde(p, s) {
  for (var r = 0, x = s.split(";"); r < x.length; r++) {
    var z = x[r],
      E = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(z);
    if (E) {
      var k = E[1],
        l = E[2],
        F = E[4];
      p.setProperty(k, l, F || "")
    }
  }
}

function Bde() {
  for (var p = window;;) {
    var s = p.parent;
    if (!s || s === p) return !1;
    try {
      if (s.location.origin !== p.location.origin) return !0
    } catch (r) {
      if (r instanceof Error && r.name === "SecurityError") return !0;
      throw r
    }
    p = s
  }
}
var Ode = "mmMwWLliI0O&1",
  qde = "48px",
  yc = ["monospace", "sans-serif", "serif"],
  Av = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function Nde() {
  var p = this;
  return q0(function(s, r) {
    var x = r.document;
    return jo(p, void 0, void 0, function() {
      var z, E, k, l, F, W, ee, $, se, _e, ge, V;
      return Fo(this, function(Me) {
        for (z = x.body, z.style.fontSize = qde, E = x.createElement("div"), E.style.setProperty("visibility", "hidden", "important"), k = {}, l = {}, F = function(we) {
            var Fe = x.createElement("span"),
              be = Fe.style;
            return be.position = "absolute", be.top = "0", be.left = "0", be.fontFamily = we, Fe.textContent = Ode, E.appendChild(Fe), Fe
          }, W = function(we, Fe) {
            return F("'".concat(we, "',").concat(Fe))
          }, ee = function() {
            return yc.map(F)
          }, $ = function() {
            for (var we = {}, Fe = function(Ye) {
                we[Ye] = yc.map(function(Ce) {
                  return W(Ye, Ce)
                })
              }, be = 0, Xe = Av; be < Xe.length; be++) {
              var tt = Xe[be];
              Fe(tt)
            }
            return we
          }, se = function(we) {
            return yc.some(function(Fe, be) {
              return we[be].offsetWidth !== k[Fe] || we[be].offsetHeight !== l[Fe]
            })
          }, _e = ee(), ge = $(), z.appendChild(E), V = 0; V < yc.length; V++) k[yc[V]] = _e[V].offsetWidth, l[yc[V]] = _e[V].offsetHeight;
        return [2, Av.filter(function(we) {
          return se(ge[we])
        })]
      })
    })
  })
}

function Vde() {
  var p = navigator.plugins;
  if (p) {
    for (var s = [], r = 0; r < p.length; ++r) {
      var x = p[r];
      if (x) {
        for (var z = [], E = 0; E < x.length; ++E) {
          var k = x[E];
          z.push({
            type: k.type,
            suffixes: k.suffixes
          })
        }
        s.push({
          name: x.name,
          description: x.description,
          mimeTypes: z
        })
      }
    }
    return s
  }
}

function Ude() {
  return Zde(Kde())
}

function Zde(p) {
  var s, r = !1,
    x, z, E = Gde(),
    k = E[0],
    l = E[1];
  return Wde(k, l) ? (r = Hde(l), p ? x = z = "skipped" : (s = $de(k, l), x = s[0], z = s[1])) : x = z = "unsupported", {
    winding: r,
    geometry: x,
    text: z
  }
}

function Gde() {
  var p = document.createElement("canvas");
  return p.width = 1, p.height = 1, [p, p.getContext("2d")]
}

function Wde(p, s) {
  return !!(s && p.toDataURL)
}

function Hde(p) {
  return p.rect(0, 0, 10, 10), p.rect(2, 2, 6, 6), !p.isPointInPath(5, 5, "evenodd")
}

function $de(p, s) {
  Xde(p, s);
  var r = Wf(p),
    x = Wf(p);
  if (r !== x) return ["unstable", "unstable"];
  Yde(p, s);
  var z = Wf(p);
  return [z, r]
}

function Xde(p, s) {
  p.width = 240, p.height = 60, s.textBaseline = "alphabetic", s.fillStyle = "#f60", s.fillRect(100, 1, 62, 20), s.fillStyle = "#069", s.font = '11pt "Times New Roman"';
  var r = "Cwm fjordbank gly ".concat("ðŸ˜ƒ");
  s.fillText(r, 2, 15), s.fillStyle = "rgba(102, 204, 0, 0.2)", s.font = "18pt Arial", s.fillText(r, 4, 45)
}

function Yde(p, s) {
  p.width = 122, p.height = 110, s.globalCompositeOperation = "multiply";
  for (var r = 0, x = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; r < x.length; r++) {
    var z = x[r],
      E = z[0],
      k = z[1],
      l = z[2];
    s.fillStyle = E, s.beginPath(), s.arc(k, l, 40, 0, Math.PI * 2, !0), s.closePath(), s.fill()
  }
  s.fillStyle = "#f9c", s.arc(60, 60, 60, 0, Math.PI * 2, !0), s.arc(60, 60, 20, 0, Math.PI * 2, !0), s.fill("evenodd")
}

function Wf(p) {
  return p.toDataURL()
}

function Kde() {
  return To() && Eh() && Ah()
}

function Jde() {
  var p = navigator,
    s = 0,
    r;
  p.maxTouchPoints !== void 0 ? s = am(p.maxTouchPoints) : p.msMaxTouchPoints !== void 0 && (s = p.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), r = !0
  } catch {
    r = !1
  }
  var x = "ontouchstart" in window;
  return {
    maxTouchPoints: s,
    touchEvent: r,
    touchStart: x
  }
}

function Qde() {
  return navigator.oscpu
}

function epe() {
  var p = navigator,
    s = [],
    r = p.language || p.userLanguage || p.browserLanguage || p.systemLanguage;
  if (r !== void 0 && s.push([r]), Array.isArray(p.languages)) zh() && kde() || s.push(p.languages);
  else if (typeof p.languages == "string") {
    var x = p.languages;
    x && s.push(x.split(","))
  }
  return s
}

function tpe() {
  return window.screen.colorDepth
}

function rpe() {
  return ls(wo(navigator.deviceMemory), void 0)
}

function npe() {
  if (!(To() && Eh() && Ah())) return ipe()
}

function ipe() {
  var p = screen,
    s = function(x) {
      return ls(am(x), null)
    },
    r = [s(p.width), s(p.height)];
  return r.sort().reverse(), r
}
var ape = 2500,
  ope = 10,
  lp, Hf;

function spe() {
  if (Hf === void 0) {
    var p = function() {
      var s = u_();
      h_(s) ? Hf = setTimeout(p, ape) : (lp = s, Hf = void 0)
    };
    p()
  }
}

function lpe() {
  var p = this;
  return spe(),
    function() {
      return jo(p, void 0, void 0, function() {
        var s;
        return Fo(this, function(r) {
          switch (r.label) {
            case 0:
              return s = u_(), h_(s) ? lp ? [2, D0([], lp, !0)] : Mde() ? [4, Ide()] : [3, 2] : [3, 2];
            case 1:
              r.sent(), s = u_(), r.label = 2;
            case 2:
              return h_(s) || (lp = s), [2, s]
          }
        })
      })
    }
}

function cpe() {
  var p = this;
  if (To() && Eh() && Ah()) return function() {
    return Promise.resolve(void 0)
  };
  var s = lpe();
  return function() {
    return jo(p, void 0, void 0, function() {
      var r, x;
      return Fo(this, function(z) {
        switch (z.label) {
          case 0:
            return [4, s()];
          case 1:
            return r = z.sent(), x = function(E) {
              return E === null ? null : F0(E, ope)
            }, [2, [x(r[0]), x(r[1]), x(r[2]), x(r[3])]]
        }
      })
    })
  }
}

function u_() {
  var p = screen;
  return [ls(wo(p.availTop), null), ls(wo(p.width) - wo(p.availWidth) - ls(wo(p.availLeft), 0), null), ls(wo(p.height) - wo(p.availHeight) - ls(wo(p.availTop), 0), null), ls(wo(p.availLeft), null)]
}

function h_(p) {
  for (var s = 0; s < 4; ++s)
    if (p[s]) return !1;
  return !0
}

function upe() {
  return ls(am(navigator.hardwareConcurrency), void 0)
}

function hpe() {
  var p, s = (p = window.Intl) === null || p === void 0 ? void 0 : p.DateTimeFormat;
  if (s) {
    var r = new s().resolvedOptions().timeZone;
    if (r) return r
  }
  var x = -dpe();
  return "UTC".concat(x >= 0 ? "+" : "").concat(x)
}

function dpe() {
  var p = new Date().getFullYear();
  return Math.max(wo(new Date(p, 0, 1).getTimezoneOffset()), wo(new Date(p, 6, 1).getTimezoneOffset()))
}

function ppe() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function fpe() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function _pe() {
  if (!(B0() || wde())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function mpe() {
  return !!window.openDatabase
}

function gpe() {
  return navigator.cpuClass
}

function vpe() {
  var p = navigator.platform;
  return p === "MacIntel" && To() && !om() ? Pde() ? "iPad" : "iPhone" : p
}

function ype() {
  return navigator.vendor || ""
}

function bpe() {
  for (var p = [], s = 0, r = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; s < r.length; s++) {
    var x = r[s],
      z = window[x];
    z && typeof z == "object" && p.push(x)
  }
  return p.sort()
}

function xpe() {
  var p = document;
  try {
    p.cookie = "cookietest=1; SameSite=Strict;";
    var s = p.cookie.indexOf("cookietest=") !== -1;
    return p.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", s
  } catch {
    return !1
  }
}

function wpe() {
  var p = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', p("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", p("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", p("LnNwb25zb3JpdA=="), ".ylamainos", p("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), p("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", p("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", p("LmhlYWRlci1ibG9ja2VkLWFk"), p("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", p("I2FkXzMwMFgyNTA="), p("I2Jhbm5lcmZsb2F0MjI="), p("I2NhbXBhaWduLWJhbm5lcg=="), p("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [p("LlppX2FkX2FfSA=="), p("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", p("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), p("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", p("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", p("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", p("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), p("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), p("LmFkZ29vZ2xl"), p("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [p("YW1wLWF1dG8tYWRz"), p("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", p("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [p("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), p("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', p("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [p("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), p("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", p("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), p("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), p("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", p("I3Jla2xhbWk="), p("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), p("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), p("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [p("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", p("LndpZGdldF9wb19hZHNfd2lkZ2V0"), p("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", p("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [p("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), p("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", p("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", p("I3Jla2xhbW5pLWJveA=="), p("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", p("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [p("I2FkdmVydGVudGll"), p("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", p("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", p("LnNwb25zb3JsaW5rZ3J1ZW4="), p("I3dlcmJ1bmdza3k="), p("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), p("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [p("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", p("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), p("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), p("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [p("LnJla2xhbW9zX3RhcnBhcw=="), p("LnJla2xhbW9zX251b3JvZG9z"), p("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), p("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), p("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [p("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [p("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), p("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", p("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [p("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), p("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), p("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", p("LmFkX19tYWlu"), p("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [p("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [p("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), p("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [p("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), p("I2xpdmVyZUFkV3JhcHBlcg=="), p("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), p("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [p("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", p("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), p("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), p("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [p("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), p("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), p("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", p("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), p("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), p("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), p("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [p("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), p("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), p("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), p("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [p("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), p("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), p("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", p("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), p("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", p("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function kpe(p) {
  var s = p === void 0 ? {} : p,
    r = s.debug;
  return jo(this, void 0, void 0, function() {
    var x, z, E, k, l, F;
    return Fo(this, function(W) {
      switch (W.label) {
        case 0:
          return Tpe() ? (x = wpe(), z = Object.keys(x), E = (F = []).concat.apply(F, z.map(function(ee) {
            return x[ee]
          })), [4, Spe(E)]) : [2, void 0];
        case 1:
          return k = W.sent(), r && Ppe(x, k), l = z.filter(function(ee) {
            var $ = x[ee],
              se = Ea($.map(function(_e) {
                return k[_e]
              }));
            return se > $.length * .6
          }), l.sort(), [2, l]
      }
    })
  })
}

function Tpe() {
  return To() || sm()
}

function Spe(p) {
  var s;
  return jo(this, void 0, void 0, function() {
    var r, x, z, E, F, k, l, F;
    return Fo(this, function(W) {
      switch (W.label) {
        case 0:
          for (r = document, x = r.createElement("div"), z = new Array(p.length), E = {}, Ev(x), F = 0; F < p.length; ++F) k = jde(p[F]), k.tagName === "DIALOG" && k.show(), l = r.createElement("div"), Ev(l), l.appendChild(k), x.appendChild(l), z[F] = k;
          W.label = 1;
        case 1:
          return r.body ? [3, 3] : [4, xp(50)];
        case 2:
          return W.sent(), [3, 1];
        case 3:
          r.body.appendChild(x);
          try {
            for (F = 0; F < p.length; ++F) z[F].offsetParent || (E[p[F]] = !0)
          } finally {
            (s = x.parentNode) === null || s === void 0 || s.removeChild(x)
          }
          return [2, E]
      }
    })
  })
}

function Ev(p) {
  p.style.setProperty("visibility", "hidden", "important"), p.style.setProperty("display", "block", "important")
}

function Ppe(p, s) {
  for (var r = "DOM blockers debug:\n```", x = 0, z = Object.keys(p); x < z.length; x++) {
    var E = z[x];
    r += `
`.concat(E, ":");
    for (var k = 0, l = p[E]; k < l.length; k++) {
      var F = l[k];
      r += `
  `.concat(s[F] ? "ðŸš«" : "âž¡ï¸", " ").concat(F)
    }
  }
  console.log("".concat(r, "\n```"))
}

function Mpe() {
  for (var p = 0, s = ["rec2020", "p3", "srgb"]; p < s.length; p++) {
    var r = s[p];
    if (matchMedia("(color-gamut: ".concat(r, ")")).matches) return r
  }
}

function Ipe() {
  if (Lv("inverted")) return !0;
  if (Lv("none")) return !1
}

function Lv(p) {
  return matchMedia("(inverted-colors: ".concat(p, ")")).matches
}

function Cpe() {
  if (Dv("active")) return !0;
  if (Dv("none")) return !1
}

function Dv(p) {
  return matchMedia("(forced-colors: ".concat(p, ")")).matches
}
var zpe = 100;

function Ape() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var p = 0; p <= zpe; ++p)
      if (matchMedia("(max-monochrome: ".concat(p, ")")).matches) return p;
    throw new Error("Too high value")
  }
}

function Epe() {
  if (bc("no-preference")) return 0;
  if (bc("high") || bc("more")) return 1;
  if (bc("low") || bc("less")) return -1;
  if (bc("forced")) return 10
}

function bc(p) {
  return matchMedia("(prefers-contrast: ".concat(p, ")")).matches
}

function Lpe() {
  if (Rv("reduce")) return !0;
  if (Rv("no-preference")) return !1
}

function Rv(p) {
  return matchMedia("(prefers-reduced-motion: ".concat(p, ")")).matches
}

function Dpe() {
  if (jv("reduce")) return !0;
  if (jv("no-preference")) return !1
}

function jv(p) {
  return matchMedia("(prefers-reduced-transparency: ".concat(p, ")")).matches
}

function Rpe() {
  if (Fv("high")) return !0;
  if (Fv("standard")) return !1
}

function Fv(p) {
  return matchMedia("(dynamic-range: ".concat(p, ")")).matches
}
var ri = Math,
  Ia = function() {
    return 0
  };

function jpe() {
  var p = ri.acos || Ia,
    s = ri.acosh || Ia,
    r = ri.asin || Ia,
    x = ri.asinh || Ia,
    z = ri.atanh || Ia,
    E = ri.atan || Ia,
    k = ri.sin || Ia,
    l = ri.sinh || Ia,
    F = ri.cos || Ia,
    W = ri.cosh || Ia,
    ee = ri.tan || Ia,
    $ = ri.tanh || Ia,
    se = ri.exp || Ia,
    _e = ri.expm1 || Ia,
    ge = ri.log1p || Ia,
    V = function(De) {
      return ri.pow(ri.PI, De)
    },
    Me = function(De) {
      return ri.log(De + ri.sqrt(De * De - 1))
    },
    we = function(De) {
      return ri.log(De + ri.sqrt(De * De + 1))
    },
    Fe = function(De) {
      return ri.log((1 + De) / (1 - De)) / 2
    },
    be = function(De) {
      return ri.exp(De) - 1 / ri.exp(De) / 2
    },
    Xe = function(De) {
      return (ri.exp(De) + 1 / ri.exp(De)) / 2
    },
    tt = function(De) {
      return ri.exp(De) - 1
    },
    Ye = function(De) {
      return (ri.exp(2 * De) - 1) / (ri.exp(2 * De) + 1)
    },
    Ce = function(De) {
      return ri.log(1 + De)
    };
  return {
    acos: p(.12312423423423424),
    acosh: s(1e308),
    acoshPf: Me(1e154),
    asin: r(.12312423423423424),
    asinh: x(1),
    asinhPf: we(1),
    atanh: z(.5),
    atanhPf: Fe(.5),
    atan: E(.5),
    sin: k(-1e300),
    sinh: l(1),
    sinhPf: be(1),
    cos: F(10.000000000123),
    cosh: W(1),
    coshPf: Xe(1),
    tan: ee(-1e300),
    tanh: $(1),
    tanhPf: Ye(1),
    exp: se(1),
    expm1: _e(1),
    expm1Pf: tt(1),
    log1p: ge(10),
    log1pPf: Ce(10),
    powPI: V(-100)
  }
}
var Fpe = "mmMwWLliI0fiflO&1",
  $f = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function Bpe() {
  return Ope(function(p, s) {
    for (var r = {}, x = {}, z = 0, E = Object.keys($f); z < E.length; z++) {
      var k = E[z],
        l = $f[k],
        F = l[0],
        W = F === void 0 ? {} : F,
        ee = l[1],
        $ = ee === void 0 ? Fpe : ee,
        se = p.createElement("span");
      se.textContent = $, se.style.whiteSpace = "nowrap";
      for (var _e = 0, ge = Object.keys(W); _e < ge.length; _e++) {
        var V = ge[_e],
          Me = W[V];
        Me !== void 0 && (se.style[V] = Me)
      }
      r[k] = se, s.append(p.createElement("br"), se)
    }
    for (var we = 0, Fe = Object.keys($f); we < Fe.length; we++) {
      var k = Fe[we];
      x[k] = r[k].getBoundingClientRect().width
    }
    return x
  })
}

function Ope(p, s) {
  return s === void 0 && (s = 4e3), q0(function(r, x) {
    var z = x.document,
      E = z.body,
      k = E.style;
    k.width = "".concat(s, "px"), k.webkitTextSizeAdjust = k.textSizeAdjust = "none", zh() ? E.style.zoom = "".concat(1 / x.devicePixelRatio) : To() && (E.style.zoom = "reset");
    var l = z.createElement("div");
    return l.textContent = D0([], Array(s / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), E.appendChild(l), p(z, E)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function qpe() {
  return navigator.pdfViewerEnabled
}

function Npe() {
  var p = new Float32Array(1),
    s = new Uint8Array(p.buffer);
  return p[0] = 1 / 0, p[0] = p[0] - p[0], s[3]
}

function Vpe() {
  var p = window.ApplePaySession;
  if (typeof(p == null ? void 0 : p.canMakePayments) != "function") return -1;
  if (Upe()) return -3;
  try {
    return p.canMakePayments() ? 1 : 0
  } catch (s) {
    return Zpe(s)
  }
}
var Upe = Bde;

function Zpe(p) {
  if (p instanceof Error && p.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(p.message)) return -2;
  throw p
}

function Gpe() {
  var p, s = document.createElement("a"),
    r = (p = s.attributionSourceId) !== null && p !== void 0 ? p : s.attributionsourceid;
  return r === void 0 ? void 0 : String(r)
}
var N0 = -1,
  V0 = -2,
  Wpe = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  Hpe = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  $pe = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  Xpe = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  U0 = "WEBGL_debug_renderer_info",
  Ype = "WEBGL_polygon_mode";

function Kpe(p) {
  var s, r, x, z, E, k, l = p.cache,
    F = Z0(l);
  if (!F) return N0;
  if (!W0(F)) return V0;
  var W = G0() ? null : F.getExtension(U0);
  return {
    version: ((s = F.getParameter(F.VERSION)) === null || s === void 0 ? void 0 : s.toString()) || "",
    vendor: ((r = F.getParameter(F.VENDOR)) === null || r === void 0 ? void 0 : r.toString()) || "",
    vendorUnmasked: W ? (x = F.getParameter(W.UNMASKED_VENDOR_WEBGL)) === null || x === void 0 ? void 0 : x.toString() : "",
    renderer: ((z = F.getParameter(F.RENDERER)) === null || z === void 0 ? void 0 : z.toString()) || "",
    rendererUnmasked: W ? (E = F.getParameter(W.UNMASKED_RENDERER_WEBGL)) === null || E === void 0 ? void 0 : E.toString() : "",
    shadingLanguageVersion: ((k = F.getParameter(F.SHADING_LANGUAGE_VERSION)) === null || k === void 0 ? void 0 : k.toString()) || ""
  }
}

function Jpe(p) {
  var s = p.cache,
    r = Z0(s);
  if (!r) return N0;
  if (!W0(r)) return V0;
  var x = r.getSupportedExtensions(),
    z = r.getContextAttributes(),
    E = [],
    k = [],
    l = [],
    F = [],
    W = [];
  if (z)
    for (var ee = 0, $ = Object.keys(z); ee < $.length; ee++) {
      var se = $[ee];
      k.push("".concat(se, "=").concat(z[se]))
    }
  for (var _e = Bv(r), ge = 0, V = _e; ge < V.length; ge++) {
    var Me = V[ge],
      we = r[Me];
    l.push("".concat(Me, "=").concat(we).concat(Wpe.has(we) ? "=".concat(r.getParameter(we)) : ""))
  }
  if (x)
    for (var Fe = 0, be = x; Fe < be.length; Fe++) {
      var Xe = be[Fe];
      if (!(Xe === U0 && G0() || Xe === Ype && tfe())) {
        var tt = r.getExtension(Xe);
        if (!tt) {
          E.push(Xe);
          continue
        }
        for (var Ye = 0, Ce = Bv(tt); Ye < Ce.length; Ye++) {
          var Me = Ce[Ye],
            we = tt[Me];
          F.push("".concat(Me, "=").concat(we).concat(Hpe.has(we) ? "=".concat(r.getParameter(we)) : ""))
        }
      }
    }
  for (var De = 0, Ke = $pe; De < Ke.length; De++)
    for (var Le = Ke[De], Ne = 0, vt = Xpe; Ne < vt.length; Ne++) {
      var et = vt[Ne],
        We = Qpe(r, Le, et);
      W.push("".concat(Le, ".").concat(et, "=").concat(We.join(",")))
    }
  return F.sort(), l.sort(), {
    contextAttributes: k,
    parameters: l,
    shaderPrecisions: W,
    extensions: x,
    extensionParameters: F,
    unsupportedExtensions: E
  }
}

function Z0(p) {
  if (p.webgl) return p.webgl.context;
  var s = document.createElement("canvas"),
    r;
  s.addEventListener("webglCreateContextError", function() {
    return r = void 0
  });
  for (var x = 0, z = ["webgl", "experimental-webgl"]; x < z.length; x++) {
    var E = z[x];
    try {
      r = s.getContext(E)
    } catch {}
    if (r) break
  }
  return p.webgl = {
    context: r
  }, r
}

function Qpe(p, s, r) {
  var x = p.getShaderPrecisionFormat(p[s], p[r]);
  return x ? [x.rangeMin, x.rangeMax, x.precision] : []
}

function Bv(p) {
  var s = Object.keys(p.__proto__);
  return s.filter(efe)
}

function efe(p) {
  return typeof p == "string" && !p.match(/[^A-Z0-9_x]/)
}

function G0() {
  return O0()
}

function tfe() {
  return zh() || To()
}

function W0(p) {
  return typeof p.getParameter == "function"
}

function rfe() {
  var p = sm() || To();
  if (!p) return -2;
  if (!window.AudioContext) return -1;
  var s = new AudioContext().baseLatency;
  return s == null ? -1 : isFinite(s) ? s : -3
}

function nfe() {
  if (!window.Intl) return -1;
  var p = window.Intl.DateTimeFormat;
  if (!p) return -2;
  var s = p().resolvedOptions().locale;
  return !s && s !== "" ? -3 : s
}
var ife = {
  fonts: Nde,
  domBlockers: kpe,
  fontPreferences: Bpe,
  audio: zde,
  screenFrame: cpe,
  canvas: Ude,
  osCpu: Qde,
  languages: epe,
  colorDepth: tpe,
  deviceMemory: rpe,
  screenResolution: npe,
  hardwareConcurrency: upe,
  timezone: hpe,
  sessionStorage: ppe,
  localStorage: fpe,
  indexedDB: _pe,
  openDatabase: mpe,
  cpuClass: gpe,
  platform: vpe,
  plugins: Vde,
  touchSupport: Jde,
  vendor: ype,
  vendorFlavors: bpe,
  cookiesEnabled: xpe,
  colorGamut: Mpe,
  invertedColors: Ipe,
  forcedColors: Cpe,
  monochrome: Ape,
  contrast: Epe,
  reducedMotion: Lpe,
  reducedTransparency: Dpe,
  hdr: Rpe,
  math: jpe,
  pdfViewerEnabled: qpe,
  architecture: Npe,
  applePay: Vpe,
  privateClickMeasurement: Gpe,
  audioBaseLatency: rfe,
  dateTimeLocale: nfe,
  webGlBasics: Kpe,
  webGlExtensions: Jpe
};

function afe(p) {
  return xde(ife, p, [])
}
var ofe = "$ if upgrade to Pro: https://fpjs.dev/pro";

function sfe(p) {
  var s = lfe(p),
    r = cfe(s);
  return {
    score: s,
    comment: ofe.replace(/\$/g, "".concat(r))
  }
}

function lfe(p) {
  if (sm()) return .4;
  if (To()) return om() && !(Eh() && Ah()) ? .5 : .3;
  var s = "value" in p.platform ? p.platform.value : "";
  return /^Win/.test(s) ? .6 : /^Mac/.test(s) ? .5 : .7
}

function cfe(p) {
  return F0(.99 + .01 * p, 1e-4)
}

function ufe(p) {
  for (var s = "", r = 0, x = Object.keys(p).sort(); r < x.length; r++) {
    var z = x[r],
      E = p[z],
      k = "error" in E ? "error" : JSON.stringify(E.value);
    s += "".concat(s ? "|" : "").concat(z.replace(/([:|\\])/g, "\\$1"), ":").concat(k)
  }
  return s
}

function H0(p) {
  return JSON.stringify(p, function(s, r) {
    return r instanceof Error ? gde(r) : r
  }, 2)
}

function $0(p) {
  return mde(ufe(p))
}

function hfe(p) {
  var s, r = sfe(p);
  return {
    get visitorId() {
      return s === void 0 && (s = $0(this.components)), s
    },
    set visitorId(x) {
      s = x
    },
    confidence: r,
    components: p,
    version: R0
  }
}

function dfe(p) {
  return p === void 0 && (p = 50), sde(p, p * 2)
}

function pfe(p, s) {
  var r = Date.now();
  return {
    get: function(x) {
      return jo(this, void 0, void 0, function() {
        var z, E, k;
        return Fo(this, function(l) {
          switch (l.label) {
            case 0:
              return z = Date.now(), [4, p()];
            case 1:
              return E = l.sent(), k = hfe(E), (s || x != null && x.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(k.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(z - r, `
visitorId: `).concat(k.visitorId, `
components: `).concat(H0(E), "\n```")), [2, k]
          }
        })
      })
    }
  }
}

function ffe() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var p = new XMLHttpRequest;
    p.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(R0, "/npm-monitoring"), !0), p.send()
  } catch (s) {
    console.error(s)
  }
}

function _fe(p) {
  var s;
  return p === void 0 && (p = {}), jo(this, void 0, void 0, function() {
    var r, x, z;
    return Fo(this, function(E) {
      switch (E.label) {
        case 0:
          return (!((s = p.monitoring) !== null && s !== void 0) || s) && ffe(), r = p.delayFallback, x = p.debug, [4, dfe(r)];
        case 1:
          return E.sent(), z = afe({
            cache: {},
            debug: x
          }), [2, pfe(z, x)]
      }
    })
  })
}
var X0 = {
  load: _fe,
  hashComponents: $0,
  componentsToDebugString: H0
};
let Xf = null,
  wp;
async function mfe() {
  return Xf || (Xf = X0.load()), Xf
}
async function lm() {
  return wp || gfe().then(p => p.visitorId)
}
async function gfe() {
  const s = await (await mfe()).get(),
    {
      languages: r,
      dateTimeLocale: x,
      ...z
    } = s.components;
  return wp = X0.hashComponents(z), {
    visitorId: wp,
    components: z
  }
}
var vfe = Yr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function bl(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = vfe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}

function cp(p) {
  const s = document.createElement("img");
  return s.src = p, new Promise((r, x) => {
    s.addEventListener("load", () => {
      r(s)
    }), s.addEventListener("error", z => {
      x(z)
    })
  })
}

function Y0(p) {
  const s = document.createElement("canvas");
  s.width = p.naturalWidth, s.height = p.naturalHeight;
  const r = s.getContext("2d");
  return r == null || r.drawImage(p, 0, 0), s
}
var yfe = he('<button type="button"></button>'),
  bfe = he('<div class="overlay pointer-events-auto svelte-rxq6cp"><canvas></canvas> <div class="overlay-border svelte-rxq6cp"></div> <!></div>'),
  xfe = he('<div><!> <p class="text-base font-medium">Drop an image or click the button below to select a file</p> <input type="file" accept="image/*" class="hidden" id="auto-paint-file"/> <label for="auto-paint-file" class="btn btn-primary btn-sm">Upload image</label></div>'),
  wfe = he("<option> </option>"),
  kfe = he('<span class="loading loading-spinner loading-sm"></span> Processing', 1),
  Tfe = he('<button class="btn btn-primary"><!></button>'),
  Sfe = he('<span class="loading loading-spinner loading-sm"></span> Sending', 1),
  Pfe = he('<button class="btn btn-primary"><!></button>'),
  Mfe = he('<div class="rounded-box bg-success/10 text-success px-3 py-2 text-sm"> </div>'),
  Ife = he('<div class="mt-4 grid gap-4 md:grid-cols-2"><div class="space-y-2"><div class="rounded-box bg-base-200/60 p-3 text-sm"><p class="font-semibold"> </p> <p class="text-base-content/70"> </p></div> <div class="flex items-center gap-2"><label class="text-base-content/70 text-sm">Opacity</label> <input type="range" min="20" max="100"/></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Dithering (Floyd-Steinberg)</span></label> <p class="text-base-content/70 text-xs">Makes color transitions smoother.</p></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Paint transparent pixels</span></label> <p class="text-base-content/70 text-xs">Clears pixels using palette index 0.</p></div> <div class="space-y-1"><label class="flex flex-col gap-1 text-sm font-medium">Color metric <select class="select select-bordered select-sm w-full max-w-xs"></select></label></div></div> <div class="space-y-2 text-sm"><p class="text-base-content/70">1. Set image position by draging it.<br/> 2. Click on <strong>Generate Preview</strong> to convert the colors.<br/> 3. Confirm to paint the canvas.</p> <button class="btn btn-sm btn-outline">Change image</button> <div class="flex flex-wrap gap-2"><button class="btn btn-sm btn-outline">Flip horizontal</button> <button class="btn btn-sm btn-outline">Flip vertical</button></div> <label class="flex items-center gap-2 text-sm font-medium"><span class="whitespace-nowrap">Paint as user ID:</span> <input class="input input-bordered input-xs min-w-0 flex-1" type="number" placeholder="User ID"/></label></div></div> <div class="mt-4 flex flex-wrap items-center gap-3"><!> <button class="btn btn-ghost">Cancelar</button> <!></div>', 1),
  Cfe = he(`<div class="pointer-events-none absolute inset-0 z-40 select-none"><!></div> <div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-2xl sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 border-t p-4 shadow-xl"><div class="flex items-center justify-between gap-2"><div><h2 class="flex items-center gap-2 text-lg font-semibold"><!> Auto Painter</h2> <p class="text-base-content/70 text-sm">Drag the image to the desired position. Use the anchors to change it's size.</p></div> <button class="btn btn-circle btn-sm" title="Fechar"><!></button></div> <!></div></div>`, 1);

function zfe(p, s) {
  var Ue;
  nn(s, !1);
  const r = 2e3,
    x = 256,
    z = "admin-auto-painter-opacity",
    E = "admin-auto-painter-dithering",
    k = "admin-auto-painter-transparent";
  let l = nr(s, "map", 8),
    F = nr(s, "tileSize", 8),
    W = nr(s, "tileZoom", 8),
    ee = nr(s, "season", 8),
    $ = nr(s, "refreshPixelArt", 8),
    se = nr(s, "onclose", 8),
    _e = ra(new Aa(F())),
    ge = ra(((Ue = Dt.data) == null ? void 0 : Ue.id) ?? 0),
    V = ra("upload"),
    Me = ra(!1),
    we = ra(!1),
    Fe = ra(!1),
    be = ra(null),
    Xe = ra(""),
    tt = ra(null),
    Ye = ra(null),
    Ce = ra(null),
    De = ra({
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }),
    Ke = [],
    Le = ra(null),
    Ne = ra(null),
    vt = ra(1),
    et = ra(!1),
    We = ra(!1),
    _t = ra("lab");
  const Vt = [{
    value: "lab",
    label: "Perceptual (CIELAB Î”E94)"
  }, {
    value: "compuphase",
    label: "Weighted RGB (CompuPhase)"
  }];
  let Et = ra(!1),
    Pt = null;
  const lt = ["nw", "n", "ne", "e", "se", "s", "sw", "w"],
    $t = new Set(["nw", "ne", "se", "sw"]);

  function yt(ae) {
    return $t.has(ae)
  }

  function Rt(ae, Ie, $e) {
    return Math.min(Math.max(ae, Ie), $e)
  }

  function jt(ae) {
    const Ie = Math.max(ae.north, ae.south),
      $e = Math.min(ae.north, ae.south),
      dt = Math.min(ae.west, ae.east),
      Tt = Math.max(ae.west, ae.east);
    return {
      north: Rt(Ie, -85, 85),
      south: Rt($e, -85, 85),
      west: Rt(dt, -180, 180),
      east: Rt(Tt, -180, 180)
    }
  }

  function Xt(ae) {
    H(tt, jt(ae)), H(Me, !1), H(Le, null), Ke = [], H(De, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), fr(), Yt(), ur()
  }

  function fr() {
    if (!g(tt)) {
      H(Ce, null);
      return
    }
    const [ae, Ie] = g(_e).latLonToPixels(g(tt).north, g(tt).west, W()), [$e, dt] = g(_e).latLonToPixels(g(tt).south, g(tt).east, W()), Tt = Math.min(ae, $e), pt = Math.max(ae, $e), St = Math.min(Ie, dt), qt = Math.max(Ie, dt), qe = Math.max(1, Math.ceil(pt - Tt)), bt = Math.max(1, Math.ceil(qt - St));
    H(Ce, {
      px0: Tt,
      py0: St,
      width: qe,
      height: bt
    })
  }

  function Yt() {
    if (!g(tt)) {
      H(Ye, null);
      return
    }
    const ae = l().project({
        lat: g(tt).north,
        lng: g(tt).west
      }),
      Ie = l().project({
        lat: g(tt).south,
        lng: g(tt).east
      }),
      $e = Math.min(ae.x, Ie.x),
      dt = Math.min(ae.y, Ie.y),
      Tt = Math.abs(Ie.x - ae.x),
      pt = Math.abs(Ie.y - ae.y);
    H(Ye, {
      left: $e,
      top: dt,
      width: Tt,
      height: pt
    })
  }

  function lr() {
    H(V, "upload"), H(be, null), H(Xe, ""), H(tt, null), H(Ce, null), H(Ye, null), H(Me, !1), Ke = [], H(Le, null), H(De, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    })
  }

  function ot() {
    if (!g(be)) return;
    const ae = l().getCenter(),
      [Ie, $e] = g(_e).latLonToPixels(ae.lat, ae.lng, W()),
      dt = Math.min(1, x / g(be).width),
      Tt = Math.max(8, Math.round(g(be).width * dt)),
      pt = Math.max(8, Math.round(g(be).height * dt)),
      St = Ie - Tt / 2,
      qt = Ie + Tt / 2,
      qe = $e - pt / 2,
      bt = $e + pt / 2,
      [Jt, Cr] = g(_e).pixelsToLatLon(St, qe, W()),
      [_r, Qe] = g(_e).pixelsToLatLon(qt, bt, W());
    Xt({
      north: Jt,
      south: _r,
      west: Cr,
      east: Qe
    }), ur()
  }
  async function nt(ae) {
    try {
      lr();
      const Ie = URL.createObjectURL(ae),
        $e = await cp(Ie);
      URL.revokeObjectURL(Ie), H(be, Y0($e)), H(Xe, ae.name), H(V, "place"), ot()
    } catch (Ie) {
      console.error(Ie), Zt.error("Failed to load image. Try again.")
    }
  }

  function Ut(ae) {
    var dt;
    const Ie = ae.target,
      $e = (dt = Ie.files) == null ? void 0 : dt[0];
    $e && nt($e), Ie.value = ""
  }

  function Qt(ae) {
    ae.preventDefault(), H(Et, !0)
  }

  function Ot(ae) {
    ae.preventDefault(), H(Et, !1)
  }

  function mr(ae) {
    var $e, dt;
    ae.preventDefault(), H(Et, !1);
    const Ie = (dt = ($e = ae.dataTransfer) == null ? void 0 : $e.files) == null ? void 0 : dt[0];
    Ie && nt(Ie)
  }

  function zt(ae) {
    const Ie = l().getCanvas().getBoundingClientRect(),
      $e = [ae.clientX - Ie.left, ae.clientY - Ie.top],
      dt = l().unproject($e);
    return {
      lat: dt.lat,
      lon: dt.lng
    }
  }

  function Mt(ae, Ie, $e) {
    if (!g(be)) return Ie;
    const dt = g(be).width / Math.max(g(be).height, 1);
    if (!isFinite(dt) || dt <= 0) return Ie;
    const Tt = ae.includes("n") ? $e.south : $e.north,
      pt = ae.includes("w") ? $e.east : $e.west,
      St = ae.includes("n") ? Ie.north : Ie.south,
      qt = ae.includes("w") ? Ie.west : Ie.east,
      [qe, bt] = g(_e).latLonToPixels(Tt, pt, W()),
      [Jt, Cr] = g(_e).latLonToPixels(St, qt, W());
    let _r = Jt - qe,
      Qe = Cr - bt,
      rr = Math.sign(_r) || (ae.includes("w") ? -1 : 1),
      Kt = Math.sign(Qe) || (ae.includes("n") ? -1 : 1),
      Tr = Math.abs(_r),
      Rr = Math.abs(Qe);
    if (Tr === 0 && Rr === 0) return Ie;
    const Qr = Rr * dt,
      br = Tr / dt;
    Qr > Tr ? Tr = Qr : Rr = br;
    const Nt = qe + rr * Tr,
      wt = bt + Kt * Rr,
      [Ge, xt] = g(_e).pixelsToLatLon(Nt, wt, W());
    return ae.includes("n") ? Ie.north = Ge : Ie.south = Ge, ae.includes("w") ? Ie.west = xt : Ie.east = xt, Ie
  }

  function kt(ae) {
    if (!g(tt)) return;
    ae.preventDefault();
    const {
      lat: Ie,
      lon: $e
    } = zt(ae);
    Pt = {
      type: "move",
      startLat: Ie,
      startLon: $e,
      startBounds: {
        ...g(tt)
      }
    }, ht()
  }

  function It(ae, Ie) {
    g(tt) && (ae.preventDefault(), ae.stopPropagation(), Pt = {
      type: "resize",
      handle: Ie,
      startBounds: {
        ...g(tt)
      }
    }, ht())
  }

  function Gt(ae) {
    l().scrollZoom.isEnabled() && (ae.preventDefault(), l().getCanvasContainer().dispatchEvent(new WheelEvent("wheel", {
      deltaX: ae.deltaX,
      deltaY: ae.deltaY,
      deltaZ: ae.deltaZ,
      deltaMode: ae.deltaMode,
      clientX: ae.clientX,
      clientY: ae.clientY,
      screenX: ae.screenX,
      screenY: ae.screenY,
      ctrlKey: ae.ctrlKey,
      shiftKey: ae.shiftKey,
      altKey: ae.altKey,
      metaKey: ae.metaKey,
      bubbles: !0,
      cancelable: !0
    })))
  }

  function ht() {
    l().dragPan.disable(), window.addEventListener("pointermove", wr), window.addEventListener("pointerup", hr)
  }

  function hr() {
    window.removeEventListener("pointermove", wr), window.removeEventListener("pointerup", hr), l().dragPan.enable(), Pt = null
  }

  function wr(ae) {
    if (!Pt || !Pt.startBounds) return;
    const {
      startBounds: Ie
    } = Pt;
    if (Pt.type === "move") {
      const {
        lat: St,
        lon: qt
      } = zt(ae), qe = St - Pt.startLat, bt = qt - Pt.startLon;
      Xt({
        north: Ie.north + qe,
        south: Ie.south + qe,
        west: Ie.west + bt,
        east: Ie.east + bt
      });
      return
    }
    const {
      handle: $e
    } = Pt, {
      lat: dt,
      lon: Tt
    } = zt(ae);
    let pt = {
      ...Ie
    };
    $e.includes("n") && (pt.north = dt), $e.includes("s") && (pt.south = dt), $e.includes("w") && (pt.west = Tt), $e.includes("e") && (pt.east = Tt), yt($e) && (pt = Mt($e, pt, Ie)), Xt(pt)
  }

  function ur() {
    if (!g(Ne) || !g(Ce) || !g(be) || g(Me)) return;
    kr().drawImage(g(be), 0, 0, g(Ce).width, g(Ce).height)
  }

  function qr(ae, Ie) {
    if (!g(be)) return;
    const $e = document.createElement("canvas");
    $e.width = g(be).width, $e.height = g(be).height;
    const dt = $e.getContext("2d");
    if (!dt) throw new Error("Canvas context not available");
    dt.imageSmoothingEnabled = !1;
    const Tt = ae ? -1 : 1,
      pt = Ie ? -1 : 1,
      St = ae ? g(be).width : 0,
      qt = Ie ? g(be).height : 0;
    if (dt.setTransform(Tt, 0, 0, pt, St, qt), dt.drawImage(g(be), 0, 0), H(be, $e), g(Me)) {
      de();
      return
    }
    ur()
  }

  function kr() {
    if (!g(Ne) || !g(Ce)) throw new Error("Canvas not ready");
    sv(Ne, g(Ne).width = g(Ce).width), sv(Ne, g(Ne).height = g(Ce).height);
    const ae = g(Ne).getContext("2d", {
      willReadFrequently: !0
    });
    if (!ae) throw new Error("Canvas context not available");
    return ae.imageSmoothingEnabled = !1, ae.clearRect(0, 0, g(Ne).width, g(Ne).height), ae
  }

  function Zr() {
    if (!g(Ne) || !g(Ce) || !g(Le) || !g(Me)) return;
    kr().putImageData(g(Le), 0, 0)
  }
  async function Wr() {
    if (!(!g(Ce) || !g(be))) {
      if (g(Ce).width > r || g(Ce).height > r) {
        Zt.error(`The selected area is too big (${g(Ce).width}Ã—${g(Ce).height}).`);
        return
      }
      H(we, !0);
      try {
        const ae = tr();
        if (!ae || ae.pixels.length === 0) {
          Zt.error("Faile to convert into valid game_pixels");
          return
        }
        H(Le, ae.imageData), Ke = ae.pixels, H(De, ae.stats), H(Me, !0), Zr()
      } catch (ae) {
        console.error(ae), Zt.error("Failed to generate preview.")
      } finally {
        H(we, !1)
      }
    }
  }

  function tr() {
    if (!g(Ce) || !g(be)) return;
    const ae = document.createElement("canvas");
    ae.width = g(Ce).width, ae.height = g(Ce).height;
    const Ie = ae.getContext("2d", {
      willReadFrequently: !0
    });
    if (!Ie) throw new Error("Context is null.");
    Ie.imageSmoothingEnabled = !1, Ie.drawImage(g(be), 0, 0, g(Ce).width, g(Ce).height);
    const $e = g(Ce).width,
      dt = g(Ce).height,
      Tt = Ie.getImageData(0, 0, $e, dt),
      pt = Tt.data,
      St = [],
      qt = new Set,
      qe = g(et);
    let bt = null,
      Jt = null;
    if (qe) {
      const Cr = $e * 3;
      bt = new Float32Array(Cr), Jt = new Float32Array(Cr)
    }
    for (let Cr = 0; Cr < dt; Cr++) {
      if (qe && bt && Jt) {
        const _r = bt;
        bt = Jt, Jt = _r, Jt.fill(0)
      }
      for (let _r = 0; _r < $e; _r++) {
        const Qe = (Cr * $e + _r) * 4;
        if (pt[Qe + 3] < 16) {
          if (pt[Qe + 3] = 0, !g(We)) continue;
          const pr = 0,
            ar = vp(pr);
          pt[Qe] = ar.r, pt[Qe + 1] = ar.g, pt[Qe + 2] = ar.b;
          const zr = g(Ce).px0 + _r + .5,
            Jr = g(Ce).py0 + Cr + .5,
            {
              tile: jr,
              pixel: Or
            } = g(_e).pixelsToTileLocal(zr, Jr),
            Fr = {
              tile: [jr[0], jr[1]],
              pixel: [Or[0], Or[1]],
              season: ee(),
              colorIdx: pr,
              color: ar
            },
            rn = `${jr[0]}:${jr[1]}`;
          qt.add(rn), St.push(Fr);
          continue
        }
        let Kt = pt[Qe],
          Tr = pt[Qe + 1],
          Rr = pt[Qe + 2];
        if (qe && bt) {
          const pr = _r * 3;
          Kt = Rt(Math.round(Kt + bt[pr]), 0, 255), Tr = Rt(Math.round(Tr + bt[pr + 1]), 0, 255), Rr = Rt(Math.round(Rr + bt[pr + 2]), 0, 255)
        }
        const Qr = l0({
            r: Kt,
            g: Tr,
            b: Rr
          }, g(_t)),
          br = vp(Qr);
        if (pt[Qe] = br.r, pt[Qe + 1] = br.g, pt[Qe + 2] = br.b, pt[Qe + 3] = br.a, qe && bt && Jt) {
          const pr = Kt - br.r,
            ar = Tr - br.g,
            zr = Rr - br.b,
            Jr = (jr, Or, Fr) => {
              jr[Or] += pr * Fr, jr[Or + 1] += ar * Fr, jr[Or + 2] += zr * Fr
            };
          if (_r + 1 < $e) {
            const jr = (_r + 1) * 3;
            Jr(bt, jr, 7 / 16)
          }
          if (Cr + 1 < dt) {
            if (_r > 0) {
              const Or = (_r - 1) * 3;
              Jr(Jt, Or, 3 / 16)
            }
            const jr = _r * 3;
            if (Jr(Jt, jr, 5 / 16), _r + 1 < $e) {
              const Or = (_r + 1) * 3;
              Jr(Jt, Or, 1 / 16)
            }
          }
        }
        const Nt = g(Ce).px0 + _r + .5,
          wt = g(Ce).py0 + Cr + .5,
          {
            tile: Ge,
            pixel: xt
          } = g(_e).pixelsToTileLocal(Nt, wt),
          Wt = {
            tile: [Ge[0], Ge[1]],
            pixel: [xt[0], xt[1]],
            season: ee(),
            colorIdx: Qr,
            color: br
          },
          At = `${Ge[0]}:${Ge[1]}`;
        qt.add(At), St.push(Wt)
      }
    }
    return {
      pixels: St,
      imageData: Tt,
      stats: {
        pixels: St.length,
        width: $e,
        height: dt,
        tiles: qt.size
      }
    }
  }
  async function Hr() {
    if (!(!g(Me) || Ke.length === 0)) {
      H(Fe, !0);
      try {
        xi.droppletAndPlop.play();
        const ae = await lm(),
          Ie = Ke.map(({
            color: $e,
            ...dt
          }) => dt);
        await dn.adminAutoPainterPaint(Ie, ae, g(ge)), await U_(Ke), $()(), Dt.refresh(), Zt.success("Art painted successfully."), sr()
      } catch (ae) {
        console.error(ae), Zt.error(ae.message ?? "Failed to paint art.")
      } finally {
        H(Fe, !1)
      }
    }
  }

  function sr() {
    lr(), se()()
  }

  function de() {
    H(Me, !1), H(Le, null), Ke = [], H(De, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), ur()
  }
  Yi(() => {
    const ae = () => Yt();
    return l().on("move", ae), l().on("zoom", ae), l().on("resize", ae), () => {
      l().off("move", ae), l().off("zoom", ae), l().off("resize", ae)
    }
  }), kx(() => {
    lr()
  }), Zf(() => Lx(F()), () => {
    H(_e, new Aa(F()))
  }), Zf(() => (g(Ne), g(Ce), g(be), g(Me), g(V)), () => {
    g(Ne) && g(Ce) && g(be) && !g(Me) && g(V) === "place" && ur()
  }), Zf(() => (g(Ne), g(Ce), g(Le), g(Me)), () => {
    g(Ne) && g(Ce) && g(Le) && g(Me) && Zr()
  }), Ex(), G_();
  var O = Cfe();
  In("keydown", Os, ae => {
    ae.key === "Escape" && sr()
  }), In("dragover", Os, G1(Qt)), In("drop", Os, mr), In("dragleave", Os, Ot);
  var N = Ct(O),
    X = M(N);
  {
    var re = ae => {
      var Ie = bfe(),
        $e = M(Ie);
      let dt;
      ja($e, St => H(Ne, St), () => g(Ne));
      var Tt = D($e, 2),
        pt = D(Tt, 2);
      si(pt, 1, () => lt, St => St, (St, qt) => {
        var qe = yfe();
        Re(bt => {
          Vr(qe, 1, `handle handle-${g(qt)}`, "svelte-rxq6cp"), er(qe, "aria-label", bt)
        }, [() => (g(qt), Ca(() => `Redimensionar (${g(qt).toUpperCase()})`))]), In("pointerdown", qe, bt => It(bt, g(qt))), q(St, qe)
      }), S(Ie), Re(() => {
        ds(Ie, (g(Ye), g(vt), Ca(() => `left:${g(Ye).left}px;top:${g(Ye).top}px;width:${g(Ye).width}px;height:${g(Ye).height}px;opacity:${g(vt)};`))), dt = Vr($e, 1, "h-full w-full svelte-rxq6cp", null, dt, {
          pixelated: g(Me)
        })
      }), In("pointerdown", $e, kt), In("pointerdown", Tt, kt), In("wheel", Ie, Gt), q(ae, Ie)
    };
    Te(X, ae => {
      g(tt) && g(Ye) && ae(re)
    })
  }
  S(N);
  var Q = D(N, 2),
    ue = M(Q),
    ke = M(ue),
    xe = M(ke),
    Ee = M(xe),
    He = M(Ee);
  bl(He, {
    class: "size-5"
  }), bn(), S(Ee), bn(2), S(xe);
  var Be = D(xe, 2),
    ie = M(Be);
  Ro(ie, {
    class: "size-4"
  }), S(Be), S(ke);
  var J = D(ke, 2);
  {
    var Ve = ae => {
        var Ie = xfe(),
          $e = M(Ie);
        n1($e, {
          class: "text-base-content/70 size-10"
        });
        var dt = D($e, 4);
        bn(2), S(Ie), Re(() => Vr(Ie, 1, `rounded-box mt-4 flex flex-col items-center justify-center gap-3 border border-dashed p-6 text-center transition ${g(Et)?"border-primary bg-primary/10":"border-base-300"}`, "svelte-rxq6cp")), In("change", dt, Ut), q(ae, Ie)
      },
      rt = ae => {
        var Ie = Sr(),
          $e = Ct(Ie);
        {
          var dt = Tt => {
            var pt = Ife(),
              St = Ct(pt),
              qt = M(St),
              qe = M(qt),
              bt = M(qe),
              Jt = M(bt, !0);
            S(bt);
            var Cr = D(bt, 2),
              _r = M(Cr);
            S(Cr), S(qe);
            var Qe = D(qe, 2),
              rr = M(Qe);
            er(rr, "for", z);
            var Kt = D(rr, 2);
            Ki(Kt), er(Kt, "id", z), S(Qe);
            var Tr = D(Qe, 2),
              Rr = M(Tr);
            er(Rr, "for", E);
            var Qr = M(Rr);
            Ki(Qr), er(Qr, "id", E), bn(2), S(Rr), bn(2), S(Tr);
            var br = D(Tr, 2),
              Nt = M(br);
            er(Nt, "for", k);
            var wt = M(Nt);
            Ki(wt), er(wt, "id", k), bn(2), S(Nt), bn(2), S(br);
            var Ge = D(br, 2),
              xt = M(Ge),
              Wt = D(M(xt));
            Re(() => {
              g(_t), Dx(() => {
                g(Me)
              })
            }), si(Wt, 5, () => Vt, Dc, (En, Tn) => {
              var Un = wfe(),
                Jn = M(Un, !0);
              S(Un);
              var ft = {};
              Re(() => {
                te(Jn, (g(Tn), Ca(() => g(Tn).label))), ft !== (ft = (g(Tn), Ca(() => g(Tn).value))) && (Un.value = (Un.__value = (g(Tn), Ca(() => g(Tn).value))) ?? "")
              }), q(En, Un)
            }), S(Wt), S(xt), S(Ge), S(qt);
            var At = D(qt, 2),
              pr = D(M(At), 2),
              ar = D(pr, 2),
              zr = M(ar),
              Jr = D(zr, 2);
            S(ar);
            var jr = D(ar, 2),
              Or = D(M(jr), 2);
            Ki(Or), S(jr), S(At), S(St);
            var Fr = D(St, 2),
              rn = M(Fr);
            {
              var An = En => {
                  var Tn = Tfe(),
                    Un = M(Tn);
                  {
                    var Jn = Ft => {
                        var Lr = kfe();
                        bn(), q(Ft, Lr)
                      },
                      ft = Ft => {
                        var Lr = Oi("Generate Preview");
                        q(Ft, Lr)
                      };
                    Te(Un, Ft => {
                      g(we) ? Ft(Jn) : Ft(ft, !1)
                    })
                  }
                  S(Tn), Re(() => Tn.disabled = g(we)), In("click", Tn, Wr), q(En, Tn)
                },
                kn = En => {
                  var Tn = Pfe(),
                    Un = M(Tn);
                  {
                    var Jn = Ft => {
                        var Lr = Sfe();
                        bn(), q(Ft, Lr)
                      },
                      ft = Ft => {
                        var Lr = Oi("Confirm painting");
                        q(Ft, Lr)
                      };
                    Te(Un, Ft => {
                      g(Fe) ? Ft(Jn) : Ft(ft, !1)
                    })
                  }
                  S(Tn), Re(() => Tn.disabled = g(Fe)), In("click", Tn, Hr), q(En, Tn)
                };
              Te(rn, En => {
                g(Me) ? En(kn, !1) : En(An)
              })
            }
            var Kr = D(rn, 2),
              Ur = D(Kr, 2);
            {
              var Cn = En => {
                var Tn = Mfe(),
                  Un = M(Tn);
                S(Tn), Re(Jn => te(Un, `Ready to paint ${Jn??""} pixels.`), [() => (g(De), Ca(() => g(De).pixels.toLocaleString(navigator.language)))]), q(En, Tn)
              };
              Te(Ur, En => {
                g(Me) && En(Cn)
              })
            }
            S(Fr), Re(() => {
              te(Jt, g(Xe)), te(_r, `Target size: ${g(Ce),Ca(()=>g(Ce).width)??""} Ã— ${g(Ce),Ca(()=>g(Ce).height)??""} pixels`), V_(Kt, g(vt) * 100)
            }), In("input", Kt, En => {
              const Tn = En.target;
              H(vt, Number(Tn.value) / 100)
            }), gp(Qr, () => g(et), En => H(et, En)), In("change", Qr, () => {
              g(Me) && de()
            }), gp(wt, () => g(We), En => H(We, En)), In("change", wt, () => {
              g(Me) && de()
            }), qx(Wt, () => g(_t), En => H(_t, En)), In("change", Wt, () => {
              g(Me) && de()
            }), In("click", pr, () => H(V, "upload")), In("click", zr, () => qr(!0, !1)), In("click", Jr, () => qr(!1, !0)), yl(Or, () => g(ge), En => H(ge, En)), In("click", Kr, sr), q(Tt, pt)
          };
          Te($e, Tt => {
            g(tt) && g(Ce) && Tt(dt)
          }, !0)
        }
        q(ae, Ie)
      };
    Te(J, ae => {
      g(V) === "upload" ? ae(Ve) : ae(rt, !1)
    })
  }
  S(ue), S(Q), In("click", Be, sr), q(p, O), an()
}
const up = yi({
  shouldReload: !0
});
var Afe = he('<dialog class="modal" closeby="any"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Efe(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15),
    x = Je(!1),
    z = Je(yi(s.description)),
    E = Je(void 0);
  var k = Afe(),
    l = M(k),
    F = M(l),
    W = M(F, !0);
  S(F);
  var ee = D(F, 2),
    $ = M(ee),
    se = M($);
  {
    let Fe = mt(() => k0());
    c0(se, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return g(Fe)
      },
      max: 512,
      get value() {
        return g(z)
      },
      set value(be) {
        H(z, be, !0)
      },
      get validate() {
        return g(E)
      },
      set validate(be) {
        H(E, be, !0)
      }
    })
  }
  S($);
  var _e = D($, 2),
    ge = M(_e);
  ge.__click = () => {
    var Fe;
    (Fe = r()) == null || Fe.close()
  };
  var V = M(ge, !0);
  S(ge);
  var Me = D(ge, 2),
    we = M(Me, !0);
  S(Me), S(_e), S(ee), S(l), bn(2), S(k), ja(k, Fe => r(Fe), () => r()), Re((Fe, be, Xe) => {
    te(W, Fe), ge.disabled = g(x), te(V, be), Me.disabled = g(x), te(we, Xe)
  }, [() => u1(), () => jc(), () => qre()]), In("submit", ee, async () => {
    var Fe, be, Xe;
    try {
      if (!((Fe = g(E)) != null && Fe())) return;
      H(x, !0), s.description !== g(z) && await dn.updateAllianceDescription(g(z)), await ((be = s.onsuccess) == null ? void 0 : be.call(s, g(z))), (Xe = r()) == null || Xe.close()
    } catch (tt) {
      Zt.error(tt.message)
    } finally {
      H(x, !1)
    }
  }), q(p, k), an()
}
Yn(["click"]);
var Lfe = he('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  Dfe = he('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Rfe(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(""),
    z = Je(!1);
  const E = mt(() => vi.url.origin + `/join?id=${g(x)}`);
  cn(() => {
    r() && dn.getAllianceInvites().then(Ye => {
      H(x, Ye[0], !0)
    }).catch(Ye => {
      Zt.error(Ye.message)
    })
  });
  var k = Dfe(),
    l = M(k),
    F = D(M(l), 2),
    W = M(F, !0);
  S(F);
  var ee = D(F, 2),
    $ = M(ee, !0);
  S(ee);
  var se = D(ee, 2),
    _e = M(se);
  let ge;
  var V = M(_e);
  Ki(V);
  var Me = D(V, 2),
    we = M(Me);
  let Fe;
  we.__click = () => {
    navigator.clipboard.writeText(g(E).toString()), H(z, !0), setTimeout(() => {
      H(z, !1)
    }, 1e3)
  };
  var be = M(we, !0);
  S(we), S(Me), S(_e);
  var Xe = D(_e, 2);
  {
    var tt = Ye => {
      var Ce = Lfe();
      q(Ye, Ce)
    };
    Te(Xe, Ye => {
      g(x) || Ye(tt)
    })
  }
  S(se), S(l), bn(2), S(k), Ji(k, () => Ye => {
    cn(() => {
      r() ? Ye.show() : Ye.close()
    })
  }), Re((Ye, Ce, De, Ke) => {
    te(W, Ye), te($, Ce), ge = Vr(_e, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, ge, {
      invisible: !g(x)
    }), V_(V, De), Fe = Vr(we, 1, "btn btn-primary", null, Fe, {
      "btn-success": g(z)
    }), te(be, Ke)
  }, [() => o8(), () => sX(), () => g(E).toString(), () => g(z) ? J_() : i_()]), In("close", k, () => r(!1)), q(p, k), an()
}
Yn(["click"]);
var jfe = Yr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function d_(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = jfe();
  Dr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...r
  })), q(p, x)
}
var Ffe = he('<span class="text-success">(Verified)</span>'),
  Bfe = he('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  Ofe = he("<button><!></button>"),
  qfe = he('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function Lh(p, s) {
  nn(s, !0);
  const r = !!s.id;
  var x = qfe(),
    z = M(x),
    E = M(z),
    k = M(E);
  S(E);
  var l = D(E, 2);
  {
    var F = se => {
      var _e = Ffe();
      q(se, _e)
    };
    Te(l, se => {
      r && se(F)
    })
  }
  S(z);
  var W = D(z, 2);
  {
    var ee = se => {
        var _e = Bfe(),
          ge = M(_e);
        d_(ge, {
          class: "size-4 opacity-70"
        }), S(_e), Re(V => er(_e, "href", V), [() => `https://discord.com/users/${encodeURIComponent(s.id)}`]), q(se, _e)
      },
      $ = se => {
        var _e = Ofe();
        _e.__click = async () => {
          await navigator.clipboard.writeText(s.username), Zt.info(dne())
        };
        var ge = M(_e);
        d_(ge, {
          class: "size-4 opacity-70"
        }), S(_e), q(se, _e)
      };
    Te(W, se => {
      r ? se(ee) : se($, !1)
    })
  }
  S(x), Re(() => te(k, `Discord: ${s.username??""}`)), q(p, x), an()
}
Yn(["click"]);
var Nfe = he('<input type="radio" class="tab max-[380px]:px-3"/>'),
  Vfe = he('<div class="tabs tabs-border w-max font-medium"></div>');

function cm(p, s) {
  nn(s, !0);
  const r = [];
  let x = nr(s, "value", 15, "today"),
    z = [{
      value: "today",
      label: Dp()
    }, {
      value: "week",
      label: Kne()
    }, {
      value: "month",
      label: hj()
    }, {
      value: "all-time",
      label: mw()
    }];
  var E = Vfe();
  si(E, 21, () => z, k => k.value, (k, l) => {
    var F = Nfe();
    Ki(F);
    var W;
    Re(() => {
      er(F, "aria-label", g(l).label), W !== (W = g(l).value) && (F.value = (F.__value = g(l).value) ?? "")
    }), Z_(r, [], F, () => (g(l).value, x()), x), q(k, F)
  }), S(E), q(p, E), an()
}
const Ufe = typeof window < "u" ? window : void 0;

function Zfe(p) {
  let s = p.activeElement;
  for (; s != null && s.shadowRoot;) {
    const r = s.shadowRoot.activeElement;
    if (r === s) break;
    s = r
  }
  return s
}
var Mc, rh, t0;
let Gfe = (t0 = class {
  constructor(s = {}) {
    wn(this, Mc);
    wn(this, rh);
    const {
      window: r = Ufe,
      document: x = r == null ? void 0 : r.document
    } = s;
    r !== void 0 && (Ma(this, Mc, x), Ma(this, rh, n0(z => {
      const E = _p(r, "focusin", z),
        k = _p(r, "focusout", z);
      return () => {
        E(), k()
      }
    })))
  }
  get current() {
    var s;
    return (s = ir(this, rh)) == null || s.call(this), ir(this, Mc) ? Zfe(ir(this, Mc)) : null
  }
}, Mc = new WeakMap, rh = new WeakMap, t0);
new Gfe;

function Wfe(p) {
  return typeof p == "function"
}

function Hfe(p, s) {
  if (Wfe(p)) {
    const x = p();
    return x === void 0 ? s : x
  }
  return p === void 0 ? s : p
}

function $fe(p, s) {
  let r = Je(null);
  const x = mt(() => Hfe(s, 250));

  function z(...E) {
    if (g(r)) g(r).timeout && clearTimeout(g(r).timeout);
    else {
      let k, l;
      const F = new Promise((W, ee) => {
        k = W, l = ee
      });
      H(r, {
        timeout: null,
        runner: null,
        promise: F,
        resolve: k,
        reject: l
      }, !0)
    }
    return g(r).runner = async () => {
      if (!g(r)) return;
      const k = g(r);
      H(r, null);
      try {
        k.resolve(await p.apply(this, E))
      } catch (l) {
        k.reject(l)
      }
    }, g(r).timeout = setTimeout(g(r).runner, g(x)), g(r).promise
  }
  return z.cancel = async () => {
    (!g(r) || g(r).timeout === null) && (await new Promise(E => setTimeout(E, 0)), !g(r) || g(r).timeout === null) || (clearTimeout(g(r).timeout), g(r).reject("Cancelled"), H(r, null))
  }, z.runScheduledNow = async () => {
    var E, k;
    (!g(r) || !g(r).timeout) && (await new Promise(l => setTimeout(l, 0)), !g(r) || !g(r).timeout) || (clearTimeout(g(r).timeout), g(r).timeout = null, await ((k = (E = g(r)).runner) == null ? void 0 : k.call(E)))
  }, Object.defineProperty(z, "pending", {
    enumerable: !0,
    get() {
      var E;
      return !!((E = g(r)) != null && E.timeout)
    }
  }), z
}

function Xfe(p, s) {
  switch (p) {
    case "post":
      cn(s);
      break;
    case "pre":
      q_(s);
      break
  }
}

function K0(p, s, r, x = {}) {
  const {
    lazy: z = !1
  } = x;
  let E = !z,
    k = Array.isArray(p) ? [] : void 0;
  Xfe(s, () => {
    const l = Array.isArray(p) ? p.map(W => W()) : p();
    if (!E) {
      E = !0, k = l;
      return
    }
    const F = Ca(() => r(l, k));
    return k = l, F
  })
}

function ps(p, s, r) {
  K0(p, "post", s, r)
}

function Yfe(p, s, r) {
  K0(p, "pre", s, r)
}
ps.pre = Yfe;

function Kfe() {}
var gl, Fs;
class Jfe {
  constructor(s, r = 250) {
    wn(this, gl, Je());
    wn(this, Fs);
    H(ir(this, gl), s(), !0), this.cancel = this.cancel.bind(this), this.setImmediately = this.setImmediately.bind(this), this.updateImmediately = this.updateImmediately.bind(this), Ma(this, Fs, $fe(() => {
      H(ir(this, gl), s(), !0)
    }, r)), ps(s, () => {
      ir(this, Fs).call(this).catch(Kfe)
    })
  }
  get current() {
    return g(ir(this, gl))
  }
  get pending() {
    return ir(this, Fs).pending
  }
  cancel() {
    ir(this, Fs).cancel()
  }
  updateImmediately() {
    return ir(this, Fs).runScheduledNow()
  }
  setImmediately(s) {
    this.cancel(), H(ir(this, gl), s, !0)
  }
}
gl = new WeakMap, Fs = new WeakMap;
var Qfe = he('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  e_e = he('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  t_e = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  r_e = he("<button><!></button>"),
  n_e = he('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  i_e = he('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  a_e = he('<div><!> <div class="mt-4"><!></div></div>');

function o_e(p, s) {
  nn(s, !0);
  let r = nr(s, "reload", 15),
    x = Je(!0),
    z = Je([]),
    E = Je(0),
    k = Je("today"),
    l = {};
  r(F);

  function F() {
    const V = g(k);
    dn.allianceLeaderboard(V).then(Me => {
      H(z, Me), l = {
        [V]: Me
      }, H(x, !1)
    }).catch(Me => {
      Zt.error(Me.message)
    })
  }
  ps(() => [g(k)], () => {
    const V = g(k),
      Me = l[V];
    if (Me) {
      H(z, Me), H(x, !1);
      return
    }
    H(x, !0), dn.allianceLeaderboard(V).then(we => {
      H(z, we), l[V] = we, H(x, !1)
    }).catch(we => {
      Zt.error(we.message)
    })
  });
  var W = a_e(),
    ee = M(W);
  cm(ee, {
    get value() {
      return g(k)
    },
    set value(V) {
      H(k, V, !0)
    }
  });
  var $ = D(ee, 2),
    se = M($);
  {
    var _e = V => {
        var Me = Qfe();
        q(V, Me)
      },
      ge = V => {
        var Me = Sr(),
          we = Ct(Me);
        {
          var Fe = Xe => {
              var tt = e_e(),
                Ye = M(tt),
                Ce = D(Ye);
              {
                var De = Le => {
                    var Ne = Oi();
                    Re(vt => te(Ne, vt), [() => Dp().toLowerCase()]), q(Le, Ne)
                  },
                  Ke = Le => {
                    var Ne = Sr(),
                      vt = Ct(Ne);
                    {
                      var et = _t => {
                          var Vt = Oi();
                          Re(Et => te(Vt, Et), [() => rm()]), q(_t, Vt)
                        },
                        We = _t => {
                          var Vt = Sr(),
                            Et = Ct(Vt);
                          {
                            var Pt = lt => {
                              var $t = Oi();
                              Re(yt => te($t, yt), [() => tm()]), q(lt, $t)
                            };
                            Te(Et, lt => {
                              g(k) === "month" && lt(Pt)
                            }, !0)
                          }
                          q(_t, Vt)
                        };
                      Te(vt, _t => {
                        g(k) === "week" ? _t(et) : _t(We, !1)
                      }, !0)
                    }
                    q(Le, Ne)
                  };
                Te(Ce, Le => {
                  g(k) === "today" ? Le(De) : Le(Ke, !1)
                })
              }
              S(tt), Re(Le => te(Ye, `${Le??""} `), [() => em()]), q(Xe, tt)
            },
            be = Xe => {
              var tt = i_e(),
                Ye = M(tt),
                Ce = M(Ye),
                De = D(M(Ce)),
                Ke = M(De, !0);
              S(De);
              var Le = D(De),
                Ne = M(Le, !0);
              S(Le), S(Ce), S(Ye);
              var vt = D(Ye);
              si(vt, 31, () => g(z), et => et.userId, (et, We, _t) => {
                const Vt = mt(() => {
                  var kt;
                  return ((kt = Dt.data) == null ? void 0 : kt.id) === g(We).userId
                });
                var Et = n_e();
                let Pt;
                var lt = M(Et),
                  $t = M(lt, !0);
                S(lt);
                var yt = D(lt),
                  Rt = M(yt),
                  jt = M(Rt);
                Ra(jt, {
                  class: "size-10 border",
                  get userId() {
                    return g(We).userId
                  },
                  get pictureUrl() {
                    return g(We).picture
                  }
                });
                var Xt = D(jt, 2),
                  fr = M(Xt),
                  Yt = D(fr),
                  lr = M(Yt);
                S(Yt), S(Xt);
                var ot = D(Xt, 2);
                {
                  var nt = kt => {
                    const It = mt(() => Do(g(We).equippedFlag));
                    var Gt = t_e(),
                      ht = M(Gt, !0);
                    S(Gt), Re(() => {
                      er(Gt, "data-tip", g(It).name), te(ht, g(It).flag)
                    }), q(kt, Gt)
                  };
                  Te(ot, kt => {
                    g(We).equippedFlag && kt(nt)
                  })
                }
                var Ut = D(ot, 2);
                {
                  var Qt = kt => {
                    Lh(kt, {
                      get username() {
                        return g(We).discord
                      },
                      get id() {
                        return g(We).discordId
                      }
                    })
                  };
                  Te(Ut, kt => {
                    g(We).discord && kt(Qt)
                  })
                }
                S(Rt), S(yt);
                var Ot = D(yt),
                  mr = M(Ot),
                  zt = D(mr);
                {
                  var Mt = kt => {
                    var It = r_e();
                    let Gt;
                    It.__click = () => {
                      s.onlastpixelclick({
                        lat: g(We).lastLatitude ?? 0,
                        lng: g(We).lastLongitude ?? 0
                      })
                    };
                    var ht = M(It);
                    Ap(ht, {
                      class: "size-4"
                    }), S(It), Re(hr => {
                      Gt = Vr(It, 1, "btn btn-sm btn-ghost -translate-y-1/2! absolute -right-2 top-1/2 sm:right-4", null, Gt, {
                        tooltip: g(E) > 640
                      }), er(It, "data-tip", hr)
                    }, [() => P1()]), q(kt, It)
                  };
                  Te(zt, kt => {
                    g(We).lastLatitude && g(We).lastLongitude && kt(Mt)
                  })
                }
                S(Ot), S(Et), Re((kt, It) => {
                  var Gt;
                  Pt = Vr(Et, 1, "", null, Pt, {
                    "bg-base-200": g(Vt)
                  }), te($t, g(_t) + 1), Vr(Xt, 1, `font-semibold ${kt??""} flex gap-1`), te(fr, `${(g(Vt)?((Gt=Dt.data)==null?void 0:Gt.name)??g(We).name:g(We).name)??""} `), te(lr, `#${g(We).userId??""}`), te(mr, `${It??""} `)
                }, [() => na(g(We).userId), () => g(We).pixelsPainted.toLocaleString(navigator.language)]), _l(Et, () => ml, () => ({
                  duration: 200
                })), q(et, Et)
              }), S(vt), S(tt), Re((et, We) => {
                te(Ke, et), te(Ne, We)
              }, [() => $_(), () => W_()]), q(Xe, tt)
            };
          Te(we, Xe => {
            g(z).length === 0 ? Xe(Fe) : Xe(be, !1)
          }, !0)
        }
        q(V, Me)
      };
    Te(se, V => {
      g(x) ? V(_e) : V(ge, !1)
    })
  }
  S($), S(W), Ch("innerWidth", V => H(E, V, !0)), q(p, W), an()
}
Yn(["click"]);
var s_e = Yr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function um(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = s_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var l_e = he('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  c_e = he('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1),
  u_e = he('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'),
  h_e = he('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'),
  d_e = he('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  p_e = he('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'),
  f_e = he('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  __e = he('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  m_e = he('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function g_e(p, s) {
  nn(s, !0);
  let r = yi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    x = yi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var z = m_e(),
    E = M(z),
    k = M(E);
  k.__click = () => s.onclickback();
  var l = M(k);
  f0(l, {
    class: "size-5"
  }), S(k);
  var F = D(k, 2),
    W = M(F, !0);
  S(F), S(E);
  var ee = D(E, 2),
    $ = M(ee);
  Ki($);
  var se = D($, 2),
    _e = M(se),
    ge = M(_e);
  si(ge, 21, () => r.data, Ke => Ke.id, (Ke, Le, Ne) => {
    const vt = mt(() => {
      var nt;
      return ((nt = Dt.data) == null ? void 0 : nt.id) === g(Le).id
    });
    var et = h_e(),
      We = M(et),
      _t = M(We),
      Vt = M(_t);
    Ra(Vt, {
      class: "size-10 border",
      get userId() {
        return g(Le).id
      },
      get pictureUrl() {
        return g(Le).picture
      }
    });
    var Et = D(Vt, 2),
      Pt = M(Et);
    S(Et);
    var lt = D(Et, 2);
    {
      var $t = nt => {
        var Ut = l_e();
        q(nt, Ut)
      };
      Te(lt, nt => {
        g(Le).role === "admin" && nt($t)
      })
    }
    S(_t), S(We);
    var yt = D(We),
      Rt = M(yt),
      jt = M(Rt),
      Xt = M(jt);
    um(Xt, {
      class: "size-4"
    }), S(jt);
    var fr = D(jt, 2),
      Yt = M(fr);
    {
      var lr = nt => {
          var Ut = c_e(),
            Qt = Ct(Ut),
            Ot = M(Qt);
          Ot.__click = async () => {
            try {
              g(Le).loading = !0, await dn.giveAllianceAdmin(g(Le).id), g(Le).role = "admin"
            } catch {
              Zt.error(Q6())
            } finally {
              g(Le).loading = !1
            }
          };
          var mr = M(Ot, !0);
          S(Ot), S(Qt);
          var zt = D(Qt, 2),
            Mt = M(zt);
          Mt.__click = async () => {
            try {
              g(Le).loading = !0, await dn.banAllianceUser(g(Le).id), r.data = r.data.filter(It => It.id !== g(Le).id)
            } catch {
              Zt.error(AI())
            } finally {
              g(Le).loading = !1
            }
          };
          var kt = M(Mt, !0);
          S(Mt), S(zt), Re((It, Gt) => {
            Ot.disabled = g(Le).loading, te(mr, It), Mt.disabled = g(Le).loading, te(kt, Gt)
          }, [() => q6(), () => x0()]), q(nt, Ut)
        },
        ot = nt => {
          var Ut = u_e(),
            Qt = M(Ut);
          Qt.disabled = !0;
          var Ot = M(Qt, !0);
          S(Qt), S(Ut), Re(mr => te(Ot, mr), [() => DF()]), q(nt, Ut)
        };
      Te(Yt, nt => {
        g(Le).role === "member" ? nt(lr) : nt(ot, !1)
      })
    }
    S(fr), S(Rt), S(yt), S(et), Re(nt => {
      var Ut;
      Vr(Et, 1, `font-semibold ${nt??""}`), te(Pt, `${(g(vt)?((Ut=Dt.data)==null?void 0:Ut.name)??g(Le).name:g(Le).name)??""} #${g(Le).id??""}`)
    }, [() => na(g(Le).id)]), q(Ke, et)
  }), S(ge), S(_e);
  var V = D(_e, 2);
  {
    var Me = Ke => {
      var Le = Sr(),
        Ne = Ct(Le);
      Ec(Ne, () => r.page, vt => {
        var et = d_e();
        Ji(et, () => We => {
          const _t = new IntersectionObserver(Vt => {
            Vt[0].isIntersecting && !r.loading && (r.loading = !0, dn.getAllianceMembers(r.page).then(Et => {
              r.data = [...r.data, ...Et.data], r.hasNextPage = Et.hasNext, r.page++
            }).catch(Et => {
              Zt.error(Et.message)
            }).finally(() => {
              r.loading = !1
            }))
          });
          return _t.observe(We), () => {
            _t.disconnect()
          }
        }), q(vt, et)
      }), q(Ke, Le)
    };
    Te(V, Ke => {
      r.hasNextPage && Ke(Me)
    })
  }
  S(se);
  var we = D(se, 2),
    Fe = D(we, 2),
    be = M(Fe),
    Xe = M(be);
  si(Xe, 21, () => x.data, Ke => Ke.id, (Ke, Le, Ne) => {
    var vt = p_e(),
      et = M(vt),
      We = M(et),
      _t = M(We);
    Ra(_t, {
      class: "size-10 border",
      get userId() {
        return g(Le).id
      },
      get pictureUrl() {
        return g(Le).picture
      }
    });
    var Vt = D(_t, 2),
      Et = M(Vt);
    S(Vt), S(We), S(et);
    var Pt = D(et),
      lt = M(Pt);
    lt.__click = () => {
      dn.unbanAllianceUser(g(Le).id).then(() => {
        x.data = x.data.filter(yt => yt.id !== g(Le).id)
      }).catch(yt => Zt.error(yt.message)).finally(() => {
        g(Le).loading = !1
      })
    };
    var $t = M(lt, !0);
    S(lt), S(Pt), S(vt), Re((yt, Rt) => {
      Vr(Vt, 1, `font-semibold ${yt??""}`), te(Et, `${g(Le).name??""} #${g(Le).id??""}`), lt.disabled = g(Le).loading, te($t, Rt)
    }, [() => na(g(Le).id), () => I1()]), q(Ke, vt)
  }), S(Xe), S(be);
  var tt = D(be, 2);
  {
    var Ye = Ke => {
      var Le = f_e(),
        Ne = M(Le, !0);
      S(Le), Re(vt => te(Ne, vt), [() => HF()]), q(Ke, Le)
    };
    Te(tt, Ke => {
      !x.hasNextPage && x.data.length === 0 && Ke(Ye)
    })
  }
  var Ce = D(tt, 2);
  {
    var De = Ke => {
      var Le = Sr(),
        Ne = Ct(Le);
      Ec(Ne, () => x.page, vt => {
        var et = __e();
        Ji(et, () => We => {
          const _t = new IntersectionObserver(Vt => {
            Vt[0].isIntersecting && !x.loading && (x.loading = !0, dn.getAllianceBannedMembers(x.page).then(Et => {
              x.data = [...x.data, ...Et.data], x.hasNextPage = Et.hasNext, x.page++
            }).catch(Et => {
              Zt.error(Et.message)
            }).finally(() => {
              x.loading = !1
            }))
          });
          return _t.observe(We), () => {
            _t.disconnect()
          }
        }), q(vt, et)
      }), q(Ke, Le)
    };
    Te(Ce, Ke => {
      x.hasNextPage && Ke(De)
    })
  }
  S(Fe), S(ee), S(z), Re((Ke, Le, Ne) => {
    te(W, Ke), er($, "aria-label", Le), er(we, "aria-label", Ne)
  }, [() => p0(), () => C1(), () => X_()]), q(p, z), an()
}
Yn(["click"]);
var v_e = he('<span class="label"> </span>'),
  y_e = he('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  b_e = he('<p class="text-error ml-3 text-sm"> </p>'),
  x_e = he('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function p_(p, s) {
  nn(s, !0);
  let r = nr(s, "value", 15),
    x = nr(s, "validate", 15),
    z = Je("");
  const E = mt(() => {
    var we;
    return ((we = r()) == null ? void 0 : we.length) ?? 0
  });
  x(k);

  function k() {
    return s.min !== void 0 && g(E) < s.min ? (H(z, g(E) === 0 ? "Required" : `Min. characters: ${s.min}`, !0), !1) : s.max !== void 0 && g(E) > s.max ? (H(z, `Max. characters: ${s.max}`), !1) : !0
  }
  cn(() => {
    var we;
    s.max !== void 0 && g(E) > s.max && r((we = r()) == null ? void 0 : we.substring(0, s.max))
  });
  var l = x_e(),
    F = M(l);
  let W;
  var ee = M(F);
  {
    var $ = we => {
      var Fe = v_e(),
        be = M(Fe, !0);
      S(Fe), Re(() => te(be, s.label)), q(we, Fe)
    };
    Te(ee, we => {
      s.label && we($)
    })
  }
  var se = D(ee, 2);
  Ki(se);
  var _e = D(se, 2);
  {
    var ge = we => {
      var Fe = y_e(),
        be = M(Fe, !0);
      S(Fe), Re(() => te(be, s.max - g(E))), q(we, Fe)
    };
    Te(_e, we => {
      s.max !== void 0 && we(ge)
    })
  }
  S(F);
  var V = D(F, 2);
  {
    var Me = we => {
      var Fe = b_e(),
        be = M(Fe, !0);
      S(Fe), Re(() => te(be, g(z))), q(we, Fe)
    };
    Te(V, we => {
      g(z) && we(Me)
    })
  }
  S(l), Re(() => {
    W = Vr(F, 1, "input w-full", null, W, {
      "input-error": !!g(z)
    }), er(se, "placeholder", s.placeholder), er(se, "maxlength", s.max)
  }), yl(se, r), q(p, l), an()
}
var w_e = he('<dialog class="modal" closedby="any"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function k_e(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15),
    x = Je(!1),
    z = Je(""),
    E = Je(void 0);
  var k = w_e(),
    l = M(k),
    F = M(l),
    W = M(F, !0);
  S(F);
  var ee = D(F, 2),
    $ = M(ee),
    se = M($);
  {
    let Fe = mt(() => s_()),
      be = mt(() => Cw());
    p_(se, {
      get label() {
        return g(Fe)
      },
      get placeholder() {
        return g(be)
      },
      min: 1,
      max: 16,
      get value() {
        return g(z)
      },
      set value(Xe) {
        H(z, Xe, !0)
      },
      get validate() {
        return g(E)
      },
      set validate(Xe) {
        H(E, Xe, !0)
      }
    })
  }
  S($);
  var _e = D($, 2),
    ge = M(_e);
  ge.__click = () => {
    var Fe;
    (Fe = r()) == null || Fe.close()
  };
  var V = M(ge, !0);
  S(ge);
  var Me = D(ge, 2),
    we = M(Me, !0);
  S(Me), S(_e), S(ee), S(l), bn(2), S(k), ja(k, Fe => r(Fe), () => r()), Re((Fe, be, Xe) => {
    te(W, Fe), ge.disabled = g(x), te(V, be), Me.disabled = g(x), te(we, Xe)
  }, [() => dP(), () => jc(), () => QS()]), In("submit", ee, async () => {
    var Fe, be;
    try {
      if (!((Fe = g(E)) != null && Fe())) return;
      H(x, !0);
      const {
        id: Xe
      } = await dn.createAlliance(g(z));
      await s.onsuccess(Xe), (be = r()) == null || be.close()
    } catch (Xe) {
      Zt.error(Xe.message)
    } finally {
      H(x, !1)
    }
  }), q(p, k), an()
}
Yn(["click"]);
var T_e = Yr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function S_e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = T_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var P_e = Yr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function M_e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = P_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var I_e = Yr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function C_e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = I_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var z_e = Yr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function Rp(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = z_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}

function A_e(p, s = "_blank") {
  return p.replaceAll(/https?:\/\/[^\s]+/g, r => `<a href="${r}"${s?` target="${s}"`:""}>${r}</a>`)
}
var E_e = he('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  L_e = he('<div class="tooltip"><button class="btn"><!></button></div>'),
  D_e = he('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'),
  R_e = he('<section class="text-base-content/80 highlight-link"><!> <!></section>'),
  j_e = he('<span class="font-semibold"> </span>'),
  F_e = he('<button class="text-primary font-semibold underline"> </button>'),
  B_e = he('<span class="text-primary underline"> </span>'),
  O_e = he('<span class="text-primary underline"> </span>'),
  q_e = he('<button class="text-base-content/80 p-1"><!></button>'),
  N_e = he('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'),
  V_e = he('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1),
  U_e = he('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1),
  Z_e = he('<div class="h-full"><!></div>');

function G_e(p, s) {
  nn(s, !0);
  let r = Je(void 0),
    x = Je(!0),
    z = Je(void 0),
    E = Je(!1),
    k = Je(void 0),
    l = Je(!1),
    F = Je(!1),
    W = Je(() => {});
  ps(() => s.open, () => {
    s.open && up.shouldReload && ee()
  }), Yi(() => {
    const V = setInterval(() => {
      up.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(V)
    }
  });
  async function ee() {
    try {
      H(r, await dn.getAlliance(), !0), g(r) && g(W)(), H(x, !1), up.shouldReload = !1
    } catch (V) {
      Zt.error(V.message)
    }
  }
  var $ = Z_e(),
    se = M($);
  {
    var _e = V => {
        var Me = E_e();
        q(V, Me)
      },
      ge = V => {
        var Me = Sr(),
          we = Ct(Me);
        {
          var Fe = Xe => {
              g_e(Xe, {
                onclickback: () => H(F, !1)
              })
            },
            be = Xe => {
              var tt = Sr(),
                Ye = Ct(tt);
              {
                var Ce = Ke => {
                    var Le = V_e(),
                      Ne = Ct(Le),
                      vt = M(Ne),
                      et = M(vt, !0);
                    S(vt);
                    var We = D(vt, 2),
                      _t = M(We),
                      Vt = M(_t),
                      Et = M(Vt);
                    um(Et, {
                      class: "size-4"
                    }), S(Vt);
                    var Pt = D(Vt, 2),
                      lt = M(Pt),
                      $t = M(lt);
                    $t.__click = async () => {
                      try {
                        H(E, !0), await dn.leaveAlliance(), H(x, !0), await ee()
                      } catch (sr) {
                        Zt.error(sr.message)
                      } finally {
                        H(E, !1)
                      }
                    };
                    var yt = M($t, !0);
                    S($t), S(lt), S(Pt), S(_t);
                    var Rt = D(_t, 2);
                    {
                      var jt = sr => {
                        var de = L_e(),
                          O = M(de);
                        O.__click = () => {
                          H(l, !0)
                        };
                        var N = M(O);
                        C_e(N, {
                          class: "size-4"
                        }), S(O), S(de), Re(X => er(de, "data-tip", X), [() => HE()]), q(sr, de)
                      };
                      Te(Rt, sr => {
                        g(r).role == "admin" && sr(jt)
                      })
                    }
                    S(We), S(Ne);
                    var Xt = D(Ne, 2);
                    {
                      var fr = sr => {
                        var de = R_e(),
                          O = M(de);
                        zp(O, () => A_e(g(r).description || k0()));
                        var N = D(O, 2);
                        {
                          var X = re => {
                            var Q = D_e();
                            Q.__click = () => {
                              var ke;
                              (ke = g(k)) == null || ke.show()
                            };
                            var ue = M(Q);
                            a_(ue, {
                              class: "size-4"
                            }), S(Q), q(re, Q)
                          };
                          Te(N, re => {
                            g(r).role === "admin" && re(X)
                          })
                        }
                        S(de), q(sr, de)
                      };
                      Te(Xt, sr => {
                        (g(r).description || g(r).role === "admin") && sr(fr)
                      })
                    }
                    var Yt = D(Xt, 2),
                      lr = M(Yt),
                      ot = M(lr);
                    bl(ot, {
                      class: "inline size-4"
                    });
                    var nt = D(ot, 2),
                      Ut = M(nt),
                      Qt = D(Ut),
                      Ot = M(Qt, !0);
                    S(Qt), S(nt), S(lr);
                    var mr = D(lr, 2),
                      zt = M(mr);
                    Rp(zt, {
                      class: "inline size-4"
                    });
                    var Mt = D(zt, 2),
                      kt = M(Mt),
                      It = D(kt);
                    {
                      var Gt = sr => {
                          var de = j_e(),
                            O = M(de, !0);
                          S(de), Re(N => te(O, N), [() => g(r).members.toLocaleString(navigator.language)]), q(sr, de)
                        },
                        ht = sr => {
                          var de = F_e();
                          de.__click = () => H(F, !0);
                          var O = M(de, !0);
                          S(de), Re(N => te(O, N), [() => g(r).members.toLocaleString(navigator.language)]), q(sr, de)
                        };
                      Te(It, sr => {
                        g(r).role === "member" ? sr(Gt) : sr(ht, !1)
                      })
                    }
                    S(Mt), S(mr);
                    var hr = D(mr, 2);
                    {
                      var wr = sr => {
                        var de = N_e(),
                          O = M(de);
                        S_e(O, {
                          class: "inline size-4"
                        });
                        var N = D(O, 2),
                          X = M(N),
                          re = D(X);
                        re.__click = () => {
                          var He;
                          (He = g(r)) != null && He.hq ? s.onhqclick({
                            lat: g(r).hq.latitude,
                            lng: g(r).hq.longitude
                          }) : s.onhqchange()
                        };
                        var Q = M(re);
                        {
                          var ue = He => {
                              var Be = B_e(),
                                ie = M(Be);
                              S(Be), Re((J, Ve) => te(ie, `${J??""}, ${Ve??""}`), [() => g(r).hq.latitude.toFixed(3), () => g(r).hq.longitude.toFixed(3)]), q(He, Be)
                            },
                            ke = He => {
                              var Be = O_e(),
                                ie = M(Be, !0);
                              S(Be), Re(J => te(ie, J), [() => jO()]), q(He, Be)
                            };
                          Te(Q, He => {
                            g(r).hq ? He(ue) : He(ke, !1)
                          })
                        }
                        S(re), S(N);
                        var xe = D(N, 2);
                        {
                          var Ee = He => {
                            var Be = q_e();
                            Be.__click = function(...J) {
                              var Ve;
                              (Ve = s.onhqchange) == null || Ve.apply(this, J)
                            };
                            var ie = M(Be);
                            a_(ie, {
                              class: "text-base-content/50 size-4"
                            }), S(Be), q(He, Be)
                          };
                          Te(xe, He => {
                            g(r).role === "admin" && He(Ee)
                          })
                        }
                        S(de), Re(He => te(X, `${He??""}: `), [() => dz()]), q(sr, de)
                      };
                      Te(hr, sr => {
                        (g(r).hq || g(r).role === "admin") && sr(wr)
                      })
                    }
                    S(Yt);
                    var ur = D(Yt, 2),
                      qr = M(ur),
                      kr = M(qr, !0);
                    S(qr);
                    var Zr = D(qr, 2),
                      Wr = M(Zr);
                    o_e(Wr, {
                      get allianceId() {
                        return g(r).id
                      },
                      get onlastpixelclick() {
                        return s.onlastpixelclick
                      },
                      get reload() {
                        return g(W)
                      },
                      set reload(sr) {
                        H(W, sr, !0)
                      }
                    }), S(Zr), S(ur);
                    var tr = D(ur, 2);
                    Efe(tr, {
                      get description() {
                        return g(r).description
                      },
                      onsuccess: async sr => {
                        g(r) && (g(r).description = sr)
                      },
                      get ref() {
                        return g(k)
                      },
                      set ref(sr) {
                        H(k, sr, !0)
                      }
                    });
                    var Hr = D(tr, 2);
                    Rfe(Hr, {
                      get open() {
                        return g(l)
                      },
                      set open(sr) {
                        H(l, sr, !0)
                      }
                    }), Re((sr, de, O, N, X) => {
                      te(et, g(r).name), $t.disabled = g(E), te(yt, sr), te(Ut, `${de??""}: `), te(Ot, O), te(kt, `${N??""}: `), te(kr, X)
                    }, [() => G8(), () => W_(), () => g(r).pixelsPainted.toLocaleString(navigator.language), () => p0(), () => Y_()]), q(Ke, Le)
                  },
                  De = Ke => {
                    var Le = U_e(),
                      Ne = Ct(Le),
                      vt = M(Ne),
                      et = M(vt);
                    S(vt);
                    var We = D(vt, 2),
                      _t = M(We);
                    M_e(_t, {
                      class: "size-5"
                    });
                    var Vt = D(_t, 1, !0);
                    S(We);
                    var Et = D(We, 2),
                      Pt = M(Et),
                      lt = M(Pt, !0);
                    S(Pt), S(Et);
                    var $t = D(Et, 2);
                    $t.__click = () => {
                      var Xt;
                      (Xt = g(z)) == null || Xt.show()
                    };
                    var yt = M($t);
                    a0(yt, {
                      class: "size-6"
                    });
                    var Rt = D(yt);
                    S($t), S(Ne);
                    var jt = D(Ne, 2);
                    k_e(jt, {
                      onsuccess: ee,
                      get ref() {
                        return g(z)
                      },
                      set ref(Xt) {
                        H(z, Xt, !0)
                      }
                    }), Re((Xt, fr, Yt, lr) => {
                      te(et, `${Xt??""}:`), te(Vt, fr), te(lt, Yt), te(Rt, ` ${lr??""}`)
                    }, [() => uO(), () => f6(), () => a2(), () => SP()]), q(Ke, Le)
                  };
                Te(Ye, Ke => {
                  g(r) ? Ke(Ce) : Ke(De, !1)
                }, !0)
              }
              q(Xe, tt)
            };
          Te(we, Xe => {
            g(F) ? Xe(Fe) : Xe(be, !1)
          }, !0)
        }
        q(V, Me)
      };
    Te(se, V => {
      g(x) ? V(_e) : V(ge, !1)
    })
  }
  S($), q(p, $), an()
}
Yn(["click"]);
var W_e = Yr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function jp(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = W_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var H_e = he('<dialog class="modal" closedby="any"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function $_e(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  var x = H_e(),
    z = M(x),
    E = D(M(z), 2),
    k = M(E);
  jp(k, {
    class: "size-5 max-sm:size-6"
  });
  var l = D(k, 2),
    F = M(l, !0);
  S(l), S(E);
  var W = D(E, 2),
    ee = M(W);
  G_e(ee, {
    get open() {
      return r()
    },
    get onhqchange() {
      return s.onhqchange
    },
    get onhqclick() {
      return s.onhqclick
    },
    get onlastpixelclick() {
      return s.onlastpixelclick
    }
  }), S(W), S(z), bn(2), S(x), Ji(x, () => $ => {
    cn(() => {
      r() ? ($.show(), vi.url.searchParams.get("alliance") && (vi.url.searchParams.delete("alliance"), mp(vi.url.toString()))) : $.close()
    })
  }), Re($ => te(F, $), [() => Ep()]), In("close", x, () => r(!1)), fa(2, W, () => Ja, () => ({
    duration: 300
  })), q(p, x), an()
}

function X_e(p, s, r) {
  return new Promise((x, z) => {
    p.once("render", () => {
      const E = p.getCanvas().toDataURL(),
        k = document.createElement("img");
      k.src = E, k.onload = () => {
        const l = document.createElement("canvas");
        l.width = k.width, l.height = k.height;
        const F = l.getContext("2d");
        if (F) {
          F.drawImage(k, 0, 0);
          const [W, ee, $, se] = F.getImageData(s, r, 1, 1).data;
          x([W, ee, $, se])
        } else z(new Error("Could not get 2d context from canvas"));
        k.remove(), l.remove()
      }
    }), p.triggerRepaint()
  })
}

function kp(p, s) {
  return new Promise((r, x) => {
    p.once("render", () => {
      const z = p.getCanvas();
      let E = z;
      if (s != null && s.maxWidth || s != null && s.maxHeight) {
        const k = z.width,
          l = z.height,
          F = (s == null ? void 0 : s.maxWidth) ?? k,
          W = (s == null ? void 0 : s.maxHeight) ?? l;
        E = document.createElement("canvas");
        const ee = Math.min(F / k, W / l);
        E.width = Math.floor(k * ee), E.height = Math.floor(l * ee);
        const $ = E.getContext("2d");
        $ && $.drawImage(z, 0, 0, E.width, E.height)
      }
      try {
        E.toBlob(k => {
          k && r(k)
        }, (s == null ? void 0 : s.type) ?? "image/png", (s == null ? void 0 : s.quality) ?? 1)
      } catch (k) {
        x(k)
      } finally {
        E !== z && E.remove()
      }
    })
  })
}
var Y_e = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function K_e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Y_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var J_e = Yr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function J0(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = J_e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
const kc = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function Q0(p) {
  const s = Math.floor(p / kc.hour);
  p -= s * kc.hour;
  const r = Math.floor(p / kc.min);
  p -= r * kc.min;
  const z = Math.floor(p / kc.sec).toString().padStart(2, "0");
  return s > 0 ? `${s}:${r.toString().padStart(2,"0")}:${z}` : `${r}:${z}`
}

function Q_e(p) {
  const s = p.getFullYear(),
    r = String(p.getMonth() + 1).padStart(2, "0"),
    x = String(p.getDate()).padStart(2, "0"),
    z = String(p.getHours()).padStart(2, "0"),
    E = String(p.getMinutes()).padStart(2, "0"),
    k = String(p.getSeconds()).padStart(2, "0");
  return `${s}-${r}-${x} ${z}:${E}:${k}`
}
var eme = he('<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'),
  tme = he('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  rme = he('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  nme = he('<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'),
  ime = he('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function ame(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(!1),
    z = Je(null),
    E = Je("");
  const k = mt(() => {
    const Ye = new URL(s.url.toString()),
      Ce = Ye.searchParams.get("lat"),
      De = Ye.searchParams.get("lng");
    if (Ce && De) return {
      lat: parseFloat(Ce),
      lng: parseFloat(De)
    }
  });
  cn(() => {
    r() ? (s.hideHover(), setTimeout(async () => {
      kp(s.map).then(Ye => {
        H(z, Ye, !0), H(E, URL.createObjectURL(g(z)), !0)
      }).finally(() => {
        s.showHover()
      })
    }, 500)) : g(E) && (URL.revokeObjectURL(g(E)), H(z, null), H(E, ""))
  });
  var l = ime(),
    F = M(l),
    W = D(M(F), 2),
    ee = M(W);
  J0(ee, {
    class: "size-5"
  });
  var $ = D(ee);
  S(W);
  var se = D(W, 2),
    _e = M(se);
  Ki(_e);
  var ge = D(_e, 2),
    V = M(ge);
  let Me;
  V.__click = () => {
    navigator.clipboard.writeText(s.url.toString()), H(x, !0), setTimeout(() => {
      H(x, !1)
    }, 1e3)
  };
  var we = M(V, !0);
  S(V), S(ge), S(se);
  var Fe = D(se, 2);
  {
    var be = Ye => {
      var Ce = eme(),
        De = M(Ce),
        Ke = M(De);
      S(De);
      var Le = D(De);
      S(Ce), Re(Ne => {
        te(Ke, `${Ne??""}:`), te(Le, ` ${g(k).lat??""}, ${g(k).lng??""}`)
      }, [() => w0()]), q(Ye, Ce)
    };
    Te(Fe, Ye => {
      g(k) && Ye(be)
    })
  }
  var Xe = D(Fe, 2);
  {
    var tt = Ye => {
      const Ce = mt(() => {
        var Rt;
        return (Rt = s.map) == null ? void 0 : Rt.getCanvas()
      });
      var De = nme(),
        Ke = M(De),
        Le = M(Ke);
      K_e(Le, {
        class: "inline size-5"
      });
      var Ne = D(Le);
      S(Ke);
      var vt = D(Ke, 2);
      {
        var et = Rt => {
            var jt = tme();
            Re(() => {
              er(jt, "src", g(E)), er(jt, "width", g(Ce).width), er(jt, "height", g(Ce).height)
            }), q(Rt, jt)
          },
          We = Rt => {
            var jt = rme();
            Re(() => ds(jt, `aspect-ratio: ${g(Ce).width/g(Ce).height}`)), q(Rt, jt)
          };
        Te(vt, Rt => {
          g(E) ? Rt(et) : Rt(We, !1)
        })
      }
      var _t = D(vt, 2),
        Vt = M(_t);
      Vt.__click = async () => {
        g(z) && (await navigator.clipboard.write([new ClipboardItem({
          "image/png": g(z)
        })]), Zt.info(jA()))
      };
      var Et = M(Vt);
      K_(Et, {
        class: "size-5"
      });
      var Pt = D(Et);
      S(Vt);
      var lt = D(Vt, 2),
        $t = M(lt);
      H_($t, {
        class: "size-5"
      });
      var yt = D($t);
      S(lt), S(_t), S(De), Re((Rt, jt, Xt, fr) => {
        te(Ne, ` ${Rt??""}`), te(Pt, ` ${jt??""}`), er(lt, "href", g(E)), er(lt, "download", `wplace_${Xt??""}.png`), te(yt, ` ${fr??""}`)
      }, [() => kA(), () => i_(), () => Q_e(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => L4()]), fa(2, De, () => Ja, () => ({
        duration: 300
      })), q(Ye, De)
    };
    Te(Xe, Ye => {
      r() && Ye(tt)
    })
  }
  S(F), bn(2), S(l), Ji(l, () => Ye => {
    cn(() => {
      r() ? Ye.show() : Ye.close()
    })
  }), Re((Ye, Ce, De) => {
    te($, ` ${Ye??""}`), V_(_e, Ce), Me = Vr(V, 1, "btn btn-primary", null, Me, {
      "btn-success": g(x)
    }), te(we, De)
  }, [() => WX(), () => s.url.toString(), () => g(x) ? J_() : i_()]), In("close", l, () => r(!1)), q(p, l), an()
}
Yn(["click"]);
Yn(["click"]);
Yn(["click"]);
var ome = Yr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function sme(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = ome();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var lme = he('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  cme = he('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function ey(p, s) {
  nn(s, !1);
  const r = [s4(), A7(), nB(), O9(), cM(), fV(), $U()];
  G_();
  var x = cme(),
    z = M(x),
    E = M(z);
  sme(E, {
    class: "size-5"
  });
  var k = D(E, 2),
    l = M(k),
    F = D(l),
    W = M(F, !0);
  S(F), S(k), S(z);
  var ee = D(z, 2),
    $ = M(ee);
  si($, 5, () => r, Dc, (Fe, be) => {
    var Xe = lme(),
      tt = M(Xe, !0);
    S(Xe), Re(() => te(tt, g(be))), q(Fe, Xe)
  }), S($);
  var se = D($, 2),
    _e = M(se, !0);
  S(se);
  var ge = D(se, 2),
    V = M(ge),
    Me = D(V),
    we = M(Me, !0);
  S(Me), bn(), S(ge), S(ee), S(x), Re((Fe, be, Xe, tt, Ye) => {
    te(l, `${Fe??""} `), te(W, be), te(_e, Xe), te(V, `${tt??""} `), te(we, Ye)
  }, [() => FH(), () => XA(), () => Bne(), () => t6(), () => A2()]), q(p, x), an()
}
var ume = he('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function hme(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  var x = ume(),
    z = M(x),
    E = M(z),
    k = M(E),
    l = M(k),
    F = M(l, !0);
  S(l);
  var W = D(l, 2);
  _0(W, {
    hasText: !0,
    size: "medium"
  }), S(k), S(E);
  var ee = D(E, 2),
    $ = M(ee);
  ey($, {}), S(ee);
  var se = D(ee, 2),
    _e = M(se);
  _e.__click = () => {
    vi.url.searchParams.delete("new-user"), mp(vi.url.toString())
  };
  var ge = M(_e, !0);
  S(_e), S(se), S(z), S(x), Ji(x, () => V => {
    cn(() => {
      r() ? V.show() : V.close()
    })
  }), Re((V, Me) => {
    te(F, V), te(ge, Me)
  }, [() => uie(), () => Cte()]), In("close", x, () => r(!1)), q(p, x), an()
}
Yn(["click"]);

function dme() {
  const p = navigator.userAgent,
    s = navigator.vendor;
  return /Chrome/.test(p) && /Google Inc/.test(s) ? "Chrome" : /Safari/.test(p) && /Apple Computer/.test(s) ? "Safari" : /Firefox/.test(p) ? "Firefox" : /Edge/.test(p) ? "Edge" : /Opera|OPR/.test(p) ? "Opera" : "Unknown"
}
var pme = Yr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function fme(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = pme();
  Dr(x, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...r
  })), q(p, x)
}
var _me = Yr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function f_(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = _me();
  Dr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var mme = Yr('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function gme(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = mme();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...r
  })), q(p, x)
}
var vme = Yr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function Tp(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = vme();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var yme = Yr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function bme(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = yme();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...r
  })), q(p, x)
}
var xme = Yr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function wme(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = xme();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...r
  })), q(p, x)
}
var kme = he(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  Tme = he('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  Sme = he('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  Pme = he(' <kbd class="kbd kbd-sm h-fit px-3"> </kbd> <!>', 1),
  Mme = he('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> Â· <a class="link" target="_blank"> </a> Â· <a class="link" target="_blank"> </a> Â· <a class="link" target="_blank"> </a> Â· <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> Â· <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  Ime = he('<dialog class="modal" closedby="any"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function Cme(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  const x = dme();
  var z = Ime(),
    E = M(z),
    k = D(M(E), 2);
  {
    var l = $ => {
      var se = Mme(),
        _e = M(se),
        ge = M(_e);
      _0(ge, {
        hasText: !0,
        size: "medium"
      });
      var V = D(ge, 2),
        Me = M(V),
        we = D(Me, 4);
      bn(), S(V);
      var Fe = D(V, 2),
        be = M(Fe),
        Xe = M(be),
        tt = M(Xe);
      f_(tt, {
        class: "text-base-content mr-0.5 inline size-4"
      }), bn(2), S(Xe);
      var Ye = D(Xe, 4),
        Ce = M(Ye);
      fme(Ce, {
        class: "size-4.5 mr-0.5 inline"
      }), bn(2), S(Ye);
      var De = D(Ye, 4),
        Ke = M(De);
      gme(Ke, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), S(De);
      var Le = D(De, 4),
        Ne = M(Le);
      wme(Ne, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), S(Le);
      var vt = D(Le, 4),
        et = M(vt);
      bme(et, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), S(vt), S(be), S(Fe), S(_e);
      var We = D(_e, 2),
        _t = M(We),
        Vt = M(_t, !0);
      S(_t);
      var Et = D(_t, 2);
      S(We);
      var Pt = D(We, 2),
        lt = M(Pt),
        $t = M(lt, !0);
      S(lt);
      var yt = D(lt, 2),
        Rt = M(yt),
        jt = D(Rt),
        Xt = M(jt);
      Tp(Xt, {
        class: "size-5"
      }), S(jt);
      var fr = D(jt);
      S(yt);
      var Yt = D(yt, 2),
        lr = M(Yt),
        ot = D(lr),
        nt = M(ot, !0);
      S(ot);
      var Ut = D(ot);
      S(Yt), S(Pt);
      var Qt = D(Pt, 2),
        Ot = M(Qt),
        mr = M(Ot, !0);
      S(Ot);
      var zt = D(Ot, 2),
        Mt = M(zt);
      {
        var kt = O => {
            var N = kme(),
              X = Ct(N);
            bn(), Re(re => te(X, `${re??""}: `), [() => VC()]), q(O, N)
          },
          It = O => {
            var N = Pme(),
              X = Ct(N),
              re = D(X),
              Q = M(re, !0);
            S(re);
            var ue = D(re),
              ke = D(ue);
            {
              var xe = He => {
                  var Be = Tme();
                  bn(), q(He, Be)
                },
                Ee = He => {
                  var Be = Sr(),
                    ie = Ct(Be);
                  {
                    var J = Ve => {
                      var rt = Sme();
                      bn(), q(Ve, rt)
                    };
                    Te(ie, Ve => {
                      x === "Edge" && Ve(J)
                    }, !0)
                  }
                  q(He, Be)
                };
              Te(ke, He => {
                x === "Chrome" ? He(xe) : He(Ee, !1)
              })
            }
            Re((He, Be, ie) => {
              te(X, `${He??""} `), te(Q, Be), te(ue, ` ${ie??""} `)
            }, [() => Sne(), () => Qre(), () => y8()]), q(O, N)
          };
        Te(Mt, O => {
          x !== "Chrome" && x !== "Edge" ? O(kt) : O(It, !1)
        })
      }
      S(zt), S(Qt);
      var Gt = D(Qt, 2),
        ht = M(Gt);
      ey(ht, {}), S(Gt);
      var hr = D(Gt, 4),
        wr = D(M(hr), 2),
        ur = M(wr, !0);
      S(wr);
      var qr = D(wr, 2),
        kr = M(qr, !0);
      S(qr);
      var Zr = D(qr, 2),
        Wr = M(Zr, !0);
      S(Zr);
      var tr = D(Zr, 2),
        Hr = M(tr, !0);
      S(tr);
      var sr = D(tr, 2),
        de = M(sr, !0);
      S(sr), S(hr), S(se), Re((O, N, X, re, Q, ue, ke, xe, Ee, He, Be, ie, J, Ve, rt, Ue, ae) => {
        te(Me, `${O??""} `), te(we, ` Â©
						${N??""} `), te(Vt, X), er(Et, "src", za.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), te($t, re), te(Rt, `${Q??""} `), te(fr, ` ${ue??""}`), te(lr, `${ke??""} `), te(nt, xe), te(Ut, ` ${Ee??""}`), te(mr, He), er(wr, "href", Be), te(ur, ie), er(qr, "href", `${vi.url.origin??""}/terms/privacy`), te(kr, J), er(Zr, "href", Ve), te(Wr, rt), te(Hr, Ue), te(de, ae)
      }, [() => sZ(), () => Lq(), () => aN(), () => uA(), () => kie(), () => bq(), () => Kz(), () => ZY(), () => f5(), () => pR(), z1, () => eJ(), () => bZ(), m0, () => M0(), () => IK(), () => X3()]), fa(2, se, () => Ja, () => ({
        duration: 300
      })), q($, se)
    };
    Te(k, $ => {
      r() && $(l)
    })
  }
  S(E);
  var F = D(E, 2),
    W = M(F),
    ee = M(W, !0);
  S(W), S(F), S(z), Ji(z, () => $ => {
    cn(() => {
      r() ? $.show() : $.close()
    })
  }), Re($ => te(ee, $), [() => hs()]), In("close", z, () => r(!1)), q(p, z), an()
}

function zme(p) {
  return p !== null && typeof p == "object"
}
const Ame = ["string", "number", "bigint", "boolean"];

function __(p) {
  return p == null || Ame.includes(typeof p) ? !0 : Array.isArray(p) ? p.every(s => __(s)) : typeof p == "object" ? Object.getPrototypeOf(p) === Object.prototype : !1
}
const m_ = Symbol("box"),
  Eme = Symbol("is-writable");

function Vn(p, s) {
  const r = mt(p);
  return s ? {
    [m_]: !0,
    [Eme]: !0,
    get current() {
      return g(r)
    },
    set current(x) {
      s(x)
    }
  } : {
    [m_]: !0,
    get current() {
      return p()
    }
  }
}

function Lme(p) {
  return zme(p) && m_ in p
}

function Dme(...p) {
  return function(s) {
    var r;
    for (const x of p)
      if (x) {
        if (s.defaultPrevented) return;
        typeof x == "function" ? x.call(this, s) : (r = x.current) == null || r.call(this, s)
      }
  }
}
var Ov = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  Rme = /\n/g,
  jme = /^\s*/,
  Fme = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  Bme = /^:\s*/,
  Ome = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  qme = /^[;\s]*/,
  Nme = /^\s+|\s+$/g,
  Vme = `
`,
  qv = "/",
  Nv = "*",
  pl = "",
  Ume = "comment",
  Zme = "declaration";

function Gme(p, s) {
  if (typeof p != "string") throw new TypeError("First argument must be a string");
  if (!p) return [];
  s = s || {};
  var r = 1,
    x = 1;

  function z(ge) {
    var V = ge.match(Rme);
    V && (r += V.length);
    var Me = ge.lastIndexOf(Vme);
    x = ~Me ? ge.length - Me : x + ge.length
  }

  function E() {
    var ge = {
      line: r,
      column: x
    };
    return function(V) {
      return V.position = new k(ge), W(), V
    }
  }

  function k(ge) {
    this.start = ge, this.end = {
      line: r,
      column: x
    }, this.source = s.source
  }
  k.prototype.content = p;

  function l(ge) {
    var V = new Error(s.source + ":" + r + ":" + x + ": " + ge);
    if (V.reason = ge, V.filename = s.source, V.line = r, V.column = x, V.source = p, !s.silent) throw V
  }

  function F(ge) {
    var V = ge.exec(p);
    if (V) {
      var Me = V[0];
      return z(Me), p = p.slice(Me.length), V
    }
  }

  function W() {
    F(jme)
  }

  function ee(ge) {
    var V;
    for (ge = ge || []; V = $();) V !== !1 && ge.push(V);
    return ge
  }

  function $() {
    var ge = E();
    if (!(qv != p.charAt(0) || Nv != p.charAt(1))) {
      for (var V = 2; pl != p.charAt(V) && (Nv != p.charAt(V) || qv != p.charAt(V + 1));) ++V;
      if (V += 2, pl === p.charAt(V - 1)) return l("End of comment missing");
      var Me = p.slice(2, V - 2);
      return x += 2, z(Me), p = p.slice(V), x += 2, ge({
        type: Ume,
        comment: Me
      })
    }
  }

  function se() {
    var ge = E(),
      V = F(Fme);
    if (V) {
      if ($(), !F(Bme)) return l("property missing ':'");
      var Me = F(Ome),
        we = ge({
          type: Zme,
          property: Vv(V[0].replace(Ov, pl)),
          value: Me ? Vv(Me[0].replace(Ov, pl)) : pl
        });
      return F(qme), we
    }
  }

  function _e() {
    var ge = [];
    ee(ge);
    for (var V; V = se();) V !== !1 && (ge.push(V), ee(ge));
    return ge
  }
  return W(), _e()
}

function Vv(p) {
  return p ? p.replace(Nme, pl) : pl
}

function Wme(p, s) {
  let r = null;
  if (!p || typeof p != "string") return r;
  const x = Gme(p),
    z = typeof s == "function";
  return x.forEach(E => {
    if (E.type !== "declaration") return;
    const {
      property: k,
      value: l
    } = E;
    z ? s(k, l, E) : l && (r = r || {}, r[k] = l)
  }), r
}
const Hme = /\d/,
  $me = ["-", "_", "/", "."];

function Xme(p = "") {
  if (!Hme.test(p)) return p !== p.toLowerCase()
}

function Yme(p) {
  const s = [];
  let r = "",
    x, z;
  for (const E of p) {
    const k = $me.includes(E);
    if (k === !0) {
      s.push(r), r = "", x = void 0;
      continue
    }
    const l = Xme(E);
    if (z === !1) {
      if (x === !1 && l === !0) {
        s.push(r), r = E, x = l;
        continue
      }
      if (x === !0 && l === !1 && r.length > 1) {
        const F = r.at(-1);
        s.push(r.slice(0, Math.max(0, r.length - 1))), r = F + E, x = l;
        continue
      }
    }
    r += E, x = l, z = k
  }
  return s.push(r), s
}

function ty(p) {
  return p ? Yme(p).map(s => Jme(s)).join("") : ""
}

function Kme(p) {
  return Qme(ty(p || ""))
}

function Jme(p) {
  return p ? p[0].toUpperCase() + p.slice(1) : ""
}

function Qme(p) {
  return p ? p[0].toLowerCase() + p.slice(1) : ""
}

function ep(p) {
  if (!p) return {};
  const s = {};

  function r(x, z) {
    if (x.startsWith("-moz-") || x.startsWith("-webkit-") || x.startsWith("-ms-") || x.startsWith("-o-")) {
      s[ty(x)] = z;
      return
    }
    if (x.startsWith("--")) {
      s[x] = z;
      return
    }
    s[Kme(x)] = z
  }
  return Wme(p, r), s
}

function ege(...p) {
  return (...s) => {
    for (const r of p) typeof r == "function" && r(...s)
  }
}

function tge(p, s) {
  const r = RegExp(p, "g");
  return x => {
    if (typeof x != "string") throw new TypeError(`expected an argument of type string, but got ${typeof x}`);
    return x.match(r) ? x.replace(r, s) : x
  }
}
const rge = tge(/[A-Z]/, p => `-${p.toLowerCase()}`);

function nge(p) {
  if (!p || typeof p != "object" || Array.isArray(p)) throw new TypeError(`expected an argument of type object, but got ${typeof p}`);
  return Object.keys(p).map(s => `${rge(s)}: ${p[s]};`).join(`
`)
}

function ry(p = {}) {
  return nge(p).replace(`
`, " ")
}
const ige = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  age = new Set(ige);

function oge(p) {
  return age.has(p)
}

function _s(...p) {
  const s = {
    ...p[0]
  };
  for (let r = 1; r < p.length; r++) {
    const x = p[r];
    if (x) {
      for (const z of Object.keys(x)) {
        const E = s[z],
          k = x[z],
          l = typeof E == "function",
          F = typeof k == "function";
        if (l && oge(z)) {
          const W = E,
            ee = k;
          s[z] = Dme(W, ee)
        } else if (l && F) s[z] = ege(E, k);
        else if (z === "class") {
          const W = __(E),
            ee = __(k);
          W && ee ? s[z] = np(E, k) : W ? s[z] = np(E) : ee && (s[z] = np(k))
        } else if (z === "style") {
          const W = typeof E == "object",
            ee = typeof k == "object",
            $ = typeof E == "string",
            se = typeof k == "string";
          if (W && ee) s[z] = {
            ...E,
            ...k
          };
          else if (W && se) {
            const _e = ep(k);
            s[z] = {
              ...E,
              ..._e
            }
          } else if ($ && ee) {
            const _e = ep(E);
            s[z] = {
              ..._e,
              ...k
            }
          } else if ($ && se) {
            const _e = ep(E),
              ge = ep(k);
            s[z] = {
              ..._e,
              ...ge
            }
          } else W ? s[z] = E : ee ? s[z] = k : $ ? s[z] = E : se && (s[z] = k)
        } else s[z] = k !== void 0 ? k : E
      }
      for (const z of Object.getOwnPropertySymbols(x)) {
        const E = s[z],
          k = x[z];
        s[z] = k !== void 0 ? k : E
      }
    }
  }
  return typeof s.style == "object" && (s.style = ry(s.style).replaceAll(`
`, " ")), s.hidden === !1 && (s.hidden = void 0, delete s.hidden), s.disabled === !1 && (s.disabled = void 0, delete s.disabled), s
}
const ny = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
ry(ny);
const sge = typeof window < "u" ? window : void 0;

function lge(p) {
  let s = p.activeElement;
  for (; s != null && s.shadowRoot;) {
    const r = s.shadowRoot.activeElement;
    if (r === s) break;
    s = r
  }
  return s
}
var Ic, nh;
class cge {
  constructor(s = {}) {
    wn(this, Ic);
    wn(this, nh);
    const {
      window: r = sge,
      document: x = r == null ? void 0 : r.document
    } = s;
    r !== void 0 && (Ma(this, Ic, x), Ma(this, nh, n0(z => {
      const E = _p(r, "focusin", z),
        k = _p(r, "focusout", z);
      return () => {
        E(), k()
      }
    })))
  }
  get current() {
    var s;
    return (s = ir(this, nh)) == null || s.call(this), ir(this, Ic) ? lge(ir(this, Ic)) : null
  }
}
Ic = new WeakMap, nh = new WeakMap;
new cge;
var ih, us;
class hm {
  constructor(s) {
    wn(this, ih);
    wn(this, us);
    Ma(this, ih, s), Ma(this, us, Symbol(s))
  }
  get key() {
    return ir(this, us)
  }
  exists() {
    return Rx(ir(this, us))
  }
  get() {
    const s = lv(ir(this, us));
    if (s === void 0) throw new Error(`Context "${ir(this,ih)}" not found`);
    return s
  }
  getOr(s) {
    const r = lv(ir(this, us));
    return r === void 0 ? s : r
  }
  set(s) {
    return jx(ir(this, us), s)
  }
}
ih = new WeakMap, us = new WeakMap;

function uge(p, s) {
  switch (p) {
    case "post":
      cn(s);
      break;
    case "pre":
      q_(s);
      break
  }
}

function iy(p, s, r, x = {}) {
  const {
    lazy: z = !1
  } = x;
  let E = !z,
    k = Array.isArray(p) ? [] : void 0;
  uge(s, () => {
    const l = Array.isArray(p) ? p.map(W => W()) : p();
    if (!E) {
      E = !0, k = l;
      return
    }
    const F = Ca(() => r(l, k));
    return k = l, F
  })
}

function Lc(p, s, r) {
  iy(p, "post", s, r)
}

function hge(p, s, r) {
  iy(p, "pre", s, r)
}
Lc.pre = hge;

function dge(p, s) {
  return setTimeout(s, p)
}

function xc(p) {
  N_().then(p)
}

function ms(p, s) {
  return {
    [Z1()]: r => Lme(p) ? (p.current = r, Ca(() => s == null ? void 0 : s(r)), () => {
      "isConnected" in r && r.isConnected || (p.current = null, s == null || s(null))
    }) : (p(r), Ca(() => s == null ? void 0 : s(r)), () => {
      "isConnected" in r && r.isConnected || (p(null), s == null || s(null))
    })
  }
}

function g_(p) {
  return p ? "true" : "false"
}

function Uv(p) {
  return p ? "" : void 0
}
var Cc, ah;
class pge {
  constructor(s) {
    wn(this, Cc);
    wn(this, ah);
    mn(this, "attrs");
    Ma(this, Cc, s.getVariant ? s.getVariant() : null), Ma(this, ah, ir(this, Cc) ? `data-${ir(this,Cc)}-` : `data-${s.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(s.parts.map(r => [r, this.getAttr(r)]))
  }
  getAttr(s, r) {
    return r ? `data-${r}-${s}` : `${ir(this,ah)}${s}`
  }
  selector(s, r) {
    return `[${this.getAttr(s,r)}]`
  }
}
Cc = new WeakMap, ah = new WeakMap;

function fge(p) {
  const s = new pge(p);
  return {
    ...s.attrs,
    selector: s.selector,
    getAttr: s.getAttr
  }
}
const _ge = "ArrowDown",
  mge = "ArrowLeft",
  gge = "ArrowRight",
  vge = "ArrowUp",
  yge = "End",
  bge = "Enter",
  xge = "Home",
  wge = "p",
  kge = "n",
  Tge = "j",
  Sge = "k",
  Pge = "h",
  Mge = "l";

function v_() {}

function gs(p, s) {
  return `bits-${p}`
}

function Ige(p) {
  if (!p) return null;
  for (const s of p.childNodes)
    if (s.nodeType !== Node.COMMENT_NODE) return s;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function Cge(p = "bits") {
  return globalThis.bitsIdCounter.current++, `${p}-${globalThis.bitsIdCounter.current}`
}

function zge(p, s) {
  let r = p.nextElementSibling;
  for (; r;) {
    if (r.matches(s)) return r;
    r = r.nextElementSibling
  }
}

function Age(p, s) {
  let r = p.previousElementSibling;
  for (; r;) {
    if (r.matches(s)) return r;
    r = r.previousElementSibling
  }
}

function ay(p) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(p);
  const s = p.length;
  let r = -1,
    x, z = "";
  const E = p.charCodeAt(0);
  if (s === 1 && E === 45) return "\\" + p;
  for (; ++r < s;) {
    if (x = p.charCodeAt(r), x === 0) {
      z += "ï¿½";
      continue
    }
    if (x >= 1 && x <= 31 || x === 127 || r === 0 && x >= 48 && x <= 57 || r === 1 && x >= 48 && x <= 57 && E === 45) {
      z += "\\" + x.toString(16) + " ";
      continue
    }
    if (x >= 128 || x === 45 || x === 95 || x >= 48 && x <= 57 || x >= 65 && x <= 90 || x >= 97 && x <= 122) {
      z += p.charAt(r);
      continue
    }
    z += "\\" + p.charAt(r)
  }
  return z
}
const fl = "data-value",
  Fa = fge({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  wc = Fa.selector("group"),
  Yf = Fa.selector("group-items"),
  Zv = Fa.selector("group-heading"),
  oy = Fa.selector("item"),
  Kf = `${Fa.selector("item")}:not([aria-disabled="true"])`,
  xl = new hm("Command.Root"),
  Ege = new hm("Command.List"),
  Ju = new hm("Command.Group"),
  Gv = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var zc, Ac, oh, sh, lh, ch, uh, hh, Gr, sy, hp, b_, dp, pp, fp, js, ly, cy, x_, Wu, w_, k_, uy, Hu, T_, S_, hy, $u, Xu, dh;
const mm = class mm {
  constructor(s) {
    wn(this, Gr);
    mn(this, "opts");
    mn(this, "attachment");
    wn(this, zc, !1);
    wn(this, Ac, !0);
    mn(this, "sortAfterTick", !1);
    mn(this, "sortAndFilterAfterTick", !1);
    mn(this, "allItems", new Set);
    mn(this, "allGroups", new Map);
    mn(this, "allIds", new Map);
    wn(this, oh, Je(0));
    wn(this, sh, Je(null));
    wn(this, lh, Je(null));
    wn(this, ch, Je(null));
    wn(this, uh, Je(Gv));
    wn(this, hh, Je(yi(Gv)));
    wn(this, dh, mt(() => ({
      id: this.opts.id.current,
      role: "application",
      [Fa.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = s, this.attachment = ms(this.opts.ref);
    const r = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = r, this.commandState = r, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(s) {
    return xl.set(new mm(s))
  }
  get key() {
    return g(ir(this, oh))
  }
  set key(s) {
    H(ir(this, oh), s, !0)
  }
  get viewportNode() {
    return g(ir(this, sh))
  }
  set viewportNode(s) {
    H(ir(this, sh), s, !0)
  }
  get inputNode() {
    return g(ir(this, lh))
  }
  set inputNode(s) {
    H(ir(this, lh), s, !0)
  }
  get labelNode() {
    return g(ir(this, ch))
  }
  set labelNode(s) {
    H(ir(this, ch), s, !0)
  }
  get commandState() {
    return g(ir(this, uh))
  }
  set commandState(s) {
    H(ir(this, uh), s)
  }
  get _commandState() {
    return g(ir(this, hh))
  }
  set _commandState(s) {
    H(ir(this, hh), s, !0)
  }
  setState(s, r, x) {
    Object.is(this._commandState[s], r) || (this._commandState[s] = r, s === "search" ? (sn(this, Gr, fp).call(this), sn(this, Gr, dp).call(this)) : s === "value" && (x || sn(this, Gr, ly).call(this)), sn(this, Gr, hp).call(this))
  }
  setValue(s, r) {
    s !== this.opts.value.current && s === "" && xc(() => {
      this.key++
    }), this.setState("value", s, r), this.opts.value.current = s
  }
  getValidItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(Kf)).filter(x => !!x) : []
  }
  getVisibleItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(oy)).filter(x => !!x) : []
  }
  get itemsGrid() {
    var l, F, W, ee;
    if (!this.isGrid) return [];
    const s = this.opts.columns.current ?? 1,
      r = this.getVisibleItems(),
      x = [
        []
      ];
    let z = (l = r[0]) == null ? void 0 : l.getAttribute("data-group"),
      E = 0,
      k = 0;
    for (let $ = 0; $ < r.length; $++) {
      const se = r[$],
        _e = se == null ? void 0 : se.getAttribute("data-group");
      z !== _e ? (z = _e, E = 1, k++, x.push([{
        index: $,
        firstRowOfGroup: !0,
        ref: se
      }])) : (E++, E > s && (k++, E = 1, x.push([])), (ee = x[k]) == null || ee.push({
        index: $,
        firstRowOfGroup: ((W = (F = x[k]) == null ? void 0 : F[0]) == null ? void 0 : W.firstRowOfGroup) ?? $ === 0,
        ref: se
      }))
    }
    return x
  }
  updateSelectedToIndex(s) {
    const r = this.getValidItems()[s];
    r && this.setValue(r.getAttribute(fl) ?? "")
  }
  updateSelectedByItem(s) {
    const r = sn(this, Gr, js).call(this),
      x = this.getValidItems(),
      z = x.findIndex(k => k === r);
    let E = x[z + s];
    this.opts.loop.current && (E = z + s < 0 ? x[x.length - 1] : z + s === x.length ? x[0] : x[z + s]), E && this.setValue(E.getAttribute(fl) ?? "")
  }
  updateSelectedByGroup(s) {
    const r = sn(this, Gr, js).call(this);
    let x = r == null ? void 0 : r.closest(wc),
      z;
    for (; x && !z;) x = s > 0 ? zge(x, wc) : Age(x, wc), z = x == null ? void 0 : x.querySelector(Kf);
    z ? this.setValue(z.getAttribute(fl) ?? "") : this.updateSelectedByItem(s)
  }
  registerValue(s, r) {
    var x;
    return s && s === ((x = this.allIds.get(s)) == null ? void 0 : x.value) || this.allIds.set(s, {
      value: s,
      keywords: r
    }), this._commandState.filtered.items.set(s, sn(this, Gr, b_).call(this, s, r)), this.sortAfterTick || (this.sortAfterTick = !0, xc(() => {
      sn(this, Gr, dp).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(s)
    }
  }
  registerItem(s, r) {
    return this.allItems.add(s), r && (this.allGroups.has(r) ? this.allGroups.get(r).add(s) : this.allGroups.set(r, new Set([s]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, xc(() => {
      sn(this, Gr, fp).call(this), sn(this, Gr, dp).call(this), this.sortAndFilterAfterTick = !1
    })), sn(this, Gr, hp).call(this), () => {
      const x = sn(this, Gr, js).call(this);
      this.allItems.delete(s), this.commandState.filtered.items.delete(s), sn(this, Gr, fp).call(this), (x == null ? void 0 : x.getAttribute("id")) === s && sn(this, Gr, pp).call(this), sn(this, Gr, hp).call(this)
    }
  }
  registerGroup(s) {
    return this.allGroups.has(s) || this.allGroups.set(s, new Set), () => {
      this.allIds.delete(s), this.allGroups.delete(s)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(s) {
    const r = this.opts.vimBindings.current && s.ctrlKey;
    switch (s.key) {
      case kge:
      case Tge: {
        r && (this.isGrid ? sn(this, Gr, w_).call(this, s) : sn(this, Gr, Wu).call(this, s));
        break
      }
      case Mge: {
        r && this.isGrid && sn(this, Gr, Wu).call(this, s);
        break
      }
      case _ge:
        this.isGrid ? sn(this, Gr, w_).call(this, s) : sn(this, Gr, Wu).call(this, s);
        break;
      case gge:
        if (!this.isGrid) break;
        sn(this, Gr, Wu).call(this, s);
        break;
      case wge:
      case Sge: {
        r && (this.isGrid ? sn(this, Gr, S_).call(this, s) : sn(this, Gr, Xu).call(this, s));
        break
      }
      case Pge: {
        r && this.isGrid && sn(this, Gr, Xu).call(this, s);
        break
      }
      case vge:
        this.isGrid ? sn(this, Gr, S_).call(this, s) : sn(this, Gr, Xu).call(this, s);
        break;
      case mge:
        if (!this.isGrid) break;
        sn(this, Gr, Xu).call(this, s);
        break;
      case xge:
        s.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case yge:
        s.preventDefault(), sn(this, Gr, x_).call(this);
        break;
      case bge:
        if (!s.isComposing && s.keyCode !== 229) {
          s.preventDefault();
          const x = sn(this, Gr, js).call(this);
          x && (x == null || x.click())
        }
    }
  }
  get props() {
    return g(ir(this, dh))
  }
  set props(s) {
    H(ir(this, dh), s)
  }
};
zc = new WeakMap, Ac = new WeakMap, oh = new WeakMap, sh = new WeakMap, lh = new WeakMap, ch = new WeakMap, uh = new WeakMap, hh = new WeakMap, Gr = new WeakSet, sy = function() {
  return U1(this._commandState)
}, hp = function() {
  ir(this, zc) || (Ma(this, zc, !0), xc(() => {
    var x, z;
    Ma(this, zc, !1);
    const s = sn(this, Gr, sy).call(this);
    !Object.is(this.commandState, s) && (this.commandState = s, (z = (x = this.opts.onStateChange) == null ? void 0 : x.current) == null || z.call(x, s))
  }))
}, b_ = function(s, r) {
  const x = this.opts.filter.current ?? fy;
  return s ? x(s, this._commandState.search, r) : 0
}, dp = function() {
  var k;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    (!this._commandState.value || !ir(this, Ac)) && sn(this, Gr, pp).call(this);
    return
  }
  const s = this._commandState.filtered.items,
    r = [];
  for (const l of this._commandState.filtered.groups) {
    const F = this.allGroups.get(l);
    let W = 0;
    if (!F) {
      r.push([l, W]);
      continue
    }
    for (const ee of F) {
      const $ = s.get(ee);
      W = Math.max($ ?? 0, W)
    }
    r.push([l, W])
  }
  const x = this.viewportNode,
    z = this.getValidItems().sort((l, F) => {
      const W = l.getAttribute("data-value"),
        ee = F.getAttribute("data-value"),
        $ = s.get(W) ?? 0;
      return (s.get(ee) ?? 0) - $
    });
  for (const l of z) {
    const F = l.closest(Yf);
    if (F) {
      const W = l.parentElement === F ? l : l.closest(`${Yf} > *`);
      W && F.appendChild(W)
    } else {
      const W = l.parentElement === x ? l : l.closest(`${Yf} > *`);
      W && (x == null || x.appendChild(W))
    }
  }
  const E = r.sort((l, F) => F[1] - l[1]);
  for (const l of E) {
    const F = x == null ? void 0 : x.querySelector(`${wc}[${fl}="${ay(l[0])}"]`);
    (k = F == null ? void 0 : F.parentElement) == null || k.appendChild(F)
  }
  sn(this, Gr, pp).call(this)
}, pp = function() {
  xc(() => {
    const s = this.getValidItems().find(z => z.getAttribute("aria-disabled") !== "true"),
      r = s == null ? void 0 : s.getAttribute(fl),
      x = ir(this, Ac) && this.opts.disableInitialScroll.current;
    this.setValue(r ?? "", x), Ma(this, Ac, !1)
  })
}, fp = function() {
  var r, x;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let s = 0;
  for (const z of this.allItems) {
    const E = ((r = this.allIds.get(z)) == null ? void 0 : r.value) ?? "",
      k = ((x = this.allIds.get(z)) == null ? void 0 : x.keywords) ?? [],
      l = sn(this, Gr, b_).call(this, E, k);
    this._commandState.filtered.items.set(z, l), l > 0 && s++
  }
  for (const [z, E] of this.allGroups)
    for (const k of E) {
      const l = this._commandState.filtered.items.get(k);
      if (l && l > 0) {
        this._commandState.filtered.groups.add(z);
        break
      }
    }
  this._commandState.filtered.count = s
}, js = function() {
  const s = this.opts.ref.current;
  if (!s) return;
  const r = s.querySelector(`${Kf}[data-selected]`);
  if (r) return r
}, ly = function() {
  xc(() => {
    var x, z, E, k, l;
    const s = sn(this, Gr, js).call(this);
    if (!s) return;
    const r = (x = s.parentElement) == null ? void 0 : x.parentElement;
    if (r) {
      if (this.isGrid) {
        const F = sn(this, Gr, cy).call(this, s);
        if (s.scrollIntoView({
            block: "nearest"
          }), F) {
          const W = (z = s == null ? void 0 : s.closest(wc)) == null ? void 0 : z.querySelector(Zv);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const F = Ige(r);
        if (F && ((E = F.dataset) == null ? void 0 : E.value) === ((k = s.dataset) == null ? void 0 : k.value)) {
          const W = (l = s == null ? void 0 : s.closest(wc)) == null ? void 0 : l.querySelector(Zv);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      s.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, cy = function(s) {
  const r = this.itemsGrid;
  if (r.length === 0) return !1;
  for (let x = 0; x < r.length; x++) {
    const z = r[x];
    if (z !== void 0)
      for (let E = 0; E < z.length; E++) {
        const k = z[E];
        if (!(k === void 0 || k.ref !== s)) return k.firstRowOfGroup
      }
  }
  return !1
}, x_ = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Wu = function(s) {
  s.preventDefault(), s.metaKey ? sn(this, Gr, x_).call(this) : s.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, w_ = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(sn(this, Gr, uy).call(this, s)))
}, k_ = function(s, r) {
  if (r.length === 0) return null;
  for (let x = 0; x < r.length; x++) {
    const z = r[x];
    if (z !== void 0)
      for (let E = 0; E < z.length; E++) {
        const k = z[E];
        if (!(k === void 0 || k.ref !== s)) return {
          columnIndex: E,
          rowIndex: x
        }
      }
  }
  return null
}, uy = function(s) {
  const r = this.itemsGrid,
    x = sn(this, Gr, js).call(this);
  if (!x) return 0;
  const z = sn(this, Gr, k_).call(this, x, r);
  if (!z) return 0;
  let E = null;
  const k = s.altKey ? 1 : 0;
  if (s.altKey && z.rowIndex === r.length - 2 && !this.opts.loop.current) E = sn(this, Gr, Hu).call(this, {
    start: r.length - 1,
    end: r.length,
    expectedColumnIndex: z.columnIndex,
    grid: r
  });
  else if (z.rowIndex === r.length - 1) {
    if (!this.opts.loop.current) return 0;
    E = sn(this, Gr, Hu).call(this, {
      start: 0 + k,
      end: z.rowIndex,
      expectedColumnIndex: z.columnIndex,
      grid: r
    })
  } else E = sn(this, Gr, Hu).call(this, {
    start: z.rowIndex + 1 + k,
    end: r.length,
    expectedColumnIndex: z.columnIndex,
    grid: r
  }), E === null && this.opts.loop.current && (E = sn(this, Gr, Hu).call(this, {
    start: 0,
    end: z.rowIndex,
    expectedColumnIndex: z.columnIndex,
    grid: r
  }));
  return sn(this, Gr, T_).call(this, x, E)
}, Hu = function({
  start: s,
  end: r,
  grid: x,
  expectedColumnIndex: z
}) {
  var k;
  let E = null;
  for (let l = s; l < r; l++) {
    const F = x[l];
    if (E = ((k = F[z]) == null ? void 0 : k.ref) ?? null, E !== null && tp(E)) {
      E = null;
      continue
    }
    if (E === null)
      for (let W = F.length - 1; W >= 0; W--) {
        const ee = F[F.length - 1];
        if (!(ee === void 0 || tp(ee.ref))) {
          E = ee.ref;
          break
        }
      }
    break
  }
  return E
}, T_ = function(s, r) {
  if (r === null) return 0;
  const x = this.getValidItems(),
    z = x.findIndex(k => k === s);
  return x.findIndex(k => k === r) - z
}, S_ = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(sn(this, Gr, hy).call(this, s)))
}, hy = function(s) {
  const r = this.itemsGrid,
    x = sn(this, Gr, js).call(this);
  if (x === void 0) return 0;
  const z = sn(this, Gr, k_).call(this, x, r);
  if (z === null) return 0;
  let E = null;
  const k = s.altKey ? 1 : 0;
  if (s.altKey && z.rowIndex === 1 && this.opts.loop.current === !1) E = sn(this, Gr, $u).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: z.columnIndex,
    grid: r
  });
  else if (z.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    E = sn(this, Gr, $u).call(this, {
      start: r.length - 1 - k,
      end: z.rowIndex + 1,
      expectedColumnIndex: z.columnIndex,
      grid: r
    })
  } else E = sn(this, Gr, $u).call(this, {
    start: z.rowIndex - 1 - k,
    end: 0,
    expectedColumnIndex: z.columnIndex,
    grid: r
  }), E === null && this.opts.loop.current && (E = sn(this, Gr, $u).call(this, {
    start: r.length - 1,
    end: z.rowIndex + 1,
    expectedColumnIndex: z.columnIndex,
    grid: r
  }));
  return sn(this, Gr, T_).call(this, x, E)
}, $u = function({
  start: s,
  end: r,
  grid: x,
  expectedColumnIndex: z
}) {
  var k;
  let E = null;
  for (let l = s; l >= r; l--) {
    const F = x[l];
    if (F !== void 0) {
      if (E = ((k = F[z]) == null ? void 0 : k.ref) ?? null, E !== null && tp(E)) {
        E = null;
        continue
      }
      if (E === null)
        for (let W = F.length - 1; W >= 0; W--) {
          const ee = F[F.length - 1];
          if (!(ee === void 0 || tp(ee.ref))) {
            E = ee.ref;
            break
          }
        }
      break
    }
  }
  return E
}, Xu = function(s) {
  s.preventDefault(), s.metaKey ? this.updateSelectedToIndex(0) : s.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, dh = new WeakMap;
let y_ = mm;

function tp(p) {
  return p.getAttribute("aria-disabled") === "true"
}
var ph, fh, _h;
const gm = class gm {
  constructor(s, r) {
    mn(this, "opts");
    mn(this, "root");
    mn(this, "attachment");
    wn(this, ph, mt(() => this.root._commandState.filtered.count === 0 && ir(this, fh) === !1 || this.opts.forceMount.current));
    wn(this, fh, !0);
    wn(this, _h, mt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [Fa.empty]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = r, this.attachment = ms(this.opts.ref), q_(() => {
      Ma(this, fh, !1)
    })
  }
  static create(s) {
    return new gm(s, xl.get())
  }
  get shouldRender() {
    return g(ir(this, ph))
  }
  set shouldRender(s) {
    H(ir(this, ph), s)
  }
  get props() {
    return g(ir(this, _h))
  }
  set props(s) {
    H(ir(this, _h), s)
  }
};
ph = new WeakMap, fh = new WeakMap, _h = new WeakMap;
let P_ = gm;
var mh, gh, vh, yh;
const vm = class vm {
  constructor(s, r) {
    mn(this, "opts");
    mn(this, "root");
    mn(this, "attachment");
    wn(this, mh, mt(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    wn(this, gh, Je(null));
    wn(this, vh, Je(""));
    wn(this, yh, mt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [Fa.group]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = r, this.attachment = ms(this.opts.ref), this.trueValue = s.value.current ?? s.id.current, Lc(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), cn(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(s) {
    return Ju.set(new vm(s, xl.get()))
  }
  get shouldRender() {
    return g(ir(this, mh))
  }
  set shouldRender(s) {
    H(ir(this, mh), s)
  }
  get headingNode() {
    return g(ir(this, gh))
  }
  set headingNode(s) {
    H(ir(this, gh), s, !0)
  }
  get trueValue() {
    return g(ir(this, vh))
  }
  set trueValue(s) {
    H(ir(this, vh), s, !0)
  }
  get props() {
    return g(ir(this, yh))
  }
  set props(s) {
    H(ir(this, yh), s)
  }
};
mh = new WeakMap, gh = new WeakMap, vh = new WeakMap, yh = new WeakMap;
let M_ = vm;
var bh;
const ym = class ym {
  constructor(s, r) {
    mn(this, "opts");
    mn(this, "group");
    mn(this, "attachment");
    wn(this, bh, mt(() => ({
      id: this.opts.id.current,
      [Fa["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = s, this.group = r, this.attachment = ms(this.opts.ref, x => this.group.headingNode = x)
  }
  static create(s) {
    return new ym(s, Ju.get())
  }
  get props() {
    return g(ir(this, bh))
  }
  set props(s) {
    H(ir(this, bh), s)
  }
};
bh = new WeakMap;
let I_ = ym;
var xh;
const bm = class bm {
  constructor(s, r) {
    mn(this, "opts");
    mn(this, "group");
    mn(this, "attachment");
    wn(this, xh, mt(() => {
      var s;
      return {
        id: this.opts.id.current,
        role: "group",
        [Fa["group-items"]]: "",
        "aria-labelledby": ((s = this.group.headingNode) == null ? void 0 : s.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = s, this.group = r, this.attachment = ms(this.opts.ref)
  }
  static create(s) {
    return new bm(s, Ju.get())
  }
  get props() {
    return g(ir(this, xh))
  }
  set props(s) {
    H(ir(this, xh), s)
  }
};
xh = new WeakMap;
let C_ = bm;
var Pp, wh;
const xm = class xm {
  constructor(s, r) {
    mn(this, "opts");
    mn(this, "root");
    mn(this, "attachment");
    wn(this, Pp, mt(() => {
      var r;
      const s = (r = this.root.viewportNode) == null ? void 0 : r.querySelector(`${oy}[${fl}="${ay(this.root.opts.value.current)}"]`);
      if (s != null) return s.getAttribute("id") ?? void 0
    }));
    wn(this, wh, mt(() => {
      var s, r;
      return {
        id: this.opts.id.current,
        type: "text",
        [Fa.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": g_(!0),
        "aria-controls": ((s = this.root.viewportNode) == null ? void 0 : s.id) ?? void 0,
        "aria-labelledby": ((r = this.root.labelNode) == null ? void 0 : r.id) ?? void 0,
        "aria-activedescendant": g(ir(this, Pp)),
        ...this.attachment
      }
    }));
    this.opts = s, this.root = r, this.attachment = ms(this.opts.ref, x => this.root.inputNode = x), Lc(() => this.opts.ref.current, () => {
      const x = this.opts.ref.current;
      x && this.opts.autofocus.current && dge(10, () => x.focus())
    }), Lc(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(s) {
    return new xm(s, xl.get())
  }
  get props() {
    return g(ir(this, wh))
  }
  set props(s) {
    H(ir(this, wh), s)
  }
};
Pp = new WeakMap, wh = new WeakMap;
let z_ = xm;
var Bs, Mp, kh, Th, Sh, vl, dy, E_, Ph;
const wm = class wm {
  constructor(s, r) {
    wn(this, vl);
    mn(this, "opts");
    mn(this, "root");
    mn(this, "attachment");
    wn(this, Bs, null);
    wn(this, Mp, mt(() => {
      var s;
      return this.opts.forceMount.current || ((s = ir(this, Bs)) == null ? void 0 : s.opts.forceMount.current) === !0
    }));
    wn(this, kh, mt(() => {
      if (this.opts.ref.current, g(ir(this, Mp)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const s = this.root.commandState.filtered.items.get(this.trueValue);
      return s === void 0 ? !1 : s > 0
    }));
    wn(this, Th, mt(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    wn(this, Sh, Je(""));
    wn(this, Ph, mt(() => {
      var s;
      return {
        id: this.opts.id.current,
        "aria-disabled": g_(this.opts.disabled.current),
        "aria-selected": g_(this.isSelected),
        "data-disabled": Uv(this.opts.disabled.current),
        "data-selected": Uv(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (s = ir(this, Bs)) == null ? void 0 : s.trueValue,
        [Fa.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = r, Ma(this, Bs, Ju.getOr(null)), this.trueValue = s.value.current, this.attachment = ms(this.opts.ref), Lc([() => this.trueValue, () => {
      var x;
      return (x = ir(this, Bs)) == null ? void 0 : x.trueValue
    }, () => this.opts.forceMount.current], () => {
      var x;
      if (!(this.opts.forceMount.current || !this.trueValue)) return this.root.registerItem(this.trueValue, (x = ir(this, Bs)) == null ? void 0 : x.trueValue)
    }), Lc([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var x, z;
      this.opts.value.current ? this.trueValue = this.opts.value.current : (x = this.opts.ref.current) != null && x.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, s.keywords.current.map(E => E.trim())), (z = this.opts.ref.current) == null || z.setAttribute(fl, this.trueValue))
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(s) {
    const r = Ju.getOr(null);
    return new wm({
      ...s,
      group: r
    }, xl.get())
  }
  get shouldRender() {
    return g(ir(this, kh))
  }
  set shouldRender(s) {
    H(ir(this, kh), s)
  }
  get isSelected() {
    return g(ir(this, Th))
  }
  set isSelected(s) {
    H(ir(this, Th), s)
  }
  get trueValue() {
    return g(ir(this, Sh))
  }
  set trueValue(s) {
    H(ir(this, Sh), s, !0)
  }
  onpointermove(s) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || sn(this, vl, E_).call(this)
  }
  onclick(s) {
    this.opts.disabled.current || sn(this, vl, dy).call(this)
  }
  get props() {
    return g(ir(this, Ph))
  }
  set props(s) {
    H(ir(this, Ph), s)
  }
};
Bs = new WeakMap, Mp = new WeakMap, kh = new WeakMap, Th = new WeakMap, Sh = new WeakMap, vl = new WeakSet, dy = function() {
  var s;
  this.opts.disabled.current || (sn(this, vl, E_).call(this), (s = this.opts.onSelect) == null || s.current())
}, E_ = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, Ph = new WeakMap;
let A_ = wm;
var Mh;
const km = class km {
  constructor(s, r) {
    mn(this, "opts");
    mn(this, "root");
    mn(this, "attachment");
    wn(this, Mh, mt(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [Fa.list]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = r, this.attachment = ms(this.opts.ref)
  }
  static create(s) {
    return Ege.set(new km(s, xl.get()))
  }
  get props() {
    return g(ir(this, Mh))
  }
  set props(s) {
    H(ir(this, Mh), s)
  }
};
Mh = new WeakMap;
let L_ = km;
var Ih;
const Tm = class Tm {
  constructor(s, r) {
    mn(this, "opts");
    mn(this, "root");
    mn(this, "attachment");
    wn(this, Ih, mt(() => {
      var s;
      return {
        id: this.opts.id.current,
        [Fa["input-label"]]: "",
        for: (s = this.opts.for) == null ? void 0 : s.current,
        style: ny,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = r, this.attachment = ms(this.opts.ref, x => this.root.labelNode = x)
  }
  static create(s) {
    return new Tm(s, xl.get())
  }
  get props() {
    return g(ir(this, Ih))
  }
  set props(s) {
    H(ir(this, Ih), s)
  }
};
Ih = new WeakMap;
let D_ = Tm;
var Lge = he("<label><!></label>");

function Dge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "id", 19, () => gs(r)),
    z = nr(s, "ref", 15, null),
    E = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const k = D_.create({
      id: Vn(() => x()),
      ref: Vn(() => z(), ee => z(ee))
    }),
    l = mt(() => _s(E, k.props));
  var F = Lge();
  Dr(F, () => ({
    ...g(l)
  }));
  var W = M(F);
  qi(W, () => s.children ?? Qa), S(F), q(p, F), an()
}
var Rge = he("<!> <!>", 1),
  jge = he("<div><!> <!></div>");

function Fge(p, s) {
  const r = fs();
  nn(s, !0);
  const x = et => {
    Dge(et, {
      children: (We, _t) => {
        bn();
        var Vt = Oi();
        Re(() => te(Vt, se())), q(We, Vt)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let z = nr(s, "id", 19, () => gs(r)),
    E = nr(s, "ref", 15, null),
    k = nr(s, "value", 15, ""),
    l = nr(s, "onValueChange", 3, v_),
    F = nr(s, "onStateChange", 3, v_),
    W = nr(s, "loop", 3, !1),
    ee = nr(s, "shouldFilter", 3, !0),
    $ = nr(s, "filter", 3, fy),
    se = nr(s, "label", 3, ""),
    _e = nr(s, "vimBindings", 3, !0),
    ge = nr(s, "disablePointerSelection", 3, !1),
    V = nr(s, "disableInitialScroll", 3, !1),
    Me = nr(s, "columns", 3, null),
    we = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const Fe = y_.create({
      id: Vn(() => z()),
      ref: Vn(() => E(), et => E(et)),
      filter: Vn(() => $()),
      shouldFilter: Vn(() => ee()),
      loop: Vn(() => W()),
      value: Vn(() => k(), et => {
        k() !== et && (k(et), l()(et))
      }),
      vimBindings: Vn(() => _e()),
      disablePointerSelection: Vn(() => ge()),
      disableInitialScroll: Vn(() => V()),
      onStateChange: Vn(() => F()),
      columns: Vn(() => Me())
    }),
    be = et => Fe.updateSelectedToIndex(et),
    Xe = et => Fe.updateSelectedByGroup(et),
    tt = et => Fe.updateSelectedByItem(et),
    Ye = () => Fe.getValidItems(),
    Ce = mt(() => _s(we, Fe.props));
  var De = {
      updateSelectedToIndex: be,
      updateSelectedByGroup: Xe,
      updateSelectedByItem: tt,
      getValidItems: Ye
    },
    Ke = Sr(),
    Le = Ct(Ke);
  {
    var Ne = et => {
        var We = Rge(),
          _t = Ct(We);
        x(_t);
        var Vt = D(_t, 2);
        qi(Vt, () => s.child, () => ({
          props: g(Ce)
        })), q(et, We)
      },
      vt = et => {
        var We = jge();
        Dr(We, () => ({
          ...g(Ce)
        }));
        var _t = M(We);
        x(_t);
        var Vt = D(_t, 2);
        qi(Vt, () => s.children ?? Qa), S(We), q(et, We)
      };
    Te(Le, et => {
      s.child ? et(Ne) : et(vt, !1)
    })
  }
  return q(p, Ke), an(De)
}
var Bge = he("<div><!></div>");

function Oge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "id", 19, () => gs(r)),
    z = nr(s, "ref", 15, null),
    E = nr(s, "forceMount", 3, !1),
    k = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const l = P_.create({
      id: Vn(() => x()),
      ref: Vn(() => z(), se => z(se)),
      forceMount: Vn(() => E())
    }),
    F = mt(() => _s(l.props, k));
  var W = Sr(),
    ee = Ct(W);
  {
    var $ = se => {
      var _e = Sr(),
        ge = Ct(_e);
      {
        var V = we => {
            var Fe = Sr(),
              be = Ct(Fe);
            qi(be, () => s.child, () => ({
              props: g(F)
            })), q(we, Fe)
          },
          Me = we => {
            var Fe = Bge();
            Dr(Fe, () => ({
              ...g(F)
            }));
            var be = M(Fe);
            qi(be, () => s.children ?? Qa), S(Fe), q(we, Fe)
          };
        Te(ge, we => {
          s.child ? we(V) : we(Me, !1)
        })
      }
      q(se, _e)
    };
    Te(ee, se => {
      l.shouldRender && se($)
    })
  }
  q(p, W), an()
}
var qge = he("<div><!></div>");

function Nge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "id", 19, () => gs(r)),
    z = nr(s, "ref", 15, null),
    E = nr(s, "value", 3, ""),
    k = nr(s, "forceMount", 3, !1),
    l = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const F = M_.create({
      id: Vn(() => x()),
      ref: Vn(() => z(), ge => z(ge)),
      forceMount: Vn(() => k()),
      value: Vn(() => E())
    }),
    W = mt(() => _s(l, F.props));
  var ee = Sr(),
    $ = Ct(ee);
  {
    var se = ge => {
        var V = Sr(),
          Me = Ct(V);
        qi(Me, () => s.child, () => ({
          props: g(W)
        })), q(ge, V)
      },
      _e = ge => {
        var V = qge();
        Dr(V, () => ({
          ...g(W)
        }));
        var Me = M(V);
        qi(Me, () => s.children ?? Qa), S(V), q(ge, V)
      };
    Te($, ge => {
      s.child ? ge(se) : ge(_e, !1)
    })
  }
  q(p, ee), an()
}
var Vge = he("<div><!></div>");

function Uge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "id", 19, () => gs(r)),
    z = nr(s, "ref", 15, null),
    E = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const k = I_.create({
      id: Vn(() => x()),
      ref: Vn(() => z(), se => z(se))
    }),
    l = mt(() => _s(E, k.props));
  var F = Sr(),
    W = Ct(F);
  {
    var ee = se => {
        var _e = Sr(),
          ge = Ct(_e);
        qi(ge, () => s.child, () => ({
          props: g(l)
        })), q(se, _e)
      },
      $ = se => {
        var _e = Vge();
        Dr(_e, () => ({
          ...g(l)
        }));
        var ge = M(_e);
        qi(ge, () => s.children ?? Qa), S(_e), q(se, _e)
      };
    Te(W, se => {
      s.child ? se(ee) : se($, !1)
    })
  }
  q(p, F), an()
}
var Zge = he("<div><!></div>"),
  Gge = he('<div style="display: contents;"><!></div>');

function Wge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "id", 19, () => gs(r)),
    z = nr(s, "ref", 15, null),
    E = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const k = C_.create({
      id: Vn(() => x()),
      ref: Vn(() => z(), se => z(se))
    }),
    l = mt(() => _s(E, k.props));
  var F = Gge(),
    W = M(F);
  {
    var ee = se => {
        var _e = Sr(),
          ge = Ct(_e);
        qi(ge, () => s.child, () => ({
          props: g(l)
        })), q(se, _e)
      },
      $ = se => {
        var _e = Zge();
        Dr(_e, () => ({
          ...g(l)
        }));
        var ge = M(_e);
        qi(ge, () => s.children ?? Qa), S(_e), q(se, _e)
      };
    Te(W, se => {
      s.child ? se(ee) : se($, !1)
    })
  }
  S(F), q(p, F), an()
}
var Hge = he("<input/>");

function $ge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "value", 15, ""),
    z = nr(s, "autofocus", 3, !1),
    E = nr(s, "id", 19, () => gs(r)),
    k = nr(s, "ref", 15, null),
    l = Er(s, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const F = z_.create({
      id: Vn(() => E()),
      ref: Vn(() => k(), ge => k(ge)),
      value: Vn(() => x(), ge => {
        x(ge)
      }),
      autofocus: Vn(() => z() ?? !1)
    }),
    W = mt(() => _s(l, F.props));
  var ee = Sr(),
    $ = Ct(ee);
  {
    var se = ge => {
        var V = Sr(),
          Me = Ct(V);
        qi(Me, () => s.child, () => ({
          props: g(W)
        })), q(ge, V)
      },
      _e = ge => {
        var V = Hge();
        Dr(V, () => ({
          ...g(W)
        }), void 0, void 0, void 0, void 0, !0), yl(V, x), q(ge, V)
      };
    Te($, ge => {
      s.child ? ge(se) : ge(_e, !1)
    })
  }
  q(p, ee), an()
}
var Xge = he("<div><!></div>"),
  Yge = he('<div style="display: contents;" data-item-wrapper=""><!></div>');

function Kge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "id", 19, () => gs(r)),
    z = nr(s, "ref", 15, null),
    E = nr(s, "value", 3, ""),
    k = nr(s, "disabled", 3, !1),
    l = nr(s, "onSelect", 3, v_),
    F = nr(s, "forceMount", 3, !1),
    W = nr(s, "keywords", 19, () => []),
    ee = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const $ = A_.create({
      id: Vn(() => x()),
      ref: Vn(() => z(), V => z(V)),
      value: Vn(() => E()),
      disabled: Vn(() => k()),
      onSelect: Vn(() => l()),
      forceMount: Vn(() => F()),
      keywords: Vn(() => W())
    }),
    se = mt(() => _s(ee, $.props));
  var _e = Sr(),
    ge = Ct(_e);
  Ec(ge, () => $.root.key, V => {
    var Me = Yge(),
      we = M(Me);
    {
      var Fe = be => {
        var Xe = Sr(),
          tt = Ct(Xe);
        {
          var Ye = De => {
              var Ke = Sr(),
                Le = Ct(Ke);
              qi(Le, () => s.child, () => ({
                props: g(se)
              })), q(De, Ke)
            },
            Ce = De => {
              var Ke = Xge();
              Dr(Ke, () => ({
                ...g(se)
              }));
              var Le = M(Ke);
              qi(Le, () => s.children ?? Qa), S(Ke), q(De, Ke)
            };
          Te(tt, De => {
            s.child ? De(Ye) : De(Ce, !1)
          })
        }
        q(be, Xe)
      };
      Te(we, be => {
        $.shouldRender && be(Fe)
      })
    }
    S(Me), Re(() => er(Me, "data-value", $.trueValue)), q(V, Me)
  }), q(p, _e), an()
}
var Jge = he("<div><!></div>");

function Qge(p, s) {
  const r = fs();
  nn(s, !0);
  let x = nr(s, "id", 19, () => gs(r)),
    z = nr(s, "ref", 15, null),
    E = Er(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const k = L_.create({
      id: Vn(() => x()),
      ref: Vn(() => z(), ee => z(ee)),
      ariaLabel: Vn(() => s["aria-label"] ?? "Suggestions...")
    }),
    l = mt(() => _s(E, k.props));
  var F = Sr(),
    W = Ct(F);
  Ec(W, () => k.root._commandState.search === "", ee => {
    var $ = Sr(),
      se = Ct($);
    {
      var _e = V => {
          var Me = Sr(),
            we = Ct(Me);
          qi(we, () => s.child, () => ({
            props: g(l)
          })), q(V, Me)
        },
        ge = V => {
          var Me = Jge();
          Dr(Me, () => ({
            ...g(l)
          }));
          var we = M(Me);
          qi(we, () => s.children ?? Qa), S(Me), q(V, Me)
        };
      Te(se, V => {
        s.child ? V(_e) : V(ge, !1)
      })
    }
    q(ee, $)
  }), q(p, F), an()
}
const Wv = 1,
  eve = .9,
  tve = .8,
  rve = .17,
  Jf = .1,
  Qf = .999,
  nve = .9999,
  ive = .99,
  ave = /[\\/_+.#"@[({&]/,
  ove = /[\\/_+.#"@[({&]/g,
  sve = /[\s-]/,
  py = /[\s-]/g;

function R_(p, s, r, x, z, E, k) {
  if (E === s.length) return z === p.length ? Wv : ive;
  const l = `${z},${E}`;
  if (k[l] !== void 0) return k[l];
  const F = x.charAt(E);
  let W = r.indexOf(F, z),
    ee = 0,
    $, se, _e, ge;
  for (; W >= 0;) $ = R_(p, s, r, x, W + 1, E + 1, k), $ > ee && (W === z ? $ *= Wv : ave.test(p.charAt(W - 1)) ? ($ *= tve, _e = p.slice(z, W - 1).match(ove), _e && z > 0 && ($ *= Qf ** _e.length)) : sve.test(p.charAt(W - 1)) ? ($ *= eve, ge = p.slice(z, W - 1).match(py), ge && z > 0 && ($ *= Qf ** ge.length)) : ($ *= rve, z > 0 && ($ *= Qf ** (W - z))), p.charAt(W) !== s.charAt(E) && ($ *= nve)), ($ < Jf && r.charAt(W - 1) === x.charAt(E + 1) || x.charAt(E + 1) === x.charAt(E) && r.charAt(W - 1) !== x.charAt(E)) && (se = R_(p, s, r, x, W + 1, E + 2, k), se * Jf > $ && ($ = se * Jf)), $ > ee && (ee = $), W = r.indexOf(F, W + 1);
  return k[l] = ee, ee
}

function Hv(p) {
  return p.toLowerCase().replace(py, " ")
}

function fy(p, s, r) {
  return p = r && r.length > 0 ? `${`${p} ${r==null?void 0:r.join(" ")}`}` : p, R_(p, s, Hv(p), Hv(s), 0, 0, {})
}

function Fc(...p) {
  return S1(np(p))
}

function lve(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15, null),
    x = nr(s, "value", 15, ""),
    z = Er(s, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var E = Sr(),
    k = Ct(E);
  {
    let l = mt(() => Fc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", s.class));
    ba(k, () => Fge, (F, W) => {
      W(F, Rc({
        "data-slot": "command",
        get class() {
          return g(l)
        }
      }, () => z, {
        get value() {
          return x()
        },
        set value(ee) {
          x(ee)
        },
        get ref() {
          return r()
        },
        set ref(ee) {
          r(ee)
        }
      }))
    })
  }
  q(p, E), an()
}

function cve(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15, null),
    x = Er(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = Sr(),
    E = Ct(z);
  {
    let k = mt(() => Fc("py-6 text-center text-sm", s.class));
    ba(E, () => Oge, (l, F) => {
      F(l, Rc({
        "data-slot": "command-empty",
        get class() {
          return g(k)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref(W) {
          r(W)
        }
      }))
    })
  }
  q(p, z), an()
}
var uve = he("<!> <!>", 1);

function hve(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15, null),
    x = Er(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var z = Sr(),
    E = Ct(z);
  {
    let k = mt(() => Fc("text-foreground overflow-hidden p-1", s.class)),
      l = mt(() => s.value ?? s.heading ?? `----${Cge()}`);
    ba(E, () => Nge, (F, W) => {
      W(F, Rc({
        "data-slot": "command-group",
        get class() {
          return g(k)
        },
        get value() {
          return g(l)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref(ee) {
          r(ee)
        },
        children: (ee, $) => {
          var se = uve(),
            _e = Ct(se);
          {
            var ge = Me => {
              var we = Sr(),
                Fe = Ct(we);
              ba(Fe, () => Uge, (be, Xe) => {
                Xe(be, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (tt, Ye) => {
                    bn();
                    var Ce = Oi();
                    Re(() => te(Ce, s.heading)), q(tt, Ce)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), q(Me, we)
            };
            Te(_e, Me => {
              s.heading && Me(ge)
            })
          }
          var V = D(_e, 2);
          ba(V, () => Wge, (Me, we) => {
            we(Me, {
              get children() {
                return s.children
              }
            })
          }), q(ee, se)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  q(p, z), an()
}

function dve(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15, null),
    x = Er(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = Sr(),
    E = Ct(z);
  {
    let k = mt(() => Fc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", s.class));
    ba(E, () => Kge, (l, F) => {
      F(l, Rc({
        "data-slot": "command-item",
        get class() {
          return g(k)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref(W) {
          r(W)
        }
      }))
    })
  }
  q(p, z), an()
}
var pve = he('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function fve(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15, null),
    x = nr(s, "value", 15, ""),
    z = Er(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var E = pve(),
    k = M(E);
  Qx(k, {
    class: "size-5 opacity-50"
  });
  var l = D(k, 2);
  {
    let F = mt(() => Fc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", s.class));
    ba(l, () => $ge, (W, ee) => {
      ee(W, Rc({
        "data-slot": "command-input",
        get class() {
          return g(F)
        }
      }, () => z, {
        get ref() {
          return r()
        },
        set ref($) {
          r($)
        },
        get value() {
          return x()
        },
        set value($) {
          x($)
        }
      }))
    })
  }
  S(E), q(p, E), an()
}

function _ve(p, s) {
  nn(s, !0);
  let r = nr(s, "ref", 15, null),
    x = Er(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = Sr(),
    E = Ct(z);
  {
    let k = mt(() => Fc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", s.class));
    ba(E, () => Qge, (l, F) => {
      F(l, Rc({
        "data-slot": "command-list",
        get class() {
          return g(k)
        }
      }, () => x, {
        get ref() {
          return r()
        },
        set ref(W) {
          r(W)
        }
      }))
    })
  }
  q(p, z), an()
}
var mve = Yr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function gve(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = mve();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var vve = he("<span> </span> <!>", 1),
  yve = he('<span class="font-flag ml-0.5"> </span> ', 1),
  bve = he('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  xve = he("<!> <!>", 1),
  wve = he("<!> <!>", 1),
  kve = he('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  Tve = he('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function $v(p, s) {
  nn(s, !0);
  let r = nr(s, "countryId", 15, 0),
    x = nr(s, "dropdownDirection", 3, "right"),
    z = Je(null),
    E = Je(null),
    k = Je("");

  function l() {
    N_().then(() => {
      var be;
      (be = document.activeElement) == null || be.blur(), H(k, "")
    })
  }
  var F = Tve(),
    W = M(F),
    ee = M(W),
    $ = M(ee);
  {
    var se = be => {
        var Xe = vve(),
          tt = Ct(Xe),
          Ye = M(tt, !0);
        S(tt);
        var Ce = D(tt, 2);
        gve(Ce, {
          class: "size-3.5"
        }), Re(De => te(Ye, De), [() => Q_()]), q(be, Xe)
      },
      _e = be => {
        const Xe = mt(() => Do(r()));
        var tt = yve(),
          Ye = Ct(tt),
          Ce = M(Ye, !0);
        S(Ye);
        var De = D(Ye);
        Re(() => {
          te(Ce, g(Xe).flag), te(De, ` ${g(Xe).name??""}`)
        }), q(be, tt)
      };
    Te($, be => {
      r() === 0 ? be(se) : be(_e, !1)
    })
  }
  S(ee);
  var ge = D(ee, 2);
  let V;
  var Me = M(ge);
  ba(Me, () => lve, (be, Xe) => {
    Xe(be, {
      children: (tt, Ye) => {
        var Ce = wve(),
          De = Ct(Ce);
        ba(De, () => fve, (Le, Ne) => {
          Ne(Le, {
            placeholder: "Country",
            get ref() {
              return g(z)
            },
            set ref(vt) {
              H(z, vt)
            },
            get value() {
              return g(k)
            },
            set value(vt) {
              H(k, vt, !0)
            }
          })
        });
        var Ke = D(De, 2);
        ba(Ke, () => _ve, (Le, Ne) => {
          Ne(Le, {
            children: (vt, et) => {
              var We = xve(),
                _t = Ct(We);
              ba(_t, () => cve, (Et, Pt) => {
                Pt(Et, {
                  children: (lt, $t) => {
                    bn();
                    var yt = Oi();
                    Re(Rt => te(yt, Rt), [() => o7()]), q(lt, yt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var Vt = D(_t, 2);
              ba(Vt, () => hve, (Et, Pt) => {
                Pt(Et, {
                  children: (lt, $t) => {
                    var yt = Sr(),
                      Rt = Ct(yt);
                    si(Rt, 17, () => xa.countries, jt => jt.id, (jt, Xt) => {
                      var fr = Sr(),
                        Yt = Ct(fr);
                      ba(Yt, () => dve, (lr, ot) => {
                        ot(lr, {
                          get value() {
                            return g(Xt).name
                          },
                          onSelect: () => {
                            r(g(Xt).id), l()
                          },
                          children: (nt, Ut) => {
                            var Qt = bve(),
                              Ot = M(Qt),
                              mr = M(Ot, !0);
                            S(Ot);
                            var zt = D(Ot);
                            S(Qt), Re(() => {
                              te(mr, g(Xt).flag), te(zt, ` ${g(Xt).name??""}`)
                            }), q(nt, Qt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), q(jt, fr)
                    }), q(lt, yt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), q(vt, We)
            },
            $$slots: {
              default: !0
            }
          })
        }), q(tt, Ce)
      },
      $$slots: {
        default: !0
      }
    })
  }), S(ge), S(W);
  var we = D(W, 2);
  {
    var Fe = be => {
      var Xe = kve();
      Xe.__click = () => {
        r(0)
      };
      var tt = M(Xe);
      Ro(tt, {
        class: "size-3.5"
      }), S(Xe), q(be, Xe)
    };
    Te(we, be => {
      r() != 0 && be(Fe)
    })
  }
  S(F), ja(F, be => H(E, be), () => g(E)), Re(() => V = Vr(ge, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, V, {
    "right-1": x() === "left"
  })), In("focus", ee, () => {
    g(z).focus()
  }), q(p, F), an()
}
Yn(["click"]);
var Sve = Yr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function _y(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Sve();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Pve = Yr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  Mve = Yr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function Qu(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Sr(),
    z = Ct(x);
  {
    var E = l => {
        var F = Pve();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      },
      k = l => {
        var F = Mve();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      };
    Te(z, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  q(p, x)
}
var Ive = he('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  Cve = he('<div class="mb-2"><!></div>'),
  zve = he('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  Ave = he('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  Eve = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  Lve = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Dve = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  Rve = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  jve = he("<span> </span>"),
  Fve = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Bve = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  Ove = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  qve = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  Nve = he('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  Vve = he('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function Uve(p, s) {
  nn(s, !0);
  const r = [];
  let x = Je(1e3);
  const z = mt(() => g(x) <= 640);
  let E = Je("today"),
    k = {
      regions: {
        label: IW(),
        icon: Ap
      },
      countries: {
        label: IS(),
        icon: _y
      },
      players: {
        label: P0(),
        icon: Rp
      },
      alliances: {
        label: g0(),
        icon: jp
      }
    },
    l = Je("regions"),
    F = Je(0),
    W = yi({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    ee = mt(() => {
      var Ce, De, Ke;
      return g(l) === "regions" ? (De = (Ce = W[g(l)][g(F)]) == null ? void 0 : Ce[g(E)]) == null ? void 0 : De.entries : (Ke = W[g(l)][g(E)]) == null ? void 0 : Ke.entries
    });
  const $ = 5 * 1e3;
  cn(() => {
    var Le;
    if (!s.open) return;
    const Ce = g(E),
      De = g(l),
      Ke = g(F);
    De === "players" && (!W[De][Ce] || Date.now() - W[De][Ce].time > $) ? dn.leaderboardPlayers(Ce).then(Ne => {
      W[De][Ce] = {
        time: Date.now(),
        entries: Ne
      }
    }).catch(Ne => Zt.error(Ne.message)) : De === "alliances" && (!W[De][Ce] || Date.now() - W[De][Ce].time > $) ? dn.leaderboardAlliances(Ce).then(Ne => {
      W[De][Ce] = {
        time: Date.now(),
        entries: Ne
      }
    }).catch(Ne => Zt.error(Ne.message)) : De === "countries" && (!W[De][Ce] || Date.now() - W[De][Ce].time > $) ? dn.leaderboardCountries(Ce).then(Ne => {
      W[De][Ce] = {
        time: Date.now(),
        entries: Ne
      }
    }).catch(Ne => Zt.error(Ne.message)) : De === "regions" && (!((Le = W[De][Ke]) != null && Le[Ce]) || Date.now() - W[De][Ke][Ce].time > $) && dn.leaderboardRegions(Ce, Ke).then(Ne => {
      W[De][Ke] || (W[De][Ke] = {}), W[De][Ke][Ce] = {
        time: Date.now(),
        entries: Ne
      }
    }).catch(Ne => Zt.error(Ne.message))
  });
  var se = Vve(),
    _e = Ct(se);
  si(_e, 21, () => Object.entries(k), ([Ce, {
    label: De,
    icon: Ke
  }]) => Ce, (Ce, De) => {
    var Ke = mt(() => r0(g(De), 2));
    let Le = () => g(Ke)[0],
      Ne = () => g(Ke)[1].label,
      vt = () => g(Ke)[1].icon;
    const et = mt(vt);
    var We = Ive(),
      _t = M(We);
    Ki(_t);
    var Vt, Et = D(_t, 2);
    ba(Et, () => g(et), (lt, $t) => {
      $t(lt, {
        get this() {
          return vt()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Pt = D(Et);
    S(We), Re(() => {
      er(_t, "aria-label", Ne()), Vt !== (Vt = Le()) && (_t.value = (_t.__value = Le()) ?? ""), te(Pt, ` ${Ne()??""}`)
    }), Z_(r, [], _t, () => (Le(), g(l)), lt => H(l, lt)), q(Ce, We)
  }), S(_e);
  var ge = D(_e, 2),
    V = M(ge);
  cm(V, {
    get value() {
      return g(E)
    },
    set value(Ce) {
      H(E, Ce, !0)
    }
  });
  var Me = D(V, 2);
  {
    var we = Ce => {
      $v(Ce, {
        dropdownDirection: "left",
        get countryId() {
          return g(F)
        },
        set countryId(De) {
          H(F, De, !0)
        }
      })
    };
    Te(Me, Ce => {
      g(l) === "regions" && !g(z) && Ce(we)
    })
  }
  S(ge);
  var Fe = D(ge, 2);
  {
    var be = Ce => {
      var De = Cve(),
        Ke = M(De);
      $v(Ke, {
        get countryId() {
          return g(F)
        },
        set countryId(Le) {
          H(F, Le, !0)
        }
      }), S(De), q(Ce, De)
    };
    Te(Fe, Ce => {
      g(l) === "regions" && g(z) && Ce(be)
    })
  }
  var Xe = D(Fe, 2);
  {
    var tt = Ce => {
        var De = zve(),
          Ke = M(De),
          Le = D(Ke);
        {
          var Ne = et => {
              var We = Oi();
              Re(_t => te(We, _t), [() => Dp().toLowerCase()]), q(et, We)
            },
            vt = et => {
              var We = Sr(),
                _t = Ct(We);
              {
                var Vt = Pt => {
                    var lt = Oi();
                    Re($t => te(lt, $t), [() => rm()]), q(Pt, lt)
                  },
                  Et = Pt => {
                    var lt = Sr(),
                      $t = Ct(lt);
                    {
                      var yt = Rt => {
                        var jt = Oi();
                        Re(Xt => te(jt, Xt), [() => tm()]), q(Rt, jt)
                      };
                      Te($t, Rt => {
                        g(E) === "month" && Rt(yt)
                      }, !0)
                    }
                    q(Pt, lt)
                  };
                Te(_t, Pt => {
                  g(E) === "week" ? Pt(Vt) : Pt(Et, !1)
                }, !0)
              }
              q(et, We)
            };
          Te(Le, et => {
            g(E) === "today" ? et(Ne) : et(vt, !1)
          })
        }
        S(De), Re(et => te(Ke, `${et??""} `), [() => em()]), q(Ce, De)
      },
      Ye = Ce => {
        var De = Sr(),
          Ke = Ct(De);
        {
          var Le = vt => {
              var et = Sr(),
                We = Ct(et);
              {
                var _t = Et => {
                    const Pt = mt(() => g(ee));
                    var lt = Eve(),
                      $t = M(lt),
                      yt = M($t),
                      Rt = D(M(yt)),
                      jt = M(Rt, !0);
                    S(Rt);
                    var Xt = D(Rt),
                      fr = M(Xt),
                      Yt = D(fr, 2),
                      lr = D(Yt),
                      ot = M(lr);
                    Qu(ot, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), S(lr), S(Xt), bn(), S(yt), S($t);
                    var nt = D($t);
                    si(nt, 31, () => g(Pt), Ut => Ut.id, (Ut, Qt, Ot) => {
                      const mr = mt(() => Do(g(Qt).countryId));
                      var zt = Ave(),
                        Mt = M(zt),
                        kt = M(Mt, !0);
                      S(Mt);
                      var It = D(Mt),
                        Gt = M(It),
                        ht = M(Gt, !0);
                      S(Gt);
                      var hr = D(Gt, 2),
                        wr = M(hr),
                        ur = D(wr),
                        qr = M(ur);
                      S(ur), S(hr), S(It);
                      var kr = D(It),
                        Zr = M(kr, !0);
                      S(kr);
                      var Wr = D(kr),
                        tr = M(Wr);
                      tr.__click = () => {
                        s.onvisitclick({
                          lat: g(Qt).lastLatitude,
                          lng: g(Qt).lastLongitude
                        })
                      };
                      var Hr = M(tr, !0);
                      S(tr), S(Wr), S(zt), Re((sr, de, O) => {
                        te(kt, g(Ot) + 1), er(Gt, "data-tip", g(mr).name), te(ht, g(mr).flag), Vr(hr, 1, `font-semibold ${sr??""}`), te(wr, `${g(Qt).name??""} `), te(qr, `#${g(Qt).number??""}`), te(Zr, de), te(Hr, O)
                      }, [() => na(g(Qt).cityId), () => g(Qt).pixelsPainted.toLocaleString(navigator.language), () => M1()]), _l(zt, () => ml, () => ({
                        duration: 200
                      })), q(Ut, zt)
                    }), S(nt), S(lt), Re((Ut, Qt, Ot, mr) => {
                      te(jt, Ut), te(fr, `${Qt??""} `), te(Yt, `${Ot??""} `), er(lr, "data-tip", mr)
                    }, [() => _W(), () => Pc(), () => Sc().toLowerCase(), () => kU()]), q(Et, lt)
                  },
                  Vt = Et => {
                    var Pt = Sr(),
                      lt = Ct(Pt);
                    {
                      var $t = Rt => {
                          var jt = Dve(),
                            Xt = M(jt),
                            fr = M(Xt),
                            Yt = D(M(fr)),
                            lr = M(Yt, !0);
                          S(Yt);
                          var ot = D(Yt),
                            nt = M(ot),
                            Ut = D(nt, 2),
                            Qt = D(Ut),
                            Ot = M(Qt);
                          Qu(Ot, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), S(Qt), S(ot), S(fr), S(Xt);
                          var mr = D(Xt);
                          si(mr, 31, () => g(ee), zt => zt.id, (zt, Mt, kt) => {
                            const It = mt(() => Do(g(Mt).id) ?? {
                              name: `Pais ID: ${g(Mt).id}`,
                              flag: "ðŸ³ï¸",
                              code: "XX"
                            });
                            var Gt = Lve(),
                              ht = M(Gt),
                              hr = M(ht, !0);
                            S(ht);
                            var wr = D(ht),
                              ur = M(wr),
                              qr = M(ur, !0);
                            S(ur);
                            var kr = D(ur, 2),
                              Zr = M(kr, !0);
                            S(kr), S(wr);
                            var Wr = D(wr),
                              tr = M(Wr, !0);
                            S(Wr), S(Gt), Re((Hr, sr) => {
                              te(hr, g(kt) + 1), er(ur, "data-tip", g(It).name), te(qr, g(It).flag), Vr(kr, 1, `font-semibold ${Hr??""}`), te(Zr, g(It).name), te(tr, sr)
                            }, [() => na(g(Mt).id), () => g(Mt).pixelsPainted.toLocaleString(navigator.language)]), _l(Gt, () => ml, () => ({
                              duration: 200
                            })), q(zt, Gt)
                          }), S(mr), S(jt), Re((zt, Mt, kt, It) => {
                            te(lr, zt), te(nt, `${Mt??""} `), te(Ut, `${kt??""} `), er(Qt, "data-tip", It)
                          }, [() => Q_(), () => Pc(), () => Sc().toLowerCase(), () => uU()]), q(Rt, jt)
                        },
                        yt = Rt => {
                          var jt = Sr(),
                            Xt = Ct(jt);
                          {
                            var fr = lr => {
                                const ot = mt(() => g(ee));
                                var nt = Bve(),
                                  Ut = M(nt),
                                  Qt = M(Ut),
                                  Ot = D(M(Qt)),
                                  mr = M(Ot, !0);
                                S(Ot);
                                var zt = D(Ot),
                                  Mt = M(zt),
                                  kt = D(Mt, 2, !0);
                                S(zt), S(Qt), S(Ut);
                                var It = D(Ut);
                                si(It, 31, () => g(ot), Gt => Gt.id, (Gt, ht, hr) => {
                                  const wr = mt(() => {
                                    var ie;
                                    return ((ie = Dt.data) == null ? void 0 : ie.id) === g(ht).id
                                  });
                                  var ur = Fve();
                                  let qr;
                                  var kr = M(ur),
                                    Zr = M(kr, !0);
                                  S(kr);
                                  var Wr = D(kr),
                                    tr = M(Wr),
                                    Hr = M(tr);
                                  Ra(Hr, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return g(ht).id
                                    },
                                    get pictureUrl() {
                                      return g(ht).picture
                                    },
                                    get borderUrl() {
                                      return g(ht).frameUrl
                                    }
                                  });
                                  var sr = D(Hr, 2),
                                    de = M(sr),
                                    O = M(de),
                                    N = D(O),
                                    X = M(N);
                                  S(N), S(de);
                                  var re = D(de, 2);
                                  {
                                    var Q = ie => {
                                      const J = mt(() => Do(g(ht).equippedFlag));
                                      var Ve = Sr(),
                                        rt = Ct(Ve);
                                      {
                                        var Ue = ae => {
                                          var Ie = Rve(),
                                            $e = M(Ie, !0);
                                          S(Ie), Re(() => {
                                            er(Ie, "data-tip", g(J).name), te($e, g(J).flag)
                                          }), q(ae, Ie)
                                        };
                                        Te(rt, ae => {
                                          g(J) && ae(Ue)
                                        })
                                      }
                                      q(ie, Ve)
                                    };
                                    Te(re, ie => {
                                      g(ht).equippedFlag && ie(Q)
                                    })
                                  }
                                  var ue = D(re, 2);
                                  {
                                    var ke = ie => {
                                      Lh(ie, {
                                        get username() {
                                          return g(ht).discord
                                        },
                                        get id() {
                                          return g(ht).discordId
                                        }
                                      })
                                    };
                                    Te(ue, ie => {
                                      g(ht).discord && ie(ke)
                                    })
                                  }
                                  var xe = D(ue, 2);
                                  {
                                    var Ee = ie => {
                                      var J = jve(),
                                        Ve = M(J, !0);
                                      S(J), Re((rt, Ue) => {
                                        Vr(J, 1, `badge badge-sm ml-0.5 border-0 ${rt??""} ${Ue??""}`), te(Ve, g(ht).allianceName)
                                      }, [() => Cp(g(ht).allianceId), () => na(g(ht).allianceId)]), q(ie, J)
                                    };
                                    Te(xe, ie => {
                                      "allianceName" in g(ht) && g(ht).allianceName && ie(Ee)
                                    })
                                  }
                                  S(sr), S(tr), S(Wr);
                                  var He = D(Wr),
                                    Be = M(He, !0);
                                  S(He), S(ur), Re((ie, J) => {
                                    qr = Vr(ur, 1, "", null, qr, {
                                      "bg-base-200": g(wr)
                                    }), te(Zr, g(hr) + 1), Vr(de, 1, `font-semibold max-sm:ml-2 ${ie??""} flex gap-1`), te(O, `${g(ht).name??""} `), te(X, `#${g(ht).id??""}`), te(Be, J)
                                  }, [() => na(g(ht).id), () => g(ht).pixelsPainted.toLocaleString(navigator.language)]), _l(ur, () => ml, () => ({
                                    duration: 200
                                  })), q(Gt, ur)
                                }), S(It), S(nt), Re((Gt, ht, hr) => {
                                  te(mr, Gt), te(Mt, `${ht??""} `), te(kt, hr)
                                }, [() => $_(), () => Pc(), () => Sc().toLowerCase()]), q(lr, nt)
                              },
                              Yt = lr => {
                                var ot = Sr(),
                                  nt = Ct(ot);
                                {
                                  var Ut = Qt => {
                                    var Ot = qve(),
                                      mr = M(Ot),
                                      zt = M(mr),
                                      Mt = D(M(zt)),
                                      kt = M(Mt, !0);
                                    S(Mt);
                                    var It = D(Mt),
                                      Gt = M(It),
                                      ht = D(Gt, 2, !0);
                                    S(It), S(zt), S(mr);
                                    var hr = D(mr);
                                    si(hr, 31, () => g(ee), wr => wr.id, (wr, ur, qr) => {
                                      const kr = mt(() => {
                                        var re;
                                        return ((re = Dt.data) == null ? void 0 : re.allianceId) === g(ur).id
                                      });
                                      var Zr = Ove();
                                      let Wr;
                                      var tr = M(Zr),
                                        Hr = M(tr, !0);
                                      S(tr);
                                      var sr = D(tr),
                                        de = M(sr),
                                        O = M(de, !0);
                                      S(de), S(sr);
                                      var N = D(sr),
                                        X = M(N, !0);
                                      S(N), S(Zr), Re((re, Q) => {
                                        Wr = Vr(Zr, 1, "", null, Wr, {
                                          "bg-base-200": g(kr)
                                        }), te(Hr, g(qr) + 1), Vr(de, 1, `font-semibold ${re??""}`), te(O, g(ur).name), te(X, Q)
                                      }, [() => na(g(ur).id), () => g(ur).pixelsPainted.toLocaleString(navigator.language)]), _l(Zr, () => ml, () => ({
                                        duration: 200
                                      })), q(wr, Zr)
                                    }), S(hr), S(Ot), Re((wr, ur, qr) => {
                                      te(kt, wr), te(Gt, `${ur??""} `), te(ht, qr)
                                    }, [() => Ep(), () => Pc(), () => Sc().toLowerCase()]), q(Qt, Ot)
                                  };
                                  Te(nt, Qt => {
                                    g(l) === "alliances" && Qt(Ut)
                                  }, !0)
                                }
                                q(lr, ot)
                              };
                            Te(Xt, lr => {
                              g(l) === "players" ? lr(fr) : lr(Yt, !1)
                            }, !0)
                          }
                          q(Rt, jt)
                        };
                      Te(lt, Rt => {
                        g(l) === "countries" ? Rt($t) : Rt(yt, !1)
                      }, !0)
                    }
                    q(Et, Pt)
                  };
                Te(We, Et => {
                  g(l) === "regions" ? Et(_t) : Et(Vt, !1)
                })
              }
              q(vt, et)
            },
            Ne = vt => {
              var et = Nve();
              q(vt, et)
            };
          Te(Ke, vt => {
            g(ee) ? vt(Le) : vt(Ne, !1)
          }, !0)
        }
        q(Ce, De)
      };
    Te(Xe, Ce => {
      g(ee) && g(ee).length === 0 ? Ce(tt) : Ce(Ye, !1)
    })
  }
  Ch("innerWidth", Ce => H(x, Ce, !0)), q(p, se), an()
}
Yn(["click"]);
var Zve = Yr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function my(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Zve();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Gve = he('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Wve(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  var x = Gve(),
    z = M(x),
    E = D(M(z), 2),
    k = M(E);
  my(k, {
    class: "size-6"
  });
  var l = D(k, 2),
    F = M(l, !0);
  S(l), S(E);
  var W = D(E, 2),
    ee = M(W);
  Uve(ee, {
    get onvisitclick() {
      return s.onvisitclick
    },
    get open() {
      return r()
    }
  }), S(W), S(z), bn(2), S(x), Ji(x, () => $ => {
    cn(() => {
      r() ? $.show() : $.close()
    })
  }), Re($ => te(F, $), [() => Y_()]), In("close", x, () => r(!1)), q(p, x), an()
}
var Hve = he("<div><!></div>"),
  $ve = he('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Xve(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  var x = $ve(),
    z = M(x),
    E = D(M(z), 2);
  {
    var k = l => {
      var F = Hve(),
        W = M(F);
      E1(W, {}), S(F), fa(2, F, () => Ja, () => ({
        duration: 300
      })), q(l, F)
    };
    Te(E, l => {
      r() && l(k)
    })
  }
  S(z), bn(2), S(x), Ji(x, () => l => {
    cn(() => {
      r() ? l.show() : l.close()
    })
  }), In("close", x, () => r(!1)), q(p, x), an()
}
var Yve = he("<p>You don't have charges to paint. <br/> </p>");

function Kve(p, s) {
  nn(s, !1), G_();
  var r = Yve(),
    x = D(M(r), 2);
  S(r), Re(z => te(x, ` Next charge in ${z??""}`), [() => Q0(Dt.cooldown ?? 0)]), q(p, r), an()
}
var Jve = he('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form>'),
  Qve = he('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  e0e = he('<dialog closedby="any"><div><!> <!></div> <!></dialog>');

function dm(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = nr(s, "hasBackdrop", 3, !0),
    z = nr(s, "hasCloseButton", 3, !0);
  var E = e0e(),
    k = M(E),
    l = M(k);
  {
    var F = se => {
      var _e = Jve();
      q(se, _e)
    };
    Te(l, se => {
      z() && se(F)
    })
  }
  var W = D(l, 2);
  qi(W, () => s.children ?? Qa), S(k);
  var ee = D(k, 2);
  {
    var $ = se => {
      var _e = Qve(),
        ge = M(_e),
        V = M(ge, !0);
      S(ge), S(_e), Re(Me => te(V, Me), [() => hs()]), q(se, _e)
    };
    Te(ee, se => {
      x() && se($)
    })
  }
  S(E), Ji(E, () => se => {
    cn(() => {
      r() ? se.show() : se.close()
    })
  }), Re(() => {
    Vr(E, 1, `modal ${s.dialogClass??""}`), Vr(k, 1, `modal-box ${s.modalBoxClass??""}`)
  }), In("close", E, () => r(!1)), q(p, E), an()
}
var t0e = he('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span class="whitespace-pre-line"><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function r0e(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = nr(s, "buttonText", 3, "OK");
  dm(p, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return r()
    },
    set open(z) {
      r(z)
    },
    children: (z, E) => {
      var k = t0e(),
        l = M(k),
        F = M(l, !0);
      S(l);
      var W = D(l, 2),
        ee = M(W);
      qi(ee, () => s.message), S(W);
      var $ = D(W, 2);
      $.__click = () => {
        r(!1)
      };
      var se = M($, !0);
      S($), S(k), Re(() => {
        te(F, s.title), te(se, x())
      }), q(z, k)
    },
    $$slots: {
      default: !0
    }
  }), an()
}
Yn(["click"]);

function n0e(p) {
  const s = new Date;
  return p.getDate() === s.getDate() && p.getMonth() === s.getMonth() && p.getFullYear() === s.getFullYear() ? p.toLocaleTimeString(navigator.language, {
    timeStyle: "short"
  }) : p.toLocaleDateString(navigator.language, {
    dateStyle: "medium"
  })
}
var i0e = he('<span class="size-2 rounded-full bg-red-400"></span>'),
  a0e = he('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function Xv(p, s) {
  nn(s, !0);
  let r = nr(s, "read", 15);
  var x = a0e();
  x.__click = () => {
    r(!0), s.onclick()
  };
  var z = M(x),
    E = M(z);
  qi(E, () => s.icon), S(z);
  var k = D(z, 2),
    l = M(k),
    F = M(l),
    W = M(F, !0);
  S(F);
  var ee = D(F, 2),
    $ = M(ee),
    se = M($, !0);
  S($);
  var _e = D($, 2);
  {
    var ge = we => {
      var Fe = i0e();
      q(we, Fe)
    };
    Te(_e, we => {
      r() || we(ge)
    })
  }
  S(ee), S(l);
  var V = D(l, 2),
    Me = M(V, !0);
  S(V), S(k), S(x), Re(we => {
    te(W, s.title), te(se, we), te(Me, s.message)
  }, [() => n0e(s.createdAt)]), q(p, x), an()
}
Yn(["click"]);
var o0e = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function Yv(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = o0e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var s0e = he('<button class="btn btn-sm btn-ghost"> </button>'),
  l0e = he('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  c0e = he("<!> <!>", 1),
  u0e = he('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  h0e = he('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  d0e = he("<p> </p>"),
  p0e = he("<!> <!>", 1);

function f0e(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(!1),
    z = Je(void 0),
    E = Je(void 0),
    k = Je(!1),
    l = Je(""),
    F = Je("");
  var W = p0e(),
    ee = Ct(W);
  dm(ee, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return r()
    },
    set open(se) {
      r(se)
    },
    children: (se, _e) => {
      var ge = h0e(),
        V = Ct(ge),
        Me = M(V),
        we = M(Me, !0);
      S(Me);
      var Fe = D(Me, 2);
      {
        var be = Ke => {
          var Le = s0e();
          Le.__click = async () => {
            if (dn.postNotificationMarkReadAll(), Dt.notificiationCount = 0, g(z))
              for (const vt of g(z)) vt.read = !0
          };
          var Ne = M(Le, !0);
          S(Le), Re(vt => te(Ne, vt), [() => PR()]), q(Ke, Le)
        };
        Te(Fe, Ke => {
          Dt.notificiationCount !== 0 && Ke(be)
        })
      }
      S(V);
      var Xe = D(V, 2),
        tt = M(Xe);
      {
        var Ye = Ke => {
          var Le = c0e(),
            Ne = Ct(Le);
          si(Ne, 17, () => g(z), We => We.id, (We, _t, Vt) => {
            var Et = Sr(),
              Pt = Ct(Et);
            {
              var lt = yt => {
                  {
                    const Rt = Yt => {
                      Yv(Yt, {
                        class: "size-5"
                      })
                    };
                    let jt = mt(() => mv()),
                      Xt = mt(() => gv()),
                      fr = mt(() => new Date(g(_t).createdAt));
                    Xv(yt, {
                      get title() {
                        return g(jt)
                      },
                      get message() {
                        return g(Xt)
                      },
                      get createdAt() {
                        return g(fr)
                      },
                      onclick: () => {
                        H(l, mv(), !0), H(F, `${gv()} ${hH()}`), H(k, !0)
                      },
                      get read() {
                        return g(_t).read
                      },
                      set read(Yt) {
                        g(_t).read = Yt
                      },
                      icon: Rt,
                      $$slots: {
                        icon: !0
                      }
                    })
                  }
                },
                $t = yt => {
                  var Rt = Sr(),
                    jt = Ct(Rt);
                  {
                    var Xt = fr => {
                      {
                        const Yt = Ut => {
                          Yv(Ut, {
                            class: "size-5"
                          })
                        };
                        let lr = mt(() => yv()),
                          ot = mt(() => {
                            var Ut;
                            return (Ut = g(_t).data) != null && Ut.approved ? bv() : xv()
                          }),
                          nt = mt(() => new Date(g(_t).createdAt));
                        Xv(fr, {
                          get title() {
                            return g(lr)
                          },
                          get message() {
                            return g(ot)
                          },
                          get createdAt() {
                            return g(nt)
                          },
                          onclick: () => {
                            var Ut;
                            H(l, yv(), !0), H(F, (Ut = g(_t).data) != null && Ut.approved ? `${bv()}

${wv()}` : `${xv()}

${wv()}`, !0), H(k, !0)
                          },
                          get read() {
                            return g(_t).read
                          },
                          set read(Ut) {
                            g(_t).read = Ut
                          },
                          icon: Yt,
                          $$slots: {
                            icon: !0
                          }
                        })
                      }
                    };
                    Te(jt, fr => {
                      g(_t).type === "appeal_feedback" && fr(Xt)
                    }, !0)
                  }
                  q(yt, Rt)
                };
              Te(Pt, yt => {
                g(_t).type === "report_feedback" ? yt(lt) : yt($t, !1)
              })
            }
            q(We, Et)
          });
          var vt = D(Ne, 2);
          {
            var et = We => {
              var _t = l0e(),
                Vt = M(_t, !0);
              S(_t), Re(Et => te(Vt, Et), [() => CB()]), q(We, _t)
            };
            Te(vt, We => {
              g(z).length === 0 && !g(x) && We(et)
            })
          }
          q(Ke, Le)
        };
        Te(tt, Ke => {
          g(z) && Ke(Ye)
        })
      }
      var Ce = D(tt, 2);
      {
        var De = Ke => {
          var Le = u0e();
          Ji(Le, () => Ne => {
            const vt = new IntersectionObserver(et => {
              et[0].isIntersecting && !g(x) && (H(x, !0), dn.getNotificationPage(g(E)).then(We => {
                H(z, [...g(z) ?? [], ...We.notifications], !0), H(E, We.nextCursor, !0);
                const _t = We.notifications.filter(Vt => !Vt.read).map(Vt => Vt.id);
                _t.length > 0 && (dn.postNotificationMarkRead(_t), Dt.notificiationCount !== void 0 && (Dt.notificiationCount = Math.max(0, Dt.notificiationCount - _t.length)))
              }).catch(We => {
                Zt.error(We.message)
              }).finally(() => {
                H(x, !1)
              }))
            });
            return vt.observe(Ne), () => {
              vt.disconnect()
            }
          }), q(Ke, Le)
        };
        Te(Ce, Ke => {
          r() && (g(z) === void 0 || g(E) !== void 0) && Ke(De)
        })
      }
      S(Xe), Re(Ke => te(we, Ke), [() => T0()]), q(se, ge)
    },
    $$slots: {
      default: !0
    }
  });
  var $ = D(ee, 2);
  r0e($, {
    get title() {
      return g(l)
    },
    get open() {
      return g(k)
    },
    set open(_e) {
      H(k, _e, !0)
    },
    message: _e => {
      var ge = d0e(),
        V = M(ge, !0);
      S(ge), Re(() => te(V, g(F))), q(_e, ge)
    },
    $$slots: {
      message: !0
    }
  }), q(p, W), an()
}
Yn(["click"]);
var _0e = he("<canvas></canvas>");

function gy(p, s) {
  nn(s, !0);
  let r = nr(s, "width", 15, 0),
    x = Er(s, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    z = mt(() => Math.ceil(s.fontSize)),
    E = Je(null);
  const k = window.devicePixelRatio ?? 1,
    l = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    F = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  cn(() => {
    const ee = g(E).getContext("2d");
    ee.textBaseline = "top", ee.font = `${s.weight??"normal"} ${s.fontSize}px ${s.mono?F:l}`, ee.fillStyle = s.color ?? "#394e6a", ee.setTransform(k, 0, 0, k, 0, 0), ee.clearRect(0, 0, r(), g(z)), ee.fillText(s.value, 0, 0);
    const $ = ee.measureText(s.value);
    r(Math.ceil($.actualBoundingBoxRight)), H(z, $.actualBoundingBoxDescent)
  });
  var W = _0e();
  Dr(W, () => ({
    width: r() * k,
    height: g(z) * k,
    style: `width: ${r()??""}px; height: ${g(z)??""}px`,
    ...x
  })), ja(W, ee => H(E, ee), () => g(E)), q(p, W), an()
}
var m0e = he('<span class="w-7 text-xs"> </span>'),
  g0e = he('<span class="flex items-center gap-1 sm:mt-px"><span><!></span> <!></span>'),
  v0e = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  y0e = he('<button><div class="flex items-center gap-1.5"><!> <div class="flex items-center gap-2 whitespace-nowrap"> <!></div></div> <!></button>');

function vy(p, s) {
  nn(s, !0);
  let r = Er(s, ["$$slots", "$$events", "$$legacy", "loading", "charges", "maxWidth"]),
    x = Je(0),
    z = Je(null),
    E = Je(void 0);
  ps(() => [s.loading, s.maxWidth], () => {
    H(E, void 0), requestAnimationFrame(() => {
      const V = g(z).offsetWidth;
      !s.loading && s.maxWidth !== void 0 && V + 20 > s.maxWidth ? H(E, 16 * (s.maxWidth / V) * .8) : H(E, void 0)
    })
  });
  var k = y0e();
  Dr(k, () => ({
    ...r,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${s.class??""}`,
    style: `max-width: ${s.maxWidth?`${s.maxWidth}px`:"none"}
	${g(E)?`;font-size: ${g(E)}px`:""}`
  }));
  var l = M(k),
    F = M(l);
  bl(F, {
    class: "size-6"
  });
  var W = D(F, 2),
    ee = M(W),
    $ = D(ee);
  {
    var se = V => {
      const Me = mt(() => `${Math.floor(s.charges)}/${Dt.data.charges.max}`);
      var we = g0e(),
        Fe = M(we),
        be = M(Fe);
      {
        let Ye = mt(() => g(E) ?? 16),
          Ce = mt(() => s.disabled ? "#394e6a33" : "#ffffff");
        gy(be, {
          weight: 600,
          get fontSize() {
            return g(Ye)
          },
          get value() {
            return g(Me)
          },
          get color() {
            return g(Ce)
          },
          get width() {
            return g(x)
          },
          set width(De) {
            H(x, De, !0)
          }
        })
      }
      S(Fe);
      var Xe = D(Fe, 2);
      {
        var tt = Ye => {
          var Ce = m0e(),
            De = M(Ce);
          S(Ce), Re(Ke => te(De, `(${Ke??""})`), [() => Q0(Dt.cooldown)]), q(Ye, Ce)
        };
        Te(Xe, Ye => {
          s.charges < Dt.data.charges.max && Dt.cooldown !== void 0 && Ye(tt)
        })
      }
      S(we), Re(Ye => ds(Fe, `width: ${Ye??""}px`), [() => (Math.floor(g(x) / 5) + 1) * 5]), q(V, we)
    };
    Te($, V => {
      s.charges !== void 0 && Dt.data && V(se)
    })
  }
  S(W), S(l), ja(l, V => H(z, V), () => g(z));
  var _e = D(l, 2);
  {
    var ge = V => {
      var Me = v0e();
      q(V, Me)
    };
    Te(_e, V => {
      s.loading && V(ge)
    })
  }
  S(k), Re(V => te(ee, `${V??""} `), [() => S0()]), q(p, k), an()
}
const b0e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  x0e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  w0e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  k0e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class T0e {
  constructor(s) {
    mn(this, "gm");
    mn(this, "opacity", 1);
    mn(this, "id", `paint-preview-${Math.random()}`);
    mn(this, "tiles", new Map);
    this.input = s, this.gm = new Aa(this.input.tileSize)
  }
  place([s, r], x) {
    const {
      tile: z,
      pixel: E
    } = this.gm.latLonToTileAndPixel(s, r, this.input.tileZoom), k = this.getTileKey(z[0], z[1]);
    let l = this.tiles.get(k);
    if (!l) {
      const F = this.gm.tileBoundsLatLon(z[0], z[1], this.input.tileZoom),
        W = nm(F, !0),
        ee = new S0e({
          coordinates: W,
          id: `${this.id}-${k}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      ee.addTo(this.input.map), this.tiles.set(k, ee), l = ee
    }
    l.place(E[0], this.input.tileSize - E[1] - 1, x)
  }
  clear() {
    const s = this.input.map;
    for (const r of this.tiles.values()) r.removeFrom(s), r.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(s, r) {
    this.clear(), this.place(s, r)
  }
  remove([s, r]) {
    const {
      tile: x,
      pixel: z
    } = this.gm.latLonToTileAndPixel(s, r, this.input.tileZoom), E = this.getTileKey(x[0], x[1]), k = this.tiles.get(E);
    k && k.remove(z[0], this.input.tileSize - z[1] - 1)
  }
  setCanvasOpacity(s) {
    this.opacity = s;
    for (const r of this.tiles.values()) r.setOpacity(s)
  }
  getTileKey(s, r) {
    return `${s},${r}`
  }
}
class S0e {
  constructor(s) {
    mn(this, "canvas");
    mn(this, "maps", new Set);
    this.input = s;
    const r = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = r, this.canvas.height = r
  }
  place(s, r, x) {
    var k;
    const z = ((k = xa.colors) == null ? void 0 : k[x]) ?? xa.colors[0],
      E = this.canvas.getContext("2d");
    if (E) {
      const l = E.createImageData(1, 1),
        [F, W, ee] = z.rgb,
        $ = x === 0 ? 0 : 255;
      l.data[0] = F, l.data[1] = W, l.data[2] = ee, l.data[3] = $, E.putImageData(l, s, r)
    }
  }
  remove(s, r) {
    const x = this.canvas.getContext("2d");
    x && x.clearRect(s, r, 1, 1)
  }
  addTo(s) {
    const r = this.input.id;
    s.getSource(r) || s.addSource(r, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), s.getLayer(r) || (s.addLayer({
      id: r,
      type: "raster",
      source: r,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && s.moveLayer(r, this.input.beforeLayerId)), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: r
    } = this.input;
    s.getLayer(r) && s.removeLayer(r), s.getSource(r) && s.removeSource(r), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(s) {
    for (const r of this.maps.values()) r.setPaintProperty(this.input.id, "raster-opacity", s)
  }
}
var P0e = Yr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function M0e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = P0e();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...r
  })), q(p, x)
}
var I0e = Yr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function C0e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = I0e();
  Dr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...r
  })), q(p, x)
}
var z0e = he("<div><!></div>");

function Tc(p, s) {
  nn(s, !0);
  var r = z0e(),
    x = M(r);
  qi(x, () => s.children ?? Qa), S(r), Re(() => Vr(r, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${s.class??""}`)), q(p, r), an()
}
var A0e = he('<div class="confetti svelte-av71ki"></div>'),
  E0e = he("<div></div>");

function pm(p, s) {
  nn(s, !0);
  const r = nr(s, "size", 3, 10),
    x = nr(s, "x", 19, () => [-.5, .5]),
    z = nr(s, "y", 19, () => [.25, 1]),
    E = nr(s, "duration", 3, 2e3),
    k = nr(s, "infinite", 3, !1),
    l = nr(s, "delay", 19, () => [0, 50]),
    F = nr(s, "colorRange", 19, () => [0, 360]),
    W = nr(s, "colorArray", 19, () => []),
    ee = nr(s, "amount", 3, 50),
    $ = nr(s, "iterationCount", 3, 1),
    se = nr(s, "fallDistance", 3, "100px"),
    _e = nr(s, "rounded", 3, !1),
    ge = nr(s, "cone", 3, !1),
    V = nr(s, "noGravity", 3, !1),
    Me = nr(s, "xSpread", 3, .15),
    we = nr(s, "destroyOnComplete", 3, !0),
    Fe = nr(s, "disableForReducedMotion", 3, !1);
  let be = Je(!1);
  Yi(() => {
    !we() || k() || typeof $() == "string" || setTimeout(() => H(be, !0), (E() + l()[1]) * $())
  });

  function Xe(Ke, Le) {
    return Math.random() * (Le - Ke) + Ke
  }

  function tt() {
    return W().length ? W()[Math.round(Math.random() * (W().length - 1))] : `hsl(${Math.round(Xe(F()[0],F()[1]))}, 75%, 50%)`
  }
  var Ye = Sr(),
    Ce = Ct(Ye);
  {
    var De = Ke => {
      var Le = E0e();
      let Ne;
      si(Le, 21, () => ({
        length: ee()
      }), Dc, (vt, et) => {
        var We = A0e();
        Re((_t, Vt, Et, Pt, lt, $t, yt, Rt, jt, Xt, fr) => ds(We, `
        --color: ${_t??""};
        --skew: ${Vt??""}deg,${Et??""}deg;
        --rotation-xyz: ${Pt??""}, ${lt??""}, ${$t??""};
        --rotation-deg: ${yt??""}deg;
        --translate-y-multiplier: ${Rt??""};
        --translate-x-multiplier: ${jt??""};
        --scale: ${Xt??""};
        --transition-delay: ${fr??""}ms;
        --transition-duration: ${k()?`calc(${E()}ms * var(--scale))`:`${E()}ms`};`), [tt, () => Xe(-45, 45), () => Xe(-45, 45), () => Xe(-10, 10), () => Xe(-10, 10), () => Xe(-10, 10), () => Xe(0, 360), () => Xe(z()[0], z()[1]), () => Xe(x()[0], x()[1]), () => .1 * Xe(2, 10), () => Xe(l()[0], l()[1])]), q(vt, We)
      }), S(Le), Re(() => {
        Ne = Vr(Le, 1, "confetti-holder svelte-av71ki", null, Ne, {
          rounded: _e(),
          cone: ge(),
          "no-gravity": V(),
          "reduced-motion": Fe()
        }), ds(Le, `
    --fall-distance: ${se()??""};
    --size: ${r()??""}px;
    --x-spread: ${1-Me()};
    --transition-iteration-count: ${(k()?"infinite":$())??""};`)
      }), q(Ke, Le)
    };
    Te(Ce, Ke => {
      g(be) || Ke(De)
    })
  }
  q(p, Ye), an()
}
var L0e = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  D0e = he('<!> <span class="text-sm">Droplets</span>', 1),
  R0e = he('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  j0e = he('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'),
  F0e = he('<dialog class="modal bg-black/80!" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function B0e(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  const x = mt(() => xa.colors[s.colorIdx]),
    z = mt(() => {
      var _e;
      return ((_e = Dt.data) == null ? void 0 : _e.droplets) ?? 0
    });
  let E = Je(!1);
  const k = mt(() => (g(E), Dt.hasColor(s.colorIdx))),
    l = 100,
    F = xa.products[l];
  var W = F0e(),
    ee = M(W),
    $ = D(M(ee), 2);
  {
    var se = _e => {
      var ge = j0e(),
        V = M(ge),
        Me = M(V),
        we = M(Me);
      Tp(we, {
        class: "size-6"
      });
      var Fe = D(we, 4),
        be = M(Fe);
      o0(be, {
        get value() {
          return g(z)
        }
      }), S(Fe), S(Me), bn(2), S(V);
      var Xe = D(V, 2),
        tt = M(Xe),
        Ye = M(tt);
      S(tt);
      var Ce = D(tt, 2),
        De = M(Ce, !0);
      S(Ce);
      var Ke = D(Ce, 2),
        Le = M(Ke);
      let Ne;
      var vt = M(Le);
      vt.__click = async () => {
        try {
          H(E, !0), await dn.purchase({
            id: l,
            amount: 1,
            variant: s.colorIdx
          }), await Dt.refresh(), xi.notification1.play()
        } catch (lt) {
          Zt.error(lt.message)
        } finally {
          H(E, !1)
        }
      };
      var et = M(vt);
      {
        var We = lt => {
          var $t = L0e();
          q(lt, $t)
        };
        Te(et, lt => {
          g(E) && lt(We)
        })
      }
      var _t = D(et, 2);
      {
        var Vt = lt => {
            var $t = D0e(),
              yt = Ct($t);
            Ip(yt, {
              class: "size-5"
            });
            var Rt = D(yt);
            bn(), Re(jt => te(Rt, ` ${jt??""} `), [() => F.price.toLocaleString(navigator.language)]), q(lt, $t)
          },
          Et = lt => {
            var $t = R0e(),
              yt = Ct($t);
            Tp(yt, {
              class: "size-5"
            });
            var Rt = D(yt, 2),
              jt = M(Rt);
            pm(jt, {}), S(Rt), q(lt, $t)
          };
        Te(_t, lt => {
          g(k) ? lt(Et, !1) : lt(Vt)
        })
      }
      S(vt), S(Le);
      var Pt = D(Le, 2);
      Pt.__click = () => r(!1), S(Ke), S(Xe), S(ge), Re(lt => {
        ds(Ye, `background: rgb(${g(x).rgb[0]} ${g(x).rgb[1]} ${g(x).rgb[2]})`), er(Ye, "aria-label", g(x).name), te(De, g(x).name), er(Le, "data-tip", lt), Ne = Vr(Le, 1, "", null, Ne, {
          tooltip: !g(k) && g(z) < F.price
        }), vt.disabled = g(z) < F.price || g(E) || g(k)
      }, [() => Lp()]), q(_e, ge)
    };
    Te($, _e => {
      Dt.data && _e(se)
    })
  }
  S(ee), bn(2), S(W), Ji(W, () => _e => {
    cn(() => {
      r() ? _e.show() : _e.close()
    })
  }), In("close", W, () => r(!1)), q(p, W), an()
}
Yn(["click"]);
var O0e = Yr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function Kv(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = O0e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var q0e = Yr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function yy(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = q0e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var N0e = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  V0e = Yr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function by(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Sr(),
    z = Ct(x);
  {
    var E = l => {
        var F = N0e();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      },
      k = l => {
        var F = V0e();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      };
    Te(z, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  q(p, x)
}
var U0e = Yr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function j_(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = U0e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Z0e = Yr('<svg><path d="M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z"></path></svg>');

function G0e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Z0e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var W0e = Yr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function xy(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = W0e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var H0e = Yr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function $0e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = H0e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var X0e = he("<!> ", 1),
  Y0e = he("<!> ", 1),
  K0e = he("<!> ", 1),
  J0e = he('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  Q0e = he("<!> ", 1),
  eye = he('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  tye = he("<div><button><!></button></div>"),
  rye = he('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1.5"><h2 class="sm:min-w-38 select-none text-xl"> <!></h2> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip max-sm:hidden"><button title="Toggle art opacity"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Z</kbd></div> <button title="Undo"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Y</kbd></div> <button title="Redo"><!></button></div></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function nye(p, s) {
  var Nt, wt;
  nn(s, !0);
  let r = nr(s, "screenLocked", 15),
    x = nr(s, "opaquePixelArt", 15);
  const z = mt(() => new Aa(s.tileSize));
  let E = Je(1),
    k = Je("pencil");
  const l = new Map,
    F = new Map;
  let W = Je(0),
    ee = Je(!1),
    $ = Je(!0),
    se = mt(() => Dt.charges ?? 0),
    _e = mt(() => g(se) - g(W)),
    ge = Je(!1),
    V = !1,
    Me = Je(!1);
  const we = mt(() => g(k) === "pencil"),
    Fe = mt(() => g(k) === "eraser"),
    be = mt(() => g(k) === "colorpicker");
  let Xe = Je(!1),
    tt = Je(0),
    Ye = Je(void 0),
    Ce = Je(void 0);
  const De = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Ge => ({
      ...xa.colors[Ge],
      idx: Ge,
      label: hv[Ge]()
    })),
    Ke = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Ge => ({
      ...xa.colors[Ge],
      idx: Ge,
      label: hv[Ge]()
    }));
  let Le = Je(!1);
  const Ne = mt(() => g(Le) ? De : Ke),
    vt = "show-all-colors";
  Yi(() => {
    H(Le, localStorage.getItem(vt) === "true")
  }), cn(() => {
    localStorage.setItem(vt, g(Le) ? "true" : "false")
  });
  const et = "selected-color";
  Yi(() => {
    const Ge = Number(localStorage.getItem(et));
    !isNaN(Ge) && Ge < xa.colors.length && Ge > 0 && H(E, Ge, !0)
  }), cn(() => {
    localStorage.setItem(et, g(E).toString())
  });
  const We = new T0e({
    map: s.map,
    tileSize: s.tileSize,
    tileZoom: s.tileZoom,
    beforeLayerId: s.hoverLayerId
  });
  cn(() => {
    const Ge = x() ? 1 : 0;
    We.setCanvasOpacity(Ge)
  }), cn(() => {
    x() ? r_() : yt([...l.values()])
  });
  let _t = !1;
  Yi(() => {
    ss(s.map.getCenter(), s.map.getZoom());
    const Ge = s.map.on("click", Kr => {
      var Cn;
      s.zoom < s.tileZoom + 2 && ((Cn = Dt.data) == null ? void 0 : Cn.role) === "user" && s.map.easeTo({
        center: Kr.lngLat,
        zoom: 17
      });
      const Ur = [Kr.lngLat.lat, Kr.lngLat.lng];
      g(we) ? (Et([Ur], g(E)), Ot.finishAction()) : g(Fe) ? (Pt([Ur]), Ot.finishAction()) : g(be) && lt(Ur, Kr.point), H(ge, !0)
    });

    function xt(Kr, Ur) {
      const Cn = g(z).latLonToPixels(Kr.lat, Kr.lng, s.tileZoom),
        En = Ur ? g(z).latLonToPixels(Ur.lat, Ur.lng, s.tileZoom) : Cn;
      return a1(Cn, En).map(Un => g(z).pixelsToLatLon(Un[0] + .5, Un[1] + .5, s.tileZoom))
    }

    function Wt(Kr, Ur) {
      const Cn = xt(Kr, Ur);
      g(we) ? Et(Cn, g(E)) : g(Fe) && Pt(Cn), H(ge, !0)
    }
    let At;

    function pr(Kr) {
      const Ur = s.map.unproject([Kr.clientX, Kr.clientY]);
      if (g(Me)) {
        const Cn = xt(Ur, At);
        Pt(Cn)
      }(_t || V) && Wt(Ur, At), At = Ur
    }
    window.addEventListener("mousemove", pr);
    let ar = !1;
    const zr = s.map.on("touchstart", Kr => {
        if (Kr.points.length == 2) {
          r(!1), fr(), ar = !0, setTimeout(() => ar = !1, 150);
          return
        }
        r() && setTimeout(() => {
          !ar && Wt(Kr.lngLat)
        }, 150), At = Kr.lngLat
      }),
      Jr = s.map.on("touchend", () => {
        Ot.finishAction()
      }),
      jr = s.map.on("touchmove", Kr => {
        r() && Wt(Kr.lngLat, At), At = Kr.lngLat
      }),
      Or = Kr => {
        Kr.code === "Space" && (_t || At && Wt(At), _t = !0, Kr.preventDefault())
      };
    document.addEventListener("keydown", Or);
    const Fr = Kr => {
      Kr.code === "Space" && (_t = !1, Vt = !1, Ot.finishAction(), g(W) === 0 && g(Fe) && H(k, "pencil"))
    };
    document.addEventListener("keyup", Fr);

    function rn(Kr) {
      if (Kr.button === 2) {
        H(Me, !0);
        const Cn = s.map.unproject([Kr.clientX, Kr.clientY]);
        Pt([
          [Cn.lat, Cn.lng]
        ])
      }
    }
    document.addEventListener("mousedown", rn);

    function An(Kr) {
      Kr.button === 2 && H(Me, !1)
    }
    document.addEventListener("mouseup", An);
    const kn = Kr => {
      switch (Kr.code) {
        case "KeyE":
          g(W) > 0 && (g(Fe) ? H(k, "pencil") : H(k, "eraser"));
          return;
        case "KeyI":
          H(k, "colorpicker");
          return
      }
    };
    return document.addEventListener("keypress", kn), () => {
      jr.unsubscribe(), zr.unsubscribe(), Jr.unsubscribe(), Ge.unsubscribe(), document.removeEventListener("mousemove", pr), document.removeEventListener("keydown", Or), document.removeEventListener("keyup", Fr), document.removeEventListener("keypress", kn), document.removeEventListener("mousedown", rn), document.removeEventListener("mouseup", An), Rt()
    }
  });
  let Vt = !1;

  function Et(Ge, xt, Wt = !0) {
    let At = !1;
    const pr = xt === 0;
    for (let ar of Ge) {
      const [zr, Jr] = ar, jr = vp(xt), {
        tile: Or,
        pixel: Fr
      } = g(z).latLonToTileAndPixel(zr, Jr, s.tileZoom), rn = {
        color: jr,
        tile: Or,
        pixel: Fr,
        season: s.season,
        colorIdx: xt
      }, An = Gf(rn), kn = l.get(An), Kr = g(se) - l.size;
      if (!kn && Kr < 1) {
        if (Vt && (_t || r())) continue;
        Vt = !0, Zt.info(Z7());
        continue
      }
      if (!(kn && kn.colorIdx === xt) && (xi.plop.play(), At || s.hidePixelHover(), l.set(An, rn), We.place(ar, xt), s.crosshair.place(ar), At = !0, pr && F.set(An, rn), Wt)) {
        const Ur = {
            type: "paint",
            latLons: [ar],
            colorIdx: xt
          },
          Cn = kn ? {
            type: "paint",
            latLons: [ar],
            colorIdx: kn.colorIdx
          } : {
            type: "erase",
            latLons: [ar]
          };
        Ot.saveAction(Ur, Cn)
      }
    }
    H(W, l.size, !0), At && !x() ? yt([...l.values()]) : At && x() && pr && yt([...F.values()])
  }

  function Pt(Ge, xt = !0) {
    let Wt = !1,
      At = !1;
    for (let pr of Ge) {
      const [ar, zr] = pr, {
        tile: Jr,
        pixel: jr
      } = g(z).latLonToTileAndPixel(ar, zr, s.tileZoom), Or = Gf({
        tile: Jr,
        pixel: jr,
        season: s.season
      }), Fr = l.get(Or);
      Fr && (xi.plop.play(), s.hidePixelHover(), l.delete(Or), F.delete(Or), We.remove([ar, zr]), s.crosshair.remove(pr), Wt = !0, Fr.colorIdx === 0 && (At = !0), xt && Ot.saveAction({
        type: "erase",
        latLons: [pr]
      }, {
        type: "paint",
        latLons: [pr],
        colorIdx: Fr.colorIdx
      })), l.size === 0 && !(_t || V || r()) && H(k, "pencil")
    }
    H(W, l.size, !0), Wt && !x() ? yt([...l.values()]) : Wt && x() && At && yt([...F.values()])
  }

  function lt(Ge, xt) {
    const {
      tile: Wt,
      pixel: At
    } = g(z).latLonToTileAndPixel(Ge[0], Ge[1], s.tileZoom), pr = Gf({
      tile: Wt,
      pixel: At,
      season: s.season
    }), ar = l.get(pr);
    if (ar) {
      Yt(ar.colorIdx), requestAnimationFrame(() => {
        var Or;
        (Or = document.getElementById(`color-${ar.colorIdx}`)) == null || Or.focus()
      });
      return
    }
    const zr = window.devicePixelRatio,
      Jr = Math.floor(xt.x * zr),
      jr = Math.floor(xt.y * zr);
    s.hidePixelHover(), X_e(s.map, Jr, jr).then(([Or, Fr, rn]) => {
      const An = l0({
        r: Or,
        g: Fr,
        b: rn
      });
      Yt(An), requestAnimationFrame(() => {
        var kn;
        (kn = document.getElementById(`color-${An}`)) == null || kn.focus()
      })
    })
  }
  ps(() => g(E), () => {
    s.clickedLatLon && !g(ge) && (g(E) === void 0 && H(E, 1), Et([s.clickedLatLon], g(E)))
  }), cn(() => {
    const Ge = g($) ? .8 : 0;
    s.crosshair.setCanvasOpacity(Ge)
  });
  let $t = Je(16.5);
  cn(() => {
    if (g(Ye) && g(Ce) && s.clickedLatLon) {
      const Ge = s.map.getZoom();
      if (Ge < g($t)) {
        const [xt, Wt] = s.clickedLatLon, At = g(z).latLonToPixelBoundsLatLon(xt, Wt, s.tileZoom), pr = im(At), ar = g(Ye) - g(Ce).clientHeight, zr = g(Ye) / 2 - ar / 2;
        s.map.flyTo({
          center: {
            lat: pr[0],
            lng: pr[1]
          },
          zoom: 17.5,
          offset: Ge > 11 ? [0, -zr] : [0, 0]
        })
      }
      H($t, s.tileZoom, !0)
    }
  }), Yi(() => {
    const Ge = () => {
      !document.hidden && (x() ? yt([...F.values()]) : yt([...l.values()]))
    };
    return document.addEventListener("visibilitychange", Ge), () => document.removeEventListener("visibilitychange", Ge)
  }), cn(() => {
    switch (g(k)) {
      case "pencil":
        s.map.getCanvas().style.cursor = `url('${w0e}') 8 8, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        s.map.getCanvas().style.cursor = `url('${b0e}') 0 16, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        s.map.getCanvas().style.cursor = `url('${x0e}') 2 14, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), cn(() => {
    r() ? Xt() : fr()
  });
  async function yt(Ge) {
    await Jx(Ge), s.refreshPixelArt()
  }
  async function Rt() {
    await r_(), We.clear(), s.refreshPixelArt(), s.crosshair.clear()
  }
  async function jt() {
    await Rt(), fr(), s.map.getCanvas().style.cursor = "default", s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4), Ot.clear(), s.onclose()
  }

  function Xt() {
    s.map.dragPan.disable(), s.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function fr() {
    s.map.dragPan.enable(), s.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function Yt(Ge) {
    return Ge >= 32 && H(Le, !0), Dt.hasColor(Ge) ? (xi.smallDropplet.play(), H(E, Ge, !0), H(k, "pencil"), !0) : (xi.smallDropplet.play(), H(Xe, !0), H(tt, Ge, !0), !1)
  }
  Nx(Ge => {
    Ge.type === "leave" && g(W) > 0 && Ge.cancel()
  });
  const lr = "show-paint-more-than-one-pixel-msg";
  let ot = Je(!1);
  Yi(() => {
    var Ge;
    H(ot, !localStorage.getItem(lr) && (((Ge = Dt.data) == null ? void 0 : Ge.pixelsPainted) ?? 0) < 100, !0)
  }), cn(() => {
    g(W) > 1 && (H(ot, !1), localStorage.setItem(lr, "false"))
  });
  const nt = "lp";
  Yi(() => {
    var xt;
    const Ge = localStorage.getItem(nt);
    if (Ge) try {
      const Wt = JSON.parse(atob(Ge)),
        At = (Wt == null ? void 0 : Wt.time) ?? 0,
        pr = 60 * 1e3;
      (Wt == null ? void 0 : Wt.userId) !== ((xt = Dt.data) == null ? void 0 : xt.id) && Date.now() - At < 30 * pr && !W1 && (Zt.error(mB()), jt())
    } catch (Wt) {
      console.error(Wt)
    }
  });

  function Ut() {
    var xt;
    const Ge = btoa(JSON.stringify({
      userId: (xt = Dt.data) == null ? void 0 : xt.id,
      time: Date.now()
    }));
    localStorage.setItem(nt, Ge)
  }
  class Qt {
    constructor() {
      mn(this, "history", []);
      mn(this, "actionInProgress", !1);
      mn(this, "historyIdx", -1);
      wn(this, Nt, Je(!1));
      wn(this, wt, Je(!1))
    }
    get canUndo() {
      return g(ir(this, Nt))
    }
    set canUndo(xt) {
      H(ir(this, Nt), xt, !0)
    }
    get canRedo() {
      return g(ir(this, wt))
    }
    set canRedo(xt) {
      H(ir(this, wt), xt, !0)
    }
    undo() {
      if (this.historyIdx < 0) return;
      const xt = this.history[this.historyIdx];
      if (xt) {
        const Wt = this.mergeActions(xt.undo);
        for (const At of Wt) this.applyAction(At)
      }
      this.historyIdx--, this.refreshCanUndoRedo()
    }
    redo() {
      if (this.historyIdx >= this.history.length - 1) return;
      this.historyIdx++;
      const xt = this.history[this.historyIdx];
      if (xt) {
        const Wt = this.mergeActions(xt.redo);
        for (const At of Wt) this.applyAction(At)
      }
      this.refreshCanUndoRedo()
    }
    saveAction(xt, Wt) {
      this.actionInProgress || (this.historyIdx < this.history.length - 1 && (this.history = this.history.slice(0, this.historyIdx + 1)), this.actionInProgress = !0, this.historyIdx++, this.history.push({
        redo: [],
        undo: []
      }));
      const At = this.history[this.historyIdx];
      At && (At.redo.push(xt), At.undo.push(Wt))
    }
    finishAction() {
      this.actionInProgress = !1, this.refreshCanUndoRedo()
    }
    clear() {
      this.history = [], this.actionInProgress = !1, this.historyIdx = -1, this.refreshCanUndoRedo()
    }
    mergeActions(xt) {
      const Wt = {
          type: "erase",
          latLons: []
        },
        At = new Map;
      for (const ar of xt)
        if (ar.type === "erase") Wt.latLons.push(...ar.latLons);
        else {
          const zr = At.get(ar.colorIdx);
          zr ? zr.latLons.push(...ar.latLons) : At.set(ar.colorIdx, {
            type: "paint",
            colorIdx: ar.colorIdx,
            latLons: [...ar.latLons]
          })
        } const pr = [];
      if (Wt.latLons.length > 0 && pr.push(Wt), At.size > 0)
        for (const ar of At.values()) pr.push(ar);
      return pr
    }
    applyAction(xt) {
      switch (xt.type) {
        case "paint":
          Et(xt.latLons, xt.colorIdx, !1);
          break;
        case "erase":
          Pt(xt.latLons, !1);
          break
      }
    }
    refreshCanUndoRedo() {
      this.canUndo = this.historyIdx >= 0, this.canRedo = this.historyIdx < this.history.length - 1
    }
  }
  Nt = new WeakMap, wt = new WeakMap;
  const Ot = new Qt;
  var mr = rye();
  In("keypress", Os, Ge => {
    switch (Ge.code) {
      case "KeyZ":
        (Ge.ctrlKey || Ge.metaKey) && (Ge.shiftKey ? Ot.redo() : Ot.undo());
        break;
      case "KeyY":
        (Ge.ctrlKey || Ge.metaKey) && Ot.redo()
    }
  });
  var zt = Ct(mr),
    Mt = M(zt);
  {
    var kt = Ge => {
        Tc(Ge, {
          children: (xt, Wt) => {
            var At = X0e(),
              pr = Ct(At);
            yy(pr, {
              class: "inline size-5"
            });
            var ar = D(pr);
            Re(zr => te(ar, ` ${zr??""}`), [() => YH()]), q(xt, At)
          },
          $$slots: {
            default: !0
          }
        })
      },
      It = Ge => {
        var xt = Sr(),
          Wt = Ct(xt);
        {
          var At = ar => {
              Tc(ar, {
                class: "not-touchscreen:hidden",
                children: (zr, Jr) => {
                  var jr = Y0e(),
                    Or = Ct(jr);
                  n_(Or, {
                    class: "inline size-5"
                  });
                  var Fr = D(Or);
                  Re(rn => te(Fr, ` ${rn??""}`), [() => c$()]), q(zr, jr)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            pr = ar => {
              var zr = Sr(),
                Jr = Ct(zr);
              {
                var jr = Fr => {
                    Tc(Fr, {
                      class: "not-touchscreen:hidden",
                      children: (rn, An) => {
                        var kn = K0e(),
                          Kr = Ct(kn);
                        Kv(Kr, {
                          class: "inline size-5"
                        });
                        var Ur = D(Kr, 1, !0);
                        Re(Cn => te(Ur, Cn), [() => OV()]), q(rn, kn)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Or = Fr => {
                    var rn = Sr(),
                      An = Ct(rn);
                    {
                      var kn = Ur => {
                          Tc(Ur, {
                            class: "touchscreen:hidden",
                            children: (Cn, En) => {
                              var Tn = J0e(),
                                Un = Ct(Tn);
                              xy(Un, {
                                class: "inline size-5"
                              });
                              var Jn = D(Un),
                                ft = M(Jn, !0);
                              S(Jn);
                              var Ft = D(Jn, 2),
                                Lr = M(Ft),
                                On = D(Lr),
                                Zn = M(On, !0);
                              S(On), S(Ft);
                              var Si = D(Ft);
                              Re((Kn, Nn, Ri, Br) => {
                                te(ft, Kn), te(Lr, `${Nn??""} `), te(Zn, Ri), te(Si, ` ${Br??""}`)
                              }, [() => oT(), () => Wq(), () => v2(), () => $Q()]), q(Cn, Tn)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        Kr = Ur => {
                          var Cn = Sr(),
                            En = Ct(Cn);
                          {
                            var Tn = Un => {
                              Tc(Un, {
                                class: "bg-warning text-warning-content animate-bounce",
                                children: (Jn, ft) => {
                                  var Ft = Q0e(),
                                    Lr = Ct(Ft);
                                  bl(Lr, {
                                    class: "inline size-5"
                                  });
                                  var On = D(Lr);
                                  Re(Zn => te(On, ` ${Zn??""}`), [() => see()]), q(Jn, Ft)
                                },
                                $$slots: {
                                  default: !0
                                }
                              })
                            };
                            Te(En, Un => {
                              g(ot) && Un(Tn)
                            }, !0)
                          }
                          q(Ur, Cn)
                        };
                      Te(An, Ur => {
                        g(we) && g(W) === 0 ? Ur(kn) : Ur(Kr, !1)
                      }, !0)
                    }
                    q(Fr, rn)
                  };
                Te(Jr, Fr => {
                  g(be) ? Fr(jr) : Fr(Or, !1)
                }, !0)
              }
              q(ar, zr)
            };
          Te(Wt, ar => {
            g(Fe) ? ar(At) : ar(pr, !1)
          }, !0)
        }
        q(Ge, xt)
      };
    Te(Mt, Ge => {
      g(Fe) && g(W) === 0 ? Ge(kt) : Ge(It, !1)
    })
  }
  var Gt = D(Mt, 2),
    ht = M(Gt);
  ht.__click = () => H($, !g($));
  var hr = M(ht);
  {
    var wr = Ge => {
        M0e(Ge, {
          class: "size-4"
        })
      },
      ur = Ge => {
        C0e(Ge, {
          class: "size-4"
        })
      };
    Te(hr, Ge => {
      g($) ? Ge(wr) : Ge(ur, !1)
    })
  }
  S(ht);
  var qr = D(ht, 2),
    kr = M(qr),
    Zr = M(kr),
    Wr = D(Zr);
  gy(Wr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${g(W)??""})`
    },
    mono: !0
  }), S(kr);
  var tr = D(kr, 2),
    Hr = M(tr),
    sr = M(Hr);
  bn(), S(Hr);
  var de = D(Hr, 2);
  de.__click = () => {
    H(k, "colorpicker")
  };
  var O = M(de);
  Kv(O, {
    class: "size-4.5"
  }), S(de), S(tr);
  var N = D(tr, 2),
    X = M(N);
  let re;
  X.__click = () => {
    x(!x())
  };
  var Q = M(X);
  {
    let Ge = mt(() => !x());
    by(Q, {
      class: "size-4.5",
      get filled() {
        return g(Ge)
      }
    })
  }
  S(X), S(N);
  var ue = D(N, 2),
    ke = M(ue),
    xe = M(ke);
  bn(), S(ke);
  var Ee = D(ke, 2);
  let He;
  Ee.__click = () => {
    Ot.undo()
  };
  var Be = M(Ee);
  $0e(Be, {
    class: "size-4.5"
  }), S(Ee), S(ue);
  var ie = D(ue, 2),
    J = M(ie),
    Ve = M(J);
  bn(), S(J);
  var rt = D(J, 2);
  let Ue;
  rt.__click = () => {
    Ot.redo()
  };
  var ae = M(rt);
  G0e(ae, {
    class: "size-4.5"
  }), S(rt), S(ie), S(qr);
  var Ie = D(qr, 2);
  Ie.__click = () => {
    xi.smallPlop.play(), jt()
  };
  var $e = M(Ie);
  Ro($e, {
    class: "size-4"
  }), S(Ie), S(Gt);
  var dt = D(Gt, 2),
    Tt = M(dt);
  si(Tt, 23, () => g(Ne), Ge => Ge.idx, (Ge, xt, Wt) => {
    const At = mt(() => {
        const [rn, An, kn] = g(xt).rgb;
        return {
          r: rn,
          g: An,
          b: kn
        }
      }),
      pr = mt(() => g(E) === g(xt).idx && g(we)),
      ar = mt(() => g(xt).idx === 0),
      zr = mt(() => Dt.hasColor(g(xt).idx));
    var Jr = tye(),
      jr = M(Jr);
    jr.__click = () => {
      Yt(g(xt).idx)
    };
    var Or = M(jr);
    {
      var Fr = rn => {
        var An = eye(),
          kn = Ct(An);
        j_(kn, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var Kr = D(kn, 2),
          Ur = M(Kr);
        j_(Ur, {
          class: "text-base-content/80 size-4"
        }), S(Kr), q(rn, An)
      };
      Te(Or, rn => {
        g(zr) || rn(Fr)
      })
    }
    S(jr), S(Jr), Re(() => {
      Vr(Jr, 1, qs({
        tooltip: !0,
        "max-sm:h-6": g(Le),
        "max-sm:before:translate-x-1/4": g(Wt) % 8 === 0 && g(xt).label.length > 7,
        "max-sm:before:-translate-x-1/4": (g(Wt) - 7) % 8 === 0 && g(xt).label.length > 7,
        "max-xl:before:translate-x-1/4": g(Wt) % 16 === 0 && g(xt).label.length > 7,
        "max-xl:before:-translate-x-1/4": (g(Wt) - 15) % 16 === 0 && g(xt).label.length > 7,
        "xl:before:translate-x-1/4": g(Le) && g(Wt) % 32 === 0 && g(xt).label.length > 7,
        "xl:before:-translate-x-1/4": g(Le) && (g(Wt) - 31) % 32 === 0 && g(xt).label.length > 7
      })), er(Jr, "data-tip", g(xt).label), Vr(jr, 1, qs({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": g(pr),
        "border-base-300": !g(pr) && g(ar),
        "border-base-content/20": !g(pr) && !g(ar),
        "max-sm:h-6 max-sm:rounded-md": g(Le)
      })), ds(jr, g(ar) ? `background-image: url(${k0e}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${g(At).r} ${g(At).g} ${g(At).b})`), er(jr, "aria-label", g(xt).label), er(jr, "id", `color-${g(xt).idx??""}`)
    }), In("focus", jr, () => {
      g(zr) && (H(E, g(xt).idx, !0), H(k, "pencil"))
    }), q(Ge, Jr)
  }), S(Tt), S(dt);
  var pt = D(dt, 2),
    St = M(pt);
  St.__click = () => {
    H(Le, !g(Le))
  };
  var qt = M(St);
  {
    var qe = Ge => {
        e1(Ge, {
          class: "size-5"
        })
      },
      bt = Ge => {
        t1(Ge, {
          class: "size-5"
        })
      };
    Te(qt, Ge => {
      g(Le) ? Ge(qe) : Ge(bt, !1)
    })
  }
  S(St);
  var Jt = D(St, 2),
    Cr = M(Jt);
  {
    let Ge = mt(() => g(W) > 100 ? "animate-pulse" : ""),
      xt = mt(() => g(W) === 0 || g(ee) || g(_e) < 0);
    vy(Cr, {
      get class() {
        return g(Ge)
      },
      get charges() {
        return g(_e)
      },
      get disabled() {
        return g(xt)
      },
      get loading() {
        return g(ee)
      },
      onclick: async () => {
        xi.droppletAndPlop.play();
        const Wt = [...l.values()];
        H(ee, !0);
        try {
          const At = await lm();
          await dn.paint(Wt, At), await U_(Wt), Ut(), Dt.refresh(), up.shouldReload = !0, await jt()
        } catch (At) {
          Zt.error(`${At.message}`, {
            duration: 7e3
          })
        } finally {
          H(ee, !1)
        }
      }
    })
  }
  S(Jt);
  var _r = D(Jt, 2),
    Qe = M(_r),
    rr = M(Qe),
    Kt = M(rr);
  bn(), S(rr);
  var Tr = D(rr, 2);
  let Rr;
  Tr.__click = () => {
    H(k, g(k) === "eraser" ? "pencil" : "eraser", !0)
  };
  var Qr = M(Tr);
  n_(Qr, {
    class: "size-5",
    get filled() {
      return g(Fe)
    }
  }), S(Tr), S(Qe), S(_r), S(pt), S(zt), ja(zt, Ge => H(Ce, Ge), () => g(Ce));
  var br = D(zt, 2);
  B0e(br, {
    get colorIdx() {
      return g(tt)
    },
    get open() {
      return g(Xe)
    },
    set open(Ge) {
      H(Xe, Ge, !0)
    }
  }), Re((Ge, xt, Wt, At, pr, ar) => {
    te(Zr, `${Ge??""} `), te(sr, `${xt??""} `), Vr(de, 1, qs({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !g(be),
      "btn-primary": g(be)
    })), er(N, "data-tip", Wt), re = Vr(X, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, re, {
      "text-primary": !x()
    }), te(xe, `${At??""} `), He = Vr(Ee, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, He, {
      "opacity-50": !Ot.canUndo
    }), Ee.disabled = !Ot.canUndo, te(Ve, `${pr??""} `), Ue = Vr(rt, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Ue, {
      "opacity-50": !Ot.canRedo
    }), rt.disabled = !Ot.canRedo, Vr(Tt, 1, qs({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": g(Le),
      "gap-1": !g(Le)
    })), te(Kt, `${ar??""} `), Rr = Vr(Tr, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, Rr, {
      "btn-primary": g(Fe)
    }), Tr.disabled = g(W) === 0
  }, [() => zN(), () => yT(), () => C0(), () => Vte(), () => ZG(), () => i1()]), Ch("innerHeight", Ge => H(Ye, Ge, !0)), q(p, mr), an()
}
Yn(["click"]);
var iye = he('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></form></div></dialog>');

function aye(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(!1),
    z = Je("");
  var E = iye(),
    k = M(E),
    l = D(M(k), 2),
    F = M(l, !0);
  S(l);
  var W = D(l, 2),
    ee = M(W),
    $ = M(ee);
  zp($, () => Ahe()), S(ee);
  var se = D(ee, 2),
    _e = M(se);
  {
    let be = mt(() => M5()),
      Xe = mt(() => q5());
    c0(_e, {
      get label() {
        return g(be)
      },
      get placeholder() {
        return g(Xe)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return g(x)
      },
      get value() {
        return g(z)
      },
      set value(tt) {
        H(z, tt, !0)
      }
    })
  }
  S(se);
  var ge = D(se, 2),
    V = M(ge);
  V.__click = () => {
    r(!1)
  };
  var Me = M(V, !0);
  S(V);
  var we = D(V, 2),
    Fe = M(we, !0);
  S(we), S(ge), S(W), S(k), S(E), Ji(E, () => be => {
    cn(() => {
      r() ? be.show() : be.close()
    })
  }), Re((be, Xe, tt) => {
    te(F, be), V.disabled = g(x), te(Me, Xe), we.disabled = g(x) || g(z).length <= 1, te(Fe, tt)
  }, [() => s.userData.banned ? L1() : wQ(), () => hs(), () => _K()]), In("close", E, () => r(!1)), In("submit", W, async () => {
    try {
      if (H(x, !0), await dn.submitBanAppeal(g(z)) === 208) {
        Zt.error(jue());
        return
      }
      Zt.success(Q5()), r(!1)
    } catch (be) {
      Zt.error(be.message, {
        duration: 5e3
      })
    } finally {
      H(x, !1)
    }
  }), q(p, E), an()
}
Yn(["click"]);
var oye = he("<span> </span>");

function Jv(p, s) {
  nn(s, !0);
  var r = oye(),
    x = M(r, !0);
  S(r), Re(() => {
    Vr(r, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${s.count<10?"text-xs":"text-[10px]"} ${s.class??""}`), te(x, s.count < 10 ? s.count : "9+")
  }), q(p, r), an()
}
var sye = he('<p class="text-error mt-1 text-sm"> </p>'),
  lye = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  cye = he('<dialog class="modal bg-black/80!"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 mt-6 w-full border py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function uye(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(""),
    z = Je(null),
    E = Je(!1),
    k = mt(() => {
      var Pt;
      return ((Pt = Dt.data) == null ? void 0 : Pt.name) ?? ""
    });
  cn(() => {
    r() || (H(x, ""), H(z, null))
  });
  var l = cye(),
    F = M(l),
    W = D(M(F), 2),
    ee = M(W);
  h1(ee, {
    class: "text-error size-5"
  });
  var $ = D(ee, 2),
    se = M($, !0);
  S($), S(W);
  var _e = D(W, 2),
    ge = M(_e),
    V = M(ge, !0);
  S(ge);
  var Me = D(ge);
  S(_e);
  var we = D(_e, 2),
    Fe = M(we);
  S(we);
  var be = D(we, 2),
    Xe = M(be, !0);
  S(be);
  var tt = D(be, 2);
  Ki(tt);
  var Ye = D(tt, 2);
  {
    var Ce = Pt => {
      var lt = sye(),
        $t = M(lt, !0);
      S(lt), Re(() => te($t, g(z))), q(Pt, lt)
    };
    Te(Ye, Pt => {
      g(z) && Pt(Ce)
    })
  }
  var De = D(Ye, 2),
    Ke = M(De);
  Ke.__click = () => {
    r(!1)
  };
  var Le = M(Ke, !0);
  S(Ke);
  var Ne = D(Ke, 2);
  Ne.__click = async () => {
    if (g(x) !== g(k)) {
      H(z, Ux(), !0);
      return
    }
    try {
      H(E, !0), await dn.deleteMe(g(k)), Zt.warning(Z2()), await Dt.logout(), r(!1)
    } catch (Pt) {
      Zt.error(Pt.message)
    } finally {
      H(E, !1)
    }
  };
  var vt = M(Ne),
    et = D(vt);
  {
    var We = Pt => {
      var lt = lye();
      q(Pt, lt)
    };
    Te(et, Pt => {
      g(E) && Pt(We)
    })
  }
  S(Ne), S(De), S(F);
  var _t = D(F, 2),
    Vt = M(_t),
    Et = M(Vt, !0);
  S(Vt), S(_t), S(l), Ji(l, () => Pt => {
    cn(() => {
      r() ? Pt.show() : Pt.close()
    })
  }), Re((Pt, lt, $t, yt, Rt, jt, Xt, fr, Yt) => {
    te(se, Pt), te(V, lt), te(Me, ` ${$t??""}`), te(Fe, `${yt??""} ${Rt??""}`), te(Xe, g(k)), er(tt, "placeholder", jt), te(Le, Xt), Ne.disabled = g(E), te(vt, `${fr??""} `), te(Et, Yt)
  }, [() => o_(), () => d3(), () => YJ(), () => pJ(), () => nte(), () => mte(), () => jc(), () => o_(), () => hs()]), In("close", l, () => r(!1)), yl(tt, () => g(x), Pt => H(x, Pt)), q(p, l), an()
}
Yn(["click"]);
var hye = he('<p class="text-base-content/80 text-sm"> </p>'),
  dye = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  pye = he('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function fye(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = nr(s, "type", 3, "confirmation"),
    z = nr(s, "buttonText", 19, () => v0()),
    E = Je(!1);
  dm(p, {
    dialogClass: "!bg-black/80",
    get open() {
      return r()
    },
    set open(k) {
      r(k)
    },
    children: (k, l) => {
      var F = pye(),
        W = Ct(F),
        ee = M(W, !0);
      S(W);
      var $ = D(W, 2),
        se = M($, !0);
      S($);
      var _e = D($, 2);
      {
        var ge = De => {
          var Ke = hye(),
            Le = M(Ke, !0);
          S(Ke), Re(() => te(Le, s.subDescription)), q(De, Ke)
        };
        Te(_e, De => {
          s.subDescription && De(ge)
        })
      }
      var V = D(_e, 2),
        Me = M(V),
        we = M(Me),
        Fe = M(we, !0);
      S(we), S(Me);
      var be = D(Me, 2);
      let Xe;
      be.__click = async () => {
        try {
          H(E, !0), r(await s.onConfirm())
        } finally {
          H(E, !1)
        }
      };
      var tt = M(be),
        Ye = D(tt);
      {
        var Ce = De => {
          var Ke = dye();
          q(De, Ke)
        };
        Te(Ye, De => {
          g(E) && De(Ce)
        })
      }
      S(be), S(V), Re(De => {
        te(ee, s.title), te(se, s.description), te(Fe, De), Xe = Vr(be, 1, "btn relative", null, Xe, {
          "btn-error": x() === "warning",
          "btn-primary": x() === "confirmation"
        }), be.disabled = g(E), te(tt, `${z()??""} `)
      }, [() => jc()]), q(k, F)
    },
    $$slots: {
      default: !0
    }
  }), an()
}
Yn(["click"]);

function _ye(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  {
    let x = mt(() => u0()),
      z = mt(() => eR()),
      E = mt(() => TH());
    fye(p, {
      type: "warning",
      get title() {
        return g(x)
      },
      get description() {
        return g(z)
      },
      get subDescription() {
        return g(E)
      },
      onConfirm: async () => {
        try {
          return await dn.deleteSessions(), Zt.success(d1()), await Dt.logout(), !0
        } catch {
          return Zt.error(p1()), !1
        }
      },
      get open() {
        return r()
      },
      set open(k) {
        r(k)
      }
    })
  }
  an()
}
var mye = he('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  gye = he('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  vye = he('<button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="relative"><div class="relative flex size-16 items-center justify-center overflow-hidden rounded-full"><img class="pointer-events-none absolute inset-0 rounded-full object-cover"/></div></div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button>'),
  yye = he('<div class="flex gap-2"><div class="bg-base-200 aspect-square rounded-lg p-4"><div class="relative"><!></div></div> <div class="bg-base-200 flex flex-col items-center justify-center gap-4 rounded-lg p-2"><div class="relative"><!></div> <div class="relative"><!></div></div></div>'),
  bye = he('<span class="loading loading-spinner"></span>'),
  xye = he('<dialog class="modal"><div class="modal-box max-h-11/12 max-w-2xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="text-lg font-bold"> </h3> <p class="text-base-content/80 mb-3 text-sm"> </p> <div class="grid grow grid-cols-1 gap-4 sm:grid-cols-[1fr_auto]"><section class="overflow-y-auto"><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <div class="grid grid-cols-2 gap-3 sm:grid-cols-3"><button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="text-base-content/60 border-base-content/60 flex size-16 items-center justify-center rounded-full border text-xs font-semibold"> </div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button> <!></div> <h4 class="text-base-content/80 mb-2 mt-4 text-sm font-semibold"> </h4> <span class="text-base-content/70 text-xs"> </span> <p class="sm:pt-10"></p></section> <section class="flex flex-col justify-between"><div><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <!></div> <div class="mt-4 flex justify-end"><button type="button" class="btn mr-2"> </button> <button type="button" class="btn btn-primary"><!></button></div></section></div></div></dialog>');

function wye(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(yi([]));
  const z = yi(Dt.data);
  let E = Je(!1),
    k = Je(null);
  cn(() => {
    z && z.equippedFrameId !== void 0 && g(k) === null && H(k, z.equippedFrameId || 0, !0)
  });

  function l(Mt) {
    g(E) || H(k, Mt, !0)
  }
  async function F() {
    if (!(g(E) || g(k) === null)) {
      H(E, !0);
      try {
        await dn.postEquipUserFrame(g(k)), await Dt.refresh(), Zt.success(zse())
      } catch {
        Zt.error(Use())
      } finally {
        H(E, !1)
      }
    }
  }

  function W(Mt) {
    if (Mt === null || Mt === 0) return !1;
    const kt = g(x).find(It => It.id === Mt);
    return kt ? !!kt.value && kt.value > 0 : !1
  }
  Yi(async () => {
    try {
      H(x, await dn.getUserFrames(), !0), H(k, z.equippedFrameId || 0, !0)
    } catch {
      Zt.error(D1())
    }
  });
  var ee = xye(),
    $ = M(ee),
    se = M($),
    _e = M(se);
  _e.__click = () => {
    r(!1)
  }, S(se);
  var ge = D(se, 2),
    V = M(ge, !0);
  S(ge);
  var Me = D(ge, 2),
    we = M(Me, !0);
  S(Me);
  var Fe = D(Me, 2),
    be = M(Fe),
    Xe = M(be),
    tt = M(Xe, !0);
  S(Xe);
  var Ye = D(Xe, 2),
    Ce = M(Ye);
  Ce.__click = () => l(0);
  var De = M(Ce),
    Ke = M(De),
    Le = M(Ke, !0);
  S(Ke), S(De);
  var Ne = D(De, 2),
    vt = M(Ne),
    et = M(vt, !0);
  S(vt);
  var We = D(vt, 2),
    _t = M(We, !0);
  S(We), S(Ne);
  var Vt = D(Ne, 2);
  {
    var Et = Mt => {
      var kt = mye(),
        It = M(kt),
        Gt = M(It, !0);
      S(It), S(kt), Re(ht => te(Gt, ht), [() => vv()]), q(Mt, kt)
    };
    Te(Vt, Mt => {
      g(k) === 0 && Mt(Et)
    })
  }
  S(Ce);
  var Pt = D(Ce, 2);
  si(Pt, 17, () => g(x), Mt => Mt.id, (Mt, kt) => {
    var It = vye();
    It.__click = () => l(g(kt).id);
    var Gt = M(It),
      ht = M(Gt),
      hr = M(ht),
      wr = M(hr);
    S(hr), S(ht), S(Gt);
    var ur = D(Gt, 2),
      qr = M(ur),
      kr = M(qr, !0);
    S(qr);
    var Zr = D(qr, 2),
      Wr = M(Zr, !0);
    S(Zr), S(ur);
    var tr = D(ur, 2);
    {
      var Hr = sr => {
        var de = gye(),
          O = M(de),
          N = M(O, !0);
        S(O), S(de), Re(X => te(N, X), [() => vv()]), q(sr, de)
      };
      Te(tr, sr => {
        g(k) === g(kt).id && sr(Hr)
      })
    }
    S(It), Re(() => {
      Vr(It, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
									transition disabled:opacity-50
									${g(k)===g(kt).id?" border-primary bg-primary/10":""}`), It.disabled = g(E), er(wr, "src", g(kt).imageUrl), er(wr, "alt", g(kt).name), te(kr, g(kt).name), te(Wr, g(kt).description)
    }), q(Mt, It)
  }), S(Ye);
  var lt = D(Ye, 2),
    $t = M(lt, !0);
  S(lt);
  var yt = D(lt, 2),
    Rt = M(yt, !0);
  S(yt), bn(2), S(be);
  var jt = D(be, 2),
    Xt = M(jt),
    fr = M(Xt),
    Yt = M(fr, !0);
  S(fr);
  var lr = D(fr, 2);
  Ec(lr, () => g(k), Mt => {
    const kt = mt(() => g(x).find(Wr => Wr.id === g(k)));
    var It = yye(),
      Gt = M(It),
      ht = M(Gt),
      hr = M(ht);
    {
      let Wr = mt(() => {
        var tr;
        return (tr = g(kt)) == null ? void 0 : tr.imageUrl
      });
      Ra(hr, {
        class: "size-20",
        get userId() {
          return z.id
        },
        get pictureUrl() {
          return z.picture
        },
        get borderUrl() {
          return g(Wr)
        }
      })
    }
    S(ht), S(Gt);
    var wr = D(Gt, 2),
      ur = M(wr),
      qr = M(ur);
    {
      let Wr = mt(() => {
        var tr;
        return (tr = g(kt)) == null ? void 0 : tr.imageUrl
      });
      Ra(qr, {
        class: "size-10",
        get userId() {
          return z.id
        },
        get pictureUrl() {
          return z.picture
        },
        get borderUrl() {
          return g(Wr)
        }
      })
    }
    S(ur);
    var kr = D(ur, 2),
      Zr = M(kr);
    {
      let Wr = mt(() => {
        var tr;
        return (tr = g(kt)) == null ? void 0 : tr.imageUrl
      });
      Ra(Zr, {
        class: "size-5",
        get userId() {
          return z.id
        },
        get pictureUrl() {
          return z.picture
        },
        get borderUrl() {
          return g(Wr)
        }
      })
    }
    S(kr), S(wr), S(It), q(Mt, It)
  }), S(Xt);
  var ot = D(Xt, 2),
    nt = M(ot);
  nt.__click = () => {
    r(!1)
  };
  var Ut = M(nt, !0);
  S(nt);
  var Qt = D(nt, 2);
  Qt.__click = F;
  var Ot = M(Qt);
  {
    var mr = Mt => {
        var kt = bye();
        q(Mt, kt)
      },
      zt = Mt => {
        var kt = Sr(),
          It = Ct(kt);
        {
          var Gt = hr => {
              var wr = Oi();
              Re(ur => te(wr, ur), [() => Bce()]), q(hr, wr)
            },
            ht = hr => {
              var wr = Oi();
              Re(ur => te(wr, ur), [() => h0()]), q(hr, wr)
            };
          Te(It, hr => {
            W(g(k)) ? hr(Gt) : hr(ht, !1)
          }, !0)
        }
        q(Mt, kt)
      };
    Te(Ot, Mt => {
      g(E) ? Mt(mr) : Mt(zt, !1)
    })
  }
  S(Qt), S(ot), S(jt), S(Fe), S($), S(ee), Ji(ee, () => Mt => {
    cn(() => {
      r() ? Mt.showModal() : Mt.close()
    })
  }), Re((Mt, kt, It, Gt, ht, hr, wr, ur, qr, kr) => {
    te(V, Mt), te(we, kt), te(tt, It), Vr(Ce, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
								transition disabled:opacity-50
								${g(k)===0?" border-primary bg-primary/10":""}`), Ce.disabled = g(E), te(Le, Gt), te(et, ht), te(_t, hr), te($t, wr), te(Rt, ur), te(Yt, qr), nt.disabled = g(E), te(Ut, kr), Qt.disabled = g(E) || g(k) === null
  }, [() => rle(), () => _le(), () => Ile(), () => Kce(), () => uue(), () => Nle(), () => dce(), () => Sce(), () => o1(), () => jc()]), In("close", ee, () => r(!1)), q(p, ee), an()
}
Yn(["click"]);
var kye = he('<img alt="Frame equipado" class="h-30 w-30 pointer-events-none absolute inset-0 select-none"/>'),
  Tye = he('<span class="center-absolute loading loading-spinner absolute"></span>'),
  Sye = he('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  Pye = he('<span class="center-absolute loading loading-spinner absolute"></span>'),
  Mye = he('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  Iye = he('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  Cye = he('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  zye = he('<button class="btn btn-error btn-soft"><!> </button>'),
  Aye = he('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative flex w-max items-center gap-2"><div class="relative w-max"><!> <!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <button type="button" class="tooltip btn btn-circle btn-soft tooltip-bottom absolute -bottom-1 -left-1 before:translate-x-1/3"><span class="text-lg">ðŸŽ¨</span></button></div> <!></div> <div class="flex w-full flex-col gap-3"><div class="tooltip tooltip-bottom"><!></div> <!> <label class="label whitespace-pre-line text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!> <!>', 1);

function Eye(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(yi(s.userData.name)),
    z = Je(yi(s.userData.discord)),
    E = Je(yi(s.userData.showLastPixel)),
    k = Je(!1),
    l = Je(void 0),
    F = Je(!1),
    W = Je(!1);
  const ee = Zx("2025-09_discord_linking");
  let $ = Je(!!s.userData.discordId),
    se = Je(!1),
    _e = Je(void 0),
    ge = Je(void 0);
  cn(() => {
    H(x, s.userData.name, !0), H(E, s.userData.showLastPixel, !0)
  }), cn(() => {
    r() && !g(l) && dn.getMyProfilePictures().then(tr => {
      H(l, tr, !0)
    }).catch(tr => {
      Zt.error(tr.message)
    })
  });
  let V = Je(!1);
  async function Me(tr) {
    try {
      H(V, !0), await dn.changeProfilePicture(tr), await Dt.refresh()
    } finally {
      H(V, !1)
    }
  }
  var we = Aye(),
    Fe = Ct(we),
    be = M(Fe),
    Xe = D(M(be), 2),
    tt = M(Xe, !0);
  S(Xe);
  var Ye = D(Xe, 2),
    Ce = M(Ye),
    De = M(Ce),
    Ke = M(De),
    Le = M(Ke),
    Ne = M(Le);
  Ra(Ne, {
    class: "h-30 w-30 relative",
    get userId() {
      return s.userData.id
    },
    get pictureUrl() {
      return s.userData.picture
    }
  });
  var vt = D(Ne, 2);
  {
    var et = tr => {
      var Hr = kye();
      Re(() => er(Hr, "src", s.userData.equippedFrameUrl)), q(tr, Hr)
    };
    Te(vt, tr => {
      s.userData.equippedFrameUrl && tr(et)
    })
  }
  var We = D(vt, 2),
    _t = M(We);
  a0(_t, {
    class: "size-5"
  }), S(We), S(Le);
  var Vt = D(Le, 2);
  Vt.__click = () => {
    H(se, !0)
  }, S(Ke);
  var Et = D(Ke, 2);
  {
    var Pt = tr => {
      var Hr = Iye(),
        sr = M(Hr),
        de = M(sr, !0);
      S(sr);
      var O = D(sr, 2),
        N = M(O);
      {
        var X = Q => {
          var ue = Sye();
          ue.__click = () => {
            Me()
          };
          var ke = M(ue);
          Ra(ke, {
            class: "size-10 border",
            get userId() {
              return s.userData.id
            }
          });
          var xe = D(ke, 2);
          {
            var Ee = He => {
              var Be = Tye();
              q(He, Be)
            };
            Te(xe, He => {
              g(V) && He(Ee)
            })
          }
          S(ue), Re(() => ue.disabled = g(V)), q(Q, ue)
        };
        Te(N, Q => {
          s.userData.picture && Q(X)
        })
      }
      var re = D(N, 2);
      si(re, 17, () => g(l), Q => Q.id, (Q, ue) => {
        var ke = Sr(),
          xe = Ct(ke);
        {
          var Ee = He => {
            var Be = Mye();
            Be.__click = () => {
              Me(g(ue).id)
            };
            var ie = M(Be);
            Ra(ie, {
              class: "size-10 border",
              get userId() {
                return s.userData.id
              },
              get pictureUrl() {
                return g(ue).url
              }
            });
            var J = D(ie, 2);
            {
              var Ve = rt => {
                var Ue = Pye();
                q(rt, Ue)
              };
              Te(J, rt => {
                g(V) && rt(Ve)
              })
            }
            S(Be), Re(() => Be.disabled = g(V)), q(He, Be)
          };
          Te(xe, He => {
            s.userData.picture !== g(ue).url && He(Ee)
          })
        }
        q(Q, ke)
      }), S(O), S(Hr), Re(Q => te(de, Q), [() => xk()]), q(tr, Hr)
    };
    Te(Et, tr => {
      var Hr;
      (Hr = g(l)) != null && Hr.length && tr(Pt)
    })
  }
  S(De);
  var lt = D(De, 2),
    $t = M(lt),
    yt = M($t);
  {
    let tr = mt(() => s_()),
      Hr = mt(() => s_());
    p_(yt, {
      get label() {
        return g(tr)
      },
      get placeholder() {
        return g(Hr)
      },
      min: 1,
      max: 16,
      get value() {
        return g(x)
      },
      set value(sr) {
        H(x, sr, !0)
      },
      get validate() {
        return g(_e)
      },
      set validate(sr) {
        H(_e, sr, !0)
      }
    })
  }
  S($t);
  var Rt = D($t, 2);
  {
    var jt = tr => {
        var Hr = Sr(),
          sr = Ct(Hr);
        {
          var de = N => {
              var X = Cye(),
                re = M(X);
              f_(re, {
                class: "size-4.5"
              });
              var Q = D(re);
              S(X), Re((ue, ke) => {
                er(X, "href", ue), te(Q, ` ${ke??""}`)
              }, [() => Gx("/discord/authorize"), () => zL()]), q(N, X)
            },
            O = N => {
              var X = zye();
              X.__click = async () => {
                try {
                  H(k, !0), await dn.unlinkDiscord(), Dt.refresh(), Zt.success(fre()), H($, !1)
                } catch (ue) {
                  Zt.error(ue.message, {
                    duration: 5e3
                  })
                } finally {
                  H(k, !1)
                }
              };
              var re = M(X);
              f_(re, {
                class: "size-4.5"
              });
              var Q = D(re);
              S(X), Re(ue => {
                X.disabled = g(k), te(Q, ` ${ue??""}`)
              }, [() => {
                var ue;
                return tre({
                  username: ((ue = s.userData) == null ? void 0 : ue.discord) ?? ""
                })
              }]), q(N, X)
            };
          Te(sr, N => {
            g($) ? N(O, !1) : N(de)
          })
        }
        q(tr, Hr)
      },
      Xt = tr => {
        {
          let Hr = mt(() => RM());
          p_(tr, {
            label: "Discord",
            get placeholder() {
              return g(Hr)
            },
            max: 32,
            get value() {
              return g(z)
            },
            set value(sr) {
              H(z, sr, !0)
            },
            get validate() {
              return g(ge)
            },
            set validate(sr) {
              H(ge, sr, !0)
            }
          })
        }
      };
    Te(Rt, tr => {
      ee ? tr(jt) : tr(Xt, !1)
    })
  }
  var fr = D(Rt, 2),
    Yt = M(fr);
  Ki(Yt);
  var lr = D(Yt);
  S(fr), S(lt), S(Ce);
  var ot = D(Ce, 2),
    nt = M(ot),
    Ut = M(nt),
    Qt = M(Ut, !0);
  S(Ut);
  var Ot = D(Ut, 2),
    mr = M(Ot),
    zt = M(mr);
  zt.__click = () => {
    H(W, !0)
  };
  var Mt = M(zt, !0);
  S(zt), S(mr);
  var kt = D(mr, 2),
    It = M(kt);
  It.__click = () => {
    H(F, !0)
  };
  var Gt = M(It, !0);
  S(It), S(kt), S(Ot), S(nt);
  var ht = D(nt, 2),
    hr = M(ht);
  hr.__click = () => {
    r(!1)
  };
  var wr = M(hr, !0);
  S(hr);
  var ur = D(hr, 2),
    qr = M(ur, !0);
  S(ur), S(ht), S(ot), S(Ye), S(be), S(Fe), Ji(Fe, () => tr => {
    cn(() => {
      r() ? tr.showModal() : tr.close()
    })
  });
  var kr = D(Fe, 2);
  uye(kr, {
    get open() {
      return g(F)
    },
    set open(tr) {
      H(F, tr, !0)
    }
  });
  var Zr = D(kr, 2);
  _ye(Zr, {
    get open() {
      return g(W)
    },
    set open(tr) {
      H(W, tr, !0)
    }
  });
  var Wr = D(Zr, 2);
  wye(Wr, {
    get open() {
      return g(se)
    },
    set open(tr) {
      H(se, tr, !0)
    }
  }), Re((tr, Hr, sr, de, O, N, X, re, Q, ue) => {
    te(tt, tr), er(We, "data-tip", Hr), er(Vt, "data-tip", sr), er($t, "data-tip", de), te(lr, ` ${O??""}`), te(Qt, N), te(Mt, X), te(Gt, re), hr.disabled = g(k), te(wr, Q), ur.disabled = g(k), te(qr, ue)
  }, [() => W4(), () => s1(), () => gse(), () => xF(), () => aY(), () => Tj(), () => u0(), () => o_(), () => hs(), () => h0()]), In("close", Fe, () => r(!1)), In("submit", Ye, async () => {
    var tr;
    try {
      if (!((tr = g(_e)) != null && tr())) return;
      H(k, !0), await dn.updateMe({
        name: g(x),
        showLastPixel: g(E)
      }), Dt.refresh(), Zt.success(WZ()), r(!1)
    } catch (Hr) {
      Zt.error(Hr.message, {
        duration: 5e3
      })
    } finally {
      H(k, !1)
    }
  }), gp(Yt, () => g(E), tr => H(E, tr)), q(p, we), an()
}
Yn(["click"]);
var Lye = Yr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function Dye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Lye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Rye = Yr('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function jye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Rye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Fye = Yr('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function Bye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Fye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Oye = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function Qv(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Oye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var qye = Yr('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function Nye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = qye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Vye = Yr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function Uye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Vye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Zye = Yr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function Gye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Zye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...r
  }), void 0, void 0, void 0, "svelte-14mu38d"), q(p, x)
}
var Wye = Yr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function F_(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Wye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Hye = Yr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function rp(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Hye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var $ye = Yr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function Xye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = $ye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Yye = Yr('<svg><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"></path></svg>');

function Kye(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Yye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Jye = Yr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function wy(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Jye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Qye = Yr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function ebe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Qye();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var tbe = Yr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function rbe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = tbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var nbe = he('<img alt="Frame equipado" class="pointer-events-none absolute inset-0 -bottom-1 -right-1 select-none"/>'),
  ibe = he('<span class="tooltip font-flag ml-0.5"> </span>'),
  abe = he('<div class="mt-1"><!></div>'),
  obe = he('<p class="w-full"> <!></p>'),
  sbe = he('<p class="w-full"><!></p>'),
  lbe = he('<div class=" flex items-center gap-2"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  cbe = he('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  ube = he("<li><button><!> </button></li>"),
  hbe = he('<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'),
  dbe = he('<button class="btn btn-sm btn-circle tooltip"><!></button>'),
  pbe = he('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  fbe = he('<a class="btn w-full" target="_blank"><!> </a>'),
  _be = he('<a class="btn w-full" target="_blank"><!> </a>'),
  mbe = he('<a class="btn w-full" target="_blank"><!> </a>'),
  gbe = he('<a class="btn w-full" target="_blank"><!> </a>'),
  vbe = he('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1),
  ybe = he('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle tooltip"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 max-h-[50svh] w-max flex-nowrap overflow-y-auto rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <!> <button class="btn btn-sm btn-circle tooltip relative before:-left-1/2"><!> <!></button></div></div>  <!> <!> <!> <!> <!> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> </a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> </a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function bbe(p, s) {
  var ge;
  nn(s, !0);
  let r = Je(!1),
    x = Je(!1),
    z = Je(!0);

  function E() {
    var V;
    (V = document.activeElement) == null || V.blur()
  }
  const k = [{
    label: "ðŸ‡ºðŸ‡¸ English",
    key: "en"
  }, {
    label: "ðŸ‡§ðŸ‡· PortuguÃªs",
    key: "pt"
  }, ...(ge = s.user.data) != null && ge.role && s.user.data.role !== "user" ? [{
    label: "ðŸ‡¨ðŸ‡³ ä¸­æ–‡",
    key: "ch"
  }, {
    label: "ðŸ‡©ðŸ‡ª Deutsch",
    key: "de"
  }, {
    label: "ðŸ‡ªðŸ‡¸ EspaÃ±ol",
    key: "es"
  }, {
    label: "ðŸ‡«ðŸ‡· FranÃ§ais",
    key: "fr"
  }, {
    label: "ðŸ‡®ðŸ‡¹ Italiano",
    key: "it"
  }, {
    label: "ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž",
    key: "jp"
  }, {
    label: "ðŸ‡µðŸ‡± Polski",
    key: "pl"
  }, {
    label: "ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹",
    key: "ru"
  }, {
    label: "ðŸ‡ºðŸ‡¦ Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ°",
    key: "uk"
  }, {
    label: "ðŸ‡»ðŸ‡³ Tiáº¿ng Viá»‡t",
    key: "vi"
  }] : []];
  let l = Je(""),
    F = Je(void 0);
  const W = mt(() => !!s.user.timeoutUntil);
  let ee = Je("");
  Yi(async () => {
    if (s.user.data || await s.user.refresh(), s.user.hasAnyPermission(Di.dashboard.summary)) {
      H(ee, `${vi.url.origin}/dashboard/summary`);
      return
    }
    if (s.user.hasAnyPermission(Di.dashboard.team)) {
      H(ee, `${vi.url.origin}/dashboard/team`);
      return
    }
    if (s.user.hasAnyPermission(Di.dashboard.users)) {
      H(ee, `${vi.url.origin}/dashboard/users`);
      return
    }
    if (s.user.hasAnyPermission(Di.dashboard.permissions)) {
      H(ee, `${vi.url.origin}/dashboard/permissions`);
      return
    }
    if (s.user.hasAnyPermission(Di.dashboard.alliances)) {
      H(ee, `${vi.url.origin}/dashboard/alliances`);
      return
    }
    if (s.user.hasAnyPermission(Di.dashboard.auditLogs)) {
      H(ee, `${vi.url.origin}/dashboard/audit-logs`);
      return
    }
    if (s.user.hasAnyPermission(Di.dashboard.banWaves)) {
      H(ee, `${vi.url.origin}/dashboard/ban-waves`);
      return
    }
  });
  var $ = Sr(),
    se = Ct($);
  {
    var _e = V => {
      var Me = ybe(),
        we = Ct(Me),
        Fe = M(we);
      let be;
      var Xe = M(Fe);
      s0(Xe, {
        get userId() {
          return s.user.data.id
        },
        get level() {
          return s.user.data.level
        },
        get pictureUrl() {
          return s.user.data.picture
        }
      });
      var tt = D(Xe, 2);
      {
        var Ye = Nt => {
          Jv(Nt, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return s.user.notificiationCount
            }
          })
        };
        Te(tt, Nt => {
          s.user.notificiationCount && Nt(Ye)
        })
      }
      S(Fe);
      var Ce = D(Fe, 2),
        De = M(Ce);
      De.__click = E;
      var Ke = M(De);
      Ro(Ke, {
        class: "size-5"
      }), S(De);
      var Le = D(De, 2),
        Ne = M(Le),
        vt = M(Ne);
      Ra(vt, {
        get userId() {
          return s.user.data.id
        },
        get pictureUrl() {
          return s.user.data.picture
        },
        get isSuspended() {
          return g(W)
        }
      });
      var et = D(vt, 2);
      {
        var We = Nt => {
          var wt = nbe();
          Re(() => er(wt, "src", s.user.data.equippedFrameUrl)), q(Nt, wt)
        };
        Te(et, Nt => {
          s.user.data.equippedFrameUrl && Nt(We)
        })
      }
      var _t = D(et, 2);
      _t.__click = () => {
        H(r, !0)
      };
      var Vt = M(_t);
      a_(Vt, {
        class: "size-4"
      }), S(_t), S(Ne);
      var Et = D(Ne, 2),
        Pt = M(Et),
        lt = M(Pt),
        $t = M(lt, !0);
      S(lt);
      var yt = D(lt, 2),
        Rt = M(yt);
      S(yt);
      var jt = D(yt, 2);
      {
        var Xt = Nt => {
          const wt = mt(() => Do(s.user.data.equippedFlag));
          var Ge = ibe(),
            xt = M(Ge, !0);
          S(Ge), Re(() => {
            er(Ge, "data-tip", g(wt).name), te(xt, g(wt).flag)
          }), q(Nt, Ge)
        };
        Te(jt, Nt => {
          s.user.data.equippedFlag && Nt(Xt)
        })
      }
      var fr = D(jt, 2);
      {
        var Yt = Nt => {
          var wt = abe(),
            Ge = M(wt);
          Lh(Ge, {
            get username() {
              return s.user.data.discord
            },
            get id() {
              return s.user.data.discordId
            }
          }), S(wt), q(Nt, wt)
        };
        Te(fr, Nt => {
          s.user.data.discord && Nt(Yt)
        })
      }
      S(Pt);
      var lr = D(Pt, 2),
        ot = M(lr);
      bl(ot, {
        class: "inline size-4"
      });
      var nt = D(ot, 2),
        Ut = M(nt),
        Qt = D(Ut),
        Ot = M(Qt, !0);
      S(Qt), S(nt), S(lr);
      var mr = D(lr, 2),
        zt = M(mr);
      Dye(zt, {
        class: "inline size-4"
      });
      var Mt = D(zt, 2),
        kt = M(Mt),
        It = M(kt);
      S(kt);
      var Gt = D(kt),
        ht = D(Gt),
        hr = M(ht);
      Qu(hr, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), S(ht), S(Mt), S(mr), S(Et), S(Le);
      var wr = D(Le, 2),
        ur = M(wr);
      {
        var qr = Nt => {
          var wt = lbe(),
            Ge = M(wt);
          F_(Ge, {
            class: "size-6 text-red-500"
          });
          var xt = D(Ge, 2);
          {
            var Wt = Jr => {
                var jr = obe(),
                  Or = M(jr),
                  Fr = D(Or);
                {
                  var rn = kn => {
                      var Kr = Oi();
                      Re(Ur => te(Kr, `(${Ur??""})`), [() => fv({
                        reason: Hx()
                      })]), q(kn, Kr)
                    },
                    An = kn => {
                      var Kr = Sr(),
                        Ur = Ct(Kr);
                      {
                        var Cn = En => {
                          var Tn = Oi();
                          Re(Un => te(Tn, `(${Un??""})`), [() => fv({
                            reason: $x()
                          })]), q(En, Tn)
                        };
                        Te(Ur, En => {
                          s.user.data.suspensionReason === "multi-accounting" && En(Cn)
                        }, !0)
                      }
                      q(kn, Kr)
                    };
                  Te(Fr, kn => {
                    s.user.data.suspensionReason === "bot" ? kn(rn) : kn(An, !1)
                  })
                }
                S(jr), Re(kn => te(Or, `${kn??""} `), [() => lae()]), q(Jr, jr)
              },
              At = Jr => {
                var jr = Sr(),
                  Or = Ct(jr);
                {
                  var Fr = rn => {
                    var An = sbe(),
                      kn = M(An);
                    zp(kn, () => Wx({
                      until: `<span class="text-secondary font-medium text-nowrap">${s.user.timeoutUntil.toLocaleString(navigator.language)}</span>`
                    })), S(An), q(rn, An)
                  };
                  Te(Or, rn => {
                    s.user.timeoutUntil && rn(Fr)
                  }, !0)
                }
                q(Jr, jr)
              };
            Te(xt, Jr => {
              s.user.data.timeoutUntil && new Date(s.user.data.timeoutUntil).getTime() >= Date.now() + 31536e6 ? Jr(Wt) : Jr(At, !1)
            })
          }
          var pr = D(xt, 2);
          pr.__click = Jr => {
            var jr;
            (jr = s.onbanappeal) == null || jr.call(s)
          };
          var ar = M(pr);
          F_(ar, {
            class: "size-5 text-red-500"
          });
          var zr = D(ar, 1, !0);
          S(pr), S(wt), Re(Jr => te(zr, Jr), [() => RQ()]), q(Nt, wt)
        };
        Te(ur, Nt => {
          g(W) && Nt(qr)
        })
      }
      var kr = D(ur, 2),
        Zr = M(kr),
        Wr = M(Zr, !0);
      S(Zr);
      var tr = D(Zr, 2),
        Hr = M(tr),
        sr = M(Hr),
        de = M(sr);
      Xye(de, {
        class: "size-4"
      }), S(sr);
      var O = D(sr, 2);
      si(O, 21, () => k, Dc, (Nt, wt) => {
        const Ge = mt(() => g(l) === g(wt).key),
          xt = mt(() => A1() === g(wt).key);
        var Wt = ube(),
          At = M(Wt);
        let pr;
        At.__click = () => {
          localStorage.setItem(c1, g(wt).key), H(l, g(wt).key, !0), location.reload()
        };
        var ar = M(At);
        {
          var zr = jr => {
            var Or = cbe();
            q(jr, Or)
          };
          Te(ar, jr => {
            g(Ge) && jr(zr)
          })
        }
        var Jr = D(ar);
        S(At), S(Wt), Re(() => {
          pr = Vr(At, 1, "font-flag relative font-medium", null, pr, {
            "bg-base-200": g(Ge),
            "bg-base-300": g(xt)
          }), te(Jr, ` ${g(wt).label??""}`)
        }), q(Nt, Wt)
      }), S(O), S(Hr);
      var N = D(Hr, 2),
        X = M(N);
      X.__click = () => {
        za.muted = !za.muted
      };
      var re = M(X);
      {
        var Q = Nt => {
            ebe(Nt, {
              class: "size-4"
            })
          },
          ue = Nt => {
            rbe(Nt, {
              class: "size-4"
            })
          };
        Te(re, Nt => {
          za.muted ? Nt(Q) : Nt(ue, !1)
        })
      }
      S(X), S(N);
      var ke = D(N, 2);
      {
        var xe = Nt => {
          var wt = hbe(),
            Ge = M(wt);
          Ge.__click = () => {
            za.theme = za.theme === "dark" ? "custom-winter" : "dark"
          };
          var xt = M(Ge);
          {
            var Wt = pr => {
                Bye(pr, {
                  class: "size-4"
                })
              },
              At = pr => {
                jye(pr, {
                  class: "size-4"
                })
              };
            Te(xt, pr => {
              za.theme === "dark" ? pr(Wt) : pr(At, !1)
            })
          }
          S(Ge), S(wt), Re(pr => er(wt, "data-tip", pr), [() => za.theme === "dark" ? iL() : BP()]), q(Nt, wt)
        };
        Te(ke, Nt => {
          s.user.hasPermission(Di.ui.themeDarkMode) && Nt(xe)
        })
      }
      var Ee = D(ke, 2);
      {
        var He = Nt => {
          var wt = dbe();
          wt.__click = () => {
            var At;
            H(z, !g(z)), (At = s.ontogglepixelarts) == null || At.call(s, g(z))
          };
          var Ge = M(wt);
          {
            var xt = At => {
                Kye(At, {
                  class: "size-4"
                })
              },
              Wt = At => {
                wy(At, {
                  class: "size-4"
                })
              };
            Te(Ge, At => {
              g(z) ? At(Wt, !1) : At(xt)
            })
          }
          S(wt), Re(At => er(wt, "data-tip", At), [() => g(z) == !1 ? vY() : Sz()]), q(Nt, wt)
        };
        Te(Ee, Nt => {
          s.user.hasPermission(Di.ui.tooglePixelArt) && Nt(He)
        })
      }
      var Be = D(Ee, 2);
      Be.__click = function(...Nt) {
        var wt;
        (wt = s.onnotificationclick) == null || wt.apply(this, Nt)
      };
      var ie = M(Be);
      Nye(ie, {
        class: "size-4"
      });
      var J = D(ie, 2);
      {
        var Ve = Nt => {
          Jv(Nt, {
            class: "absolute -right-1 -top-1",
            get count() {
              return s.user.notificiationCount
            }
          })
        };
        Te(J, Nt => {
          s.user.notificiationCount && Nt(Ve)
        })
      }
      S(Be), S(tr), S(kr);
      var rt = D(kr, 2);
      {
        var Ue = Nt => {
          var wt = pbe();
          wt.__click = async () => {
            var Wt;
            try {
              const At = await ((Wt = g(F)) == null ? void 0 : Wt.prompt());
              (At == null ? void 0 : At.outcome) === "accepted" && H(F, void 0)
            } catch (At) {
              Zt.error(rS({
                error: At.message
              }))
            }
          };
          var Ge = M(wt);
          H_(Ge, {
            class: "size-5"
          });
          var xt = D(Ge);
          S(wt), Re(Wt => te(xt, ` ${Wt??""}`), [() => DE()]), q(Nt, wt)
        };
        Te(rt, Nt => {
          g(F) && Nt(Ue)
        })
      }
      var ae = D(rt, 2);
      {
        var Ie = Nt => {
          var wt = fbe(),
            Ge = M(wt);
          rp(Ge, {
            class: "size-5"
          });
          var xt = D(Ge);
          S(wt), Re(Wt => {
            er(wt, "href", g(ee)), te(xt, ` ${Wt??""}`)
          }, [() => j1()]), q(Nt, wt)
        };
        Te(ae, Nt => {
          s.user.hasAnyPermission(Di.dashboard) && Nt(Ie)
        })
      }
      var $e = D(ae, 2);
      {
        var dt = Nt => {
          var wt = _be(),
            Ge = M(wt);
          rp(Ge, {
            class: "size-5"
          });
          var xt = D(Ge);
          S(wt), Re(Wt => {
            er(wt, "href", `${vi.url.origin??""}/tickets`), te(xt, ` ${Wt??""}`)
          }, [() => cQ()]), q(Nt, wt)
        };
        Te($e, Nt => {
          s.user.hasAnyPermission(Di.tickets) && Nt(dt)
        })
      }
      var Tt = D($e, 2);
      {
        var pt = Nt => {
          var wt = mbe(),
            Ge = M(wt);
          rp(Ge, {
            class: "size-5"
          });
          var xt = D(Ge);
          S(wt), Re(Wt => {
            er(wt, "href", `${vi.url.origin??""}/appeals`), te(xt, ` ${Wt??""}`)
          }, [() => R1()]), q(Nt, wt)
        };
        Te(Tt, Nt => {
          s.user.hasAnyPermission(Di.appeals) && Nt(pt)
        })
      }
      var St = D(Tt, 2);
      {
        var qt = Nt => {
          var wt = gbe(),
            Ge = M(wt);
          rp(Ge, {
            class: "size-5"
          });
          var xt = D(Ge);
          S(wt), Re(Wt => {
            er(wt, "href", `${vi.url.origin??""}/wayback`), te(xt, ` ${Wt??""}`)
          }, [() => kue()]), q(Nt, wt)
        };
        Te(St, Nt => {
          s.user.hasAnyPermission(Di.tools.wayback) && Nt(qt)
        })
      }
      var qe = D(St, 2),
        bt = M(qe);
      d_(bt, {
        class: "size-5"
      });
      var Jt = D(bt);
      S(qe);
      var Cr = D(qe, 2),
        _r = M(Cr);
      Gye(_r, {
        class: "size-5"
      });
      var Qe = D(_r);
      S(Cr);
      var rr = D(Cr, 2);
      {
        var Kt = Nt => {
          var wt = vbe(),
            Ge = Ct(wt),
            xt = M(Ge),
            Wt = M(xt);
          Uye(Wt, {
            class: "size-5"
          });
          var At = D(Wt);
          S(xt), S(Ge);
          var pr = D(Ge, 2),
            ar = M(pr);
          Qu(ar, {
            class: "size-5"
          });
          var zr = D(ar);
          S(pr), Re((Jr, jr, Or) => {
            er(Ge, "action", `${Vx}/payment/create-portal-session`), te(At, ` ${Jr??""}`), er(pr, "href", jr), te(zr, ` ${Or??""}`)
          }, [() => m1(), m0, () => M0()]), q(Nt, wt)
        };
        Te(rr, Nt => {
          var wt;
          (wt = s.user.data) != null && wt.isCustomer && Nt(Kt)
        })
      }
      var Tr = D(rr, 2);
      Tr.__click = async () => {
        var Nt;
        try {
          H(x, !0), await s.user.logout(), E(), Zt.warning(ND(), {
            icon: Qv
          }), (Nt = s.onlogout) == null || Nt.call(s)
        } catch {
          Zt.error(_S())
        } finally {
          H(x, !1)
        }
      };
      var Rr = M(Tr);
      Qv(Rr, {
        class: "size-5"
      });
      var Qr = D(Rr);
      S(Tr), S(wr), S(Ce), S(we);
      var br = D(we, 2);
      Eye(br, {
        get userData() {
          return s.user.data
        },
        get open() {
          return g(r)
        },
        set open(Nt) {
          H(r, Nt, !0)
        }
      }), Re((Nt, wt, Ge, xt, Wt, At, pr, ar, zr, Jr, jr, Or, Fr, rn) => {
        be = Vr(Fe, 1, "btn relative size-12 p-0 shadow-md", null, be, {
          "bg-red-500": g(W)
        }), er(Fe, "title", Nt), er(lt, "title", s.user.data.name), te($t, s.user.data.name), Vr(yt, 1, wt), te(Rt, `#${s.user.data.id??""}`), te(Ut, `${Ge??""}: `), te(Ot, xt), te(It, `Level ${Wt??""}`), te(Gt, ` (${At??""}%) `), er(ht, "data-tip", pr), te(Wr, ar), er(sr, "data-tip", zr), er(N, "data-tip", Jr), er(Be, "data-tip", jr), te(Jt, ` ${Or??""}`), te(Qe, ` ${Fr??""}`), Tr.disabled = g(x), te(Qr, ` ${rn??""}`)
      }, [() => AY(), () => qs(na(s.user.data.id)), () => W_(), () => s.user.data.pixelsPainted.toLocaleString(navigator.language), () => Math.floor(s.user.data.level), () => Math.floor(s.user.data.level % 1 * 100), () => OR(), () => JR(), () => lk(), () => za.muted ? Mre() : Fj(), () => T0(), () => f1(), () => r1(), () => _1()]), In("focus", Fe, () => {
        H(F, window.pwaInstallPrompt, !0)
      }), q(V, Me)
    };
    Te(se, V => {
      s.user.data && s.user.charges !== void 0 && V(_e)
    })
  }
  q(p, $), an()
}
Yn(["click"]);
var xbe = he('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  wbe = he('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  kbe = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  Tbe = he("<span> </span>"),
  Sbe = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Pbe = he('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  Mbe = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Ibe = he('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  Cbe = he('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  zbe = he('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function Abe(p, s) {
  nn(s, !0);
  const r = [];
  let x = Je("today"),
    z = {
      players: {
        label: P0(),
        icon: Rp
      },
      alliances: {
        label: g0(),
        icon: jp
      }
    },
    E = Je("players"),
    k = yi({
      players: {},
      alliances: {}
    });
  const l = mt(() => k[g(E)][g(x)]);
  cn(() => {
    if (g(l)) return;
    const V = g(x),
      Me = g(E);
    Me === "players" ? dn.leaderboardRegionPlayers(s.regionId, V).then(we => {
      k[Me][V] = we
    }).catch(we => {
      Zt.error(we.message)
    }) : Me === "alliances" && dn.leaderboardRegionAlliances(s.regionId, V).then(we => {
      k[Me][V] = we
    }).catch(we => {
      Zt.error(we.message)
    })
  });
  var F = zbe(),
    W = Ct(F);
  si(W, 21, () => Object.entries(z), ([V, {
    label: Me,
    icon: we
  }]) => V, (V, Me) => {
    var we = mt(() => r0(g(Me), 2));
    let Fe = () => g(we)[0],
      be = () => g(we)[1].label,
      Xe = () => g(we)[1].icon;
    const tt = mt(Xe);
    var Ye = xbe(),
      Ce = M(Ye);
    Ki(Ce);
    var De, Ke = D(Ce, 2);
    ba(Ke, () => g(tt), (Ne, vt) => {
      vt(Ne, {
        get this() {
          return Xe()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Le = D(Ke);
    S(Ye), Re(() => {
      er(Ce, "aria-label", be()), De !== (De = Fe()) && (Ce.value = (Ce.__value = Fe()) ?? ""), te(Le, ` ${be()??""}`)
    }), Z_(r, [], Ce, () => (Fe(), g(E)), Ne => H(E, Ne)), q(V, Ye)
  }), S(W);
  var ee = D(W, 2),
    $ = M(ee);
  cm($, {
    get value() {
      return g(x)
    },
    set value(V) {
      H(x, V, !0)
    }
  }), S(ee);
  var se = D(ee, 2);
  {
    var _e = V => {
        var Me = wbe(),
          we = M(Me),
          Fe = D(we);
        {
          var be = tt => {
              var Ye = Oi();
              Re(Ce => te(Ye, Ce), [() => Dp().toLowerCase()]), q(tt, Ye)
            },
            Xe = tt => {
              var Ye = Sr(),
                Ce = Ct(Ye);
              {
                var De = Le => {
                    var Ne = Oi();
                    Re(vt => te(Ne, vt), [() => rm()]), q(Le, Ne)
                  },
                  Ke = Le => {
                    var Ne = Sr(),
                      vt = Ct(Ne);
                    {
                      var et = We => {
                        var _t = Oi();
                        Re(Vt => te(_t, Vt), [() => tm()]), q(We, _t)
                      };
                      Te(vt, We => {
                        g(x) === "month" && We(et)
                      }, !0)
                    }
                    q(Le, Ne)
                  };
                Te(Ce, Le => {
                  g(x) === "week" ? Le(De) : Le(Ke, !1)
                }, !0)
              }
              q(tt, Ye)
            };
          Te(Fe, tt => {
            g(x) === "today" ? tt(be) : tt(Xe, !1)
          })
        }
        S(Me), Re(tt => te(we, `${tt??""} `), [() => em()]), q(V, Me)
      },
      ge = V => {
        var Me = Sr(),
          we = Ct(Me);
        {
          var Fe = Xe => {
              var tt = Sr(),
                Ye = Ct(tt);
              {
                var Ce = Ke => {
                    const Le = mt(() => g(l));
                    var Ne = Pbe(),
                      vt = M(Ne),
                      et = M(vt),
                      We = D(M(et)),
                      _t = M(We, !0);
                    S(We);
                    var Vt = D(We),
                      Et = M(Vt),
                      Pt = D(Et, 2, !0);
                    S(Vt), S(et), S(vt);
                    var lt = D(vt);
                    si(lt, 31, () => g(Le), $t => $t.id, ($t, yt, Rt) => {
                      const jt = mt(() => {
                        var kr;
                        return ((kr = Dt.data) == null ? void 0 : kr.id) === g(yt).id
                      });
                      var Xt = Sbe();
                      let fr;
                      var Yt = M(Xt),
                        lr = M(Yt, !0);
                      S(Yt);
                      var ot = D(Yt),
                        nt = M(ot),
                        Ut = M(nt);
                      Ra(Ut, {
                        class: "size-10 border",
                        get userId() {
                          return g(yt).id
                        },
                        get pictureUrl() {
                          return g(yt).picture
                        },
                        get borderUrl() {
                          return g(yt).frameUrl
                        }
                      });
                      var Qt = D(Ut, 2),
                        Ot = M(Qt),
                        mr = M(Ot),
                        zt = D(mr),
                        Mt = M(zt);
                      S(zt), S(Ot);
                      var kt = D(Ot, 2);
                      {
                        var It = kr => {
                          const Zr = mt(() => Do(g(yt).equippedFlag));
                          var Wr = kbe(),
                            tr = M(Wr, !0);
                          S(Wr), Re(() => {
                            er(Wr, "data-tip", g(Zr).name), te(tr, g(Zr).flag)
                          }), q(kr, Wr)
                        };
                        Te(kt, kr => {
                          "equippedFlag" in g(yt) && g(yt).equippedFlag && kr(It)
                        })
                      }
                      var Gt = D(kt, 2);
                      {
                        var ht = kr => {
                          Lh(kr, {
                            get username() {
                              return g(yt).discord
                            },
                            get id() {
                              return g(yt).discordId
                            }
                          })
                        };
                        Te(Gt, kr => {
                          g(yt).discord && kr(ht)
                        })
                      }
                      var hr = D(Gt, 2);
                      {
                        var wr = kr => {
                          var Zr = Tbe(),
                            Wr = M(Zr, !0);
                          S(Zr), Re((tr, Hr) => {
                            Vr(Zr, 1, `badge badge-sm ml-0.5 border-0 ${tr??""} ${Hr??""}`), te(Wr, g(yt).allianceName)
                          }, [() => Cp(g(yt).allianceId), () => na(g(yt).allianceId)]), q(kr, Zr)
                        };
                        Te(hr, kr => {
                          "allianceName" in g(yt) && g(yt).allianceName && kr(wr)
                        })
                      }
                      S(Qt), S(nt), S(ot);
                      var ur = D(ot),
                        qr = M(ur, !0);
                      S(ur), S(Xt), Re((kr, Zr) => {
                        fr = Vr(Xt, 1, "", null, fr, {
                          "bg-base-200": g(jt)
                        }), te(lr, g(Rt) + 1), Vr(Ot, 1, `font-semibold max-sm:ml-2 ${kr??""} flex gap-1`), te(mr, `${g(yt).name??""} `), te(Mt, `#${g(yt).id??""}`), te(qr, Zr)
                      }, [() => na(g(yt).id), () => g(yt).pixelsPainted.toLocaleString(navigator.language)]), _l(Xt, () => ml, () => ({
                        duration: 200
                      })), q($t, Xt)
                    }), S(lt), S(Ne), Re(($t, yt, Rt) => {
                      te(_t, $t), te(Et, `${yt??""} `), te(Pt, Rt)
                    }, [() => $_(), () => Pc(), () => Sc().toLowerCase()]), q(Ke, Ne)
                  },
                  De = Ke => {
                    var Le = Sr(),
                      Ne = Ct(Le);
                    {
                      var vt = et => {
                        var We = Ibe(),
                          _t = M(We),
                          Vt = M(_t),
                          Et = D(M(Vt)),
                          Pt = M(Et, !0);
                        S(Et);
                        var lt = D(Et),
                          $t = M(lt),
                          yt = D($t, 2, !0);
                        S(lt), S(Vt), S(_t);
                        var Rt = D(_t);
                        si(Rt, 31, () => g(l), jt => jt.id, (jt, Xt, fr) => {
                          const Yt = mt(() => {
                            var kt;
                            return ((kt = Dt.data) == null ? void 0 : kt.allianceId) === g(Xt).id
                          });
                          var lr = Mbe();
                          let ot;
                          var nt = M(lr),
                            Ut = M(nt, !0);
                          S(nt);
                          var Qt = D(nt),
                            Ot = M(Qt),
                            mr = M(Ot, !0);
                          S(Ot), S(Qt);
                          var zt = D(Qt),
                            Mt = M(zt, !0);
                          S(zt), S(lr), Re((kt, It) => {
                            ot = Vr(lr, 1, "", null, ot, {
                              "bg-base-200": g(Yt)
                            }), te(Ut, g(fr) + 1), Vr(Ot, 1, `font-semibold ${kt??""}`), te(mr, g(Xt).name), te(Mt, It)
                          }, [() => na(g(Xt).id), () => g(Xt).pixelsPainted.toLocaleString(navigator.language)]), _l(lr, () => ml, () => ({
                            duration: 200
                          })), q(jt, lr)
                        }), S(Rt), S(We), Re((jt, Xt, fr) => {
                          te(Pt, jt), te($t, `${Xt??""} `), te(yt, fr)
                        }, [() => Ep(), () => Pc(), () => Sc().toLowerCase()]), q(et, We)
                      };
                      Te(Ne, et => {
                        g(E) === "alliances" && et(vt)
                      }, !0)
                    }
                    q(Ke, Le)
                  };
                Te(Ye, Ke => {
                  g(E) === "players" ? Ke(Ce) : Ke(De, !1)
                })
              }
              q(Xe, tt)
            },
            be = Xe => {
              var tt = Cbe();
              q(Xe, tt)
            };
          Te(we, Xe => {
            g(l) ? Xe(Fe) : Xe(be, !1)
          }, !0)
        }
        q(V, Me)
      };
    Te(se, V => {
      g(l) && g(l).length === 0 ? V(_e) : V(ge, !1)
    })
  }
  q(p, F), an()
}
var Ebe = he('<div class="mt-5"><!></div>'),
  Lbe = he('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Dbe(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15);
  const x = mt(() => Do(s.region.countryId));
  var z = Lbe(),
    E = M(z),
    k = D(M(E), 2),
    l = M(k),
    F = M(l, !0);
  S(l);
  var W = D(l, 2),
    ee = M(W, !0);
  S(W);
  var $ = D(W, 2),
    se = M($);
  S($), S(k);
  var _e = D(k, 2);
  {
    var ge = V => {
      var Me = Ebe(),
        we = M(Me);
      Abe(we, {
        get regionId() {
          return s.region.id
        }
      }), S(Me), fa(2, Me, () => Ja, () => ({
        duration: 300
      })), q(V, Me)
    };
    Te(_e, V => {
      r() && V(ge)
    })
  }
  S(E), bn(2), S(z), Ji(z, () => V => {
    cn(() => {
      r() ? V.show() : V.close()
    })
  }), Re(V => {
    Vr(k, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${V??""}`), er(l, "data-tip", g(x).name), te(F, g(x).flag), te(ee, s.region.name), te(se, `#${s.region.number??""}`)
  }, [() => na(s.region.cityId)]), In("close", z, () => r(!1)), q(p, z), an()
}

function Rbe(p) {
  switch (p) {
    case "en":
    case "pt":
    case "es":
    case "fr":
    case "de":
    case "it":
    case "pl":
    case "ru":
    case "uk":
    case "vi":
      return p;
    case "jp":
      return "ja";
    case "ch":
      return "zh";
    default:
      return ""
  }
}
async function jbe(p) {
  const s = Rbe(je());
  let r = `https://geocoding.wplace.live/v1/autocomplete?text=${encodeURIComponent(p)}${s!=="en"?`&lang=${s}`:""}`;
  const x = await fetch(r);
  if (!x.ok) {
    const z = await x.text();
    throw console.error(`Geocoding API error: ${z}`), new Error(Xx())
  }
  return x.json()
}
var Fbe = he('<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'),
  Bbe = he('<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>');

function e_(p, s) {
  nn(s, !0);
  const r = (l, F) => {
    let W = () => F == null ? void 0 : F().name,
      ee = () => F == null ? void 0 : F().label,
      $ = () => F == null ? void 0 : F().onclick;
    var se = Bbe(),
      _e = M(se);
    _e.__click = function(...Ye) {
      var Ce;
      (Ce = $()) == null || Ce.apply(this, Ye)
    };
    var ge = M(_e);
    Ap(ge, {
      class: "text-base-content/80 mt-0.5 size-6 min-w-6"
    });
    var V = D(ge, 2),
      Me = M(V),
      we = M(Me, !0);
    S(Me);
    var Fe = D(Me, 2),
      be = M(Fe, !0);
    S(Fe), S(V), S(_e);
    var Xe = D(_e, 2);
    {
      var tt = Ye => {
        var Ce = Fbe(),
          De = M(Ce);
        De.__click = function(...Le) {
          var Ne;
          (Ne = s.onremove) == null || Ne.apply(this, Le)
        };
        var Ke = M(De);
        Ro(Ke, {
          class: "size-4"
        }), S(De), S(Ce), q(Ye, Ce)
      };
      Te(Xe, Ye => {
        s.onremove && Ye(tt)
      })
    }
    S(se), Re(() => {
      te(we, W()), te(be, ee())
    }), q(l, se)
  };
  var x = Sr(),
    z = Ct(x);
  {
    var E = l => {
        r(l, () => ({
          name: s.location.name,
          label: s.location.label,
          onclick: s.onclick
        }))
      },
      k = l => {
        var F = Sr(),
          W = Ct(F);
        {
          var ee = se => {
              {
                let _e = mt(() => ({
                  name: s.location.name,
                  label: Q_(),
                  onclick: s.onclick
                }));
                r(se, () => g(_e))
              }
            },
            $ = se => {
              var _e = Sr(),
                ge = Ct(_e);
              {
                var V = Me => {
                  {
                    let we = mt(() => ({
                      name: `${s.location.pos.lat.toFixed(4)}, ${s.location.pos.lng.toFixed(4)}`,
                      label: w0(),
                      onclick: s.onclick
                    }));
                    r(Me, () => g(we))
                  }
                };
                Te(ge, Me => {
                  s.location.type === "coordinates" && Me(V)
                }, !0)
              }
              q(se, _e)
            };
          Te(W, se => {
            s.location.type === "country" ? se(ee) : se($, !1)
          }, !0)
        }
        q(l, F)
      };
    Te(z, l => {
      s.location.type === "place" ? l(E) : l(k, !1)
    })
  }
  q(p, x), an()
}
Yn(["click"]);
var Obe = Yr('<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function qbe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Obe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Nbe = Yr('<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>');

function Vbe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Nbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Ube = he('<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'),
  Zbe = he('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  Gbe = he("<!> <!>", 1),
  Wbe = he('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  Hbe = he('<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>', 1),
  $be = he('<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Xbe(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(""),
    z = Je(!1),
    E = Je(!1);
  const k = new Jfe(() => g(x), 400);
  let l = Je(null),
    F = Je(void 0),
    W = Je([]);
  const ee = /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    $ = mt(() => {
      const et = ee.exec(g(x));
      if (et) {
        const We = parseFloat(et[1]),
          _t = parseFloat(et[5]);
        return {
          type: "coordinates",
          id: `coords-${We}-${_t}`,
          pos: {
            lat: We,
            lng: _t
          },
          zoom: s.tileZoom + 2
        }
      }
    }),
    se = "recent-locations";
  Yi(() => {
    const et = localStorage.getItem(se);
    if (et) try {
      H(W, JSON.parse(et))
    } catch (We) {
      console.error("Failed to parse recent locations from localStorage", We)
    }
  }), cn(() => {
    k.current && jbe(k.current).then(et => {
      H(F, et.features.map(We => {
        if (We.properties.layer === "country") return {
          type: "country",
          id: We.properties.id,
          name: We.properties.name,
          bbox: We.bbox,
          coordinates: We.geometry.type === "Point" ? {
            lat: We.geometry.coordinates[1],
            lng: We.geometry.coordinates[0]
          } : void 0
        };
        const _t = We.properties.label.replace(We.properties.name + ",", "").trim();
        return {
          type: "place",
          id: We.properties.id,
          name: We.properties.name,
          label: _t,
          bbox: We.bbox,
          coordinates: We.geometry.type === "Point" ? {
            lat: We.geometry.coordinates[1],
            lng: We.geometry.coordinates[0]
          } : void 0
        }
      })), g(z) && g(F).length > 0 && ge(g(F)[0])
    })
  }), cn(() => {
    g(x) || H(F, void 0)
  }), cn(() => {
    r() ? setTimeout(() => {
      g(l).focus()
    }, 50) : (H(x, ""), H(z, !1), H(F, void 0))
  });
  async function _e() {
    const {
      tile: et,
      pixel: We
    } = await dn.getRandomTile(s.season), _t = new Aa(s.tileSize), Vt = et.x * s.tileSize + We.x, Et = et.y * s.tileSize + We.y, [Pt, lt] = _t.pixelsToLatLon(Vt, Et, s.tileZoom), $t = {
      lat: Pt,
      lng: lt
    }, yt = s.tileZoom + 2;
    s.map.flyTo({
      zoom: yt,
      center: $t
    }), V({
      type: "coordinates",
      id: `coords-${Pt}-${lt}`,
      pos: $t,
      zoom: yt
    })
  }

  function ge(et) {
    et.type === "coordinates" ? s.map.flyTo({
      zoom: et.zoom,
      center: et.pos
    }) : et.bbox ? s.map.fitBounds([
      [et.bbox[0], et.bbox[1]],
      [et.bbox[2], et.bbox[3]]
    ], {
      padding: 40,
      duration: 1e3
    }) : et.coordinates && s.map.flyTo({
      zoom: 16,
      center: et.coordinates,
      duration: 1e3
    }), r(!1), H(F, void 0), V(et)
  }

  function V(et) {
    H(W, g(W).filter(_t => _t.id !== et.id)), g(W).unshift(et);
    const We = 15;
    g(W).length > We && H(W, g(W).slice(0, We)), H(W, [...g(W)]), localStorage.setItem(se, JSON.stringify(g(W)))
  }
  var Me = $be(),
    we = M(Me),
    Fe = M(we),
    be = M(Fe),
    Xe = M(be);
  Ki(Xe), ja(Xe, et => H(l, et), () => g(l));
  var tt = D(Xe, 2);
  tt.__click = () => r(!1);
  var Ye = M(tt);
  f0(Ye, {
    class: "size-5"
  }), S(tt);
  var Ce = D(tt, 2);
  {
    var De = et => {
      var We = Ube();
      We.__click = () => H(x, "");
      var _t = M(We);
      qbe(_t, {
        class: "size-4.5"
      }), S(We), q(et, We)
    };
    Te(Ce, et => {
      g(x) && et(De)
    })
  }
  S(be), S(Fe);
  var Ke = D(Fe, 2),
    Le = M(Ke);
  {
    var Ne = et => {
        e_(et, {
          get location() {
            return g($)
          },
          onclick: () => ge(g($))
        })
      },
      vt = et => {
        var We = Sr(),
          _t = Ct(We);
        {
          var Vt = Pt => {
              var lt = Gbe(),
                $t = Ct(lt);
              si($t, 17, () => g(F), jt => jt.id, (jt, Xt) => {
                e_(jt, {
                  get location() {
                    return g(Xt)
                  },
                  onclick: () => ge(g(Xt))
                })
              });
              var yt = D($t, 2);
              {
                var Rt = jt => {
                  var Xt = Zbe(),
                    fr = M(Xt, !0);
                  S(Xt), Re(Yt => te(fr, Yt), [() => e9()]), q(jt, Xt)
                };
                Te(yt, jt => {
                  g(F).length === 0 && jt(Rt)
                })
              }
              q(Pt, lt)
            },
            Et = Pt => {
              var lt = Hbe(),
                $t = Ct(lt),
                yt = M($t),
                Rt = M(yt, !0);
              S(yt);
              var jt = D(yt, 2);
              jt.__click = async () => {
                try {
                  await _e(), r(!1)
                } catch (ot) {
                  Zt.error(ot.message)
                } finally {
                  H(E, !1)
                }
              };
              var Xt = M(jt);
              Vbe(Xt, {
                class: "size-5"
              }), S(jt), S($t);
              var fr = D($t, 2);
              si(fr, 17, () => g(W), ot => ot.id, (ot, nt) => {
                e_(ot, {
                  get location() {
                    return g(nt)
                  },
                  onclick: () => {
                    ge(g(nt))
                  },
                  onremove: () => {
                    H(W, g(W).filter(Ut => Ut.id !== g(nt).id)), localStorage.setItem(se, JSON.stringify(g(W)))
                  }
                })
              });
              var Yt = D(fr, 2);
              {
                var lr = ot => {
                  var nt = Wbe(),
                    Ut = M(nt, !0);
                  S(nt), Re(Qt => te(Ut, Qt), [() => p9()]), q(ot, nt)
                };
                Te(Yt, ot => {
                  g(W).length === 0 && ot(lr)
                })
              }
              Re((ot, nt) => {
                te(Rt, ot), er(jt, "data-tip", nt), jt.disabled = g(E)
              }, [() => vG(), () => aG()]), q(Pt, lt)
            };
          Te(_t, Pt => {
            g(F) ? Pt(Vt) : Pt(Et, !1)
          }, !0)
        }
        q(et, We)
      };
    Te(Le, et => {
      g($) ? et(Ne) : et(vt, !1)
    })
  }
  S(Ke), S(we), bn(2), S(Me), Ji(Me, () => et => {
    cn(() => {
      r() ? et.showModal() : et.close()
    })
  }), Re(et => er(Xe, "placeholder", et), [() => d0()]), In("close", Me, () => r(!1)), In("submit", be, () => {
    var et;
    g($) ? ge(g($)) : k.pending ? H(z, !0) : (et = g(F)) != null && et.length && ge(g(F)[0])
  }), yl(Xe, () => g(x), et => H(x, et)), q(p, Me), an()
}
Yn(["click"]);
var Ybe = Yr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function B_(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Ybe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Kbe = Yr('<svg><path fill="currentColor" d="M9 14c1.381 0 2.631-.56 3.536-1.465C13.44 11.631 14 10.381 14 9s-.56-2.631-1.464-3.535C11.631 4.56 10.381 4 9 4s-2.631.56-3.536 1.465C4.56 6.369 4 7.619 4 9s.56 2.631 1.464 3.535A5 5 0 0 0 9 14m0 7c3.518 0 6-1 6-2c0-2-2.354-4-6-4c-3.75 0-6 2-6 4c0 1 2.25 2 6 2m12-9h-2v-2a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2"></path></svg>');

function Jbe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Kbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), q(p, x)
}
var Qbe = Yr('<svg><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>');

function exe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Qbe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), q(p, x)
}
var txe = Yr('<svg><path fill="currentColor" d="m15 21l-6-2.1l-4.65 1.8q-.5.2-.925-.112T3 19.75v-14q0-.325.188-.575T3.7 4.8L9 3l6 2.1l4.65-1.8q.5-.2.925.113T21 4.25v14q0 .325-.187.575t-.513.375zm-1-2.45V6.85l-4-1.4v11.7zm2 0l3-1V5.7l-3 1.15zM5 18.3l3-1.15V5.45l-3 1zM16 6.85v11.7zm-8-1.4v11.7z"></path></svg>');

function rxe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = txe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), q(p, x)
}
var nxe = Yr('<svg><rect x="6" y="6" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" rx="2"></rect><rect x="10" y="10" width="4" height="4" fill="currentColor" rx="1"></rect></svg>');

function ixe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = nxe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...r
  })), q(p, x)
}
var axe = he("<!> <!>", 1),
  oxe = he('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  sxe = he('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  lxe = he('<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'),
  cxe = he('<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'),
  uxe = he('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button>'),
  hxe = he('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'),
  dxe = he('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  pxe = he('<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'),
  fxe = he('<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>', 1),
  _xe = he("<span> </span>"),
  mxe = he('<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'),
  gxe = he('<span class="tooltip svelte-15blegn"><!></span>'),
  vxe = he('<span class="tooltip svelte-15blegn"><!></span>'),
  yxe = he('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>', 1),
  bxe = he('<span class="text-primary ml-1 text-xs svelte-15blegn"> </span>'),
  xxe = he('<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> <!></td></tr>'),
  wxe = he('<div class="max-h-[27vh] overflow-y-auto overflow-x-hidden svelte-15blegn"><table class="table max-w-full svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <!> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'),
  kxe = he('<div class="pointer-events-none w-full select-none svelte-15blegn"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box pointer-events-auto w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex cursor-grab flex-wrap items-center justify-between gap-1 active:cursor-grabbing svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <div class="flex items-center gap-1 svelte-15blegn"><div class="flex items-center gap-0 svelte-15blegn"><button class="btn btn-xs btn-soft text-base-content/80 flex items-center gap-1 whitespace-nowrap rounded-br-none rounded-tr-none pr-1 text-xs svelte-15blegn"><!> <input type="checkbox" class="checkbox checkbox-xs svelte-15blegn"/></button> <button class="btn btn-xs tooltip tooltip-bottom btn-soft rounded-bl-none rounded-tl-none svelte-15blegn"><!></button></div> <button><!></button> <button><!></button> <button><!></button> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div></div> <div class="pb-3 svelte-15blegn"><!></div></div></div></div>');

function Txe(p, s) {
  nn(s, !0);
  let r = yi([]),
    x = Je(yi([])),
    z = Je(!1),
    E = Je(!1),
    k = Je(!1),
    l = Je(!1),
    F = Je(!1),
    W, ee, $, se, _e, ge = Je(void 0),
    V = yi({
      x: 0,
      y: 0
    }),
    Me, we;
  const Fe = 15e6,
    be = new bp,
    Xe = new Map;
  let tt = Je(0);
  const Ye = mt(() => {
      g(tt);
      const ie = new Map;
      for (const J of Xe.values()) ie.set(J.userId, (ie.get(J.userId) ?? 0) + 1);
      return ie
    }),
    Ce = mt(() => {
      g(tt), be.size;
      let ie = 0;
      for (const J of Xe.values()) be.has(J.userId) || (ie += 1);
      return ie
    }),
    De = mt(() => {
      g(tt);
      const ie = g(Ce);
      return be.size === 0 && ie === 0 ? "none" : be.size === g(x).length && ie === 0 ? "all" : "some"
    }),
    Ke = mt(() => {
      g(tt);
      let ie = 0;
      for (const J of be.values()) J.id !== 0 && (ie += J.painted.latitudes.length);
      for (const J of Xe.values()) be.has(J.userId) || (ie += 1);
      return ie
    }),
    Le = mt(() => g(We) * 2 + 1);
  let Ne = Je("area-select"),
    vt = Je(!1);
  const et = 15;
  let We = Je(et);
  const _t = 0,
    Vt = 4096,
    Et = "select-area-info:brush-radius",
    Pt = new bp,
    lt = new Map,
    $t = [],
    yt = () => g(Ne) === "brush-circle" || g(Ne) === "brush-square";
  let Rt, jt = !1,
    Xt = !1;

  function fr() {
    jt && (jt = !1, Rt = void 0)
  }

  function Yt() {
    if ($t.length > 0) return;
    const ie = [s.map.dragPan, s.map.scrollZoom, s.map.boxZoom, s.map.keyboard, s.map.doubleClickZoom, s.map.touchZoomRotate].filter(Boolean);
    for (const J of ie) {
      const Ve = J.isEnabled ? J.isEnabled() !== !1 : !0;
      J.disable && J.disable(), $t.push({
        handler: J,
        wasEnabled: Ve
      })
    }
  }

  function lr() {
    if ($t.length !== 0) {
      for (const {
          handler: ie,
          wasEnabled: J
        }
        of $t) J && ie.enable && ie.enable();
      $t.length = 0
    }
  }

  function ot() {
    var Ve, rt;
    if (!Me) return;
    const {
      handle: ie,
      pointerId: J
    } = Me;
    (Ve = ie.hasPointerCapture) != null && Ve.call(ie, J) && ((rt = ie.releasePointerCapture) == null || rt.call(ie, J)), Me = void 0, we !== void 0 && (document.body.style.userSelect = we, we = void 0), nt()
  }

  function nt() {
    var St, qt;
    if (!g(ge)) return;
    const ie = (qt = (St = s.map).getContainer) == null ? void 0 : qt.call(St);
    if (!ie) return;
    const J = ie.getBoundingClientRect(),
      Ve = g(ge).getBoundingClientRect(),
      rt = Ve.left - V.x,
      Ue = Ve.top - V.y,
      ae = J.left - rt,
      Ie = J.right - rt - Ve.width,
      $e = J.top - Ue,
      dt = J.bottom - Ue - Ve.height;
    let Tt = V.x,
      pt = V.y;
    Ie >= ae ? (Tt < ae && (Tt = ae), Tt > Ie && (Tt = Ie)) : Tt = ae, dt >= $e ? (pt < $e && (pt = $e), pt > dt && (pt = dt)) : pt = $e, Tt !== V.x && (V.x = Tt), pt !== V.y && (V.y = pt)
  }

  function Ut(ie) {
    var $e, dt, Tt;
    if (Me || ie.pointerType === "mouse" && ie.button !== 0) return;
    const J = ie.target;
    if (J && J.closest('button, input, textarea, select, a, [role="button"]')) return;
    const Ve = ie.currentTarget;
    if (!Ve) return;
    const rt = g(ge);
    if (!rt) return;
    const Ue = (dt = ($e = s.map).getContainer) == null ? void 0 : dt.call($e);
    if (!Ue) return;
    const ae = Ue.getBoundingClientRect(),
      Ie = rt.getBoundingClientRect();
    Me = {
      pointerId: ie.pointerId,
      handle: Ve,
      startX: ie.clientX,
      startY: ie.clientY,
      startPosX: V.x,
      startPosY: V.y,
      baseLeft: Ie.left - V.x,
      baseTop: Ie.top - V.y,
      containerRect: ae,
      panelWidth: Ie.width,
      panelHeight: Ie.height
    }, we === void 0 && (we = document.body.style.userSelect), document.body.style.userSelect = "none", (Tt = Ve.setPointerCapture) == null || Tt.call(Ve, ie.pointerId), ie.preventDefault(), ie.stopPropagation()
  }
  Yi(() => {
    const ie = window.localStorage.getItem(Et);
    if (ie !== null) {
      const bt = Number(ie);
      if (!Number.isNaN(bt)) {
        const Jt = Math.min(Vt, Math.max(_t, Math.trunc(bt)));
        H(We, Jt, !0)
      }
    }
    xi.droppletAndPlop.play(), W = It();
    const J = async bt => {
      if (g(Ne) === "user-picker") {
        await qr(bt, "select");
        return
      }
      if (yt()) {
        const Jt = bt.originalEvent;
        O(bt, "add", {
          silent: !!(Jt != null && Jt.altKey)
        });
        return
      }
      if (r.length >= 2) {
        s.onclose();
        return
      }
      if (r.push(bt.lngLat), Gt(), xi.plop.play(), r.length === 2) try {
        H(z, !0), H(x, await Ot(r[0], r[1]), !0)
      } finally {
        H(z, !1)
      }
    }, Ve = async bt => {
      var Cr, _r;
      if (g(Ne) === "user-picker") {
        (Cr = bt.preventDefault) == null || Cr.call(bt);
        const Qe = bt.originalEvent;
        Qe == null || Qe.preventDefault();
        try {
          await qr(bt, "deselect")
        } catch (rr) {
          console.error(rr)
        }
        return
      }
      if (!yt()) return;
      (_r = bt.preventDefault) == null || _r.call(bt);
      const Jt = bt.originalEvent;
      Jt == null || Jt.preventDefault(), O(bt, "remove")
    }, rt = bt => {
      if (!yt()) return;
      const Jt = bt.originalEvent;
      if (!Jt || !Jt.altKey) return;
      const Cr = Jt.button === 2 ? "remove" : "add";
      Jt.preventDefault(), Yt(), Rt = Cr, jt = !0, O(bt, Cr, {
        silent: !0
      })
    }, Ue = () => {
      fr()
    }, ae = s.map.on("click", J), Ie = s.map.on("contextmenu", Ve), $e = s.map.on("mousedown", rt), dt = s.map.on("mouseup", Ue), Tt = bt => {
      const Jt = Me;
      if (!Jt || bt.pointerId !== Jt.pointerId) return;
      const Cr = bt.clientX - Jt.startX,
        _r = bt.clientY - Jt.startY;
      let Qe = Jt.startPosX + Cr,
        rr = Jt.startPosY + _r;
      const Kt = Jt.containerRect.left - Jt.baseLeft,
        Tr = Jt.containerRect.right - Jt.baseLeft - Jt.panelWidth,
        Rr = Jt.containerRect.top - Jt.baseTop,
        Qr = Jt.containerRect.bottom - Jt.baseTop - Jt.panelHeight;
      Tr >= Kt ? (Qe < Kt && (Qe = Kt), Qe > Tr && (Qe = Tr)) : Qe = Kt, Qr >= Rr ? (rr < Rr && (rr = Rr), rr > Qr && (rr = Qr)) : rr = Rr, V.x !== Qe && (V.x = Qe), V.y !== rr && (V.y = rr)
    }, pt = bt => {
      const Jt = Me;
      !Jt || bt.pointerId !== Jt.pointerId || ot()
    };
    window.addEventListener("pointermove", Tt), window.addEventListener("pointerup", pt), window.addEventListener("pointercancel", pt), window.addEventListener("resize", nt);
    const St = bt => {
        if (bt.altKey && (bt.key === "r" || bt.key === "R")) {
          H(We, et), bt.preventDefault(), ht();
          return
        }
        bt.key === "Alt" && (Xt || (Xt = !0, yt() && Yt()))
      },
      qt = bt => {
        bt.key === "Alt" && (Xt = !1, fr(), lr())
      },
      qe = () => {
        ot(), !(!Xt && !jt) && (Xt = !1, fr(), lr())
      };
    return window.addEventListener("keydown", St), window.addEventListener("keyup", qt), window.addEventListener("blur", qe), () => {
      var Jt, Cr;
      ae.unsubscribe(), Ie.unsubscribe(), $e.unsubscribe(), dt.unsubscribe(), window.removeEventListener("pointermove", Tt), window.removeEventListener("pointerup", pt), window.removeEventListener("pointercancel", pt), window.removeEventListener("resize", nt), window.removeEventListener("keydown", St), window.removeEventListener("keyup", qt), window.removeEventListener("blur", qe), ot(), fr(), lr(), Xt = !1, s.crosshair.clear();
      const bt = (Cr = (Jt = s.map).getCanvas) == null ? void 0 : Cr.call(Jt);
      bt && (bt.style.cursor = ""), W == null || W(), W = void 0
    }
  });

  function Qt() {
    ot(), g(E) || (W == null || W(), W = void 0, H(Ne, "area-select"), fr(), lr(), Xt = !1, V.x = 0, V.y = 0, Xe.clear(), H(tt, g(tt) + 1), Pt.clear(), lt.clear(), s.crosshair.clear(), s.onclose())
  }
  async function Ot(ie, J) {
    const Ve = new Aa(s.tileSize),
      [rt, Ue] = Ve.latLonToPixelsFloor(ie.lat, ie.lng, s.pixelArtZoom),
      [ae, Ie] = Ve.latLonToPixelsFloor(J.lat, J.lng, s.pixelArtZoom),
      [$e, dt] = [Math.min(rt, ae), Math.min(Ue, Ie)],
      [Tt, pt] = [Math.max(rt, ae), Math.max(Ue, Ie)],
      St = Tt - $e,
      qt = pt - dt;
    if (St * qt > Fe) return Zt.error(`The selected area is too big. Please select an area smaller than ${Fe.toLocaleString(navigator.language)} pixels.`), [];
    const bt = Math.floor($e / s.tileSize),
      Jt = Math.floor(dt / s.tileSize),
      Cr = Math.floor(Tt / s.tileSize),
      _r = Math.floor(pt / s.tileSize),
      Qe = Cr - bt + 1,
      rr = _r - Jt + 1,
      Kt = new Array(rr).fill(0).flatMap((wt, Ge) => new Array(Qe).fill(0).map(async (xt, Wt) => {
        const At = bt + Wt,
          pr = Jt + Ge;
        let ar = 0,
          zr = 0,
          Jr = s.tileSize - 1,
          jr = s.tileSize - 1;
        pr === Jt && (zr = dt % s.tileSize), At === bt && (ar = $e % s.tileSize), pr === _r && (jr = pt % s.tileSize), At === Cr && (Jr = Tt % s.tileSize);
        const kn = [At, pr],
          Kr = [ar, zr],
          Ur = [Jr, jr];
        return {
          response: await dn.getPixelAreaInfo({
            season: s.season,
            tile: kn,
            p0: Kr,
            p1: Ur
          }),
          tile: kn,
          p0: Kr,
          p1: Ur
        }
      })),
      Tr = await Promise.all(Kt);
    Pt.clear(), lt.clear();
    const Rr = new Map;
    for (const {
        response: wt,
        p0: Ge,
        p1: xt,
        tile: Wt
      }
      of Tr) {
      const [At, pr] = Wt, [ar, zr] = Ge, [Jr, jr] = xt, Or = Jr - ar + 1, Fr = jr - zr + 1;
      for (let rn = 0; rn < Fr; rn++)
        for (let An = 0; An < Or; An++) {
          const kn = rn * Or + An,
            Kr = wt.paintedBy[kn];
          let Ur = Rr.get(Kr);
          Ur || (Ur = {
            latitudes: [],
            longitudes: [],
            tileXs: [],
            tileYs: [],
            pixelXs: [],
            pixelYs: [],
            globalPx: [],
            globalPy: [],
            minLat: 1 / 0,
            maxLat: -1 / 0,
            minLon: 1 / 0,
            maxLon: -1 / 0
          }, Rr.set(Kr, Ur));
          const Cn = ar + An,
            En = zr + rn,
            Tn = At * s.tileSize + (Cn + .5),
            Un = pr * s.tileSize + (En + .5),
            [Jn, ft] = Ve.pixelsToLatLon(Tn, Un, s.pixelArtZoom);
          if (Ur.latitudes.push(Jn), Ur.longitudes.push(ft), Ur.tileXs.push(At), Ur.tileYs.push(pr), Ur.pixelXs.push(Cn), Ur.pixelYs.push(En), Ur.globalPx.push(Tn), Ur.globalPy.push(Un), Jn < Ur.minLat && (Ur.minLat = Jn), Jn > Ur.maxLat && (Ur.maxLat = Jn), ft < Ur.minLon && (Ur.minLon = ft), ft > Ur.maxLon && (Ur.maxLon = ft), Kr !== 0) {
            const Ft = `${At}:${pr}:${Cn}:${En}`,
              Lr = {
                key: Ft,
                userId: Kr,
                lat: Jn,
                lon: ft,
                tile: [At, pr],
                pixel: [Cn, En],
                globalPx: Tn,
                globalPy: Un
              };
            Pt.set(Ft, Lr);
            const On = `${At}:${pr}`;
            let Zn = lt.get(On);
            Zn || (Zn = [], lt.set(On, Zn)), Zn.push(Lr)
          }
        }
    }
    const {
      users: Qr
    } = await dn.getMultipleUsersInfoById([...Rr.keys()]), br = Yx(Qr, wt => wt.id), Nt = [...Rr.entries()].map(([wt, Ge]) => ({
      ...br[wt] ?? {
        id: wt,
        name: "Player",
        deleted: !0
      },
      painted: Ge
    }));
    return Nt.sort((wt, Ge) => wt.id === 0 ? 1 : Ge.id === 0 ? -1 : Ge.painted.latitudes.length - wt.painted.latitudes.length), Nt
  }
  async function mr({
    preserveSelection: ie = !1
  } = {}) {
    if (r.length < 2) return;
    const J = ie ? new Set([...be.keys()]) : void 0,
      Ve = ie ? [...Xe.keys()] : void 0;
    try {
      H(z, !0);
      const rt = await Ot(r[0], r[1]);
      if (H(x, rt, !0), be.clear(), Xe.clear(), H(tt, g(tt) + 1), s.crosshair.clear(), ie && (J != null && J.size)) {
        for (const Ue of rt) J.has(Ue.id) && be.set(Ue.id, Ue);
        for (const Ue of be.values())
          for (let ae = 0; ae < Ue.painted.latitudes.length; ae++) s.crosshair.place([Ue.painted.latitudes[ae], Ue.painted.longitudes[ae]])
      }
      if (ie && (Ve != null && Ve.length)) {
        let Ue = !1;
        for (const ae of Ve) {
          const Ie = Pt.get(ae);
          Ie && (Xe.set(ae, Ie), Ue = !0)
        }
        Ue && H(tt, g(tt) + 1)
      }
      for (const Ue of Xe.values()) s.crosshair.place([Ue.lat, Ue.lon])
    } finally {
      H(z, !1)
    }
  }

  function zt(ie) {
    let J = !1;
    for (const Ve of ie)(tr(Ve) || Ve.id === 0) && (J = !0);
    J && xi.plop.play()
  }

  function Mt(ie) {
    for (let J = 0; J < ie.latitudes.length; J++) s.crosshair.remove([ie.latitudes[J], ie.longitudes[J]])
  }

  function kt(ie) {
    if (!ie) {
      _e = void 0;
      return
    }
    if (r.length >= 2 && g(Ne) === "area-select") {
      _e = void 0;
      return
    }
    _e = ie
  }
  cn(() => {
    r.length < 2 && g(Ne) !== "area-select" && H(Ne, "area-select");
    const ie = s.map.getCanvas();
    if (!ie) return;
    const J = g(Ne) === "user-picker" || g(Ne) === "brush-circle" || g(Ne) === "brush-square";
    ie.style.cursor = J ? "crosshair" : "", ht()
  }), cn(() => {
    const ie = yt();
    ie || fr(), Xt && (ie ? Yt() : lr())
  }), cn(() => {
    g(We), ht()
  }), cn(() => {
    typeof window < "u" && window.localStorage.setItem(Et, String(Math.trunc(g(We))))
  }), cn(() => {
    r.length, r.length < 2 ? (V.x !== 0 && (V.x = 0), V.y !== 0 && (V.y = 0)) : nt(), Gt(), hr()
  });

  function It() {
    const ie = s.map.getContainer(),
      J = document.createElement("div");
    J.classList.add("selection-rectangle"), J.style.position = "absolute", J.style.pointerEvents = "none", J.style.display = "none", J.style.zIndex = "6", ie.appendChild(J);
    const Ve = document.createElement("div");
    Ve.classList.add("selection-brush"), Ve.style.position = "absolute", Ve.style.pointerEvents = "none", Ve.style.display = "none", Ve.style.zIndex = "7", ie.appendChild(Ve);
    const rt = ur(ie, "horizontal"),
      Ue = ur(ie, "vertical");
    se = {
      horizontal: rt,
      vertical: Ue
    }, $ = Ve;
    const ae = pt => {
        kt({
          x: pt.point.x,
          y: pt.point.y
        }), Gt(), hr(), ht();
        const St = pt.originalEvent;
        if (!St) {
          jt && fr();
          return
        }
        if (!jt && St.altKey && yt()) {
          let qt = !1;
          if (St.buttons & 1 ? (Yt(), Rt = "add", jt = !0, qt = !0) : St.buttons & 2 && (Yt(), Rt = "remove", jt = !0, qt = !0), qt && Rt) {
            O(pt, Rt, {
              silent: !0
            });
            return
          }
        }
        if (jt && Rt) {
          if (!St.altKey || St.buttons === 0) {
            fr();
            return
          }
          O(pt, Rt, {
            silent: !0
          })
        }
      },
      Ie = pt => {
        const St = ie.getBoundingClientRect();
        kt({
          x: pt.clientX - St.left,
          y: pt.clientY - St.top
        }), Gt(), hr(), ht()
      },
      $e = () => {
        _e = void 0, fr(), Gt(), hr(), ht()
      },
      dt = () => {
        nt(), Gt(), hr(), ht()
      },
      Tt = pt => {
        if (!yt()) return;
        if (!(pt.altKey || Xt)) {
          jt && (fr(), lr());
          return
        }
        Xt = !0, Yt(), pt.preventDefault(), pt.stopPropagation(), typeof pt.stopImmediatePropagation == "function" && pt.stopImmediatePropagation();
        const St = pt.deltaY < 0 ? 1 : -1,
          qt = (pt.shiftKey ? 10 : 1) * St,
          qe = Math.min(Vt, Math.max(_t, g(We) + qt));
        qe !== g(We) && (H(We, qe, !0), ht())
      };
    return s.map.on("mousemove", ae), ie.addEventListener("pointermove", Ie), ie.addEventListener("mouseleave", $e), s.map.on("move", dt), s.map.on("resize", dt), ie.addEventListener("wheel", Tt, {
      passive: !1
    }), ee = J, Gt(), hr(), ht(), () => {
      s.map.off("mousemove", ae), s.map.off("move", dt), s.map.off("resize", dt), ie.removeEventListener("pointermove", Ie), ie.removeEventListener("mouseleave", $e), ie.removeEventListener("wheel", Tt), J.remove(), ee = void 0, _e = void 0, se == null || se.horizontal.remove(), se == null || se.vertical.remove(), se = void 0, $ == null || $.remove(), $ = void 0
    }
  }

  function Gt() {
    const ie = ee;
    if (!ie) return;
    const J = new Aa(s.tileSize);
    let Ve, rt, Ue, ae;
    if (r.length >= 2) {
      const Cr = r.map(_r => J.latLonToPixelsFloor(_r.lat, _r.lng, s.pixelArtZoom));
      Ve = Math.min(...Cr.map(([_r]) => _r)), rt = Math.max(...Cr.map(([_r]) => _r)) + 1, Ue = Math.min(...Cr.map(([, _r]) => _r)), ae = Math.max(...Cr.map(([, _r]) => _r)) + 1
    } else if (r.length === 1 && _e) {
      const [Cr, _r] = J.latLonToPixelsFloor(r[0].lat, r[0].lng, s.pixelArtZoom), Qe = s.map.unproject([_e.x, _e.y]), [rr, Kt] = J.latLonToPixelsFloor(Qe.lat, Qe.lng, s.pixelArtZoom);
      Ve = Math.min(Cr, rr), rt = Math.max(Cr, rr) + 1, Ue = Math.min(_r, Kt), ae = Math.max(_r, Kt) + 1
    } else {
      ie.style.display = "none";
      return
    }
    const [Ie, $e] = J.pixelsToLatLon(Ve, Ue, s.pixelArtZoom), [dt, Tt] = J.pixelsToLatLon(rt, ae, s.pixelArtZoom), pt = s.map.project([$e, Ie]), St = s.map.project([Tt, dt]);
    let qt = Math.min(pt.x, St.x),
      qe = Math.max(pt.x, St.x),
      bt = Math.min(pt.y, St.y),
      Jt = Math.max(pt.y, St.y);
    qe - qt < 1 && (qe = qt + 1), Jt - bt < 1 && (Jt = bt + 1), ie.style.display = "block", ie.style.left = `${qt}px`, ie.style.top = `${bt}px`, ie.style.width = `${qe-qt}px`, ie.style.height = `${Jt-bt}px`
  }

  function ht() {
    const ie = $;
    if (!ie) return;
    if (!(g(Ne) === "brush-circle" || g(Ne) === "brush-square") || !_e) {
      ie.style.display = "none";
      return
    }
    const J = new Aa(s.tileSize),
      Ve = s.map.unproject([_e.x, _e.y]),
      [rt, Ue] = J.latLonToPixels(Ve.lat, Ve.lng, s.pixelArtZoom),
      ae = g(We) + .5,
      [Ie, $e] = J.pixelsToLatLon(rt - ae, Ue - ae, s.pixelArtZoom),
      [dt, Tt] = J.pixelsToLatLon(rt + ae, Ue + ae, s.pixelArtZoom),
      pt = s.map.project([$e, Ie]),
      St = s.map.project([Tt, dt]),
      qt = Math.min(pt.x, St.x),
      qe = Math.max(pt.x, St.x),
      bt = Math.min(pt.y, St.y),
      Jt = Math.max(pt.y, St.y);
    ie.style.display = "block", ie.style.left = `${qt}px`, ie.style.top = `${bt}px`, ie.style.width = `${Math.max(qe-qt,2)}px`, ie.style.height = `${Math.max(Jt-bt,2)}px`, ie.style.borderRadius = g(Ne) === "brush-circle" ? "100%" : "4px", ie.dataset.radius = String(g(We))
  }

  function hr() {
    const ie = se;
    if (ie) {
      if (!_e || r.length >= 2) {
        wr();
        return
      }
      ie.horizontal.style.display = "block", ie.horizontal.style.top = `${_e.y}px`, ie.horizontal.style.transform = "translateY(-0.5px)", ie.vertical.style.display = "block", ie.vertical.style.left = `${_e.x}px`, ie.vertical.style.transform = "translateX(-0.5px)"
    }
  }

  function wr() {
    se && (se.horizontal.style.display = "none", se.vertical.style.display = "none")
  }

  function ur(ie, J) {
    const Ve = document.createElement("div");
    return Ve.style.position = "absolute", Ve.style.pointerEvents = "none", Ve.style.zIndex = "5", Ve.style.display = "none", Ve.style.mixBlendMode = "difference", Ve.style.backgroundColor = "rgba(255, 255, 255, 0.9)", J === "horizontal" ? (Ve.style.left = "0", Ve.style.right = "0", Ve.style.height = "1px") : (Ve.style.top = "0", Ve.style.bottom = "0", Ve.style.width = "1px"), ie.appendChild(Ve), Ve
  }
  async function qr(ie, J = "select") {
    var Ve;
    if (!g(vt)) {
      if (g(z)) {
        Zt.info("Wait until the selected area finishes loading.");
        return
      }
      if (r.length < 2) {
        Zt.info("Select an area first to use the user picker.");
        return
      }
      H(vt, !0);
      try {
        const rt = new Aa(s.tileSize),
          {
            tile: Ue,
            pixel: ae
          } = rt.latLonToTileAndPixel(ie.lngLat.lat, ie.lngLat.lng, s.pixelArtZoom),
          {
            paintedBy: Ie
          } = await dn.getPixelInfo({
            season: s.season,
            tile: Ue,
            pixel: ae,
            role: (Ve = Dt.data) == null ? void 0 : Ve.role
          });
        if (!Ie || Ie.id === 0) {
          Zt.info("That pixel is not painted by any player.");
          return
        }
        const $e = g(x).find(Tt => Tt.id === Ie.id);
        if (!$e) {
          Zt.info("Selected pixel is outside the selected area.");
          return
        }
        if (J === "deselect") {
          if (!be.has($e.id)) {
            Wr($e.id) ? (xi.plop.play(), Zt.success(`${$e.name} deselected`)) : Zt.info("That player is not selected.");
            return
          }
          be.delete($e.id), Mt($e.painted), Wr($e.id, {
            skipCrosshair: !0
          }), xi.plop.play(), Zt.success(`${$e.name} deselected`);
          return
        }
        if (be.has($e.id)) {
          Zt.info("Player already selected.");
          return
        }
        be.set($e.id, $e), (tr($e) || $e.id === 0) && xi.plop.play(), Zt.success(`${$e.name} selected`)
      } catch (rt) {
        Zt.error(rt.message)
      } finally {
        H(vt, !1)
      }
    }
  }

  function kr(ie, {
    skipCrosshair: J = !1
  } = {}) {
    return Xe.has(ie.key) ? !1 : (Xe.set(ie.key, ie), J || s.crosshair.place([ie.lat, ie.lon]), !0)
  }

  function Zr(ie, {
    skipCrosshair: J = !1
  } = {}) {
    const Ve = Xe.get(ie);
    return Ve ? (Xe.delete(ie), J || s.crosshair.remove([Ve.lat, Ve.lon]), !0) : !1
  }

  function Wr(ie, {
    skipCrosshair: J = !1
  } = {}) {
    const Ve = [];
    for (const [Ue, ae] of Xe.entries()) ae.userId === ie && Ve.push(Ue);
    let rt = !1;
    for (const Ue of Ve) Zr(Ue, {
      skipCrosshair: J
    }) && (rt = !0);
    return rt && H(tt, g(tt) + 1), rt
  }

  function tr(ie, {
    skipCrosshair: J = !1
  } = {}) {
    if (ie.id === 0) return !1;
    const Ve = ie.painted;
    let rt = !1;
    for (let Ue = 0; Ue < Ve.latitudes.length; Ue++) {
      const ae = Ve.tileXs[Ue],
        Ie = Ve.tileYs[Ue],
        $e = Ve.pixelXs[Ue],
        dt = Ve.pixelYs[Ue],
        Tt = `${ae}:${Ie}:${$e}:${dt}`;
      let pt = Pt.get(Tt);
      if (!pt) {
        pt = {
          key: Tt,
          userId: ie.id,
          lat: Ve.latitudes[Ue],
          lon: Ve.longitudes[Ue],
          tile: [ae, Ie],
          pixel: [$e, dt],
          globalPx: Ve.globalPx[Ue],
          globalPy: Ve.globalPy[Ue]
        }, Pt.set(Tt, pt);
        const St = `${ae}:${Ie}`;
        let qt = lt.get(St);
        qt || (qt = [], lt.set(St, qt)), qt.push(pt)
      }
      kr(pt, {
        skipCrosshair: J
      }) && (rt = !0)
    }
    return rt && H(tt, g(tt) + 1), rt
  }

  function Hr(ie) {
    return g(x).find(J => J.id === ie)
  }

  function sr(ie, {
    silent: J = !1
  } = {}) {
    let Ve = !1;
    for (const [rt, Ue] of ie) {
      if (be.has(rt)) continue;
      const ae = Hr(rt);
      if (!ae) continue;
      const Ie = ae.painted.latitudes.length;
      (g(Ye).get(rt) ?? 0) + Ue >= Ie && (be.set(rt, ae), Ve = !0)
    }
    Ve && !J && xi.plop.play()
  }

  function de(ie, J) {
    if (Pt.size === 0) return [];
    const Ve = new Aa(s.tileSize),
      [rt, Ue] = Ve.latLonToPixels(ie, J, s.pixelArtZoom),
      ae = g(We) + .5,
      Ie = rt - ae,
      $e = rt + ae,
      dt = Ue - ae,
      Tt = Ue + ae,
      pt = Math.floor(Ie / s.tileSize),
      St = Math.floor($e / s.tileSize),
      qt = Math.floor(dt / s.tileSize),
      qe = Math.floor(Tt / s.tileSize),
      bt = [];
    for (let Jt = pt; Jt <= St; Jt++)
      for (let Cr = qt; Cr <= qe; Cr++) {
        const _r = `${Jt}:${Cr}`,
          Qe = lt.get(_r);
        if (Qe)
          for (const rr of Qe) {
            const Kt = rr.globalPx - rt,
              Tr = rr.globalPy - Ue;
            if (g(Ne) === "brush-circle") {
              if (Kt * Kt + Tr * Tr > ae * ae) continue
            } else if (Math.abs(Kt) > ae || Math.abs(Tr) > ae) continue;
            bt.push(rr)
          }
      }
    return bt
  }

  function O(ie, J, {
    silent: Ve = !1
  } = {}) {
    if (g(z)) return Ve || Zt.info("Wait until the selected area finishes loading."), !1;
    if (r.length < 2) return Ve || Zt.info("Select an area first to use the brush tool."), !1;
    const rt = de(ie.lngLat.lat, ie.lngLat.lng);
    if (rt.length === 0) {
      if (!Ve) {
        const Ie = J === "add" ? "No painted pixels found within the brush." : "No selected pixels to remove within the brush.";
        Zt.info(Ie)
      }
      return !1
    }
    let Ue = !1;
    const ae = new Map;
    if (J === "add")
      for (const Ie of rt) be.has(Ie.userId) || Xe.has(Ie.key) || kr(Ie) && (Ue = !0, ae.set(Ie.userId, (ae.get(Ie.userId) ?? 0) + 1));
    else
      for (const Ie of rt) Zr(Ie.key) && (Ue = !0, be.has(Ie.userId) && be.delete(Ie.userId));
    return Ue ? (J === "add" && ae.size > 0 && sr(ae, {
      silent: Ve
    }), H(tt, g(tt) + 1), Ve || xi.plop.play(), !0) : (!Ve && J === "add" && Zt.info("All pixels inside the brush are already selected."), !1)
  }
  async function N() {
    const ie = s.map.getCanvas();
    if (!ie) return Zt.error("Unable to access map canvas."), !1;
    const J = ie.getBoundingClientRect();
    if (!J.width || !J.height) return Zt.error("Map is not visible to capture."), !1;
    let Ve = 1 / 0,
      rt = -1 / 0,
      Ue = 1 / 0,
      ae = -1 / 0;
    for (const Ge of r) {
      const {
        lat: xt,
        lng: Wt
      } = Ge;
      xt < Ve && (Ve = xt), xt > rt && (rt = xt), Wt < Ue && (Ue = Wt), Wt > ae && (ae = Wt)
    }
    if (!isFinite(Ve) || !isFinite(rt) || !isFinite(Ue) || !isFinite(ae)) return Zt.error("Unable to determine selected area."), !1;
    const Ie = s.map.project([Ue, rt]),
      $e = s.map.project([ae, Ve]);
    if (!Number.isFinite(Ie.x) || !Number.isFinite(Ie.y) || !Number.isFinite($e.x) || !Number.isFinite($e.y)) return Zt.error("Unable to project selected area on the map."), !1;
    let dt = Math.min(Ie.x, $e.x),
      Tt = Math.max(Ie.x, $e.x),
      pt = Math.min(Ie.y, $e.y),
      St = Math.max(Ie.y, $e.y);
    dt = Math.max(0, dt), pt = Math.max(0, pt), Tt = Math.min(J.width, Tt), St = Math.min(J.height, St);
    const qt = Tt - dt,
      qe = St - pt;
    if (qt <= 0 || qe <= 0) return Zt.error("Selected area is outside the current map view."), !1;
    const bt = ie.width / J.width,
      Jt = ie.height / J.height,
      Cr = Math.floor(dt * bt),
      _r = Math.floor(pt * Jt),
      Qe = Math.max(1, Math.ceil(Tt * bt) - Cr),
      rr = Math.max(1, Math.ceil(St * Jt) - _r),
      Kt = await kp(s.map);
    let Tr;
    if ("createImageBitmap" in window) Tr = await createImageBitmap(Kt);
    else {
      const Ge = URL.createObjectURL(Kt);
      Tr = await new Promise((xt, Wt) => {
        const At = new Image;
        At.crossOrigin = "anonymous", At.onload = () => xt(At), At.onerror = () => Wt(new Error("Failed to decode map image.")), At.src = Ge
      }), URL.revokeObjectURL(Ge)
    }
    const Rr = document.createElement("canvas");
    Rr.width = Qe, Rr.height = rr;
    const Qr = Rr.getContext("2d");
    if (!Qr) return "close" in Tr && Tr.close(), Zt.error("Unable to create drawing context."), !1;
    Qr.drawImage(Tr, Cr, _r, Qe, rr, 0, 0, Qe, rr), "close" in Tr && Tr.close();
    const br = await new Promise((Ge, xt) => {
        Rr.toBlob(Wt => {
          Wt ? Ge(Wt) : xt(new Error("Failed to prepare download."))
        }, "image/png")
      }),
      Nt = URL.createObjectURL(br),
      wt = document.createElement("a");
    return wt.href = Nt, wt.download = `selected-map-${Qe}x${rr}.png`, document.body.appendChild(wt), wt.click(), document.body.removeChild(wt), URL.revokeObjectURL(Nt), !0
  }
  async function X() {
    if (!(g(l) || g(z))) {
      if (r.length < 2) {
        Zt.info(g(F) ? "Select an area first to save the map view." : "Select an area first to save pixel art.");
        return
      }
      H(l, !0);
      try {
        switch (g(F)) {
          case !0:
            if (g(F)) {
              await N() && Zt.success("Selected map view saved");
              return
            }
          case !1:
            const ie = new Aa(s.tileSize);
            let J = 1 / 0,
              Ve = -1 / 0,
              rt = 1 / 0,
              Ue = -1 / 0;
            for (let Qe = 0; Qe < r.length; Qe++) {
              const rr = r[Qe],
                Kt = ie.latLonToPixelsFloor(rr.lat, rr.lng, s.pixelArtZoom),
                Tr = Kt[0],
                Rr = Kt[1];
              Tr < J && (J = Tr), Tr > Ve && (Ve = Tr), Rr < rt && (rt = Rr), Rr > Ue && (Ue = Rr)
            }
            if (!isFinite(J) || !isFinite(Ve) || !isFinite(rt) || !isFinite(Ue)) {
              Zt.error("Unable to determine selected area.");
              return
            }
            const ae = Ve + 1,
              Ie = Ue + 1,
              $e = ae - J,
              dt = Ie - rt;
            if ($e <= 0 || dt <= 0) {
              Zt.error("Selected area has no size.");
              return
            }
            const Tt = document.createElement("canvas");
            Tt.width = $e, Tt.height = dt;
            const pt = Tt.getContext("2d");
            if (!pt) {
              Zt.error("Unable to create drawing context.");
              return
            }
            const St = Math.floor(J / s.tileSize),
              qt = Math.floor((ae - 1) / s.tileSize),
              qe = Math.floor(rt / s.tileSize),
              bt = Math.floor((Ie - 1) / s.tileSize);
            for (let Qe = qe; Qe <= bt; Qe++)
              for (let rr = St; rr <= qt; rr++) {
                const Kt = rr * s.tileSize,
                  Tr = Qe * s.tileSize,
                  Rr = Math.max(J, Kt),
                  Qr = Math.max(rt, Tr),
                  br = Math.min(ae, Kt + s.tileSize),
                  Nt = Math.min(Ie, Tr + s.tileSize),
                  wt = br - Rr,
                  Ge = Nt - Qr;
                if (wt <= 0 || Ge <= 0) continue;
                const xt = await fetch(`${i0}/s${s.season}/tiles/${rr}/${Qe}.png`);
                if (!xt.ok) throw new Error("Failed to load tile image.");
                const Wt = await xt.blob();
                if ("createImageBitmap" in window) {
                  const At = await createImageBitmap(Wt);
                  pt.drawImage(At, Rr - Kt, Qr - Tr, wt, Ge, Rr - J, Qr - rt, wt, Ge), At.close && At.close()
                } else {
                  const At = URL.createObjectURL(Wt),
                    pr = await new Promise((ar, zr) => {
                      const Jr = new Image;
                      Jr.crossOrigin = "anonymous", Jr.onload = () => ar(Jr), Jr.onerror = () => zr(new Error("Failed to decode tile image.")), Jr.src = At
                    });
                  pt.drawImage(pr, Rr - Kt, Qr - Tr, wt, Ge, Rr - J, Qr - rt, wt, Ge), URL.revokeObjectURL(At)
                }
              }
            const Jt = await new Promise((Qe, rr) => {
                Tt.toBlob(Kt => {
                  Kt ? Qe(Kt) : rr(new Error("Failed to prepare download."))
                }, "image/png")
              }),
              Cr = URL.createObjectURL(Jt),
              _r = document.createElement("a");
            _r.href = Cr, _r.download = `selected-area-${$e}x${dt}.png`, document.body.appendChild(_r), _r.click(), document.body.removeChild(_r), URL.revokeObjectURL(Cr), Zt.success("Selected area image saved")
        }
      } catch (ie) {
        Zt.error(ie.message)
      } finally {
        H(l, !1)
      }
    }
  }
  async function re() {
    if (g(k) || g(z)) return;
    const ie = new Map;
    for (const J of be.values()) {
      if (J.id === 0) continue;
      const {
        tileXs: Ve,
        tileYs: rt,
        pixelXs: Ue,
        pixelYs: ae
      } = J.painted;
      for (let Ie = 0; Ie < Ve.length; Ie++) {
        const $e = [Ve[Ie], rt[Ie]],
          dt = [Ue[Ie], ae[Ie]],
          Tt = {
            tile: $e,
            pixel: dt,
            season: s.season
          },
          pt = `${$e[0]}:${$e[1]}:${dt[0]}:${dt[1]}`;
        ie.set(pt, Tt)
      }
    }
    for (const J of Xe.values()) be.has(J.userId) || ie.has(J.key) || ie.set(J.key, {
      tile: J.tile,
      pixel: J.pixel,
      season: s.season
    });
    if (ie.size === 0) {
      Zt.info("Select painted pixels to clear with transparent color");
      return
    }
    H(k, !0);
    try {
      xi.droppletAndPlop.play();
      const J = await lm(),
        Ve = [];
      for (const ae of ie.values()) Ve.push({
        ...ae,
        colorIdx: 0
      });
      await dn.selectAreaClear(Ve, J);
      const rt = vp(0),
        Ue = Ve.map(({
          tile: ae,
          pixel: Ie,
          season: $e
        }) => ({
          tile: ae,
          pixel: Ie,
          season: $e,
          color: rt
        }));
      await U_(Ue), Zt.success("Painted selected pixels with transparent color"), await mr()
    } catch (J) {
      Zt.error(J.message)
    } finally {
      H(k, !1)
    }
  }
  const Q = ie => ({
    id: ie.id,
    name: ie.name,
    picture: ie.picture,
    allianceId: ie.allianceId ?? void 0,
    allianceName: ie.allianceName ?? void 0,
    timedOut: ie.timedOut,
    banned: ie.banned,
    deleted: ie.deleted
  });

  function ue() {
    const ie = new Map;
    for (const J of be.values()) J.id !== 0 && ie.set(J.id, J);
    if (Xe.size > 0) {
      let J;
      for (const Ve of Xe.values()) {
        const rt = Ve.userId;
        if (rt === 0 || ie.has(rt)) continue;
        if (!J) {
          J = new Map;
          for (const ae of g(x)) J.set(ae.id, ae)
        }
        const Ue = J.get(rt);
        Ue && ie.set(Ue.id, Ue)
      }
    }
    return [...ie.values()]
  }
  async function ke(ie, J) {
    try {
      H(E, !0);
      const Ve = ie.filter(pt => pt.id !== 0);
      if (Ve.length === 0) {
        Zt.info("Select at least one player");
        return
      }
      let rt = 1 / 0,
        Ue = -1 / 0,
        ae = 1 / 0,
        Ie = -1 / 0;
      if (r.length >= 2)
        for (const pt of r) {
          const {
            lat: St,
            lng: qt
          } = pt;
          !isFinite(St) || !isFinite(qt) || (St < rt && (rt = St), St > Ue && (Ue = St), qt < ae && (ae = qt), qt > Ie && (Ie = qt))
        }
      rt === Ue && (rt -= 1e-6, Ue += 1e-6), ae === Ie && (ae -= 1e-6, Ie += 1e-6), s.map.stop();
      const $e = s.map.getCanvas(),
        dt = Math.max(48, Math.min($e.width, $e.height) * .08);
      s.map.fitBounds([
        [Math.min(ae, Ie), Math.min(rt, Ue)],
        [Math.max(ae, Ie), Math.max(rt, Ue)]
      ], {
        padding: dt,
        duration: 0
      });
      const Tt = (async () => await kp(s.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: .8,
        type: "image/jpeg"
      }))();
      s.onmodaction({
        action: J,
        targets: Ve.map(Q),
        image: Tt,
        latLon: [(rt + Ue) / 2, (ae + Ie) / 2],
        zoom: s.map.getZoom(),
        onSuccess: async () => {
          await mr({
            preserveSelection: !0
          })
        }
      })
    } catch (Ve) {
      Zt.error(Ve.message)
    } finally {
      H(E, !1)
    }
  }
  var xe = Sr();
  In("keydown", Os, ie => ie.code === "Escape" && Qt());
  var Ee = Ct(xe);
  {
    var He = ie => {
        Tc(ie, {
          class: "bg-warning animate-bounce",
          children: (J, Ve) => {
            var rt = axe(),
              Ue = Ct(rt);
            B_(Ue, {
              class: "inline size-5"
            });
            var ae = D(Ue, 2);
            {
              var Ie = dt => {
                  var Tt = Oi();
                  Re(pt => te(Tt, pt), [() => w$()]), q(dt, Tt)
                },
                $e = dt => {
                  var Tt = Sr(),
                    pt = Ct(Tt);
                  {
                    var St = qt => {
                      var qe = Oi();
                      Re(bt => te(qe, bt), [() => R$()]), q(qt, qe)
                    };
                    Te(pt, qt => {
                      r.length === 1 && qt(St)
                    }, !0)
                  }
                  q(dt, Tt)
                };
              Te(ae, dt => {
                r.length === 0 ? dt(Ie) : dt($e, !1)
              })
            }
            q(J, rt)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Be = ie => {
        var J = kxe();
        let Ve;
        var rt = M(J),
          Ue = M(rt),
          ae = M(Ue);
        ae.__pointerdown = Ut, ds(ae, "", {}, {
          "touch-action": "none"
        });
        var Ie = M(ae),
          $e = M(Ie),
          dt = M($e);
        B_(dt, {
          class: "size-4"
        }), S($e);
        var Tt = D($e, 4),
          pt = M(Tt);
        S(Tt), S(Ie);
        var St = D(Ie, 2),
          qt = M(St),
          qe = M(qt);
        qe.__click = () => {
          H(F, g(F) !== !0)
        };
        var bt = M(qe);
        rxe(bt, {
          class: "h-4 w-4"
        });
        var Jt = D(bt, 2);
        Ki(Jt), S(qe);
        var Cr = D(qe, 2);
        Cr.__click = X;
        var _r = M(Cr);
        {
          var Qe = Fr => {
              var rn = oxe();
              q(Fr, rn)
            },
            rr = Fr => {
              H_(Fr, {
                class: "size-4"
              })
            };
          Te(_r, Fr => {
            g(l) ? Fr(Qe) : Fr(rr, !1)
          })
        }
        S(Cr), S(qt);
        var Kt = D(qt, 2);
        let Tr;
        Kt.__click = () => {
          if (g(Ne) === "brush-circle") {
            H(Ne, "area-select");
            return
          }
          if (g(z)) {
            Zt.info("Wait until the selected area finishes loading.");
            return
          }
          if (r.length < 2) {
            Zt.info("Select an area first to use the brush tools.");
            return
          }
          H(Ne, "brush-circle")
        };
        var Rr = M(Kt);
        exe(Rr, {
          class: "size-4"
        }), S(Kt);
        var Qr = D(Kt, 2);
        let br;
        Qr.__click = () => {
          if (g(Ne) === "brush-square") {
            H(Ne, "area-select");
            return
          }
          if (g(z)) {
            Zt.info("Wait until the selected area finishes loading.");
            return
          }
          if (r.length < 2) {
            Zt.info("Select an area first to use the brush tools.");
            return
          }
          H(Ne, "brush-square")
        };
        var Nt = M(Qr);
        ixe(Nt, {
          class: "size-4"
        }), S(Qr);
        var wt = D(Qr, 2);
        let Ge;
        wt.__click = () => {
          if (g(Ne) === "user-picker") {
            H(Ne, "area-select");
            return
          }
          if (g(z)) {
            Zt.info("Wait until the selected area finishes loading.");
            return
          }
          if (r.length < 2) {
            Zt.info("Select an area first to use the user picker.");
            return
          }
          H(Ne, "user-picker")
        };
        var xt = M(wt);
        {
          var Wt = Fr => {
              var rn = sxe();
              q(Fr, rn)
            },
            At = Fr => {
              Jbe(Fr, {
                class: "size-4"
              })
            };
          Te(xt, Fr => {
            g(vt) ? Fr(Wt) : Fr(At, !1)
          })
        }
        S(wt);
        var pr = D(wt, 2);
        pr.__click = Qt;
        var ar = M(pr);
        Ro(ar, {
          class: "size-4"
        }), S(pr), S(St), S(ae);
        var zr = D(ae, 2),
          Jr = M(zr);
        {
          var jr = Fr => {
              var rn = lxe();
              q(Fr, rn)
            },
            Or = Fr => {
              var rn = Sr(),
                An = Ct(rn);
              {
                var kn = Ur => {
                    var Cn = cxe();
                    q(Ur, Cn)
                  },
                  Kr = Ur => {
                    var Cn = wxe(),
                      En = M(Cn),
                      Tn = M(En),
                      Un = M(Tn),
                      Jn = M(Un),
                      ft = M(Jn);
                    Ki(ft), ft.__click = pn => {
                      if (g(De) === "none") {
                        Xe.clear(), H(tt, g(tt) + 1), s.crosshair.clear();
                        const Ar = [];
                        for (const gn of g(x)) be.has(gn.id) || (be.set(gn.id, gn), Ar.push(gn));
                        Ar.length && zt(Ar);
                        return
                      }
                      be.clear(), Xe.clear(), H(tt, g(tt) + 1), s.crosshair.clear()
                    }, S(Jn);
                    var Ft = D(Jn),
                      Lr = D(M(Ft));
                    Lr.__click = () => {
                      navigator.clipboard.writeText([...be.keys()].filter(pn => pn !== 0).join(", ")), Zt.success("Player IDs copied to clipboard")
                    };
                    var On = M(Lr);
                    K_(On, {
                      class: "size-3"
                    }), S(Lr);
                    var Zn = D(Lr, 2);
                    {
                      var Si = pn => {
                        var Ar = uxe();
                        Ar.__click = () => {
                          const Ir = ue();
                          ke(Ir, "timeout")
                        };
                        var gn = M(Ar);
                        Yu(gn, {
                          class: "size-4"
                        }), S(Ar), Re(() => Ar.disabled = g(E)), q(pn, Ar)
                      };
                      Te(Zn, pn => {
                        Dt.hasPermission(Di.tools.selectArea.timeout) && pn(Si)
                      })
                    }
                    var Kn = D(Zn, 2);
                    {
                      var Nn = pn => {
                        var Ar = hxe();
                        Ar.__click = () => {
                          const Ir = ue();
                          ke(Ir, "ban")
                        };
                        var gn = M(Ar);
                        yp(gn, {
                          class: "size-4"
                        }), S(Ar), Re(() => Ar.disabled = g(E)), q(pn, Ar)
                      };
                      Te(Kn, pn => {
                        Dt.hasPermission(Di.tools.selectArea.ban) && pn(Nn)
                      })
                    }
                    S(Ft);
                    var Ri = D(Ft),
                      Br = M(Ri);
                    {
                      var Pr = pn => {
                        var Ar = pxe();
                        Ar.__click = re;
                        var gn = M(Ar);
                        {
                          var Ir = Gn => {
                              var qn = dxe();
                              q(Gn, qn)
                            },
                            tn = Gn => {
                              n_(Gn, {
                                class: "size-4"
                              })
                            };
                          Te(gn, Gn => {
                            g(k) ? Gn(Ir) : Gn(tn, !1)
                          })
                        }
                        S(Ar), Re(() => Ar.disabled = g(k) || g(z) || be.size === 0 && g(Ce) === 0), q(pn, Ar)
                      };
                      Te(Br, pn => {
                        Dt.hasPermission(Di.tools.selectArea.clear) && pn(Pr)
                      })
                    }
                    bn(), S(Ri), S(Un), S(Tn);
                    var Dn = D(Tn);
                    si(Dn, 23, () => g(x), pn => pn.id, (pn, Ar, gn, Ir) => {
                      const tn = mt(() => be.has(g(Ar).id)),
                        Gn = mt(() => g(Ye).get(g(Ar).id) ?? 0),
                        qn = mt(() => g(tn) || g(Gn) > 0);
                      var Ln = xxe();
                      let Pn;
                      Ln.__click = () => {
                        g(tn) ? (be.delete(g(Ar).id), Mt(g(Ar).painted), Wr(g(Ar).id, {
                          skipCrosshair: !0
                        })) : (Wr(g(Ar).id, {
                          skipCrosshair: !0
                        }), be.set(g(Ar).id, g(Ar)), (tr(g(Ar)) || g(Ar).id === 0) && xi.plop.play())
                      };
                      var Mn = M(Ln),
                        fn = M(Mn);
                      Ki(fn), S(Mn);
                      var un = D(Mn),
                        ia = M(un);
                      {
                        var Wn = hi => {
                            var Mi = fxe();
                            bn(2), q(hi, Mi)
                          },
                          ii = hi => {
                            var Mi = yxe(),
                              Ni = Ct(Mi);
                            Ra(Ni, {
                              class: "size-5 border-0",
                              get userId() {
                                return g(Ar).id
                              },
                              get pictureUrl() {
                                return g(Ar).picture
                              }
                            });
                            var Sn = D(Ni, 2),
                              wa = M(Sn),
                              vn = M(wa),
                              yn = M(vn, !0);
                            S(vn);
                            var Ba = D(vn, 2),
                              Rn = M(Ba);
                            S(Ba), S(wa);
                            var Oa = D(wa, 2);
                            {
                              var Vi = di => {
                                var Ii = _xe(),
                                  _a = M(Ii, !0);
                                S(Ii), Re((pi, Va) => {
                                  Vr(Ii, 1, `badge badge-sm ml-0.5 border-0 ${pi??""} ${Va??""}`, "svelte-15blegn"), te(_a, g(Ar).allianceName)
                                }, [() => Cp(g(Ar).allianceId), () => na(g(Ar).allianceId)]), q(di, Ii)
                              };
                              Te(Oa, di => {
                                g(Ar).allianceId && di(Vi)
                              })
                            }
                            var eo = D(Oa, 2);
                            {
                              var qa = di => {
                                var Ii = mxe();
                                q(di, Ii)
                              };
                              Te(eo, di => {
                                g(Ar).deleted && di(qa)
                              })
                            }
                            var ka = D(eo, 2),
                              oo = M(ka);
                            {
                              var Na = di => {
                                  var Ii = gxe(),
                                    _a = M(Ii);
                                  yp(_a, {
                                    class: "text-error size-4"
                                  }), S(Ii), Re(pi => er(Ii, "data-tip", pi), [() => X_()]), q(di, Ii)
                                },
                                to = di => {
                                  var Ii = Sr(),
                                    _a = Ct(Ii);
                                  {
                                    var pi = Va => {
                                      var Bo = vxe(),
                                        vs = M(Bo);
                                      Yu(vs, {
                                        class: "text-error size-4"
                                      }), S(Bo), Re(Hn => er(Bo, "data-tip", Hn), [() => b0()]), q(Va, Bo)
                                    };
                                    Te(_a, Va => {
                                      g(Ar).timedOut && Va(pi)
                                    }, !0)
                                  }
                                  q(di, Ii)
                                };
                              Te(oo, di => {
                                g(Ar).banned ? di(Na) : di(to, !1)
                              })
                            }
                            S(ka), S(Sn), Re(di => {
                              Vr(wa, 1, `font-medium ${di??""} flex gap-1.5`, "svelte-15blegn"), te(yn, g(Ar).name), te(Rn, `#${g(Ar).id??""}`)
                            }, [() => na(g(Ar).id)]), q(hi, Mi)
                          };
                        Te(ia, hi => {
                          g(Ar).id === 0 ? hi(Wn) : hi(ii, !1)
                        })
                      }
                      S(un);
                      var li = D(un),
                        ji = M(li),
                        Pi = D(ji);
                      {
                        var Qn = hi => {
                          var Mi = bxe(),
                            Ni = M(Mi);
                          S(Mi), Re(Sn => te(Ni, `(${Sn??""} selected)`), [() => g(Gn).toLocaleString(navigator.language)]), q(hi, Mi)
                        };
                        Te(Pi, hi => {
                          !g(tn) && g(Gn) > 0 && hi(Qn)
                        })
                      }
                      S(li), S(Ln), Re(hi => {
                        Pn = Vr(Ln, 1, "hover:bg-base-300 cursor-pointer svelte-15blegn", null, Pn, {
                          "bg-base-200": g(qn)
                        }), t_(fn, g(tn)), fn.indeterminate = !g(tn) && g(Gn) > 0, te(ji, `${hi??""} `)
                      }, [() => g(Ar).painted.latitudes.length.toLocaleString(navigator.language)]), q(pn, Ln)
                    }), S(Dn), S(En), S(Cn), Re(() => {
                      t_(ft, g(De) !== "none"), ft.indeterminate = g(De) === "some"
                    }), q(Ur, Cn)
                  };
                Te(An, Ur => {
                  g(x).length === 0 ? Ur(kn) : Ur(Kr, !1)
                }, !0)
              }
              q(Fr, rn)
            };
          Te(Jr, Fr => {
            g(z) ? Fr(jr) : Fr(Or, !1)
          })
        }
        S(zr), S(Ue), S(rt), S(J), ja(J, Fr => H(ge, Fr), () => g(ge)), Re((Fr, rn) => {
          Ve = ds(J, "", Ve, {
            transform: `translate3d(${V.x}px, ${V.y}px, 0)`,
            "will-change": "transform"
          }), te(pt, `(Pixels: ${Fr??""})`), er(Jt, "aria-label", `${rn??""} toggle`), er(Cr, "data-tip", g(F) ? "Save selected map view" : "Save selected pixel art"), Cr.disabled = g(l) || g(z), Tr = Vr(Kt, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Tr, {
            "btn-soft": g(Ne) !== "brush-circle",
            "btn-primary": g(Ne) === "brush-circle"
          }), er(Kt, "data-tip", `Circle brush (Alt + scroll to resize) Â· Size: ${g(Le)}`), er(Kt, "aria-label", g(Ne) === "brush-circle" ? "Disable circle brush tool" : `Enable circle brush tool (size ${g(Le)})`), er(Kt, "aria-pressed", g(Ne) === "brush-circle"), br = Vr(Qr, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, br, {
            "btn-soft": g(Ne) !== "brush-square",
            "btn-primary": g(Ne) === "brush-square"
          }), er(Qr, "data-tip", `Square brush (Alt + scroll to resize) Â· Size: ${g(Le)}`), er(Qr, "aria-label", g(Ne) === "brush-square" ? "Disable square brush tool" : `Enable square brush tool (size ${g(Le)})`), er(Qr, "aria-pressed", g(Ne) === "brush-square"), Ge = Vr(wt, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Ge, {
            "btn-soft": g(Ne) !== "user-picker",
            "btn-primary": g(Ne) === "user-picker"
          }), er(wt, "data-tip", g(Ne) === "user-picker" ? "User picker enabled. Click pixels to select their painter." : "Enable the user picker to select a player by clicking a pixel."), er(wt, "aria-label", g(Ne) === "user-picker" ? "Disable user picker tool" : "Enable user picker tool"), er(wt, "aria-pressed", g(Ne) === "user-picker")
        }, [() => g(Ke).toLocaleString(navigator.language), () => ooe()]), gp(Jt, () => g(F), Fr => H(F, Fr)), fa(3, rt, () => ip, () => ({
          duration: 100
        })), q(ie, J)
      };
    Te(Ee, ie => {
      r.length < 2 ? ie(He) : ie(Be, !1)
    })
  }
  q(p, xe), an()
}
Yn(["pointerdown", "click"]);
var Sxe = Yr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function fm(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Sxe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Pxe = Yr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function Mxe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = Pxe();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var Ixe = Yr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  Cxe = Yr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function zxe(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Sr(),
    z = Ct(x);
  {
    var E = l => {
        var F = Ixe();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      },
      k = l => {
        var F = Cxe();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      };
    Te(z, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  q(p, x)
}
var Axe = he('<a target="_blank"><button class="btn btn-xs py-3"><!></button></a>'),
  Exe = he('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button> <!>', 1),
  Lxe = he('<div class="skeleton h-5 w-16"></div>'),
  Dxe = he('<div class="skeleton mt-1 h-5 w-32"></div>'),
  Rxe = he('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm">ðŸŽ„</div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span>Christmas</span></span></div></div>'),
  jxe = he('<img alt="Frame equipado" class="pointer-events-none absolute inset-0 h-6 w-6 select-none"/>'),
  Fxe = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  Bxe = he("<button><!></button>"),
  Oxe = he("<span> </span> <!>", 1),
  qxe = he('<span class="tooltip"><!></span>'),
  Nxe = he('<span class="tooltip"><!></span>'),
  Vxe = he("<li><button><!> </button></li>"),
  Uxe = he("<li><button><!> </button></li>"),
  Zxe = he("<li><button><!> </button></li>"),
  Gxe = he('<li><button class="text-error font-medium"><!> </button></li>'),
  Wxe = he('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'),
  Hxe = he('<div class="flex items-center gap-1"><span> </span> <div class="relative ml-0.5 h-5 w-6"><div class="ml-0.5"><!></div> <!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'),
  $xe = he('<button class="btn btn-primary"><!> </button>'),
  Xxe = he("<!> ", 1),
  Yxe = he("<!> ", 1),
  Kxe = he('<button class="btn btn-primary"><!></button>'),
  Jxe = he("<button><!> </button>"),
  Qxe = he('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function e1e(p, s) {
  nn(s, !0);
  let r = Je(void 0);
  const x = mt(() => new Aa(s.tileSize));
  let z = Je(void 0),
    E = Je(void 0),
    k = Je(!1),
    l = Je(!1);
  const F = mt(() => {
      var ot, nt, Ut;
      return !!((nt = (ot = g(r)) == null ? void 0 : ot.paintedBy) != null && nt.id) && ((Ut = Dt.data) == null ? void 0 : Ut.id) === g(r).paintedBy.id
    }),
    W = mt(() => {
      const [ot, nt] = s.latLon ?? [0, 0];
      return `https://wplace.eralyon.net/?lat=${ot}&lng=${nt}&zoom=${s.zoom}`
    }),
    ee = mt(() => {
      const [ot, nt] = s.latLon ?? [0, 0], Ut = g(x).latLonToPixelBoundsLatLon(ot, nt, s.pixelArtZoom), Qt = im(Ut), {
        tile: Ot,
        pixel: mr
      } = g(x).latLonToTileAndPixel(ot, nt, s.pixelArtZoom), zt = g(x).latLonToRegionAndPixel(ot, nt, s.pixelArtZoom);
      return {
        lat: ot,
        lon: nt,
        bounds: Ut,
        center: Qt,
        tile: Ot,
        pixel: mr,
        regionPixel: zt.pixel
      }
    });
  cn(() => {
    xi.plop.play(), s.crosshair.clearAndPlace(s.latLon)
  });
  let $ = 0;
  const se = ({
    pixel: ot,
    tile: nt,
    season: Ut
  }) => `s${Ut}:p(${ot[0]},${ot[1]}):t(${nt[0]},${nt[1]})`;
  let _e;
  ps(() => [g(ee), s.season], () => {
    const ot = {
      ...g(ee),
      season: s.season
    };
    s.christmasTreeId !== void 0 && (ot.christmasTreeId = s.christmasTreeId);
    const nt = se(ot);
    if (H(r, s.pixelInfoCache.get(nt), !0), g(r) !== void 0) return;
    s.pixelInfoCache.size === 0 && ($ = 0), $++, $ > 6 ? (clearTimeout(_e), _e = setTimeout(async () => ge(ot), 500)) : ge(ot)
  });
  async function ge(ot) {
    var Qt;
    const nt = await dn.getPixelInfo({
      ...ot,
      role: (Qt = Dt.data) == null ? void 0 : Qt.role,
      christmasTreeId: s.christmasTreeId
    });
    if (nt.paintedBy !== void 0) {
      const Ot = se(ot);
      s.pixelInfoCache.set(Ot, nt)
    }
    const Ut = se({
      ...g(ee),
      season: s.season
    });
    return H(r, s.pixelInfoCache.get(Ut), !0), nt
  }
  Yi(() => () => {
    s.crosshair.clear(), xi.smallPlop.play()
  });
  const V = mt(() => {
    const ot = [];
    return Dt.hasPermission(Di.tools.selectPixel.ban) && ot.push("ban-user"), Dt.hasPermission(Di.tools.selectPixel.timeout) && ot.push("timeout-user"), !g(F) && Dt.data && ot.push("report-user"), ot
  });

  function Me(ot) {
    const nt = (async () => await kp(s.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    s.onclickmodaction(g(r), nt, s.latLon, ot)
  }
  async function we() {
    try {
      await dn.claimEventPixel(s.christmasTreeId), await ge({
        ...g(ee),
        season: s.season
      }), await dn.getChristmasLocations(), await Dt.refresh()
    } catch (ot) {
      Zt.error(ot.message)
    }
  }
  var Fe = Qxe();
  In("keypress", Os, ot => {
    ot.key === "Escape" && s.onclose()
  });
  var be = M(Fe),
    Xe = M(be),
    tt = M(Xe);
  tt.__click = () => {
    if (g(z) && g(E)) {
      const ot = g(z) - g(E).clientHeight,
        nt = g(z) / 2 - ot / 2;
      s.map.flyTo({
        center: {
          lat: g(ee).center[0],
          lng: g(ee).center[1]
        },
        zoom: 17.5,
        offset: [0, -nt]
      })
    }
  };
  var Ye = M(tt);
  Ap(Ye, {
    class: "fill-primary size-5"
  }), S(tt);
  var Ce = D(tt, 2),
    De = M(Ce),
    Ke = M(De);
  S(De);
  var Le = D(De, 2);
  {
    var Ne = ot => {
        const nt = mt(() => g(r).region),
          Ut = mt(() => Do(g(nt).countryId));
        var Qt = Exe(),
          Ot = Ct(Qt);
        Ot.__click = () => s.onclickregion(g(nt));
        var mr = M(Ot),
          zt = M(mr, !0);
        S(mr);
        var Mt = D(mr, 2),
          kt = M(Mt, !0);
        S(Mt);
        var It = D(Mt, 2),
          Gt = M(It);
        S(It), S(Ot);
        var ht = D(Ot, 2);
        {
          var hr = wr => {
            var ur = Axe(),
              qr = M(ur),
              kr = M(qr);
            _y(kr, {
              class: "h-4 w-4"
            }), S(qr), S(ur), Re(() => er(ur, "href", g(W))), q(wr, ur)
          };
          Te(ht, wr => {
            var ur;
            ((ur = Dt.data) == null ? void 0 : ur.role) !== "user" && Dt.hasPermission(Di.tools.selectPixel.archive) && wr(hr)
          })
        }
        Re(wr => {
          Vr(Ot, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${wr??""}`), er(mr, "data-tip", g(Ut).name), te(zt, g(Ut).flag), te(kt, g(nt).name), te(Gt, `#${g(nt).number??""}`)
        }, [() => na(g(nt).cityId)]), q(ot, Qt)
      },
      vt = ot => {
        var nt = Lxe();
        q(ot, nt)
      };
    Te(Le, ot => {
      var nt;
      (nt = g(r)) != null && nt.region ? ot(Ne) : ot(vt, !1)
    })
  }
  S(Ce), S(Xe);
  var et = D(Xe, 2);
  et.__click = function(...ot) {
    var nt;
    (nt = s.onclose) == null || nt.apply(this, ot)
  };
  var We = M(et);
  Ro(We, {
    class: "size-4"
  }), S(et), S(be);
  var _t = D(be, 2),
    Vt = M(_t);
  {
    var Et = ot => {
        var nt = Dxe();
        q(ot, nt)
      },
      Pt = ot => {
        var nt = Sr(),
          Ut = Ct(nt);
        {
          var Qt = mr => {
              var zt = Oi();
              Re(Mt => te(zt, Mt), [() => kO()]), q(mr, zt)
            },
            Ot = mr => {
              var zt = Sr(),
                Mt = Ct(zt);
              {
                var kt = Gt => {
                    var ht = Rxe(),
                      hr = M(ht),
                      wr = M(hr);
                    S(hr), bn(4), S(ht), Re(ur => te(wr, `${ur??""}:`), [() => ZI()]), q(Gt, ht)
                  },
                  It = Gt => {
                    const ht = mt(() => g(r).paintedBy);
                    var hr = Hxe(),
                      wr = M(hr),
                      ur = M(wr);
                    S(wr);
                    var qr = D(wr, 2),
                      kr = M(qr),
                      Zr = M(kr);
                    Ra(Zr, {
                      class: "size-5 border-0",
                      get userId() {
                        return g(ht).id
                      },
                      get pictureUrl() {
                        return g(ht).picture
                      }
                    }), S(kr);
                    var Wr = D(kr, 2);
                    {
                      var tr = ae => {
                        var Ie = jxe();
                        Re(() => er(Ie, "src", g(ht).equippedFrameUrl)), q(ae, Ie)
                      };
                      Te(Wr, ae => {
                        g(ht).equippedFrameUrl && ae(tr)
                      })
                    }
                    S(qr);
                    var Hr = D(qr, 2),
                      sr = M(Hr),
                      de = M(sr),
                      O = M(de, !0);
                    S(de);
                    var N = D(de, 2),
                      X = M(N);
                    S(N), S(sr);
                    var re = D(sr, 2);
                    {
                      var Q = ae => {
                        const Ie = mt(() => Do(g(ht).equippedFlag));
                        var $e = Fxe(),
                          dt = M($e, !0);
                        S($e), Re(() => {
                          er($e, "data-tip", g(Ie).name), te(dt, g(Ie).flag)
                        }), q(ae, $e)
                      };
                      Te(re, ae => {
                        g(ht).equippedFlag && ae(Q)
                      })
                    }
                    var ue = D(re, 2);
                    {
                      var ke = ae => {
                        Lh(ae, {
                          get username() {
                            return g(ht).discord
                          },
                          get id() {
                            return g(ht).discordId
                          }
                        })
                      };
                      Te(ue, ae => {
                        g(ht).discord && ae(ke)
                      })
                    }
                    var xe = D(ue, 2);
                    {
                      var Ee = ae => {
                        y0(ae, {
                          get role() {
                            return g(ht).role
                          },
                          big: !1
                        })
                      };
                      Te(xe, ae => {
                        g(ht).role && g(ht).role !== "user" && ae(Ee)
                      })
                    }
                    var He = D(xe, 2);
                    {
                      var Be = ae => {
                        var Ie = Oxe(),
                          $e = Ct(Ie),
                          dt = M($e, !0);
                        S($e);
                        var Tt = D($e, 2);
                        {
                          var pt = St => {
                            var qt = Bxe();
                            qt.__click = () => {
                              navigator.clipboard.writeText(g(ht).allianceId.toString()), Zt.success(J_())
                            };
                            var qe = M(qt);
                            K_(qe, {
                              class: "size-3"
                            }), S(qt), Re((bt, Jt) => {
                              Vr(qt, 1, bt), er(qt, "title", Jt)
                            }, [() => qs(na(g(ht).allianceId)), () => F1({
                              allianceId: g(ht).allianceId
                            })]), q(St, qt)
                          };
                          Te(Tt, St => {
                            var qt, qe, bt;
                            (((qt = Dt.data) == null ? void 0 : qt.role) === "admin" || ((qe = Dt.data) == null ? void 0 : qe.role) === "moderator" || ((bt = Dt.data) == null ? void 0 : bt.role) === "global_moderator") && St(pt)
                          })
                        }
                        Re((St, qt) => {
                          Vr($e, 1, `badge badge-sm ml-0.5 border-0 ${St??""} ${qt??""}`), te(dt, g(ht).allianceName)
                        }, [() => Cp(g(ht).allianceId), () => na(g(ht).allianceId)]), q(ae, Ie)
                      };
                      Te(He, ae => {
                        g(ht).allianceId && ae(Be)
                      })
                    }
                    var ie = D(He, 2);
                    {
                      var J = ae => {
                          var Ie = qxe(),
                            $e = M(Ie);
                          yp($e, {
                            class: "text-error size-4"
                          }), S(Ie), Re(dt => er(Ie, "data-tip", dt), [() => X_()]), q(ae, Ie)
                        },
                        Ve = ae => {
                          var Ie = Sr(),
                            $e = Ct(Ie);
                          {
                            var dt = Tt => {
                              var pt = Nxe(),
                                St = M(pt);
                              Yu(St, {
                                class: "text-error size-4"
                              }), S(pt), Re(qt => er(pt, "data-tip", qt), [() => b0()]), q(Tt, pt)
                            };
                            Te($e, Tt => {
                              g(r).paintedBy.timedOut && Tt(dt)
                            }, !0)
                          }
                          q(ae, Ie)
                        };
                      Te(ie, ae => {
                        g(r).paintedBy.banned ? ae(J) : ae(Ve, !1)
                      })
                    }
                    S(Hr);
                    var rt = D(Hr, 2);
                    {
                      var Ue = ae => {
                        var Ie = Wxe(),
                          $e = M(Ie),
                          dt = M($e);
                        um(dt, {
                          class: "size-4"
                        }), S($e);
                        var Tt = D($e, 2);
                        si(Tt, 21, () => g(V), Dc, (pt, St) => {
                          var qt = Sr(),
                            qe = Ct(qt);
                          {
                            var bt = Cr => {
                                var _r = Vxe(),
                                  Qe = M(_r);
                                let rr;
                                Qe.__click = () => {
                                  Me("report-user")
                                };
                                var Kt = M(Qe);
                                F_(Kt, {
                                  class: "size-5"
                                });
                                var Tr = D(Kt);
                                S(Qe), S(_r), Re(Rr => {
                                  rr = Vr(Qe, 1, "py-2 font-medium text-red-300", null, rr, {
                                    "cursor-not-allowed": g(F)
                                  }), te(Tr, ` ${Rr??""}`)
                                }, [() => g1()]), q(Cr, _r)
                              },
                              Jt = Cr => {
                                var _r = Sr(),
                                  Qe = Ct(_r);
                                {
                                  var rr = Tr => {
                                      var Rr = Uxe(),
                                        Qr = M(Rr);
                                      let br;
                                      Qr.__click = () => {
                                        Me("timeout")
                                      };
                                      var Nt = M(Qr);
                                      Yu(Nt, {
                                        class: "size-5"
                                      });
                                      var wt = D(Nt);
                                      S(Qr), S(Rr), Re(Ge => {
                                        br = Vr(Qr, 1, "text-warning font-medium", null, br, {
                                          "cursor-not-allowed": g(F)
                                        }), te(wt, ` ${Ge??""}`)
                                      }, [() => v1()]), q(Tr, Rr)
                                    },
                                    Kt = Tr => {
                                      var Rr = Sr(),
                                        Qr = Ct(Rr);
                                      {
                                        var br = wt => {
                                            var Ge = Zxe(),
                                              xt = M(Ge);
                                            let Wt;
                                            xt.__click = () => {
                                              Me("ban")
                                            };
                                            var At = M(xt);
                                            yp(At, {
                                              class: "size-5"
                                            });
                                            var pr = D(At);
                                            S(xt), S(Ge), Re(ar => {
                                              Wt = Vr(xt, 1, "text-error font-medium", null, Wt, {
                                                "cursor-not-allowed": g(F)
                                              }), te(pr, ` ${ar??""}`)
                                            }, [() => y1()]), q(wt, Ge)
                                          },
                                          Nt = wt => {
                                            var Ge = Sr(),
                                              xt = Ct(Ge);
                                            {
                                              var Wt = At => {
                                                var pr = Gxe(),
                                                  ar = M(pr);
                                                ar.__click = async () => {
                                                  H(l, !0);
                                                  try {
                                                    await dn.banAllianceUser(g(ht).id), await ge({
                                                      ...g(ee),
                                                      season: s.season
                                                    })
                                                  } catch (jr) {
                                                    Zt.error(jr.message)
                                                  } finally {
                                                    H(l, !1)
                                                  }
                                                };
                                                var zr = M(ar);
                                                Mxe(zr, {
                                                  class: "size-5"
                                                });
                                                var Jr = D(zr);
                                                S(ar), S(pr), Re(jr => te(Jr, ` ${jr??""}`), [() => x0()]), q(At, pr)
                                              };
                                              Te(xt, At => {
                                                g(St) === "ban-alliance" && At(Wt)
                                              }, !0)
                                            }
                                            q(wt, Ge)
                                          };
                                        Te(Qr, wt => {
                                          g(St) === "ban-user" ? wt(br) : wt(Nt, !1)
                                        }, !0)
                                      }
                                      q(Tr, Rr)
                                    };
                                  Te(Qe, Tr => {
                                    g(St) === "timeout-user" ? Tr(rr) : Tr(Kt, !1)
                                  }, !0)
                                }
                                q(Cr, _r)
                              };
                            Te(qe, Cr => {
                              g(St) === "report-user" ? Cr(bt) : Cr(Jt, !1)
                            })
                          }
                          q(pt, qt)
                        }), S(Tt), S(Ie), q(ae, Ie)
                      };
                      Te(rt, ae => {
                        g(V).length > 0 && ae(Ue)
                      })
                    }
                    S(hr), Re((ae, Ie) => {
                      var $e;
                      te(ur, `${ae??""}:`), Vr(sr, 1, `font-medium ${Ie??""} flex gap-1.5`), te(O, (($e = Dt.data) == null ? void 0 : $e.id) === g(ht).id ? Dt.data.name : g(ht).name), te(X, `#${g(ht).id??""}`)
                    }, [() => tV(), () => na(g(ht).id)]), q(Gt, hr)
                  };
                Te(Mt, Gt => {
                  g(r).paintedBy.event ? Gt(kt) : Gt(It, !1)
                }, !0)
              }
              q(mr, zt)
            };
          Te(Ut, mr => {
            g(r).paintedBy.id === 0 ? mr(Qt) : mr(Ot, !1)
          }, !0)
        }
        q(ot, nt)
      };
    Te(Vt, ot => {
      g(r) === void 0 ? ot(Et) : ot(Pt, !1)
    })
  }
  S(_t);
  var lt = D(_t, 2),
    $t = M(lt);
  {
    var yt = ot => {
        var nt = $xe();
        nt.__click = () => s.onclickpaint(s.latLon);
        var Ut = M(nt);
        bl(Ut, {
          class: "size-4.5"
        });
        var Qt = D(Ut);
        S(nt), Re(Ot => {
          nt.disabled = Dt.loading, te(Qt, ` ${Ot??""}`)
        }, [() => S0()]), q(ot, nt)
      },
      Rt = ot => {
        var nt = Sr(),
          Ut = Ct(nt);
        {
          var Qt = Ot => {
            var mr = Kxe();
            mr.__click = () => we();
            var zt = M(mr);
            {
              var Mt = It => {
                  var Gt = Xxe(),
                    ht = Ct(Gt);
                  B1(ht, {
                    class: "size-4.5"
                  });
                  var hr = D(ht);
                  Re(wr => te(hr, ` ${wr??""}`), [() => Hk()]), q(It, Gt)
                },
                kt = It => {
                  var Gt = Yxe(),
                    ht = Ct(Gt);
                  fm(ht, {
                    class: "size-4.5"
                  });
                  var hr = D(ht);
                  Re(wr => te(hr, ` ${wr??""}`), [() => Dk()]), q(It, Gt)
                };
              Te(zt, It => {
                g(r).paintedBy.claimed ? It(Mt) : It(kt, !1)
              })
            }
            S(mr), Re(() => mr.disabled = Dt.loading || g(r).paintedBy.claimed), q(Ot, mr)
          };
          Te(Ut, Ot => {
            Dt.data && g(r).paintedBy.eventClaimNumber && Ot(Qt)
          }, !0)
        }
        q(ot, nt)
      };
    Te($t, ot => {
      var nt;
      (nt = g(r)) != null && nt.paintedBy.event ? ot(Rt, !1) : ot(yt)
    })
  }
  var jt = D($t, 2);
  {
    var Xt = ot => {
      const nt = mt(() => Dt.data.favoriteLocations.find(Mt => Math.abs(Mt.latitude - g(ee).center[0]) < 5e-5 && Math.abs(Mt.longitude - g(ee).center[1]) < 5e-5)),
        Ut = mt(() => !g(nt) && Dt.data.favoriteLocations.length >= Dt.data.maxFavoriteLocations);
      var Qt = Jxe();
      let Ot;
      Qt.__click = async () => {
        try {
          H(k, !0), g(nt) ? (await dn.deleteFavoriteLocation(g(nt).id), Zt.warning(rD())) : (await dn.favoriteLocation(g(ee).center), Zt.success(UL())), xi.smallPlop.play(), Dt.refresh()
        } catch (Mt) {
          Zt.error(Mt.message)
        } finally {
          H(k, !1)
        }
      };
      var mr = M(Qt);
      {
        let Mt = mt(() => !!g(nt));
        zxe(mr, {
          class: "size-4.5",
          get filled() {
            return g(Mt)
          }
        })
      }
      var zt = D(mr);
      S(Qt), Re(Mt => {
        Ot = Vr(Qt, 1, "btn btn-primary btn-soft", null, Ot, {
          "text-yellow-400": !!g(nt)
        }), Qt.disabled = g(k) || g(Ut), te(zt, ` ${Mt??""}`)
      }, [() => g(Ut) ? gL() : nC()]), q(ot, Qt)
    };
    Te(jt, ot => {
      Dt.data && ot(Xt)
    })
  }
  var fr = D(jt, 2);
  fr.__click = () => s.onclickshare(ade(vi.url, {
    pos: {
      lat: g(ee).center[0],
      lng: g(ee).center[1]
    },
    zoom: s.zoom
  }));
  var Yt = M(fr);
  J0(Yt, {
    class: "size-4.5"
  });
  var lr = D(Yt);
  S(fr), S(lt), S(Fe), ja(Fe, ot => H(E, ot), () => g(E)), Re(ot => {
    te(Ke, `Pixel: ${g(ee).regionPixel[0]??""}, ${g(ee).regionPixel[1]??""}`), te(lr, ` ${ot??""}`)
  }, [() => LX()]), Ch("innerHeight", ot => H(z, ot, !0)), q(p, Fe), an()
}
Yn(["click"]);

function t1e(p) {
  var x;
  const s = document.createElement("div");
  (x = p.parentElement) == null || x.insertBefore(s, p.nextSibling);
  const r = new IntersectionObserver(z => {
    z[0].isIntersecting ? p.classList.remove("stuck") : p.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return r.observe(s), () => {
    s.remove(), r.disconnect()
  }
}
var O_;
(p => {
  function s() {
    let r, x;
    return {
      promise: new Promise((E, k) => {
        r = E, x = k
      }),
      resolve: r,
      reject: x
    }
  }
  p.withResolvers = s
})(O_ || (O_ = {}));
var r1e = Yr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  n1e = Yr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function i1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Sr(),
    z = Ct(x);
  {
    var E = l => {
        var F = r1e();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      },
      k = l => {
        var F = n1e();
        Dr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...r
        })), q(l, F)
      };
    Te(z, l => {
      s.filled ? l(E) : l(k, !1)
    })
  }
  q(p, x)
}
var a1e = he("<p><!></p>"),
  o1e = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  s1e = he('<span class="text-sm"> </span>'),
  l1e = he(' <span class="text-sm">Droplets</span>', 1),
  c1e = he('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <!></button>'),
  u1e = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  h1e = he('<!> <span class="text-sm"> </span>', 1),
  d1e = he('<span class="text-sm"> </span>'),
  p1e = he('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  f1e = he('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  _1e = he('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function m1e(p, s) {
  nn(s, !0);
  const r = (Ye, Ce = Qa, De = Qa) => {
      const Ke = mt(() => {
          var Yt;
          return (((Yt = Dt.data) == null ? void 0 : Yt.droplets) ?? 0) >= l.price
        }),
        Le = mt(() => g(W) === Ce().id),
        Ne = mt(() => x.has(Ce().id));
      var vt = f1e(),
        et = M(vt),
        We = M(et, !0);
      S(et);
      var _t = D(et, 2),
        Vt = M(_t),
        Et = D(Vt);
      {
        var Pt = Yt => {
          var lr = a1e(),
            ot = M(lr);
          Qu(ot, {
            class: "text-base-content/60 size-4.5 inline pb-0.5"
          }), S(lr), Re(nt => {
            Vr(lr, 1, qs({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": (De() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": De() % 4 === 0,
              "before:-translate-x-1/3": (De() + 1) % 2 === 0,
              "before:translate-x-1/3": De() % 2 === 0
            })), er(lr, "data-tip", nt)
          }, [() => P9()]), q(Yt, lr)
        };
        Te(Et, Yt => {
          g(Ne) && Yt(Pt)
        })
      }
      S(_t);
      var lt = D(_t, 2);
      {
        var $t = Yt => {
          pm(Yt, {})
        };
        Te(lt, Yt => {
          Ce().id === g(ee) && Yt($t)
        })
      }
      var yt = D(lt, 2);
      let Rt;
      var jt = M(yt);
      {
        var Xt = Yt => {
            var lr = c1e();
            lr.__click = async () => {
              if (!(g(Ne) && !await s.promptUserConfirmation(Ce().label))) try {
                const zt = Ce().id;
                H(W, zt, !0), await dn.purchase({
                  id: k,
                  amount: 1,
                  variant: zt
                }), Dt.refresh(), xi.notification1.play();
                const Mt = E.find(kt => kt.id === zt);
                Mt && (Mt.owned = !0), H(ee, zt, !0)
              } catch (zt) {
                Zt.error(zt.message)
              } finally {
                H(W, void 0)
              }
            };
            var ot = M(lr);
            {
              var nt = zt => {
                var Mt = o1e();
                q(zt, Mt)
              };
              Te(ot, zt => {
                g(Le) && zt(nt)
              })
            }
            var Ut = D(ot, 2);
            Ip(Ut, {
              class: "size-4"
            });
            var Qt = D(Ut, 2);
            {
              var Ot = zt => {
                  var Mt = s1e(),
                    kt = M(Mt, !0);
                  S(Mt), Re(It => te(kt, It), [() => ise()]), q(zt, Mt)
                },
                mr = zt => {
                  var Mt = l1e(),
                    kt = Ct(Mt);
                  bn(), Re(It => te(kt, `${It??""} `), [() => l.price.toLocaleString(navigator.language)]), q(zt, Mt)
                };
              Te(Qt, zt => {
                var Mt;
                (Mt = Dt.data) != null && Mt.freeFlag ? zt(Ot) : zt(mr, !1)
              })
            }
            S(lr), Re(() => {
              var zt;
              return lr.disabled = !g(Ke) && ((zt = Dt.data) == null ? void 0 : zt.freeFlag) == !1 || g(Le)
            }), q(Yt, lr)
          },
          fr = Yt => {
            const lr = mt(() => {
              var It;
              return ((It = Dt.data) == null ? void 0 : It.equippedFlag) === Ce().id
            });
            var ot = p1e();
            let nt;
            ot.__click = async () => {
              try {
                H(W, Ce().id, !0);
                const It = g(lr) ? 0 : Ce().id;
                await dn.equipFlag(It), Dt.data && (Dt.data.equippedFlag = It), Dt.refresh()
              } catch (It) {
                Zt.error(It.message)
              } finally {
                H(W, void 0)
              }
            };
            var Ut = M(ot),
              Qt = M(Ut, !0);
            S(Ut);
            var Ot = D(Ut, 2);
            {
              var mr = It => {
                var Gt = u1e();
                q(It, Gt)
              };
              Te(Ot, It => {
                g(Le) && It(mr)
              })
            }
            var zt = D(Ot, 2);
            {
              var Mt = It => {
                  var Gt = h1e(),
                    ht = Ct(Gt);
                  Ro(ht, {
                    class: "size-4"
                  });
                  var hr = D(ht, 2),
                    wr = M(hr, !0);
                  S(hr), Re(ur => te(wr, ur), [() => vI()]), q(It, Gt)
                },
                kt = It => {
                  var Gt = d1e(),
                    ht = M(Gt, !0);
                  S(Gt), Re(hr => te(ht, hr), [() => aI()]), q(It, Gt)
                };
              Te(zt, It => {
                g(lr) ? It(Mt) : It(kt, !1)
              })
            }
            S(ot), Re(It => {
              nt = Vr(ot, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, nt, {
                "btn-warning": g(lr)
              }), ot.disabled = g(Le), te(Qt, It)
            }, [() => b4()]), q(Yt, ot)
          };
        Te(jt, Yt => {
          Ce().owned ? Yt(fr, !1) : Yt(Xt)
        })
      }
      S(yt), S(vt), Re(Yt => {
        var lr;
        te(We, Ce().flag), te(Vt, `${Ce().label??""} `), Rt = Vr(yt, 1, "mt-3", null, Rt, {
          tooltip: !g(Ke) && !Ce().owned && ((lr = Dt.data) == null ? void 0 : lr.freeFlag) == !1
        }), er(yt, "data-tip", Yt)
      }, [() => Lp()]), q(Ye, vt)
    },
    x = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    z = xa.countries.map(Ye => {
      var Ce, De;
      return {
        ...Ye,
        owned: Dt.flagsBitmap.get(Ye.id),
        label: ((De = (Ce = b1)[Ye.code]) == null ? void 0 : De.call(Ce)) ?? Ye.name
      }
    });
  z.sort((Ye, Ce) => Number(Ce.owned) - Number(Ye.owned));
  const E = yi(z),
    k = 110,
    l = xa.products[k];
  let F = Je(!1),
    W = Je(void 0),
    ee = Je(void 0);
  var $ = _1e(),
    se = M($),
    _e = M(se);
  i1e(_e, {
    class: "size-5.5",
    filled: !0
  });
  var ge = D(_e, 2),
    V = M(ge, !0);
  S(ge), S(se);
  var Me = D(se, 2),
    we = M(Me, !0);
  S(Me);
  var Fe = D(Me, 2);
  si(Fe, 23, () => E, Ye => Ye.id, (Ye, Ce, De) => {
    var Ke = Sr(),
      Le = Ct(Ke);
    {
      var Ne = vt => {
        r(vt, () => g(Ce), () => g(De))
      };
      Te(Le, vt => {
        (g(De) < 8 || g(F)) && vt(Ne)
      })
    }
    q(Ye, Ke)
  }), S(Fe);
  var be = D(Fe, 2),
    Xe = M(be);
  Xe.__click = () => {
    H(F, !g(F))
  };
  var tt = M(Xe, !0);
  S(Xe), S(be), S($), Re((Ye, Ce, De) => {
    te(V, Ye), te(we, Ce), te(tt, De)
  }, [() => Goe(), () => $M(), () => g(F) ? yoe() : Eoe()]), q(p, $), an()
}
Yn(["click"]);
var g1e = he('<p class="mt-1 text-center text-sm"> </p>'),
  v1e = he('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  y1e = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  b1e = he('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function e0(p, s) {
  nn(s, !0);
  let r = nr(s, "amount", 15, 1);
  const x = mt(() => r() * s.unitPrice),
    z = mt(() => Math.floor(s.userDroplets / s.unitPrice));
  let E = Je(!1);
  cn(() => {
    r() < 0 && r(0)
  });
  var k = b1e(),
    l = M(k),
    F = M(l);
  qi(F, () => s.icon ?? Qa), S(l);
  var W = D(l, 2),
    ee = M(W, !0);
  S(W);
  var $ = D(W, 2);
  {
    var se = Le => {
      var Ne = g1e(),
        vt = M(Ne, !0);
      S(Ne), Re(() => te(vt, s.subtitle)), q(Le, Ne)
    };
    Te($, Le => {
      s.subtitle && Le(se)
    })
  }
  var _e = D($, 2),
    ge = M(_e);
  ge.__click = () => {
    uv(r, -1)
  };
  var V = D(ge, 2);
  Ki(V);
  var Me = D(V, 2);
  Me.__click = () => {
    uv(r)
  };
  var we = D(Me, 2);
  {
    var Fe = Le => {
      var Ne = v1e();
      Ne.__click = () => {
        r(g(z))
      }, q(Le, Ne)
    };
    Te(we, Le => {
      r() < g(z) && Le(Fe)
    })
  }
  S(_e);
  var be = D(_e, 2);
  let Xe;
  var tt = M(be);
  tt.__click = async () => {
    try {
      H(E, !0), await dn.purchase({
        id: s.productId,
        amount: r()
      }), xi.notification1.play(), s.onpurchasecompleted(r())
    } catch (Le) {
      Zt.error(Le.message)
    } finally {
      H(E, !1)
    }
  };
  var Ye = M(tt);
  {
    var Ce = Le => {
      var Ne = y1e();
      q(Le, Ne)
    };
    Te(Ye, Le => {
      g(E) && Le(Ce)
    })
  }
  var De = D(Ye, 2);
  Ip(De, {
    class: "size-4"
  });
  var Ke = D(De);
  bn(), S(tt), S(be), S(k), Re((Le, Ne, vt) => {
    te(ee, Le), Me.disabled = r() >= g(z), er(be, "data-tip", Ne), Xe = Vr(be, 1, "", null, Xe, {
      tooltip: s.userDroplets < g(x)
    }), tt.disabled = s.userDroplets < g(x) || g(E) || !r(), te(Ke, ` ${vt??""} `)
  }, [() => s.title(r()), () => Lp(), () => g(x).toLocaleString(navigator.language)]), yl(V, r), q(p, k), an()
}
Yn(["click"]);
var x1e = Yr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function w1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = x1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var k1e = Yr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function ky(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = k1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var T1e = Yr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function S1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = T1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var P1e = Yr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function M1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = P1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var I1e = he('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">âœ•</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  C1e = he('<span class="center-absolute absolute"><!></span>'),
  z1e = he('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function A1e(p, s) {
  nn(s, !0);
  let r = nr(s, "open", 15),
    x = Je(null),
    z = Je(yi({
      name: dv(),
      prev: 1e3,
      new: 1e5
    }));
  const E = {
      id: 70,
      product: xa.products[70]
    },
    k = {
      id: 80,
      product: xa.products[80]
    },
    l = {
      product: xa.products[120]
    };
  let F = Je(null),
    W = Je(null),
    ee = Je("");
  async function $(ht) {
    return g(F).showModal(), H(W, O_.withResolvers(), !0), H(ee, ht, !0), g(W).promise
  }
  var se = z1e(),
    _e = Ct(se),
    ge = M(_e),
    V = M(ge);
  {
    var Me = ht => {
      var hr = I1e(),
        wr = M(hr),
        ur = M(wr),
        qr = M(ur);
      ky(qr, {
        class: "size-8"
      });
      var kr = D(qr, 2),
        Zr = M(kr, !0);
      S(kr);
      var Wr = D(kr, 2),
        tr = M(Wr);
      {
        let Kt = mt(() => {
          var Tr;
          return ((Tr = Dt.data) == null ? void 0 : Tr.droplets) ?? 0
        });
        o0(tr, {
          get value() {
            return g(Kt)
          }
        })
      }
      S(Wr), bn(2), S(ur), S(wr), Ji(wr, () => t1e);
      var Hr = D(wr, 2),
        sr = M(Hr),
        de = M(sr),
        O = M(de);
      w1e(O, {
        class: "size-5.5",
        filled: !0
      });
      var N = D(O, 2),
        X = M(N, !0);
      S(N), S(de);
      var re = D(de, 2),
        Q = M(re, !0);
      S(re);
      var ue = D(re, 2),
        ke = M(ue);
      {
        const Kt = Rr => {
          M1e(Rr, {
            class: "text-primary size-26"
          })
        };
        let Tr = mt(() => lE());
        e0(ke, {
          get productId() {
            return E.id
          },
          title: Rr => Vw({
            amount: E.product.items[0].amount * Rr
          }),
          get subtitle() {
            return g(Tr)
          },
          get unitPrice() {
            return E.product.price
          },
          get userDroplets() {
            return Dt.data.droplets
          },
          onpurchasecompleted: async Rr => {
            var Nt, wt, Ge, xt;
            const Qr = (wt = (Nt = Dt.data) == null ? void 0 : Nt.charges) == null ? void 0 : wt.max;
            await Dt.refresh();
            const br = (xt = (Ge = Dt.data) == null ? void 0 : Ge.charges) == null ? void 0 : xt.max;
            Qr !== void 0 && br !== void 0 && (H(z, {
              name: dv(),
              prev: Qr,
              new: br
            }, !0), g(x).show())
          },
          icon: Kt,
          $$slots: {
            icon: !0
          }
        })
      }
      var xe = D(ke, 2);
      {
        const Kt = Rr => {
          yy(Rr, {
            class: "text-primary my-3 size-20"
          })
        };
        let Tr = mt(() => AG());
        e0(xe, {
          get productId() {
            return k.id
          },
          title: Rr => t5({
            amount: k.product.items[0].amount * Rr
          }),
          get subtitle() {
            return g(Tr)
          },
          get unitPrice() {
            return k.product.price
          },
          get userDroplets() {
            return Dt.data.droplets
          },
          onpurchasecompleted: async Rr => {
            var br, Nt, wt;
            const Qr = (Nt = (br = Dt.data) == null ? void 0 : br.charges) == null ? void 0 : Nt.count;
            await Dt.refresh(), Qr !== void 0 && (H(z, {
              name: x1(),
              prev: Math.floor(Qr),
              new: Math.floor(Qr + k.product.items[0].amount * Rr)
            }, !0), (wt = g(x)) == null || wt.show())
          },
          icon: Kt,
          $$slots: {
            icon: !0
          }
        })
      }
      S(ue), S(sr);
      var Ee = D(sr, 2),
        He = M(Ee),
        Be = M(He);
      Rp(Be, {
        class: "size-5.5",
        filled: !0
      });
      var ie = D(Be, 2),
        J = M(ie, !0);
      S(ie), S(He);
      var Ve = D(He, 2),
        rt = M(Ve),
        Ue = M(rt),
        ae = M(Ue),
        Ie = M(ae),
        $e = M(Ie);
      s0($e, {
        get userId() {
          return Dt.data.id
        },
        get level() {
          return Dt.data.level
        },
        get pictureUrl() {
          return Dt.data.picture
        }
      }), S(Ie), S(ae), S(Ue);
      var dt = D(Ue, 2),
        Tt = M(dt, !0);
      S(dt);
      var pt = D(dt, 2),
        St = M(pt, !0);
      S(pt);
      var qt = D(pt, 2);
      let qe;
      var bt = M(qt),
        Jt = M(bt),
        Cr = M(Jt);
      Ip(Cr, {
        class: "size-4"
      });
      var _r = D(Cr);
      bn(), S(Jt), S(bt), S(qt), S(rt), S(Ve), S(Ee);
      var Qe = D(Ee, 2),
        rr = M(Qe);
      m1e(rr, {
        promptUserConfirmation: $
      }), S(Qe), S(Hr), S(hr), Re((Kt, Tr, Rr, Qr, br, Nt, wt, Ge) => {
        te(Zr, Kt), te(X, Tr), te(Q, Rr), te(J, Qr), te(Tt, br), te(St, Nt), er(qt, "data-tip", wt), qe = Vr(qt, 1, "", null, qe, {
          tooltip: Dt.data.droplets < l.product.price
        }), Jt.disabled = Dt.data.droplets < l.product.price, te(_r, ` ${Ge??""} `)
      }, [() => I0(), () => E8(), () => M6(), () => LZ(), () => w1(), () => nw(), () => Lp(), () => l.product.price.toLocaleString(navigator.language)]), fa(2, hr, () => Ja), q(ht, hr)
    };
    Te(V, ht => {
      Dt.data && r() && ht(Me)
    })
  }
  S(ge);
  var we = D(ge, 2),
    Fe = M(we),
    be = M(Fe, !0);
  S(Fe), S(we), S(_e), Ji(_e, () => ht => {
    cn(() => {
      r() ? ht.show() : ht.close()
    })
  });
  var Xe = D(_e, 2),
    tt = M(Xe),
    Ye = M(tt),
    Ce = M(Ye),
    De = M(Ce, !0);
  S(Ce);
  var Ke = D(Ce, 2),
    Le = M(Ke),
    Ne = M(Le),
    vt = D(Ne),
    et = M(vt);
  S(vt), S(Le);
  var We = D(Le, 2),
    _t = M(We);
  S1e(_t, {
    class: "size-5"
  }), S(We);
  var Vt = D(We, 2),
    Et = M(Vt, !0);
  S(Vt), S(Ke);
  var Pt = D(Ke, 2),
    lt = M(Pt),
    $t = M(lt),
    yt = D($t);
  Ec(yt, () => g(z).new, ht => {
    var hr = C1e(),
      wr = M(hr);
    pm(wr, {}), S(hr), q(ht, hr)
  }), S(lt), S(Pt), S(Ye), S(tt);
  var Rt = D(tt, 2),
    jt = M(Rt),
    Xt = M(jt, !0);
  S(jt), S(Rt), S(Xe), ja(Xe, ht => H(x, ht), () => g(x));
  var fr = D(Xe, 2),
    Yt = M(fr),
    lr = M(Yt),
    ot = M(lr, !0);
  S(lr);
  var nt = D(lr, 2),
    Ut = M(nt);
  zp(Ut, () => mC({
    country: g(ee)
  })), S(nt);
  var Qt = D(nt, 2),
    Ot = M(Qt);
  Ot.__click = () => {
    var ht;
    (ht = g(W)) == null || ht.resolve(!1), g(F).close()
  };
  var mr = M(Ot, !0);
  S(Ot);
  var zt = D(Ot, 2);
  zt.__click = () => {
    var ht;
    (ht = g(W)) == null || ht.resolve(!0), g(F).close()
  };
  var Mt = M(zt, !0);
  S(zt), S(Qt), S(Yt);
  var kt = D(Yt, 2),
    It = M(kt),
    Gt = M(It, !0);
  S(It), S(kt), S(fr), ja(fr, ht => H(F, ht), () => g(F)), Re((ht, hr, wr, ur, qr, kr, Zr) => {
    te(be, ht), te(De, g(z).name), te(Ne, `${g(z).prev??""} `), te(et, `(+${g(z).new-g(z).prev})`), te(Et, g(z).new), te($t, `${hr??""} `), te(Xt, wr), te(ot, ur), te(mr, qr), te(Mt, kr), te(Gt, Zr)
  }, [() => hs(), () => hs(), () => hs(), () => CC(), () => jc(), () => v0(), () => hs()]), In("close", _e, () => r(!1)), q(p, se), an()
}
Yn(["click"]);
var E1e = Yr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function L1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = E1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var D1e = Yr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function R1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = D1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var j1e = Yr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function F1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = j1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var B1e = Yr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function O1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = B1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var q1e = Yr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function N1e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = q1e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...r
  })), q(p, x)
}

function V1e(p, s, r) {
  return p < s ? s : p > r ? r : p
}

function U1e(p, s) {
  const r = 10 ** s;
  return Math.round(p * r) / r
}
var Z1e = he('<div class="badge badge-error badge-sm"> </div>'),
  G1e = he('<span class="loading loading-spinner loading-sm"></span>'),
  W1e = he('<div class="bg-base-100/80 absolute inset-0 flex items-center justify-center"><span class="loading loading-spinner loading-lg"></span></div>'),
  H1e = he('<div class="bg-base-200 absolute left-4 top-4 rounded-lg p-3 shadow-lg"><div class="text-sm font-semibold">Pixel Info</div> <div class="mt-2 space-y-1 text-xs"><div> </div> <div>User ID: <span class="badge badge-sm"> </span></div> <div> </div></div></div>'),
  $1e = he('<canvas class="absolute inset-0 cursor-crosshair"></canvas> <!>', 1),
  X1e = he('<span class="badge badge-outline badge-sm"> </span>'),
  Y1e = he('<div><button><div class="flex items-center justify-between"><div class="flex items-center gap-2"><input type="checkbox" class="checkbox checkbox-sm pointer-events-auto"/> <span class="badge badge-sm"> </span> <!></div> <span class="text-xs"> </span></div> <div class="text-base-content/60 mt-1 text-xs"> </div></button></div>'),
  K1e = he('<span class="loading loading-spinner loading-xs"></span>'),
  J1e = he('<div class="border-base-300 border-t p-2"><button class="btn btn-outline btn-block btn-sm"><!> Load 100 Older Events</button></div>'),
  Q1e = he('<div class="fixed inset-0 z-50 flex flex-col"><div class="border-base-300 bg-base-100/95 pointer-events-auto flex items-center justify-between border-b p-3 backdrop-blur-sm"><div class="flex items-center gap-4"><h2 class="text-lg font-bold">Wayback Video Mode</h2> <div class="flex gap-4 text-sm"><div class="badge badge-sm"> </div> <div class="badge badge-sm"> </div> <div class="badge badge-sm"> </div> <!></div></div> <div class="flex items-center gap-2"><button class="btn btn-success btn-sm"><!> Reconstruct</button> <button class="btn btn-circle btn-sm"><!></button></div></div> <div class="flex flex-1 overflow-hidden"><div class="relative flex-1"><!></div> <div class="bg-base-200/95 border-base-300 pointer-events-auto flex w-80 flex-col border-l backdrop-blur-sm"><div class="border-base-300 border-b p-3"><h3 class="font-semibold">Events History</h3> <p class="text-base-content/60 text-xs">Click to exclude/include</p></div> <div class="flex-1 overflow-y-auto p-2"><div class="space-y-1"></div></div> <!></div></div> <div class="border-base-300 bg-base-200/95 border-t p-3"><div class="flex items-center gap-4"><div class="font-mono text-xs"> </div> <input type="range" class="range range-primary flex-1"/> <div class="font-mono text-xs"> </div></div> <div class="text-primary mt-2 text-center font-mono text-sm font-bold"> </div></div></div>');

function e2e(p, s) {
  nn(s, !0);
  let r = Je(!1),
    x = Je(!1),
    z = Je(yi([])),
    E = Je(!1);
  const k = Date.now();
  let l = Je(yi(k)),
    F = Je(yi(k)),
    W = Je(yi(k)),
    ee = Je(!0),
    $ = 100,
    se = Je(void 0),
    _e = null,
    ge = Je(yi(new Map)),
    V = Je(null),
    Me = Je(null),
    we = Je(void 0);
  const Fe = new Aa(s.tileSize);
  let be = mt(() => g(z).filter(Q => Q.ts <= g(W) && Q.selected)),
    Xe = mt(() => g(be).reduce((Q, ue) => Q + ue.pixelsCount, 0)),
    tt = mt(() => new Set(g(be).map(Q => Q.userId)).size),
    Ye = mt(() => g(z).filter(Q => !Q.selected).length);
  cn(() => {
    g(se) && (_e = g(se).getContext("2d", {
      willReadFrequently: !0
    }), _e && (_e.imageSmoothingEnabled = !1))
  });
  async function Ce() {
    H(r, !0);
    try {
      const Q = s.map.getBounds(),
        ue = new URLSearchParams({
          to_ts: k.toString(),
          min_lat: Q.getSouth().toString(),
          max_lat: Q.getNorth().toString(),
          min_lon: Q.getWest().toString(),
          max_lon: Q.getEast().toString(),
          limit: $.toString()
        }),
        ke = await dn.getWaybackVideo(s.season, ue.toString());
      if (!ke.ok) throw new Error("Failed to load events");
      const Ee = ((await ke.json()).events ?? []).map(He => ({
        ...He,
        selected: !0
      }));
      H(z, Ee, !0), Ee.length > 0 && (H(l, Ee[0].ts, !0), H(F, Ee[Ee.length - 1].ts, !0), H(W, g(F), !0)), H(ee, Ee.length === $), setTimeout(() => Ke(), 0), Zt.success(`Carregados ${Ee.length} eventos mais recentes`)
    } catch (Q) {
      Zt.error(Q.message)
    } finally {
      H(r, !1)
    }
  }
  async function De() {
    if (!(g(x) || !g(ee))) {
      H(x, !0);
      try {
        const Q = s.map.getBounds(),
          ue = new URLSearchParams({
            from_ts: (g(l) - 10080 * 60 * 1e3).toString(),
            to_ts: g(l).toString(),
            min_lat: Q.getSouth().toString(),
            max_lat: Q.getNorth().toString(),
            min_lon: Q.getWest().toString(),
            max_lon: Q.getEast().toString(),
            limit: $.toString()
          }),
          ke = await dn.getWaybackVideo(s.season, ue.toString());
        if (!ke.ok) throw new Error("Failed to load more events");
        const Ee = ((await ke.json()).events ?? []).map(He => ({
          ...He,
          selected: !0
        }));
        if (Ee.length === 0) {
          H(ee, !1), Zt.info("No more events");
          return
        }
        H(z, [...Ee, ...g(z)], !0), H(l, Ee[0].ts, !0), H(ee, Ee.length === $), setTimeout(() => Ke(), 0), Zt.success(`Loaded +${Ee.length} older events`)
      } catch (Q) {
        Zt.error(Q.message)
      } finally {
        H(x, !1)
      }
    }
  }

  function Ke() {
    var xe, Ee, He;
    if (console.log("rebuildCanvas called", {
        hasCtx: !!_e,
        hasCanvas: !!g(se),
        visibleEventsCount: g(be).length,
        canvasWidth: (xe = g(se)) == null ? void 0 : xe.width,
        canvasHeight: (Ee = g(se)) == null ? void 0 : Ee.height
      }), !_e || !g(se)) {
      console.log("No ctx or canvas");
      return
    }
    if (!_e || !g(se)) return;
    _e.clearRect(0, 0, g(se).width, g(se).height), g(ge).clear();
    const Q = s.map.getBounds(),
      ue = s.map.project([Q.getWest(), Q.getNorth()]),
      ke = s.map.project([Q.getEast(), Q.getSouth()]);
    for (let Be = 0; Be < g(be).length; Be++) {
      const ie = g(be)[Be];
      for (let J = 0; J < ie.pixelsX.length; J++) {
        const Ve = ie.pixelsX[J],
          rt = ie.pixelsY[J],
          Ue = ie.colors[J],
          ae = ie.tileX * s.tileSize + Ve,
          Ie = ie.tileY * s.tileSize + rt,
          $e = Fe.pixelsToLatLon(ae + .5, Ie + .5, s.pixelArtZoom),
          dt = s.map.project([$e[1], $e[0]]);
        if (dt.x >= ue.x && dt.x <= ke.x && dt.y >= ue.y && dt.y <= ke.y) {
          const Tt = `${ie.tileX},${ie.tileY},${Ve},${rt}`;
          g(ge).set(Tt, {
            color: Ue,
            userId: ie.userId,
            ts: ie.ts,
            eventIndex: Be
          });
          const pt = xa.colors[Ue];
          if (pt) {
            const [St, qt, qe] = pt.rgb;
            _e.fillStyle = `rgb(${St}, ${qt}, ${qe})`;
            const bt = ae + 1,
              Jt = Ie + 1,
              Cr = Fe.pixelsToLatLon(bt + .5, Jt + .5, s.pixelArtZoom),
              _r = s.map.project([Cr[1], Cr[0]]),
              Qe = Math.max(1, Math.abs(_r.x - dt.x)),
              rr = Math.max(1, Math.abs(_r.y - dt.y));
            _e.fillRect(Math.floor(dt.x), Math.floor(dt.y), Math.ceil(Qe), Math.ceil(rr)), g(Me) !== null && ((He = g(z)[g(Me)]) == null ? void 0 : He.userId) === ie.userId && (_e.strokeStyle = "rgba(255, 255, 0, 0.8)", _e.lineWidth = 2, _e.strokeRect(Math.floor(dt.x) - 1, Math.floor(dt.y) - 1, Math.ceil(Qe) + 2, Math.ceil(rr) + 2))
          }
        }
      }
    }
    H(ge, new Map(g(ge)), !0)
  }

  function Le(Q) {
    if (!g(se)) return;
    const ue = g(se).getBoundingClientRect(),
      ke = Q.clientX - ue.left,
      xe = Q.clientY - ue.top,
      Ee = s.map.unproject([ke + ue.left, xe + ue.top]),
      He = Fe.latLonToPixels(Ee.lat, Ee.lng, s.pixelArtZoom),
      Be = Math.floor(He[0]),
      ie = Math.floor(He[1]),
      J = Math.floor(Be / s.tileSize),
      Ve = Math.floor(ie / s.tileSize),
      rt = Be % s.tileSize,
      Ue = ie % s.tileSize,
      ae = `${J},${Ve},${rt},${Ue}`,
      Ie = g(ge).get(ae);
    if (Ie) {
      H(V, {
        x: Be,
        y: ie,
        userId: Ie.userId,
        ts: Ie.ts
      }, !0);
      const $e = g(z).findIndex(dt => dt.ts === Ie.ts && dt.userId === Ie.userId);
      $e !== -1 && (H(Me, $e, !0), et($e), setTimeout(() => Ke(), 0))
    } else H(V, null), H(Me, null), setTimeout(() => Ke(), 0)
  }

  function Ne(Q) {
    g(z)[Q].selected = !g(z)[Q].selected, H(z, [...g(z)], !0), setTimeout(() => Ke(), 0)
  }

  function vt(Q, ue) {
    H(Me, Q, !0), H(V, {
      x: ue.tileX * s.tileSize + (ue.pixelsX[0] ?? 0),
      y: ue.tileY * s.tileSize + (ue.pixelsY[0] ?? 0),
      userId: ue.userId,
      ts: ue.ts
    }, !0), setTimeout(() => Ke(), 0)
  }

  function et(Q) {
    if (!g(we)) return;
    const ue = g(we).querySelector(`[data-event-index="${Q}"]`);
    ue && ue.scrollIntoView({
      behavior: "smooth",
      block: "center"
    })
  }
  async function We() {
    if (g(be).length === 0) {
      Zt.error("No events to reconstruct");
      return
    }
    H(E, !0);
    try {
      const Q = new Map;
      for (const ke of g(be)) {
        const xe = `${ke.tileX},${ke.tileY}`;
        Q.has(xe) || Q.set(xe, []), Q.get(xe).push(ke)
      }
      let ue = 0;
      for (const [ke, xe] of Q) {
        const [Ee, He] = ke.split(",").map(Number), Be = new Map;
        for (const rt of xe)
          for (let Ue = 0; Ue < rt.pixelsX.length; Ue++) {
            const ae = `${rt.pixelsX[Ue]},${rt.pixelsY[Ue]}`;
            Be.set(ae, {
              x: rt.pixelsX[Ue],
              y: rt.pixelsY[Ue],
              color: rt.colors[Ue],
              userId: rt.userId
            })
          }
        const ie = Array.from(Be.values()),
          J = {
            events: [{
              tileX: Ee,
              tileY: He,
              pixelsX: ie.map(rt => rt.x),
              pixelsY: ie.map(rt => rt.y),
              colors: ie.map(rt => rt.color),
              userIds: ie.map(rt => rt.userId)
            }]
          };
        if (!(await dn.postWaybackReconstruct(s.season, J)).ok) throw new Error(`Failed to reconstruct tile ${ke}`);
        ue += ie.length
      }
      s.refreshPixelArt(), Zt.success(`Reconstructed ${ue} pixels from ${g(be).length} events`)
    } catch (Q) {
      Zt.error(Q.message)
    } finally {
      H(E, !1)
    }
  }

  function _t(Q) {
    return new Date(Q).toLocaleString(navigator.language)
  }

  function Vt(Q) {
    return new Date(Q).toLocaleTimeString(navigator.language)
  }
  cn(() => {
    if (s.map && g(z).length > 0) {
      const Q = () => setTimeout(() => Ke(), 0);
      return s.map.on("move", Q), s.map.on("zoom", Q), () => {
        s.map.off("move", Q), s.map.off("zoom", Q)
      }
    }
  }), cn(() => {
    g(W) !== void 0 && setTimeout(() => Ke(), 0)
  }), Yi(() => {
    setTimeout(() => Ce(), 100)
  });
  var Et = Q1e(),
    Pt = M(Et),
    lt = M(Pt),
    $t = D(M(lt), 2),
    yt = M($t),
    Rt = M(yt);
  S(yt);
  var jt = D(yt, 2),
    Xt = M(jt);
  S(jt);
  var fr = D(jt, 2),
    Yt = M(fr);
  S(fr);
  var lr = D(fr, 2);
  {
    var ot = Q => {
      var ue = Z1e(),
        ke = M(ue);
      S(ue), Re(() => te(ke, `${g(Ye)??""} excluded`)), q(Q, ue)
    };
    Te(lr, Q => {
      g(Ye) > 0 && Q(ot)
    })
  }
  S($t), S(lt);
  var nt = D(lt, 2),
    Ut = M(nt);
  Ut.__click = We;
  var Qt = M(Ut);
  {
    var Ot = Q => {
        var ue = G1e();
        q(Q, ue)
      },
      mr = Q => {
        fm(Q, {
          class: "size-4"
        })
      };
    Te(Qt, Q => {
      g(E) ? Q(Ot) : Q(mr, !1)
    })
  }
  bn(), S(Ut);
  var zt = D(Ut, 2);
  zt.__click = function(...Q) {
    var ue;
    (ue = s.onclose) == null || ue.apply(this, Q)
  };
  var Mt = M(zt);
  Ro(Mt, {
    class: "size-4"
  }), S(zt), S(nt), S(Pt);
  var kt = D(Pt, 2),
    It = M(kt),
    Gt = M(It);
  {
    var ht = Q => {
        var ue = W1e();
        q(Q, ue)
      },
      hr = Q => {
        var ue = $1e(),
          ke = Ct(ue);
        er(ke, "width", window.innerWidth), er(ke, "height", window.innerHeight - 150), ke.__click = Le, ja(ke, He => H(se, He), () => g(se));
        var xe = D(ke, 2);
        {
          var Ee = He => {
            var Be = H1e(),
              ie = D(M(Be), 2),
              J = M(ie),
              Ve = M(J);
            S(J);
            var rt = D(J, 2),
              Ue = D(M(rt)),
              ae = M(Ue, !0);
            S(Ue), S(rt);
            var Ie = D(rt, 2),
              $e = M(Ie);
            S(Ie), S(ie), S(Be), Re(dt => {
              te(Ve, `Position: (${g(V).x??""}, ${g(V).y??""})`), te(ae, g(V).userId), te($e, `Time: ${dt??""}`)
            }, [() => Vt(g(V).ts)]), q(He, Be)
          };
          Te(xe, He => {
            g(V) && He(Ee)
          })
        }
        q(Q, ue)
      };
    Te(Gt, Q => {
      g(r) ? Q(ht) : Q(hr, !1)
    })
  }
  S(It);
  var wr = D(It, 2),
    ur = D(M(wr), 2),
    qr = M(ur);
  si(qr, 21, () => g(z), Dc, (Q, ue, ke) => {
    const xe = mt(() => g(ue).ts <= g(W)),
      Ee = mt(() => g(ue).selected),
      He = mt(() => g(Me) === ke);
    var Be = Y1e();
    er(Be, "data-event-index", ke);
    var ie = M(Be);
    let J;
    ie.__click = qe => {
      const bt = qe.target;
      bt.tagName === "INPUT" || bt.closest("input") ? Ne(ke) : vt(ke, g(ue))
    };
    var Ve = M(ie),
      rt = M(Ve),
      Ue = M(rt);
    Ki(Ue), Ue.__click = qe => {
      qe.stopPropagation(), Ne(ke)
    };
    var ae = D(Ue, 2),
      Ie = M(ae, !0);
    S(ae);
    var $e = D(ae, 2);
    {
      var dt = qe => {
        var bt = X1e(),
          Jt = M(bt, !0);
        S(bt), Re(() => te(Jt, g(ue).allianceId)), q(qe, bt)
      };
      Te($e, qe => {
        g(ue).allianceId > 0 && qe(dt)
      })
    }
    S(rt);
    var Tt = D(rt, 2),
      pt = M(Tt);
    S(Tt), S(Ve);
    var St = D(Ve, 2),
      qt = M(St);
    S(St), S(ie), S(Be), Re(qe => {
      Vr(Be, 1, "relative rounded transition-all" + (g(He) ? " ring-primary bg-primary/10 ring-2" : "")), J = Vr(ie, 1, "hover:bg-base-300 w-full rounded p-2 text-left transition-colors", null, J, {
        "opacity-30": !g(xe),
        "bg-base-300": !g(Ee) && !g(He),
        "line-through": !g(Ee)
      }), ie.disabled = !g(xe), t_(Ue, g(Ee)), Ue.disabled = !g(xe), te(Ie, g(ue).userId), te(pt, `${g(ue).pixelsCount??""}px`), te(qt, `${qe??""} â€¢ Tile (${g(ue).tileX??""}, ${g(ue).tileY??""})`)
    }, [() => Vt(g(ue).ts)]), q(Q, Be)
  }), S(qr), S(ur), ja(ur, Q => H(we, Q), () => g(we));
  var kr = D(ur, 2);
  {
    var Zr = Q => {
      var ue = J1e(),
        ke = M(ue);
      ke.__click = De;
      var xe = M(ke);
      {
        var Ee = He => {
          var Be = K1e();
          q(He, Be)
        };
        Te(xe, He => {
          g(x) && He(Ee)
        })
      }
      bn(), S(ke), S(ue), Re(() => ke.disabled = g(x)), q(Q, ue)
    };
    Te(kr, Q => {
      g(ee) && Q(Zr)
    })
  }
  S(wr), S(kt);
  var Wr = D(kt, 2),
    tr = M(Wr),
    Hr = M(tr),
    sr = M(Hr, !0);
  S(Hr);
  var de = D(Hr, 2);
  Ki(de), er(de, "step", 1e3);
  var O = D(de, 2),
    N = M(O, !0);
  S(O), S(tr);
  var X = D(tr, 2),
    re = M(X, !0);
  S(X), S(Wr), S(Et), Re((Q, ue, ke) => {
    te(Rt, `${g(be).length??""} events`), te(Xt, `${g(Xe)??""} pixels`), te(Yt, `${g(tt)??""} users`), Ut.disabled = g(E) || g(be).length === 0 || g(Ye) === 0, te(sr, Q), er(de, "min", g(l)), er(de, "max", g(F)), te(N, ue), te(re, ke)
  }, [() => _t(g(l)), () => _t(g(F)), () => _t(g(W))]), yl(de, () => g(W), Q => H(W, Q)), fa(3, Et, () => Ja), q(p, Et), an()
}
Yn(["click"]);
var t2e = Yr('<svg><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"></path></svg>');

function r2e(p, s) {
  let r = Er(s, ["$$slots", "$$events", "$$legacy"]);
  var x = t2e();
  Dr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    ...r
  })), q(p, x)
}
var n2e = he('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  i2e = he("<button><!></button>"),
  a2e = he('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'),
  o2e = he('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'),
  s2e = he('<button class="btn btn-primary shadow-xl"> </button>'),
  l2e = he('<div class="absolute top-0 -left-2 -translate-x-full translate-y-1/2 select-none"><!></div>'),
  c2e = he('<div class="relative"><!> <!></div>'),
  u2e = he('<button class="btn btn-square shadow-md"><!></button> <button class="btn btn-square relative shadow-md"><!></button>', 1),
  h2e = he('<button title="Auto painter" class="btn btn-square shadow-md"><!></button>'),
  d2e = he('<button title="Video Wayback" class="btn btn-square shadow-md"><!></button>'),
  p2e = he('<div class="flex flex-col items-center gap-3"><!> <button class="btn btn-square relative shadow-md"><!></button> <button class="btn btn-square shadow-md"><!></button> <!> <!></div>'),
  f2e = he('<div class="flex flex-col gap-3"><button><!></button></div>'),
  _2e = he('<button class="btn btn-sm btn-circle"><!></button>'),
  m2e = he('<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'),
  g2e = he('<button class="btn btn-sm btn-circle"><!></button>'),
  v2e = he('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
  y2e = he('<div class="btn btn-sm btn-error w-max cursor-auto text-xs text-nowrap sm:text-base"><!> </div>'),
  b2e = he('<button class="btn sm:btn-lg duration text-xs text-nowrap transition-opacity sm:text-base"><!> </button>'),
  x2e = he("<span></span>"),
  w2e = he('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'),
  k2e = he('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'),
  T2e = he('<div class="pointer-events-none absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-lg sm:-translate-x-1/2 md:max-w-xl"><!></div>'),
  S2e = he('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pt-1 pb-2"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'),
  P2e = he('<div class="disable-pinch-zoom relative h-full overflow-hidden"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function Lwe(p, s) {
  nn(s, !0);
  let r = Je(!1);
  const x = Yd,
    z = Kx,
    E = new Aa(z),
    k = x - .4,
    l = ide(vi.url),
    F = l.season ?? cv;
  let W = Je(0);
  const ee = new Map;
  let $ = Je(void 0),
    se = Je(14.5),
    _e = Je(!1);
  const ge = mt(() => {
    var ft;
    return ((ft = Dt.data) == null ? void 0 : ft.id) === 401
  });
  let V = Je(!1),
    Me = Je("select-pixel"),
    we = Je(yi(l.select && l.pos ? {
      name: "pixelSelected",
      latLon: [l.pos.lat, l.pos.lng]
    } : {
      name: "mainMenu"
    }));
  Yi(() => {
    tt().then(Lr => H($, Lr)).catch(Lr => {
      Zt.error(bX(), {
        duration: 5e3
      }), console.error("Error setting up map:", Lr)
    });
    let ft = [0, 0];

    function Ft(Lr) {
      var On;
      if (g($) && g(se) > x + 1) {
        const {
          lat: Zn,
          lng: Si
        } = g($).unproject([Lr.clientX, Lr.clientY]), Kn = E.latLonToPixels(Zn, Si, x), Nn = Math.floor(Kn[0]), Ri = Math.floor(Kn[1]);
        if (ft[0] !== Nn || ft[1] !== Ri) {
          const Br = E.latLonToPixelBoundsLatLon(Zn, Si, x),
            Pr = nm(Br, !0);
          (On = g($).getSource(De)) == null || On.setCoordinates(Pr), ft = [Nn, Ri]
        }
      }
    }
    return window.addEventListener("mousemove", Ft), () => {
      var Lr;
      (Lr = g($)) == null || Lr.remove(), window.removeEventListener("mousemove", Ft), Xe && clearInterval(Xe), r_()
    }
  }), ps(() => [za.theme], () => {
    if (g($)) {
      be = !1;
      const ft = Fe(za.theme);
      g($).setStyle(ft)
    }
  });

  function Fe(ft) {
    return `https://maps.wplace.live/styles/${ft==="custom-winter"?"liberty":"fiord"}`
  }
  let be = !1,
    Xe;
  async function tt() {
    let ft = l.pos ? {
      ...l.pos,
      zoom: g(se)
    } : await Whe();
    l.zoom !== void 0 && (ft.zoom = l.zoom), Xhe(ft) || (ft = {
      zoom: ft.zoom,
      ...z0.tokyo
    });
    const Ft = await new Promise(Kn => {
        const Nn = new Kd.Map({
          style: Fe(za.theme),
          center: ft,
          zoom: ft.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        Nn.touchZoomRotate.disableRotation(), Nn.on("styledata", Ri => {
          be || (za.theme === "custom-winter" && (Nn.setLayoutProperty("poi_transit", "visibility", "none"), Nn.setLayoutProperty("poi_r20", "visibility", "none"), Nn.setLayoutProperty("poi_r7", "visibility", "none"), Nn.setLayoutProperty("poi_r1", "visibility", "none"), Nn.setLayoutProperty("building", "visibility", "none"), Nn.setLayoutProperty("building-3d", "visibility", "none"), Nn.setLayoutProperty("landuse_pitch", "visibility", "none"), Nn.setLayoutProperty("landuse_hospital", "visibility", "none"), Nn.setLayoutProperty("landuse_school", "visibility", "none"), Nn.setLayoutProperty("landuse_residential", "visibility", "none"), Nn.setLayoutProperty("waterway_tunnel", "visibility", "none"), Nn.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), Ce(Nn), vt(), be = !0)
        }), Nn.on("style.load", () => {
          Kn(Nn)
        })
      }),
      Lr = xa.refreshIntervalMs;

    function On() {
      let Kn = g(se) > x + 1.5 ? Lr : 2.5 * Lr;
      try {
        document.visibilityState === "visible" && Ce(Ft)
      } finally {
        setTimeout(On, Kn)
      }
    }
    Xe = setTimeout(On, Lr), Ft.on("load", () => {
      l.discordLinked && (Zt.success(wM()), vi.url.searchParams.delete("discord-linked"), mp(vi.url.toString())), l.twitchMigration && (Zt.success(Zee()), vi.url.searchParams.delete("twitch-migration"), mp(vi.url.toString()))
    });
    let Zn = g(se);
    Ft.on("zoom", () => {
      H(se, Ft.getZoom(), !0);
      const Kn = U1e(g(se), 1);
      Kn != Zn && (g($t) && g($t).setOpacity(yt(Zn)), Zn = Kn)
    });
    let Si = "default";
    return Ft.on("dragstart", () => {
      const Kn = Ft.getCanvas();
      Si = Kn.style.cursor, Kn.style.cursor = "move"
    }), Ft.on("dragend", () => {
      Ft.getCanvas().style.cursor = Si
    }), Ft.on("mouseout", () => {
      et()
    }), Ft.on("click", async Kn => {
      var Dn;
      const Nn = Kn.lngLat.lat,
        Ri = Kn.lngLat.lng,
        Br = [Nn, Ri];
      if (g(we).name === "paintingPixel" || g(we).name === "selectArea") return;
      if (g(we).name === "selectHq") {
        g(we).hq = Br, (Dn = g(Rt)) == null || Dn.clearAndPlace(Br);
        return
      }
      const Pr = Ft.getZoom();
      if (Pr < k) {
        Zt.info(Xie());
        return
      }
      ss({
        lat: Nn,
        lng: Ri
      }, Pr), H(we, {
        name: "pixelSelected",
        latLon: Br
      }, !0)
    }), Ft
  }
  const Ye = "pixel-art-layer";

  function Ce(ft) {
    const Ft = window.innerWidth,
      Lr = `${i0}/s${cv}/tiles/{x}/{y}.png`;
    if (ee.clear(), !ft.style) return;
    ft.getSource(Ye) ? ft.refreshTiles(Ye) : ft.addSource(Ye, {
      type: "raster",
      tiles: [Lr],
      minzoom: x,
      maxzoom: x,
      tileSize: Ft > 640 ? 550 : 400
    }), ft.getLayer(Ye) || ft.addLayer({
      id: Ye,
      type: "raster",
      source: Ye,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": g(Vt)
      }
    })
  }
  const De = "pixel-hover",
    Ke = 1e-5,
    Le = [
      [0, 0],
      [Ke, 0],
      [Ke, -Ke],
      [0, -Ke]
    ],
    Ne = .4;
  async function vt() {
    var ft, Ft, Lr, On;
    if (!((ft = g($)) != null && ft.getSource(De))) {
      const Zn = Y0(await cp(Zhe));
      (Ft = g($)) == null || Ft.addSource(De, {
        type: "canvas",
        canvas: Zn,
        coordinates: Le
      })
    }(Lr = g($)) != null && Lr.getLayer(De) || (On = g($)) == null || On.addLayer({
      id: De,
      type: "raster",
      source: De,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": Ne
      }
    })
  }

  function et() {
    var ft, Ft;
    (Ft = (ft = g($)) == null ? void 0 : ft.getSource(De)) == null || Ft.setCoordinates(Le)
  }
  let We = Je(yi(l.opaque ?? !0)),
    _t = Je(!0),
    Vt = mt(() => g(_t) ? g(We) ? 1 : .2 : 0);
  cn(() => {
    var ft;
    (ft = g($)) != null && ft.getLayer(Ye) && g($).setPaintProperty(Ye, "raster-opacity", g(Vt))
  });
  let Et = Je(void 0),
    Pt = Je(void 0),
    lt = Je(void 0);
  Yi(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(ft => {
    ft.state === "granted" && H(lt, navigator.geolocation.watchPosition(Ft => {
      H(Et, Ft)
    }, Ft => {
      H(Pt, Ft)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    g(lt) && navigator.geolocation.clearWatch(g(lt))
  }));
  let $t = Je(void 0);
  ps(() => [g(Et), g($)], () => {
    var ft, Ft;
    if (g(Et) && g($)) {
      const Lr = {
          lat: g(Et).coords.latitude,
          lng: g(Et).coords.longitude
        },
        On = yt(g(se));
      if (!g($t)) {
        const Zn = document.createElement("div");
        Zn.classList.add("maplibregl-user-location-dot"), Zn.classList.add("cursor-auto"), H($t, new Kd.Marker({
          element: Zn,
          opacity: On
        }).setLngLat(Lr).addTo(g($)))
      }(Ft = (ft = g($t)) == null ? void 0 : ft.setLngLat(Lr)) == null || Ft.setOpacity(On)
    }
  });

  function yt(ft) {
    return ft < x ? "1.0" : V1e((ft - x) * .2, .5, 1).toFixed(2)
  }
  let Rt = Je(void 0);
  cn(() => {
    var ft;
    g($) && ((ft = Ca(() => g(Rt))) == null || ft.clear(), cp(kv).then(Ft => {
      H(Rt, new Sv({
        id: "select-crosshair",
        map: g($),
        tileSize: z,
        zoom: x,
        img: Ft,
        markerFn: () => {
          const Lr = new Kd.Marker({
            color: "#0069ff"
          });
          return Lr.addClassName("z-20"), Lr
        }
      }))
    }))
  });
  let jt = Je(void 0);
  cn(() => {
    var ft;
    g($) && ((ft = Ca(() => g(Rt))) == null || ft.clear(), cp(kv).then(Ft => {
      H(jt, new Sv({
        id: "paint-crosshair",
        map: g($),
        tileSize: z,
        zoom: x,
        img: Ft
      }))
    }))
  });
  let Xt = Je(!1),
    fr = Je(yi(vi.url)),
    Yt = Je(yi({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    lr = Je(!1);
  cn(() => {
    var ft;
    H(lr, !!((ft = Dt.data) != null && ft.needsPhoneVerification))
  });
  let ot = Je([]),
    nt = mt(() => g(se) < k ? "1.0" : g(se) < k + 2 ? "0.5" : "0.3");
  cn(() => {
    var Ft;
    const ft = (Ft = Dt.data) == null ? void 0 : Ft.favoriteLocations;
    if (ft && g($)) {
      for (const Lr of Ca(() => g(ot))) Lr.remove();
      H(ot, ft.map(Lr => {
        const On = document.createElement("div");
        On.classList.add("text-yellow-400"), On.classList.add("cursor-pointer"), On.classList.add("z-10"), On.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Zn = {
          lat: Lr.latitude,
          lng: Lr.longitude
        };
        return On.addEventListener("click", Kn => {
          Kn.stopPropagation(), Ut([Lr.latitude, Lr.longitude])
        }), new Kd.Marker({
          element: On,
          opacity: g(nt)
        }).setLngLat(Zn).addTo(g($))
      }))
    }
  });

  function Ut(ft) {
    var Lr;
    const Ft = {
      lat: ft[0],
      lng: ft[1]
    };
    (Lr = g($)) == null || Lr.flyTo({
      center: Ft,
      zoom: Math.max(g(se), 15)
    }), ss(Ft, g(se)), H(we, {
      name: "pixelSelected",
      latLon: [Ft.lat, Ft.lng]
    }, !0)
  }
  cn(() => {
    const ft = g(we).name === "paintingPixel";
    for (const Ft of g(ot)) ft ? Ft.addClassName("hidden") : (Ft.removeClassName("hidden"), Ft.setOpacity(g(nt)))
  });
  let Qt = Number.MAX_VALUE;
  cn(() => {
    if (Dt.charges !== void 0 && Dt.data) {
      const ft = Dt.data.charges.max,
        Ft = Dt.charges;
      Qt < ft && Ft >= ft && xi.notification1.play(), Qt = Dt.charges
    }
  });
  let Ot = Je(!1),
    mr = Date.now();
  Yi(() => {
    const ft = nde(),
      Ft = () => {
        var On;
        if (!document.hidden && Date.now() - mr > 30 * kc.min) {
          if (ft) {
            const Si = (On = g($)) == null ? void 0 : On.getCenter();
            Si && ss(Si, g(se)), window.location.replace(vi.url.origin)
          } else Dt.refresh();
          mr = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", Ft), () => document.removeEventListener("visibilitychange", Ft)
  }), Yi(() => {
    function ft() {
      dn.online = !0
    }
    window.addEventListener("online", ft);

    function Ft() {
      dn.online = !1
    }
    return window.addEventListener("offline", Ft), () => {
      window.removeEventListener("online", ft), window.removeEventListener("offline", Ft)
    }
  }), cn(() => {
    if (!dn.online) {
      const ft = setInterval(() => {
        dn.health().then(() => {
          dn.online = !0, !Dt.data && !Dt.loading && Dt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(ft)
      }
    }
  }), Yi(() => {
    if (!navigator.serviceWorker) {
      setTimeout(() => {
        console.log("Setting up service worker message listener", navigator.serviceWorker), Zt.warning(NK(), {
          duration: 5e3
        })
      });
      return
    }

    function ft(Ft) {
      Ft.data.type && g($) && Ce(g($))
    }
    return navigator.serviceWorker.addEventListener("message", ft), () => {
      navigator.serviceWorker.removeEventListener("message", ft)
    }
  });
  let zt = Je(!1),
    Mt = Je("report-user"),
    kt = Je(void 0),
    It = Je(void 0),
    Gt = Je(void 0),
    ht = Je(0),
    hr = Je(void 0);
  cn(() => {
    g(zt) || (H(hr, void 0), H(It, void 0), H(kt, void 0), H(Gt, void 0))
  });

  function wr() {
    H(we, {
      name: "mainMenu"
    }, !0), et()
  }
  let ur = Je(!1),
    qr = Je(!1),
    kr = Je(!1),
    Zr = Je(!1),
    Wr = Je(!1),
    tr = Je(!1),
    Hr = Je(!!l.newUser),
    sr = Je(!1),
    de = Je(!!l.alliance),
    O = Je(!1);
  const N = mt(() => g(ur) || g(qr) || g(kr) || g(Zr) || g(Wr) || g(tr) || g(Hr) || g(sr) || g(de) || g(O));
  var X = P2e();
  In("keydown", Os, async ft => {
    if (!g(N) && !(ft.target instanceof HTMLInputElement || ft.target instanceof HTMLTextAreaElement) && !ft.ctrlKey) switch (ft.code) {
      case "KeyC":
        if (!Dt.hasAnyPermission(Di.tools.selectArea) || g(we).name === "paintingPixel" || ft.repeat) return;
        wr(), await N_(), H(we, {
          name: "selectArea"
        }, !0);
        break
    }
  }), Ox("1uha8ag", ft => {
    var Ft = n2e();
    bn(6), Fx(() => {
      Bx.title = "Wplace - Paint the world"
    }), q(ft, Ft)
  });
  var re = Ct(X);
  {
    const ft = Br => {
        var Pr = i2e();
        Pr.__click = () => {
          H(We, !g(We))
        };
        var Dn = M(Pr);
        {
          let pn = mt(() => !g(We));
          by(Dn, {
            class: "size-5",
            get filled() {
              return g(pn)
            }
          })
        }
        S(Pr), Re(pn => {
          er(Pr, "title", pn), Vr(Pr, 1, qs({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": g(We),
            "btn-primary btn-soft": !g(We)
          }))
        }, [() => C0()]), q(Br, Pr)
      },
      Ft = Br => {
        var Pr = o2e();
        Pr.__click = async () => {
          var gn;
          g(Et) || H(Et, await new Promise((Ir, tn) => {
            navigator.geolocation.getCurrentPosition(Gn => {
              Ir(Gn)
            }, Gn => {
              tn(Gn)
            })
          })), g(Et) && (ss({
            lat: g(Et).coords.latitude,
            lng: g(Et).coords.longitude
          }, g(se)), (gn = g($)) == null || gn.flyTo({
            center: {
              lat: g(Et).coords.latitude,
              lng: g(Et).coords.longitude
            },
            zoom: 16.5
          }))
        };
        var Dn = M(Pr);
        {
          var pn = gn => {
              F1e(gn, {
                class: "size-5.5 fill-blue-800"
              })
            },
            Ar = gn => {
              var Ir = a2e(),
                tn = M(Ir);
              R1e(tn, {
                class: "size-5.5 fill-red-400"
              }), bn(2), S(Ir), q(gn, Ir)
            };
          Te(Dn, gn => {
            g(Et) ? gn(pn) : gn(Ar, !1)
          })
        }
        S(Pr), Re(gn => er(Pr, "title", gn), [() => Yj()]), q(Br, Pr)
      };
    var Q = D(M(re), 2);
    let Lr;
    var ue = M(Q);
    let On;
    var ke = M(ue);
    {
      var xe = Br => {
          var Pr = s2e();
          Pr.__click = () => {
            var pn;
            H(Zr, !0), g($) && ss((pn = g($)) == null ? void 0 : pn.getCenter(), g(se))
          };
          var Dn = M(Pr, !0);
          S(Pr), Re(pn => te(Dn, pn), [() => ID()]), q(Br, Pr)
        },
        Ee = Br => {
          var Pr = Sr(),
            Dn = Ct(Pr);
          {
            var pn = Ar => {
              var gn = c2e(),
                Ir = M(gn);
              {
                var tn = qn => {
                  var Ln = l2e(),
                    Pn = M(Ln);
                  y0(Pn, {
                    get role() {
                      return Dt.data.role
                    }
                  }), S(Ln), q(qn, Ln)
                };
                Te(Ir, qn => {
                  var Ln;
                  (Ln = Dt.data) != null && Ln.role && Dt.data.role !== "user" && qn(tn)
                })
              }
              var Gn = D(Ir, 2);
              bbe(Gn, {
                get user() {
                  return Dt
                },
                onlogout: () => {
                  H(we, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  H(ur, !0)
                },
                onnotificationclick: () => {
                  H(qr, !0)
                },
                ontogglepixelarts: qn => {
                  H(_t, qn, !0)
                }
              }), S(gn), fa(3, gn, () => Ja, () => ({
                duration: 150
              })), q(Ar, gn)
            };
            Te(Dn, Ar => {
              Dt.data && g($) && g(we).name !== "paintingPixel" && Ar(pn)
            }, !0)
          }
          q(Br, Pr)
        };
      Te(ke, Br => {
        !Dt.loading && !Dt.data ? Br(xe) : Br(Ee, !1)
      })
    }
    var He = D(ke, 2);
    {
      var Be = Br => {
          var Pr = p2e(),
            Dn = M(Pr);
          {
            var pn = Mn => {
              var fn = u2e(),
                un = Ct(fn);
              un.__click = () => {
                var ji;
                H(Wr, !0);
                const li = (ji = g($)) == null ? void 0 : ji.getCenter();
                li && ss(li, g(se))
              };
              var ia = M(un);
              ky(ia, {
                class: "size-5"
              }), S(un);
              var Wn = D(un, 2);
              Wn.__click = () => {
                H(de, !0)
              };
              var ii = M(Wn);
              jp(ii, {
                class: "size-5"
              }), S(Wn), Re((li, ji) => {
                er(un, "title", li), er(Wn, "title", ji)
              }, [() => I0(), () => Ep()]), q(Mn, fn)
            };
            Te(Dn, Mn => {
              Dt.data && Mn(pn)
            })
          }
          var Ar = D(Dn, 2);
          Ar.__click = () => {
            H(tr, !0)
          };
          var gn = M(Ar);
          my(gn, {
            class: "size-5"
          }), S(Ar);
          var Ir = D(Ar, 2);
          Ir.__click = () => {
            H(kr, !0)
          };
          var tn = M(Ir);
          N1e(tn, {
            class: "size-5"
          }), S(Ir);
          var Gn = D(Ir, 2);
          {
            var qn = Mn => {
              var fn = h2e();
              fn.__click = () => {
                g($) && H(we, {
                  name: "adminAutoPaint"
                }, !0)
              };
              var un = M(fn);
              bl(un, {
                class: "size-5"
              }), S(fn), q(Mn, fn)
            };
            Te(Gn, Mn => {
              Dt.hasPermission(Di.tools.autoPainter) && Mn(qn)
            })
          }
          var Ln = D(Gn, 2);
          {
            var Pn = Mn => {
              var fn = d2e();
              fn.__click = () => {
                g($) && H(r, !0)
              };
              var un = M(fn);
              r2e(un, {
                class: "size-5"
              }), S(fn), q(Mn, fn)
            };
            Te(Ln, Mn => {
              Dt.hasPermission("staff.tools.wayback.video") && Mn(Pn)
            })
          }
          S(Pr), Re((Mn, fn) => {
            er(Ar, "title", Mn), er(Ir, "title", fn)
          }, [() => Y_(), () => d0()]), fa(3, Pr, () => Ja, () => ({
            duration: 150
          })), q(Br, Pr)
        },
        ie = Br => {
          var Pr = Sr(),
            Dn = Ct(Pr);
          {
            var pn = Ar => {
              var gn = f2e(),
                Ir = M(gn);
              let tn;
              Ir.__click = () => {
                H(_e, !g(_e))
              };
              var Gn = M(Ir);
              {
                var qn = Pn => {
                    j_(Pn, {
                      class: "size-5"
                    })
                  },
                  Ln = Pn => {
                    Tp(Pn, {
                      class: "size-5"
                    })
                  };
                Te(Gn, Pn => {
                  g(_e) ? Pn(qn) : Pn(Ln, !1)
                })
              }
              S(Ir), S(gn), Re(Pn => {
                er(Ir, "title", Pn), tn = Vr(Ir, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, tn, {
                  "btn-primary": g(_e)
                })
              }, [() => g(_e) ? T1() : _D()]), fa(1, gn, () => Ja, () => ({
                delay: 150,
                duration: 150
              })), q(Ar, gn)
            };
            Te(Dn, Ar => {
              g($) && g(we).name === "paintingPixel" && Ar(pn)
            }, !0)
          }
          q(Br, Pr)
        };
      Te(He, Br => {
        g($) && g(we).name !== "paintingPixel" ? Br(Be) : Br(ie, !1)
      })
    }
    S(ue), S(Q);
    var J = D(Q, 2);
    let Zn;
    var Ve = M(J);
    {
      var rt = Br => {
        var Pr = _2e();
        Pr.__click = () => {
          H(sr, !0)
        };
        var Dn = M(Pr);
        L1e(Dn, {
          class: "size-3.5"
        }), S(Pr), Re(pn => er(Pr, "title", pn), [() => xE()]), q(Br, Pr)
      };
      Te(Ve, Br => {
        g(we).name !== "paintingPixel" && Br(rt)
      })
    }
    var Ue = D(Ve, 2),
      ae = M(Ue);
    ae.__click = () => {
      var Br;
      (Br = g($)) == null || Br.zoomIn()
    };
    var Ie = D(ae, 2);
    Ie.__click = () => {
      var Br;
      (Br = g($)) == null || Br.zoomOut()
    }, S(Ue);
    var $e = D(Ue, 2);
    {
      var dt = Br => {
        var Pr = m2e(),
          Dn = D(M(Pr), 2);
        Dn.__click = () => {
          H(we, {
            name: "selectArea"
          }, !0)
        };
        var pn = M(Dn);
        B_(pn, {
          class: "size-4"
        }), S(Dn), S(Pr), q(Br, Pr)
      };
      Te($e, Br => {
        g(we).name !== "paintingPixel" && Dt.hasAnyPermission(Di.tools.selectArea) && Br(dt)
      })
    }
    var Tt = D($e, 2);
    {
      var pt = Br => {
        var Pr = g2e(),
          Dn = M(Pr);
        wy(Dn, {
          class: "size-4",
          onclick: () => {
            H(V, !g(V))
          }
        }), S(Pr), Re(pn => er(Pr, "title", pn), [() => Bz()]), q(Br, Pr)
      };
      Te(Tt, Br => {
        g(ge) && Br(pt)
      })
    }
    var St = D(Tt, 2);
    {
      var qt = Br => {
        var Pr = v2e();
        Pr.__click = () => {
          window.location.replace(vi.url.origin)
        };
        var Dn = M(Pr);
        O1(Dn, {
          class: "size-3"
        }), S(Pr), Re(pn => er(Pr, "title", pn), [() => N1()]), q(Br, Pr)
      };
      Te(St, Br => {
        g(we).name !== "paintingPixel" && Br(qt)
      })
    }
    S(J);
    var qe = D(J, 2);
    let Si;
    var bt = M(qe);
    {
      var Jt = Br => {
        var Pr = y2e(),
          Dn = M(Pr);
        q1(Dn, {
          class: "size-5"
        });
        var pn = D(Dn);
        S(Pr), Re(Ar => te(pn, ` ${Ar??""}`), [() => sq()]), fa(1, Pr, () => Ja, () => ({
          duration: 1e3
        })), fa(2, Pr, () => Ja), q(Br, Pr)
      };
      Te(bt, Br => {
        dn.online || Br(Jt)
      })
    }
    var Cr = D(bt, 2);
    {
      var _r = Br => {
        var Pr = b2e();
        Pr.__click = () => {
          var Ar;
          (Ar = g($)) == null || Ar.flyTo({
            center: g($).getCenter(),
            zoom: x
          })
        };
        var Dn = M(Pr);
        O1e(Dn, {
          class: "size-5"
        });
        var pn = D(Dn);
        S(Pr), Re(Ar => te(pn, ` ${Ar??""}`), [() => Dae()]), fa(3, Pr, () => Ja, () => ({
          duration: 300
        })), q(Br, Pr)
      };
      Te(Cr, Br => {
        g(se) < k && Br(_r)
      })
    }
    S(qe);
    var Qe = D(qe, 2);
    let Kn;
    var rr = M(Qe);
    ft(rr), S(Qe);
    var Kt = D(Qe, 2);
    let Nn;
    var Tr = M(Kt);
    {
      var Rr = Br => {
          {
            let Pr = mt(() => g(W) - 96 - 32);
            vy(Br, {
              class: "z-30",
              get maxWidth() {
                return g(Pr)
              },
              onclick: () => {
                var Dn;
                (Dn = Dt.data) != null && Dn.needsPhoneVerification ? (H(lr, !0), Zt.warning(_v())) : Dt.charges !== void 0 && Dt.charges < 1 ? Zt.warning(Kve, {
                  icon: Yu
                }) : g($) && Dt.data ? (xi.smallDropplet.play(), H(we, {
                  name: "paintingPixel"
                }, !0)) : (H(Zr, !0), g($) && ss(g($).getCenter(), g(se)))
              },
              get disabled() {
                return Dt.loading
              },
              get loading() {
                return Dt.loading
              },
              get charges() {
                return Dt.charges
              }
            })
          }
        },
        Qr = Br => {
          var Pr = x2e();
          q(Br, Pr)
        };
      Te(Tr, Br => {
        g(we).name === "mainMenu" ? Br(Rr) : Br(Qr, !1)
      })
    }
    S(Kt);
    var br = D(Kt, 2);
    let Ri;
    var Nt = M(br);
    Ft(Nt), S(br);
    var wt = D(br, 2);
    {
      var Ge = Br => {
        var Pr = Sr(),
          Dn = Ct(Pr);
        {
          var pn = gn => {
              var Ir = w2e(),
                tn = M(Ir),
                Gn = M(tn);
              e1e(Gn, {
                get latLon() {
                  return g(we).latLon
                },
                get map() {
                  return g($)
                },
                get crosshair() {
                  return g(Rt)
                },
                get pixelInfoCache() {
                  return ee
                },
                get season() {
                  return F
                },
                get tileSize() {
                  return z
                },
                get pixelArtZoom() {
                  return x
                },
                get zoom() {
                  return g(se)
                },
                get opaquePixelArt() {
                  return g(We)
                },
                onclose: () => H(we, {
                  name: "mainMenu"
                }, !0),
                onclickshare: qn => {
                  H(fr, qn, !0), H(Xt, !0)
                },
                onclickpaint: ([qn, Ln]) => {
                  var Mn, fn, un;
                  if (!Dt.data) {
                    H(Zr, !0);
                    return
                  }
                  if ((Mn = Dt.data) != null && Mn.needsPhoneVerification) {
                    H(lr, !0), Zt.warning(_v());
                    return
                  }
                  if (Dt.charges !== void 0 && Dt.charges < 1) {
                    Zt.warning(jie());
                    return
                  }
                  const Pn = im(E.latLonToPixelBoundsLatLon(qn, Ln, x));
                  (fn = g($)) == null || fn.flyTo({
                    center: {
                      lat: Pn[0],
                      lon: Pn[1]
                    }
                  }), H(we, {
                    name: "paintingPixel",
                    clickedLatLon: [qn, Ln]
                  }, !0), (un = g(Rt)) == null || un.clear()
                },
                onclickregion: qn => {
                  H(Yt, qn, !0), H(O, !0)
                },
                onclickmodaction: (qn, Ln, Pn, Mn) => {
                  var ia, Wn, ii;
                  (ia = g($)) == null || ia.setZoom(Math.max(g(se), x + 3.5));
                  const fn = E.latLonToPixelBoundsLatLon(Pn[0], Pn[1], x);
                  if ((Wn = g($)) == null || Wn.setCenter({
                      lat: fn.min[0],
                      lng: (fn.max[1] + fn.min[1]) / 2
                    }), !(qn != null && qn.paintedBy)) {
                    Zt.error(pv());
                    return
                  }
                  const un = qn.paintedBy;
                  H(kt, Ln, !0), H(It, [{
                    id: un.id,
                    name: un.name,
                    picture: un.picture,
                    allianceId: un.allianceId ?? void 0,
                    allianceName: un.allianceName ?? void 0,
                    timedOut: un.timedOut,
                    banned: un.banned
                  }], !0), H(Gt, Pn, !0), H(ht, ((ii = g($)) == null ? void 0 : ii.getZoom()) ?? 0, !0), H(Mt, Mn, !0), H(hr, void 0), H(zt, !0), H(Me, "select-pixel")
                },
                get christmasTreeId() {
                  return g(we).christmasTreeId
                }
              }), S(tn), S(Ir), fa(3, tn, () => ip, () => ({
                duration: 100
              })), q(gn, Ir)
            },
            Ar = gn => {
              var Ir = Sr(),
                tn = Ct(Ir);
              {
                var Gn = Ln => {
                    var Pn = k2e(),
                      Mn = M(Pn),
                      fn = M(Mn);
                    nye(fn, {
                      get map() {
                        return g($)
                      },
                      get clickedLatLon() {
                        return g(we).clickedLatLon
                      },
                      get tileSize() {
                        return z
                      },
                      get tileZoom() {
                        return x
                      },
                      get season() {
                        return F
                      },
                      get zoom() {
                        return g(se)
                      },
                      get crosshair() {
                        return g(jt)
                      },
                      refreshPixelArt: () => g($) && Ce(g($)),
                      hidePixelHover: et,
                      hoverLayerId: De,
                      onclose: () => {
                        H(we, {
                          name: "mainMenu"
                        }, !0), et()
                      },
                      get screenLocked() {
                        return g(_e)
                      },
                      set screenLocked(un) {
                        H(_e, un, !0)
                      },
                      get opaquePixelArt() {
                        return g(We)
                      },
                      set opaquePixelArt(un) {
                        H(We, un, !0)
                      }
                    }), S(Mn), S(Pn), fa(3, Mn, () => ip, () => ({
                      duration: 100
                    })), q(Ln, Pn)
                  },
                  qn = Ln => {
                    var Pn = Sr(),
                      Mn = Ct(Pn);
                    {
                      var fn = ia => {
                          var Wn = T2e(),
                            ii = M(Wn);
                          Txe(ii, {
                            get map() {
                              return g($)
                            },
                            get tileSize() {
                              return z
                            },
                            get pixelArtZoom() {
                              return Yd
                            },
                            get season() {
                              return F
                            },
                            get crosshair() {
                              return g(jt)
                            },
                            onmodaction: li => {
                              var Sn;
                              const {
                                targets: ji,
                                image: Pi,
                                latLon: Qn,
                                zoom: hi,
                                action: Mi,
                                onSuccess: Ni
                              } = li;
                              if (!ji || ji.length === 0) {
                                Zt.error(pv());
                                return
                              }
                              H(kt, Pi, !0), H(It, ji, !0), H(Gt, Qn, !0), H(ht, hi ?? ((Sn = g($)) == null ? void 0 : Sn.getZoom()) ?? 0, !0), H(Mt, Mi, !0), H(hr, {
                                onSuccess: Ni
                              }, !0), H(zt, !0), H(Me, "select-area")
                            },
                            onclose: wr
                          }), S(Wn), q(ia, Wn)
                        },
                        un = ia => {
                          var Wn = Sr(),
                            ii = Ct(Wn);
                          {
                            var li = Pi => {
                                zfe(Pi, {
                                  get map() {
                                    return g($)
                                  },
                                  get tileSize() {
                                    return z
                                  },
                                  get tileZoom() {
                                    return x
                                  },
                                  get season() {
                                    return F
                                  },
                                  refreshPixelArt: () => g($) && Ce(g($)),
                                  onclose: () => {
                                    H(we, {
                                      name: "mainMenu"
                                    }, !0)
                                  }
                                })
                              },
                              ji = Pi => {
                                var Qn = Sr(),
                                  hi = Ct(Qn);
                                {
                                  var Mi = Ni => {
                                    var Sn = S2e(),
                                      wa = M(Sn),
                                      vn = M(wa),
                                      yn = M(vn),
                                      Ba = M(yn),
                                      Rn = M(Ba);
                                    xy(Rn, {
                                      class: "inline size-4"
                                    });
                                    var Oa = D(Rn);
                                    S(Ba);
                                    var Vi = D(Ba, 2);
                                    Vi.__click = () => {
                                      H(we, {
                                        name: "mainMenu"
                                      }, !0)
                                    };
                                    var eo = M(Vi);
                                    Ro(eo, {
                                      class: "size-4"
                                    }), S(Vi), S(yn);
                                    var qa = D(yn, 2),
                                      ka = M(qa);
                                    ka.__click = async () => {
                                      var Na;
                                      if (g(we).name === "selectHq") {
                                        const to = g(we).hq;
                                        if (to) try {
                                          H(Ot, !0), await dn.updateAllianceHeadquarters(to[0], to[1]), (Na = g(Rt)) == null || Na.clear(), H(de, !0), H(we, {
                                            name: "mainMenu"
                                          }, !0)
                                        } catch (di) {
                                          Zt.error(di.message)
                                        } finally {
                                          H(Ot, !1)
                                        }
                                      }
                                    };
                                    var oo = M(ka);
                                    fm(oo, {
                                      class: "size-6"
                                    }), S(ka), S(qa), S(vn), S(wa), S(Sn), Re(Na => {
                                      te(Oa, ` ${Na??""}`), ka.disabled = g(we).hq === void 0 || g(Ot)
                                    }, [() => $$()]), fa(3, wa, () => ip, () => ({
                                      duration: 100
                                    })), q(Ni, Sn)
                                  };
                                  Te(hi, Ni => {
                                    g(we).name === "selectHq" && Ni(Mi)
                                  }, !0)
                                }
                                q(Pi, Qn)
                              };
                            Te(ii, Pi => {
                              g(we).name === "adminAutoPaint" && g($) ? Pi(li) : Pi(ji, !1)
                            }, !0)
                          }
                          q(ia, Wn)
                        };
                      Te(Mn, ia => {
                        g(we).name === "selectArea" ? ia(fn) : ia(un, !1)
                      }, !0)
                    }
                    q(Ln, Pn)
                  };
                Te(tn, Ln => {
                  g(we).name === "paintingPixel" && g(jt) ? Ln(Gn) : Ln(qn, !1)
                }, !0)
              }
              q(gn, Ir)
            };
          Te(Dn, gn => {
            g(we).name === "pixelSelected" && g(Rt) ? gn(pn) : gn(Ar, !1)
          })
        }
        q(Br, Pr)
      };
      Te(wt, Br => {
        g($) && Br(Ge)
      })
    }
    S(re), Re((Br, Pr) => {
      Lr = Vr(Q, 1, "absolute top-2 right-2 z-30", null, Lr, {
        hidden: g(V)
      }), On = Vr(ue, 1, "flex flex-col gap-4", null, On, {
        "items-end": !Dt.data,
        "items-center": Dt.data
      }), Zn = Vr(J, 1, "absolute top-2 left-2 z-30 flex flex-col gap-3", null, Zn, {
        hidden: g(V)
      }), er(ae, "title", Br), er(Ie, "title", Pr), Si = Vr(qe, 1, "absolute top-2 left-1/2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Si, {
        hidden: g(V)
      }), Kn = Vr(Qe, 1, "absolute bottom-3 left-3 z-30", null, Kn, {
        hidden: g(V)
      }), Nn = Vr(Kt, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, Nn, {
        hidden: g(V)
      }), Ri = Vr(br, 1, "absolute right-3 bottom-3 z-30", null, Ri, {
        hidden: g(V)
      })
    }, [() => xae(), () => Hae()])
  }
  var xt = D(re, 2);
  {
    var Wt = ft => {
      e2e(ft, {
        get map() {
          return g($)
        },
        get season() {
          return F
        },
        get tileSize() {
          return z
        },
        get pixelArtZoom() {
          return Yd
        },
        refreshPixelArt: () => g($) && Ce(g($)),
        onclose: () => {
          H(r, !1)
        }
      })
    };
    Te(xt, ft => {
      g(r) && g($) && ft(Wt)
    })
  }
  var At = D(xt, 2);
  Xve(At, {
    get open() {
      return g(Zr)
    },
    set open(ft) {
      H(Zr, ft, !0)
    }
  });
  var pr = D(At, 2);
  A1e(pr, {
    get open() {
      return g(Wr)
    },
    set open(ft) {
      H(Wr, ft, !0)
    }
  });
  var ar = D(pr, 2);
  hme(ar, {
    get open() {
      return g(Hr)
    },
    set open(ft) {
      H(Hr, ft, !0)
    }
  });
  var zr = D(ar, 2);
  Cme(zr, {
    get open() {
      return g(sr)
    },
    set open(ft) {
      H(sr, ft, !0)
    }
  });
  var Jr = D(zr, 2);
  Wve(Jr, {
    onvisitclick: ft => {
      var Ft;
      (Ft = g($)) == null || Ft.flyTo({
        center: ft,
        zoom: Yd + 1
      }), ss(ft, g(se)), Khe.push({
        pos: ft,
        zoom: g(se)
      }), H(tr, !1)
    },
    get open() {
      return g(tr)
    },
    set open(ft) {
      H(tr, ft, !0)
    }
  });
  var jr = D(Jr, 2);
  Dbe(jr, {
    get region() {
      return g(Yt)
    },
    get open() {
      return g(O)
    },
    set open(ft) {
      H(O, ft, !0)
    }
  });
  var Or = D(jr, 2);
  l1(Or, {
    get open() {
      return za.dropletsDialogOpen
    },
    set open(ft) {
      za.dropletsDialogOpen = ft
    }
  });
  var Fr = D(Or, 2);
  {
    var rn = ft => {
      $_e(ft, {
        onhqchange: () => {
          H(we, {
            name: "selectHq"
          }, !0), H(de, !1)
        },
        onhqclick: Ft => {
          var Lr;
          (Lr = g($)) == null || Lr.flyTo({
            center: Ft,
            zoom: Math.max(g(se), 15)
          }), H(we, {
            name: "pixelSelected",
            latLon: [Ft.lat, Ft.lng]
          }, !0), H(de, !1)
        },
        onlastpixelclick: Ft => {
          var Lr;
          (Lr = g($)) == null || Lr.flyTo({
            center: Ft,
            zoom: Math.max(g(se), 15)
          }), H(we, {
            name: "pixelSelected",
            latLon: [Ft.lat, Ft.lng]
          }, !0), H(de, !1)
        },
        get open() {
          return g(de)
        },
        set open(Ft) {
          H(de, Ft, !0)
        }
      })
    };
    Te(Fr, ft => {
      g($) && ft(rn)
    })
  }
  var An = D(Fr, 2);
  {
    var kn = ft => {
      ame(ft, {
        get url() {
          return g(fr)
        },
        get map() {
          return g($)
        },
        hideHover: () => {
          var Ft, Lr;
          (Ft = g($)) == null || Ft.setPaintProperty(De, "raster-opacity", 0), (Lr = g(Rt)) == null || Lr.setCanvasOpacity(0)
        },
        showHover: () => {
          var Ft, Lr;
          (Ft = g($)) == null || Ft.setPaintProperty(De, "raster-opacity", Ne), (Lr = g(Rt)) == null || Lr.setCanvasOpacity(1)
        },
        get open() {
          return g(Xt)
        },
        set open(Ft) {
          H(Xt, Ft, !0)
        }
      })
    };
    Te(An, ft => {
      g($) && ft(kn)
    })
  }
  var Kr = D(An, 2);
  {
    var Ur = ft => {
      k1(ft, {
        get image() {
          return g(kt)
        },
        get targets() {
          return g(It)
        },
        get latLon() {
          return g(Gt)
        },
        get zoom() {
          return g(ht)
        },
        get action() {
          return g(Mt)
        },
        onsuccess: () => {
          var Ft, Lr;
          (Lr = (Ft = g(hr)) == null ? void 0 : Ft.onSuccess) == null || Lr.call(Ft)
        },
        get origin() {
          return g(Me)
        },
        get open() {
          return g(zt)
        },
        set open(Ft) {
          H(zt, Ft, !0)
        }
      })
    };
    Te(Kr, ft => {
      g(It) && g(It).length > 0 && g(kt) && g(Gt) && ft(Ur)
    })
  }
  var Cn = D(Kr, 2);
  {
    var En = ft => {
      aye(ft, {
        get userData() {
          return Dt.data
        },
        get open() {
          return g(ur)
        },
        set open(Ft) {
          H(ur, Ft, !0)
        }
      })
    };
    Te(Cn, ft => {
      Dt.data && ft(En)
    })
  }
  var Tn = D(Cn, 2);
  f0e(Tn, {
    get open() {
      return g(qr)
    },
    set open(ft) {
      H(qr, ft, !0)
    }
  });
  var Un = D(Tn, 2);
  {
    var Jn = ft => {
      Xbe(ft, {
        get map() {
          return g($)
        },
        get tileSize() {
          return z
        },
        get season() {
          return F
        },
        get tileZoom() {
          return x
        },
        get open() {
          return g(kr)
        },
        set open(Ft) {
          H(kr, Ft, !0)
        }
      })
    };
    Te(Un, ft => {
      g($) && ft(Jn)
    })
  }
  Ch("innerWidth", ft => H(W, ft, !0)), q(p, X), an()
}
Yn(["click"]);
export {
  Lwe as component
};