var _x = Object.defineProperty;
var hx = Object.getPrototypeOf;
var dx = Reflect.get;
var ry = l => {
  throw TypeError(l)
};
var px = (l, s, t) => s in l ? _x(l, s, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: t
}) : l[s] = t;
var dn = (l, s, t) => px(l, typeof s != "symbol" ? s + "" : s, t),
  Bp = (l, s, t) => s.has(l) || ry("Cannot " + t);
var We = (l, s, t) => (Bp(l, s, "read from private field"), t ? t.call(l) : s.get(l)),
  yn = (l, s, t) => s.has(l) ? ry("Cannot add the same private member more than once") : s instanceof WeakSet ? s.add(l) : s.set(l, t),
  Mo = (l, s, t, w) => (Bp(l, s, "write to private field"), w ? w.call(l, t) : s.set(l, t), t),
  tn = (l, s, t) => (Bp(l, s, "access private method"), t);
var ny = (l, s, t) => dx(hx(l), t, s);
import "../chunks/DY7xnStP.js";
import {
  o as ti,
  a as fx,
  s as Bi
} from "../chunks/B1AZJvFo.js";
import {
  a9 as mx,
  bm as gx,
  bB as yx,
  bo as vx,
  bC as bx,
  aX as xx,
  bD as wx,
  e as ee,
  bE as iy,
  a7 as kx,
  j as y,
  i as Y,
  a_ as ql,
  o as $r,
  b as Z,
  p as en,
  a6 as ho,
  bF as Fp,
  bG as Tx,
  f as ft,
  as as jn,
  bx as Oa,
  a as xe,
  d as C,
  r as P,
  s as D,
  n as Mn,
  c as rn,
  t as Bt,
  x as Io,
  h as kr,
  bH as oy,
  H as Sx,
  bI as Px,
  aR as to,
  g as Qi,
  ar as ri,
  u as ge,
  K as cn,
  bz as dd,
  J as Bf,
  aD as Mx,
  aC as sy,
  aE as Cx,
  w as Ff,
  bJ as da,
  aY as Yo,
  bK as $y,
  F as Ix,
  $ as zx
} from "../chunks/BnnwGbo9.js";
import {
  s as at,
  c as Xy
} from "../chunks/CHaT1zrU.js";
import {
  i as At
} from "../chunks/BkhpDRks.js";
import {
  h as Ax
} from "../chunks/CE8OA3P0.js";
import {
  b as Er,
  a as Gr,
  s as pr,
  f as _a,
  r as xo,
  g as Of,
  e as Ex,
  d as eo,
  i as ed,
  c as qa,
  h as ay
} from "../chunks/2z4inOa3.js";
import {
  a as fu,
  t as vo
} from "../chunks/BiUhNzGy.js";
import {
  g as pd,
  b as jx
} from "../chunks/BZj4bi_O.js";
import {
  p as gi
} from "../chunks/BNEerMnb.js";
import {
  g as zo,
  P as Lx,
  b as Yy
} from "../chunks/Dutiof8Y.js";
import {
  a as Ao,
  t as Ne,
  b as fn,
  u as ze,
  q as Ls,
  r as Dx,
  v as Rx,
  w as Bx,
  y as Fx,
  f as Ox,
  x as qx,
  c as Nx,
  z as Vx,
  C as uy,
  P as Op,
  A as Ux
} from "../chunks/DOSnmeqm.js";
import {
  A as mi,
  p as qf,
  c as Jp,
  g as qp,
  a as Zx
} from "../chunks/BlER6fFV.js";
import {
  P as Ri
} from "../chunks/BzuEigt6.js";
import "../chunks/CMCIaQ-i.js";
import {
  e as di,
  i as P_
} from "../chunks/BB-v54M_.js";
import {
  a as Nf,
  c as Vf,
  b as M_
} from "../chunks/DTf9GJW2.js";
import {
  b as os
} from "../chunks/DOn3DNKP.js";
import {
  i as Uf
} from "../chunks/zR425q2b.js";
import {
  r as Ir,
  p as $e,
  s as Ec,
  u as cy
} from "../chunks/MQjh4H31.js";
import {
  C as pa,
  S as Gx,
  U as Hx,
  a as Wx,
  r as $x
} from "../chunks/CkcAzUff.js";
import {
  U as Xx,
  A as Ky,
  D as Jy,
  a as kd,
  I as Qp,
  e as Yx,
  r as Kx,
  c as Jx,
  P as Qy,
  b as Qx
} from "../chunks/CXftNFol.js";
import {
  b as tv,
  c as Zf,
  g as Ji,
  a as Td
} from "../chunks/D9eU8q7o.js";
import {
  h as Sd
} from "../chunks/PxWHy-gH.js";
import {
  L as ev
} from "../chunks/18S_3gTv.js";
import {
  g as B,
  l as t1
} from "../chunks/BsHwvxn8.js";
import {
  c as C_
} from "../chunks/_KcqMkJO.js";
import {
  d as e1,
  L as Pd,
  p as Gf
} from "../chunks/D8FwLYa_.js";
import {
  c as tf,
  e as Md,
  D as Hf,
  W as r1,
  s as n1,
  b as i1,
  l as rv,
  d as o1,
  a as s1,
  p as a1,
  r as u1,
  t as c1,
  f as l1,
  R as _1,
  g as ly
} from "../chunks/vOHD9riC.js";
import {
  P as ws,
  t as h1
} from "../chunks/DbCMAySt.js";
import {
  l as d1,
  v as p1,
  s as nv
} from "../chunks/C49eVGwr.js";
import {
  p as Wf,
  m as iv,
  s as f1
} from "../chunks/BYTFhmnu.js";
import {
  f as mu
} from "../chunks/Lniy2Ma3.js";
import {
  k as Hl
} from "../chunks/By9YASnl.js";
import {
  A as ov,
  c as la
} from "../chunks/DG48s7cA.js";
import {
  b as $f
} from "../chunks/BazR7k_b.js";
import {
  u as m1
} from "../chunks/wbOGB0es.js";
import {
  u as g1
} from "../chunks/BSaNXFk7.js";
import {
  l as Xf
} from "../chunks/BBQehowE.js";
import {
  f as is,
  s as rd
} from "../chunks/B3itTX18.js";
import {
  C as Yf
} from "../chunks/DjP738DW.js";
import {
  L as sv
} from "../chunks/C0kPDjQD.js";
import {
  t as y1,
  r as av,
  g as v1
} from "../chunks/CyfxxXSC.js";
import {
  c as bo
} from "../chunks/DBmghTJl.js";
import {
  a as uv
} from "../chunks/culBebg7.js";
import {
  L as b1
} from "../chunks/C34syqse.js";
import {
  c as cv
} from "../chunks/BXecplFs.js";
import {
  a as x1
} from "../chunks/gA2Ir-7I.js";
import {
  d as w1
} from "../chunks/aF2rlbU1.js";
import {
  R as lv
} from "../chunks/hHKlgDP9.js";
import {
  T as Wl,
  G as fd,
  c as k1
} from "../chunks/DpGZ8_KB.js";
import {
  t as _v
} from "../chunks/BVJKRz2s.js";
import {
  C as T1
} from "../chunks/DREiJzEY.js";
import {
  R as S1
} from "../chunks/22sH7qVC.js";
import {
  W as P1
} from "../chunks/CQFtUvzw.js";
import {
  r as M1
} from "../chunks/DjPcjyB1.js";
(function() {
  try {
    var l = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    l.SENTRY_RELEASE = {
      id: "e76e01713b9f24724b47470026b2b700ac9e05af"
    }
  } catch {}
})();
try {
  (function() {
    var l = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      s = new l.Error().stack;
    s && (l._sentryDebugIds = l._sentryDebugIds || {}, l._sentryDebugIds[s] = "35a738f2-e96b-4d6d-96af-9a2736637b66", l._sentryDebugIdIdentifier = "sentry-dbid-35a738f2-e96b-4d6d-96af-9a2736637b66")
  })()
} catch {}
const C1 = [];

function I1(l, s = !1, t = !1) {
  return nd(l, new Map, "", C1, null, t)
}

function nd(l, s, t, w, z = null, E = !1) {
  if (typeof l == "object" && l !== null) {
    var k = s.get(l);
    if (k !== void 0) return k;
    if (l instanceof Map) return new Map(l);
    if (l instanceof Set) return new Set(l);
    if (mx(l)) {
      var c = Array(l.length);
      s.set(l, c), z !== null && s.set(z, c);
      for (var R = 0; R < l.length; R += 1) {
        var X = l[R];
        R in l && (c[R] = nd(X, s, t, w, null, E))
      }
      return c
    }
    if (gx(l) === yx) {
      c = {}, s.set(l, c), z !== null && s.set(z, c);
      for (var $ in l) c[$] = nd(l[$], s, t, w, null, E);
      return c
    }
    if (l instanceof Date) return structuredClone(l);
    if (typeof l.toJSON == "function" && !E) return nd(l.toJSON(), s, t, w, l)
  }
  if (l instanceof EventTarget) return l;
  try {
    return structuredClone(l)
  } catch {
    return l
  }
}

function z1() {
  return Symbol(vx)
}

function I_(l, s) {
  bx(window, ["resize"], () => xx(() => s(window[l])))
}

function A1(l) {
  return function(...s) {
    var t = s[0];
    return t.preventDefault(), l == null ? void 0 : l.apply(this, s)
  }
}
const E1 = wx;
var Es, js, ua, bd, xs, Nl, id;
const dm = class dm extends Map {
  constructor(t) {
    super();
    yn(this, xs);
    yn(this, Es, new Map);
    yn(this, js, ee(0));
    yn(this, ua, ee(0));
    yn(this, bd, iy || -1);
    if (t) {
      for (var [w, z] of t) super.set(w, z);
      We(this, ua).v = super.size
    }
  }
  has(t) {
    var w = We(this, Es),
      z = w.get(t);
    if (z === void 0) {
      var E = super.get(t);
      if (E !== void 0) z = tn(this, xs, Nl).call(this, 0), w.set(t, z);
      else return y(We(this, js)), !1
    }
    return y(z), !0
  }
  forEach(t, w) {
    tn(this, xs, id).call(this), super.forEach(t, w)
  }
  get(t) {
    var w = We(this, Es),
      z = w.get(t);
    if (z === void 0) {
      var E = super.get(t);
      if (E !== void 0) z = tn(this, xs, Nl).call(this, 0), w.set(t, z);
      else {
        y(We(this, js));
        return
      }
    }
    return y(z), super.get(t)
  }
  set(t, w) {
    var tt;
    var z = We(this, Es),
      E = z.get(t),
      k = super.get(t),
      c = super.set(t, w),
      R = We(this, js);
    if (E === void 0) E = tn(this, xs, Nl).call(this, 0), z.set(t, E), Y(We(this, ua), super.size), ql(R);
    else if (k !== w) {
      ql(E);
      var X = R.reactions === null ? null : new Set(R.reactions),
        $ = X === null || !((tt = E.reactions) != null && tt.every(ut => X.has(ut)));
      $ && ql(R)
    }
    return c
  }
  delete(t) {
    var w = We(this, Es),
      z = w.get(t),
      E = super.delete(t);
    return z !== void 0 && (w.delete(t), Y(We(this, ua), super.size), Y(z, -1), ql(We(this, js))), E
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var t = We(this, Es);
      Y(We(this, ua), 0);
      for (var w of t.values()) Y(w, -1);
      ql(We(this, js)), t.clear()
    }
  }
  keys() {
    return y(We(this, js)), super.keys()
  }
  values() {
    return tn(this, xs, id).call(this), super.values()
  }
  entries() {
    return tn(this, xs, id).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return y(We(this, ua)), super.size
  }
};
Es = new WeakMap, js = new WeakMap, ua = new WeakMap, bd = new WeakMap, xs = new WeakSet, Nl = function(t) {
  return iy === We(this, bd) ? ee(t) : kx(t)
}, id = function() {
  y(We(this, js));
  var t = We(this, Es);
  if (We(this, ua).v !== t.size) {
    for (var w of ny(dm.prototype, this, "keys").call(this))
      if (!t.has(w)) {
        var z = tn(this, xs, Nl).call(this, 0);
        t.set(w, z)
      }
  }
  for ([, z] of We(this, Es)) y(z)
};
let md = dm;
const j1 = () => "OR",
  L1 = () => "OU",
  D1 = () => "æˆ–",
  R1 = () => "ODER",
  B1 = () => "O",
  F1 = () => "OU",
  O1 = () => "O",
  q1 = () => "ã¾ãŸã¯",
  N1 = () => "LUB",
  V1 = () => "Ğ˜Ğ›Ğ˜",
  U1 = () => "ĞĞ‘Ğ",
  Z1 = () => "HOáº¶C",
  G1 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? j1() : t === "pt" ? L1() : t === "ch" ? D1() : t === "de" ? R1() : t === "es" ? B1() : t === "fr" ? F1() : t === "it" ? O1() : t === "jp" ? q1() : t === "pl" ? N1() : t === "ru" ? V1() : t === "uk" ? U1() : Z1()
  },
  H1 = () => "SPACE",
  W1 = () => "ESPAÃ‡O",
  $1 = () => "ç©ºæ ¼é”®",
  X1 = () => "LEERTASTE",
  Y1 = () => "ESPACIO",
  K1 = () => "ESPACE",
  J1 = () => "SPAZIO",
  Q1 = () => "ã‚¹ãƒšãƒ¼ã‚¹",
  tw = () => "SPACJA",
  ew = () => "ĞŸĞ ĞĞ‘Ğ•Ğ›",
  rw = () => "ĞŸĞ ĞĞ‘Ğ†Ğ›",
  nw = () => "PHÃM CÃCH",
  iw = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? H1() : t === "pt" ? W1() : t === "ch" ? $1() : t === "de" ? X1() : t === "es" ? Y1() : t === "fr" ? K1() : t === "it" ? J1() : t === "jp" ? Q1() : t === "pl" ? tw() : t === "ru" ? ew() : t === "uk" ? rw() : nw()
  },
  ow = () => "Account Enforcement Policy and Code of Conduct",
  sw = () => "PolÃ­tica de AplicaÃ§Ã£o da Conta e CÃ³digo de Conduta",
  aw = () => "è´¦å·æ‰§è¡Œæ”¿ç­–ä¸è¡Œä¸ºå®ˆåˆ™",
  uw = () => "Richtlinie zur Kontodurchsetzung und Verhaltenskodex",
  cw = () => "PolÃ­tica de Cumplimiento de Cuenta y CÃ³digo de Conducta",
  lw = () => "Politique dâ€™application du compte et Code de conduite",
  _w = () => "Norme di applicazione dell'account e Codice di condotta",
  hw = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆåˆ¶è£ãƒãƒªã‚·ãƒ¼ã¨è¡Œå‹•è¦ç¯„",
  dw = () => "Polityka egzekwowania zasad konta i kodeks postÄ™powania",
  pw = () => "ĞŸĞ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ°Ğ½ĞºÑ†Ğ¸Ğ¹ Ğº Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°Ğ¼ Ğ¸ ĞšĞ¾Ğ´ĞµĞºÑ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ",
  fw = () => "ĞŸĞ¾Ğ»Ñ–Ñ‚Ğ¸ĞºĞ° Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑĞ°Ğ½ĞºÑ†Ñ–Ğ¹ Ğ´Ğ¾ Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ñ–Ğ² Ñ‚Ğ° ĞšĞ¾Ğ´ĞµĞºÑ Ğ¿Ğ¾Ğ²ĞµĞ´Ñ–Ğ½ĞºĞ¸",
  mw = () => "ChÃ­nh sÃ¡ch Xá»­ lÃ½ TÃ i khoáº£n vÃ  Quy táº¯c á»¨ng xá»­",
  gw = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ow() : t === "pt" ? sw() : t === "ch" ? aw() : t === "de" ? uw() : t === "es" ? cw() : t === "fr" ? lw() : t === "it" ? _w() : t === "jp" ? hw() : t === "pl" ? dw() : t === "ru" ? pw() : t === "uk" ? fw() : mw()
  },
  yw = () => "Account successfully deleted",
  vw = () => "Conta deletada com sucesso",
  bw = () => "è´¦å·å·²æˆåŠŸåˆ é™¤",
  xw = () => "Konto erfolgreich gelÃ¶scht",
  ww = () => "Cuenta eliminada correctamente",
  kw = () => "Compte supprimÃ© avec succÃ¨s",
  Tw = () => "Account eliminato con successo",
  Sw = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚",
  Pw = () => "Konto zostaÅ‚o pomyÅ›lnie usuniÄ™te",
  Mw = () => "ĞĞºĞºĞ°ÑƒĞ½Ñ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½",
  Cw = () => "ĞĞ±Ğ»Ñ–ĞºĞ¾Ğ²Ğ¸Ğ¹ Ğ·Ğ°Ğ¿Ğ¸Ñ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ¾",
  Iw = () => "ÄÃ£ xÃ³a tÃ i khoáº£n thÃ nh cÃ´ng",
  zw = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? yw() : t === "pt" ? vw() : t === "ch" ? bw() : t === "de" ? xw() : t === "es" ? ww() : t === "fr" ? kw() : t === "it" ? Tw() : t === "jp" ? Sw() : t === "pl" ? Pw() : t === "ru" ? Mw() : t === "uk" ? Cw() : Iw()
  },
  Aw = () => "Add a new 16x16 profile picture",
  Ew = () => "Adicionar uma nova imagem de perfil 16x16",
  jw = () => "æ·»åŠ æ–°çš„ 16x16 å¤´åƒ",
  Lw = () => "Neues 16x16-Profilbild hinzufÃ¼gen",
  Dw = () => "AÃ±adir una nueva imagen de perfil 16x16",
  Rw = () => "Ajouter une nouvelle image de profil 16x16",
  Bw = () => "Aggiungi una nuova immagine del profilo 16x16",
  Fw = () => "æ–°ã—ã„16x16ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒã‚’è¿½åŠ ã™ã‚‹",
  Ow = () => "Dodaj nowy awatar 16x16",
  qw = () => "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ 16x16",
  Nw = () => "Ğ”Ğ¾Ğ´Ğ°Ñ‚Ğ¸ Ğ½Ğ¾Ğ²Ğµ Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»Ñ 16x16",
  Vw = () => "ThÃªm áº£nh Ä‘áº¡i diá»‡n má»›i 16x16",
  Uw = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Aw() : t === "pt" ? Ew() : t === "ch" ? jw() : t === "de" ? Lw() : t === "es" ? Dw() : t === "fr" ? Rw() : t === "it" ? Bw() : t === "jp" ? Fw() : t === "pl" ? Ow() : t === "ru" ? qw() : t === "uk" ? Nw() : Vw()
  },
  Zw = () => "All time",
  Gw = () => "Geral",
  Hw = () => "å…¨éƒ¨æ—¶é—´",
  Ww = () => "Gesamt",
  $w = () => "Todo el tiempo",
  Xw = () => "Tout le temps",
  Yw = () => "Tutto il tempo",
  Kw = () => "å…¨æœŸé–“",
  Jw = () => "CaÅ‚y czas",
  Qw = () => "Ğ—Ğ° Ğ²ÑÑ‘ Ğ²Ñ€ĞµĞ¼Ñ",
  t2 = () => "Ğ—Ğ° Ğ²ĞµÑÑŒ Ñ‡Ğ°Ñ",
  e2 = () => "ToÃ n thá»i gian",
  r2 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Zw() : t === "pt" ? Gw() : t === "ch" ? Hw() : t === "de" ? Ww() : t === "es" ? $w() : t === "fr" ? Xw() : t === "it" ? Yw() : t === "jp" ? Kw() : t === "pl" ? Jw() : t === "ru" ? Qw() : t === "uk" ? t2() : e2()
  },
  n2 = () => "Alliance Name",
  i2 = () => "Nome da alianÃ§a",
  o2 = () => "è”ç›Ÿåç§°",
  s2 = () => "Allianznamen",
  a2 = () => "Nombre de la alianza",
  u2 = () => "Nom de lâ€™alliance",
  c2 = () => "Nome dell'alleanza",
  l2 = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å",
  _2 = () => "Nazwa sojuszu",
  h2 = () => "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°Ğ»ÑŒÑĞ½ÑĞ°",
  d2 = () => "ĞĞ°Ğ·Ğ²Ğ° Ğ°Ğ»ÑŒÑĞ½ÑÑƒ",
  p2 = () => "TÃªn liÃªn minh",
  f2 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? n2() : t === "pt" ? i2() : t === "ch" ? o2() : t === "de" ? s2() : t === "es" ? a2() : t === "fr" ? u2() : t === "it" ? c2() : t === "jp" ? l2() : t === "pl" ? _2() : t === "ru" ? h2() : t === "uk" ? d2() : p2()
  },
  m2 = l => `+${l.amount} Max. Charges`,
  g2 = l => `+${l.amount} Tinta mÃ¡xima`,
  y2 = l => `+${l.amount} æœ€å¤§å……èƒ½ä¸Šé™`,
  v2 = l => `+${l.amount} maximale Ladungen`,
  b2 = l => `+${l.amount} cargas mÃ¡ximas`,
  x2 = l => `+${l.amount} charges max`,
  w2 = l => `+${l.amount} cariche massime`,
  k2 = l => `æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸ +${l.amount}`,
  T2 = l => `+${l.amount} maks. Å‚adunkÃ³w`,
  S2 = l => `+${l.amount} Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²`,
  P2 = l => `+${l.amount} Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ²`,
  M2 = l => `+${l.amount} lÆ°á»£t tÃ´ tá»‘i Ä‘a`,
  C2 = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? m2(l) : t === "pt" ? g2(l) : t === "ch" ? y2(l) : t === "de" ? v2(l) : t === "es" ? b2(l) : t === "fr" ? x2(l) : t === "it" ? w2(l) : t === "jp" ? k2(l) : t === "pl" ? T2(l) : t === "ru" ? S2(l) : t === "uk" ? P2(l) : M2(l)
  },
  I2 = l => `+${l.amount} Paint Charges`,
  z2 = l => `+${l.amount} Tintas`,
  A2 = l => `+${l.amount} ç»˜åˆ¶å……èƒ½`,
  E2 = l => `+${l.amount} Pixel-Ladungen`,
  j2 = l => `+${l.amount} cargas de pintura`,
  L2 = l => `+${l.amount} charges de peinture`,
  D2 = l => `+${l.amount} cariche di vernice`,
  R2 = l => `ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸ +${l.amount}`,
  B2 = l => `+${l.amount} Å‚adunkÃ³w malowania`,
  F2 = l => `+${l.amount} Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²`,
  O2 = l => `+${l.amount} Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ² Ñ„Ğ°Ñ€Ğ±Ğ¸`,
  q2 = l => `+${l.amount} lÆ°á»£t tÃ´`,
  N2 = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? I2(l) : t === "pt" ? z2(l) : t === "ch" ? A2(l) : t === "de" ? E2(l) : t === "es" ? j2(l) : t === "fr" ? L2(l) : t === "it" ? D2(l) : t === "jp" ? R2(l) : t === "pl" ? B2(l) : t === "ru" ? F2(l) : t === "uk" ? O2(l) : q2(l)
  },
  V2 = () => "and move your cursor over the map.",
  U2 = () => "e mova seu cursor sobre o mapa.",
  Z2 = () => "ç„¶åæŠŠé¼ æ ‡ç§»åŠ¨åˆ°åœ°å›¾ä¸Šã€‚",
  G2 = () => "gedrÃ¼ckt und bewege deinen Cursor Ã¼ber die Karte.",
  H2 = () => "y mueve el cursor sobre el mapa.",
  W2 = () => "et dÃ©placez votre curseur sur la carte.",
  $2 = () => "e muovi il cursore sopra la mappa.",
  X2 = () => "ãã—ã¦ã€ãƒãƒƒãƒ—ä¸Šã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã—ã¦ãã ã•ã„ã€‚",
  Y2 = () => "i przesuÅ„ kursor po mapie.",
  K2 = () => "Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°Ğ¹Ñ‚Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ğµ.",
  J2 = () => "Ñ– Ğ¿Ñ€Ğ¾Ğ²ĞµĞ´Ñ–Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ñ–.",
  Q2 = () => "vÃ  di chuyá»ƒn con trá» cá»§a báº¡n trÃªn báº£n Ä‘á»“.",
  tk = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? V2() : t === "pt" ? U2() : t === "ch" ? Z2() : t === "de" ? G2() : t === "es" ? H2() : t === "fr" ? W2() : t === "it" ? $2() : t === "jp" ? X2() : t === "pl" ? Y2() : t === "ru" ? K2() : t === "uk" ? J2() : Q2()
  },
  ek = l => `You can send another appeal in ${l.days} days`,
  rk = l => `VocÃª pode enviar outro apelo em ${l.days} dias`,
  nk = l => `ä½ å¯ä»¥åœ¨ ${l.days} å¤©åå†æ¬¡æäº¤ç”³è¯‰`,
  ik = l => `Du kannst in ${l.days} Tagen erneut Einspruch einlegen`,
  ok = l => `PodrÃ¡s enviar otra apelaciÃ³n en ${l.days} dÃ­as`,
  sk = l => `Vous pouvez envoyer un nouveau recours dans ${l.days} jours`,
  ak = l => `Puoi inviare un altro ricorso tra ${l.days} giorni`,
  uk = l => `${l.days}æ—¥å¾Œã«ã‚‚ã†ä¸€åº¦ç•°è­°ç”³ç«‹ã¦ã‚’é€ä¿¡ã§ãã¾ã™ã€‚`,
  ck = l => `MoÅ¼esz wysÅ‚aÄ‡ kolejne odwoÅ‚anie za ${l.days} dni`,
  lk = l => `Ğ’Ñ‹ ÑĞ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ Ğ°Ğ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· ${l.days} Ğ´Ğ½.`,
  _k = l => `Ğ’Ğ¸ Ğ·Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ½Ğ°Ğ´Ñ–ÑĞ»Ğ°Ñ‚Ğ¸ Ñ‰Ğµ Ğ¾Ğ´Ğ½Ñƒ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ Ñ‡ĞµÑ€ĞµĞ· ${l.days} Ğ´Ğ½Ñ–Ğ²`,
  hk = l => `Báº¡n cÃ³ thá»ƒ gá»­i khÃ¡ng cÃ¡o khÃ¡c sau ${l.days} ngÃ y`,
  dk = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ek(l) : t === "pt" ? rk(l) : t === "ch" ? nk(l) : t === "de" ? ik(l) : t === "es" ? ok(l) : t === "fr" ? sk(l) : t === "it" ? ak(l) : t === "jp" ? uk(l) : t === "pl" ? ck(l) : t === "ru" ? lk(l) : t === "uk" ? _k(l) : hk(l)
  },
  pk = () => `If you believe your suspension was a mistake, you can send one appeal <b>every 90 days</b> to have your case reviewed again.

Please note that submitting an appeal <b>does not guarantee that your suspension will be lifted</b>; however, our team will review your situation.

Reviews usually take up to <b>a week</b>.`,
  fk = () => `Se vocÃª acredita que sua suspensÃ£o foi um erro, vocÃª pode enviar um apelo <b>a cada 90 dias</b> para que seu caso seja revisado novamente.

Por favor, note que enviar um recurso <b>nÃ£o garante que sua suspensÃ£o serÃ¡ removida</b>; no entanto, nossa equipe analisarÃ¡ a sua situaÃ§Ã£o novamente.

As revisÃµes geralmente levam atÃ© <b>uma semana</b>.`,
  mk = () => `å¦‚æœä½ è®¤ä¸ºä½ çš„å°ç¦æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œä½ å¯ä»¥æ¯ <b>90 å¤©</b> æäº¤ä¸€æ¬¡ç”³è¯‰ï¼Œä»¥ä¾¿æˆ‘ä»¬é‡æ–°å®¡æ ¸ä½ çš„æƒ…å†µã€‚

è¯·æ³¨æ„ï¼Œæäº¤ç”³è¯‰<b>å¹¶ä¸ä¿è¯</b>ä¼šè§£é™¤å°ç¦ï¼Œä½†æˆ‘ä»¬çš„å›¢é˜Ÿä¼šé‡æ–°å®¡æŸ¥ä½ çš„æƒ…å†µã€‚

å®¡æ ¸é€šå¸¸æœ€å¤šéœ€è¦ <b>ä¸€å‘¨</b> æ—¶é—´ã€‚`,
  gk = () => `Wenn du glaubst, dass deine Sperre ein Fehler war, kannst du alle <b>90 Tage</b> einen Einspruch einreichen, damit dein Fall erneut geprÃ¼ft wird.

Bitte beachte, dass das Einreichen eines Einspruchs <b>nicht garantiert, dass deine Sperre aufgehoben wird</b>; unser Team wird deine Situation jedoch prÃ¼fen.

ÃœberprÃ¼fungen dauern in der Regel bis zu <b>eine Woche</b>.`,
  yk = () => `Si crees que tu suspensiÃ³n fue un error, puedes enviar una apelaciÃ³n <b>cada 90 dÃ­as</b> para que tu caso sea revisado de nuevo.

Ten en cuenta que enviar una apelaciÃ³n <b>no garantiza que se levante la suspensiÃ³n</b>; sin embargo, nuestro equipo revisarÃ¡ tu situaciÃ³n.

Las revisiones suelen tardar hasta <b>una semana</b>.`,
  vk = () => `Si vous pensez que votre suspension est une erreur, vous pouvez envoyer un recours <b>tous les 90 jours</b> pour que votre cas soit rÃ©examinÃ©.

Veuillez noter que lâ€™envoi dâ€™un recours <b>ne garantit pas que votre suspension sera levÃ©e</b>; cependant, notre Ã©quipe analysera votre situation.

Les analyses prennent gÃ©nÃ©ralement jusquâ€™Ã  <b>une semaine</b>.`,
  bk = () => `Se ritieni che la tua sospensione sia un errore, puoi inviare un ricorso <b>ogni 90 giorni</b> per far riesaminare il tuo caso.

Tieni presente che l'invio di un ricorso <b>non garantisce che la sospensione venga rimossa</b>; tuttavia, il nostro team analizzerÃ  di nuovo la tua situazione.

Le revisioni solitamente richiedono fino a <b>una settimana</b>.`,
  xk = () => `åœæ­¢ãŒèª¤ã‚Šã ã¨æ€ã†å ´åˆã¯ã€<b>90æ—¥ã”ã¨ã«1å›</b>ç•°è­°ç”³ç«‹ã¦ã‚’é€ä¿¡ã—ã€å†å¯©æŸ»ã‚’ä¾é ¼ã§ãã¾ã™ã€‚

ãŸã ã—ã€ç•°è­°ç”³ç«‹ã¦ã‚’è¡Œã£ã¦ã‚‚<b>å¿…ãšã—ã‚‚åœæ­¢ãŒè§£é™¤ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“</b>ã€‚ãƒãƒ¼ãƒ ãŒçŠ¶æ³ã‚’ç¢ºèªã—ã¾ã™ã€‚

å¯©æŸ»ã«ã¯é€šå¸¸<b>æœ€å¤§1é€±é–“</b>ã‹ã‹ã‚Šã¾ã™ã€‚`,
  wk = () => `JeÅ›li uwaÅ¼asz, Å¼e Twoje zawieszenie jest bÅ‚Ä™dem, moÅ¼esz wysÅ‚aÄ‡ jedno odwoÅ‚anie <b>co 90 dni</b>, aby ponownie rozpatrzyÄ‡ TwojÄ… sprawÄ™.

PamiÄ™taj, Å¼e wysÅ‚anie odwoÅ‚ania <b>nie gwarantuje, Å¼e zawieszenie zostanie zniesione</b>; nasz zespÃ³Å‚ ponownie przeanalizuje jednak TwojÄ… sytuacjÄ™.

Rozpatrywanie zwykle trwa do <b>tygodnia</b>.`,
  kk = () => `Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ ÑÑ‡Ğ¸Ñ‚Ğ°ĞµÑ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°ÑˆĞ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ±Ñ‹Ğ»Ğ° Ğ²Ñ‹Ğ½ĞµÑĞµĞ½Ğ° Ğ¿Ğ¾ Ğ¾ÑˆĞ¸Ğ±ĞºĞµ, Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ°Ğ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ <b>Ñ€Ğ°Ğ· Ğ² 90 Ğ´Ğ½ĞµĞ¹</b>, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ğ°Ñˆ ÑĞ»ÑƒÑ‡Ğ°Ğ¹ Ğ±Ñ‹Ğ» Ğ¿ĞµÑ€ĞµÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½.

ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ´Ğ°Ñ‡Ğ° Ğ°Ğ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ğ¸ <b>Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ½ÑÑ‚Ğ¸Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸</b>, Ğ¾Ğ´Ğ½Ğ°ĞºĞ¾ Ğ½Ğ°ÑˆĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ²Ğ°ÑˆÑƒ ÑĞ¸Ñ‚ÑƒĞ°Ñ†Ğ¸Ñ.

ĞĞ±Ñ‹Ñ‡Ğ½Ğ¾ Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ´Ğ¾ <b>Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ½ĞµĞ´ĞµĞ»Ğ¸</b>.`,
  Tk = () => `Ğ¯ĞºÑ‰Ğ¾ Ğ²Ğ¸ Ğ²Ğ²Ğ°Ğ¶Ğ°Ñ”Ñ‚Ğµ, Ñ‰Ğ¾ Ğ²Ğ°ÑˆÑƒ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ±ÑƒĞ»Ğ¾ Ğ·Ğ´Ñ–Ğ¹ÑĞ½ĞµĞ½Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¾Ğ²Ğ¾, Ğ²Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ½Ğ°Ğ´ÑĞ¸Ğ»Ğ°Ñ‚Ğ¸ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ <b>Ñ€Ğ°Ğ· Ğ½Ğ° 90 Ğ´Ğ½Ñ–Ğ²</b>, Ñ‰Ğ¾Ğ± Ğ¼Ğ¸ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾ Ñ€Ğ¾Ğ·Ğ³Ğ»ÑĞ½ÑƒĞ»Ğ¸ Ğ²Ğ°Ñˆ Ğ²Ğ¸Ğ¿Ğ°Ğ´Ğ¾Ğº.

Ğ—Ğ²ĞµÑ€Ğ½Ñ–Ñ‚ÑŒ ÑƒĞ²Ğ°Ğ³Ñƒ, Ñ‰Ğ¾ Ğ½Ğ°Ğ´ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ— <b>Ğ½Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚ÑƒÑ” Ğ·Ğ½ÑÑ‚Ñ‚Ñ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ</b>, Ğ¾Ğ´Ğ½Ğ°Ğº Ğ½Ğ°ÑˆĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ½Ğµ Ğ²Ğ°ÑˆÑƒ ÑĞ¸Ñ‚ÑƒĞ°Ñ†Ñ–Ñ.

Ğ—Ğ°Ğ·Ğ²Ğ¸Ñ‡Ğ°Ğ¹ Ñ€Ğ¾Ğ·Ğ³Ğ»ÑĞ´ Ğ·Ğ°Ğ¹Ğ¼Ğ°Ñ” Ğ´Ğ¾ <b>Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¶Ğ½Ñ</b>.`,
  Sk = () => `Náº¿u báº¡n tin ráº±ng viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n lÃ  má»™t sai sÃ³t, báº¡n cÃ³ thá»ƒ gá»­i má»™t khÃ¡ng cÃ¡o <b>má»—i 90 ngÃ y</b> Ä‘á»ƒ yÃªu cáº§u xem xÃ©t láº¡i.

LÆ°u Ã½ ráº±ng gá»­i khÃ¡ng cÃ¡o <b>khÃ´ng Ä‘áº£m báº£o tÃ i khoáº£n cá»§a báº¡n sáº½ Ä‘Æ°á»£c má»Ÿ khÃ³a</b>; tuy nhiÃªn Ä‘á»™i ngÅ© cá»§a chÃºng tÃ´i sáº½ xem xÃ©t láº¡i trÆ°á»ng há»£p cá»§a báº¡n.

Viá»‡c xem xÃ©t thÆ°á»ng máº¥t Ä‘áº¿n <b>má»™t tuáº§n</b>.`,
  Pk = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pk() : t === "pt" ? fk() : t === "ch" ? mk() : t === "de" ? gk() : t === "es" ? yk() : t === "fr" ? vk() : t === "it" ? bk() : t === "jp" ? xk() : t === "pl" ? wk() : t === "ru" ? kk() : t === "uk" ? Tk() : Sk()
  },
  Mk = () => "Why your suspension should be lifted?",
  Ck = () => "Por que sua suspensÃ£o deve ser reconsiderada?",
  Ik = () => "ä¸ºä»€ä¹ˆåº”è¯¥è§£é™¤ä½ çš„å°ç¦ï¼Ÿ",
  zk = () => "Warum sollte deine Sperre aufgehoben werden?",
  Ak = () => "Â¿Por quÃ© deberÃ­a levantarse tu suspensiÃ³n?",
  Ek = () => "Pourquoi votre suspension devrait-elle Ãªtre levÃ©e ?",
  jk = () => "PerchÃ© la tua sospensione dovrebbe essere rivalutata?",
  Lk = () => "ãªãœåœæ­¢ã‚’è§£é™¤ã™ã¹ãã ã¨æ€ã†ã®ã‹æ•™ãˆã¦ãã ã•ã„ã€‚",
  Dk = () => "Dlaczego Twoje zawieszenie powinno zostaÄ‡ cofniÄ™te?",
  Rk = () => "ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ, Ğ¿Ğ¾ Ğ²Ğ°ÑˆĞµĞ¼Ñƒ Ğ¼Ğ½ĞµĞ½Ğ¸Ñ, Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ ÑĞ½ÑÑ‚Ğ°?",
  Bk = () => "Ğ§Ğ¾Ğ¼Ñƒ, Ğ½Ğ° Ğ²Ğ°ÑˆÑƒ Ğ´ÑƒĞ¼ĞºÑƒ, Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¼Ğ°Ñ” Ğ±ÑƒÑ‚Ğ¸ ÑĞºĞ°ÑĞ¾Ğ²Ğ°Ğ½Ğ¾?",
  Fk = () => "VÃ¬ sao viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n cá»§a báº¡n nÃªn Ä‘Æ°á»£c gá»¡ bá»?",
  Ok = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Mk() : t === "pt" ? Ck() : t === "ch" ? Ik() : t === "de" ? zk() : t === "es" ? Ak() : t === "fr" ? Ek() : t === "it" ? jk() : t === "jp" ? Lk() : t === "pl" ? Dk() : t === "ru" ? Rk() : t === "uk" ? Bk() : Fk()
  },
  qk = () => "Tell us why you think your suspension should be reconsidered",
  Nk = () => "Explique por que vocÃª acha que sua suspensÃ£o deve ser reconsiderada",
  Vk = () => "å‘Šè¯‰æˆ‘ä»¬ä½ è®¤ä¸ºå°ç¦åº”è¢«é‡æ–°è€ƒè™‘çš„åŸå› ",
  Uk = () => "ErklÃ¤re uns, warum deine Sperre deiner Meinung nach Ã¼berprÃ¼ft werden sollte",
  Zk = () => "CuÃ©ntanos por quÃ© crees que tu suspensiÃ³n deberÃ­a ser reconsiderada",
  Gk = () => "Expliquez-nous pourquoi vous pensez que votre suspension devrait Ãªtre reconsidÃ©rÃ©e",
  Hk = () => "Spiega perchÃ© ritieni che la tua sospensione dovrebbe essere rivista",
  Wk = () => "åœæ­¢ã‚’å†æ¤œè¨ã™ã¹ãã ã¨æ€ã†ç†ç”±ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
  $k = () => "WyjaÅ›nij, dlaczego Twoje zawieszenie powinno zostaÄ‡ ponownie rozwaÅ¼one",
  Xk = () => "Ğ Ğ°ÑÑĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ Ğ²Ñ‹ ÑÑ‡Ğ¸Ñ‚Ğ°ĞµÑ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°ÑˆÑƒ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ ÑÑ‚Ğ¾Ğ¸Ñ‚ Ğ¿ĞµÑ€ĞµÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ",
  Yk = () => "ĞĞ¿Ğ¸ÑˆÑ–Ñ‚ÑŒ, Ñ‡Ğ¾Ğ¼Ñƒ Ğ²Ğ¸ Ğ²Ğ²Ğ°Ğ¶Ğ°Ñ”Ñ‚Ğµ, Ñ‰Ğ¾ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑĞ»Ñ–Ğ´ Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ½ÑƒÑ‚Ğ¸",
  Kk = () => "HÃ£y cho chÃºng tÃ´i biáº¿t vÃ¬ sao báº¡n nghÄ© viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n nÃªn Ä‘Æ°á»£c xem xÃ©t láº¡i",
  Jk = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qk() : t === "pt" ? Nk() : t === "ch" ? Vk() : t === "de" ? Uk() : t === "es" ? Zk() : t === "fr" ? Gk() : t === "it" ? Hk() : t === "jp" ? Wk() : t === "pl" ? $k() : t === "ru" ? Xk() : t === "uk" ? Yk() : Kk()
  },
  Qk = () => "Appeal sent successfully",
  t5 = () => "Apelo enviado com sucesso",
  e5 = () => "ç”³è¯‰å·²æˆåŠŸå‘é€",
  r5 = () => "Einspruch erfolgreich gesendet",
  n5 = () => "ApelaciÃ³n enviada correctamente",
  i5 = () => "Recours envoyÃ© avec succÃ¨s",
  o5 = () => "Ricorso inviato con successo",
  s5 = () => "ç•°è­°ç”³ç«‹ã¦ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚",
  a5 = () => "OdwoÅ‚anie zostaÅ‚o pomyÅ›lnie wysÅ‚ane",
  u5 = () => "ĞĞ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ°",
  c5 = () => "ĞĞ¿ĞµĞ»ÑÑ†Ñ–Ñ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ½Ğ°Ğ´Ñ–ÑĞ»Ğ°Ğ½Ğ¾",
  l5 = () => "ÄÃ£ gá»­i khÃ¡ng cÃ¡o thÃ nh cÃ´ng",
  _5 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Qk() : t === "pt" ? t5() : t === "ch" ? e5() : t === "de" ? r5() : t === "es" ? n5() : t === "fr" ? i5() : t === "it" ? o5() : t === "jp" ? s5() : t === "pl" ? a5() : t === "ru" ? u5() : t === "uk" ? c5() : l5()
  },
  h5 = () => "Are you absolutely sure?",
  d5 = () => "VocÃª tem certeza absoluta?",
  p5 = () => "ä½ ç¡®å®šå—ï¼Ÿ",
  f5 = () => "Bist du dir absolut sicher?",
  m5 = () => "Â¿EstÃ¡s absolutamente seguro?",
  g5 = () => "ÃŠtes-vous absolument sÃ»r ?",
  y5 = () => "Sei assolutamente sicuro?",
  v5 = () => "æœ¬å½“ã«å®Ÿè¡Œã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
  b5 = () => "Czy na pewno chcesz to zrobiÄ‡?",
  x5 = () => "Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹?",
  w5 = () => "Ğ’Ğ¸ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾ Ğ²Ğ¿ĞµĞ²Ğ½ĞµĞ½Ñ–?",
  k5 = () => "Báº¡n cÃ³ thá»±c sá»± cháº¯c cháº¯n?",
  T5 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? h5() : t === "pt" ? d5() : t === "ch" ? p5() : t === "de" ? f5() : t === "es" ? m5() : t === "fr" ? g5() : t === "it" ? y5() : t === "jp" ? v5() : t === "pl" ? b5() : t === "ru" ? x5() : t === "uk" ? w5() : k5()
  },
  S5 = () => "Ban appeal",
  P5 = () => "RevisÃ£o de banimento",
  M5 = () => "å°ç¦ç”³è¯‰",
  C5 = () => "Bann-Einspruch",
  I5 = () => "ApelaciÃ³n de ban",
  z5 = () => "Recours de bannissement",
  A5 = () => "Ricorso contro il ban",
  E5 = () => "BANã®ç•°è­°ç”³ç«‹ã¦",
  j5 = () => "OdwoÅ‚anie od bana",
  L5 = () => "ĞĞ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ Ğ½Ğ° Ğ±Ğ°Ğ½",
  D5 = () => "ĞĞ¿ĞµĞ»ÑÑ†Ñ–Ñ Ğ½Ğ° Ğ±Ğ°Ğ½",
  R5 = () => "KhÃ¡ng cÃ¡o lá»‡nh cáº¥m",
  hv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? S5() : t === "pt" ? P5() : t === "ch" ? M5() : t === "de" ? C5() : t === "es" ? I5() : t === "fr" ? z5() : t === "it" ? A5() : t === "jp" ? E5() : t === "pl" ? j5() : t === "ru" ? L5() : t === "uk" ? D5() : R5()
  },
  B5 = () => "Ban from alliance",
  F5 = () => "Banir da alianÃ§a",
  O5 = () => "ä»è”ç›Ÿä¸­å°ç¦",
  q5 = () => "Aus Allianz bannen",
  N5 = () => "Banear de la alianza",
  V5 = () => "Bannir de lâ€™alliance",
  U5 = () => "Banna dall'alleanza",
  Z5 = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‹ã‚‰BAN",
  G5 = () => "Zbanuj z sojuszu",
  H5 = () => "Ğ—Ğ°Ğ±Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑĞµ",
  W5 = () => "Ğ—Ğ°Ğ±Ğ°Ğ½Ğ¸Ñ‚Ğ¸ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑÑ–",
  $5 = () => "Cáº¥m khá»i liÃªn minh",
  dv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? B5() : t === "pt" ? F5() : t === "ch" ? O5() : t === "de" ? q5() : t === "es" ? N5() : t === "fr" ? V5() : t === "it" ? U5() : t === "jp" ? Z5() : t === "pl" ? G5() : t === "ru" ? H5() : t === "uk" ? W5() : $5()
  },
  X5 = l => `Reason: ${l.reason}`,
  Y5 = l => `Motivo: ${l.reason}`,
  K5 = l => `åŸå› ï¼š${l.reason}`,
  J5 = l => `Grund: ${l.reason}`,
  Q5 = l => `Motivo: ${l.reason}`,
  t3 = l => `Raison : ${l.reason}`,
  e3 = l => `Motivo: ${l.reason}`,
  r3 = l => `ç†ç”±: ${l.reason}`,
  n3 = l => `PowÃ³d: ${l.reason}`,
  i3 = l => `ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: ${l.reason}`,
  o3 = l => `ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: ${l.reason}`,
  s3 = l => `LÃ½ do: ${l.reason}`,
  _y = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? X5(l) : t === "pt" ? Y5(l) : t === "ch" ? K5(l) : t === "de" ? J5(l) : t === "es" ? Q5(l) : t === "fr" ? t3(l) : t === "it" ? e3(l) : t === "jp" ? r3(l) : t === "pl" ? n3(l) : t === "ru" ? i3(l) : t === "uk" ? o3(l) : s3(l)
  },
  a3 = () => "Bug report",
  u3 = () => "Reportar bug",
  c3 = () => "é”™è¯¯æŠ¥å‘Š",
  l3 = () => "Bug melden",
  _3 = () => "Reporte de bug",
  h3 = () => "Signaler un bug",
  d3 = () => "Segnala bug",
  p3 = () => "ãƒã‚°å ±å‘Š",
  f3 = () => "ZgÅ‚oszenie bÅ‚Ä™du",
  m3 = () => "Ğ¡Ğ¾Ğ¾Ğ±Ñ‰Ğ¸Ñ‚ÑŒ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ",
  g3 = () => "Ğ—Ğ²Ñ–Ñ‚ Ğ¿Ñ€Ğ¾ Ğ±Ğ°Ğ³",
  y3 = () => "BÃ¡o lá»—i",
  v3 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? a3() : t === "pt" ? u3() : t === "ch" ? c3() : t === "de" ? l3() : t === "es" ? _3() : t === "fr" ? h3() : t === "it" ? d3() : t === "jp" ? p3() : t === "pl" ? f3() : t === "ru" ? m3() : t === "uk" ? g3() : y3()
  },
  b3 = () => "Change language",
  x3 = () => "Mudar idioma",
  w3 = () => "æ›´æ”¹è¯­è¨€",
  k3 = () => "Sprache Ã¤ndern",
  T3 = () => "Cambiar idioma",
  S3 = () => "Changer de langue",
  P3 = () => "Cambia lingua",
  M3 = () => "è¨€èªã‚’å¤‰æ›´",
  C3 = () => "ZmieÅ„ jÄ™zyk",
  I3 = () => "Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº",
  z3 = () => "Ğ—Ğ¼Ñ–Ğ½Ğ¸Ñ‚Ğ¸ Ğ¼Ğ¾Ğ²Ñƒ",
  A3 = () => "Thay Ä‘á»•i ngÃ´n ngá»¯",
  E3 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? b3() : t === "pt" ? x3() : t === "ch" ? w3() : t === "de" ? k3() : t === "es" ? T3() : t === "fr" ? S3() : t === "it" ? P3() : t === "jp" ? M3() : t === "pl" ? C3() : t === "ru" ? I3() : t === "uk" ? z3() : A3()
  },
  j3 = () => "Change picture:",
  L3 = () => "Trocar imagem:",
  D3 = () => "æ›´æ¢å¤´åƒï¼š",
  R3 = () => "Bild Ã¤ndern:",
  B3 = () => "Cambiar imagen:",
  F3 = () => "Changer lâ€™image :",
  O3 = () => "Cambia immagine:",
  q3 = () => "ç”»åƒã‚’å¤‰æ›´:",
  N3 = () => "ZmieÅ„ obraz:",
  V3 = () => "Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ:",
  U3 = () => "Ğ—Ğ¼Ñ–Ğ½Ğ¸Ñ‚Ğ¸ Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ:",
  Z3 = () => "Äá»•i áº£nh:",
  G3 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? j3() : t === "pt" ? L3() : t === "ch" ? D3() : t === "de" ? R3() : t === "es" ? B3() : t === "fr" ? F3() : t === "it" ? O3() : t === "jp" ? q3() : t === "pl" ? N3() : t === "ru" ? V3() : t === "uk" ? U3() : Z3()
  },
  H3 = () => "Claim",
  W3 = () => "Resgatar",
  $3 = () => "é¢†å–",
  X3 = () => "Einsammeln",
  Y3 = () => "Reclamar",
  K3 = () => "RÃ©cupÃ©rer",
  J3 = () => "Riscatta",
  Q3 = () => "å—ã‘å–ã‚‹",
  tT = () => "Odbierz",
  eT = () => "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ",
  rT = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸",
  nT = () => "Nháº­n",
  iT = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? H3() : t === "pt" ? W3() : t === "ch" ? $3() : t === "de" ? X3() : t === "es" ? Y3() : t === "fr" ? K3() : t === "it" ? J3() : t === "jp" ? Q3() : t === "pl" ? tT() : t === "ru" ? eT() : t === "uk" ? rT() : nT()
  },
  oT = () => "Claimed",
  sT = () => "Resgatado",
  aT = () => "å·²é¢†å–",
  uT = () => "Eingesammelt",
  cT = () => "Reclamado",
  lT = () => "RÃ©cupÃ©rÃ©",
  _T = () => "Riscattato",
  hT = () => "å—ã‘å–ã‚Šæ¸ˆã¿",
  dT = () => "Odebrano",
  pT = () => "ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾",
  fT = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ¾",
  mT = () => "ÄÃ£ nháº­n",
  gT = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? oT() : t === "pt" ? sT() : t === "ch" ? aT() : t === "de" ? uT() : t === "es" ? cT() : t === "fr" ? lT() : t === "it" ? _T() : t === "jp" ? hT() : t === "pl" ? dT() : t === "ru" ? pT() : t === "uk" ? fT() : mT()
  },
  yT = () => "Click",
  vT = () => "Clique",
  bT = () => "ç‚¹å‡»",
  xT = () => "Klicken",
  wT = () => "Haz clic",
  kT = () => "Cliquez",
  TT = () => "Clicca",
  ST = () => "ã‚¯ãƒªãƒƒã‚¯",
  PT = () => "Kliknij",
  MT = () => "ĞšĞ»Ğ¸Ğº",
  CT = () => "ĞšĞ»Ğ°Ñ†Ğ½Ñ–Ñ‚ÑŒ",
  IT = () => "Nháº¥p",
  zT = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? yT() : t === "pt" ? vT() : t === "ch" ? bT() : t === "de" ? xT() : t === "es" ? wT() : t === "fr" ? kT() : t === "it" ? TT() : t === "jp" ? ST() : t === "pl" ? PT() : t === "ru" ? MT() : t === "uk" ? CT() : IT()
  },
  AT = () => "Color Picker",
  ET = () => "Conta Gotas",
  jT = () => "å–è‰²å™¨",
  LT = () => "Farbpipette",
  DT = () => "Selector de color",
  RT = () => "Pipette",
  BT = () => "Contagocce",
  FT = () => "ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼",
  OT = () => "PrÃ³bnik kolorÃ³w",
  qT = () => "ĞŸĞ¸Ğ¿ĞµÑ‚ĞºĞ°",
  NT = () => "ĞŸÑ–Ğ¿ĞµÑ‚ĞºĞ°",
  VT = () => "Báº£ng chá»n mÃ u",
  UT = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? AT() : t === "pt" ? ET() : t === "ch" ? jT() : t === "de" ? LT() : t === "es" ? DT() : t === "fr" ? RT() : t === "it" ? BT() : t === "jp" ? FT() : t === "pl" ? OT() : t === "ru" ? qT() : t === "uk" ? NT() : VT()
  },
  ZT = () => "Coordinates",
  GT = () => "Coordenadas",
  HT = () => "åæ ‡",
  WT = () => "Koordinaten",
  $T = () => "Coordenadas",
  XT = () => "CoordonnÃ©es",
  YT = () => "Coordinate",
  KT = () => "åº§æ¨™",
  JT = () => "WspÃ³Å‚rzÄ™dne",
  QT = () => "ĞšĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ñ‹",
  tS = () => "ĞšĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ¸",
  eS = () => "Tá»a Ä‘á»™",
  pv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ZT() : t === "pt" ? GT() : t === "ch" ? HT() : t === "de" ? WT() : t === "es" ? $T() : t === "fr" ? XT() : t === "it" ? YT() : t === "jp" ? KT() : t === "pl" ? JT() : t === "ru" ? QT() : t === "uk" ? tS() : eS()
  },
  rS = () => "Copied",
  nS = () => "Copiado",
  iS = () => "å·²å¤åˆ¶",
  oS = () => "Kopiert",
  sS = () => "Copiado",
  aS = () => "CopiÃ©",
  uS = () => "Copiato",
  cS = () => "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  lS = () => "Skopiowano",
  _S = () => "Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾",
  hS = () => "Ğ¡ĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾",
  dS = () => "ÄÃ£ sao chÃ©p",
  Kf = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rS() : t === "pt" ? nS() : t === "ch" ? iS() : t === "de" ? oS() : t === "es" ? sS() : t === "fr" ? aS() : t === "it" ? uS() : t === "jp" ? cS() : t === "pl" ? lS() : t === "ru" ? _S() : t === "uk" ? hS() : dS()
  },
  pS = l => `Could not install the app: ${l.error}`,
  fS = l => `NÃ£o pode instalar o app: ${l.error}`,
  mS = l => `æ— æ³•å®‰è£…åº”ç”¨ï¼š${l.error}`,
  gS = l => `App konnte nicht installiert werden: ${l.error}`,
  yS = l => `No se pudo instalar la app: ${l.error}`,
  vS = l => `Impossible dâ€™installer lâ€™application : ${l.error}`,
  bS = l => `Impossibile installare l'app: ${l.error}`,
  xS = l => `ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ãã¾ã›ã‚“ã§ã—ãŸ: ${l.error}`,
  wS = l => `Nie udaÅ‚o siÄ™ zainstalowaÄ‡ aplikacji: ${l.error}`,
  kS = l => `ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ: ${l.error}`,
  TS = l => `ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸ Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ½Ğ¾Ğº: ${l.error}`,
  SS = l => `KhÃ´ng thá»ƒ cÃ i Ä‘áº·t á»©ng dá»¥ng: ${l.error}`,
  PS = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pS(l) : t === "pt" ? fS(l) : t === "ch" ? mS(l) : t === "de" ? gS(l) : t === "es" ? yS(l) : t === "fr" ? vS(l) : t === "it" ? bS(l) : t === "jp" ? xS(l) : t === "pl" ? wS(l) : t === "ru" ? kS(l) : t === "uk" ? TS(l) : SS(l)
  },
  MS = () => "Could not logout. Try refreshing the page.",
  CS = () => "NÃ£o foi possÃ­vel sair da conta. Tente recarregar a pÃ¡gina.",
  IS = () => "æ— æ³•ç™»å‡ºï¼Œè¯·å°è¯•åˆ·æ–°é¡µé¢ã€‚",
  zS = () => "Abmelden nicht mÃ¶glich. Versuche, die Seite neu zu laden.",
  AS = () => "No se pudo cerrar sesiÃ³n. Intenta refrescar la pÃ¡gina.",
  ES = () => "Impossible de se dÃ©connecter. Essayez dâ€™actualiser la page.",
  jS = () => "Impossibile disconnettersi. Prova a ricaricare la pagina.",
  LS = () => "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã¦ãã ã•ã„ã€‚",
  DS = () => "Nie udaÅ‚o siÄ™ wylogowaÄ‡. SprÃ³buj odÅ›wieÅ¼yÄ‡ stronÄ™.",
  RS = () => "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ²Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ.",
  BS = () => "ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²Ğ¸Ğ¹Ñ‚Ğ¸ Ğ· Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ğ°. Ğ¡Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¾Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸ ÑÑ‚Ğ¾Ñ€Ñ–Ğ½ĞºÑƒ.",
  FS = () => "KhÃ´ng thá»ƒ Ä‘Äƒng xuáº¥t. HÃ£y thá»­ táº£i láº¡i trang.",
  OS = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? MS() : t === "pt" ? CS() : t === "ch" ? IS() : t === "de" ? zS() : t === "es" ? AS() : t === "fr" ? ES() : t === "it" ? jS() : t === "jp" ? LS() : t === "pl" ? DS() : t === "ru" ? RS() : t === "uk" ? BS() : FS()
  },
  qS = () => "Countries",
  NS = () => "PaÃ­ses",
  VS = () => "å›½å®¶",
  US = () => "LÃ¤nder",
  ZS = () => "PaÃ­ses",
  GS = () => "Pays",
  HS = () => "Paesi",
  WS = () => "å›½",
  $S = () => "Kraje",
  XS = () => "Ğ¡Ñ‚Ñ€Ğ°Ğ½Ñ‹",
  YS = () => "ĞšÑ€Ğ°Ñ—Ğ½Ğ¸",
  KS = () => "Quá»‘c gia",
  JS = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qS() : t === "pt" ? NS() : t === "ch" ? VS() : t === "de" ? US() : t === "es" ? ZS() : t === "fr" ? GS() : t === "it" ? HS() : t === "jp" ? WS() : t === "pl" ? $S() : t === "ru" ? XS() : t === "uk" ? YS() : KS()
  },
  QS = () => "Country",
  tP = () => "PaÃ­s",
  eP = () => "å›½å®¶",
  rP = () => "Land",
  nP = () => "PaÃ­s",
  iP = () => "Pays",
  oP = () => "Paese",
  sP = () => "å›½",
  aP = () => "Kraj",
  uP = () => "Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ°",
  cP = () => "ĞšÑ€Ğ°Ñ—Ğ½Ğ°",
  lP = () => "Quá»‘c gia",
  Jf = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? QS() : t === "pt" ? tP() : t === "ch" ? eP() : t === "de" ? rP() : t === "es" ? nP() : t === "fr" ? iP() : t === "it" ? oP() : t === "jp" ? sP() : t === "pl" ? aP() : t === "ru" ? uP() : t === "uk" ? cP() : lP()
  },
  _P = () => "Create",
  hP = () => "Criar",
  dP = () => "åˆ›å»º",
  pP = () => "Erstellen",
  fP = () => "Crear",
  mP = () => "CrÃ©er",
  gP = () => "Crea",
  yP = () => "ä½œæˆ",
  vP = () => "UtwÃ³rz",
  bP = () => "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ",
  xP = () => "Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸",
  wP = () => "Táº¡o",
  kP = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? _P() : t === "pt" ? hP() : t === "ch" ? dP() : t === "de" ? pP() : t === "es" ? fP() : t === "fr" ? mP() : t === "it" ? gP() : t === "jp" ? yP() : t === "pl" ? vP() : t === "ru" ? bP() : t === "uk" ? xP() : wP()
  },
  TP = () => "Create alliance",
  SP = () => "Criar alianÃ§a",
  PP = () => "åˆ›å»ºè”ç›Ÿ",
  MP = () => "Allianz erstellen",
  CP = () => "Crear alianza",
  IP = () => "CrÃ©er une alliance",
  zP = () => "Crea alleanza",
  AP = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’ä½œæˆ",
  EP = () => "UtwÃ³rz sojusz",
  jP = () => "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ",
  LP = () => "Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸ Ğ°Ğ»ÑŒÑĞ½Ñ",
  DP = () => "Táº¡o liÃªn minh",
  RP = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? TP() : t === "pt" ? SP() : t === "ch" ? PP() : t === "de" ? MP() : t === "es" ? CP() : t === "fr" ? IP() : t === "it" ? zP() : t === "jp" ? AP() : t === "pl" ? EP() : t === "ru" ? jP() : t === "uk" ? LP() : DP()
  },
  BP = () => "Create an alliance",
  FP = () => "Crie uma alianÃ§a",
  OP = () => "åˆ›å»ºä¸€ä¸ªè”ç›Ÿ",
  qP = () => "Erstelle eine Allianz",
  NP = () => "Crear una alianza",
  VP = () => "CrÃ©er une alliance",
  UP = () => "Crea un'alleanza",
  ZP = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹",
  GP = () => "UtwÃ³rz sojusz",
  HP = () => "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ",
  WP = () => "Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ñ–Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ",
  $P = () => "Táº¡o má»™t liÃªn minh",
  XP = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? BP() : t === "pt" ? FP() : t === "ch" ? OP() : t === "de" ? qP() : t === "es" ? NP() : t === "fr" ? VP() : t === "it" ? UP() : t === "jp" ? ZP() : t === "pl" ? GP() : t === "ru" ? HP() : t === "uk" ? WP() : $P()
  },
  YP = () => "Dark mode",
  KP = () => "Modo escuro",
  JP = () => "æ·±è‰²æ¨¡å¼",
  QP = () => "Dunkler Modus",
  tM = () => "Modo oscuro",
  eM = () => "Mode sombre",
  rM = () => "Tema scuro",
  nM = () => "ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒ",
  iM = () => "Tryb ciemny",
  oM = () => "Ğ¢Ñ‘Ğ¼Ğ½Ğ°Ñ Ñ‚ĞµĞ¼Ğ°",
  sM = () => "Ğ¢ĞµĞ¼Ğ½Ğ° Ñ‚ĞµĞ¼Ğ°",
  aM = () => "Cháº¿ Ä‘á»™ tá»‘i",
  uM = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? YP() : t === "pt" ? KP() : t === "ch" ? JP() : t === "de" ? QP() : t === "es" ? tM() : t === "fr" ? eM() : t === "it" ? rM() : t === "jp" ? nM() : t === "pl" ? iM() : t === "ru" ? oM() : t === "uk" ? sM() : aM()
  },
  cM = () => "Delete Account",
  lM = () => "Deletar Conta",
  _M = () => "åˆ é™¤è´¦å·",
  hM = () => "Konto lÃ¶schen",
  dM = () => "Eliminar cuenta",
  pM = () => "Supprimer le compte",
  fM = () => "Elimina account",
  mM = () => "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤",
  gM = () => "UsuÅ„ konto",
  yM = () => "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚",
  vM = () => "Ğ’Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚Ğ¸ Ğ°ĞºĞ°ÑƒĞ½Ñ‚",
  bM = () => "XÃ³a tÃ i khoáº£n",
  ef = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? cM() : t === "pt" ? lM() : t === "ch" ? _M() : t === "de" ? hM() : t === "es" ? dM() : t === "fr" ? pM() : t === "it" ? fM() : t === "jp" ? mM() : t === "pl" ? gM() : t === "ru" ? yM() : t === "uk" ? vM() : bM()
  },
  xM = () => "ğŸ™… Disclosing other's personal information is not allowed",
  wM = () => "ğŸ™… Divulgar informaÃ§Ãµes pessoais dos outros nÃ£o Ã© permitido",
  kM = () => "ğŸ™… ä¸å…è®¸æ³„éœ²ä»–äººä¸ªäººä¿¡æ¯",
  TM = () => "ğŸ™… Das VerÃ¶ffentlichen persÃ¶nlicher Daten anderer ist nicht erlaubt",
  SM = () => "ğŸ™… No estÃ¡ permitido divulgar informaciÃ³n personal de otras personas",
  PM = () => "ğŸ™… La divulgation dâ€™informations personnelles dâ€™autrui nâ€™est pas autorisÃ©e",
  MM = () => "ğŸ™… Non Ã¨ consentito divulgare informazioni personali di altre persone",
  CM = () => "ğŸ™… ä»–äººã®å€‹äººæƒ…å ±ã‚’å…¬é–‹ã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  IM = () => "ğŸ™… UdostÄ™pnianie cudzych danych osobowych jest niedozwolone",
  zM = () => "ğŸ™… ĞŸÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ»ÑĞ´ĞµĞ¹ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ğ°",
  AM = () => "ğŸ™… ĞŸĞ¾ÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ Ğ¾ÑĞ¾Ğ±Ğ¸ÑÑ‚Ğ¾Ñ— Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ— Ñ–Ğ½ÑˆĞ¸Ñ… Ğ»ÑĞ´ĞµĞ¹ Ğ·Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ½ĞµĞ½Ğ¾",
  EM = () => "ğŸ™… KhÃ´ng Ä‘Æ°á»£c phÃ©p tiáº¿t lá»™ thÃ´ng tin cÃ¡ nhÃ¢n cá»§a ngÆ°á»i khÃ¡c",
  jM = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xM() : t === "pt" ? wM() : t === "ch" ? kM() : t === "de" ? TM() : t === "es" ? SM() : t === "fr" ? PM() : t === "it" ? MM() : t === "jp" ? CM() : t === "pl" ? IM() : t === "ru" ? zM() : t === "uk" ? AM() : EM()
  },
  LM = () => "Successfully linked your Discord account.",
  DM = () => "A sua conta Discord foi conectada com sucesso.",
  RM = () => "å·²æˆåŠŸå…³è”ä½ çš„ Discord è´¦å·ã€‚",
  BM = () => "Dein Discord-Konto wurde erfolgreich verknÃ¼pft.",
  FM = () => "Tu cuenta de Discord se ha vinculado correctamente.",
  OM = () => "Votre compte Discord a Ã©tÃ© liÃ© avec succÃ¨s.",
  qM = () => "Il tuo account Discord Ã¨ stato collegato con successo.",
  NM = () => "Discordã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æ­£å¸¸ã«é€£æºã—ã¾ã—ãŸã€‚",
  VM = () => "Twoje konto Discord zostaÅ‚o pomyÅ›lnie poÅ‚Ä…czone.",
  UM = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Discord ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ²ÑĞ·Ğ°Ğ½.",
  ZM = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Discord ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ²Ê¼ÑĞ·Ğ°Ğ½Ğ¾.",
  GM = () => "ÄÃ£ liÃªn káº¿t tÃ i khoáº£n Discord cá»§a báº¡n thÃ nh cÃ´ng.",
  HM = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? LM() : t === "pt" ? DM() : t === "ch" ? RM() : t === "de" ? BM() : t === "es" ? FM() : t === "fr" ? OM() : t === "it" ? qM() : t === "jp" ? NM() : t === "pl" ? VM() : t === "ru" ? UM() : t === "uk" ? ZM() : GM()
  },
  WM = () => "Discord Username",
  $M = () => "UsuÃ¡rio do Discord",
  XM = () => "Discord ç”¨æˆ·å",
  YM = () => "Discord-Benutzername",
  KM = () => "Usuario de Discord",
  JM = () => "Nom dâ€™utilisateur Discord",
  QM = () => "Utente Discord",
  tC = () => "Discordã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å",
  eC = () => "Nazwa uÅ¼ytkownika Discord",
  rC = () => "Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Discord",
  nC = () => "Ğ†Ğ¼Ê¼Ñ Ğ² Discord",
  iC = () => "TÃªn ngÆ°á»i dÃ¹ng Discord",
  oC = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? WM() : t === "pt" ? $M() : t === "ch" ? XM() : t === "de" ? YM() : t === "es" ? KM() : t === "fr" ? JM() : t === "it" ? QM() : t === "jp" ? tC() : t === "pl" ? eC() : t === "ru" ? rC() : t === "uk" ? nC() : iC()
  },
  sC = () => "Display your countryâ€™s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  aC = () => "Exiba a bandeira do seu paÃ­s ao lado do seu nome de usuÃ¡rio. AlÃ©m disso, ao pintar em regiÃµes onde vocÃª possui a bandeira correspondente, vocÃª recupera 10% das tintas gastas.",
  uC = () => "åœ¨ç”¨æˆ·åæ—æ˜¾ç¤ºä½ çš„å›½å®¶å›½æ——ã€‚æ­¤å¤–ï¼Œå½“ä½ åœ¨æ‹¥æœ‰å¯¹åº”å›½æ——çš„åŒºåŸŸå†…ç»˜åˆ¶åƒç´ æ—¶ï¼Œå¯ä»¥è¿”è¿˜ 10% æ¶ˆè€—çš„å……èƒ½ã€‚",
  cC = () => "Zeige die Flagge deines Landes neben deinem Benutzernamen an. Wenn du in Regionen malst, in denen du die entsprechende Flagge besitzt, erhÃ¤ltst du 10 % der verbrauchten Pixel zurÃ¼ck.",
  lC = () => "Muestra la bandera de tu paÃ­s junto a tu nombre de usuario. AdemÃ¡s, al pintar en regiones donde posees la bandera correspondiente, recuperas el 10% de las cargas gastadas.",
  _C = () => "Affichez le drapeau de votre pays Ã  cÃ´tÃ© de votre nom dâ€™utilisateur. De plus, lorsque vous peignez dans des rÃ©gions correspondant Ã  votre drapeau, vous rÃ©cupÃ©rez 10 % des charges dÃ©pensÃ©es.",
  hC = () => "Mostra la bandiera del tuo paese accanto al tuo nome utente. Inoltre, quando dipingi in regioni in cui possiedi la bandiera corrispondente, recuperi il 10% delle cariche spese.",
  dC = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã®æ¨ªã«è‡ªåˆ†ã®å›½æ——ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ã•ã‚‰ã«ã€ãã®å›½æ——ã«å¯¾å¿œã™ã‚‹åœ°åŸŸã§ãƒšã‚¤ãƒ³ãƒˆã™ã‚‹ã¨ã€æ¶ˆè²»ã—ãŸãƒãƒ£ãƒ¼ã‚¸ã®10%ãŒæˆ»ã£ã¦ãã¾ã™ã€‚",
  pC = () => "WyÅ›wietl flagÄ™ swojego kraju obok nazwy uÅ¼ytkownika. Dodatkowo, malujÄ…c w regionach, ktÃ³rych flagÄ™ posiadasz, odzyskujesz 10% zuÅ¼ytych Å‚adunkÃ³w.",
  fC = () => "ĞŸĞ¾ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ„Ğ»Ğ°Ğ³ ÑĞ²Ğ¾ĞµĞ¹ ÑÑ‚Ñ€Ğ°Ğ½Ñ‹ Ñ€ÑĞ´Ğ¾Ğ¼ Ñ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ. ĞšÑ€Ğ¾Ğ¼Ğµ Ñ‚Ğ¾Ğ³Ğ¾, Ñ€Ğ¸ÑÑƒÑ Ğ² Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°Ñ…, Ğ³Ğ´Ğµ Ñƒ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ Ñ„Ğ»Ğ°Ğ³, Ğ²Ñ‹ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚Ğµ 10% Ğ¿Ğ¾Ñ‚Ñ€Ğ°Ñ‡ĞµĞ½Ğ½Ñ‹Ñ… Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ².",
  mC = () => "ĞŸĞ¾ĞºĞ°Ğ·ÑƒĞ¹Ñ‚Ğµ Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€ ÑĞ²Ğ¾Ñ”Ñ— ĞºÑ€Ğ°Ñ—Ğ½Ğ¸ Ğ¿Ğ¾Ñ€ÑƒÑ‡ Ñ–Ğ· Ñ–Ğ¼â€™ÑĞ¼ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°. Ğ¢Ğ°ĞºĞ¾Ğ¶, ĞºĞ¾Ğ»Ğ¸ Ğ²Ğ¸ Ğ¼Ğ°Ğ»ÑÑ”Ñ‚Ğµ Ğ² Ñ€ĞµĞ³Ñ–Ğ¾Ğ½Ğ°Ñ…, Ñ‰Ğ¾ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°ÑÑ‚ÑŒ Ğ²Ğ°ÑˆĞ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€Ñƒ, Ğ²Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ñ‚Ğµ 10% Ğ²Ğ¸Ñ‚Ñ€Ğ°Ñ‡ĞµĞ½Ğ¸Ñ… Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ².",
  gC = () => "Hiá»ƒn thá»‹ cá» quá»‘c gia bÃªn cáº¡nh tÃªn ngÆ°á»i dÃ¹ng cá»§a báº¡n. NgoÃ i ra, khi tÃ´ trong khu vá»±c tÆ°Æ¡ng á»©ng vá»›i lÃ¡ cá» báº¡n sá»Ÿ há»¯u, báº¡n sáº½ nháº­n láº¡i 10% lÆ°á»£t tÃ´ Ä‘Ã£ dÃ¹ng.",
  yC = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? sC() : t === "pt" ? aC() : t === "ch" ? uC() : t === "de" ? cC() : t === "es" ? lC() : t === "fr" ? _C() : t === "it" ? hC() : t === "jp" ? dC() : t === "pl" ? pC() : t === "ru" ? fC() : t === "uk" ? mC() : gC()
  },
  vC = () => "ğŸ˜ˆ Do not paint over other artworks using random colors or patterns just to mess things up",
  bC = () => "ğŸ˜ˆ NÃ£o desenhe por cima de outras artes usando cores ou padrÃµes aleatÃ³rios sÃ³ para bagunÃ§ar",
  xC = () => "ğŸ˜ˆ è¯·ä¸è¦éšæ„ç”¨éšæœºé¢œè‰²æˆ–å›¾æ¡ˆè¦†ç›–ä»–äººçš„ä½œå“æ¥æ£ä¹±",
  wC = () => "ğŸ˜ˆ Ãœbermale nicht andere Kunstwerke mit irgendwelchen Farben oder Mustern, nur um Chaos zu stiften",
  kC = () => "ğŸ˜ˆ No pintes sobre las obras de otros usando colores o patrones aleatorios sÃ³lo para arruinar",
  TC = () => "ğŸ˜ˆ Ne peignez pas par-dessus les Å“uvres des autres avec des couleurs ou motifs alÃ©atoires juste pour gÃ¢cher",
  SC = () => "ğŸ˜ˆ Non disegnare sopra le opere altrui usando colori o pattern casuali solo per rovinare",
  PC = () => "ğŸ˜ˆ ã„ãŸãšã‚‰ç›®çš„ã§ã€ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ã‚„æ¨¡æ§˜ã§ä»–äººã®ä½œå“ã‚’å¡—ã‚Šã¤ã¶ã•ãªã„ã§ãã ã•ã„",
  MC = () => "ğŸ˜ˆ Nie maluj po cudzych pracach losowymi kolorami lub wzorami tylko po to, aby wszystko zepsuÄ‡",
  CC = () => "ğŸ˜ˆ ĞĞµ Ñ€Ğ¸ÑÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ°Ğ±Ğ¾Ñ‚ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¼Ğ¸ Ñ†Ğ²ĞµÑ‚Ğ°Ğ¼Ğ¸ Ğ¸Ğ»Ğ¸ ÑƒĞ·Ğ¾Ñ€Ğ°Ğ¼Ğ¸ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ñ€Ğ°Ğ´Ğ¸ Ñ‚Ğ¾Ğ³Ğ¾, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸ÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ‚ÑŒ Ğ¸Ñ…",
  IC = () => "ğŸ˜ˆ ĞĞµ Ğ¼Ğ°Ğ»ÑĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ¾Ğ±Ñ–Ñ‚ Ğ²Ğ¸Ğ¿Ğ°Ğ´ĞºĞ¾Ğ²Ğ¸Ğ¼Ğ¸ ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ğ°Ğ¼Ğ¸ Ñ‡Ğ¸ Ğ²Ñ–Ğ·ĞµÑ€ÑƒĞ½ĞºĞ°Ğ¼Ğ¸ Ğ»Ğ¸ÑˆĞµ Ğ·Ğ°Ñ€Ğ°Ğ´Ğ¸ Ğ¿ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ",
  zC = () => "ğŸ˜ˆ Äá»«ng tÃ´ Ä‘Ã¨ lÃªn tÃ¡c pháº©m cá»§a ngÆ°á»i khÃ¡c báº±ng mÃ u ngáº«u nhiÃªn chá»‰ Ä‘á»ƒ phÃ¡",
  AC = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vC() : t === "pt" ? bC() : t === "ch" ? xC() : t === "de" ? wC() : t === "es" ? kC() : t === "fr" ? TC() : t === "it" ? SC() : t === "jp" ? PC() : t === "pl" ? MC() : t === "ru" ? CC() : t === "uk" ? IC() : zC()
  },
  EC = () => "Does not need to be equipped to provide the bonus",
  jC = () => "NÃ£o precisa estar equipada para obter o bÃ´nus",
  LC = () => "æ— éœ€è£…å¤‡å³å¯æä¾›åŠ æˆæ•ˆæœ",
  DC = () => "Muss nicht ausgerÃ¼stet sein, um den Bonus zu erhalten",
  RC = () => "No necesita estar equipada para otorgar el bono",
  BC = () => "Nâ€™a pas besoin dâ€™Ãªtre Ã©quipÃ© pour fournir le bonus",
  FC = () => "Non deve essere equipaggiato per fornire il bonus",
  OC = () => "ãƒœãƒ¼ãƒŠã‚¹ã‚’å¾—ã‚‹ãŸã‚ã«è£…å‚™ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  qC = () => "Nie musi byÄ‡ zaÅ‚oÅ¼one, aby dawaÅ‚o bonus",
  NC = () => "ĞĞµ Ğ½ÑƒĞ¶Ğ½Ğ¾ ÑĞºĞ¸Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ğ½ÑƒÑ",
  VC = () => "ĞĞµ Ğ¾Ğ±Ğ¾Ğ²Ê¼ÑĞ·ĞºĞ¾Ğ²Ğ¾ Ğ¾Ğ±Ğ»Ğ°Ğ´Ğ½ÑƒĞ²Ğ°Ñ‚Ğ¸, Ñ‰Ğ¾Ğ± Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸ Ğ±Ğ¾Ğ½ÑƒÑ",
  UC = () => "KhÃ´ng cáº§n trang bá»‹ Ä‘á»ƒ nháº­n hiá»‡u á»©ng",
  ZC = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? EC() : t === "pt" ? jC() : t === "ch" ? LC() : t === "de" ? DC() : t === "es" ? RC() : t === "fr" ? BC() : t === "it" ? FC() : t === "jp" ? OC() : t === "pl" ? qC() : t === "ru" ? NC() : t === "uk" ? VC() : UC()
  },
  GC = () => "Download",
  HC = () => "Download",
  WC = () => "ä¸‹è½½",
  $C = () => "Download",
  XC = () => "Descargar",
  YC = () => "TÃ©lÃ©charger",
  KC = () => "Download",
  JC = () => "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
  QC = () => "Pobierz",
  tI = () => "Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ",
  eI = () => "Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸",
  rI = () => "Táº£i xuá»‘ng",
  nI = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? GC() : t === "pt" ? HC() : t === "ch" ? WC() : t === "de" ? $C() : t === "es" ? XC() : t === "fr" ? YC() : t === "it" ? KC() : t === "jp" ? JC() : t === "pl" ? QC() : t === "ru" ? tI() : t === "uk" ? eI() : rI()
  },
  iI = () => "Edit profile",
  oI = () => "Editar perfil",
  sI = () => "ç¼–è¾‘ä¸ªäººèµ„æ–™",
  aI = () => "Profil bearbeiten",
  uI = () => "Editar perfil",
  cI = () => "Modifier le profil",
  lI = () => "Modifica profilo",
  _I = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’ç·¨é›†",
  hI = () => "Edytuj profil",
  dI = () => "Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
  pI = () => "Ğ ĞµĞ´Ğ°Ğ³ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»ÑŒ",
  fI = () => "Chá»‰nh sá»­a há»“ sÆ¡",
  mI = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? iI() : t === "pt" ? oI() : t === "ch" ? sI() : t === "de" ? aI() : t === "es" ? uI() : t === "fr" ? cI() : t === "it" ? lI() : t === "jp" ? _I() : t === "pl" ? hI() : t === "ru" ? dI() : t === "uk" ? pI() : fI()
  },
  gI = () => "Equip",
  yI = () => "Equipar",
  vI = () => "è£…å¤‡",
  bI = () => "AusrÃ¼sten",
  xI = () => "Equipar",
  wI = () => "Ã‰quiper",
  kI = () => "Equipaggia",
  TI = () => "è£…å‚™ã™ã‚‹",
  SI = () => "ZaÅ‚Ã³Å¼",
  PI = () => "Ğ­ĞºĞ¸Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
  MI = () => "ĞÑĞ½Ğ°ÑÑ‚Ğ¸Ñ‚Ğ¸",
  CI = () => "Trang bá»‹",
  II = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? gI() : t === "pt" ? yI() : t === "ch" ? vI() : t === "de" ? bI() : t === "es" ? xI() : t === "fr" ? wI() : t === "it" ? kI() : t === "jp" ? TI() : t === "pl" ? SI() : t === "ru" ? PI() : t === "uk" ? MI() : CI()
  },
  zI = () => "Equipped",
  AI = () => "Equipado",
  EI = () => "å·²è£…å¤‡",
  jI = () => "AusgerÃ¼stet",
  LI = () => "Equipado",
  DI = () => "Ã‰quipÃ©",
  RI = () => "Equipaggiato",
  BI = () => "è£…å‚™ä¸­",
  FI = () => "ZaÅ‚oÅ¼one",
  OI = () => "Ğ­ĞºĞ¸Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾",
  qI = () => "ĞÑĞ½Ğ°Ñ‰ĞµĞ½Ğ¾",
  NI = () => "ÄÃ£ trang bá»‹",
  VI = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? zI() : t === "pt" ? AI() : t === "ch" ? EI() : t === "de" ? jI() : t === "es" ? LI() : t === "fr" ? DI() : t === "it" ? RI() : t === "jp" ? BI() : t === "pl" ? FI() : t === "ru" ? OI() : t === "uk" ? qI() : NI()
  },
  UI = () => "Error giving admin to user",
  ZI = () => "Erro ao tornar usuÃ¡rio admin",
  GI = () => "æˆäºˆç®¡ç†å‘˜æƒé™æ—¶å‡ºé”™",
  HI = () => "Fehler beim Vergeben von Admin-Rechten",
  WI = () => "Error al otorgar admin al usuario",
  $I = () => "Erreur lors de lâ€™attribution du rÃ´le admin",
  XI = () => "Errore nel rendere l'utente admin",
  YI = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç®¡ç†è€…æ¨©é™ã‚’ä»˜ä¸ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚",
  KI = () => "BÅ‚Ä…d podczas nadawania uprawnieÅ„ admina",
  JI = () => "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ´Ğ°Ñ‡Ğµ Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ",
  QI = () => "ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¿Ñ–Ğ´ Ñ‡Ğ°Ñ Ğ½Ğ°Ğ´Ğ°Ğ½Ğ½Ñ Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°",
  tz = () => "Lá»—i khi gÃ¡n quyá»n admin cho ngÆ°á»i dÃ¹ng",
  ez = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? UI() : t === "pt" ? ZI() : t === "ch" ? GI() : t === "de" ? HI() : t === "es" ? WI() : t === "fr" ? $I() : t === "it" ? XI() : t === "jp" ? YI() : t === "pl" ? KI() : t === "ru" ? JI() : t === "uk" ? QI() : tz()
  },
  rz = () => "Event",
  nz = () => "Evento",
  iz = () => "æ´»åŠ¨",
  oz = () => "Event",
  sz = () => "Evento",
  az = () => "Ã‰vÃ©nement",
  uz = () => "Evento",
  cz = () => "ã‚¤ãƒ™ãƒ³ãƒˆ",
  lz = () => "Wydarzenie",
  _z = () => "Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ",
  hz = () => "ĞŸĞ¾Ğ´Ñ–Ñ",
  dz = () => "Sá»± kiá»‡n",
  pz = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rz() : t === "pt" ? nz() : t === "ch" ? iz() : t === "de" ? oz() : t === "es" ? sz() : t === "fr" ? az() : t === "it" ? uz() : t === "jp" ? cz() : t === "pl" ? lz() : t === "ru" ? _z() : t === "uk" ? hz() : dz()
  },
  fz = l => `You received ${l.Gouttelettes} Gouttelettes!`,
  mz = l => `VocÃª recebeu ${l.droplets} droplets!`,
  gz = l => `ä½ è·å¾—äº† ${l.droplets} æ°´æ»´ï¼`,
  yz = l => `Du hast ${l.droplets} Droplets erhalten!`,
  vz = l => `Â¡Has recibido ${l.droplets} gotas!`,
  bz = l => `Vous avez reÃ§u ${l.droplets} droplets !`,
  xz = l => `Hai ricevuto ${l.droplets} gocce!`,
  wz = l => `ã‚ãªãŸã¯${l.droplets}ãƒ‰ãƒ­ãƒƒãƒ—ãƒ¬ãƒƒãƒˆã‚’å—ã‘å–ã‚Šã¾ã—ãŸï¼`,
  kz = l => `OtrzymaÅ‚eÅ› ${l.droplets} kropli!`,
  Tz = l => `Ğ’Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ ${l.droplets} droplets!`,
  Sz = l => `Ğ’Ğ¸ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ»Ğ¸ ${l.droplets} Ğ´Ñ€Ğ¾Ğ¿Ğ»ĞµÑ‚Ñ–Ğ²!`,
  Pz = l => `Báº¡n Ä‘Ã£ nháº­n Ä‘Æ°á»£c ${l.droplets} droplets!`,
  Mz = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? fz(l) : t === "pt" ? mz(l) : t === "ch" ? gz(l) : t === "de" ? yz(l) : t === "es" ? vz(l) : t === "fr" ? bz(l) : t === "it" ? xz(l) : t === "jp" ? wz(l) : t === "pl" ? kz(l) : t === "ru" ? Tz(l) : t === "uk" ? Sz(l) : Pz(l)
  },
  Cz = () => "Favorite",
  Iz = () => "Favoritar",
  zz = () => "æ”¶è—",
  Az = () => "Favorit",
  Ez = () => "Favorito",
  jz = () => "Favori",
  Lz = () => "Preferito",
  Dz = () => "ãŠæ°—ã«å…¥ã‚Š",
  Rz = () => "Ulubione",
  Bz = () => "Ğ˜Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ",
  Fz = () => "Ğ£ Ğ²Ğ¸Ğ±Ñ€Ğ°Ğ½Ğµ",
  Oz = () => "YÃªu thÃ­ch",
  qz = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Cz() : t === "pt" ? Iz() : t === "ch" ? zz() : t === "de" ? Az() : t === "es" ? Ez() : t === "fr" ? jz() : t === "it" ? Lz() : t === "jp" ? Dz() : t === "pl" ? Rz() : t === "ru" ? Bz() : t === "uk" ? Fz() : Oz()
  },
  Nz = l => `The flag of <b>${l.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
  Vz = l => `A bandeira <b>${l.country}</b> nÃ£o possui regiÃµes correspondente no mapa e sÃ³ terÃ¡ efeito cosmÃ©tico.`,
  Uz = l => `<b>${l.country}</b> çš„å›½æ——åœ¨åœ°å›¾ä¸Šæ²¡æœ‰å¯¹åº”çš„åŒºåŸŸï¼Œä»…å…·æœ‰è£…é¥°æ•ˆæœã€‚`,
  Zz = l => `Die Flagge von <b>${l.country}</b> hat keine entsprechende Region auf der Karte und ist nur kosmetisch.`,
  Gz = l => `La bandera de <b>${l.country}</b> no tiene regiones correspondientes en el mapa y tendrÃ¡ sÃ³lo efecto cosmÃ©tico.`,
  Hz = l => `Le drapeau de <b>${l.country}</b> nâ€™a pas de rÃ©gion correspondante sur la carte et aura uniquement un effet cosmÃ©tique.`,
  Wz = l => `La bandiera di <b>${l.country}</b> non ha una regione corrispondente sulla mappa e avrÃ  solo effetto cosmetico.`,
  $z = l => `<b>${l.country}</b>ã®å›½æ——ã«ã¯ãƒãƒƒãƒ—ä¸Šã®å¯¾å¿œã‚¨ãƒªã‚¢ãŒãªã„ãŸã‚ã€è¦‹ãŸç›®ã®ã¿ã®åŠ¹æœã«ãªã‚Šã¾ã™ã€‚`,
  Xz = l => `Flaga <b>${l.country}</b> nie ma odpowiadajÄ…cych jej obszarÃ³w na mapie i ma jedynie efekt kosmetyczny.`,
  Yz = l => `Ğ¤Ğ»Ğ°Ğ³ <b>${l.country}</b> Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ Ğ¸ Ğ±ÑƒĞ´ĞµÑ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾ÑĞ¼ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ.`,
  Kz = l => `ĞŸÑ€Ğ°Ğ¿Ğ¾Ñ€ <b>${l.country}</b> Ğ½Ğµ Ğ¼Ğ°Ñ” Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ½Ğ¸Ñ… Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ĞµĞ¹ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ– Ñ‚Ğ° Ğ¼Ğ°Ñ‚Ğ¸Ğ¼Ğµ Ğ»Ğ¸ÑˆĞµ Ğ²Ñ–Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ğ¹ ĞµÑ„ĞµĞºÑ‚.`,
  Jz = l => `Cá» cá»§a <b>${l.country}</b> khÃ´ng cÃ³ khu vá»±c tÆ°Æ¡ng á»©ng trÃªn báº£n Ä‘á»“ vÃ  chá»‰ cÃ³ tÃ¡c dá»¥ng trang trÃ­.`,
  Qz = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Nz(l) : t === "pt" ? Vz(l) : t === "ch" ? Uz(l) : t === "de" ? Zz(l) : t === "es" ? Gz(l) : t === "fr" ? Hz(l) : t === "it" ? Wz(l) : t === "jp" ? $z(l) : t === "pl" ? Xz(l) : t === "ru" ? Yz(l) : t === "uk" ? Kz(l) : Jz(l)
  },
  t4 = () => "Flag without region on the map",
  e4 = () => "Bandeira sem regiÃ£o no mapa",
  r4 = () => "æ— åœ°å›¾åŒºåŸŸçš„å›½æ——",
  n4 = () => "Flagge ohne Region auf der Karte",
  i4 = () => "Bandera sin regiÃ³n en el mapa",
  o4 = () => "Drapeau sans rÃ©gion sur la carte",
  s4 = () => "Bandiera senza regione sulla mappa",
  a4 = () => "ãƒãƒƒãƒ—ã«å¯¾å¿œã™ã‚‹åœ°åŸŸã®ãªã„æ——",
  u4 = () => "Flaga bez regionu na mapie",
  c4 = () => "Ğ¤Ğ»Ğ°Ğ³ Ğ±ĞµĞ· Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ° Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ",
  l4 = () => "ĞŸÑ€Ğ°Ğ¿Ğ¾Ñ€ Ğ±ĞµĞ· Ñ€ĞµĞ³Ñ–Ğ¾Ğ½Ñƒ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ–",
  _4 = () => "Cá» khÃ´ng cÃ³ vÃ¹ng trÃªn báº£n Ä‘á»“",
  h4 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? t4() : t === "pt" ? e4() : t === "ch" ? r4() : t === "de" ? n4() : t === "es" ? i4() : t === "fr" ? o4() : t === "it" ? s4() : t === "jp" ? a4() : t === "pl" ? u4() : t === "ru" ? c4() : t === "uk" ? l4() : _4()
  },
  d4 = () => "Follow the instructions to enable hardware acceleration",
  p4 = () => "Siga a instruÃ§Ã£o para habilitar a aceleraÃ§Ã£o de hardware",
  f4 = () => "è¯·æŒ‰ç…§è¯´æ˜å¯ç”¨ç¡¬ä»¶åŠ é€Ÿ",
  m4 = () => "Folge den Anweisungen, um Hardwarebeschleunigung zu aktivieren",
  g4 = () => "Sigue las instrucciones para habilitar la aceleraciÃ³n por hardware",
  y4 = () => "Suivez les instructions pour activer lâ€™accÃ©lÃ©ration matÃ©rielle",
  v4 = () => "Segui le istruzioni per abilitare l'accelerazione hardware",
  b4 = () => "ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹ã«ã™ã‚‹æ‰‹é †ã«å¾“ã£ã¦ãã ã•ã„ã€‚",
  x4 = () => "PostÄ™puj zgodnie z instrukcjami, aby wÅ‚Ä…czyÄ‡ akceleracjÄ™ sprzÄ™towÄ…",
  w4 = () => "Ğ¡Ğ»ĞµĞ´ÑƒĞ¹Ñ‚Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸ÑĞ¼, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ¿Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğµ ÑƒÑĞºĞ¾Ñ€ĞµĞ½Ğ¸Ğµ",
  k4 = () => "Ğ”Ğ¾Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ¹Ñ‚ĞµÑÑŒ Ñ–Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ñ–Ğ¹, Ñ‰Ğ¾Ğ± ÑƒĞ²Ñ–Ğ¼ĞºĞ½ÑƒÑ‚Ğ¸ Ğ°Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğµ Ğ¿Ñ€Ğ¸ÑĞºĞ¾Ñ€ĞµĞ½Ğ½Ñ",
  T4 = () => "LÃ m theo hÆ°á»›ng dáº«n Ä‘á»ƒ báº­t tÄƒng tá»‘c pháº§n cá»©ng",
  S4 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? d4() : t === "pt" ? p4() : t === "ch" ? f4() : t === "de" ? m4() : t === "es" ? g4() : t === "fr" ? y4() : t === "it" ? v4() : t === "jp" ? b4() : t === "pl" ? x4() : t === "ru" ? w4() : t === "uk" ? k4() : T4()
  },
  P4 = () => "For more details, see our",
  M4 = () => "Para mais detalhes, veja nossa",
  C4 = () => "æ›´å¤šè¯¦æƒ…è¯·å‚é˜…æˆ‘ä»¬çš„",
  I4 = () => "FÃ¼r weitere Details siehe unsere",
  z4 = () => "Para mÃ¡s detalles, consulta nuestra",
  A4 = () => "Pour plus de dÃ©tails, consultez notre",
  E4 = () => "Per maggiori dettagli, consulta la nostra",
  j4 = () => "è©³ã—ãã¯ã€ã“ã¡ã‚‰ã‚’ã”è¦§ãã ã•ã„:",
  L4 = () => "Po wiÄ™cej informacji zobacz naszÄ…",
  D4 = () => "ĞŸĞ¾Ğ´Ñ€Ğ¾Ğ±Ğ½ĞµĞµ ÑĞ¼. Ğ² Ğ½Ğ°ÑˆĞ¸Ñ…",
  R4 = () => "Ğ”Ğ»Ñ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ğ¾Ñ— Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ— Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ½ÑŒÑ‚Ğµ Ğ½Ğ°ÑˆÑ–",
  B4 = () => "Äá»ƒ biáº¿t thÃªm chi tiáº¿t, hÃ£y xem",
  F4 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? P4() : t === "pt" ? M4() : t === "ch" ? C4() : t === "de" ? I4() : t === "es" ? z4() : t === "fr" ? A4() : t === "it" ? E4() : t === "jp" ? j4() : t === "pl" ? L4() : t === "ru" ? D4() : t === "uk" ? R4() : B4()
  },
  O4 = () => "Get invited to an alliance",
  q4 = () => "Seja convidado para uma alianÃ§a",
  N4 = () => "é€šè¿‡é‚€è¯·åŠ å…¥è”ç›Ÿ",
  V4 = () => "Lass dich in eine Allianz einladen",
  U4 = () => "Recibe una invitaciÃ³n para una alianza",
  Z4 = () => "Recevoir une invitation dans une alliance",
  G4 = () => "Fatti invitare in un'alleanza",
  H4 = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‹›å¾…ã—ã¦ã‚‚ã‚‰ã†",
  W4 = () => "ZostaÅ„ zaproszony do sojuszu",
  $4 = () => "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  X4 = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ¹Ñ‚Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑˆĞµĞ½Ğ½Ñ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  Y4 = () => "Nháº­n lá»i má»i vÃ o má»™t liÃªn minh",
  K4 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? O4() : t === "pt" ? q4() : t === "ch" ? N4() : t === "de" ? V4() : t === "es" ? U4() : t === "fr" ? Z4() : t === "it" ? G4() : t === "jp" ? H4() : t === "pl" ? W4() : t === "ru" ? $4() : t === "uk" ? X4() : Y4()
  },
  J4 = () => "Get more charges",
  Q4 = () => "Recarregue tinta para pintar",
  tA = () => "è·å¾—æ›´å¤šå……èƒ½",
  eA = () => "Mehr Pixel-Ladungen bekommen",
  rA = () => "Obtener mÃ¡s cargas",
  nA = () => "Obtenir plus de charges",
  iA = () => "Ricarica la vernice per dipingere",
  oA = () => "ãƒãƒ£ãƒ¼ã‚¸ã‚’è¿½åŠ ã§ç²å¾—",
  sA = () => "ZdobÄ…dÅº wiÄ™cej Å‚adunkÃ³w",
  aA = () => "ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²",
  uA = () => "ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ²",
  cA = () => "Nháº­n thÃªm lÆ°á»£t tÃ´",
  lA = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? J4() : t === "pt" ? Q4() : t === "ch" ? tA() : t === "de" ? eA() : t === "es" ? rA() : t === "fr" ? nA() : t === "it" ? iA() : t === "jp" ? oA() : t === "pl" ? sA() : t === "ru" ? aA() : t === "uk" ? uA() : cA()
  },
  _A = () => "Give admin",
  hA = () => "Tornar admin",
  dA = () => "æˆäºˆç®¡ç†å‘˜",
  pA = () => "Admin vergeben",
  fA = () => "Dar admin",
  mA = () => "Donner le rÃ´le admin",
  gA = () => "Rendi admin",
  yA = () => "ç®¡ç†è€…ã«ã™ã‚‹",
  vA = () => "Nadaj uprawnienia admina",
  bA = () => "Ğ¡Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼",
  xA = () => "ĞĞ°Ğ´Ğ°Ñ‚Ğ¸ Ğ°Ğ´Ğ¼Ñ–Ğ½-Ğ¿Ñ€Ğ°Ğ²Ğ°",
  wA = () => "GÃ¡n quyá»n admin",
  kA = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? _A() : t === "pt" ? hA() : t === "ch" ? dA() : t === "de" ? pA() : t === "es" ? fA() : t === "fr" ? mA() : t === "it" ? gA() : t === "jp" ? yA() : t === "pl" ? vA() : t === "ru" ? bA() : t === "uk" ? xA() : wA()
  },
  TA = () => "Giving admin to user",
  SA = () => "Tornar usuÃ¡rio um admin",
  PA = () => "æ­£åœ¨æˆäºˆç®¡ç†å‘˜æƒé™",
  MA = () => "Vergebe Admin-Rechte an Benutzer",
  CA = () => "Otorgando admin al usuario",
  IA = () => "Attribution du rÃ´le admin Ã  lâ€™utilisateur",
  zA = () => "Assegnazione permessi admin all'utente",
  AA = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç®¡ç†è€…æ¨©é™ã‚’ä»˜ä¸ä¸­",
  EA = () => "Nadawanie uprawnieÅ„ admina uÅ¼ytkownikowi",
  jA = () => "Ğ’Ñ‹Ğ´Ğ°Ñ‡Ğ° Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ",
  LA = () => "ĞĞ°Ğ´Ğ°Ğ½Ğ½Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñƒ Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ñ–Ğ½Ñ–ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°",
  DA = () => "Äang gÃ¡n quyá»n admin cho ngÆ°á»i dÃ¹ng",
  RA = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? TA() : t === "pt" ? SA() : t === "ch" ? PA() : t === "de" ? MA() : t === "es" ? CA() : t === "fr" ? IA() : t === "it" ? zA() : t === "jp" ? AA() : t === "pl" ? EA() : t === "ru" ? jA() : t === "uk" ? LA() : DA()
  },
  BA = () => "Headquarters",
  FA = () => "Quartel General",
  OA = () => "æ€»éƒ¨",
  qA = () => "Hauptquartier",
  NA = () => "Cuartel general",
  VA = () => "Quartier gÃ©nÃ©ral",
  UA = () => "Quartier generale",
  ZA = () => "æ‹ ç‚¹",
  GA = () => "Siedziba",
  HA = () => "Ğ¨Ñ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ°",
  WA = () => "Ğ¨Ñ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ°",
  $A = () => "Trá»¥ sá»Ÿ",
  XA = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? BA() : t === "pt" ? FA() : t === "ch" ? OA() : t === "de" ? qA() : t === "es" ? NA() : t === "fr" ? VA() : t === "it" ? UA() : t === "jp" ? ZA() : t === "pl" ? GA() : t === "ru" ? HA() : t === "uk" ? WA() : $A()
  },
  YA = () => "Hide pixel art",
  KA = () => "Esconder Pixel Art",
  JA = () => "éšè—åƒç´ ç”»",
  QA = () => "Pixel-Art ausblenden",
  t6 = () => "Ocultar pixel art",
  e6 = () => "Masquer le pixel art",
  r6 = () => "Nascondi Pixel Art",
  n6 = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚¢ãƒ¼ãƒˆã‚’éè¡¨ç¤º",
  i6 = () => "Ukryj pixel art",
  o6 = () => "Ğ¡ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ-Ğ°Ñ€Ñ‚",
  s6 = () => "ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ-Ğ°Ñ€Ñ‚",
  a6 = () => "áº¨n pixel art",
  u6 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? YA() : t === "pt" ? KA() : t === "ch" ? JA() : t === "de" ? QA() : t === "es" ? t6() : t === "fr" ? e6() : t === "it" ? r6() : t === "jp" ? n6() : t === "pl" ? i6() : t === "ru" ? o6() : t === "uk" ? s6() : a6()
  },
  c6 = () => "Hide UI",
  l6 = () => "Esconder UI",
  _6 = () => "éšè—ç•Œé¢",
  h6 = () => "UI ausblenden",
  d6 = () => "Ocultar UI",
  p6 = () => "Masquer lâ€™interface",
  f6 = () => "Nascondi UI",
  m6 = () => "UIã‚’éš ã™",
  g6 = () => "Ukryj interfejs",
  y6 = () => "Ğ¡ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ",
  v6 = () => "ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ñ‚Ğ¸ Ñ–Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ",
  b6 = () => "áº¨n giao diá»‡n",
  x6 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? c6() : t === "pt" ? l6() : t === "ch" ? _6() : t === "de" ? h6() : t === "es" ? d6() : t === "fr" ? p6() : t === "it" ? f6() : t === "jp" ? m6() : t === "pl" ? g6() : t === "ru" ? y6() : t === "uk" ? v6() : b6()
  },
  w6 = () => "Hold",
  k6 = () => "Segure",
  T6 = () => "æŒ‰ä½",
  S6 = () => "Halten",
  P6 = () => "Mantener",
  M6 = () => "Maintenir",
  C6 = () => "Tieni premuto",
  I6 = () => "é•·æŠ¼ã—",
  z6 = () => "Przytrzymaj",
  A6 = () => "Ğ£Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ",
  E6 = () => "Ğ£Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ¹Ñ‚Ğµ",
  j6 = () => "Giá»¯",
  L6 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? w6() : t === "pt" ? k6() : t === "ch" ? T6() : t === "de" ? S6() : t === "es" ? P6() : t === "fr" ? M6() : t === "it" ? C6() : t === "jp" ? I6() : t === "pl" ? z6() : t === "ru" ? A6() : t === "uk" ? E6() : j6()
  },
  D6 = () => "How to paint faster",
  R6 = () => "Como pintar mais rÃ¡pido",
  B6 = () => "å¦‚ä½•æ›´å¿«åœ°ç»˜åˆ¶",
  F6 = () => "Wie man schneller malt",
  O6 = () => "CÃ³mo pintar mÃ¡s rÃ¡pido",
  q6 = () => "Comment peindre plus vite",
  N6 = () => "Come dipingere piÃ¹ velocemente",
  V6 = () => "æ—©ãå¡—ã‚‹ã«ã¯",
  U6 = () => "Jak malowaÄ‡ szybciej",
  Z6 = () => "ĞšĞ°Ğº Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ",
  G6 = () => "Ğ¯Ğº Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ ÑˆĞ²Ğ¸Ğ´ÑˆĞµ",
  H6 = () => "CÃ¡ch tÃ´ nhanh hÆ¡n",
  W6 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? D6() : t === "pt" ? R6() : t === "ch" ? B6() : t === "de" ? F6() : t === "es" ? O6() : t === "fr" ? q6() : t === "it" ? N6() : t === "jp" ? V6() : t === "pl" ? U6() : t === "ru" ? Z6() : t === "uk" ? G6() : H6()
  },
  $6 = () => "Image",
  X6 = () => "Imagem",
  Y6 = () => "å›¾ç‰‡",
  K6 = () => "Bild",
  J6 = () => "Imagen",
  Q6 = () => "Image",
  tE = () => "Immagine",
  eE = () => "ç”»åƒ",
  rE = () => "Obraz",
  nE = () => "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ",
  iE = () => "Ğ—Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ",
  oE = () => "HÃ¬nh áº£nh",
  sE = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $6() : t === "pt" ? X6() : t === "ch" ? Y6() : t === "de" ? K6() : t === "es" ? J6() : t === "fr" ? Q6() : t === "it" ? tE() : t === "jp" ? eE() : t === "pl" ? rE() : t === "ru" ? nE() : t === "uk" ? iE() : oE()
  },
  aE = () => "Image copied to clipboard",
  uE = () => "Imagem copiada para a Ã¡rea de transferÃªncia",
  cE = () => "å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿",
  lE = () => "Bild in die Zwischenablage kopiert",
  _E = () => "Imagen copiada al portapapeles",
  hE = () => "Image copiÃ©e dans le presse-papiers",
  dE = () => "Immagine copiata negli appunti",
  pE = () => "ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  fE = () => "Obraz skopiowany do schowka",
  mE = () => "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°",
  gE = () => "Ğ—Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ ÑĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ´Ğ¾ Ğ±ÑƒÑ„ĞµÑ€Ğ° Ğ¾Ğ±Ğ¼Ñ–Ğ½Ñƒ",
  yE = () => "ÄÃ£ sao chÃ©p hÃ¬nh áº£nh vÃ o clipboard",
  vE = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? aE() : t === "pt" ? uE() : t === "ch" ? cE() : t === "de" ? lE() : t === "es" ? _E() : t === "fr" ? hE() : t === "it" ? dE() : t === "jp" ? pE() : t === "pl" ? fE() : t === "ru" ? mE() : t === "uk" ? gE() : yE()
  },
  bE = () => "Important",
  xE = () => "Importante",
  wE = () => "é‡è¦",
  kE = () => "Wichtig",
  TE = () => "Importante",
  SE = () => "Important",
  PE = () => "Importante",
  ME = () => "é‡è¦",
  CE = () => "WaÅ¼ne",
  IE = () => "Ğ’Ğ°Ğ¶Ğ½Ğ¾",
  zE = () => "Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾",
  AE = () => "Quan trá»ng",
  EE = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? bE() : t === "pt" ? xE() : t === "ch" ? wE() : t === "de" ? kE() : t === "es" ? TE() : t === "fr" ? SE() : t === "it" ? PE() : t === "jp" ? ME() : t === "pl" ? CE() : t === "ru" ? IE() : t === "uk" ? zE() : AE()
  },
  jE = () => "Increase your maximum paint charges capacity",
  LE = () => "Aumente sua capacidade mÃ¡xima de tinta",
  DE = () => "æå‡ä½ çš„æœ€å¤§ç»˜åˆ¶å……èƒ½ä¸Šé™",
  RE = () => "ErhÃ¶he deine maximale Anzahl an Pixel-Ladungen",
  BE = () => "Aumenta tu capacidad mÃ¡xima de cargas de pintura",
  FE = () => "Augmentez votre capacitÃ© maximale de charges de peinture",
  OE = () => "Aumenta la tua capacitÃ  massima di vernice",
  qE = () => "ãƒšã‚¤ãƒ³ãƒˆã®æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸æ•°ã‚’å¢—ã‚„ã™",
  NE = () => "ZwiÄ™ksz maksymalnÄ… pojemnoÅ›Ä‡ Å‚adunkÃ³w malowania",
  VE = () => "Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡ÑŒÑ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ²",
  UE = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñƒ ĞºÑ–Ğ»ÑŒĞºÑ–ÑÑ‚ÑŒ Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ² Ñ„Ğ°Ñ€Ğ±Ğ¸",
  ZE = () => "TÄƒng sá»‘ lÆ°á»£t tÃ´ tá»‘i Ä‘a",
  GE = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? jE() : t === "pt" ? LE() : t === "ch" ? DE() : t === "de" ? RE() : t === "es" ? BE() : t === "fr" ? FE() : t === "it" ? OE() : t === "jp" ? qE() : t === "pl" ? NE() : t === "ru" ? VE() : t === "uk" ? UE() : ZE()
  },
  HE = () => "Info",
  WE = () => "InformaÃ§Ãµes",
  $E = () => "ä¿¡æ¯",
  XE = () => "Info",
  YE = () => "Info",
  KE = () => "Infos",
  JE = () => "Informazioni",
  QE = () => "æƒ…å ±",
  t8 = () => "Informacje",
  e8 = () => "Ğ˜Ğ½Ñ„Ğ¾",
  r8 = () => "Ğ†Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ",
  n8 = () => "ThÃ´ng tin",
  i8 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? HE() : t === "pt" ? WE() : t === "ch" ? $E() : t === "de" ? XE() : t === "es" ? YE() : t === "fr" ? KE() : t === "it" ? JE() : t === "jp" ? QE() : t === "pl" ? t8() : t === "ru" ? e8() : t === "uk" ? r8() : n8()
  },
  o8 = () => "Install App",
  s8 = () => "Instalar App",
  a8 = () => "å®‰è£…åº”ç”¨",
  u8 = () => "App installieren",
  c8 = () => "Instalar app",
  l8 = () => "Installer lâ€™application",
  _8 = () => "Installa app",
  h8 = () => "ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«",
  d8 = () => "Zainstaluj aplikacjÄ™",
  p8 = () => "Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ",
  f8 = () => "Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸ Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ½Ğ¾Ğº",
  m8 = () => "CÃ i Ä‘áº·t á»©ng dá»¥ng",
  g8 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? o8() : t === "pt" ? s8() : t === "ch" ? a8() : t === "de" ? u8() : t === "es" ? c8() : t === "fr" ? l8() : t === "it" ? _8() : t === "jp" ? h8() : t === "pl" ? d8() : t === "ru" ? p8() : t === "uk" ? f8() : m8()
  },
  y8 = () => "Invite",
  v8 = () => "Convite",
  b8 = () => "é‚€è¯·",
  x8 = () => "Einladen",
  w8 = () => "Invitar",
  k8 = () => "Invitation",
  T8 = () => "Invito",
  S8 = () => "æ‹›å¾…",
  P8 = () => "ZaproÅ›",
  M8 = () => "ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ",
  C8 = () => "Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚Ğ¸",
  I8 = () => "Má»i",
  z8 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? y8() : t === "pt" ? v8() : t === "ch" ? b8() : t === "de" ? x8() : t === "es" ? w8() : t === "fr" ? k8() : t === "it" ? T8() : t === "jp" ? S8() : t === "pl" ? P8() : t === "ru" ? M8() : t === "uk" ? C8() : I8()
  },
  A8 = () => "Invite link",
  E8 = () => "Link de convite",
  j8 = () => "é‚€è¯·é“¾æ¥",
  L8 = () => "Einladungslink",
  D8 = () => "Enlace de invitaciÃ³n",
  R8 = () => "Lien dâ€™invitation",
  B8 = () => "Link di invito",
  F8 = () => "æ‹›å¾…ãƒªãƒ³ã‚¯",
  O8 = () => "Link zaproszenia",
  q8 = () => "Ğ¡ÑÑ‹Ğ»ĞºĞ°-Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ",
  N8 = () => "ĞŸĞ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑˆĞµĞ½Ğ½Ñ",
  V8 = () => "LiÃªn káº¿t má»i",
  U8 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? A8() : t === "pt" ? E8() : t === "ch" ? j8() : t === "de" ? L8() : t === "es" ? D8() : t === "fr" ? R8() : t === "it" ? B8() : t === "jp" ? F8() : t === "pl" ? O8() : t === "ru" ? q8() : t === "uk" ? N8() : V8()
  },
  Z8 = () => "is enabled on",
  G8 = () => "estÃ¡ habilitado em",
  H8 = () => "å·²åœ¨æ­¤å¯ç”¨ï¼š",
  W8 = () => "aktiviert ist auf",
  $8 = () => "estÃ¡ habilitado en",
  X8 = () => "est activÃ© sur",
  Y8 = () => "Ã¨ abilitato su",
  K8 = () => "ã¯æ¬¡ã§æœ‰åŠ¹ã§ã™:",
  J8 = () => "jest wÅ‚Ä…czone na",
  Q8 = () => "Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾ Ğ½Ğ°",
  tj = () => "ÑƒĞ²Ñ–Ğ¼ĞºĞ½ĞµĞ½Ğ¾ Ğ½Ğ°",
  ej = () => "Ä‘Æ°á»£c báº­t trÃªn",
  rj = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Z8() : t === "pt" ? G8() : t === "ch" ? H8() : t === "de" ? W8() : t === "es" ? $8() : t === "fr" ? X8() : t === "it" ? Y8() : t === "jp" ? K8() : t === "pl" ? J8() : t === "ru" ? Q8() : t === "uk" ? tj() : ej()
  },
  nj = () => "Items",
  ij = () => "Itens",
  oj = () => "ç‰©å“",
  sj = () => "Items",
  aj = () => "Ãtems",
  uj = () => "Objets",
  cj = () => "Oggetti",
  lj = () => "ã‚¢ã‚¤ãƒ†ãƒ ",
  _j = () => "Przedmioty",
  hj = () => "ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚Ñ‹",
  dj = () => "ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¸",
  pj = () => "Váº­t pháº©m",
  fj = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? nj() : t === "pt" ? ij() : t === "ch" ? oj() : t === "de" ? sj() : t === "es" ? aj() : t === "fr" ? uj() : t === "it" ? cj() : t === "jp" ? lj() : t === "pl" ? _j() : t === "ru" ? hj() : t === "uk" ? dj() : pj()
  },
  mj = () => "Leave alliance",
  gj = () => "Sair da alianÃ§a",
  yj = () => "ç¦»å¼€è”ç›Ÿ",
  vj = () => "Allianz verlassen",
  bj = () => "Salir de la alianza",
  xj = () => "Quitter lâ€™alliance",
  wj = () => "Esci dall'alleanza",
  kj = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’æŠœã‘ã‚‹",
  Tj = () => "OpuÅ›Ä‡ sojusz",
  Sj = () => "Ğ’Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· Ğ°Ğ»ÑŒÑĞ½ÑĞ°",
  Pj = () => "Ğ’Ğ¸Ğ¹Ñ‚Ğ¸ Ğ· Ğ°Ğ»ÑŒÑĞ½ÑÑƒ",
  Mj = () => "Rá»i liÃªn minh",
  Cj = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mj() : t === "pt" ? gj() : t === "ch" ? yj() : t === "de" ? vj() : t === "es" ? bj() : t === "fr" ? xj() : t === "it" ? wj() : t === "jp" ? kj() : t === "pl" ? Tj() : t === "ru" ? Sj() : t === "uk" ? Pj() : Mj()
  },
  Ij = () => "Light mode",
  zj = () => "Modo claro",
  Aj = () => "æµ…è‰²æ¨¡å¼",
  Ej = () => "Heller Modus",
  jj = () => "Modo claro",
  Lj = () => "Mode clair",
  Dj = () => "Tema chiaro",
  Rj = () => "ãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒ",
  Bj = () => "Tryb jasny",
  Fj = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ°Ñ Ñ‚ĞµĞ¼Ğ°",
  Oj = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ° Ñ‚ĞµĞ¼Ğ°",
  qj = () => "Cháº¿ Ä‘á»™ sÃ¡ng",
  Nj = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ij() : t === "pt" ? zj() : t === "ch" ? Aj() : t === "de" ? Ej() : t === "es" ? jj() : t === "fr" ? Lj() : t === "it" ? Dj() : t === "jp" ? Rj() : t === "pl" ? Bj() : t === "ru" ? Fj() : t === "uk" ? Oj() : qj()
  },
  Vj = () => "Limit reached",
  Uj = () => "Limite atingido",
  Zj = () => "å·²è¾¾åˆ°ä¸Šé™",
  Gj = () => "Limit erreicht",
  Hj = () => "LÃ­mite alcanzado",
  Wj = () => "Limite atteinte",
  $j = () => "Limite raggiunto",
  Xj = () => "ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚",
  Yj = () => "OsiÄ…gniÄ™to limit",
  Kj = () => "Ğ”Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚",
  Jj = () => "Ğ”Ğ¾ÑÑĞ³Ğ½ÑƒÑ‚Ğ¾ Ğ»Ñ–Ğ¼Ñ–Ñ‚",
  Qj = () => "ÄÃ£ Ä‘áº¡t giá»›i háº¡n",
  tL = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Vj() : t === "pt" ? Uj() : t === "ch" ? Zj() : t === "de" ? Gj() : t === "es" ? Hj() : t === "fr" ? Wj() : t === "it" ? $j() : t === "jp" ? Xj() : t === "pl" ? Yj() : t === "ru" ? Kj() : t === "uk" ? Jj() : Qj()
  },
  eL = () => "Link your Discord",
  rL = () => "Conectar Discord",
  nL = () => "å…³è”ä½ çš„ Discord",
  iL = () => "Discord verknÃ¼pfen",
  oL = () => "Vincular Discord",
  sL = () => "Lier votre Discord",
  aL = () => "Collega Discord",
  uL = () => "Discordã‚’é€£æºã™ã‚‹",
  cL = () => "PoÅ‚Ä…cz Discord",
  lL = () => "ĞŸÑ€Ğ¸Ğ²ÑĞ·Ğ°Ñ‚ÑŒ Discord",
  _L = () => "ĞŸÑ€Ğ¸Ğ²Ê¼ÑĞ·Ğ°Ñ‚Ğ¸ Discord",
  hL = () => "LiÃªn káº¿t Discord",
  dL = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? eL() : t === "pt" ? rL() : t === "ch" ? nL() : t === "de" ? iL() : t === "es" ? oL() : t === "fr" ? sL() : t === "it" ? aL() : t === "jp" ? uL() : t === "pl" ? cL() : t === "ru" ? lL() : t === "uk" ? _L() : hL()
  },
  pL = () => "Location favorited",
  fL = () => "LocalizaÃ§Ã£o favoritada",
  mL = () => "ä½ç½®å·²æ”¶è—",
  gL = () => "Ort favorisiert",
  yL = () => "UbicaciÃ³n agregada a favoritos",
  vL = () => "Emplacement ajoutÃ© aux favoris",
  bL = () => "LocalitÃ  aggiunta ai preferiti",
  xL = () => "å ´æ‰€ã‚’ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã—ã¾ã—ãŸã€‚",
  wL = () => "Lokalizacja dodana do ulubionych",
  kL = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ",
  TL = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ñ–Ñ Ğ´Ğ¾Ğ´Ğ°Ğ½Ğ¾ Ğ´Ğ¾ Ğ²Ğ¸Ğ±Ñ€Ğ°Ğ½Ğ¸Ñ…",
  SL = () => "ÄÃ£ thÃªm vá»‹ trÃ­ vÃ o yÃªu thÃ­ch",
  PL = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pL() : t === "pt" ? fL() : t === "ch" ? mL() : t === "de" ? gL() : t === "es" ? yL() : t === "fr" ? vL() : t === "it" ? bL() : t === "jp" ? xL() : t === "pl" ? wL() : t === "ru" ? kL() : t === "uk" ? TL() : SL()
  },
  ML = () => "Location unfavorited",
  CL = () => "LocalizaÃ§Ã£o desfavoritada",
  IL = () => "ä½ç½®å·²å–æ¶ˆæ”¶è—",
  zL = () => "Ort aus Favoriten entfernt",
  AL = () => "UbicaciÃ³n eliminada de favoritos",
  EL = () => "Emplacement retirÃ© des favoris",
  jL = () => "LocalitÃ  rimossa dai preferiti",
  LL = () => "å ´æ‰€ã®ãŠæ°—ã«å…¥ã‚Šã‚’è§£é™¤ã—ã¾ã—ãŸã€‚",
  DL = () => "Lokalizacja usuniÄ™ta z ulubionych",
  RL = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ° Ğ¸Ğ· Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾",
  BL = () => "Ğ›Ğ¾ĞºĞ°Ñ†Ñ–Ñ Ğ²Ğ¸Ğ»ÑƒÑ‡ĞµĞ½Ğ¾ Ğ· Ğ²Ğ¸Ğ±Ñ€Ğ°Ğ½Ğ¸Ñ…",
  FL = () => "ÄÃ£ bá» yÃªu thÃ­ch vá»‹ trÃ­",
  OL = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ML() : t === "pt" ? CL() : t === "ch" ? IL() : t === "de" ? zL() : t === "es" ? AL() : t === "fr" ? EL() : t === "it" ? jL() : t === "jp" ? LL() : t === "pl" ? DL() : t === "ru" ? RL() : t === "uk" ? BL() : FL()
  },
  qL = () => "Lock",
  NL = () => "Travar",
  VL = () => "é”å®š",
  UL = () => "Sperren",
  ZL = () => "Bloquear",
  GL = () => "Verrouiller",
  HL = () => "Blocca",
  WL = () => "ãƒ­ãƒƒã‚¯",
  $L = () => "Zablokuj",
  XL = () => "Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
  YL = () => "Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ñ‚Ğ¸",
  KL = () => "KhÃ³a",
  JL = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qL() : t === "pt" ? NL() : t === "ch" ? VL() : t === "de" ? UL() : t === "es" ? ZL() : t === "fr" ? GL() : t === "it" ? HL() : t === "jp" ? WL() : t === "pl" ? $L() : t === "ru" ? XL() : t === "uk" ? YL() : KL()
  },
  QL = () => "Log in",
  tD = () => "Entrar",
  eD = () => "ç™»å½•",
  rD = () => "Einloggen",
  nD = () => "Iniciar sesiÃ³n",
  iD = () => "Se connecter",
  oD = () => "Accedi",
  sD = () => "ãƒ­ã‚°ã‚¤ãƒ³",
  aD = () => "Zaloguj siÄ™",
  uD = () => "Ğ’Ğ¾Ğ¹Ñ‚Ğ¸",
  cD = () => "Ğ£Ğ²Ñ–Ğ¹Ñ‚Ğ¸",
  lD = () => "ÄÄƒng nháº­p",
  _D = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? QL() : t === "pt" ? tD() : t === "ch" ? eD() : t === "de" ? rD() : t === "es" ? nD() : t === "fr" ? iD() : t === "it" ? oD() : t === "jp" ? sD() : t === "pl" ? aD() : t === "ru" ? uD() : t === "uk" ? cD() : lD()
  },
  hD = () => "Logged out",
  dD = () => "Logout feito",
  pD = () => "å·²ç™»å‡º",
  fD = () => "Ausgeloggt",
  mD = () => "SesiÃ³n cerrada",
  gD = () => "DÃ©connectÃ©",
  yD = () => "Logout effettuato",
  vD = () => "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚",
  bD = () => "Wylogowano",
  xD = () => "Ğ’Ñ‹ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ¸Ğ· Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°",
  wD = () => "Ğ’Ğ¸Ñ…Ñ–Ğ´ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ¾",
  kD = () => "ÄÃ£ Ä‘Äƒng xuáº¥t",
  TD = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hD() : t === "pt" ? dD() : t === "ch" ? pD() : t === "de" ? fD() : t === "es" ? mD() : t === "fr" ? gD() : t === "it" ? yD() : t === "jp" ? vD() : t === "pl" ? bD() : t === "ru" ? xD() : t === "uk" ? wD() : kD()
  },
  SD = () => "This action will log your account out from all devices.",
  PD = () => "Essa aÃ§Ã£o ira desconectar sua conta de todos os dispositivos.",
  MD = () => "æ­¤æ“ä½œå°†ä½¿ä½ çš„è´¦å·åœ¨æ‰€æœ‰è®¾å¤‡ä¸Šç™»å‡ºã€‚",
  CD = () => "Diese Aktion meldet dein Konto auf allen GerÃ¤ten ab.",
  ID = () => "Esta acciÃ³n cerrarÃ¡ tu sesiÃ³n en todos los dispositivos.",
  zD = () => "Cette action dÃ©connectera votre compte de tous les appareils.",
  AD = () => "Questa azione disconnetterÃ  il tuo account da tutti i dispositivi.",
  ED = () => "ã“ã®æ“ä½œã«ã‚ˆã‚Šã€ã™ã¹ã¦ã®ç«¯æœ«ã‹ã‚‰ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ­ã‚°ã‚¢ã‚¦ãƒˆã•ã‚Œã¾ã™ã€‚",
  jD = () => "Ta akcja wyloguje Twoje konto ze wszystkich urzÄ…dzeÅ„.",
  LD = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ Ğ²Ğ°Ñˆ ÑĞµĞ°Ğ½Ñ Ğ½Ğ° Ğ²ÑĞµÑ… ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°Ñ….",
  DD = () => "Ğ¦Ñ Ğ´Ñ–Ñ Ğ²Ğ¸Ğ²ĞµĞ´Ğµ Ğ²Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ğ· ÑƒÑÑ–Ñ… Ğ¿Ñ€Ğ¸ÑÑ‚Ñ€Ğ¾Ñ—Ğ².",
  RD = () => "HÃ nh Ä‘á»™ng nÃ y sáº½ Ä‘Äƒng xuáº¥t tÃ i khoáº£n cá»§a báº¡n khá»i táº¥t cáº£ thiáº¿t bá»‹.",
  BD = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? SD() : t === "pt" ? PD() : t === "ch" ? MD() : t === "de" ? CD() : t === "es" ? ID() : t === "fr" ? zD() : t === "it" ? AD() : t === "jp" ? ED() : t === "pl" ? jD() : t === "ru" ? LD() : t === "uk" ? DD() : RD()
  },
  FD = () => "My map is lagging",
  OD = () => "Meu mapa estÃ¡ travando",
  qD = () => "æˆ‘çš„åœ°å›¾å¾ˆå¡",
  ND = () => "Meine Karte laggt",
  VD = () => "Mi mapa va con lag",
  UD = () => "Ma carte lag",
  ZD = () => "La mia mappa Ã¨ lenta",
  GD = () => "ãƒãƒƒãƒ—ã®å‹•ä½œãŒé‡ã„ã§ã™ã€‚",
  HD = () => "Mapa siÄ™ zacina",
  WD = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ñ‚Ğ¾Ñ€Ğ¼Ğ¾Ğ·Ğ¸Ñ‚",
  $D = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ğ³Ğ°Ğ»ÑŒĞ¼ÑƒÑ”",
  XD = () => "Báº£n Ä‘á»“ cá»§a tÃ´i Ä‘ang bá»‹ lag",
  YD = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? FD() : t === "pt" ? OD() : t === "ch" ? qD() : t === "de" ? ND() : t === "es" ? VD() : t === "fr" ? UD() : t === "it" ? ZD() : t === "jp" ? GD() : t === "pl" ? HD() : t === "ru" ? WD() : t === "uk" ? $D() : XD()
  },
  KD = () => "Mark all as read",
  JD = () => "Marcar tudo como lido",
  QD = () => "å…¨éƒ¨æ ‡è®°ä¸ºå·²è¯»",
  tR = () => "Alle als gelesen markieren",
  eR = () => "Marcar todo como leÃ­do",
  rR = () => "Tout marquer comme lu",
  nR = () => "Segna tutto come letto",
  iR = () => "ã™ã¹ã¦æ—¢èª­ã«ã™ã‚‹",
  oR = () => "Oznacz wszystko jako przeczytane",
  sR = () => "ĞÑ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ğ¾Ğµ",
  aR = () => "ĞŸĞ¾Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚Ğ¸ Ğ²ÑĞµ ÑĞº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğµ",
  uR = () => "ÄÃ¡nh dáº¥u táº¥t cáº£ lÃ  Ä‘Ã£ Ä‘á»c",
  cR = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? KD() : t === "pt" ? JD() : t === "ch" ? QD() : t === "de" ? tR() : t === "es" ? eR() : t === "fr" ? rR() : t === "it" ? nR() : t === "jp" ? iR() : t === "pl" ? oR() : t === "ru" ? sR() : t === "uk" ? aR() : uR()
  },
  lR = () => "+2 max. charge/niveau",
  _R = () => "+2 tinta mÃ¡xima/level",
  hR = () => "æ¯çº§ +2 æœ€å¤§å……èƒ½",
  dR = () => "+2 max. Ladung/Level",
  pR = () => "+2 carga mÃ¡xima/nivel",
  fR = () => "+2 charge max/niveau",
  mR = () => "+2 cariche massime/livello",
  gR = () => "ãƒ¬ãƒ™ãƒ«ã”ã¨ã«æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸ +2",
  yR = () => "+2 maks. Å‚adunkÃ³w na poziom",
  vR = () => "+2 Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ğ°/ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ",
  bR = () => "+2 Ğ¼Ğ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´/Ñ€Ñ–Ğ²ĞµĞ½ÑŒ",
  xR = () => "+2 lÆ°á»£t tÃ´ tá»‘i Ä‘a má»—i cáº¥p",
  wR = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lR() : t === "pt" ? _R() : t === "ch" ? hR() : t === "de" ? dR() : t === "es" ? pR() : t === "fr" ? fR() : t === "it" ? mR() : t === "jp" ? gR() : t === "pl" ? yR() : t === "ru" ? vR() : t === "uk" ? bR() : xR()
  },
  kR = () => "Max. Charges",
  TR = () => "Tinta mÃ¡xima",
  SR = () => "æœ€å¤§å……èƒ½",
  PR = () => "Max. Ladungen",
  MR = () => "Cargas mÃ¡ximas",
  CR = () => "Charges max",
  IR = () => "Cariche massime",
  zR = () => "æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸æ•°",
  AR = () => "Maks. Å‚adunki",
  ER = () => "ĞœĞ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ñ‹",
  jR = () => "ĞœĞ°ĞºÑ. Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ²",
  LR = () => "LÆ°á»£t tÃ´ tá»‘i Ä‘a",
  hy = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kR() : t === "pt" ? TR() : t === "ch" ? SR() : t === "de" ? PR() : t === "es" ? MR() : t === "fr" ? CR() : t === "it" ? IR() : t === "jp" ? zR() : t === "pl" ? AR() : t === "ru" ? ER() : t === "uk" ? jR() : LR()
  },
  DR = () => "Menu",
  RR = () => "Menu",
  BR = () => "èœå•",
  FR = () => "MenÃ¼",
  OR = () => "MenÃº",
  qR = () => "Menu",
  NR = () => "Menu",
  VR = () => "ãƒ¡ãƒ‹ãƒ¥ãƒ¼",
  UR = () => "Menu",
  ZR = () => "ĞœĞµĞ½Ñ",
  GR = () => "ĞœĞµĞ½Ñ",
  HR = () => "Menu",
  WR = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? DR() : t === "pt" ? RR() : t === "ch" ? BR() : t === "de" ? FR() : t === "es" ? OR() : t === "fr" ? qR() : t === "it" ? NR() : t === "jp" ? VR() : t === "pl" ? UR() : t === "ru" ? ZR() : t === "uk" ? GR() : HR()
  },
  $R = () => "Month",
  XR = () => "MÃªs",
  YR = () => "æœˆ",
  KR = () => "Monat",
  JR = () => "Mes",
  QR = () => "Mois",
  tB = () => "Mese",
  eB = () => "æœˆ",
  rB = () => "MiesiÄ…c",
  nB = () => "ĞœĞµÑÑÑ†",
  iB = () => "ĞœÑ–ÑÑÑ†ÑŒ",
  oB = () => "ThÃ¡ng",
  sB = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $R() : t === "pt" ? XR() : t === "ch" ? YR() : t === "de" ? KR() : t === "es" ? JR() : t === "fr" ? QR() : t === "it" ? tB() : t === "jp" ? eB() : t === "pl" ? rB() : t === "ru" ? nB() : t === "uk" ? iB() : oB()
  },
  aB = () => "More",
  uB = () => "Mais",
  cB = () => "æ›´å¤š",
  lB = () => "Mehr",
  _B = () => "MÃ¡s",
  hB = () => "Plus",
  dB = () => "Altro",
  pB = () => "ã‚‚ã£ã¨è¦‹ã‚‹",
  fB = () => "WiÄ™cej",
  mB = () => "Ğ•Ñ‰Ñ‘",
  gB = () => "Ğ‘Ñ–Ğ»ÑŒÑˆĞµ",
  yB = () => "ThÃªm",
  vB = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? aB() : t === "pt" ? uB() : t === "ch" ? cB() : t === "de" ? lB() : t === "es" ? _B() : t === "fr" ? hB() : t === "it" ? dB() : t === "jp" ? pB() : t === "pl" ? fB() : t === "ru" ? mB() : t === "uk" ? gB() : yB()
  },
  bB = () => "Mute",
  xB = () => "Mutar",
  wB = () => "é™éŸ³",
  kB = () => "Stummschalten",
  TB = () => "Silenciar",
  SB = () => "Muet",
  PB = () => "Muta",
  MB = () => "ãƒŸãƒ¥ãƒ¼ãƒˆ",
  CB = () => "Wycisz",
  IB = () => "Ğ—Ğ°Ğ¼ÑŒÑÑ‚Ğ¸Ñ‚ÑŒ",
  zB = () => "Ğ—Ğ°Ğ³Ğ»ÑƒÑˆĞ¸Ñ‚Ğ¸",
  AB = () => "Táº¯t tiáº¿ng",
  EB = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? bB() : t === "pt" ? xB() : t === "ch" ? wB() : t === "de" ? kB() : t === "es" ? TB() : t === "fr" ? SB() : t === "it" ? PB() : t === "jp" ? MB() : t === "pl" ? CB() : t === "ru" ? IB() : t === "uk" ? zB() : AB()
  },
  jB = () => "My location",
  LB = () => "Minha localizaÃ§Ã£o",
  DB = () => "æˆ‘çš„ä½ç½®",
  RB = () => "Mein Standort",
  BB = () => "Mi ubicaciÃ³n",
  FB = () => "Ma position",
  OB = () => "La mia posizione",
  qB = () => "ç¾åœ¨åœ°",
  NB = () => "Moja lokalizacja",
  VB = () => "ĞœĞ¾Ñ‘ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ",
  UB = () => "ĞœĞ¾Ñ” Ğ¼Ñ–ÑÑ†ĞµĞ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¶ĞµĞ½Ğ½Ñ",
  ZB = () => "Vá»‹ trÃ­ cá»§a tÃ´i",
  GB = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? jB() : t === "pt" ? LB() : t === "ch" ? DB() : t === "de" ? RB() : t === "es" ? BB() : t === "fr" ? FB() : t === "it" ? OB() : t === "jp" ? qB() : t === "pl" ? NB() : t === "ru" ? VB() : t === "uk" ? UB() : ZB()
  },
  HB = () => "Name",
  WB = () => "Nome",
  $B = () => "åç§°",
  XB = () => "Name",
  YB = () => "Nombre",
  KB = () => "Nom",
  JB = () => "Nome",
  QB = () => "åå‰",
  tF = () => "Nazwa",
  eF = () => "Ğ˜Ğ¼Ñ",
  rF = () => "Ğ†Ğ¼Ê¼Ñ",
  nF = () => "TÃªn",
  rf = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? HB() : t === "pt" ? WB() : t === "ch" ? $B() : t === "de" ? XB() : t === "es" ? YB() : t === "fr" ? KB() : t === "it" ? JB() : t === "jp" ? QB() : t === "pl" ? tF() : t === "ru" ? eF() : t === "uk" ? rF() : nF()
  },
  iF = () => "Your name is how other users will see you in Wplace. It can be changed every 60 days.",
  oF = () => "Seu nome Ã© como outros usuÃ¡rios o verÃ£o no Wplace. VocÃª pode alterÃ¡-lo a cada 60 dias.",
  sF = () => "ä½ çš„åç§°æ˜¯å…¶ä»–ç©å®¶åœ¨ Wplace ä¸­çœ‹åˆ°çš„åå­—ã€‚æ¯ 60 å¤©å¯ä»¥æ›´æ”¹ä¸€æ¬¡ã€‚",
  aF = () => "Dein Name ist das, was andere Nutzer in Wplace sehen. Er kann alle 60 Tage geÃ¤ndert werden.",
  uF = () => "Tu nombre es cÃ³mo te verÃ¡n otros usuarios en Wplace. Se puede cambiar cada 60 dÃ­as.",
  cF = () => "Votre nom est celui que les autres utilisateurs verront dans Wplace. Vous pouvez le changer tous les 60 jours.",
  lF = () => "Il tuo nome Ã¨ come gli altri utenti ti vedranno su Wplace. Puoi cambiarlo ogni 60 giorni.",
  _F = () => "ã‚ãªãŸã®åå‰ã¯ã€Wplaceå†…ã§ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¡¨ç¤ºã•ã‚Œã‚‹åå‰ã§ã™ã€‚60æ—¥ã«ä¸€åº¦å¤‰æ›´ã§ãã¾ã™ã€‚",
  hF = () => "Twoje imiÄ™ to to, jak inni uÅ¼ytkownicy widzÄ… CiÄ™ w Wplace. MoÅ¼na je zmieniaÄ‡ co 60 dni.",
  dF = () => "Ğ’Ğ°ÑˆĞµ Ğ¸Ğ¼Ñ â€” Ñ‚Ğ¾, ĞºĞ°Ğº Ğ²Ğ°Ñ Ğ²Ğ¸Ğ´ÑÑ‚ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ² Wplace. Ğ•Ğ³Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€Ğ°Ğ· Ğ² 60 Ğ´Ğ½ĞµĞ¹.",
  pF = () => "Ğ’Ğ°ÑˆĞµ Ñ–Ğ¼Ê¼Ñ â€” Ñ†Ğµ Ñ‚Ğµ, ÑĞº Ñ–Ğ½ÑˆÑ– ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ– Ğ±Ğ°Ñ‡Ğ¸Ñ‚Ğ¸Ğ¼ÑƒÑ‚ÑŒ Ğ²Ğ°Ñ Ñƒ Wplace. Ğ™Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ·Ğ¼Ñ–Ğ½ÑĞ²Ğ°Ñ‚Ğ¸ Ñ€Ğ°Ğ· Ğ½Ğ° 60 Ğ´Ğ½Ñ–Ğ².",
  fF = () => "TÃªn lÃ  cÃ¡ch ngÆ°á»i chÆ¡i khÃ¡c nhÃ¬n tháº¥y báº¡n trong Wplace. Báº¡n cÃ³ thá»ƒ Ä‘á»•i tÃªn má»—i 60 ngÃ y.",
  mF = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? iF() : t === "pt" ? oF() : t === "ch" ? sF() : t === "de" ? aF() : t === "es" ? uF() : t === "fr" ? cF() : t === "it" ? lF() : t === "jp" ? _F() : t === "pl" ? hF() : t === "ru" ? dF() : t === "uk" ? pF() : fF()
  },
  gF = () => "No action",
  yF = () => "Sem opÃ§Ã£o",
  vF = () => "æ— æ“ä½œ",
  bF = () => "Keine Aktion",
  xF = () => "Sin acciÃ³n",
  wF = () => "Aucune action",
  kF = () => "Nessuna azione",
  TF = () => "å¯¾å¿œãªã—",
  SF = () => "Brak akcji",
  PF = () => "ĞĞµÑ‚ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ",
  MF = () => "ĞĞµĞ¼Ğ°Ñ” Ğ´Ñ–Ñ—",
  CF = () => "KhÃ´ng cÃ³ hÃ nh Ä‘á»™ng",
  IF = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? gF() : t === "pt" ? yF() : t === "ch" ? vF() : t === "de" ? bF() : t === "es" ? xF() : t === "fr" ? wF() : t === "it" ? kF() : t === "jp" ? TF() : t === "pl" ? SF() : t === "ru" ? PF() : t === "uk" ? MF() : CF()
  },
  zF = () => "No banned users",
  AF = () => "Sem usuÃ¡rios banidos",
  EF = () => "æ²¡æœ‰è¢«å°ç¦çš„ç”¨æˆ·",
  jF = () => "Keine gebannten Benutzer",
  LF = () => "No hay usuarios baneados",
  DF = () => "Aucun utilisateur banni",
  RF = () => "Nessun utente bannato",
  BF = () => "BANã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã„ã¾ã›ã‚“ã€‚",
  FF = () => "Brak zbanowanych uÅ¼ytkownikÃ³w",
  OF = () => "ĞĞµÑ‚ Ğ·Ğ°Ğ±Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹",
  qF = () => "ĞĞµĞ¼Ğ°Ñ” Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²",
  NF = () => "KhÃ´ng cÃ³ ngÆ°á»i dÃ¹ng bá»‹ cáº¥m",
  VF = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? zF() : t === "pt" ? AF() : t === "ch" ? EF() : t === "de" ? jF() : t === "es" ? LF() : t === "fr" ? DF() : t === "it" ? RF() : t === "jp" ? BF() : t === "pl" ? FF() : t === "ru" ? OF() : t === "uk" ? qF() : NF()
  },
  UF = () => "No country found.",
  ZF = () => "PaÃ­s nÃ£o encontrado.",
  GF = () => "æœªæ‰¾åˆ°å›½å®¶ã€‚",
  HF = () => "Kein Land gefunden.",
  WF = () => "No se encontrÃ³ ningÃºn paÃ­s.",
  $F = () => "Aucun pays trouvÃ©.",
  XF = () => "Paese non trovato.",
  YF = () => "å›½ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚",
  KF = () => "Nie znaleziono kraju.",
  JF = () => "Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°.",
  QF = () => "ĞšÑ€Ğ°Ñ—Ğ½Ñƒ Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.",
  t7 = () => "KhÃ´ng tÃ¬m tháº¥y quá»‘c gia.",
  e7 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? UF() : t === "pt" ? ZF() : t === "ch" ? GF() : t === "de" ? HF() : t === "es" ? WF() : t === "fr" ? $F() : t === "it" ? XF() : t === "jp" ? YF() : t === "pl" ? KF() : t === "ru" ? JF() : t === "uk" ? QF() : t7()
  },
  r7 = () => "No description",
  n7 = () => "Sem descriÃ§Ã£o",
  i7 = () => "æ— æè¿°",
  o7 = () => "Keine Beschreibung",
  s7 = () => "Sin descripciÃ³n",
  a7 = () => "Aucune description",
  u7 = () => "Nessuna descrizione",
  c7 = () => "èª¬æ˜ãªã—",
  l7 = () => "Brak opisu",
  _7 = () => "Ğ‘ĞµĞ· Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ",
  h7 = () => "Ğ‘ĞµĞ· Ğ¾Ğ¿Ğ¸ÑÑƒ",
  d7 = () => "KhÃ´ng cÃ³ mÃ´ táº£",
  fv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? r7() : t === "pt" ? n7() : t === "ch" ? i7() : t === "de" ? o7() : t === "es" ? s7() : t === "fr" ? a7() : t === "it" ? u7() : t === "jp" ? c7() : t === "pl" ? l7() : t === "ru" ? _7() : t === "uk" ? h7() : d7()
  },
  p7 = () => "ğŸš« No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  f7 = () => "ğŸš« ConteÃºdo inapropriado nÃ£o permitido (+18, discurso de Ã³dio, links inapropriados, conteÃºdo altamente sugestivo, ...)",
  m7 = () => "ğŸš« ä¸å…è®¸å‡ºç°ä¸å½“å†…å®¹ï¼ˆ+18ã€ä»‡æ¨è¨€è®ºã€ä¸å½“é“¾æ¥ã€é«˜åº¦æš—ç¤ºæ€§å†…å®¹ç­‰ï¼‰",
  g7 = () => "ğŸš« Kein unangemessener Inhalt (+18, Hassrede, unangemessene Links, stark anzÃ¼gliches Material, ...)",
  y7 = () => "ğŸš« Sin contenido inapropiado (+18, discurso de odio, enlaces inapropiados, contenido altamente sugerente, ...)",
  v7 = () => "ğŸš« Aucun contenu inappropriÃ© (+18, discours haineux, liens inappropriÃ©s, contenu trÃ¨s suggestif, ...)",
  b7 = () => "ğŸš« Contenuto inappropriato non consentito (+18, discorsi d'odio, link inappropriati, contenuto altamente esplicito, ...)",
  x7 = () => "ğŸš« ä¸é©åˆ‡ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯ç¦æ­¢ã§ã™ï¼ˆ18ç¦ã€ãƒ˜ã‚¤ãƒˆã‚¹ãƒ”ãƒ¼ãƒã€ä¸é©åˆ‡ãªãƒªãƒ³ã‚¯ã€éåº¦ã«æ€§çš„ãªå†…å®¹ãªã©ï¼‰ã€‚",
  w7 = () => "ğŸš« Brak treÅ›ci nieodpowiednich (+18, mowa nienawiÅ›ci, nieodpowiednie linki, mocno sugestywne materiaÅ‚y, ...)",
  k7 = () => "ğŸš« ĞĞ¸ĞºĞ°ĞºĞ¾Ğ³Ğ¾ Ğ½ĞµĞ¿Ñ€Ğ¸ĞµĞ¼Ğ»ĞµĞ¼Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ğ° (+18, Ñ€ĞµÑ‡ÑŒ Ğ½ĞµĞ½Ğ°Ğ²Ğ¸ÑÑ‚Ğ¸, Ğ½ĞµĞ¿Ñ€Ğ¸ĞµĞ¼Ğ»ĞµĞ¼Ñ‹Ğµ ÑÑÑ‹Ğ»ĞºĞ¸, ĞºÑ€Ğ°Ğ¹Ğ½Ğµ Ğ¾Ñ‚ĞºÑ€Ğ¾Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚ Ğ¸ Ñ‚.Ğ¿.)",
  T7 = () => "ğŸš« Ğ–Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ½ĞµĞ¿Ñ€Ğ¸Ğ¹Ğ½ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ñƒ (+18, Ğ¼Ğ¾Ğ²Ğ° Ğ²Ğ¾Ñ€Ğ¾Ğ¶Ğ½ĞµÑ‡Ñ–, Ğ½ĞµĞ¿Ñ€Ğ¸Ğ¹Ğ½ÑÑ‚Ğ½Ñ– Ğ¿Ğ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ, Ğ´ÑƒĞ¶Ğµ Ğ²Ñ–Ğ´Ğ²ĞµÑ€Ñ‚Ğ¸Ğ¹ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚, ...)",
  S7 = () => "ğŸš« KhÃ´ng cho phÃ©p ná»™i dung khÃ´ng phÃ¹ há»£p (+18, ngÃ´n tá»« thÃ¹ háº±n, liÃªn káº¿t khÃ´ng phÃ¹ há»£p, ná»™i dung khiÃªu gá»£i máº¡nh, ...)",
  P7 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? p7() : t === "pt" ? f7() : t === "ch" ? m7() : t === "de" ? g7() : t === "es" ? y7() : t === "fr" ? v7() : t === "it" ? b7() : t === "jp" ? x7() : t === "pl" ? w7() : t === "ru" ? k7() : t === "uk" ? T7() : S7()
  },
  M7 = () => "No more charges",
  C7 = () => "Acabou a tinta",
  I7 = () => "æ²¡æœ‰å‰©ä½™å……èƒ½",
  z7 = () => "Keine Ladungen mehr",
  A7 = () => "No tienes mÃ¡s cargas",
  E7 = () => "Plus de charges",
  j7 = () => "Vernice esaurita",
  L7 = () => "ãƒãƒ£ãƒ¼ã‚¸ãŒæ®‹ã£ã¦ã„ã¾ã›ã‚“ã€‚",
  D7 = () => "Brak Å‚adunkÃ³w",
  R7 = () => "Ğ—Ğ°Ñ€ÑĞ´Ñ‹ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ¸ÑÑŒ",
  B7 = () => "Ğ—Ğ°Ñ€ÑĞ´ Ğ·Ğ°ĞºÑ–Ğ½Ñ‡Ğ¸Ğ²ÑÑ",
  F7 = () => "KhÃ´ng cÃ²n lÆ°á»£t tÃ´",
  O7 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? M7() : t === "pt" ? C7() : t === "ch" ? I7() : t === "de" ? z7() : t === "es" ? A7() : t === "fr" ? E7() : t === "it" ? j7() : t === "jp" ? L7() : t === "pl" ? D7() : t === "ru" ? R7() : t === "uk" ? B7() : F7()
  },
  q7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Do not paint with more than one account",
  N7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ NÃ£o desenhe com mais de uma conta",
  V7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ è¯·å‹¿ä½¿ç”¨å¤šä¸ªè´¦å·è¿›è¡Œç»˜åˆ¶",
  U7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Verwende nicht mehr als ein Konto zum Malen",
  Z7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ No pintes con mÃ¡s de una cuenta",
  G7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Ne dessinez pas avec plus dâ€™un compte",
  H7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Non disegnare con piÃ¹ di un account",
  W7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ è¤‡æ•°ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒšã‚¤ãƒ³ãƒˆã—ãªã„ã§ãã ã•ã„ã€‚",
  $7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ Nie maluj, uÅ¼ywajÄ…c wiÄ™cej niÅ¼ jednego konta",
  X7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ ĞĞµĞ»ÑŒĞ·Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ñ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‡ĞµĞ¼ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°",
  Y7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ ĞĞµ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ğ°",
  K7 = () => "ğŸ§‘â€ğŸ¤â€ğŸ§‘ KhÃ´ng tÃ´ báº±ng nhiá»u hÆ¡n má»™t tÃ i khoáº£n",
  J7 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? q7() : t === "pt" ? N7() : t === "ch" ? V7() : t === "de" ? U7() : t === "es" ? Z7() : t === "fr" ? G7() : t === "it" ? H7() : t === "jp" ? W7() : t === "pl" ? $7() : t === "ru" ? X7() : t === "uk" ? Y7() : K7()
  },
  Q7 = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  t9 = () => "NÃ£o Ã© permitido usar vÃ¡rias contas. Use sua conta principal para pintar.",
  e9 = () => "ä½ ä¸èƒ½ä½¿ç”¨å¤šä¸ªè´¦å·ã€‚è¯·ä½¿ç”¨ä½ çš„ä¸»è´¦å·è¿›è¡Œç»˜åˆ¶ã€‚",
  r9 = () => "Es ist nicht erlaubt, mehrere Konten zu verwenden. Nutze dein Hauptkonto zum Malen.",
  n9 = () => "No estÃ¡ permitido usar varias cuentas. Usa tu cuenta principal para pintar.",
  i9 = () => "Lâ€™utilisation de plusieurs comptes nâ€™est pas autorisÃ©e. Utilisez votre compte principal pour peindre.",
  o9 = () => "Non Ã¨ consentito usare piÃ¹ account. Usa il tuo account principale per dipingere.",
  s9 = () => "è¤‡æ•°ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ¡ã‚¤ãƒ³ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒšã‚¤ãƒ³ãƒˆã—ã¦ãã ã•ã„ã€‚",
  a9 = () => "Nie moÅ¼esz uÅ¼ywaÄ‡ wielu kont. UÅ¼yj swojego gÅ‚Ã³wnego konta do malowania.",
  u9 = () => "Ğ—Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ¾Ğ². Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ´Ğ»Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ.",
  c9 = () => "Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸ ĞºÑ–Ğ»ÑŒĞºĞ° Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ñ–Ğ² Ğ·Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ½ĞµĞ½Ğ¾. Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ¹Ñ‚Ğµ ÑĞ²Ñ–Ğ¹ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¸Ğ¹ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ğ´Ğ»Ñ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ.",
  l9 = () => "Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng nhiá»u tÃ i khoáº£n. HÃ£y dÃ¹ng tÃ i khoáº£n chÃ­nh cá»§a báº¡n Ä‘á»ƒ tÃ´.",
  _9 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Q7() : t === "pt" ? t9() : t === "ch" ? e9() : t === "de" ? r9() : t === "es" ? n9() : t === "fr" ? i9() : t === "it" ? o9() : t === "jp" ? s9() : t === "pl" ? a9() : t === "ru" ? u9() : t === "uk" ? c9() : l9()
  },
  h9 = () => "No notifications",
  d9 = () => "Nenhuma notificaÃ§Ã£o",
  p9 = () => "æ²¡æœ‰é€šçŸ¥",
  f9 = () => "Keine Benachrichtigungen",
  m9 = () => "No hay notificaciones",
  g9 = () => "Aucune notification",
  y9 = () => "Nessuna notifica",
  v9 = () => "é€šçŸ¥ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  b9 = () => "Brak powiadomieÅ„",
  x9 = () => "ĞĞµÑ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹",
  w9 = () => "ĞĞµĞ¼Ğ°Ñ” ÑĞ¿Ğ¾Ğ²Ñ–Ñ‰ĞµĞ½ÑŒ",
  k9 = () => "KhÃ´ng cÃ³ thÃ´ng bÃ¡o",
  T9 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? h9() : t === "pt" ? d9() : t === "ch" ? p9() : t === "de" ? f9() : t === "es" ? m9() : t === "fr" ? g9() : t === "it" ? y9() : t === "jp" ? v9() : t === "pl" ? b9() : t === "ru" ? x9() : t === "uk" ? w9() : k9()
  },
  S9 = () => "No pixels painted",
  P9 = () => "Nenhum pixel pintado",
  M9 = () => "å°šæœªç»˜åˆ¶åƒç´ ",
  C9 = () => "Keine Pixel gemalt",
  I9 = () => "No se han pintado pÃ­xeles",
  z9 = () => "Aucun pixel peint",
  A9 = () => "Nessun pixel dipinto",
  E9 = () => "ã¾ã ãƒ”ã‚¯ã‚»ãƒ«ãŒå¡—ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚",
  j9 = () => "Brak pomalowanych pikseli",
  L9 = () => "ĞĞµÑ‚ Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¸ĞºÑĞµĞ»ĞµĞ¹",
  D9 = () => "Ğ–Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ–ĞºÑĞµĞ»Ñ Ğ½Ğµ Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  R9 = () => "ChÆ°a cÃ³ pixel nÃ o Ä‘Æ°á»£c tÃ´",
  Qf = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? S9() : t === "pt" ? P9() : t === "ch" ? M9() : t === "de" ? C9() : t === "es" ? I9() : t === "fr" ? z9() : t === "it" ? A9() : t === "jp" ? E9() : t === "pl" ? j9() : t === "ru" ? L9() : t === "uk" ? D9() : R9()
  },
  B9 = () => "No place found",
  F9 = () => "Nenhum local encontrado",
  O9 = () => "æœªæ‰¾åˆ°åœ°ç‚¹",
  q9 = () => "Kein Ort gefunden",
  N9 = () => "No se encontrÃ³ ningÃºn lugar",
  V9 = () => "Aucun endroit trouvÃ©",
  U9 = () => "Nessun luogo trovato",
  Z9 = () => "å ´æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚",
  G9 = () => "Nie znaleziono miejsca",
  H9 = () => "ĞœĞµÑÑ‚Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹",
  W9 = () => "ĞœÑ–ÑÑ†Ğµ Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾",
  $9 = () => "KhÃ´ng tÃ¬m tháº¥y Ä‘á»‹a Ä‘iá»ƒm nÃ o",
  X9 = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? B9() : t === "pt" ? F9() : t === "ch" ? O9() : t === "de" ? q9() : t === "es" ? N9() : t === "fr" ? V9() : t === "it" ? U9() : t === "jp" ? Z9() : t === "pl" ? G9() : t === "ru" ? H9() : t === "uk" ? W9() : $9()
  },
  Y9 = () => "No recent locations",
  K9 = () => "Nenhum local recente",
  J9 = () => "æš‚æ— æœ€è¿‘ä½ç½®",
  Q9 = () => "Keine besuchten Orte",
  tO = () => "No hay ubicaciones recientes",
  eO = () => "Aucun emplacement rÃ©cent",
  rO = () => "Nessuna localitÃ  recente",
  nO = () => "æœ€è¿‘ã®å ´æ‰€ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
  iO = () => "Brak ostatnich lokalizacji",
  oO = () => "ĞĞµÑ‚ Ğ½ĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ñ… Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¹",
  sO = () => "ĞĞµĞ¼Ğ°Ñ” Ğ½ĞµÑ‰Ğ¾Ğ´Ğ°Ğ²Ğ½Ñ–Ñ… Ğ»Ğ¾ĞºĞ°Ñ†Ñ–Ğ¹",
  aO = () => "KhÃ´ng cÃ³ vá»‹ trÃ­ gáº§n Ä‘Ã¢y",
  uO = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Y9() : t === "pt" ? K9() : t === "ch" ? J9() : t === "de" ? Q9() : t === "es" ? tO() : t === "fr" ? eO() : t === "it" ? rO() : t === "jp" ? nO() : t === "pl" ? iO() : t === "ru" ? oO() : t === "uk" ? sO() : aO()
  },
  cO = () => "No corresponding region on the map (cosmetic effect only)",
  lO = () => "NÃ£o possui regiÃ£o no mapa (apenas efeito cosmÃ©tico)",
  _O = () => "åœ¨åœ°å›¾ä¸Šæ²¡æœ‰å¯¹åº”åŒºåŸŸï¼ˆä»…è£…é¥°æ•ˆæœï¼‰",
  hO = () => "Keine entsprechende Region auf der Karte (nur kosmetischer Effekt)",
  dO = () => "Sin regiÃ³n correspondiente en el mapa (solo efecto cosmÃ©tico)",
  pO = () => "Aucune rÃ©gion correspondante sur la carte (effet cosmÃ©tique seulement)",
  fO = () => "Non ha una regione sulla mappa (solo effetto cosmetico)",
  mO = () => "ãƒãƒƒãƒ—ä¸Šã«å¯¾å¿œã™ã‚‹åœ°åŸŸã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆè¦‹ãŸç›®ã®ã¿ã®åŠ¹æœï¼‰ã€‚",
  gO = () => "Brak odpowiadajÄ…cego regionu na mapie (tylko efekt kosmetyczny)",
  yO = () => "ĞĞµÑ‚ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾ÑĞ¼ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚)",
  vO = () => "ĞĞµĞ¼Ğ°Ñ” Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ½Ğ¾Ñ— Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ñ– Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ– (Ğ»Ğ¸ÑˆĞµ ĞºĞ¾ÑĞ¼ĞµÑ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ ĞµÑ„ĞµĞºÑ‚)",
  bO = () => "KhÃ´ng cÃ³ vÃ¹ng tÆ°Æ¡ng á»©ng trÃªn báº£n Ä‘á»“ (chá»‰ cÃ³ tÃ¡c dá»¥ng trang trÃ­)",
  xO = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? cO() : t === "pt" ? lO() : t === "ch" ? _O() : t === "de" ? hO() : t === "es" ? dO() : t === "fr" ? pO() : t === "it" ? fO() : t === "jp" ? mO() : t === "pl" ? gO() : t === "ru" ? yO() : t === "uk" ? vO() : bO()
  },
  wO = () => "ğŸ¤– Use of bots is not allowed",
  kO = () => "ğŸ¤– Usar bots nÃ£o Ã© permitido",
  TO = () => "ğŸ¤– ä¸å…è®¸ä½¿ç”¨æœºå™¨äººæˆ–è„šæœ¬",
  SO = () => "ğŸ¤– Das Verwenden von Bots ist verboten",
  PO = () => "ğŸ¤– No se permite el uso de bots",
  MO = () => "ğŸ¤– Lâ€™utilisation de bots nâ€™est pas autorisÃ©e",
  CO = () => "ğŸ¤– L'uso di bot non Ã¨ consentito",
  IO = () => "ğŸ¤– ãƒœãƒƒãƒˆã®ä½¿ç”¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  zO = () => "ğŸ¤– UÅ¼ywanie botÃ³w jest zabronione",
  AO = () => "ğŸ¤– Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ¾Ğ² Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ğ¾",
  EO = () => "ğŸ¤– Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ Ğ±Ğ¾Ñ‚Ñ–Ğ² Ğ·Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ½ĞµĞ½Ğ¾",
  jO = () => "ğŸ¤– KhÃ´ng Ä‘Æ°á»£c phÃ©p sá»­ dá»¥ng bot",
  LO = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? wO() : t === "pt" ? kO() : t === "ch" ? TO() : t === "de" ? SO() : t === "es" ? PO() : t === "fr" ? MO() : t === "it" ? CO() : t === "jp" ? IO() : t === "pl" ? zO() : t === "ru" ? AO() : t === "uk" ? EO() : jO()
  },
  DO = () => "Not enough Gouttelettes",
  RO = () => "Droplets insuficientes",
  BO = () => "æ°´æ»´æ•°é‡ä¸è¶³",
  FO = () => "Nicht genug Droplets",
  OO = () => "No tienes suficientes gotas",
  qO = () => "Pas assez de droplets",
  NO = () => "Gocce insufficienti",
  VO = () => "ãƒ‰ãƒ­ãƒƒãƒ—ãƒ¬ãƒƒãƒˆãŒè¶³ã‚Šã¾ã›ã‚“ã€‚",
  UO = () => "Za maÅ‚o kropli",
  ZO = () => "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ droplets",
  GO = () => "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½ÑŒĞ¾ Ğ´Ñ€Ğ¾Ğ¿Ğ»ĞµÑ‚Ñ–Ğ²",
  HO = () => "KhÃ´ng Ä‘á»§ droplets",
  Cd = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? DO() : t === "pt" ? RO() : t === "ch" ? BO() : t === "de" ? FO() : t === "es" ? OO() : t === "fr" ? qO() : t === "it" ? NO() : t === "jp" ? VO() : t === "pl" ? UO() : t === "ru" ? ZO() : t === "uk" ? GO() : HO()
  },
  WO = () => "You are not in an alliance",
  $O = () => "VocÃª nÃ£o estÃ¡ em uma alianÃ§a",
  XO = () => "ä½ ä¸åœ¨ä»»ä½•è”ç›Ÿä¸­",
  YO = () => "Du bist in keiner Allianz",
  KO = () => "No estÃ¡s en una alianza",
  JO = () => "Vous nâ€™Ãªtes pas dans une alliance",
  QO = () => "Non sei in un'alleanza",
  tq = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“ã€‚",
  eq = () => "Nie jesteÅ› w Å¼adnym sojuszu",
  rq = () => "Ğ’Ñ‹ Ğ½Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚Ğµ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑĞµ",
  nq = () => "Ğ’Ğ¸ Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ±ÑƒĞ²Ğ°Ñ”Ñ‚Ğµ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑÑ–",
  iq = () => "Báº¡n khÃ´ng á»Ÿ trong liÃªn minh nÃ o",
  oq = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? WO() : t === "pt" ? $O() : t === "ch" ? XO() : t === "de" ? YO() : t === "es" ? KO() : t === "fr" ? JO() : t === "it" ? QO() : t === "jp" ? tq() : t === "pl" ? eq() : t === "ru" ? rq() : t === "uk" ? nq() : iq()
  },
  sq = () => "Not painted",
  aq = () => "NÃ£o pintado",
  uq = () => "æœªç»˜åˆ¶",
  cq = () => "Nicht gemalt",
  lq = () => "No pintado",
  _q = () => "Non peint",
  hq = () => "Non dipinto",
  dq = () => "æœªå¡—ã‚Š",
  pq = () => "Niezamalowane",
  fq = () => "ĞĞµ Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¾",
  mq = () => "ĞĞµ Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  gq = () => "ChÆ°a tÃ´",
  yq = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? sq() : t === "pt" ? aq() : t === "ch" ? uq() : t === "de" ? cq() : t === "es" ? lq() : t === "fr" ? _q() : t === "it" ? hq() : t === "jp" ? dq() : t === "pl" ? pq() : t === "ru" ? fq() : t === "uk" ? mq() : gq()
  },
  vq = () => "Not set",
  bq = () => "NÃ£o configurado",
  xq = () => "æœªè®¾ç½®",
  wq = () => "Nicht gesetzt",
  kq = () => "No establecido",
  Tq = () => "Non dÃ©fini",
  Sq = () => "Non impostato",
  Pq = () => "æœªè¨­å®š",
  Mq = () => "Nie ustawiono",
  Cq = () => "ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¾",
  Iq = () => "ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¾",
  zq = () => "ChÆ°a Ä‘áº·t",
  Aq = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vq() : t === "pt" ? bq() : t === "ch" ? xq() : t === "de" ? wq() : t === "es" ? kq() : t === "fr" ? Tq() : t === "it" ? Sq() : t === "jp" ? Pq() : t === "pl" ? Mq() : t === "ru" ? Cq() : t === "uk" ? Iq() : zq()
  },
  Eq = () => "Notifications",
  jq = () => "NotificaÃ§Ãµes",
  Lq = () => "é€šçŸ¥",
  Dq = () => "Benachrichtigungen",
  Rq = () => "Notificaciones",
  Bq = () => "Notifications",
  Fq = () => "Notifiche",
  Oq = () => "é€šçŸ¥",
  qq = () => "Powiadomienia",
  Nq = () => "Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ",
  Vq = () => "Ğ¡Ğ¿Ğ¾Ğ²Ñ–Ñ‰ĞµĞ½Ğ½Ñ",
  Uq = () => "ThÃ´ng bÃ¡o",
  mv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Eq() : t === "pt" ? jq() : t === "ch" ? Lq() : t === "de" ? Dq() : t === "es" ? Rq() : t === "fr" ? Bq() : t === "it" ? Fq() : t === "jp" ? Oq() : t === "pl" ? qq() : t === "ru" ? Nq() : t === "uk" ? Vq() : Uq()
  },
  Zq = () => "Offline",
  Gq = () => "Desconectado",
  Hq = () => "ç¦»çº¿",
  Wq = () => "Offline",
  $q = () => "Desconectado",
  Xq = () => "Hors ligne",
  Yq = () => "Offline",
  Kq = () => "ã‚ªãƒ•ãƒ©ã‚¤ãƒ³",
  Jq = () => "Offline",
  Qq = () => "ĞÑ„Ñ„Ğ»Ğ°Ğ¹Ğ½",
  tN = () => "ĞÑ„Ğ»Ğ°Ğ¹Ğ½",
  eN = () => "Ngoáº¡i tuyáº¿n",
  rN = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Zq() : t === "pt" ? Gq() : t === "ch" ? Hq() : t === "de" ? Wq() : t === "es" ? $q() : t === "fr" ? Xq() : t === "it" ? Yq() : t === "jp" ? Kq() : t === "pl" ? Jq() : t === "ru" ? Qq() : t === "uk" ? tN() : eN()
  },
  nN = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  iN = () => "no canto superior direito da tela. Isso bloquearÃ¡ a tela, mas tambÃ©m permitirÃ¡ pintar movendo o dedo sobre o mapa.",
  oN = () => "åœ¨å±å¹•å³ä¸Šè§’ã€‚æ­¤æ“ä½œä¼šé”å®šå±å¹•ï¼Œä½†åŒæ—¶å¯ä»¥é€šè¿‡ç§»åŠ¨æ‰‹æŒ‡åœ¨åœ°å›¾ä¸Šè¿›è¡Œç»˜åˆ¶ã€‚",
  sN = () => "in der oberen rechten Ecke des Bildschirms. Dadurch wird der Bildschirm gesperrt, aber du kannst durch Bewegen deines Fingers Ã¼ber die Karte malen.",
  aN = () => "en la esquina superior derecha de la pantalla. Esto bloquearÃ¡ la pantalla pero tambiÃ©n permitirÃ¡ pintar moviendo el dedo sobre el mapa.",
  uN = () => "dans le coin supÃ©rieur droit de lâ€™Ã©cran. Cela verrouille lâ€™Ã©cran mais permet de peindre en dÃ©plaÃ§ant votre doigt sur la carte.",
  cN = () => "nell'angolo in alto a destra dello schermo. Questo bloccherÃ  lo schermo, ma ti permetterÃ  di dipingere muovendo il dito sulla mappa.",
  lN = () => "ç”»é¢å³ä¸Šã®ãƒœã‚¿ãƒ³ã§ã™ã€‚ç”»é¢ã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ãŒã€æŒ‡ã‚’ãƒãƒƒãƒ—ä¸Šã§å‹•ã‹ã™ã“ã¨ã§ãƒšã‚¤ãƒ³ãƒˆã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚",
  _N = () => "w prawym gÃ³rnym rogu ekranu. To zablokuje ekran, ale umoÅ¼liwi malowanie poprzez przesuwanie palcem po mapie.",
  hN = () => "Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¼ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¼ ÑƒĞ³Ğ»Ñƒ ÑĞºÑ€Ğ°Ğ½Ğ°. Ğ­ĞºÑ€Ğ°Ğ½ Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½, Ğ½Ğ¾ Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ¾Ğ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ñ Ğ¿Ğ°Ğ»ÑŒÑ†ĞµĞ¼ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ğµ.",
  dN = () => "Ñƒ Ğ²ĞµÑ€Ñ…Ğ½ÑŒĞ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¼Ñƒ ĞºÑƒÑ‚Ñ– ĞµĞºÑ€Ğ°Ğ½Ğ°. Ğ¦Ğµ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºÑƒÑ” ĞµĞºÑ€Ğ°Ğ½, Ğ°Ğ»Ğµ Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»Ğ¸Ñ‚ÑŒ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸, Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´ÑÑ‡Ğ¸ Ğ¿Ğ°Ğ»ÑŒÑ†ĞµĞ¼ Ğ¿Ğ¾ ĞºĞ°Ñ€Ñ‚Ñ–.",
  pN = () => "á»Ÿ gÃ³c trÃªn bÃªn pháº£i mÃ n hÃ¬nh. Äiá»u nÃ y sáº½ khÃ³a mÃ n hÃ¬nh nhÆ°ng cho phÃ©p báº¡n tÃ´ báº±ng cÃ¡ch rÃª ngÃ³n tay trÃªn báº£n Ä‘á»“.",
  fN = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? nN() : t === "pt" ? iN() : t === "ch" ? oN() : t === "de" ? sN() : t === "es" ? aN() : t === "fr" ? uN() : t === "it" ? cN() : t === "jp" ? lN() : t === "pl" ? _N() : t === "ru" ? hN() : t === "uk" ? dN() : pN()
  },
  mN = () => "OpenMapTiles Data from",
  gN = () => "OpenMapTiles com dados do",
  yN = () => "åœ°å›¾æ•°æ®æ¥è‡ª OpenMapTiles",
  vN = () => "OpenMapTiles Daten von",
  bN = () => "Datos de OpenMapTiles de",
  xN = () => "DonnÃ©es OpenMapTiles de",
  wN = () => "OpenMapTiles con dati da",
  kN = () => "OpenMapTiles ãƒ‡ãƒ¼ã‚¿æä¾›:",
  TN = () => "Dane OpenMapTiles z",
  SN = () => "Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ OpenMapTiles Ğ¾Ñ‚",
  PN = () => "Ğ”Ğ°Ğ½Ñ– OpenMapTiles Ğ²Ñ–Ğ´",
  MN = () => "Dá»¯ liá»‡u OpenMapTiles tá»«",
  CN = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mN() : t === "pt" ? gN() : t === "ch" ? yN() : t === "de" ? vN() : t === "es" ? bN() : t === "fr" ? xN() : t === "it" ? wN() : t === "jp" ? kN() : t === "pl" ? TN() : t === "ru" ? SN() : t === "uk" ? PN() : MN()
  },
  IN = () => "or hold",
  zN = () => "ou segure",
  AN = () => "æˆ–æŒ‰ä½",
  EN = () => "oder",
  jN = () => "o mantÃ©n pulsado",
  LN = () => "ou maintenez",
  DN = () => "o tieni premuto",
  RN = () => "ã¾ãŸã¯é•·æŠ¼ã—",
  BN = () => "lub przytrzymaj",
  FN = () => "Ğ¸Ğ»Ğ¸ ÑƒĞ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ",
  ON = () => "Ğ°Ğ±Ğ¾ ÑƒÑ‚Ñ€Ğ¸Ğ¼ÑƒĞ¹Ñ‚Ğµ",
  qN = () => "hoáº·c giá»¯",
  NN = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? IN() : t === "pt" ? zN() : t === "ch" ? AN() : t === "de" ? EN() : t === "es" ? jN() : t === "fr" ? LN() : t === "it" ? DN() : t === "jp" ? RN() : t === "pl" ? BN() : t === "ru" ? FN() : t === "uk" ? ON() : qN()
  },
  VN = () => "Overview",
  UN = () => "VisÃ£o Geral",
  ZN = () => "æ¦‚è§ˆ",
  GN = () => "Ãœbersicht",
  HN = () => "Resumen",
  WN = () => "Vue dâ€™ensemble",
  $N = () => "Panoramica",
  XN = () => "æ¦‚è¦",
  YN = () => "PrzeglÄ…d",
  KN = () => "ĞĞ±Ğ·Ğ¾Ñ€",
  JN = () => "ĞĞ³Ğ»ÑĞ´",
  QN = () => "Tá»•ng quan",
  tV = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? VN() : t === "pt" ? UN() : t === "ch" ? ZN() : t === "de" ? GN() : t === "es" ? HN() : t === "fr" ? WN() : t === "it" ? $N() : t === "jp" ? XN() : t === "pl" ? YN() : t === "ru" ? KN() : t === "uk" ? JN() : QN()
  },
  eV = () => "Paint",
  rV = () => "Pintar",
  nV = () => "ç»˜ç”»",
  iV = () => "Malen",
  oV = () => "Pintar",
  sV = () => "Peindre",
  aV = () => "Dipingi",
  uV = () => "ãƒšã‚¤ãƒ³ãƒˆ",
  cV = () => "Maluj",
  lV = () => "Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ",
  _V = () => "ĞœĞ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸",
  hV = () => "TÃ´",
  gv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? eV() : t === "pt" ? rV() : t === "ch" ? nV() : t === "de" ? iV() : t === "es" ? oV() : t === "fr" ? sV() : t === "it" ? aV() : t === "jp" ? uV() : t === "pl" ? cV() : t === "ru" ? lV() : t === "uk" ? _V() : hV()
  },
  dV = () => "Paint Charges",
  pV = () => "Tintas",
  fV = () => "ç»˜åˆ¶å……èƒ½",
  mV = () => "Pixel-Ladungen",
  gV = () => "Cargas de pintura",
  yV = () => "Charges de peinture",
  vV = () => "Cariche di vernice",
  bV = () => "ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸",
  xV = () => "Åadunki malowania",
  wV = () => "Ğ—Ğ°Ñ€ÑĞ´Ñ‹",
  kV = () => "Ğ—Ğ°Ñ€ÑĞ´Ğ¸ Ñ„Ğ°Ñ€Ğ±Ğ¸",
  TV = () => "LÆ°á»£t tÃ´",
  SV = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? dV() : t === "pt" ? pV() : t === "ch" ? fV() : t === "de" ? mV() : t === "es" ? gV() : t === "fr" ? yV() : t === "it" ? vV() : t === "jp" ? bV() : t === "pl" ? xV() : t === "ru" ? wV() : t === "uk" ? kV() : TV()
  },
  PV = () => "Paint pixel",
  MV = () => "Pintar pixel",
  CV = () => "ç»˜åˆ¶åƒç´ ",
  IV = () => "Pixel malen",
  zV = () => "Pintar pÃ­xel",
  AV = () => "Peindre un pixel",
  EV = () => "Dipingere pixel",
  jV = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’å¡—ã‚‹",
  LV = () => "Pomaluj piksel",
  DV = () => "ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ",
  RV = () => "ĞĞ°Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ",
  BV = () => "TÃ´ pixel",
  FV = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? PV() : t === "pt" ? MV() : t === "ch" ? CV() : t === "de" ? IV() : t === "es" ? zV() : t === "fr" ? AV() : t === "it" ? EV() : t === "jp" ? jV() : t === "pl" ? LV() : t === "ru" ? DV() : t === "uk" ? RV() : BV()
  },
  OV = () => "Painted",
  qV = () => "Pintados",
  NV = () => "å·²ç»˜åˆ¶",
  VV = () => "gemalt",
  UV = () => "Pintado",
  ZV = () => "Peints",
  GV = () => "Dipinti",
  HV = () => "å¡—ã‚‰ã‚ŒãŸ",
  WV = () => "Pomalowane",
  $V = () => "ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¾",
  XV = () => "ĞĞ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  YV = () => "ÄÃ£ tÃ´",
  Tc = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? OV() : t === "pt" ? qV() : t === "ch" ? NV() : t === "de" ? VV() : t === "es" ? UV() : t === "fr" ? ZV() : t === "it" ? GV() : t === "jp" ? HV() : t === "pl" ? WV() : t === "ru" ? $V() : t === "uk" ? XV() : YV()
  },
  KV = () => "Painted by",
  JV = () => "Pintado por",
  QV = () => "ç»˜åˆ¶è€…",
  tU = () => "Gemalt von",
  eU = () => "Pintado por",
  rU = () => "Peint par",
  nU = () => "Dipinto da",
  iU = () => "å¡—ã£ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼",
  oU = () => "Pomalowane przez",
  sU = () => "ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¾",
  aU = () => "ĞĞ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¾",
  uU = () => "ÄÆ°á»£c tÃ´ bá»Ÿi",
  cU = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? KV() : t === "pt" ? JV() : t === "ch" ? QV() : t === "de" ? tU() : t === "es" ? eU() : t === "fr" ? rU() : t === "it" ? nU() : t === "jp" ? iU() : t === "pl" ? oU() : t === "ru" ? sU() : t === "uk" ? aU() : uU()
  },
  lU = () => "âœ… Painting over other artworks to complement them or create a new drawing is allowed",
  _U = () => "âœ… Desenhar sobre outras artes para complementar ou criar novas artes Ã© permitido",
  hU = () => "âœ… åœ¨ä¸ç ´åä½œå“çš„å‰æä¸‹ï¼Œå¯¹ä»–äººä½œå“è¿›è¡Œè¡¥å……æˆ–åˆ›ä½œæ–°å›¾æ˜¯å…è®¸çš„",
  dU = () => "âœ… Ãœber andere Kunstwerke zu malen, um sie zu ergÃ¤nzen oder ein neues Bild zu erstellen, ist erlaubt",
  pU = () => "âœ… Pintar sobre las obras de otros para complementarlas o crear un nuevo dibujo estÃ¡ permitido",
  fU = () => "âœ… Peindre par-dessus dâ€™autres Å“uvres pour les complÃ©ter ou crÃ©er un nouveau dessin est autorisÃ©",
  mU = () => "âœ… Disegnare sopra le opere altrui per completarle o creare nuove opere Ã¨ consentito",
  gU = () => "âœ… ä»–äººã®ä½œå“ã‚’è£œå®Œã—ãŸã‚Šã€æ–°ã—ã„çµµã‚’ä½œã‚‹ç›®çš„ã§ä¸Šã‹ã‚‰æãè¶³ã™ã“ã¨ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  yU = () => "âœ… Malowanie po cudzych pracach, aby je uzupeÅ‚niÄ‡ lub stworzyÄ‡ nowy rysunek, jest dozwolone",
  vU = () => "âœ… Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ°Ğ±Ğ¾Ñ‚, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ¸Ñ… Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ€Ğ¸ÑÑƒĞ½Ğ¾Ğº, Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¾",
  bU = () => "âœ… ĞœĞ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ‡ÑƒĞ¶Ğ¸Ñ… Ñ€Ğ¾Ğ±Ñ–Ñ‚, Ñ‰Ğ¾Ğ± Ğ´Ğ¾Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ñ‚Ğ¸ Ñ—Ñ… Ğ°Ğ±Ğ¾ ÑÑ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸ Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ğ¼Ğ°Ğ»ÑĞ½Ğ¾Ğº, Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ĞµĞ½Ğ¾",
  xU = () => "âœ… TÃ´ Ä‘Ã¨ lÃªn tÃ¡c pháº©m cá»§a ngÆ°á»i khÃ¡c Ä‘á»ƒ bá»• sung hoáº·c táº¡o tranh má»›i lÃ  Ä‘Æ°á»£c phÃ©p",
  wU = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lU() : t === "pt" ? _U() : t === "ch" ? hU() : t === "de" ? dU() : t === "es" ? pU() : t === "fr" ? fU() : t === "it" ? mU() : t === "jp" ? gU() : t === "pl" ? yU() : t === "ru" ? vU() : t === "uk" ? bU() : xU()
  },
  kU = () => "Phone verification required",
  TU = () => "VerificaÃ§Ã£o de telefone necessÃ¡ria",
  SU = () => "éœ€è¦è¿›è¡Œç”µè¯éªŒè¯",
  PU = () => "Telefon-Verifizierung erforderlich",
  MU = () => "Se requiere verificaciÃ³n de telÃ©fono",
  CU = () => "VÃ©rification du tÃ©lÃ©phone requise",
  IU = () => "Verifica del telefono richiesta",
  zU = () => "é›»è©±ç•ªå·ã®ç¢ºèªãŒå¿…è¦ã§ã™ã€‚",
  AU = () => "Wymagana weryfikacja telefonu",
  EU = () => "Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°",
  jU = () => "ĞŸĞ¾Ñ‚Ñ€Ñ–Ğ±Ğ½Ğµ Ğ¿Ñ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¶ĞµĞ½Ğ½Ñ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ñƒ",
  LU = () => "YÃªu cáº§u xÃ¡c minh sá»‘ Ä‘iá»‡n thoáº¡i",
  dy = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kU() : t === "pt" ? TU() : t === "ch" ? SU() : t === "de" ? PU() : t === "es" ? MU() : t === "fr" ? CU() : t === "it" ? IU() : t === "jp" ? zU() : t === "pl" ? AU() : t === "ru" ? EU() : t === "uk" ? jU() : LU()
  },
  DU = () => "Pick a color from the map",
  RU = () => "Escolha uma cor do mapa",
  BU = () => "ä»åœ°å›¾ä¸­æ‹¾å–é¢œè‰²",
  FU = () => "Farbe von der Karte auswÃ¤hlen",
  OU = () => "Elige un color del mapa",
  qU = () => "Choisissez une couleur sur la carte",
  NU = () => "Scegli un colore dalla mappa",
  VU = () => "ãƒãƒƒãƒ—ã‹ã‚‰è‰²ã‚’æ‹¾ã†",
  UU = () => "Wybierz kolor z mapy",
  ZU = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ†Ğ²ĞµÑ‚ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ",
  GU = () => "ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ ĞºĞ¾Ğ»Ñ–Ñ€ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñ–",
  HU = () => "Chá»n má»™t mÃ u tá»« báº£n Ä‘á»“",
  WU = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? DU() : t === "pt" ? RU() : t === "ch" ? BU() : t === "de" ? FU() : t === "es" ? OU() : t === "fr" ? qU() : t === "it" ? NU() : t === "jp" ? VU() : t === "pl" ? UU() : t === "ru" ? ZU() : t === "uk" ? GU() : HU()
  },
  $U = () => "Pixels",
  XU = () => "Pixels",
  YU = () => "åƒç´ ",
  KU = () => "Pixel",
  JU = () => "PÃ­xeles",
  QU = () => "Pixels",
  tZ = () => "Pixel",
  eZ = () => "ãƒ”ã‚¯ã‚»ãƒ«",
  rZ = () => "Piksele",
  nZ = () => "ĞŸĞ¸ĞºÑĞµĞ»Ğ¸",
  iZ = () => "ĞŸÑ–ĞºÑĞµĞ»Ñ–",
  oZ = () => "Pixel",
  Sc = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $U() : t === "pt" ? XU() : t === "ch" ? YU() : t === "de" ? KU() : t === "es" ? JU() : t === "fr" ? QU() : t === "it" ? tZ() : t === "jp" ? eZ() : t === "pl" ? rZ() : t === "ru" ? nZ() : t === "uk" ? iZ() : oZ()
  },
  sZ = () => "Pixels painted inside the country",
  aZ = () => "Pixels pintados dentro do paÃ­s",
  uZ = () => "åœ¨è¯¥å›½å®¶å†…ç»˜åˆ¶çš„åƒç´ æ•°",
  cZ = () => "Pixel, die innerhalb des Landes gemalt wurden",
  lZ = () => "PÃ­xeles pintados dentro del paÃ­s",
  _Z = () => "Pixels peints dans le pays",
  hZ = () => "Pixel dipinti all'interno del paese",
  dZ = () => "ãã®å›½ã®é ˜åŸŸå†…ã§å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°",
  pZ = () => "Piksele pomalowane wewnÄ…trz kraju",
  fZ = () => "ĞŸĞ¸ĞºÑĞµĞ»Ğ¸, Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ ÑÑ‚Ñ€Ğ°Ğ½Ñ‹",
  mZ = () => "ĞŸÑ–ĞºÑĞµĞ»Ñ–, Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ñ– Ğ²ÑĞµÑ€ĞµĞ´Ğ¸Ğ½Ñ– ĞºÑ€Ğ°Ñ—Ğ½Ğ¸",
  gZ = () => "Pixel Ä‘Ã£ tÃ´ trong quá»‘c gia",
  yZ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? sZ() : t === "pt" ? aZ() : t === "ch" ? uZ() : t === "de" ? cZ() : t === "es" ? lZ() : t === "fr" ? _Z() : t === "it" ? hZ() : t === "jp" ? dZ() : t === "pl" ? pZ() : t === "ru" ? fZ() : t === "uk" ? mZ() : gZ()
  },
  vZ = () => "Pixels painted inside the region",
  bZ = () => "Pixels pintados dentro da regiÃ£o",
  xZ = () => "åœ¨è¯¥åŒºåŸŸå†…ç»˜åˆ¶çš„åƒç´ æ•°",
  wZ = () => "Pixel, die innerhalb der Region gemalt wurden",
  kZ = () => "PÃ­xeles pintados dentro de la regiÃ³n",
  TZ = () => "Pixels peints dans la rÃ©gion",
  SZ = () => "Pixel dipinti all'interno della regione",
  PZ = () => "ãã®åœ°åŸŸå†…ã§å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°",
  MZ = () => "Piksele pomalowane wewnÄ…trz regionu",
  CZ = () => "ĞŸĞ¸ĞºÑĞµĞ»Ğ¸, Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğ°",
  IZ = () => "ĞŸÑ–ĞºÑĞµĞ»Ñ–, Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ñ– Ğ² Ğ¼ĞµĞ¶Ğ°Ñ… Ñ€ĞµĞ³Ñ–Ğ¾Ğ½Ñƒ",
  zZ = () => "Pixel Ä‘Ã£ tÃ´ trong vÃ¹ng",
  AZ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vZ() : t === "pt" ? bZ() : t === "ch" ? xZ() : t === "de" ? wZ() : t === "es" ? kZ() : t === "fr" ? TZ() : t === "it" ? SZ() : t === "jp" ? PZ() : t === "pl" ? MZ() : t === "ru" ? CZ() : t === "uk" ? IZ() : zZ()
  },
  EZ = () => "Players",
  jZ = () => "Jogadores",
  LZ = () => "ç©å®¶",
  DZ = () => "Spieler",
  RZ = () => "Jugadores",
  BZ = () => "Joueurs",
  FZ = () => "Giocatori",
  OZ = () => "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
  qZ = () => "Gracze",
  NZ = () => "Ğ˜Ğ³Ñ€Ğ¾ĞºĞ¸",
  VZ = () => "Ğ“Ñ€Ğ°Ğ²Ñ†Ñ–",
  UZ = () => "NgÆ°á»i chÆ¡i",
  yv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? EZ() : t === "pt" ? jZ() : t === "ch" ? LZ() : t === "de" ? DZ() : t === "es" ? RZ() : t === "fr" ? BZ() : t === "it" ? FZ() : t === "jp" ? OZ() : t === "pl" ? qZ() : t === "ru" ? NZ() : t === "uk" ? VZ() : UZ()
  },
  ZZ = () => "âœ… Griefing political party flags or portraits of politicians is allowed",
  GZ = () => "âœ… Desenhar sobre bandeiras de partidos e retratos de polÃ­ticos Ã© permitido",
  HZ = () => "âœ… ç ´åæ”¿å…šæ——å¸œæˆ–æ”¿æ²»äººç‰©è‚–åƒæ˜¯å…è®¸çš„",
  WZ = () => "âœ… Das Griefen von Parteiflaggen oder PolitikerportrÃ¤ts ist erlaubt",
  $Z = () => "âœ… Griefear banderas de partidos polÃ­ticos o retratos de polÃ­ticos estÃ¡ permitido",
  XZ = () => "âœ… Peindre par-dessus les drapeaux de partis politiques ou les portraits de politiciens est autorisÃ©",
  YZ = () => "âœ… Ãˆ consentito disegnare sopra bandiere di partito e ritratti di politici",
  KZ = () => "âœ… æ”¿å…šã®æ——ã‚„æ”¿æ²»å®¶ã®è‚–åƒç”»ã‚’ã‚°ãƒªãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã™ã‚‹ã“ã¨ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚",
  JZ = () => "âœ… Niszczenie flag partii politycznych lub portretÃ³w politykÃ³w jest dozwolone",
  QZ = () => "âœ… Ğ“Ñ€Ğ¸Ñ„ĞµÑ€ÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ Ğº Ñ„Ğ»Ğ°Ğ³Ğ°Ğ¼ Ğ¿Ğ°Ñ€Ñ‚Ğ¸Ğ¹ Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ñ€Ñ‚Ñ€ĞµÑ‚Ğ°Ğ¼ Ğ¿Ğ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¾Ğ² Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¾",
  tG = () => "âœ… ĞœĞ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€Ñ–Ğ² Ğ¿Ğ°Ñ€Ñ‚Ñ–Ğ¹ Ğ°Ğ±Ğ¾ Ğ¿Ğ¾Ñ€Ñ‚Ñ€ĞµÑ‚Ñ–Ğ² Ğ¿Ğ¾Ğ»Ñ–Ñ‚Ğ¸ĞºÑ–Ğ² Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ĞµĞ½Ğ¾",
  eG = () => "âœ… TÃ´ Ä‘Ã¨ lÃªn cá» Ä‘áº£ng phÃ¡i chÃ­nh trá»‹ hoáº·c chÃ¢n dung chÃ­nh trá»‹ gia lÃ  Ä‘Æ°á»£c phÃ©p",
  rG = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ZZ() : t === "pt" ? GZ() : t === "ch" ? HZ() : t === "de" ? WZ() : t === "es" ? $Z() : t === "fr" ? XZ() : t === "it" ? YZ() : t === "jp" ? KZ() : t === "pl" ? JZ() : t === "ru" ? QZ() : t === "uk" ? tG() : eG()
  },
  nG = () => "Map powered by:",
  iG = () => "Mapa fornecido por:",
  oG = () => "åœ°å›¾æ”¯æŒï¼š",
  sG = () => "Karte bereitgestellt von:",
  aG = () => "Mapa proporcionado por:",
  uG = () => "Carte fournie par :",
  cG = () => "Mappa fornita da:",
  lG = () => "åœ°å›³æä¾›:",
  _G = () => "Mapa dostarczana przez:",
  hG = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ:",
  dG = () => "ĞšĞ°Ñ€Ñ‚Ğ° Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ñ–:",
  pG = () => "Báº£n Ä‘á»“ Ä‘Æ°á»£c cung cáº¥p bá»Ÿi:",
  fG = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? nG() : t === "pt" ? iG() : t === "ch" ? oG() : t === "de" ? sG() : t === "es" ? aG() : t === "fr" ? uG() : t === "it" ? cG() : t === "jp" ? lG() : t === "pl" ? _G() : t === "ru" ? hG() : t === "uk" ? dG() : pG()
  },
  mG = () => "Privacy",
  gG = () => "Privacidade",
  yG = () => "éšç§",
  vG = () => "Datenschutz",
  bG = () => "Privacidad",
  xG = () => "ConfidentialitÃ©",
  wG = () => "Privacy",
  kG = () => "ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼",
  TG = () => "PrywatnoÅ›Ä‡",
  SG = () => "ĞšĞ¾Ğ½Ñ„Ğ¸Ğ´ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ",
  PG = () => "ĞšĞ¾Ğ½Ñ„Ñ–Ğ´ĞµĞ½Ñ†Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ",
  MG = () => "Quyá»n riÃªng tÆ°",
  CG = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mG() : t === "pt" ? gG() : t === "ch" ? yG() : t === "de" ? vG() : t === "es" ? bG() : t === "fr" ? xG() : t === "it" ? wG() : t === "jp" ? kG() : t === "pl" ? TG() : t === "ru" ? SG() : t === "uk" ? PG() : MG()
  },
  IG = () => "Profile",
  zG = () => "Perfil",
  AG = () => "ä¸ªäººèµ„æ–™",
  EG = () => "Profil",
  jG = () => "Perfil",
  LG = () => "Profil",
  DG = () => "Profilo",
  RG = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«",
  BG = () => "Profil",
  FG = () => "ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
  OG = () => "ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»ÑŒ",
  qG = () => "Há»“ sÆ¡",
  NG = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? IG() : t === "pt" ? zG() : t === "ch" ? AG() : t === "de" ? EG() : t === "es" ? jG() : t === "fr" ? LG() : t === "it" ? DG() : t === "jp" ? RG() : t === "pl" ? BG() : t === "ru" ? FG() : t === "uk" ? OG() : qG()
  },
  VG = () => "Profile picture",
  UG = () => "Imagem de perfil",
  ZG = () => "å¤´åƒ",
  GG = () => "Profilbild",
  HG = () => "Imagen de perfil",
  WG = () => "Image de profil",
  $G = () => "Immagine del profilo",
  XG = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒ",
  YG = () => "ZdjÄ™cie profilowe",
  KG = () => "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ",
  JG = () => "Ğ—Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»Ñ",
  QG = () => "áº¢nh Ä‘áº¡i diá»‡n",
  tH = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? VG() : t === "pt" ? UG() : t === "ch" ? ZG() : t === "de" ? GG() : t === "es" ? HG() : t === "fr" ? WG() : t === "it" ? $G() : t === "jp" ? XG() : t === "pl" ? YG() : t === "ru" ? KG() : t === "uk" ? JG() : QG()
  },
  eH = () => "Profile updated",
  rH = () => "Perfil atualizado",
  nH = () => "ä¸ªäººèµ„æ–™å·²æ›´æ–°",
  iH = () => "Profil aktualisiert",
  oH = () => "Perfil actualizado",
  sH = () => "Profil mis Ã  jour",
  aH = () => "Profilo aggiornato",
  uH = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚",
  cH = () => "Profil zaktualizowany",
  lH = () => "ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½",
  _H = () => "ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»ÑŒ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾",
  hH = () => "ÄÃ£ cáº­p nháº­t há»“ sÆ¡",
  dH = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? eH() : t === "pt" ? rH() : t === "ch" ? nH() : t === "de" ? iH() : t === "es" ? oH() : t === "fr" ? sH() : t === "it" ? aH() : t === "jp" ? uH() : t === "pl" ? cH() : t === "ru" ? lH() : t === "uk" ? _H() : hH()
  },
  pH = () => "Pumpkin",
  fH = () => "AbÃ³bora",
  mH = () => "å—ç“œ",
  gH = () => "KÃ¼rbis",
  yH = () => "Calabaza",
  vH = () => "Citrouille",
  bH = () => "Zucca",
  xH = () => "ã‚«ãƒœãƒãƒ£",
  wH = () => "Dynia",
  kH = () => "Ğ¢Ñ‹ĞºĞ²Ğ°",
  TH = () => "Ğ“Ğ°Ñ€Ğ±ÑƒĞ·",
  SH = () => "BÃ­ ngÃ´",
  PH = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pH() : t === "pt" ? fH() : t === "ch" ? mH() : t === "de" ? gH() : t === "es" ? yH() : t === "fr" ? vH() : t === "it" ? bH() : t === "jp" ? xH() : t === "pl" ? wH() : t === "ru" ? kH() : t === "uk" ? TH() : SH()
  },
  MH = () => "Random place",
  CH = () => "Local aleatÃ³rio",
  IH = () => "éšæœºåœ°ç‚¹",
  zH = () => "ZufÃ¤lliger Ort",
  AH = () => "Lugar aleatorio",
  EH = () => "Lieu alÃ©atoire",
  jH = () => "Luogo casuale",
  LH = () => "ãƒ©ãƒ³ãƒ€ãƒ ãªå ´æ‰€",
  DH = () => "Losowe miejsce",
  RH = () => "Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾",
  BH = () => "Ğ’Ğ¸Ğ¿Ğ°Ğ´ĞºĞ¾Ğ²Ğµ Ğ¼Ñ–ÑÑ†Ğµ",
  FH = () => "Vá»‹ trÃ­ ngáº«u nhiÃªn",
  OH = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? MH() : t === "pt" ? CH() : t === "ch" ? IH() : t === "de" ? zH() : t === "es" ? AH() : t === "fr" ? EH() : t === "it" ? jH() : t === "jp" ? LH() : t === "pl" ? DH() : t === "ru" ? RH() : t === "uk" ? BH() : FH()
  },
  qH = () => "Recent",
  NH = () => "Recente",
  VH = () => "æœ€è¿‘",
  UH = () => "Aktuell",
  ZH = () => "Reciente",
  GH = () => "RÃ©cent",
  HH = () => "Recente",
  WH = () => "æœ€è¿‘",
  $H = () => "Ostatnie",
  XH = () => "ĞĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ğµ",
  YH = () => "ĞĞµÑ‰Ğ¾Ğ´Ğ°Ğ²Ğ½Ñ–",
  KH = () => "Gáº§n Ä‘Ã¢y",
  JH = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qH() : t === "pt" ? NH() : t === "ch" ? VH() : t === "de" ? UH() : t === "es" ? ZH() : t === "fr" ? GH() : t === "it" ? HH() : t === "jp" ? WH() : t === "pl" ? $H() : t === "ru" ? XH() : t === "uk" ? YH() : KH()
  },
  QH = () => "Recharge paint charges",
  tW = () => "Recarga de tinta",
  eW = () => "ä¸ºç»˜åˆ¶å……èƒ½å……ç”µ",
  rW = () => "Pixel-Ladungen aufladen",
  nW = () => "Recargar cargas de pintura",
  iW = () => "Recharger les charges de peinture",
  oW = () => "Ricarica della vernice",
  sW = () => "ãƒšã‚¤ãƒ³ãƒˆãƒãƒ£ãƒ¼ã‚¸ã‚’å›å¾©",
  aW = () => "DoÅ‚aduj Å‚adunki malowania",
  uW = () => "Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ñ€ÑĞ´Ñ‹",
  cW = () => "ĞŸĞ¾Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ñ‚Ğ¸ Ğ·Ğ°Ñ€ÑĞ´Ğ¸ Ñ„Ğ°Ñ€Ğ±Ğ¸",
  lW = () => "Náº¡p láº¡i lÆ°á»£t tÃ´",
  _W = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? QH() : t === "pt" ? tW() : t === "ch" ? eW() : t === "de" ? rW() : t === "es" ? nW() : t === "fr" ? iW() : t === "it" ? oW() : t === "jp" ? sW() : t === "pl" ? aW() : t === "ru" ? uW() : t === "uk" ? cW() : lW()
  },
  hW = () => "Redo",
  dW = () => "Refazer",
  pW = () => "é‡åš",
  fW = () => "Wiederholen",
  mW = () => "Rehacer",
  gW = () => "RÃ©tablir",
  yW = () => "Rifai",
  vW = () => "ã‚„ã‚Šç›´ã™",
  bW = () => "PonÃ³w",
  xW = () => "ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ",
  wW = () => "ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚Ğ¸",
  kW = () => "LÃ m láº¡i",
  TW = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hW() : t === "pt" ? dW() : t === "ch" ? pW() : t === "de" ? fW() : t === "es" ? mW() : t === "fr" ? gW() : t === "it" ? yW() : t === "jp" ? vW() : t === "pl" ? bW() : t === "ru" ? xW() : t === "uk" ? wW() : kW()
  },
  SW = () => "Refund",
  PW = () => "Reembolso",
  MW = () => "é€€æ¬¾",
  CW = () => "RÃ¼ckerstattung",
  IW = () => "Reembolso",
  zW = () => "Remboursement",
  AW = () => "Rimborso",
  EW = () => "è¿”é‡‘",
  jW = () => "Zwrot",
  LW = () => "Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ÑÑ€ĞµĞ´ÑÑ‚Ğ²",
  DW = () => "ĞŸĞ¾Ğ²ĞµÑ€Ğ½ĞµĞ½Ğ½Ñ ĞºĞ¾ÑˆÑ‚Ñ–Ğ²",
  RW = () => "HoÃ n tiá»n",
  vv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? SW() : t === "pt" ? PW() : t === "ch" ? MW() : t === "de" ? CW() : t === "es" ? IW() : t === "fr" ? zW() : t === "it" ? AW() : t === "jp" ? EW() : t === "pl" ? jW() : t === "ru" ? LW() : t === "uk" ? DW() : RW()
  },
  BW = () => "Region",
  FW = () => "RegiÃ£o",
  OW = () => "åŒºåŸŸ",
  qW = () => "Region",
  NW = () => "RegiÃ³n",
  VW = () => "RÃ©gion",
  UW = () => "Regione",
  ZW = () => "åœ°åŸŸ",
  GW = () => "Region",
  HW = () => "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½",
  WW = () => "Ğ ĞµĞ³Ñ–Ğ¾Ğ½",
  $W = () => "VÃ¹ng",
  XW = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? BW() : t === "pt" ? FW() : t === "ch" ? OW() : t === "de" ? qW() : t === "es" ? NW() : t === "fr" ? VW() : t === "it" ? UW() : t === "jp" ? ZW() : t === "pl" ? GW() : t === "ru" ? HW() : t === "uk" ? WW() : $W()
  },
  YW = () => "Regions",
  KW = () => "RegiÃµes",
  JW = () => "åŒºåŸŸ",
  QW = () => "Regionen",
  t$ = () => "Regiones",
  e$ = () => "RÃ©gions",
  r$ = () => "Regioni",
  n$ = () => "åœ°åŸŸ",
  i$ = () => "Regiony",
  o$ = () => "Ğ ĞµĞ³Ğ¸Ğ¾Ğ½Ñ‹",
  s$ = () => "Ğ ĞµĞ³Ñ–Ğ¾Ğ½Ğ¸",
  a$ = () => "CÃ¡c vÃ¹ng",
  u$ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? YW() : t === "pt" ? KW() : t === "ch" ? JW() : t === "de" ? QW() : t === "es" ? t$() : t === "fr" ? e$() : t === "it" ? r$() : t === "jp" ? n$() : t === "pl" ? i$() : t === "ru" ? o$() : t === "uk" ? s$() : a$()
  },
  c$ = () => "Report feedback",
  l$ = () => "Feedback de denÃºncia",
  _$ = () => "ä¸¾æŠ¥åé¦ˆ",
  h$ = () => "Meldungs-Feedback",
  d$ = () => "Feedback del reporte",
  p$ = () => "Retour de signalement",
  f$ = () => "Feedback segnalazione",
  m$ = () => "é€šå ±ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯",
  g$ = () => "Informacja zwrotna o zgÅ‚oszeniu",
  y$ = () => "ĞĞ±Ñ€Ğ°Ñ‚Ğ½Ğ°Ñ ÑĞ²ÑĞ·ÑŒ Ğ¿Ğ¾ Ğ¶Ğ°Ğ»Ğ¾Ğ±Ğµ",
  v$ = () => "Ğ’Ñ–Ğ´Ğ³ÑƒĞº Ñ‰Ğ¾Ğ´Ğ¾ ÑĞºĞ°Ñ€Ğ³Ğ¸",
  b$ = () => "Pháº£n há»“i bÃ¡o cÃ¡o",
  py = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? c$() : t === "pt" ? l$() : t === "ch" ? _$() : t === "de" ? h$() : t === "es" ? d$() : t === "fr" ? p$() : t === "it" ? f$() : t === "jp" ? m$() : t === "pl" ? g$() : t === "ru" ? y$() : t === "uk" ? v$() : b$()
  },
  x$ = () => "Your report has been reviewed, and a penalty has been applied to the reported player.",
  w$ = () => "Um jogador denunciado recentemente por vocÃª foi punido.",
  k$ = () => "ä½ çš„ä¸¾æŠ¥å·²è¢«å®¡æ ¸ï¼Œå¯¹è¢«ä¸¾æŠ¥ç©å®¶å·²æ–½åŠ æƒ©ç½šã€‚",
  T$ = () => "Deine Meldung wurde Ã¼berprÃ¼ft und der gemeldete Spieler wurde bestraft.",
  S$ = () => "Un jugador reportado recientemente por ti ha sido sancionado.",
  P$ = () => "Votre signalement a Ã©tÃ© analysÃ© et une sanction a Ã©tÃ© appliquÃ©e au joueur signalÃ©.",
  M$ = () => "Un giocatore che hai segnalato di recente Ã¨ stato punito.",
  C$ = () => "ã‚ãªãŸã®é€šå ±ãŒç¢ºèªã•ã‚Œã€å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‡¦ç½°ãŒé©ç”¨ã•ã‚Œã¾ã—ãŸã€‚",
  I$ = () => "Twoje zgÅ‚oszenie zostaÅ‚o przeanalizowane i na ukaranego gracza naÅ‚oÅ¼ono karÄ™.",
  z$ = () => "Ğ’Ğ°ÑˆĞ° Ğ½ĞµĞ´Ğ°Ğ²Ğ½ÑÑ Ğ¶Ğ°Ğ»Ğ¾Ğ±Ğ° Ğ±Ñ‹Ğ»Ğ° Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ°, Ğ¸ Ğº ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ¼Ñƒ Ğ¸Ğ³Ñ€Ğ¾ĞºÑƒ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¾ Ğ½Ğ°ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ.",
  A$ = () => "ĞšĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°, Ğ½Ğ° ÑĞºĞ¾Ğ³Ğ¾ Ğ²Ğ¸ Ğ½ĞµÑ‰Ğ¾Ğ´Ğ°Ğ²Ğ½Ğ¾ Ğ¿Ğ¾ÑĞºĞ°Ñ€Ğ¶Ğ¸Ğ»Ğ¸ÑÑ, Ğ±ÑƒĞ»Ğ¾ Ğ¿Ğ¾ĞºĞ°Ñ€Ğ°Ğ½Ğ¾.",
  E$ = () => "BÃ¡o cÃ¡o gáº§n Ä‘Ã¢y cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½ vÃ  ngÆ°á»i chÆ¡i bá»‹ bÃ¡o cÃ¡o Ä‘Ã£ bá»‹ pháº¡t.",
  fy = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? x$() : t === "pt" ? w$() : t === "ch" ? k$() : t === "de" ? T$() : t === "es" ? S$() : t === "fr" ? P$() : t === "it" ? M$() : t === "jp" ? C$() : t === "pl" ? I$() : t === "ru" ? z$() : t === "uk" ? A$() : E$()
  },
  j$ = () => "Thank you for helping keep the community fair and safe.",
  L$ = () => "Obrigado por ajudar a manter a comunidade justa e segura!",
  D$ = () => "æ„Ÿè°¢ä½ å¸®åŠ©ç»´æŠ¤ç¤¾åŒºçš„å…¬å¹³ä¸å®‰å…¨ã€‚",
  R$ = () => "Danke, dass du hilfst, die Community fair und sicher zu halten.",
  B$ = () => "Gracias por ayudar a mantener la comunidad justa y segura.",
  F$ = () => "Merci dâ€™aider Ã  garder la communautÃ© juste et sÃ»re.",
  O$ = () => "Grazie per aiutare a mantenere la comunitÃ  giusta e sicura!",
  q$ = () => "ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚’å…¬æ­£ã§å®‰å…¨ã«ä¿ã¤ãŸã‚ã«ã”å”åŠ›ã„ãŸã ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚",
  N$ = () => "DziÄ™kujemy za pomoc w utrzymaniu uczciwej i bezpiecznej spoÅ‚ecznoÅ›ci.",
  V$ = () => "Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°ĞµÑ‚Ğµ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµÑÑ‚Ğ²Ğ¾ Ñ‡ĞµÑÑ‚Ğ½ĞµĞµ Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½ĞµĞµ.",
  U$ = () => "Ğ”ÑĞºÑƒÑ”Ğ¼Ğ¾, Ñ‰Ğ¾ Ğ´Ğ¾Ğ¿Ğ¾Ğ¼Ğ°Ğ³Ğ°Ñ”Ñ‚Ğµ Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ²Ğ°Ñ‚Ğ¸ Ñ‡ĞµÑĞ½Ñ–ÑÑ‚ÑŒ Ñ‚Ğ° Ğ±ĞµĞ·Ğ¿ĞµĞºÑƒ ÑĞ¿Ñ–Ğ»ÑŒĞ½Ğ¾Ñ‚Ğ¸.",
  Z$ = () => "Cáº£m Æ¡n báº¡n Ä‘Ã£ giÃºp giá»¯ cá»™ng Ä‘á»“ng cÃ´ng báº±ng vÃ  an toÃ n.",
  G$ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? j$() : t === "pt" ? L$() : t === "ch" ? D$() : t === "de" ? R$() : t === "es" ? B$() : t === "fr" ? F$() : t === "it" ? O$() : t === "jp" ? q$() : t === "pl" ? N$() : t === "ru" ? V$() : t === "uk" ? U$() : Z$()
  },
  H$ = () => "This action may take some time to be completed.",
  W$ = () => "Essa aÃ§Ã£o pode levar algum tempo para ser realizada.",
  $$ = () => "è¯¥æ“ä½œå¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´æ‰èƒ½å®Œæˆã€‚",
  X$ = () => "Diese Aktion kann etwas Zeit in Anspruch nehmen.",
  Y$ = () => "Esta acciÃ³n puede tardar un poco en completarse.",
  K$ = () => "Cette action peut prendre un certain temps Ã  Ãªtre complÃ©tÃ©e.",
  J$ = () => "Questa azione potrebbe richiedere del tempo per essere completata.",
  Q$ = () => "ã“ã®æ“ä½œã®å®Œäº†ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚",
  tX = () => "Ta akcja moÅ¼e chwilÄ™ potrwaÄ‡.",
  eX = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°Ğ½ÑÑ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ.",
  rX = () => "Ğ¦Ñ Ğ´Ñ–Ñ Ğ¼Ğ¾Ğ¶Ğµ Ğ·Ğ°Ğ¹Ğ½ÑÑ‚Ğ¸ Ğ´ĞµÑĞºĞ¸Ğ¹ Ñ‡Ğ°Ñ.",
  nX = () => "HÃ nh Ä‘á»™ng nÃ y cÃ³ thá»ƒ máº¥t má»™t lÃºc Ä‘á»ƒ hoÃ n thÃ nh.",
  iX = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? H$() : t === "pt" ? W$() : t === "ch" ? $$() : t === "de" ? X$() : t === "es" ? Y$() : t === "fr" ? K$() : t === "it" ? J$() : t === "jp" ? Q$() : t === "pl" ? tX() : t === "ru" ? eX() : t === "uk" ? rX() : nX()
  },
  oX = () => "Rules",
  sX = () => "Regras",
  aX = () => "è§„åˆ™",
  uX = () => "Regeln",
  cX = () => "Reglas",
  lX = () => "RÃ¨gles",
  _X = () => "Regole",
  hX = () => "ãƒ«ãƒ¼ãƒ«",
  dX = () => "Zasady",
  pX = () => "ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°",
  fX = () => "ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°",
  mX = () => "Luáº­t",
  gX = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? oX() : t === "pt" ? sX() : t === "ch" ? aX() : t === "de" ? uX() : t === "es" ? cX() : t === "fr" ? lX() : t === "it" ? _X() : t === "jp" ? hX() : t === "pl" ? dX() : t === "ru" ? pX() : t === "uk" ? fX() : mX()
  },
  yX = () => "Select a color",
  vX = () => "Selecione uma color",
  bX = () => "é€‰æ‹©ä¸€ç§é¢œè‰²",
  xX = () => "Farbe auswÃ¤hlen",
  wX = () => "Selecciona un color",
  kX = () => "SÃ©lectionnez une couleur",
  TX = () => "Seleziona un colore",
  SX = () => "è‰²ã‚’é¸æŠ",
  PX = () => "Wybierz kolor",
  MX = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ†Ğ²ĞµÑ‚",
  CX = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ ĞºĞ¾Ğ»Ñ–Ñ€",
  IX = () => "Chá»n má»™t mÃ u",
  zX = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? yX() : t === "pt" ? vX() : t === "ch" ? bX() : t === "de" ? xX() : t === "es" ? wX() : t === "fr" ? kX() : t === "it" ? TX() : t === "jp" ? SX() : t === "pl" ? PX() : t === "ru" ? MX() : t === "uk" ? CX() : IX()
  },
  AX = () => "Select a pixel to erase",
  EX = () => "Selecione um pixel para apagar",
  jX = () => "é€‰æ‹©è¦æ“¦é™¤çš„åƒç´ ",
  LX = () => "Pixel zum LÃ¶schen auswÃ¤hlen",
  DX = () => "Selecciona un pÃ­xel para borrar",
  RX = () => "SÃ©lectionnez un pixel Ã  effacer",
  BX = () => "Seleziona un pixel da cancellare",
  FX = () => "æ¶ˆã—ãŸã„ãƒ”ã‚¯ã‚»ãƒ«ã‚’é¸æŠ",
  OX = () => "Wybierz piksel do usuniÄ™cia",
  qX = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ Ğ´Ğ»Ñ ÑÑ‚Ğ¸Ñ€Ğ°Ğ½Ğ¸Ñ",
  NX = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ Ğ´Ğ»Ñ ÑÑ‚Ğ¸Ñ€Ğ°Ğ½Ğ½Ñ",
  VX = () => "Chá»n pixel Ä‘á»ƒ xÃ³a",
  UX = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? AX() : t === "pt" ? EX() : t === "ch" ? jX() : t === "de" ? LX() : t === "es" ? DX() : t === "fr" ? RX() : t === "it" ? BX() : t === "jp" ? FX() : t === "pl" ? OX() : t === "ru" ? qX() : t === "uk" ? NX() : VX()
  },
  ZX = () => "Select the area's first corner",
  GX = () => "Selecione o primeiro canto da Ã¡rea",
  HX = () => "é€‰æ‹©åŒºåŸŸçš„ç¬¬ä¸€ä¸ªè§’",
  WX = () => "Erste Ecke des Bereichs auswÃ¤hlen",
  $X = () => "Selecciona la primera esquina del Ã¡rea",
  XX = () => "SÃ©lectionnez le premier coin de la zone",
  YX = () => "Seleziona il primo angolo dell'area",
  KX = () => "é ˜åŸŸã®æœ€åˆã®è§’ã‚’é¸æŠ",
  JX = () => "Wybierz pierwszy naroÅ¼nik obszaru",
  QX = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ ÑƒĞ³Ğ¾Ğ» Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸",
  tY = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹ ĞºÑƒÑ‚ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ñ–",
  eY = () => "Chá»n gÃ³c Ä‘áº§u tiÃªn cá»§a vÃ¹ng",
  rY = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ZX() : t === "pt" ? GX() : t === "ch" ? HX() : t === "de" ? WX() : t === "es" ? $X() : t === "fr" ? XX() : t === "it" ? YX() : t === "jp" ? KX() : t === "pl" ? JX() : t === "ru" ? QX() : t === "uk" ? tY() : eY()
  },
  nY = () => "Select the area's opposite corner",
  iY = () => "Selecione o canto oposto da Ã¡rea",
  oY = () => "é€‰æ‹©åŒºåŸŸçš„å¯¹è§’",
  sY = () => "GegenÃ¼berliegende Ecke des Bereichs auswÃ¤hlen",
  aY = () => "Selecciona la esquina opuesta del Ã¡rea",
  uY = () => "SÃ©lectionnez le coin opposÃ© de la zone",
  cY = () => "Seleziona l'angolo opposto dell'area",
  lY = () => "é ˜åŸŸã®åå¯¾å´ã®è§’ã‚’é¸æŠ",
  _Y = () => "Wybierz przeciwlegÅ‚y naroÅ¼nik obszaru",
  hY = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğ¹ ÑƒĞ³Ğ¾Ğ» Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸",
  dY = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ»ĞµĞ¶Ğ½Ğ¸Ğ¹ ĞºÑƒÑ‚ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ñ–",
  pY = () => "Chá»n gÃ³c Ä‘á»‘i diá»‡n cá»§a vÃ¹ng",
  fY = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? nY() : t === "pt" ? iY() : t === "ch" ? oY() : t === "de" ? sY() : t === "es" ? aY() : t === "fr" ? uY() : t === "it" ? cY() : t === "jp" ? lY() : t === "pl" ? _Y() : t === "ru" ? hY() : t === "uk" ? dY() : pY()
  },
  mY = () => "Select the headquarters location",
  gY = () => "Selecione a localizaÃ§Ã£o do quartel general",
  yY = () => "é€‰æ‹©æ€»éƒ¨ä½ç½®",
  vY = () => "Standort des Hauptquartiers auswÃ¤hlen",
  bY = () => "Selecciona la ubicaciÃ³n del cuartel general",
  xY = () => "SÃ©lectionnez lâ€™emplacement du quartier gÃ©nÃ©ral",
  wY = () => "Seleziona la posizione del quartier generale",
  kY = () => "æ‹ ç‚¹ã®å ´æ‰€ã‚’é¸æŠ",
  TY = () => "Wybierz lokalizacjÄ™ siedziby",
  SY = () => "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑˆÑ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ñ‹",
  PY = () => "Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ñ€Ğ¾Ğ·Ñ‚Ğ°ÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑˆÑ‚Ğ°Ğ±-ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ¸",
  MY = () => "Chá»n vá»‹ trÃ­ trá»¥ sá»Ÿ",
  CY = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mY() : t === "pt" ? gY() : t === "ch" ? yY() : t === "de" ? vY() : t === "es" ? bY() : t === "fr" ? xY() : t === "it" ? wY() : t === "jp" ? kY() : t === "pl" ? TY() : t === "ru" ? SY() : t === "uk" ? PY() : MY()
  },
  IY = () => "Send the link below to everybody you want to invite to the alliance",
  zY = () => "Envie o link abaixo para quem vocÃª deseja convidar para a alianÃ§a",
  AY = () => "å°†ä¸‹é¢çš„é“¾æ¥å‘é€ç»™ä½ æƒ³é‚€è¯·åŠ å…¥è”ç›Ÿçš„æ‰€æœ‰äºº",
  EY = () => "Sende den untenstehenden Link an alle, die du in die Allianz einladen mÃ¶chtest",
  jY = () => "EnvÃ­a el siguiente enlace a las personas que quieras invitar a la alianza",
  LY = () => "Envoyez le lien ci-dessous Ã  toutes les personnes que vous souhaitez inviter dans lâ€™alliance",
  DY = () => "Invia il link qui sotto a chi vuoi invitare nell'alleanza",
  RY = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã«æ‹›å¾…ã—ãŸã„ç›¸æ‰‹ã«ã€ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’é€ã£ã¦ãã ã•ã„ã€‚",
  BY = () => "WyÅ›lij poniÅ¼szy link wszystkim, ktÃ³rych chcesz zaprosiÄ‡ do sojuszu",
  FY = () => "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ Ğ²ÑĞµĞ¼, ĞºĞ¾Ğ³Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  OY = () => "ĞĞ°Ğ´Ñ–ÑˆĞ»Ñ–Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ Ğ½Ğ¸Ğ¶Ñ‡Ğµ Ğ²ÑÑ–Ğ¼, ĞºĞ¾Ğ³Ğ¾ Ñ…Ğ¾Ñ‡ĞµÑ‚Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚Ğ¸ Ğ² Ğ°Ğ»ÑŒÑĞ½Ñ",
  qY = () => "Gá»­i liÃªn káº¿t dÆ°á»›i Ä‘Ã¢y cho nhá»¯ng ngÆ°á»i báº¡n muá»‘n má»i vÃ o liÃªn minh",
  NY = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? IY() : t === "pt" ? zY() : t === "ch" ? AY() : t === "de" ? EY() : t === "es" ? jY() : t === "fr" ? LY() : t === "it" ? DY() : t === "jp" ? RY() : t === "pl" ? BY() : t === "ru" ? FY() : t === "uk" ? OY() : qY()
  },
  VY = () => "Your browser doesn't seem to be compatible to load the map. Please try another browser",
  UY = () => "Seu navegador nÃ£o parece ser compatÃ­vel para o mapa. Por favor, tente outro navegador",
  ZY = () => "æ‚¨çš„æµè§ˆå™¨ä¼¼ä¹ä¸å…¼å®¹åŠ è½½åœ°å›¾ã€‚è¯·å°è¯•ä½¿ç”¨å…¶ä»–æµè§ˆå™¨",
  GY = () => "Ihr Browser scheint nicht kompatibel zu sein, um die Karte zu laden. Bitte versuchen Sie es mit einem anderen Browser",
  HY = () => "Tu navegador no parece ser compatible para cargar el mapa. Por favor, prueba con otro navegador.",
  WY = () => "Votre navigateur ne semble pas compatible pour charger la carte. Veuillez essayer un autre navigateur",
  $Y = () => "Il tuo browser non sembra essere compatibile per caricare la mappa. Prova un altro browser",
  XY = () => "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯åœ°å›³ã®èª­ã¿è¾¼ã¿ã«å¯¾å¿œã—ã¦ã„ãªã„ã‚ˆã†ã§ã™ã€‚åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚",
  YY = () => "Twoja przeglÄ…darka wydaje siÄ™ byÄ‡ niekompatybilna z Å‚adowaniem mapy. SprÃ³buj innej przeglÄ…darki.",
  KY = () => "Ğ’Ğ°Ñˆ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€, Ğ¿Ğ¾Ñ…Ğ¾Ğ¶Ğµ, Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºÑƒ ĞºĞ°Ñ€Ñ‚Ñ‹. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€.",
  JY = () => "Ğ’Ğ°Ñˆ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€, ÑÑ…Ğ¾Ğ¶Ğµ, Ğ½ĞµÑÑƒĞ¼Ñ–ÑĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ ĞºĞ°Ñ€Ñ‚Ğ¸. Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, ÑĞ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ñ–Ğ½ÑˆĞ¸Ğ¹ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€",
  QY = () => "TrÃ¬nh duyá»‡t cá»§a báº¡n cÃ³ váº» khÃ´ng tÆ°Æ¡ng thÃ­ch Ä‘á»ƒ táº£i báº£n Ä‘á»“. Vui lÃ²ng thá»­ trÃ¬nh duyá»‡t khÃ¡c",
  tK = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? VY() : t === "pt" ? UY() : t === "ch" ? ZY() : t === "de" ? GY() : t === "es" ? HY() : t === "fr" ? WY() : t === "it" ? $Y() : t === "jp" ? XY() : t === "pl" ? YY() : t === "ru" ? KY() : t === "uk" ? JY() : QY()
  },
  eK = () => "Share",
  rK = () => "Compartilhar",
  nK = () => "åˆ†äº«",
  iK = () => "Teilen",
  oK = () => "Compartir",
  sK = () => "Partager",
  aK = () => "Condividi",
  uK = () => "å…±æœ‰",
  cK = () => "UdostÄ™pnij",
  lK = () => "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ",
  _K = () => "ĞŸĞ¾Ğ´Ñ–Ğ»Ğ¸Ñ‚Ğ¸ÑÑ",
  hK = () => "Chia sáº»",
  dK = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? eK() : t === "pt" ? rK() : t === "ch" ? nK() : t === "de" ? iK() : t === "es" ? oK() : t === "fr" ? sK() : t === "it" ? aK() : t === "jp" ? uK() : t === "pl" ? cK() : t === "ru" ? lK() : t === "uk" ? _K() : hK()
  },
  pK = () => "Share place",
  fK = () => "Compartilhar local",
  mK = () => "åˆ†äº«åœ°ç‚¹",
  gK = () => "Ort teilen",
  yK = () => "Compartir lugar",
  vK = () => "Partager le lieu",
  bK = () => "Condividi luogo",
  xK = () => "å ´æ‰€ã‚’å…±æœ‰",
  wK = () => "UdostÄ™pnij miejsce",
  kK = () => "ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ¼ĞµÑÑ‚Ğ¾Ğ¼",
  TK = () => "ĞŸĞ¾Ğ´Ñ–Ğ»Ğ¸Ñ‚Ğ¸ÑÑ Ğ¼Ñ–ÑÑ†ĞµĞ¼",
  SK = () => "Chia sáº» vá»‹ trÃ­",
  PK = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pK() : t === "pt" ? fK() : t === "ch" ? mK() : t === "de" ? gK() : t === "es" ? yK() : t === "fr" ? vK() : t === "it" ? bK() : t === "jp" ? xK() : t === "pl" ? wK() : t === "ru" ? kK() : t === "uk" ? TK() : SK()
  },
  MK = () => "Show last painted pixel on alliance",
  CK = () => "Mostrar Ãºltimo pixel pintado na alianÃ§a",
  IK = () => "åœ¨è”ç›Ÿä¸­æ˜¾ç¤ºæœ€åç»˜åˆ¶çš„åƒç´ ",
  zK = () => "Zuletzt gemalten Pixel in der Allianz anzeigen",
  AK = () => "Mostrar el Ãºltimo pÃ­xel pintado en la alianza",
  EK = () => "Afficher le dernier pixel peint dans lâ€™alliance",
  jK = () => "Mostra l'ultimo pixel dipinto nell'alleanza",
  LK = () => "ã‚¢ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã®æœ€å¾Œã«å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã‚’è¡¨ç¤º",
  DK = () => "PokaÅ¼ ostatni pomalowany piksel w sojuszu",
  RK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ, Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ°Ğ»ÑŒÑĞ½ÑĞ¾Ğ¼",
  BK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ Ğ½Ğ°Ğ¼Ğ°Ğ»ÑŒĞ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑÑ–",
  FK = () => "Hiá»ƒn thá»‹ pixel cuá»‘i cÃ¹ng Ä‘Æ°á»£c tÃ´ cá»§a liÃªn minh",
  OK = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? MK() : t === "pt" ? CK() : t === "ch" ? IK() : t === "de" ? zK() : t === "es" ? AK() : t === "fr" ? EK() : t === "it" ? jK() : t === "jp" ? LK() : t === "pl" ? DK() : t === "ru" ? RK() : t === "uk" ? BK() : FK()
  },
  qK = () => "Show Pixel Art",
  NK = () => "Mostrar Pixel Art",
  VK = () => "æ˜¾ç¤ºåƒç´ è‰ºæœ¯",
  UK = () => "Pixel-Art anzeigen",
  ZK = () => "Mostrar Pixel Art",
  GK = () => "Afficher le pixel art",
  HK = () => "Mostra Pixel Art",
  WK = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚¢ãƒ¼ãƒˆã‚’è¡¨ç¤º",
  $K = () => "PokaÅ¼ Pixel Art",
  XK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ-Ğ°Ñ€Ñ‚",
  YK = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Pixel Art",
  KK = () => "Hiá»ƒn thá»‹ pixel art",
  JK = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qK() : t === "pt" ? NK() : t === "ch" ? VK() : t === "de" ? UK() : t === "es" ? ZK() : t === "fr" ? GK() : t === "it" ? HK() : t === "jp" ? WK() : t === "pl" ? $K() : t === "ru" ? XK() : t === "uk" ? YK() : KK()
  },
  QK = () => "Show profile",
  tJ = () => "Exibir perfil",
  eJ = () => "æŸ¥çœ‹ä¸ªäººèµ„æ–™",
  rJ = () => "Profil anzeigen",
  nJ = () => "Mostrar perfil",
  iJ = () => "Afficher le profil",
  oJ = () => "Mostra profilo",
  sJ = () => "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’è¦‹ã‚‹",
  aJ = () => "PokaÅ¼ profil",
  uJ = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
  cJ = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»ÑŒ",
  lJ = () => "Hiá»ƒn thá»‹ há»“ sÆ¡",
  _J = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? QK() : t === "pt" ? tJ() : t === "ch" ? eJ() : t === "de" ? rJ() : t === "es" ? nJ() : t === "fr" ? iJ() : t === "it" ? oJ() : t === "jp" ? sJ() : t === "pl" ? aJ() : t === "ru" ? uJ() : t === "uk" ? cJ() : lJ()
  },
  hJ = () => "SPACE",
  dJ = () => "EspaÃ§o",
  pJ = () => "ç©ºæ ¼é”®",
  fJ = () => "Leertaste",
  mJ = () => "Espacio",
  gJ = () => "Espace",
  yJ = () => "Spazio",
  vJ = () => "ã‚¹ãƒšãƒ¼ã‚¹",
  bJ = () => "SPACJA",
  xJ = () => "ĞŸÑ€Ğ¾Ğ±ĞµĞ»",
  wJ = () => "ĞŸÑ€Ğ¾Ğ±Ñ–Ğ»",
  kJ = () => "PhÃ­m cÃ¡ch",
  TJ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hJ() : t === "pt" ? dJ() : t === "ch" ? pJ() : t === "de" ? fJ() : t === "es" ? mJ() : t === "fr" ? gJ() : t === "it" ? yJ() : t === "jp" ? vJ() : t === "pl" ? bJ() : t === "ru" ? xJ() : t === "uk" ? wJ() : kJ()
  },
  SJ = () => "Store",
  PJ = () => "Loja",
  MJ = () => "å•†åº—",
  CJ = () => "Shop",
  IJ = () => "Tienda",
  zJ = () => "Boutique",
  AJ = () => "Negozio",
  EJ = () => "ã‚¹ãƒˆã‚¢",
  jJ = () => "Sklep",
  LJ = () => "ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½",
  DJ = () => "ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½",
  RJ = () => "Cá»­a hÃ ng",
  bv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? SJ() : t === "pt" ? PJ() : t === "ch" ? MJ() : t === "de" ? CJ() : t === "es" ? IJ() : t === "fr" ? zJ() : t === "it" ? AJ() : t === "jp" ? EJ() : t === "pl" ? jJ() : t === "ru" ? LJ() : t === "uk" ? DJ() : RJ()
  },
  BJ = () => "Submit",
  FJ = () => "Enviar",
  OJ = () => "æäº¤",
  qJ = () => "Senden",
  NJ = () => "Enviar",
  VJ = () => "Envoyer",
  UJ = () => "Invia",
  ZJ = () => "é€ä¿¡",
  GJ = () => "WyÅ›lij",
  HJ = () => "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
  WJ = () => "ĞĞ°Ğ´Ñ–ÑĞ»Ğ°Ñ‚Ğ¸",
  $J = () => "Gá»­i",
  XJ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? BJ() : t === "pt" ? FJ() : t === "ch" ? OJ() : t === "de" ? qJ() : t === "es" ? NJ() : t === "fr" ? VJ() : t === "it" ? UJ() : t === "jp" ? ZJ() : t === "pl" ? GJ() : t === "ru" ? HJ() : t === "uk" ? WJ() : $J()
  },
  YJ = () => "Suggestions",
  KJ = () => "SugestÃµes",
  JJ = () => "å»ºè®®",
  QJ = () => "VorschlÃ¤ge",
  tQ = () => "Sugerencias",
  eQ = () => "Suggestions",
  rQ = () => "Suggerimenti",
  nQ = () => "ææ¡ˆ",
  iQ = () => "Sugestie",
  oQ = () => "ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ",
  sQ = () => "ĞŸÑ€Ğ¾Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ—",
  aQ = () => "Gá»£i Ã½",
  uQ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? YJ() : t === "pt" ? KJ() : t === "ch" ? JJ() : t === "de" ? QJ() : t === "es" ? tQ() : t === "fr" ? eQ() : t === "it" ? rQ() : t === "jp" ? nQ() : t === "pl" ? iQ() : t === "ru" ? oQ() : t === "uk" ? sQ() : aQ()
  },
  cQ = () => "Service Workers are not supported/enabled in your browser. Some features might not work properly.",
  lQ = () => "Service Workers nÃ£o sÃ£o suportados ou estÃ£o desativados em seu navegador. Alguns recursos podem nÃ£o funcionar corretamente.",
  _Q = () => "ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒ/æœªå¯ç”¨ Service Workerã€‚ä¸€äº›åŠŸèƒ½å¯èƒ½æ— æ³•æ­£å¸¸å·¥ä½œã€‚",
  hQ = () => "Service Worker werden in deinem Browser nicht unterstÃ¼tzt/aktiviert. Einige Funktionen kÃ¶nnten nicht richtig funktionieren.",
  dQ = () => "Service Workers no estÃ¡n soportados o estÃ¡n desactivados en tu navegador. Algunas funciones pueden no funcionar correctamente.",
  pQ = () => "Les Service Workers ne sont pas pris en charge/activÃ©s dans votre navigateur. Certaines fonctionnalitÃ©s peuvent ne pas fonctionner correctement.",
  fQ = () => "I Service Worker non sono supportati o sono disabilitati nel tuo browser. Alcune funzionalitÃ  potrebbero non funzionare correttamente.",
  mQ = () => "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯Service WorkerãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™ã€‚ä¸€éƒ¨ã®æ©Ÿèƒ½ãŒæ­£ã—ãå‹•ä½œã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚",
  gQ = () => "Service Workers nie sÄ… obsÅ‚ugiwane lub sÄ… wyÅ‚Ä…czone w Twojej przeglÄ…darce. NiektÃ³re funkcje mogÄ… nie dziaÅ‚aÄ‡ poprawnie.",
  yQ = () => "Service Workers Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ñ‹ Ğ² Ğ²Ğ°ÑˆĞµĞ¼ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğµ. ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾.",
  vQ = () => "Service Workers Ğ½Ğµ Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ÑƒÑÑ‚ÑŒÑÑ Ğ°Ğ±Ğ¾ Ğ²Ğ¸Ğ¼ĞºĞ½ĞµĞ½Ñ– Ñƒ Ğ²Ğ°ÑˆĞ¾Ğ¼Ñƒ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ñ–. Ğ”ĞµÑĞºÑ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ— Ğ¼Ğ¾Ğ¶ÑƒÑ‚ÑŒ Ğ¿Ñ€Ğ°Ñ†ÑĞ²Ğ°Ñ‚Ğ¸ Ğ½ĞµĞºĞ¾Ñ€ĞµĞºÑ‚Ğ½Ğ¾.",
  bQ = () => "TrÃ¬nh duyá»‡t cá»§a báº¡n khÃ´ng há»— trá»£/báº­t Service Workers. Má»™t sá»‘ tÃ­nh nÄƒng cÃ³ thá»ƒ khÃ´ng hoáº¡t Ä‘á»™ng Ä‘Ãºng.",
  xQ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? cQ() : t === "pt" ? lQ() : t === "ch" ? _Q() : t === "de" ? hQ() : t === "es" ? dQ() : t === "fr" ? pQ() : t === "it" ? fQ() : t === "jp" ? mQ() : t === "pl" ? gQ() : t === "ru" ? yQ() : t === "uk" ? vQ() : bQ()
  },
  wQ = () => "Terms",
  kQ = () => "Termos",
  TQ = () => "æ¡æ¬¾",
  SQ = () => "Bedingungen",
  PQ = () => "TÃ©rminos",
  MQ = () => "Conditions",
  CQ = () => "Termini",
  IQ = () => "åˆ©ç”¨è¦ç´„",
  zQ = () => "Warunki",
  AQ = () => "Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ñ",
  EQ = () => "Ğ£Ğ¼Ğ¾Ğ²Ğ¸",
  jQ = () => "Äiá»u khoáº£n",
  LQ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? wQ() : t === "pt" ? kQ() : t === "ch" ? TQ() : t === "de" ? SQ() : t === "es" ? PQ() : t === "fr" ? MQ() : t === "it" ? CQ() : t === "jp" ? IQ() : t === "pl" ? zQ() : t === "ru" ? AQ() : t === "uk" ? EQ() : jQ()
  },
  DQ = () => "This action is irreversible, do you want to proceed?",
  RQ = () => "Esta aÃ§Ã£o Ã© irreversÃ­vel, vocÃª deseja prosseguir?",
  BQ = () => "æ­¤æ“ä½œä¸å¯é€†ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ",
  FQ = () => "Diese Aktion ist irreversibel. MÃ¶chtest du fortfahren?",
  OQ = () => "Esta acciÃ³n es irreversible, Â¿quieres continuar?",
  qQ = () => "Cette action est irrÃ©versible, souhaitez-vous continuer ?",
  NQ = () => "Questa azione Ã¨ irreversibile, vuoi procedere?",
  VQ = () => "ã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚å®Ÿè¡Œã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
  UQ = () => "Ta akcja jest nieodwracalna. Czy chcesz kontynuowaÄ‡?",
  ZQ = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ¾Ğ±Ñ€Ğ°Ñ‚Ğ¸Ğ¼Ğ¾. ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ?",
  GQ = () => "Ğ¦Ñ Ğ´Ñ–Ñ Ğ½ĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ ÑĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸. ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ñ‚Ğ¸?",
  HQ = () => "HÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c, báº¡n cÃ³ muá»‘n tiáº¿p tá»¥c?",
  WQ = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? DQ() : t === "pt" ? RQ() : t === "ch" ? BQ() : t === "de" ? FQ() : t === "es" ? OQ() : t === "fr" ? qQ() : t === "it" ? NQ() : t === "jp" ? VQ() : t === "pl" ? UQ() : t === "ru" ? ZQ() : t === "uk" ? GQ() : HQ()
  },
  $Q = () => "this month",
  XQ = () => "neste mÃªs",
  YQ = () => "æœ¬æœˆ",
  KQ = () => "diesen Monat",
  JQ = () => "este mes",
  QQ = () => "ce mois-ci",
  ttt = () => "questo mese",
  ett = () => "ä»Šæœˆ",
  rtt = () => "w tym miesiÄ…cu",
  ntt = () => "Ğ² ÑÑ‚Ğ¾Ğ¼ Ğ¼ĞµÑÑÑ†Ğµ",
  itt = () => "Ñ†ÑŒĞ¾Ğ³Ğ¾ Ğ¼Ñ–ÑÑÑ†Ñ",
  ott = () => "thÃ¡ng nÃ y",
  tm = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $Q() : t === "pt" ? XQ() : t === "ch" ? YQ() : t === "de" ? KQ() : t === "es" ? JQ() : t === "fr" ? QQ() : t === "it" ? ttt() : t === "jp" ? ett() : t === "pl" ? rtt() : t === "ru" ? ntt() : t === "uk" ? itt() : ott()
  },
  stt = () => "this week",
  att = () => "nesta semana",
  utt = () => "æœ¬å‘¨",
  ctt = () => "diese Woche",
  ltt = () => "esta semana",
  _tt = () => "cette semaine",
  htt = () => "questa settimana",
  dtt = () => "ä»Šé€±",
  ptt = () => "w tym tygodniu",
  ftt = () => "Ğ½Ğ° ÑÑ‚Ğ¾Ğ¹ Ğ½ĞµĞ´ĞµĞ»Ğµ",
  mtt = () => "Ñ†ÑŒĞ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¶Ğ½Ñ",
  gtt = () => "tuáº§n nÃ y",
  em = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? stt() : t === "pt" ? att() : t === "ch" ? utt() : t === "de" ? ctt() : t === "es" ? ltt() : t === "fr" ? _tt() : t === "it" ? htt() : t === "jp" ? dtt() : t === "pl" ? ptt() : t === "ru" ? ftt() : t === "uk" ? mtt() : gtt()
  },
  ytt = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  vtt = () => "Isso excluirÃ¡ permanentemente sua conta e todos os dados associados. Esta aÃ§Ã£o nÃ£o pode ser desfeita.",
  btt = () => "è¿™å°†æ°¸ä¹…åˆ é™¤ä½ çš„è´¦å·åŠæ‰€æœ‰ç›¸å…³æ•°æ®ï¼Œæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚",
  xtt = () => "Dies wird dein Konto und alle dazugehÃ¶rigen Daten dauerhaft lÃ¶schen. Diese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden.",
  wtt = () => "Esto eliminarÃ¡ permanentemente tu cuenta y todos los datos asociados. Esta acciÃ³n no se puede deshacer.",
  ktt = () => "Cela supprimera dÃ©finitivement votre compte et toutes les donnÃ©es associÃ©es. Cette action est irrÃ©versible.",
  Ttt = () => "Questa azione eliminerÃ  definitivamente il tuo account e tutti i dati associati. Non potrÃ  essere annullata.",
  Stt = () => "ã“ã®æ“ä½œã«ã‚ˆã‚Šã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¨é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒå®Œå…¨ã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚å…ƒã«æˆ»ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚",
  Ptt = () => "To trwale usunie Twoje konto i wszystkie powiÄ…zane dane. Tej akcji nie moÅ¼na cofnÄ…Ä‡.",
  Mtt = () => "Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ° ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ Ğ²Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ¸ Ğ²ÑĞµ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ. Ğ•Ğ³Ğ¾ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ.",
  Ctt = () => "Ğ¦Ğµ Ğ½Ğ°Ğ·Ğ°Ğ²Ğ¶Ğ´Ğ¸ Ğ²Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ñ– Ğ²ÑÑ– Ğ¿Ğ¾Ğ²Ê¼ÑĞ·Ğ°Ğ½Ñ– Ğ´Ğ°Ğ½Ñ–. Ğ¦Ñ Ğ´Ñ–Ñ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ±ÑƒĞ´Ğµ ÑĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸.",
  Itt = () => "Viá»‡c nÃ y sáº½ xÃ³a vÄ©nh viá»…n tÃ i khoáº£n vÃ  táº¥t cáº£ dá»¯ liá»‡u liÃªn quan. HÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c.",
  ztt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ytt() : t === "pt" ? vtt() : t === "ch" ? btt() : t === "de" ? xtt() : t === "es" ? wtt() : t === "fr" ? ktt() : t === "it" ? Ttt() : t === "jp" ? Stt() : t === "pl" ? Ptt() : t === "ru" ? Mtt() : t === "uk" ? Ctt() : Itt()
  },
  Att = () => "Tickets",
  Ett = () => "Tickets",
  jtt = () => "å·¥å•",
  Ltt = () => "Tickets",
  Dtt = () => "Tickets",
  Rtt = () => "Tickets",
  Btt = () => "Ticket",
  Ftt = () => "ãƒã‚±ãƒƒãƒˆ",
  Ott = () => "Tickety",
  qtt = () => "Ğ¢Ğ¸ĞºĞµÑ‚Ñ‹",
  Ntt = () => "Ğ¢Ñ–ĞºĞµÑ‚Ğ¸",
  Vtt = () => "Phiáº¿u há»— trá»£",
  Utt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Att() : t === "pt" ? Ett() : t === "ch" ? jtt() : t === "de" ? Ltt() : t === "es" ? Dtt() : t === "fr" ? Rtt() : t === "it" ? Btt() : t === "jp" ? Ftt() : t === "pl" ? Ott() : t === "ru" ? qtt() : t === "uk" ? Ntt() : Vtt()
  },
  Ztt = () => "Timeout appeal",
  Gtt = () => "RevisÃ£o de suspensÃ£o",
  Htt = () => "ç¦è¨€ç”³è¯‰",
  Wtt = () => "Timeout-Einspruch",
  $tt = () => "ApelaciÃ³n de suspensiÃ³n",
  Xtt = () => "Recours de suspension",
  Ytt = () => "Ricorso contro la sospensione",
  Ktt = () => "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ç•°è­°ç”³ç«‹ã¦",
  Jtt = () => "OdwoÅ‚anie od zawieszenia",
  Qtt = () => "ĞĞ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ Ğ½Ğ° Ñ‚Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚",
  tet = () => "ĞĞ¿ĞµĞ»ÑÑ†Ñ–Ñ Ğ½Ğ° Ñ‚Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚",
  eet = () => "KhÃ¡ng cÃ¡o táº¡m khÃ³a",
  ret = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ztt() : t === "pt" ? Gtt() : t === "ch" ? Htt() : t === "de" ? Wtt() : t === "es" ? $tt() : t === "fr" ? Xtt() : t === "it" ? Ytt() : t === "jp" ? Ktt() : t === "pl" ? Jtt() : t === "ru" ? Qtt() : t === "uk" ? tet() : eet()
  },
  net = () => "Appeal",
  iet = () => "Apelar",
  oet = () => "ç”³è¯‰",
  set = () => "Einspruch",
  aet = () => "Apelar",
  uet = () => "Recours",
  cet = () => "Fare ricorso",
  _et = () => "ç•°è­°ç”³ç«‹ã¦",
  het = () => "OdwoÅ‚aj siÄ™",
  det = () => "ĞĞ¿ĞµĞ»Ğ»ÑÑ†Ğ¸Ñ",
  pet = () => "ĞŸĞ¾Ğ´Ğ°Ñ‚Ğ¸ Ğ°Ğ¿ĞµĞ»ÑÑ†Ñ–Ñ",
  fet = () => "KhÃ¡ng cÃ¡o",
  met = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? net() : t === "pt" ? iet() : t === "ch" ? oet() : t === "de" ? set() : t === "es" ? aet() : t === "fr" ? uet() : t === "it" ? cet() : t === "jp" ? _et() : t === "pl" ? het() : t === "ru" ? det() : t === "uk" ? pet() : fet()
  },
  get = () => "to paint.",
  yet = () => "para pintar",
  vet = () => "è¿›è¡Œç»˜åˆ¶ï¼Œ",
  bet = () => "gedrÃ¼ckt halten, um zu malen",
  xet = () => "para pintar.",
  wet = () => "pour peindre.",
  ket = () => "per dipingere",
  Tet = () => "å¡—ã‚‹ã«ã¯",
  Pet = () => "aby malowaÄ‡.",
  Met = () => "Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ.",
  Cet = () => "Ñ‰Ğ¾Ğ± Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸.",
  Iet = () => "Ä‘á»ƒ tÃ´.",
  zet = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? get() : t === "pt" ? yet() : t === "ch" ? vet() : t === "de" ? bet() : t === "es" ? xet() : t === "fr" ? wet() : t === "it" ? ket() : t === "jp" ? Tet() : t === "pl" ? Pet() : t === "ru" ? Met() : t === "uk" ? Cet() : Iet()
  },
  Aet = () => "You can paint more than 1 pixel",
  Eet = () => "VocÃª pode pintar mais de 1 pixel",
  jet = () => "ä½ å¯ä»¥ä¸€æ¬¡ç»˜åˆ¶å¤šä¸ªåƒç´ ",
  Let = () => "Du kannst mehr als 1 Pixel malen",
  Det = () => "Puedes pintar mÃ¡s de 1 pÃ­xel",
  Ret = () => "Vous pouvez peindre plus dâ€™un pixel",
  Bet = () => "Puoi dipingere piÃ¹ di 1 pixel",
  Fet = () => "1ã¤ä»¥ä¸Šã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã¾ã¨ã‚ã¦å¡—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚",
  Oet = () => "MoÅ¼esz pomalowaÄ‡ wiÄ™cej niÅ¼ 1 piksel",
  qet = () => "Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‡ĞµĞ¼ 1 Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ",
  Net = () => "Ğ’Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ, Ğ½Ñ–Ğ¶ 1 Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ",
  Vet = () => "Báº¡n cÃ³ thá»ƒ tÃ´ nhiá»u hÆ¡n 1 pixel",
  Uet = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Aet() : t === "pt" ? Eet() : t === "ch" ? jet() : t === "de" ? Let() : t === "es" ? Det() : t === "fr" ? Ret() : t === "it" ? Bet() : t === "jp" ? Fet() : t === "pl" ? Oet() : t === "ru" ? qet() : t === "uk" ? Net() : Vet()
  },
  Zet = () => "Today",
  Get = () => "Hoje",
  Het = () => "ä»Šå¤©",
  Wet = () => "Heute",
  $et = () => "Hoy",
  Xet = () => "Aujourdâ€™hui",
  Yet = () => "Oggi",
  Ket = () => "ä»Šæ—¥",
  Jet = () => "DziÅ›",
  Qet = () => "Ğ¡ĞµĞ³Ğ¾Ğ´Ğ½Ñ",
  trt = () => "Ğ¡ÑŒĞ¾Ğ³Ğ¾Ğ´Ğ½Ñ–",
  ert = () => "HÃ´m nay",
  Id = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Zet() : t === "pt" ? Get() : t === "ch" ? Het() : t === "de" ? Wet() : t === "es" ? $et() : t === "fr" ? Xet() : t === "it" ? Yet() : t === "jp" ? Ket() : t === "pl" ? Jet() : t === "ru" ? Qet() : t === "uk" ? trt() : ert()
  },
  rrt = () => "Toggle art opacity",
  nrt = () => "Alterar opacidade",
  irt = () => "åˆ‡æ¢ä½œå“ä¸é€æ˜åº¦",
  ort = () => "Art-Transparenz umschalten",
  srt = () => "Alternar opacidad del arte",
  art = () => "Basculer lâ€™opacitÃ© de lâ€™art",
  urt = () => "Modifica opacitÃ ",
  crt = () => "ã‚¢ãƒ¼ãƒˆã®ä¸é€æ˜åº¦ã‚’åˆ‡ã‚Šæ›¿ãˆ",
  lrt = () => "PrzeÅ‚Ä…cz przezroczystoÅ›Ä‡ grafik",
  _rt = () => "ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ½ĞµĞ¿Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ Ğ°Ñ€Ñ‚Ğ°",
  hrt = () => "ĞŸĞµÑ€ĞµĞ¼ĞºĞ½ÑƒÑ‚Ğ¸ Ğ¿Ñ€Ğ¾Ğ·Ğ¾Ñ€Ñ–ÑÑ‚ÑŒ Ğ°Ñ€Ñ‚Ñƒ",
  drt = () => "Chuyá»ƒn Ä‘á»™ trong suá»‘t cá»§a art",
  xv = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rrt() : t === "pt" ? nrt() : t === "ch" ? irt() : t === "de" ? ort() : t === "es" ? srt() : t === "fr" ? art() : t === "it" ? urt() : t === "jp" ? crt() : t === "pl" ? lrt() : t === "ru" ? _rt() : t === "uk" ? hrt() : drt()
  },
  prt = () => "Twitch account migrated successfully.",
  frt = () => "Conta da Twitch migrada com sucesso.",
  mrt = () => "Twitch è´¦å·è¿ç§»æˆåŠŸã€‚",
  grt = () => "Twitch-Konto erfolgreich migriert.",
  yrt = () => "Cuenta de Twitch migrada correctamente.",
  vrt = () => "Compte Twitch migrÃ© avec succÃ¨s.",
  brt = () => "Account Twitch migrato con successo.",
  xrt = () => "Twitchã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ç§»è¡ŒãŒå®Œäº†ã—ã¾ã—ãŸã€‚",
  wrt = () => "Konto Twitch zostaÅ‚o pomyÅ›lnie przeniesione.",
  krt = () => "ĞĞºĞºĞ°ÑƒĞ½Ñ‚ Twitch ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¼Ğ¸Ğ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½.",
  Trt = () => "ĞĞºĞ°ÑƒĞ½Ñ‚ Twitch ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ½ĞµÑĞµĞ½Ğ¾.",
  Srt = () => "ÄÃ£ di chuyá»ƒn tÃ i khoáº£n Twitch thÃ nh cÃ´ng.",
  Prt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? prt() : t === "pt" ? frt() : t === "ch" ? mrt() : t === "de" ? grt() : t === "es" ? yrt() : t === "fr" ? vrt() : t === "it" ? brt() : t === "jp" ? xrt() : t === "pl" ? wrt() : t === "ru" ? krt() : t === "uk" ? Trt() : Srt()
  },
  Mrt = () => "Please confirm by entering your username:",
  Crt = () => "Por favor, confirme digitando seu nome de usuÃ¡rio:",
  Irt = () => "è¯·é€šè¿‡è¾“å…¥ç”¨æˆ·åè¿›è¡Œç¡®è®¤ï¼š",
  zrt = () => "Bitte bestÃ¤tige, indem du deinen Benutzernamen eingibst:",
  Art = () => "Confirma escribiendo tu nombre de usuario:",
  Ert = () => "Veuillez confirmer en entrant votre nom dâ€™utilisateur :",
  jrt = () => "Conferma digitando il tuo nome utente:",
  Lrt = () => "ç¢ºèªã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:",
  Drt = () => "PotwierdÅº, wpisujÄ…c swojÄ… nazwÄ™ uÅ¼ytkownika:",
  Rrt = () => "Ğ”Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆĞµ Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:",
  Brt = () => "ĞŸÑ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ñ–Ñ‚ÑŒ, Ğ±ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, Ğ²Ğ²Ñ–Ğ²ÑˆĞ¸ Ğ²Ğ°ÑˆĞµ Ñ–Ğ¼Ê¼Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°:",
  Frt = () => "HÃ£y xÃ¡c nháº­n báº±ng cÃ¡ch nháº­p tÃªn ngÆ°á»i dÃ¹ng cá»§a báº¡n:",
  Ort = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Mrt() : t === "pt" ? Crt() : t === "ch" ? Irt() : t === "de" ? zrt() : t === "es" ? Art() : t === "fr" ? Ert() : t === "it" ? jrt() : t === "jp" ? Lrt() : t === "pl" ? Drt() : t === "ru" ? Rrt() : t === "uk" ? Brt() : Frt()
  },
  qrt = () => "Type your username",
  Nrt = () => "Digite seu nome de usuÃ¡rio",
  Vrt = () => "è¾“å…¥ä½ çš„ç”¨æˆ·å",
  Urt = () => "Benutzernamen eingeben",
  Zrt = () => "Escribe tu nombre de usuario",
  Grt = () => "Tapez votre nom dâ€™utilisateur",
  Hrt = () => "Digita il tuo nome utente",
  Wrt = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›",
  $rt = () => "Wpisz swojÄ… nazwÄ™ uÅ¼ytkownika",
  Xrt = () => "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ",
  Yrt = () => "Ğ’Ğ²ĞµĞ´Ñ–Ñ‚ÑŒ ÑĞ²Ğ¾Ñ” Ñ–Ğ¼Ê¼Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°",
  Krt = () => "Nháº­p tÃªn ngÆ°á»i dÃ¹ng",
  Jrt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qrt() : t === "pt" ? Nrt() : t === "ch" ? Vrt() : t === "de" ? Urt() : t === "es" ? Zrt() : t === "fr" ? Grt() : t === "it" ? Hrt() : t === "jp" ? Wrt() : t === "pl" ? $rt() : t === "ru" ? Xrt() : t === "uk" ? Yrt() : Krt()
  },
  Qrt = () => "Understood",
  tnt = () => "Entendido",
  ent = () => "æˆ‘å·²äº†è§£",
  rnt = () => "Verstanden",
  nnt = () => "Entendido",
  int = () => "Compris",
  ont = () => "Capito",
  snt = () => "ç†è§£ã—ã¾ã—ãŸ",
  ant = () => "ZrozumiaÅ‚em",
  unt = () => "ĞŸĞ¾Ğ½ÑÑ‚Ğ½Ğ¾",
  cnt = () => "Ğ—Ñ€Ğ¾Ğ·ÑƒĞ¼Ñ–Ğ»Ğ¾",
  lnt = () => "ÄÃ£ hiá»ƒu",
  _nt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Qrt() : t === "pt" ? tnt() : t === "ch" ? ent() : t === "de" ? rnt() : t === "es" ? nnt() : t === "fr" ? int() : t === "it" ? ont() : t === "jp" ? snt() : t === "pl" ? ant() : t === "ru" ? unt() : t === "uk" ? cnt() : lnt()
  },
  hnt = () => "Undo",
  dnt = () => "Desfazer",
  pnt = () => "æ’¤æ¶ˆ",
  fnt = () => "RÃ¼ckgÃ¤ngig machen",
  mnt = () => "Deshacer",
  gnt = () => "Annuler",
  ynt = () => "Annulla",
  vnt = () => "å…ƒã«æˆ»ã™",
  bnt = () => "Cofnij",
  xnt = () => "ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ",
  wnt = () => "Ğ¡ĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸",
  knt = () => "HoÃ n tÃ¡c",
  Tnt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hnt() : t === "pt" ? dnt() : t === "ch" ? pnt() : t === "de" ? fnt() : t === "es" ? mnt() : t === "fr" ? gnt() : t === "it" ? ynt() : t === "jp" ? vnt() : t === "pl" ? bnt() : t === "ru" ? xnt() : t === "uk" ? wnt() : knt()
  },
  Snt = l => `Unlink Discord (${l.username})`,
  Pnt = l => `Desconectar Discord (${l.username})`,
  Mnt = l => `å–æ¶ˆå…³è” Discordï¼ˆ${l.username}ï¼‰`,
  Cnt = l => `Discord trennen (${l.username})`,
  Int = l => `Desvincular Discord (${l.username})`,
  znt = l => `Dissocier Discord (${l.username})`,
  Ant = l => `Scollega Discord (${l.username})`,
  Ent = l => `Discordã¨ã®é€£æºã‚’è§£é™¤ (${l.username})`,
  jnt = l => `OdÅ‚Ä…cz Discord (${l.username})`,
  Lnt = l => `ĞÑ‚Ğ²ÑĞ·Ğ°Ñ‚ÑŒ Discord (${l.username})`,
  Dnt = l => `Ğ’Ñ–Ğ´Ê¼Ñ”Ğ´Ğ½Ğ°Ñ‚Ğ¸ Discord (${l.username})`,
  Rnt = l => `Há»§y liÃªn káº¿t Discord (${l.username})`,
  Bnt = (l, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Snt(l) : t === "pt" ? Pnt(l) : t === "ch" ? Mnt(l) : t === "de" ? Cnt(l) : t === "es" ? Int(l) : t === "fr" ? znt(l) : t === "it" ? Ant(l) : t === "jp" ? Ent(l) : t === "pl" ? jnt(l) : t === "ru" ? Lnt(l) : t === "uk" ? Dnt(l) : Rnt(l)
  },
  Fnt = () => "Discord unlinked",
  Ont = () => "Discord desconectado",
  qnt = () => "Discord å·²å–æ¶ˆå…³è”",
  Nnt = () => "Discord-Konto getrennt",
  Vnt = () => "Discord desvinculado",
  Unt = () => "Discord dissociÃ©",
  Znt = () => "Discord scollegato",
  Gnt = () => "Discordã¨ã®é€£æºã‚’è§£é™¤ã—ã¾ã—ãŸã€‚",
  Hnt = () => "Discord odÅ‚Ä…czony",
  Wnt = () => "Discord Ğ¾Ñ‚Ğ²ÑĞ·Ğ°Ğ½",
  $nt = () => "Discord Ğ²Ñ–Ğ´Ê¼Ñ”Ğ´Ğ½Ğ°Ğ½Ğ¾",
  Xnt = () => "ÄÃ£ há»§y liÃªn káº¿t Discord",
  Ynt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Fnt() : t === "pt" ? Ont() : t === "ch" ? qnt() : t === "de" ? Nnt() : t === "es" ? Vnt() : t === "fr" ? Unt() : t === "it" ? Znt() : t === "jp" ? Gnt() : t === "pl" ? Hnt() : t === "ru" ? Wnt() : t === "uk" ? $nt() : Xnt()
  },
  Knt = () => "Unlock",
  Jnt = () => "Destravar",
  Qnt = () => "è§£é”",
  tit = () => "Entsperren",
  eit = () => "Desbloquear",
  rit = () => "DÃ©verrouiller",
  nit = () => "Sblocca",
  iit = () => "ãƒ­ãƒƒã‚¯è§£é™¤",
  oit = () => "Odblokuj",
  sit = () => "Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
  ait = () => "Ğ Ğ¾Ğ·Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ñ‚Ğ¸",
  uit = () => "Má»Ÿ khÃ³a",
  cit = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Knt() : t === "pt" ? Jnt() : t === "ch" ? Qnt() : t === "de" ? tit() : t === "es" ? eit() : t === "fr" ? rit() : t === "it" ? nit() : t === "jp" ? iit() : t === "pl" ? oit() : t === "ru" ? sit() : t === "uk" ? ait() : uit()
  },
  lit = () => "Unmute",
  _it = () => "Desmutar",
  hit = () => "å–æ¶ˆé™éŸ³",
  dit = () => "Stummschaltung aufheben",
  pit = () => "Quitar silencio",
  fit = () => "RÃ©activer le son",
  mit = () => "Riattiva audio",
  git = () => "ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤",
  yit = () => "WyÅ‚Ä…cz wyciszenie",
  vit = () => "Ğ¡Ğ½ÑÑ‚ÑŒ Ğ¼ÑŒÑÑ‚",
  bit = () => "Ğ£Ğ²Ñ–Ğ¼ĞºĞ½ÑƒÑ‚Ğ¸ Ğ·Ğ²ÑƒĞº",
  xit = () => "Báº­t tiáº¿ng",
  wit = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lit() : t === "pt" ? _it() : t === "ch" ? hit() : t === "de" ? dit() : t === "es" ? pit() : t === "fr" ? fit() : t === "it" ? mit() : t === "jp" ? git() : t === "pl" ? yit() : t === "ru" ? vit() : t === "uk" ? bit() : xit()
  },
  kit = () => "Update",
  Tit = () => "Atualizar",
  Sit = () => "æ›´æ–°",
  Pit = () => "Aktualisieren",
  Mit = () => "Actualizar",
  Cit = () => "Mettre Ã  jour",
  Iit = () => "Aggiorna",
  zit = () => "æ›´æ–°",
  Ait = () => "Aktualizuj",
  Eit = () => "ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ",
  jit = () => "ĞĞ½Ğ¾Ğ²Ğ¸Ñ‚Ğ¸",
  Lit = () => "Cáº­p nháº­t",
  Dit = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kit() : t === "pt" ? Tit() : t === "ch" ? Sit() : t === "de" ? Pit() : t === "es" ? Mit() : t === "fr" ? Cit() : t === "it" ? Iit() : t === "jp" ? zit() : t === "pl" ? Ait() : t === "ru" ? Eit() : t === "uk" ? jit() : Lit()
  },
  Rit = () => "Use hardware acceleration when available",
  Bit = () => "Usar aceleraÃ§Ã£o grÃ¡fica quando disponÃ­vel",
  Fit = () => "åœ¨å¯ç”¨æ—¶ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿ",
  Oit = () => "Hardwarebeschleunigung verwenden, wenn verfÃ¼gbar",
  qit = () => "Usar aceleraciÃ³n por hardware cuando estÃ© disponible",
  Nit = () => "Utiliser lâ€™accÃ©lÃ©ration matÃ©rielle lorsquâ€™elle est disponible",
  Vit = () => "Usa l'accelerazione grafica quando disponibile",
  Uit = () => "åˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹",
  Zit = () => "UÅ¼ywaj akceleracji sprzÄ™towej, gdy jest dostÄ™pna",
  Git = () => "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ¿Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğµ ÑƒÑĞºĞ¾Ñ€ĞµĞ½Ğ¸Ğµ, ĞµÑĞ»Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾",
  Hit = () => "Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ°Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğµ Ğ¿Ñ€Ğ¸ÑĞºĞ¾Ñ€ĞµĞ½Ğ½Ñ, ÑĞºÑ‰Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾",
  Wit = () => "DÃ¹ng tÄƒng tá»‘c pháº§n cá»©ng khi cÃ³ thá»ƒ",
  $it = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Rit() : t === "pt" ? Bit() : t === "ch" ? Fit() : t === "de" ? Oit() : t === "es" ? qit() : t === "fr" ? Nit() : t === "it" ? Vit() : t === "jp" ? Uit() : t === "pl" ? Zit() : t === "ru" ? Git() : t === "uk" ? Hit() : Wit()
  },
  Xit = () => "Username copied to clipboard",
  Yit = () => "UsuÃ¡rio copiado",
  Kit = () => "ç”¨æˆ·åå·²å¤åˆ¶åˆ°å‰ªè´´æ¿",
  Jit = () => "Benutzername in die Zwischenablage kopiert",
  Qit = () => "Nombre de usuario copiado al portapapeles",
  tot = () => "Nom dâ€™utilisateur copiÃ©",
  eot = () => "Nome utente copiato",
  rot = () => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
  not = () => "Nazwa uÅ¼ytkownika skopiowana do schowka",
  iot = () => "Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°",
  oot = () => "Ğ†Ğ¼Ê¼Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° ÑĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼Ñ–Ğ½Ñƒ",
  sot = () => "ÄÃ£ sao chÃ©p tÃªn ngÆ°á»i dÃ¹ng vÃ o clipboard",
  aot = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Xit() : t === "pt" ? Yit() : t === "ch" ? Kit() : t === "de" ? Jit() : t === "es" ? Qit() : t === "fr" ? tot() : t === "it" ? eot() : t === "jp" ? rot() : t === "pl" ? not() : t === "ru" ? iot() : t === "uk" ? oot() : sot()
  },
  uot = () => "Verify if",
  cot = () => "Verifique se",
  lot = () => "è¯·æ£€æŸ¥æ˜¯å¦",
  _ot = () => "ÃœberprÃ¼fe, ob",
  hot = () => "Verifica si",
  dot = () => "VÃ©rifiez si",
  pot = () => "Verifica se",
  fot = () => "æ¬¡ã‚’ç¢ºèª:",
  mot = () => "SprawdÅº, czy",
  got = () => "Ğ£Ğ´Ğ¾ÑÑ‚Ğ¾Ğ²ĞµÑ€ÑŒÑ‚ĞµÑÑŒ Ğ² Ñ‚Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾",
  yot = () => "ĞŸĞµÑ€ĞµĞºĞ¾Ğ½Ğ°Ğ¹Ñ‚ĞµÑÑ, Ñ‰Ğ¾",
  vot = () => "Kiá»ƒm tra xem",
  bot = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? uot() : t === "pt" ? cot() : t === "ch" ? lot() : t === "de" ? _ot() : t === "es" ? hot() : t === "fr" ? dot() : t === "it" ? pot() : t === "jp" ? fot() : t === "pl" ? mot() : t === "ru" ? got() : t === "uk" ? yot() : vot()
  },
  xot = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  wot = () => "A violaÃ§Ã£o destas regras pode levar Ã  suspensÃ£o da conta ou Ã  remoÃ§Ã£o de desenhos.",
  kot = () => "è¿åè¿™äº›è§„åˆ™å¯èƒ½å¯¼è‡´ä½ çš„è´¦å·è¢«æš‚åœæˆ–ä½œå“è¢«ç§»é™¤ã€‚",
  Tot = () => "VerstÃ¶ÃŸe gegen diese Regeln kÃ¶nnen zur Sperrung deines Kontos oder zur Entfernung von Zeichnungen fÃ¼hren.",
  Sot = () => "Las violaciones de estas reglas pueden resultar en la suspensiÃ³n de tu cuenta o la eliminaciÃ³n de dibujos.",
  Pot = () => "La violation de ces rÃ¨gles peut entraÃ®ner la suspension de votre compte ou la suppression de dessins.",
  Mot = () => "La violazione di queste regole puÃ² portare alla sospensione dell'account o alla rimozione dei disegni.",
  Cot = () => "ã“ã‚Œã‚‰ã®ãƒ«ãƒ¼ãƒ«ã«é•åã—ãŸå ´åˆã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®åœæ­¢ã‚„ä½œå“ã®å‰Šé™¤ãªã©ã®æªç½®ãŒå–ã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚",
  Iot = () => "Åamanie tych zasad moÅ¼e skutkowaÄ‡ zawieszeniem konta lub usuniÄ™ciem rysunkÃ³w.",
  zot = () => "ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ¸Ñ… Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ²ĞµÑÑ‚Ğ¸ Ğº Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ° Ğ¸Ğ»Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ñ€Ğ¸ÑÑƒĞ½ĞºĞ¾Ğ².",
  Aot = () => "ĞŸĞ¾Ñ€ÑƒÑˆĞµĞ½Ğ½Ñ Ñ†Ğ¸Ñ… Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» Ğ¼Ğ¾Ğ¶Ğµ Ğ¿Ñ€Ğ¸Ğ·Ğ²ĞµÑÑ‚Ğ¸ Ğ´Ğ¾ Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ğ° Ğ°Ğ±Ğ¾ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ¼Ğ°Ğ»ÑĞ½ĞºÑ–Ğ².",
  Eot = () => "Vi pháº¡m cÃ¡c luáº­t nÃ y cÃ³ thá»ƒ dáº«n Ä‘áº¿n viá»‡c Ä‘Ã¬nh chá»‰ tÃ i khoáº£n hoáº·c xÃ³a tranh.",
  jot = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xot() : t === "pt" ? wot() : t === "ch" ? kot() : t === "de" ? Tot() : t === "es" ? Sot() : t === "fr" ? Pot() : t === "it" ? Mot() : t === "jp" ? Cot() : t === "pl" ? Iot() : t === "ru" ? zot() : t === "uk" ? Aot() : Eot()
  },
  Lot = () => "Week",
  Dot = () => "Semana",
  Rot = () => "å‘¨",
  Bot = () => "Woche",
  Fot = () => "Semana",
  Oot = () => "Semaine",
  qot = () => "Settimana",
  Not = () => "é€±",
  Vot = () => "TydzieÅ„",
  Uot = () => "ĞĞµĞ´ĞµĞ»Ñ",
  Zot = () => "Ğ¢Ğ¸Ğ¶Ğ´ĞµĞ½ÑŒ",
  Got = () => "Tuáº§n",
  Hot = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Lot() : t === "pt" ? Dot() : t === "ch" ? Rot() : t === "de" ? Bot() : t === "es" ? Fot() : t === "fr" ? Oot() : t === "it" ? qot() : t === "jp" ? Not() : t === "pl" ? Vot() : t === "ru" ? Uot() : t === "uk" ? Zot() : Got()
  },
  Wot = () => "Welcome to",
  $ot = () => "Bem vindo ao",
  Xot = () => "æ¬¢è¿æ¥åˆ°",
  Yot = () => "Willkommen bei",
  Kot = () => "Bienvenido a",
  Jot = () => "Bienvenue sur",
  Qot = () => "Benvenuto su",
  tst = () => "ã‚ˆã†ã“ã",
  est = () => "Witamy w",
  rst = () => "Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²",
  nst = () => "Ğ›Ğ°ÑĞºĞ°Ğ²Ğ¾ Ğ¿Ñ€Ğ¾ÑĞ¸Ğ¼Ğ¾ Ğ´Ğ¾",
  ist = () => "ChÃ o má»«ng Ä‘áº¿n vá»›i",
  ost = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Wot() : t === "pt" ? $ot() : t === "ch" ? Xot() : t === "de" ? Yot() : t === "es" ? Kot() : t === "fr" ? Jot() : t === "it" ? Qot() : t === "jp" ? tst() : t === "pl" ? est() : t === "ru" ? rst() : t === "uk" ? nst() : ist()
  },
  sst = () => "When painting, click on the button",
  ast = () => "Quando pintar clique no botÃ£o",
  ust = () => "åœ¨ç»˜åˆ¶æ—¶ï¼Œç‚¹å‡»æŒ‰é’®",
  cst = () => "Wenn du malst, klicke auf den Button",
  lst = () => "Cuando estÃ©s pintando, haz clic en el botÃ³n",
  _st = () => "En peignant, cliquez sur le bouton",
  hst = () => "Quando dipingi, clicca sul pulsante",
  dst = () => "ãƒšã‚¤ãƒ³ãƒˆä¸­ã«ã€æ¬¡ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚",
  pst = () => "Podczas malowania kliknij przycisk",
  fst = () => "Ğ’Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ",
  mst = () => "ĞŸÑ–Ğ´ Ñ‡Ğ°Ñ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ½Ğ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ",
  gst = () => "Khi tÃ´, hÃ£y nháº¥p vÃ o nÃºt",
  yst = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? sst() : t === "pt" ? ast() : t === "ch" ? ust() : t === "de" ? cst() : t === "es" ? lst() : t === "fr" ? _st() : t === "it" ? hst() : t === "jp" ? dst() : t === "pl" ? pst() : t === "ru" ? fst() : t === "uk" ? mst() : gst()
  },
  vst = () => "You don't have charges to paint. Wait to recharge.",
  bst = () => "VocÃª nÃ£o possui tinta para pintar. Aguarde para carrega-las.",
  xst = () => "ä½ æ²¡æœ‰å¯ç”¨å……èƒ½ï¼Œè«‹ç­‰å¾…å……èƒ½æ¢å¤ã€‚",
  wst = () => "Du hast keine Ladungen zum Malen. Warte, bis sie sich aufladen.",
  kst = () => "No tienes cargas para pintar. Espera a que se recarguen.",
  Tst = () => "Vous nâ€™avez pas de charges pour peindre. Attendez quâ€™elles se rechargent.",
  Sst = () => "Non hai vernice per dipingere. Attendi la ricarica.",
  Pst = () => "ãƒšã‚¤ãƒ³ãƒˆç”¨ã®ãƒãƒ£ãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å›å¾©ã™ã‚‹ã¾ã§ãŠå¾…ã¡ãã ã•ã„ã€‚",
  Mst = () => "Nie masz Å‚adunkÃ³w do malowania. Poczekaj na doÅ‚adowanie.",
  Cst = () => "Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°Ñ€ÑĞ´Ğ¾Ğ² Ğ´Ğ»Ñ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ. ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾ĞºĞ° Ğ¾Ğ½Ğ¸ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²ÑÑ‚ÑÑ.",
  Ist = () => "Ğ£ Ğ²Ğ°Ñ Ğ½ĞµĞ¼Ğ°Ñ” Ğ·Ğ°Ñ€ÑĞ´Ñ–Ğ² Ğ´Ğ»Ñ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ. Ğ—Ğ°Ñ‡ĞµĞºĞ°Ğ¹Ñ‚Ğµ, Ğ¿Ğ¾ĞºĞ¸ Ğ²Ğ¾Ğ½Ğ¸ Ğ²Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒÑÑ.",
  zst = () => "Báº¡n khÃ´ng cÃ²n lÆ°á»£t tÃ´ Ä‘á»ƒ váº½. HÃ£y chá» náº¡p láº¡i.",
  Ast = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vst() : t === "pt" ? bst() : t === "ch" ? xst() : t === "de" ? wst() : t === "es" ? kst() : t === "fr" ? Tst() : t === "it" ? Sst() : t === "jp" ? Pst() : t === "pl" ? Mst() : t === "ru" ? Cst() : t === "uk" ? Ist() : zst()
  },
  Est = () => "You need to zoom in to select a pixel",
  jst = () => "DÃª zoom para selecionar um pixel",
  Lst = () => "ä½ éœ€è¦æ”¾å¤§æ‰èƒ½é€‰æ‹©åƒç´ ",
  Dst = () => "Du musst hineinzoomen, um einen Pixel zu wÃ¤hlen",
  Rst = () => "Acerca el zoom para seleccionar un pÃ­xel",
  Bst = () => "Zoomez pour sÃ©lectionner un pixel",
  Fst = () => "Devi fare zoom per selezionare un pixel",
  Ost = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’é¸æŠã™ã‚‹ã«ã¯ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚",
  qst = () => "Musisz przybliÅ¼yÄ‡, aby wybraÄ‡ piksel",
  Nst = () => "ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·ÑŒÑ‚Ğµ ĞºĞ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»ÑŒ",
  Vst = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑ–Ñ‚ÑŒ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±, Ñ‰Ğ¾Ğ± Ğ²Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»ÑŒ",
  Ust = () => "Báº¡n cáº§n phÃ³ng to Ä‘á»ƒ chá»n pixel",
  Zst = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Est() : t === "pt" ? jst() : t === "ch" ? Lst() : t === "de" ? Dst() : t === "es" ? Rst() : t === "fr" ? Bst() : t === "it" ? Fst() : t === "jp" ? Ost() : t === "pl" ? qst() : t === "ru" ? Nst() : t === "uk" ? Vst() : Ust()
  },
  Gst = () => "Your account has been banned for violating the rules",
  Hst = () => "A sua conta foi banida por quebrar as regras",
  Wst = () => "ä½ çš„è´¦å·å› è¿åè§„åˆ™å·²è¢«å°ç¦",
  $st = () => "Dein Konto wurde wegen RegelverstÃ¶ÃŸen gebannt",
  Xst = () => "Tu cuenta ha sido baneada por infringir las reglas",
  Yst = () => "Votre compte a Ã©tÃ© banni pour avoir enfreint les rÃ¨gles",
  Kst = () => "Il tuo account Ã¨ stato bannato per aver infranto le regole",
  Jst = () => "ãƒ«ãƒ¼ãƒ«é•åã«ã‚ˆã‚Šã€ã‚ãªãŸã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯BANã•ã‚Œã¾ã—ãŸã€‚",
  Qst = () => "Twoje konto zostaÅ‚o zbanowane za Å‚amanie zasad",
  tat = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ±Ñ‹Ğ» Ğ·Ğ°Ğ±Ğ°Ğ½ĞµĞ½ Ğ·Ğ° Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»",
  eat = () => "Ğ’Ğ°Ñˆ Ğ°ĞºĞ°ÑƒĞ½Ñ‚ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²Ğ°Ğ½Ğ¾ Ğ·Ğ° Ğ¿Ğ¾Ñ€ÑƒÑˆĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»",
  rat = () => "TÃ i khoáº£n cá»§a báº¡n Ä‘Ã£ bá»‹ khÃ³a vÃ¬ vi pháº¡m luáº­t",
  nat = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Gst() : t === "pt" ? Hst() : t === "ch" ? Wst() : t === "de" ? $st() : t === "es" ? Xst() : t === "fr" ? Yst() : t === "it" ? Kst() : t === "jp" ? Jst() : t === "pl" ? Qst() : t === "ru" ? tat() : t === "uk" ? eat() : rat()
  },
  iat = () => "Zoom in",
  oat = () => "Aumentar zoom",
  sat = () => "æ”¾å¤§",
  aat = () => "Hineinzoomen",
  uat = () => "Acercar",
  cat = () => "Zoom avant",
  lat = () => "Zoom avanti",
  _at = () => "ã‚ºãƒ¼ãƒ ã‚¤ãƒ³",
  hat = () => "PrzybliÅ¼",
  dat = () => "ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·Ğ¸Ñ‚ÑŒ",
  pat = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆĞ¸Ñ‚Ğ¸",
  fat = () => "PhÃ³ng to",
  mat = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? iat() : t === "pt" ? oat() : t === "ch" ? sat() : t === "de" ? aat() : t === "es" ? uat() : t === "fr" ? cat() : t === "it" ? lat() : t === "jp" ? _at() : t === "pl" ? hat() : t === "ru" ? dat() : t === "uk" ? pat() : fat()
  },
  gat = () => "Zoom in to see the pixels",
  yat = () => "Amplie para ver os pixels",
  vat = () => "æ”¾å¤§ä»¥æŸ¥çœ‹åƒç´ ",
  bat = () => "Hineinzoomen, um die Pixel zu sehen",
  xat = () => "Acerca el zoom para ver los pÃ­xeles",
  wat = () => "Zoomez pour voir les pixels",
  kat = () => "Ingrandisci per vedere i pixel",
  Tat = () => "ãƒ”ã‚¯ã‚»ãƒ«ã‚’è¦‹ã‚‹ã«ã¯ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚",
  Sat = () => "PrzybliÅ¼, aby zobaczyÄ‡ piksele",
  Pat = () => "ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·ÑŒÑ‚Ğµ ĞºĞ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒĞ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ğ¿Ğ¸ĞºÑĞµĞ»Ğ¸",
  Mat = () => "Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑ–Ñ‚ÑŒ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±, Ñ‰Ğ¾Ğ± Ğ¿Ğ¾Ğ±Ğ°Ñ‡Ğ¸Ñ‚Ğ¸ Ğ¿Ñ–ĞºÑĞµĞ»Ñ–",
  Cat = () => "PhÃ³ng to Ä‘á»ƒ tháº¥y cÃ¡c pixel",
  Iat = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? gat() : t === "pt" ? yat() : t === "ch" ? vat() : t === "de" ? bat() : t === "es" ? xat() : t === "fr" ? wat() : t === "it" ? kat() : t === "jp" ? Tat() : t === "pl" ? Sat() : t === "ru" ? Pat() : t === "uk" ? Mat() : Cat()
  },
  zat = () => "Zoom out",
  Aat = () => "Diminuir zoom",
  Eat = () => "ç¼©å°",
  jat = () => "Herauszoomen",
  Lat = () => "Alejar",
  Dat = () => "Zoom arriÃ¨re",
  Rat = () => "Zoom indietro",
  Bat = () => "ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ",
  Fat = () => "Oddal",
  Oat = () => "ĞÑ‚Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ",
  qat = () => "Ğ—Ğ¼ĞµĞ½ÑˆĞ¸Ñ‚Ğ¸",
  Nat = () => "Thu nhá»",
  Vat = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? zat() : t === "pt" ? Aat() : t === "ch" ? Eat() : t === "de" ? jat() : t === "es" ? Lat() : t === "fr" ? Dat() : t === "it" ? Rat() : t === "jp" ? Bat() : t === "pl" ? Fat() : t === "ru" ? Oat() : t === "uk" ? qat() : Nat()
  },
  Uat = () => "Save with map",
  Zat = () => "Salvar com mapa",
  Gat = () => "è¿åŒåœ°å›¾ä¸€èµ·ä¿å­˜",
  Hat = () => "Mit Karte speichern",
  Wat = () => "Guardar con mapa",
  $at = () => "Enregistrer avec la carte",
  Xat = () => "Salva con mappa",
  Yat = () => "ãƒãƒƒãƒ—ä»˜ãã§ä¿å­˜",
  Kat = () => "Zapisz z mapÄ…",
  Jat = () => "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ğ¹",
  Qat = () => "Ğ—Ğ±ĞµÑ€ĞµĞ³Ñ‚Ğ¸ Ğ· ĞºĞ°Ñ€Ñ‚Ğ¾Ñ",
  tut = () => "LÆ°u kÃ¨m báº£n Ä‘á»“",
  eut = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Uat() : t === "pt" ? Zat() : t === "ch" ? Gat() : t === "de" ? Hat() : t === "es" ? Wat() : t === "fr" ? $at() : t === "it" ? Xat() : t === "jp" ? Yat() : t === "pl" ? Kat() : t === "ru" ? Jat() : t === "uk" ? Qat() : tut()
  },
  rut = () => "Show less",
  nut = () => "Mostrar menos",
  iut = () => "æ”¶èµ·",
  out = () => "Weniger anzeigen",
  sut = () => "Mostrar menos",
  aut = () => "Afficher moins",
  uut = () => "Mostra meno",
  cut = () => "å°‘ãªãè¡¨ç¤º",
  lut = () => "PokaÅ¼ mniej",
  _ut = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¼ĞµĞ½ÑŒÑˆĞµ",
  hut = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ¼ĞµĞ½ÑˆĞµ",
  dut = () => "áº¨n bá»›t",
  put = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rut() : t === "pt" ? nut() : t === "ch" ? iut() : t === "de" ? out() : t === "es" ? sut() : t === "fr" ? aut() : t === "it" ? uut() : t === "jp" ? cut() : t === "pl" ? lut() : t === "ru" ? _ut() : t === "uk" ? hut() : dut()
  },
  fut = () => "Show more",
  mut = () => "Mostrar mais",
  gut = () => "æ˜¾ç¤ºæ›´å¤š",
  yut = () => "Mehr anzeigen",
  vut = () => "Mostrar mÃ¡s",
  but = () => "Afficher plus",
  xut = () => "Mostra altro",
  wut = () => "ã‚‚ã£ã¨è¦‹ã‚‹",
  kut = () => "PokaÅ¼ wiÄ™cej",
  Tut = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ",
  Sut = () => "ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ",
  Put = () => "Hiá»ƒn thá»‹ thÃªm",
  Mut = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? fut() : t === "pt" ? mut() : t === "ch" ? gut() : t === "de" ? yut() : t === "es" ? vut() : t === "fr" ? but() : t === "it" ? xut() : t === "jp" ? wut() : t === "pl" ? kut() : t === "ru" ? Tut() : t === "uk" ? Sut() : Put()
  },
  Cut = () => "Transparent",
  Iut = () => "Transparente",
  zut = () => "é€æ˜",
  Aut = () => "Transparent",
  Eut = () => "Transparente",
  jut = () => "Transparent",
  Lut = () => "Trasparente",
  Dut = () => "é€æ˜",
  Rut = () => "Przejrzysty",
  But = () => "ĞŸÑ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ñ‹Ğ¹",
  Fut = () => "ĞŸÑ€Ğ¾Ğ·Ğ¾Ñ€Ğ¸Ğ¹",
  Out = () => "Trong suá»‘t",
  qut = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Cut() : t === "pt" ? Iut() : t === "ch" ? zut() : t === "de" ? Aut() : t === "es" ? Eut() : t === "fr" ? jut() : t === "it" ? Lut() : t === "jp" ? Dut() : t === "pl" ? Rut() : t === "ru" ? But() : t === "uk" ? Fut() : Out()
  },
  Nut = () => "Black",
  Vut = () => "Preto",
  Uut = () => "é»‘è‰²",
  Zut = () => "Schwarz",
  Gut = () => "Negro",
  Hut = () => "Noir",
  Wut = () => "Nero",
  $ut = () => "é»’",
  Xut = () => "Czarny",
  Yut = () => "Ğ§ĞµÑ€Ğ½Ñ‹Ğ¹",
  Kut = () => "Ğ§Ğ¾Ñ€Ğ½Ğ¸Ğ¹",
  Jut = () => "Äen",
  Qut = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Nut() : t === "pt" ? Vut() : t === "ch" ? Uut() : t === "de" ? Zut() : t === "es" ? Gut() : t === "fr" ? Hut() : t === "it" ? Wut() : t === "jp" ? $ut() : t === "pl" ? Xut() : t === "ru" ? Yut() : t === "uk" ? Kut() : Jut()
  },
  tct = () => "Dark Gray",
  ect = () => "Cinza Escuro",
  rct = () => "æ·±ç°è‰²",
  nct = () => "Dunkelgrau",
  ict = () => "Gris oscuro",
  oct = () => "Gris foncÃ©",
  sct = () => "Grigio scuro",
  act = () => "æ¿ƒã„ç°è‰²",
  uct = () => "Ciemnoszary",
  cct = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-ÑĞµÑ€Ñ‹Ğ¹",
  lct = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-ÑÑ–Ñ€Ğ¸Ğ¹",
  _ct = () => "XÃ¡m Ä‘áº­m",
  hct = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? tct() : t === "pt" ? ect() : t === "ch" ? rct() : t === "de" ? nct() : t === "es" ? ict() : t === "fr" ? oct() : t === "it" ? sct() : t === "jp" ? act() : t === "pl" ? uct() : t === "ru" ? cct() : t === "uk" ? lct() : _ct()
  },
  dct = () => "Gray",
  pct = () => "Cinza",
  fct = () => "ç°è‰²",
  mct = () => "Grau",
  gct = () => "Gris",
  yct = () => "Gris",
  vct = () => "Grigio",
  bct = () => "ã‚°ãƒ¬ãƒ¼",
  xct = () => "Szary",
  wct = () => "Ğ¡ĞµÑ€Ñ‹Ğ¹",
  kct = () => "Ğ¡Ñ–Ñ€Ğ¸Ğ¹",
  Tct = () => "XÃ¡m",
  Sct = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? dct() : t === "pt" ? pct() : t === "ch" ? fct() : t === "de" ? mct() : t === "es" ? gct() : t === "fr" ? yct() : t === "it" ? vct() : t === "jp" ? bct() : t === "pl" ? xct() : t === "ru" ? wct() : t === "uk" ? kct() : Tct()
  },
  Pct = () => "Light Gray",
  Mct = () => "Cinza Claro",
  Cct = () => "æµ…ç°è‰²",
  Ict = () => "Hellgrau",
  zct = () => "Gris Claro",
  Act = () => "Gris clair",
  Ect = () => "Grigio chiaro",
  jct = () => "ãƒ©ã‚¤ãƒˆã‚°ãƒ¬ãƒ¼",
  Lct = () => "Jasnoszary",
  Dct = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-ÑĞµÑ€Ñ‹Ğ¹",
  Rct = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-ÑÑ–Ñ€Ğ¸Ğ¹",
  Bct = () => "XÃ¡m nháº¡t",
  Fct = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Pct() : t === "pt" ? Mct() : t === "ch" ? Cct() : t === "de" ? Ict() : t === "es" ? zct() : t === "fr" ? Act() : t === "it" ? Ect() : t === "jp" ? jct() : t === "pl" ? Lct() : t === "ru" ? Dct() : t === "uk" ? Rct() : Bct()
  },
  Oct = () => "White",
  qct = () => "Branco",
  Nct = () => "ç™½è‰²",
  Vct = () => "WeiÃŸ",
  Uct = () => "Blanco",
  Zct = () => "Blanc",
  Gct = () => "Bianco",
  Hct = () => "ç™½",
  Wct = () => "BiaÅ‚y",
  $ct = () => "Ğ‘ĞµĞ»Ñ‹Ğ¹",
  Xct = () => "Ğ‘Ñ–Ğ»Ğ¸Ğ¹",
  Yct = () => "Tráº¯ng",
  Kct = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Oct() : t === "pt" ? qct() : t === "ch" ? Nct() : t === "de" ? Vct() : t === "es" ? Uct() : t === "fr" ? Zct() : t === "it" ? Gct() : t === "jp" ? Hct() : t === "pl" ? Wct() : t === "ru" ? $ct() : t === "uk" ? Xct() : Yct()
  },
  Jct = () => "Deep Red",
  Qct = () => "Vermelho Intenso",
  tlt = () => "æ·±çº¢è‰²",
  elt = () => "Dunkelrot",
  rlt = () => "Rojo Oscuro",
  nlt = () => "Rouge profond",
  ilt = () => "Rosso Profondo",
  olt = () => "æ·±ç´…",
  slt = () => "GÅ‚Ä™boka CzerwieÅ„",
  alt = () => "Ğ“Ğ»ÑƒĞ±Ğ¾ĞºĞ¸Ğ¹ ĞºÑ€Ğ°ÑĞ½Ñ‹Ğ¹",
  ult = () => "Ğ“Ğ»Ğ¸Ğ±Ğ¾ĞºĞ¸Ğ¹ Ñ‡ĞµÑ€Ğ²Ğ¾Ğ½Ğ¸Ğ¹",
  clt = () => "Äá» Ä‘áº­m",
  llt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Jct() : t === "pt" ? Qct() : t === "ch" ? tlt() : t === "de" ? elt() : t === "es" ? rlt() : t === "fr" ? nlt() : t === "it" ? ilt() : t === "jp" ? olt() : t === "pl" ? slt() : t === "ru" ? alt() : t === "uk" ? ult() : clt()
  },
  _lt = () => "Red",
  hlt = () => "Vermelho",
  dlt = () => "çº¢è‰²",
  plt = () => "Rot",
  flt = () => "Rojo",
  mlt = () => "Rouge",
  glt = () => "Rosso",
  ylt = () => "èµ¤",
  vlt = () => "Czerwony",
  blt = () => "ĞšÑ€Ğ°ÑĞ½Ñ‹Ğ¹",
  xlt = () => "Ğ§ĞµÑ€Ğ²Ğ¾Ğ½Ğ¸Ğ¹",
  wlt = () => "Äá»",
  klt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? _lt() : t === "pt" ? hlt() : t === "ch" ? dlt() : t === "de" ? plt() : t === "es" ? flt() : t === "fr" ? mlt() : t === "it" ? glt() : t === "jp" ? ylt() : t === "pl" ? vlt() : t === "ru" ? blt() : t === "uk" ? xlt() : wlt()
  },
  Tlt = () => "Orange",
  Slt = () => "Laranja",
  Plt = () => "æ©™è‰²",
  Mlt = () => "Orange",
  Clt = () => "Naranja",
  Ilt = () => "Orange",
  zlt = () => "Arancia",
  Alt = () => "ã‚ªãƒ¬ãƒ³ã‚¸",
  Elt = () => "PomaraÅ„cza",
  jlt = () => "ĞĞ¿ĞµĞ»ÑŒÑĞ¸Ğ½",
  Llt = () => "ĞĞ¿ĞµĞ»ÑŒÑĞ¸Ğ½",
  Dlt = () => "Cam",
  Rlt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Tlt() : t === "pt" ? Slt() : t === "ch" ? Plt() : t === "de" ? Mlt() : t === "es" ? Clt() : t === "fr" ? Ilt() : t === "it" ? zlt() : t === "jp" ? Alt() : t === "pl" ? Elt() : t === "ru" ? jlt() : t === "uk" ? Llt() : Dlt()
  },
  Blt = () => "Gold",
  Flt = () => "Ouro",
  Olt = () => "é»„é‡‘",
  qlt = () => "Gold",
  Nlt = () => "Oro",
  Vlt = () => "Or",
  Ult = () => "Oro",
  Zlt = () => "ã‚´ãƒ¼ãƒ«ãƒ‰",
  Glt = () => "ZÅ‚oto",
  Hlt = () => "Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ¾",
  Wlt = () => "Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ¾",
  $lt = () => "VÃ ng",
  Xlt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Blt() : t === "pt" ? Flt() : t === "ch" ? Olt() : t === "de" ? qlt() : t === "es" ? Nlt() : t === "fr" ? Vlt() : t === "it" ? Ult() : t === "jp" ? Zlt() : t === "pl" ? Glt() : t === "ru" ? Hlt() : t === "uk" ? Wlt() : $lt()
  },
  Ylt = () => "Yellow",
  Klt = () => "Amarelo",
  Jlt = () => "é»„è‰²",
  Qlt = () => "Gelb",
  t_t = () => "Amarillo",
  e_t = () => "Jaune",
  r_t = () => "Giallo",
  n_t = () => "é»„è‰²",
  i_t = () => "Å»Ã³Å‚ty",
  o_t = () => "Ğ–ĞµĞ»Ñ‚Ñ‹Ğ¹",
  s_t = () => "Ğ–Ğ¾Ğ²Ñ‚Ğ¸Ğ¹",
  a_t = () => "VÃ ng",
  u_t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ylt() : t === "pt" ? Klt() : t === "ch" ? Jlt() : t === "de" ? Qlt() : t === "es" ? t_t() : t === "fr" ? e_t() : t === "it" ? r_t() : t === "jp" ? n_t() : t === "pl" ? i_t() : t === "ru" ? o_t() : t === "uk" ? s_t() : a_t()
  },
  c_t = () => "Light Yellow",
  l_t = () => "Amarelo Claro",
  __t = () => "æµ…é»„è‰²",
  h_t = () => "Hellgelb",
  d_t = () => "Amarillo Claro",
  p_t = () => "Jaune clair",
  f_t = () => "Giallo chiaro",
  m_t = () => "è–„é»„è‰²",
  g_t = () => "JasnoÅ¼Ã³Å‚ty",
  y_t = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ¶ĞµĞ»Ñ‚Ñ‹Ğ¹",
  v_t = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ¶Ğ¾Ğ²Ñ‚Ğ¸Ğ¹",
  b_t = () => "VÃ ng nháº¡t",
  x_t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? c_t() : t === "pt" ? l_t() : t === "ch" ? __t() : t === "de" ? h_t() : t === "es" ? d_t() : t === "fr" ? p_t() : t === "it" ? f_t() : t === "jp" ? m_t() : t === "pl" ? g_t() : t === "ru" ? y_t() : t === "uk" ? v_t() : b_t()
  },
  w_t = () => "Dark Green",
  k_t = () => "Verde Escuro",
  T_t = () => "æ·±ç»¿è‰²",
  S_t = () => "DunkelgrÃ¼n",
  P_t = () => "Verde Oscuro",
  M_t = () => "Vert foncÃ©",
  C_t = () => "Verde scuro",
  I_t = () => "æ¿ƒã„ç·‘",
  z_t = () => "Ciemnozielony",
  A_t = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ·ĞµĞ»ĞµĞ½Ñ‹Ğ¹",
  E_t = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ·ĞµĞ»ĞµĞ½Ğ¸Ğ¹",
  j_t = () => "Xanh lÃ¡ Ä‘áº­m",
  L_t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? w_t() : t === "pt" ? k_t() : t === "ch" ? T_t() : t === "de" ? S_t() : t === "es" ? P_t() : t === "fr" ? M_t() : t === "it" ? C_t() : t === "jp" ? I_t() : t === "pl" ? z_t() : t === "ru" ? A_t() : t === "uk" ? E_t() : j_t()
  },
  D_t = () => "Green",
  R_t = () => "Verde",
  B_t = () => "ç»¿è‰²",
  F_t = () => "GrÃ¼n",
  O_t = () => "Verde",
  q_t = () => "Vert",
  N_t = () => "Verde",
  V_t = () => "ç·‘",
  U_t = () => "Zielony",
  Z_t = () => "Ğ—ĞµĞ»Ñ‘Ğ½Ñ‹Ğ¹",
  G_t = () => "Ğ—ĞµĞ»ĞµĞ½Ğ¸Ğ¹",
  H_t = () => "Xanh lÃ¡",
  W_t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? D_t() : t === "pt" ? R_t() : t === "ch" ? B_t() : t === "de" ? F_t() : t === "es" ? O_t() : t === "fr" ? q_t() : t === "it" ? N_t() : t === "jp" ? V_t() : t === "pl" ? U_t() : t === "ru" ? Z_t() : t === "uk" ? G_t() : H_t()
  },
  $_t = () => "Light Green",
  X_t = () => "Verde Claro",
  Y_t = () => "æµ…ç»¿è‰²",
  K_t = () => "HellgrÃ¼n",
  J_t = () => "Verde claro",
  Q_t = () => "Vert clair",
  tht = () => "Verde chiaro",
  eht = () => "è–„ç·‘",
  rht = () => "Jasnozielony",
  nht = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ·ĞµĞ»ĞµĞ½Ñ‹Ğ¹",
  iht = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ·ĞµĞ»ĞµĞ½Ğ¸Ğ¹",
  oht = () => "Xanh lÃ¡ cÃ¢y nháº¡t",
  sht = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $_t() : t === "pt" ? X_t() : t === "ch" ? Y_t() : t === "de" ? K_t() : t === "es" ? J_t() : t === "fr" ? Q_t() : t === "it" ? tht() : t === "jp" ? eht() : t === "pl" ? rht() : t === "ru" ? nht() : t === "uk" ? iht() : oht()
  },
  aht = () => "Dark Teal",
  uht = () => "Azul-petrÃ³leo escuro",
  cht = () => "æ·±é’è‰²",
  lht = () => "Dunkles TÃ¼rkis",
  _ht = () => "Verde azulado oscuro",
  hht = () => "Sarcelle foncÃ©e",
  dht = () => "Ottanio scuro",
  pht = () => "ãƒ€ãƒ¼ã‚¯ãƒ†ã‚£ãƒ¼ãƒ«",
  fht = () => "Ciemny Turkusowy",
  mht = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ±Ğ¸Ñ€ÑĞ·Ğ¾Ğ²Ñ‹Ğ¹",
  ght = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ±Ñ–Ñ€ÑĞ·Ğ¾Ğ²Ğ¸Ğ¹",
  yht = () => "Xanh mÃ²ng kÃ©t Ä‘áº­m",
  vht = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? aht() : t === "pt" ? uht() : t === "ch" ? cht() : t === "de" ? lht() : t === "es" ? _ht() : t === "fr" ? hht() : t === "it" ? dht() : t === "jp" ? pht() : t === "pl" ? fht() : t === "ru" ? mht() : t === "uk" ? ght() : yht()
  },
  bht = () => "Teal",
  xht = () => "Azul-petrÃ³leo",
  wht = () => "é¸­ç»¿è‰²",
  kht = () => "Petrol",
  Tht = () => "Verde azulado",
  Sht = () => "Sarcelle",
  Pht = () => "Verde acqua",
  Mht = () => "ãƒ†ã‚£ãƒ¼",
  Cht = () => "Turkusowy",
  Iht = () => "Ğ‘Ğ¸Ñ€ÑĞ·Ğ¾Ğ²Ñ‹Ğ¹",
  zht = () => "Ğ‘Ñ–Ñ€ÑĞ·Ğ¾Ğ²Ğ¸Ğ¹",
  Aht = () => "Xanh mÃ²ng kÃ©t",
  Eht = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? bht() : t === "pt" ? xht() : t === "ch" ? wht() : t === "de" ? kht() : t === "es" ? Tht() : t === "fr" ? Sht() : t === "it" ? Pht() : t === "jp" ? Mht() : t === "pl" ? Cht() : t === "ru" ? Iht() : t === "uk" ? zht() : Aht()
  },
  jht = () => "Light Teal",
  Lht = () => "Verde-azulado claro",
  Dht = () => "æµ…æ°´é¸­è‰²",
  Rht = () => "HelltÃ¼rkis",
  Bht = () => "Verde azulado claro",
  Fht = () => "Bleu-vert clair",
  Oht = () => "Verde acqua chiaro",
  qht = () => "ãƒ©ã‚¤ãƒˆãƒ†ã‚£ãƒ¼ãƒ«",
  Nht = () => "Jasny turkusowy",
  Vht = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ±Ğ¸Ñ€ÑĞ·Ğ¾Ğ²Ñ‹Ğ¹",
  Uht = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ±Ñ–Ñ€ÑĞ·Ğ¾Ğ²Ğ¸Ğ¹",
  Zht = () => "Xanh mÃ²ng kÃ©t nháº¡t",
  Ght = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? jht() : t === "pt" ? Lht() : t === "ch" ? Dht() : t === "de" ? Rht() : t === "es" ? Bht() : t === "fr" ? Fht() : t === "it" ? Oht() : t === "jp" ? qht() : t === "pl" ? Nht() : t === "ru" ? Vht() : t === "uk" ? Uht() : Zht()
  },
  Hht = () => "Dark Blue",
  Wht = () => "Azul Escuro",
  $ht = () => "æ·±è“è‰²",
  Xht = () => "Dunkelblau",
  Yht = () => "Azul oscuro",
  Kht = () => "Bleu foncÃ©",
  Jht = () => "Blu scuro",
  Qht = () => "æ¿ƒã„é’è‰²",
  tdt = () => "Ciemnoniebieski",
  edt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-ÑĞ¸Ğ½Ğ¸Ğ¹",
  rdt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-ÑĞ¸Ğ½Ñ–Ğ¹",
  ndt = () => "Xanh Ä‘áº­m",
  idt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Hht() : t === "pt" ? Wht() : t === "ch" ? $ht() : t === "de" ? Xht() : t === "es" ? Yht() : t === "fr" ? Kht() : t === "it" ? Jht() : t === "jp" ? Qht() : t === "pl" ? tdt() : t === "ru" ? edt() : t === "uk" ? rdt() : ndt()
  },
  odt = () => "Blue",
  sdt = () => "Azul",
  adt = () => "è“è‰²",
  udt = () => "Blau",
  cdt = () => "Azul",
  ldt = () => "Bleu",
  _dt = () => "Blu",
  hdt = () => "é’",
  ddt = () => "Niebieski",
  pdt = () => "Ğ¡Ğ¸Ğ½Ğ¸Ğ¹",
  fdt = () => "Ğ¡Ğ¸Ğ½Ñ–Ğ¹",
  mdt = () => "Xanh",
  gdt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? odt() : t === "pt" ? sdt() : t === "ch" ? adt() : t === "de" ? udt() : t === "es" ? cdt() : t === "fr" ? ldt() : t === "it" ? _dt() : t === "jp" ? hdt() : t === "pl" ? ddt() : t === "ru" ? pdt() : t === "uk" ? fdt() : mdt()
  },
  ydt = () => "Cyan",
  vdt = () => "Ciano",
  bdt = () => "é’è‰²",
  xdt = () => "Cyan",
  wdt = () => "Cian",
  kdt = () => "Cyan",
  Tdt = () => "Ciano",
  Sdt = () => "ã‚·ã‚¢ãƒ³",
  Pdt = () => "Cyjan",
  Mdt = () => "Ğ“Ğ¾Ğ»ÑƒĞ±Ğ¾Ğ¹",
  Cdt = () => "Ğ¦Ñ–Ğ°Ğ½Ğ¾Ğ²Ğ¸Ğ¹",
  Idt = () => "Lá»¥c lam",
  zdt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ydt() : t === "pt" ? vdt() : t === "ch" ? bdt() : t === "de" ? xdt() : t === "es" ? wdt() : t === "fr" ? kdt() : t === "it" ? Tdt() : t === "jp" ? Sdt() : t === "pl" ? Pdt() : t === "ru" ? Mdt() : t === "uk" ? Cdt() : Idt()
  },
  Adt = () => "Indigo",
  Edt = () => "Ãndigo",
  jdt = () => "é›è“è‰²",
  Ldt = () => "Indigo",
  Ddt = () => "Ãndigo",
  Rdt = () => "Indigo",
  Bdt = () => "Indaco",
  Fdt = () => "ã‚¤ãƒ³ãƒ‡ã‚£ã‚´",
  Odt = () => "Indygo",
  qdt = () => "Ğ˜Ğ½Ğ´Ğ¸Ğ³Ğ¾",
  Ndt = () => "IĞ½Ğ´Ğ¸Ğ³Ğ¾",
  Vdt = () => "ChÃ m",
  Udt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Adt() : t === "pt" ? Edt() : t === "ch" ? jdt() : t === "de" ? Ldt() : t === "es" ? Ddt() : t === "fr" ? Rdt() : t === "it" ? Bdt() : t === "jp" ? Fdt() : t === "pl" ? Odt() : t === "ru" ? qdt() : t === "uk" ? Ndt() : Vdt()
  },
  Zdt = () => "Light Indigo",
  Gdt = () => "Ãndigo Claro",
  Hdt = () => "æµ…é›è“è‰²",
  Wdt = () => "Hellindigo",
  $dt = () => "Ãndigo Claro",
  Xdt = () => "Indigo clair",
  Ydt = () => "Indaco Chiaro",
  Kdt = () => "ãƒ©ã‚¤ãƒˆã‚¤ãƒ³ãƒ‡ã‚£ã‚´",
  Jdt = () => "Jasne Indygo",
  Qdt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾Ğµ Ğ¸Ğ½Ğ´Ğ¸Ğ³Ğ¾",
  tpt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğµ Ñ–Ğ½Ğ´Ğ¸Ğ³Ğ¾",
  ept = () => "Xanh chÃ m nháº¡t",
  rpt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Zdt() : t === "pt" ? Gdt() : t === "ch" ? Hdt() : t === "de" ? Wdt() : t === "es" ? $dt() : t === "fr" ? Xdt() : t === "it" ? Ydt() : t === "jp" ? Kdt() : t === "pl" ? Jdt() : t === "ru" ? Qdt() : t === "uk" ? tpt() : ept()
  },
  npt = () => "Dark Purple",
  ipt = () => "Roxo Escuro",
  opt = () => "æ·±ç´«è‰²",
  spt = () => "Dunkelviolett",
  apt = () => "Morado Oscuro",
  upt = () => "Violet foncÃ©",
  cpt = () => "Viola Scuro",
  lpt = () => "æ¿ƒã„ç´«",
  _pt = () => "Ciemny fiolet",
  hpt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ñ„Ğ¸Ğ¾Ğ»ĞµÑ‚Ğ¾Ğ²Ñ‹Ğ¹",
  dpt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ñ„Ñ–Ğ¾Ğ»ĞµÑ‚Ğ¾Ğ²Ğ¸Ğ¹",
  ppt = () => "TÃ­m Ä‘áº­m",
  fpt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? npt() : t === "pt" ? ipt() : t === "ch" ? opt() : t === "de" ? spt() : t === "es" ? apt() : t === "fr" ? upt() : t === "it" ? cpt() : t === "jp" ? lpt() : t === "pl" ? _pt() : t === "ru" ? hpt() : t === "uk" ? dpt() : ppt()
  },
  mpt = () => "Purple",
  gpt = () => "Roxo",
  ypt = () => "ç´«è‰²",
  vpt = () => "Lila",
  bpt = () => "Morado",
  xpt = () => "Violet",
  wpt = () => "Viola",
  kpt = () => "ç´«",
  Tpt = () => "Fioletowy",
  Spt = () => "Ğ¤Ğ¸Ğ¾Ğ»ĞµÑ‚Ğ¾Ğ²Ñ‹Ğ¹",
  Ppt = () => "Ğ¤Ñ–Ğ¾Ğ»ĞµÑ‚Ğ¾Ğ²Ğ¸Ğ¹",
  Mpt = () => "TÃ­m",
  Cpt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mpt() : t === "pt" ? gpt() : t === "ch" ? ypt() : t === "de" ? vpt() : t === "es" ? bpt() : t === "fr" ? xpt() : t === "it" ? wpt() : t === "jp" ? kpt() : t === "pl" ? Tpt() : t === "ru" ? Spt() : t === "uk" ? Ppt() : Mpt()
  },
  Ipt = () => "Light Purple",
  zpt = () => "Roxo Claro",
  Apt = () => "æµ…ç´«è‰²",
  Ept = () => "Helllila",
  jpt = () => "Morado Claro",
  Lpt = () => "Violet clair",
  Dpt = () => "Viola Chiaro",
  Rpt = () => "è–„ç´«",
  Bpt = () => "Jasny fioletowy",
  Fpt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ñ„Ğ¸Ğ¾Ğ»ĞµÑ‚Ğ¾Ğ²Ñ‹Ğ¹",
  Opt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ñ„Ñ–Ğ¾Ğ»ĞµÑ‚Ğ¾Ğ²Ğ¸Ğ¹",
  qpt = () => "TÃ­m nháº¡t",
  Npt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ipt() : t === "pt" ? zpt() : t === "ch" ? Apt() : t === "de" ? Ept() : t === "es" ? jpt() : t === "fr" ? Lpt() : t === "it" ? Dpt() : t === "jp" ? Rpt() : t === "pl" ? Bpt() : t === "ru" ? Fpt() : t === "uk" ? Opt() : qpt()
  },
  Vpt = () => "Dark Pink",
  Upt = () => "Rosa Escuro",
  Zpt = () => "æ·±ç²‰è‰²",
  Gpt = () => "Dunkelrosa",
  Hpt = () => "Rosa Oscuro",
  Wpt = () => "Rose foncÃ©",
  $pt = () => "Rosa scuro",
  Xpt = () => "æ¿ƒã„ãƒ”ãƒ³ã‚¯",
  Ypt = () => "CiemnorÃ³Å¼owy",
  Kpt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ñ€Ğ¾Ğ·Ğ¾Ğ²Ñ‹Ğ¹",
  Jpt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ñ€Ğ¾Ğ¶ĞµĞ²Ğ¸Ğ¹",
  Qpt = () => "Há»“ng Ä‘áº­m",
  tft = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Vpt() : t === "pt" ? Upt() : t === "ch" ? Zpt() : t === "de" ? Gpt() : t === "es" ? Hpt() : t === "fr" ? Wpt() : t === "it" ? $pt() : t === "jp" ? Xpt() : t === "pl" ? Ypt() : t === "ru" ? Kpt() : t === "uk" ? Jpt() : Qpt()
  },
  eft = () => "Pink",
  rft = () => "Rosa",
  nft = () => "ç²‰è‰²",
  ift = () => "Rosa",
  oft = () => "Rosa",
  sft = () => "Rose",
  aft = () => "Rosa",
  uft = () => "ãƒ”ãƒ³ã‚¯",
  cft = () => "RÃ³Å¼owy",
  lft = () => "Ğ Ğ¾Ğ·Ğ¾Ğ²Ñ‹Ğ¹",
  _ft = () => "Ğ Ğ¾Ğ¶ĞµĞ²Ğ¸Ğ¹",
  hft = () => "Há»“ng",
  dft = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? eft() : t === "pt" ? rft() : t === "ch" ? nft() : t === "de" ? ift() : t === "es" ? oft() : t === "fr" ? sft() : t === "it" ? aft() : t === "jp" ? uft() : t === "pl" ? cft() : t === "ru" ? lft() : t === "uk" ? _ft() : hft()
  },
  pft = () => "Light Pink",
  fft = () => "Rosa Claro",
  mft = () => "æµ…ç²‰çº¢è‰²",
  gft = () => "Hellrosa",
  yft = () => "Rosa claro",
  vft = () => "Rose clair",
  bft = () => "Rosa chiaro",
  xft = () => "è–„ãƒ”ãƒ³ã‚¯",
  wft = () => "JasnorÃ³Å¼owy",
  kft = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ñ€Ğ¾Ğ·Ğ¾Ğ²Ñ‹Ğ¹",
  Tft = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ñ€Ğ¾Ğ¶ĞµĞ²Ğ¸Ğ¹",
  Sft = () => "Há»“ng nháº¡t",
  Pft = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pft() : t === "pt" ? fft() : t === "ch" ? mft() : t === "de" ? gft() : t === "es" ? yft() : t === "fr" ? vft() : t === "it" ? bft() : t === "jp" ? xft() : t === "pl" ? wft() : t === "ru" ? kft() : t === "uk" ? Tft() : Sft()
  },
  Mft = () => "Dark Brown",
  Cft = () => "Marrom Escuro",
  Ift = () => "æ·±æ£•è‰²",
  zft = () => "Dunkelbraun",
  Aft = () => "MarrÃ³n Oscuro",
  Eft = () => "Brun foncÃ©",
  jft = () => "Marrone scuro",
  Lft = () => "æ¿ƒã„èŒ¶è‰²",
  Dft = () => "CiemnobrÄ…zowy",
  Rft = () => "Ğ¢Ñ‘Ğ¼Ğ½Ğ¾-ĞºĞ¾Ñ€Ğ¸Ñ‡Ğ½ĞµĞ²Ñ‹Ğ¹",
  Bft = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-ĞºĞ¾Ñ€Ğ¸Ñ‡Ğ½ĞµĞ²Ğ¸Ğ¹",
  Fft = () => "NÃ¢u Ä‘áº­m",
  Oft = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Mft() : t === "pt" ? Cft() : t === "ch" ? Ift() : t === "de" ? zft() : t === "es" ? Aft() : t === "fr" ? Eft() : t === "it" ? jft() : t === "jp" ? Lft() : t === "pl" ? Dft() : t === "ru" ? Rft() : t === "uk" ? Bft() : Fft()
  },
  qft = () => "Brown",
  Nft = () => "Marrom",
  Vft = () => "æ£•è‰²",
  Uft = () => "Braun",
  Zft = () => "MarrÃ³n",
  Gft = () => "Marron",
  Hft = () => "Marrone",
  Wft = () => "èŒ¶è‰²",
  $ft = () => "BrÄ…zowy",
  Xft = () => "ĞšĞ¾Ñ€Ğ¸Ñ‡Ğ½ĞµĞ²Ñ‹Ğ¹",
  Yft = () => "ĞšĞ¾Ñ€Ğ¸Ñ‡Ğ½ĞµĞ²Ğ¸Ğ¹",
  Kft = () => "NÃ¢u",
  Jft = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qft() : t === "pt" ? Nft() : t === "ch" ? Vft() : t === "de" ? Uft() : t === "es" ? Zft() : t === "fr" ? Gft() : t === "it" ? Hft() : t === "jp" ? Wft() : t === "pl" ? $ft() : t === "ru" ? Xft() : t === "uk" ? Yft() : Kft()
  },
  Qft = () => "Beige",
  tmt = () => "Bege",
  emt = () => "ç±³è‰²",
  rmt = () => "Beige",
  nmt = () => "Beige",
  imt = () => "Beige",
  omt = () => "Beige",
  smt = () => "ãƒ™ãƒ¼ã‚¸ãƒ¥",
  amt = () => "BeÅ¼owy",
  umt = () => "Ğ‘ĞµĞ¶ĞµĞ²Ñ‹Ğ¹",
  cmt = () => "Ğ‘ĞµĞ¶ĞµĞ²Ğ¸Ğ¹",
  lmt = () => "MÃ u be",
  _mt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Qft() : t === "pt" ? tmt() : t === "ch" ? emt() : t === "de" ? rmt() : t === "es" ? nmt() : t === "fr" ? imt() : t === "it" ? omt() : t === "jp" ? smt() : t === "pl" ? amt() : t === "ru" ? umt() : t === "uk" ? cmt() : lmt()
  },
  hmt = () => "Medium Gray",
  dmt = () => "Cinza MÃ©dio",
  pmt = () => "ä¸­ç°è‰²",
  fmt = () => "Mittelgrau",
  mmt = () => "Gris medio",
  gmt = () => "Gris moyen",
  ymt = () => "Grigio medio",
  vmt = () => "ãƒŸãƒ‡ã‚£ã‚¢ãƒ ã‚°ãƒ¬ãƒ¼",
  bmt = () => "Åšredni szary",
  xmt = () => "Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ ÑĞµÑ€Ñ‹Ğ¹",
  wmt = () => "Ğ¡ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ ÑÑ–Ñ€Ğ¸Ğ¹",
  kmt = () => "XÃ¡m trung bÃ¬nh",
  Tmt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hmt() : t === "pt" ? dmt() : t === "ch" ? pmt() : t === "de" ? fmt() : t === "es" ? mmt() : t === "fr" ? gmt() : t === "it" ? ymt() : t === "jp" ? vmt() : t === "pl" ? bmt() : t === "ru" ? xmt() : t === "uk" ? wmt() : kmt()
  },
  Smt = () => "Dark Red",
  Pmt = () => "Vermelho Escuro",
  Mmt = () => "æ·±çº¢è‰²",
  Cmt = () => "Dunkelrot",
  Imt = () => "Rojo oscuro",
  zmt = () => "Rouge foncÃ©",
  Amt = () => "Rosso Scuro",
  Emt = () => "æ¿ƒã„èµ¤",
  jmt = () => "Ciemnoczerwony",
  Lmt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-ĞºÑ€Ğ°ÑĞ½Ñ‹Ğ¹",
  Dmt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ñ‡ĞµÑ€Ğ²Ğ¾Ğ½Ğ¸Ğ¹",
  Rmt = () => "Äá» sáº«m",
  Bmt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Smt() : t === "pt" ? Pmt() : t === "ch" ? Mmt() : t === "de" ? Cmt() : t === "es" ? Imt() : t === "fr" ? zmt() : t === "it" ? Amt() : t === "jp" ? Emt() : t === "pl" ? jmt() : t === "ru" ? Lmt() : t === "uk" ? Dmt() : Rmt()
  },
  Fmt = () => "Light Red",
  Omt = () => "Vermelho Claro",
  qmt = () => "æµ…çº¢è‰²",
  Nmt = () => "Hellrot",
  Vmt = () => "Rojo claro",
  Umt = () => "Rouge clair",
  Zmt = () => "Rosso chiaro",
  Gmt = () => "è–„ã„èµ¤",
  Hmt = () => "Jasnoczerwony",
  Wmt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-ĞºÑ€Ğ°ÑĞ½Ñ‹Ğ¹",
  $mt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ñ‡ĞµÑ€Ğ²Ğ¾Ğ½Ğ¸Ğ¹",
  Xmt = () => "Äá» nháº¡t",
  Ymt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Fmt() : t === "pt" ? Omt() : t === "ch" ? qmt() : t === "de" ? Nmt() : t === "es" ? Vmt() : t === "fr" ? Umt() : t === "it" ? Zmt() : t === "jp" ? Gmt() : t === "pl" ? Hmt() : t === "ru" ? Wmt() : t === "uk" ? $mt() : Xmt()
  },
  Kmt = () => "Dark Orange",
  Jmt = () => "Laranja Escuro",
  Qmt = () => "æ·±æ©™è‰²",
  tgt = () => "Dunkelorange",
  egt = () => "Naranja Oscuro",
  rgt = () => "Orange foncÃ©",
  ngt = () => "Arancione Scuro",
  igt = () => "æ¿ƒã„ã‚ªãƒ¬ãƒ³ã‚¸",
  ogt = () => "CiemnopomaraÅ„czowy",
  sgt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ¾Ñ€Ğ°Ğ½Ğ¶ĞµĞ²Ñ‹Ğ¹",
  agt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ¿Ğ¾Ğ¼Ğ°Ñ€Ğ°Ğ½Ñ‡ĞµĞ²Ğ¸Ğ¹",
  ugt = () => "Cam Ä‘áº­m",
  cgt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Kmt() : t === "pt" ? Jmt() : t === "ch" ? Qmt() : t === "de" ? tgt() : t === "es" ? egt() : t === "fr" ? rgt() : t === "it" ? ngt() : t === "jp" ? igt() : t === "pl" ? ogt() : t === "ru" ? sgt() : t === "uk" ? agt() : ugt()
  },
  lgt = () => "Light Tan",
  _gt = () => "Bege Claro",
  hgt = () => "æµ…æ£•è‰²",
  dgt = () => "Hellbraun",
  pgt = () => "Beige claro",
  fgt = () => "Beige clair",
  mgt = () => "Beige chiaro",
  ggt = () => "ãƒ©ã‚¤ãƒˆã‚¿ãƒ³",
  ygt = () => "Jasny beÅ¼",
  vgt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ±ĞµĞ¶ĞµĞ²Ñ‹Ğ¹",
  bgt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ±ĞµĞ¶ĞµĞ²Ğ¸Ğ¹",
  xgt = () => "NÃ¢u nháº¡t",
  wgt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lgt() : t === "pt" ? _gt() : t === "ch" ? hgt() : t === "de" ? dgt() : t === "es" ? pgt() : t === "fr" ? fgt() : t === "it" ? mgt() : t === "jp" ? ggt() : t === "pl" ? ygt() : t === "ru" ? vgt() : t === "uk" ? bgt() : xgt()
  },
  kgt = () => "Dark Goldenrod",
  Tgt = () => "Dourado Escuro",
  Sgt = () => "æš—é‡‘èŠè‰²",
  Pgt = () => "Dunkelgoldrute",
  Mgt = () => "Dorado Oscuro",
  Cgt = () => "Verge d'or foncÃ©e",
  Igt = () => "Giallo verga d'oro scuro",
  zgt = () => "ãƒ€ãƒ¼ã‚¯ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ãƒ­ãƒƒãƒ‰",
  Agt = () => "Ciemny zÅ‚ocisty",
  Egt = () => "Ğ¢Ñ‘Ğ¼Ğ½Ñ‹Ğ¹ Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ°Ñ€Ğ½Ğ¸Ğº",
  jgt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ Ğ·Ğ¾Ğ»Ğ¾Ñ‚Ğ°Ñ€Ğ½Ğ¸Ğº",
  Lgt = () => "VÃ ng kim sa Ä‘áº­m",
  Dgt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kgt() : t === "pt" ? Tgt() : t === "ch" ? Sgt() : t === "de" ? Pgt() : t === "es" ? Mgt() : t === "fr" ? Cgt() : t === "it" ? Igt() : t === "jp" ? zgt() : t === "pl" ? Agt() : t === "ru" ? Egt() : t === "uk" ? jgt() : Lgt()
  },
  Rgt = () => "Goldenrod",
  Bgt = () => "Vara-de-ouro",
  Fgt = () => "ç§‹éº’éºŸè‰",
  Ogt = () => "Goldrute",
  qgt = () => "vara de oro",
  Ngt = () => "Verge d'or",
  Vgt = () => "Verga d'oro",
  Ugt = () => "ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ãƒ­ãƒƒãƒ‰",
  Zgt = () => "NawÅ‚oÄ‡",
  Ggt = () => "Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ°Ñ€Ğ½Ğ¸Ğº",
  Hgt = () => "Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ°Ñ€Ğ½Ğ¸Ğº",
  Wgt = () => "Hoa HoÃ ng Anh",
  $gt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Rgt() : t === "pt" ? Bgt() : t === "ch" ? Fgt() : t === "de" ? Ogt() : t === "es" ? qgt() : t === "fr" ? Ngt() : t === "it" ? Vgt() : t === "jp" ? Ugt() : t === "pl" ? Zgt() : t === "ru" ? Ggt() : t === "uk" ? Hgt() : Wgt()
  },
  Xgt = () => "Light Goldenrod",
  Ygt = () => "Dourado Claro",
  Kgt = () => "æµ…é‡‘èŠè‰²",
  Jgt = () => "Helles Goldrutengelb",
  Qgt = () => "Amarillo mimosa claro",
  tyt = () => "Jaune verge d'or clair",
  eyt = () => "Giallo verga d'oro chiaro",
  ryt = () => "ãƒ©ã‚¤ãƒˆã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ãƒ­ãƒƒãƒ‰",
  nyt = () => "Jasny ZÅ‚ocisty",
  iyt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ·Ğ¾Ğ»Ğ¾Ñ‚Ğ¸ÑÑ‚Ñ‹Ğ¹",
  oyt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ·Ğ¾Ğ»Ğ¾Ñ‚Ğ¸ÑÑ‚Ğ¸Ğ¹",
  syt = () => "VÃ ng kim nháº¡t",
  ayt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Xgt() : t === "pt" ? Ygt() : t === "ch" ? Kgt() : t === "de" ? Jgt() : t === "es" ? Qgt() : t === "fr" ? tyt() : t === "it" ? eyt() : t === "jp" ? ryt() : t === "pl" ? nyt() : t === "ru" ? iyt() : t === "uk" ? oyt() : syt()
  },
  uyt = () => "Dark Olive",
  cyt = () => "Verde Oliva Escuro",
  lyt = () => "æ·±æ©„æ¦„",
  _yt = () => "Dunkelolive",
  hyt = () => "Verde oliva oscuro",
  dyt = () => "Olive foncÃ©e",
  pyt = () => "Verde oliva scuro",
  fyt = () => "ãƒ€ãƒ¼ã‚¯ã‚ªãƒªãƒ¼ãƒ–",
  myt = () => "Ciemna Oliwka",
  gyt = () => "Ğ¢ĞµĞ¼Ğ½Ñ‹Ğ¹ Ğ¾Ğ»Ğ¸Ğ²ĞºĞ¾Ğ²Ñ‹Ğ¹",
  yyt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ Ğ¾Ğ»Ğ¸Ğ²ĞºĞ¾Ğ²Ğ¸Ğ¹",
  vyt = () => "Xanh Ã´ liu Ä‘áº­m",
  byt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? uyt() : t === "pt" ? cyt() : t === "ch" ? lyt() : t === "de" ? _yt() : t === "es" ? hyt() : t === "fr" ? dyt() : t === "it" ? pyt() : t === "jp" ? fyt() : t === "pl" ? myt() : t === "ru" ? gyt() : t === "uk" ? yyt() : vyt()
  },
  xyt = () => "Olive",
  wyt = () => "Azeitona",
  kyt = () => "æ©„æ¦„",
  Tyt = () => "Olive",
  Syt = () => "Aceituna",
  Pyt = () => "Olive",
  Myt = () => "Oliva",
  Cyt = () => "ã‚ªãƒªãƒ¼ãƒ–",
  Iyt = () => "Oliwka",
  zyt = () => "ĞĞ»Ğ¸Ğ²Ğ°",
  Ayt = () => "ĞĞ»Ğ¸Ğ²ĞºĞ°",
  Eyt = () => "Ã” liu",
  jyt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xyt() : t === "pt" ? wyt() : t === "ch" ? kyt() : t === "de" ? Tyt() : t === "es" ? Syt() : t === "fr" ? Pyt() : t === "it" ? Myt() : t === "jp" ? Cyt() : t === "pl" ? Iyt() : t === "ru" ? zyt() : t === "uk" ? Ayt() : Eyt()
  },
  Lyt = () => "Light Olive",
  Dyt = () => "Oliva Clara",
  Ryt = () => "æµ…æ©„æ¦„è‰²",
  Byt = () => "Helle Olive",
  Fyt = () => "Oliva claro",
  Oyt = () => "Olive claire",
  qyt = () => "Oliva chiara",
  Nyt = () => "ãƒ©ã‚¤ãƒˆã‚ªãƒªãƒ¼ãƒ–",
  Vyt = () => "Jasny oliwkowy",
  Uyt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ¾Ğ»Ğ¸Ğ²ĞºĞ¾Ğ²Ñ‹Ğ¹",
  Zyt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¸Ğ¹ Ğ¾Ğ»Ğ¸Ğ²ĞºĞ¾Ğ²Ğ¸Ğ¹",
  Gyt = () => "Ã” liu nháº¡t",
  Hyt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Lyt() : t === "pt" ? Dyt() : t === "ch" ? Ryt() : t === "de" ? Byt() : t === "es" ? Fyt() : t === "fr" ? Oyt() : t === "it" ? qyt() : t === "jp" ? Nyt() : t === "pl" ? Vyt() : t === "ru" ? Uyt() : t === "uk" ? Zyt() : Gyt()
  },
  Wyt = () => "Dark Cyan",
  $yt = () => "Ciano Escuro",
  Xyt = () => "æ·±é’è‰²",
  Yyt = () => "Dunkelcyan",
  Kyt = () => "Cian Oscuro",
  Jyt = () => "Cyan foncÃ©",
  Qyt = () => "Ciano Scuro",
  tvt = () => "ãƒ€ãƒ¼ã‚¯ã‚·ã‚¢ãƒ³",
  evt = () => "Ciemny Cyjan",
  rvt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ±Ğ¸Ñ€ÑĞ·Ğ¾Ğ²Ñ‹Ğ¹",
  nvt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-Ğ±Ñ–Ñ€ÑĞ·Ğ¾Ğ²Ğ¸Ğ¹",
  ivt = () => "Xanh lam Ä‘áº­m",
  ovt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Wyt() : t === "pt" ? $yt() : t === "ch" ? Xyt() : t === "de" ? Yyt() : t === "es" ? Kyt() : t === "fr" ? Jyt() : t === "it" ? Qyt() : t === "jp" ? tvt() : t === "pl" ? evt() : t === "ru" ? rvt() : t === "uk" ? nvt() : ivt()
  },
  svt = () => "Light Cyan",
  avt = () => "Ciano Claro",
  uvt = () => "æµ…é’è‰²",
  cvt = () => "Hellcyan",
  lvt = () => "Cian claro",
  _vt = () => "Cyan clair",
  hvt = () => "Ciano chiaro",
  dvt = () => "ãƒ©ã‚¤ãƒˆã‚·ã‚¢ãƒ³",
  pvt = () => "Jasny Cyjan",
  fvt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ³Ğ¾Ğ»ÑƒĞ±Ğ¾Ğ¹",
  mvt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ±Ğ»Ğ°ĞºĞ¸Ñ‚Ğ½Ğ¸Ğ¹",
  gvt = () => "Xanh lÆ¡ nháº¡t",
  yvt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? svt() : t === "pt" ? avt() : t === "ch" ? uvt() : t === "de" ? cvt() : t === "es" ? lvt() : t === "fr" ? _vt() : t === "it" ? hvt() : t === "jp" ? dvt() : t === "pl" ? pvt() : t === "ru" ? fvt() : t === "uk" ? mvt() : gvt()
  },
  vvt = () => "Light Blue",
  bvt = () => "Azul Claro",
  xvt = () => "æµ…è“è‰²",
  wvt = () => "Hellblau",
  kvt = () => "Azul Claro",
  Tvt = () => "Bleu clair",
  Svt = () => "Azzurro",
  Pvt = () => "æ°´è‰²",
  Mvt = () => "Jasnoniebieski",
  Cvt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ³Ğ¾Ğ»ÑƒĞ±Ğ¾Ğ¹",
  Ivt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ±Ğ»Ğ°ĞºĞ¸Ñ‚Ğ½Ğ¸Ğ¹",
  zvt = () => "Xanh nháº¡t",
  Avt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vvt() : t === "pt" ? bvt() : t === "ch" ? xvt() : t === "de" ? wvt() : t === "es" ? kvt() : t === "fr" ? Tvt() : t === "it" ? Svt() : t === "jp" ? Pvt() : t === "pl" ? Mvt() : t === "ru" ? Cvt() : t === "uk" ? Ivt() : zvt()
  },
  Evt = () => "Dark Indigo",
  jvt = () => "Ãndigo Escuro",
  Lvt = () => "æ·±é›è‰²",
  Dvt = () => "Dunkelindigo",
  Rvt = () => "Ãndigo oscuro",
  Bvt = () => "Indigo foncÃ©",
  Fvt = () => "Indaco Scuro",
  Ovt = () => "ãƒ€ãƒ¼ã‚¯ã‚¤ãƒ³ãƒ‡ã‚£ã‚´",
  qvt = () => "Ciemne Indygo",
  Nvt = () => "Ğ¢ĞµĞ¼Ğ½Ñ‹Ğ¹ Ğ˜Ğ½Ğ´Ğ¸Ğ³Ğ¾",
  Vvt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ Ñ–Ğ½Ğ´Ğ¸Ğ³Ğ¾",
  Uvt = () => "ChÃ m Ä‘áº­m",
  Zvt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Evt() : t === "pt" ? jvt() : t === "ch" ? Lvt() : t === "de" ? Dvt() : t === "es" ? Rvt() : t === "fr" ? Bvt() : t === "it" ? Fvt() : t === "jp" ? Ovt() : t === "pl" ? qvt() : t === "ru" ? Nvt() : t === "uk" ? Vvt() : Uvt()
  },
  Gvt = () => "Dark Slate Blue",
  Hvt = () => "Azul ArdÃ³sia Escuro",
  Wvt = () => "æ·±çŸ³æ¿è“",
  $vt = () => "Dunkles Schieferblau",
  Xvt = () => "Azul Pizarra Oscuro",
  Yvt = () => "Bleu Ardoise FoncÃ©",
  Kvt = () => "Blu Ardesia Scuro",
  Jvt = () => "ãƒ€ãƒ¼ã‚¯ã‚¹ãƒ¬ãƒ¼ãƒˆãƒ–ãƒ«ãƒ¼",
  Qvt = () => "Ciemny Å‚upkowy bÅ‚Ä™kit",
  t0t = () => "Ğ¢ĞµĞ¼Ğ½Ğ¾-ÑĞ»Ğ°Ğ½Ñ†ĞµĞ²Ñ‹Ğ¹ ÑĞ¸Ğ½Ğ¸Ğ¹",
  e0t = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ Ğ³Ñ€Ğ¸Ñ„ĞµĞ»ÑŒĞ½Ğ¾-ÑĞ¸Ğ½Ñ–Ğ¹",
  r0t = () => "Xanh lam Ä‘Ã¡ phiáº¿n Ä‘áº­m",
  n0t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Gvt() : t === "pt" ? Hvt() : t === "ch" ? Wvt() : t === "de" ? $vt() : t === "es" ? Xvt() : t === "fr" ? Yvt() : t === "it" ? Kvt() : t === "jp" ? Jvt() : t === "pl" ? Qvt() : t === "ru" ? t0t() : t === "uk" ? e0t() : r0t()
  },
  i0t = () => "Slate Blue",
  o0t = () => "Azul ArdÃ³sia",
  s0t = () => "çŸ³æ¿è“",
  a0t = () => "Schieferblau",
  u0t = () => "Azul pizarra",
  c0t = () => "Bleu ardoise",
  l0t = () => "Blu ardesia",
  _0t = () => "ã‚¹ãƒ¬ãƒ¼ãƒˆãƒ–ãƒ«ãƒ¼",
  h0t = () => "Niebiesko-szary",
  d0t = () => "Ğ¡Ğ»Ğ°Ğ½Ñ†ĞµĞ²Ğ¾-ÑĞ¸Ğ½Ğ¸Ğ¹",
  p0t = () => "Ğ“Ñ€Ğ¸Ñ„ĞµĞ»ÑŒĞ½Ğ¾-ÑĞ¸Ğ½Ñ–Ğ¹",
  f0t = () => "Xanh lam Ä‘Ã¡ phiáº¿n",
  m0t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? i0t() : t === "pt" ? o0t() : t === "ch" ? s0t() : t === "de" ? a0t() : t === "es" ? u0t() : t === "fr" ? c0t() : t === "it" ? l0t() : t === "jp" ? _0t() : t === "pl" ? h0t() : t === "ru" ? d0t() : t === "uk" ? p0t() : f0t()
  },
  g0t = () => "Light Slate Blue",
  y0t = () => "Azul ArdÃ³sia Claro",
  v0t = () => "æµ…æ¿å²©è“",
  b0t = () => "Hellschieferblau",
  x0t = () => "Azul Pizarra Claro",
  w0t = () => "Bleu ardoise clair",
  k0t = () => "Blu Ardesia Chiaro",
  T0t = () => "ãƒ©ã‚¤ãƒˆã‚¹ãƒ¬ãƒ¼ãƒˆãƒ–ãƒ«ãƒ¼",
  S0t = () => "Jasny bÅ‚Ä™kit Å‚upkowy",
  P0t = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ñ‹Ğ¹ ÑˆĞ¸Ñ„ĞµÑ€Ğ½Ğ¾-ÑĞ¸Ğ½Ğ¸Ğ¹",
  M0t = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¸Ğ¹ Ğ³Ñ€Ğ¸Ñ„ĞµĞ»ÑŒĞ½Ğ¾-ÑĞ¸Ğ½Ñ–Ğ¹",
  C0t = () => "Xanh Ä‘Ã¡ phiáº¿n nháº¡t",
  I0t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? g0t() : t === "pt" ? y0t() : t === "ch" ? v0t() : t === "de" ? b0t() : t === "es" ? x0t() : t === "fr" ? w0t() : t === "it" ? k0t() : t === "jp" ? T0t() : t === "pl" ? S0t() : t === "ru" ? P0t() : t === "uk" ? M0t() : C0t()
  },
  z0t = () => "Light Brown",
  A0t = () => "Castanho Claro",
  E0t = () => "æµ…æ£•è‰²",
  j0t = () => "Hellbraun",
  L0t = () => "MarrÃ³n claro",
  D0t = () => "Marron clair",
  R0t = () => "Marrone Chiaro",
  B0t = () => "è–„èŒ¶è‰²",
  F0t = () => "JasnobrÄ…zowy",
  O0t = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-ĞºĞ¾Ñ€Ğ¸Ñ‡Ğ½ĞµĞ²Ñ‹Ğ¹",
  q0t = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-ĞºĞ¾Ñ€Ğ¸Ñ‡Ğ½ĞµĞ²Ğ¸Ğ¹",
  N0t = () => "NÃ¢u nháº¡t",
  V0t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? z0t() : t === "pt" ? A0t() : t === "ch" ? E0t() : t === "de" ? j0t() : t === "es" ? L0t() : t === "fr" ? D0t() : t === "it" ? R0t() : t === "jp" ? B0t() : t === "pl" ? F0t() : t === "ru" ? O0t() : t === "uk" ? q0t() : N0t()
  },
  U0t = () => "Dark Beige",
  Z0t = () => "Bege Escuro",
  G0t = () => "æ·±ç±³è‰²",
  H0t = () => "Dunkelbeige",
  W0t = () => "Beige Oscuro",
  $0t = () => "Beige foncÃ©",
  X0t = () => "Beige Scuro",
  Y0t = () => "æ¿ƒã„ãƒ™ãƒ¼ã‚¸ãƒ¥",
  K0t = () => "Ciemny BeÅ¼owy",
  J0t = () => "Ğ¢ĞµĞ¼Ğ½Ñ‹Ğ¹ Ğ±ĞµĞ¶ĞµĞ²Ñ‹Ğ¹",
  Q0t = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ Ğ±ĞµĞ¶ĞµĞ²Ğ¸Ğ¹",
  tbt = () => "MÃ u be Ä‘áº­m",
  ebt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? U0t() : t === "pt" ? Z0t() : t === "ch" ? G0t() : t === "de" ? H0t() : t === "es" ? W0t() : t === "fr" ? $0t() : t === "it" ? X0t() : t === "jp" ? Y0t() : t === "pl" ? K0t() : t === "ru" ? J0t() : t === "uk" ? Q0t() : tbt()
  },
  rbt = () => "Light Beige",
  nbt = () => "Bege Claro",
  ibt = () => "æµ…ç±³è‰²",
  obt = () => "Hellbeige",
  sbt = () => "Beige claro",
  abt = () => "Beige clair",
  ubt = () => "Beige chiaro",
  cbt = () => "ãƒ©ã‚¤ãƒˆãƒ™ãƒ¼ã‚¸ãƒ¥",
  lbt = () => "Jasny BeÅ¼",
  _bt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ğ¾-Ğ±ĞµĞ¶ĞµĞ²Ñ‹Ğ¹",
  hbt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¾-Ğ±ĞµĞ¶ĞµĞ²Ğ¸Ğ¹",
  dbt = () => "Be nháº¡t",
  pbt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rbt() : t === "pt" ? nbt() : t === "ch" ? ibt() : t === "de" ? obt() : t === "es" ? sbt() : t === "fr" ? abt() : t === "it" ? ubt() : t === "jp" ? cbt() : t === "pl" ? lbt() : t === "ru" ? _bt() : t === "uk" ? hbt() : dbt()
  },
  fbt = () => "Dark Peach",
  mbt = () => "PÃªssego Escuro",
  gbt = () => "æ·±æ¡ƒè‰²",
  ybt = () => "Dunkler Pfirsich",
  vbt = () => "MelocotÃ³n oscuro",
  bbt = () => "PÃªche FoncÃ©",
  xbt = () => "Pesca Scura",
  wbt = () => "ãƒ€ãƒ¼ã‚¯ãƒ”ãƒ¼ãƒ",
  kbt = () => "Ciemna Brzoskwinia",
  Tbt = () => "Ğ¢ĞµĞ¼Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ÑĞ¸Ğº",
  Sbt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ Ğ¿ĞµÑ€ÑĞ¸Ğº",
  Pbt = () => "ÄÃ o Äáº­m",
  Mbt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? fbt() : t === "pt" ? mbt() : t === "ch" ? gbt() : t === "de" ? ybt() : t === "es" ? vbt() : t === "fr" ? bbt() : t === "it" ? xbt() : t === "jp" ? wbt() : t === "pl" ? kbt() : t === "ru" ? Tbt() : t === "uk" ? Sbt() : Pbt()
  },
  Cbt = () => "Peach",
  Ibt = () => "PÃªssego",
  zbt = () => "æ¡ƒå­",
  Abt = () => "Pfirsich",
  Ebt = () => "MelocotÃ³n",
  jbt = () => "PÃªche",
  Lbt = () => "Pesca",
  Dbt = () => "æ¡ƒ",
  Rbt = () => "Brzoskwinia",
  Bbt = () => "ĞŸĞµÑ€ÑĞ¸Ğº",
  Fbt = () => "ĞŸĞµÑ€ÑĞ¸Ğº",
  Obt = () => "ÄÃ o",
  qbt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Cbt() : t === "pt" ? Ibt() : t === "ch" ? zbt() : t === "de" ? Abt() : t === "es" ? Ebt() : t === "fr" ? jbt() : t === "it" ? Lbt() : t === "jp" ? Dbt() : t === "pl" ? Rbt() : t === "ru" ? Bbt() : t === "uk" ? Fbt() : Obt()
  },
  Nbt = () => "Light Peach",
  Vbt = () => "PÃªssego Claro",
  Ubt = () => "æµ…æ¡ƒè‰²",
  Zbt = () => "Heller Pfirsich",
  Gbt = () => "MelocotÃ³n claro",
  Hbt = () => "PÃªche Claire",
  Wbt = () => "Pesca Chiara",
  $bt = () => "ãƒ©ã‚¤ãƒˆãƒ”ãƒ¼ãƒ",
  Xbt = () => "Jasna Brzoskwinia",
  Ybt = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ñ‹Ğ¹ Ğ¿ĞµÑ€ÑĞ¸Ğº",
  Kbt = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¸Ğ¹ Ğ¿ĞµÑ€ÑĞ¸Ğº",
  Jbt = () => "ÄÃ o nháº¡t",
  Qbt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Nbt() : t === "pt" ? Vbt() : t === "ch" ? Ubt() : t === "de" ? Zbt() : t === "es" ? Gbt() : t === "fr" ? Hbt() : t === "it" ? Wbt() : t === "jp" ? $bt() : t === "pl" ? Xbt() : t === "ru" ? Ybt() : t === "uk" ? Kbt() : Jbt()
  },
  txt = () => "Dark Tan",
  ext = () => "Bronzeado Escuro",
  rxt = () => "æ·±æ£•è¤è‰²",
  nxt = () => "Dunkelbraun",
  ixt = () => "Bronceado Oscuro",
  oxt = () => "Bronzage FoncÃ©",
  sxt = () => "Abbronzatura scura",
  axt = () => "æ¿ƒã„æ—¥ç„¼ã‘è‰²",
  uxt = () => "Ciemny beÅ¼",
  cxt = () => "Ğ¢ĞµĞ¼Ğ½Ñ‹Ğ¹ Ğ·Ğ°Ğ³Ğ°Ñ€",
  lxt = () => "Ğ¢ĞµĞ¼Ğ½Ğ° Ğ·Ğ°ÑĞ¼Ğ°Ğ³Ğ°",
  _xt = () => "RÃ¡m náº¯ng Ä‘áº­m",
  hxt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? txt() : t === "pt" ? ext() : t === "ch" ? rxt() : t === "de" ? nxt() : t === "es" ? ixt() : t === "fr" ? oxt() : t === "it" ? sxt() : t === "jp" ? axt() : t === "pl" ? uxt() : t === "ru" ? cxt() : t === "uk" ? lxt() : _xt()
  },
  dxt = () => "Tan",
  pxt = () => "Bronzeado",
  fxt = () => "è°­",
  mxt = () => "Hellbraun",
  gxt = () => "Tan",
  yxt = () => "BronzÃ©",
  vxt = () => "abbronzatura",
  bxt = () => "é»„è¤è‰²",
  xxt = () => "Opalenizna",
  wxt = () => "Ğ—Ğ°Ğ³Ğ°Ñ€",
  kxt = () => "Ğ‘ĞµĞ¶ĞµĞ²Ğ¸Ğ¹",
  Txt = () => "TÃ¢n",
  Sxt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? dxt() : t === "pt" ? pxt() : t === "ch" ? fxt() : t === "de" ? mxt() : t === "es" ? gxt() : t === "fr" ? yxt() : t === "it" ? vxt() : t === "jp" ? bxt() : t === "pl" ? xxt() : t === "ru" ? wxt() : t === "uk" ? kxt() : Txt()
  },
  Pxt = () => "Dark Slate",
  Mxt = () => "ArdÃ³sia Escura",
  Cxt = () => "æ·±æ¿å²©",
  Ixt = () => "Dunkelschiefer",
  zxt = () => "Pizarra Oscura",
  Axt = () => "Ardoise foncÃ©e",
  Ext = () => "Ardesia scura",
  jxt = () => "ãƒ€ãƒ¼ã‚¯ã‚¹ãƒ¬ãƒ¼ãƒˆ",
  Lxt = () => "Ciemny Åupek",
  Dxt = () => "Ğ¢ĞµĞ¼Ğ½Ñ‹Ğ¹ ÑĞ»Ğ°Ğ½ĞµÑ†",
  Rxt = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ ÑˆĞ¸Ñ„ĞµÑ€",
  Bxt = () => "XÃ¡m Ä‘Ã¡ phiáº¿n Ä‘áº­m",
  Fxt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Pxt() : t === "pt" ? Mxt() : t === "ch" ? Cxt() : t === "de" ? Ixt() : t === "es" ? zxt() : t === "fr" ? Axt() : t === "it" ? Ext() : t === "jp" ? jxt() : t === "pl" ? Lxt() : t === "ru" ? Dxt() : t === "uk" ? Rxt() : Bxt()
  },
  Oxt = () => "Slate",
  qxt = () => "ArdÃ³sia",
  Nxt = () => "çŸ³æ¿",
  Vxt = () => "Schiefer",
  Uxt = () => "Pizarra",
  Zxt = () => "Ardoise",
  Gxt = () => "Ardesia",
  Hxt = () => "ã‚¹ãƒ¬ãƒ¼ãƒˆ",
  Wxt = () => "Åupek",
  $xt = () => "Ğ¡Ğ»Ğ°Ğ½ĞµÑ†",
  Xxt = () => "Ğ¡Ğ»Ğ°Ğ½ĞµÑ†ÑŒ",
  Yxt = () => "ÄÃ¡ phiáº¿n",
  Kxt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Oxt() : t === "pt" ? qxt() : t === "ch" ? Nxt() : t === "de" ? Vxt() : t === "es" ? Uxt() : t === "fr" ? Zxt() : t === "it" ? Gxt() : t === "jp" ? Hxt() : t === "pl" ? Wxt() : t === "ru" ? $xt() : t === "uk" ? Xxt() : Yxt()
  },
  Jxt = () => "Light Slate",
  Qxt = () => "ArdÃ³sia Clara",
  t1t = () => "æµ…é’ç°",
  e1t = () => "Helles Schiefergrau",
  r1t = () => "Pizarra Clara",
  n1t = () => "Ardoise claire",
  i1t = () => "Ardesia Chiara",
  o1t = () => "ãƒ©ã‚¤ãƒˆã‚¹ãƒ¬ãƒ¼ãƒˆ",
  s1t = () => "Jasny Åupek",
  a1t = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ñ‹Ğ¹ Ğ³Ñ€Ğ¸Ñ„ĞµĞ»ÑŒĞ½Ñ‹Ğ¹",
  u1t = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¸Ğ¹ Ğ³Ñ€Ğ¸Ñ„ĞµĞ»ÑŒĞ½Ğ¸Ğ¹",
  c1t = () => "XÃ¡m Ä‘Ã¡ nháº¡t",
  l1t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Jxt() : t === "pt" ? Qxt() : t === "ch" ? t1t() : t === "de" ? e1t() : t === "es" ? r1t() : t === "fr" ? n1t() : t === "it" ? i1t() : t === "jp" ? o1t() : t === "pl" ? s1t() : t === "ru" ? a1t() : t === "uk" ? u1t() : c1t()
  },
  _1t = () => "Dark Stone",
  h1t = () => "Pedra Escura",
  d1t = () => "é»‘çŸ³",
  p1t = () => "Dunkler Stein",
  f1t = () => "Piedra Oscura",
  m1t = () => "Pierre sombre",
  g1t = () => "Pietra Scura",
  y1t = () => "æš—é»’çŸ³",
  v1t = () => "Ciemny KamieÅ„",
  b1t = () => "Ğ¢Ñ‘Ğ¼Ğ½Ñ‹Ğ¹ ĞºĞ°Ğ¼ĞµĞ½ÑŒ",
  x1t = () => "Ğ¢ĞµĞ¼Ğ½Ğ¸Ğ¹ ĞšĞ°Ğ¼Ñ–Ğ½ÑŒ",
  w1t = () => "ÄÃ¡ tá»‘i",
  k1t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? _1t() : t === "pt" ? h1t() : t === "ch" ? d1t() : t === "de" ? p1t() : t === "es" ? f1t() : t === "fr" ? m1t() : t === "it" ? g1t() : t === "jp" ? y1t() : t === "pl" ? v1t() : t === "ru" ? b1t() : t === "uk" ? x1t() : w1t()
  },
  T1t = () => "Stone",
  S1t = () => "Pedra",
  P1t = () => "çŸ³å¤´",
  M1t = () => "Stein",
  C1t = () => "Piedra",
  I1t = () => "Pierre",
  z1t = () => "Pietra",
  A1t = () => "çŸ³",
  E1t = () => "KamieÅ„",
  j1t = () => "ĞšĞ°Ğ¼ĞµĞ½ÑŒ",
  L1t = () => "ĞšĞ°Ğ¼Ñ–Ğ½ÑŒ",
  D1t = () => "ÄÃ¡",
  R1t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? T1t() : t === "pt" ? S1t() : t === "ch" ? P1t() : t === "de" ? M1t() : t === "es" ? C1t() : t === "fr" ? I1t() : t === "it" ? z1t() : t === "jp" ? A1t() : t === "pl" ? E1t() : t === "ru" ? j1t() : t === "uk" ? L1t() : D1t()
  },
  B1t = () => "Light Stone",
  F1t = () => "Pedra Leve",
  O1t = () => "è½»çŸ³",
  q1t = () => "Heller Stein",
  N1t = () => "Piedra Clara",
  V1t = () => "Pierre lÃ©gÃ¨re",
  U1t = () => "Pietra Chiara",
  Z1t = () => "å…‰çŸ³",
  G1t = () => "Jasny KamieÅ„",
  H1t = () => "Ğ¡Ğ²ĞµÑ‚Ğ»Ñ‹Ğ¹ ĞºĞ°Ğ¼ĞµĞ½ÑŒ",
  W1t = () => "Ğ¡Ğ²Ñ–Ñ‚Ğ»Ğ¸Ğ¹ ĞºĞ°Ğ¼Ñ–Ğ½ÑŒ",
  $1t = () => "ÄÃ¡ sÃ¡ng",
  X1t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? B1t() : t === "pt" ? F1t() : t === "ch" ? O1t() : t === "de" ? q1t() : t === "es" ? N1t() : t === "fr" ? V1t() : t === "it" ? U1t() : t === "jp" ? Z1t() : t === "pl" ? G1t() : t === "ru" ? H1t() : t === "uk" ? W1t() : $1t()
  },
  Y1t = () => "Afghanistan",
  K1t = () => "AfeganistÃ£o",
  J1t = () => "é˜¿å¯Œæ±—",
  Q1t = () => "Afghanistan",
  twt = () => "AfganistÃ¡n",
  ewt = () => "Afghanistan",
  rwt = () => "Afghanistan",
  nwt = () => "ã‚¢ãƒ•ã‚¬ãƒ‹ã‚¹ã‚¿ãƒ³",
  iwt = () => "Afganistan",
  owt = () => "ĞÑ„Ğ³Ğ°Ğ½Ğ¸ÑÑ‚Ğ°Ğ½",
  swt = () => "ĞÑ„Ğ³Ğ°Ğ½Ñ–ÑÑ‚Ğ°Ğ½",
  awt = () => "Afghanistan",
  uwt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Y1t() : t === "pt" ? K1t() : t === "ch" ? J1t() : t === "de" ? Q1t() : t === "es" ? twt() : t === "fr" ? ewt() : t === "it" ? rwt() : t === "jp" ? nwt() : t === "pl" ? iwt() : t === "ru" ? owt() : t === "uk" ? swt() : awt()
  },
  cwt = () => "Albania",
  lwt = () => "AlbÃ¢nia",
  _wt = () => "é˜¿å°”å·´å°¼äºš",
  hwt = () => "Albanien",
  dwt = () => "Albania",
  pwt = () => "Albanie",
  fwt = () => "Albania",
  mwt = () => "ã‚¢ãƒ«ãƒãƒ‹ã‚¢",
  gwt = () => "Albania",
  ywt = () => "ĞĞ»Ğ±Ğ°Ğ½Ğ¸Ñ",
  vwt = () => "ĞĞ»Ğ±Ğ°Ğ½Ñ–Ñ",
  bwt = () => "Albania",
  xwt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? cwt() : t === "pt" ? lwt() : t === "ch" ? _wt() : t === "de" ? hwt() : t === "es" ? dwt() : t === "fr" ? pwt() : t === "it" ? fwt() : t === "jp" ? mwt() : t === "pl" ? gwt() : t === "ru" ? ywt() : t === "uk" ? vwt() : bwt()
  },
  wwt = () => "Algeria",
  kwt = () => "ArgÃ©lia",
  Twt = () => "é˜¿å°”åŠåˆ©äºš",
  Swt = () => "Algerien",
  Pwt = () => "Argelia",
  Mwt = () => "AlgÃ©rie",
  Cwt = () => "Algeria",
  Iwt = () => "ã‚¢ãƒ«ã‚¸ã‚§ãƒªã‚¢",
  zwt = () => "Algieria",
  Awt = () => "ĞĞ»Ğ¶Ğ¸Ñ€",
  Ewt = () => "ĞĞ»Ğ¶Ğ¸Ñ€",
  jwt = () => "Algeria",
  Lwt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? wwt() : t === "pt" ? kwt() : t === "ch" ? Twt() : t === "de" ? Swt() : t === "es" ? Pwt() : t === "fr" ? Mwt() : t === "it" ? Cwt() : t === "jp" ? Iwt() : t === "pl" ? zwt() : t === "ru" ? Awt() : t === "uk" ? Ewt() : jwt()
  },
  Dwt = () => "American Samoa",
  Rwt = () => "Samoa Americana",
  Bwt = () => "ç¾å±è¨æ‘©äºš",
  Fwt = () => "Amerikanisch-Samoa",
  Owt = () => "Samoa Americana",
  qwt = () => "Samoa amÃ©ricaines",
  Nwt = () => "Samoa Americane",
  Vwt = () => "ã‚¢ãƒ¡ãƒªã‚«é ˜ã‚µãƒ¢ã‚¢",
  Uwt = () => "Samoa AmerykaÅ„skie",
  Zwt = () => "ĞĞ¼ĞµÑ€Ğ¸ĞºĞ°Ğ½ÑĞºĞ¾Ğµ Ğ¡Ğ°Ğ¼Ğ¾Ğ°",
  Gwt = () => "ĞĞ¼ĞµÑ€Ğ¸ĞºĞ°Ğ½ÑÑŒĞºĞµ Ğ¡Ğ°Ğ¼Ğ¾Ğ°",
  Hwt = () => "Samoa thuá»™c Má»¹",
  Wwt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Dwt() : t === "pt" ? Rwt() : t === "ch" ? Bwt() : t === "de" ? Fwt() : t === "es" ? Owt() : t === "fr" ? qwt() : t === "it" ? Nwt() : t === "jp" ? Vwt() : t === "pl" ? Uwt() : t === "ru" ? Zwt() : t === "uk" ? Gwt() : Hwt()
  },
  $wt = () => "Andorra",
  Xwt = () => "Andorra",
  Ywt = () => "å®‰é“å°”",
  Kwt = () => "Andorra",
  Jwt = () => "Andorra",
  Qwt = () => "Andorre",
  t2t = () => "Andorra",
  e2t = () => "ã‚¢ãƒ³ãƒ‰ãƒ©",
  r2t = () => "Andora",
  n2t = () => "ĞĞ½Ğ´Ğ¾Ñ€Ñ€Ğ°",
  i2t = () => "ĞĞ½Ğ´Ğ¾Ñ€Ñ€Ğ°",
  o2t = () => "Andorra",
  s2t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $wt() : t === "pt" ? Xwt() : t === "ch" ? Ywt() : t === "de" ? Kwt() : t === "es" ? Jwt() : t === "fr" ? Qwt() : t === "it" ? t2t() : t === "jp" ? e2t() : t === "pl" ? r2t() : t === "ru" ? n2t() : t === "uk" ? i2t() : o2t()
  },
  a2t = () => "Angola",
  u2t = () => "Angola",
  c2t = () => "å®‰å“¥æ‹‰",
  l2t = () => "Angola",
  _2t = () => "Angola",
  h2t = () => "Angola",
  d2t = () => "Angola",
  p2t = () => "ã‚¢ãƒ³ã‚´ãƒ©",
  f2t = () => "Angola",
  m2t = () => "ĞĞ½Ğ³Ğ¾Ğ»Ğ°",
  g2t = () => "ĞĞ½Ğ³Ğ¾Ğ»Ğ°",
  y2t = () => "Angola",
  v2t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? a2t() : t === "pt" ? u2t() : t === "ch" ? c2t() : t === "de" ? l2t() : t === "es" ? _2t() : t === "fr" ? h2t() : t === "it" ? d2t() : t === "jp" ? p2t() : t === "pl" ? f2t() : t === "ru" ? m2t() : t === "uk" ? g2t() : y2t()
  },
  b2t = () => "Anguilla",
  x2t = () => "Anguilla",
  w2t = () => "å®‰åœ­æ‹‰",
  k2t = () => "Anguilla",
  T2t = () => "Anguila",
  S2t = () => "Anguilla",
  P2t = () => "Anguilla",
  M2t = () => "ã‚¢ãƒ³ã‚®ãƒ©",
  C2t = () => "Anguilla",
  I2t = () => "ĞĞ½Ğ³Ğ¸Ğ»ÑŒÑ",
  z2t = () => "ĞĞ½Ğ³Ñ–Ğ»ÑŒÑ",
  A2t = () => "Anguilla",
  E2t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? b2t() : t === "pt" ? x2t() : t === "ch" ? w2t() : t === "de" ? k2t() : t === "es" ? T2t() : t === "fr" ? S2t() : t === "it" ? P2t() : t === "jp" ? M2t() : t === "pl" ? C2t() : t === "ru" ? I2t() : t === "uk" ? z2t() : A2t()
  },
  j2t = () => "Antarctica",
  L2t = () => "AntÃ¡rtica",
  D2t = () => "å—ææ´²",
  R2t = () => "Antarktis",
  B2t = () => "AntÃ¡rtida",
  F2t = () => "Antarctique",
  O2t = () => "Antartide",
  q2t = () => "å—æ¥µå¤§é™¸",
  N2t = () => "Antarktyda",
  V2t = () => "ĞĞ½Ñ‚Ğ°Ñ€ĞºÑ‚Ğ¸Ğ´Ğ°",
  U2t = () => "ĞĞ½Ñ‚Ğ°Ñ€ĞºÑ‚Ğ¸Ğ´Ğ°",
  Z2t = () => "Nam Cá»±c",
  G2t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? j2t() : t === "pt" ? L2t() : t === "ch" ? D2t() : t === "de" ? R2t() : t === "es" ? B2t() : t === "fr" ? F2t() : t === "it" ? O2t() : t === "jp" ? q2t() : t === "pl" ? N2t() : t === "ru" ? V2t() : t === "uk" ? U2t() : Z2t()
  },
  H2t = () => "Antigua and Barbuda",
  W2t = () => "AntÃ­gua e Barbuda",
  $2t = () => "å®‰æç“œå’Œå·´å¸ƒè¾¾",
  X2t = () => "Antigua und Barbuda",
  Y2t = () => "Antigua y Barbuda",
  K2t = () => "Antigua-et-Barbuda",
  J2t = () => "Antigua e Barbuda",
  Q2t = () => "ã‚¢ãƒ³ãƒ†ã‚£ã‚°ã‚¢ãƒ»ãƒãƒ¼ãƒ–ãƒ¼ãƒ€",
  tkt = () => "Antigua i Barbuda",
  ekt = () => "ĞĞ½Ñ‚Ğ¸Ğ³ÑƒĞ° Ğ¸ Ğ‘Ğ°Ñ€Ğ±ÑƒĞ´Ğ°",
  rkt = () => "ĞĞ½Ñ‚Ğ¸Ğ³ÑƒĞ° Ñ– Ğ‘Ğ°Ñ€Ğ±ÑƒĞ´Ğ°",
  nkt = () => "Antigua vÃ  Barbuda",
  ikt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? H2t() : t === "pt" ? W2t() : t === "ch" ? $2t() : t === "de" ? X2t() : t === "es" ? Y2t() : t === "fr" ? K2t() : t === "it" ? J2t() : t === "jp" ? Q2t() : t === "pl" ? tkt() : t === "ru" ? ekt() : t === "uk" ? rkt() : nkt()
  },
  okt = () => "Argentina",
  skt = () => "Argentina",
  akt = () => "é˜¿æ ¹å»·",
  ukt = () => "Argentinien",
  ckt = () => "Argentina",
  lkt = () => "Argentine",
  _kt = () => "Argentina",
  hkt = () => "ã‚¢ãƒ«ã‚¼ãƒ³ãƒãƒ³",
  dkt = () => "Argentyna",
  pkt = () => "ĞÑ€Ğ³ĞµĞ½Ñ‚Ğ¸Ğ½Ğ°",
  fkt = () => "ĞÑ€Ğ³ĞµĞ½Ñ‚Ğ¸Ğ½Ğ°",
  mkt = () => "Argentina",
  gkt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? okt() : t === "pt" ? skt() : t === "ch" ? akt() : t === "de" ? ukt() : t === "es" ? ckt() : t === "fr" ? lkt() : t === "it" ? _kt() : t === "jp" ? hkt() : t === "pl" ? dkt() : t === "ru" ? pkt() : t === "uk" ? fkt() : mkt()
  },
  ykt = () => "Armenia",
  vkt = () => "ArmÃªnia",
  bkt = () => "äºšç¾å°¼äºš",
  xkt = () => "Armenien",
  wkt = () => "Armenia",
  kkt = () => "ArmÃ©nie",
  Tkt = () => "Armenia",
  Skt = () => "ã‚¢ãƒ«ãƒ¡ãƒ‹ã‚¢",
  Pkt = () => "Armenia",
  Mkt = () => "ĞÑ€Ğ¼ĞµĞ½Ğ¸Ñ",
  Ckt = () => "Ğ’Ñ–Ñ€Ğ¼ĞµĞ½Ñ–Ñ",
  Ikt = () => "Armenia",
  zkt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ykt() : t === "pt" ? vkt() : t === "ch" ? bkt() : t === "de" ? xkt() : t === "es" ? wkt() : t === "fr" ? kkt() : t === "it" ? Tkt() : t === "jp" ? Skt() : t === "pl" ? Pkt() : t === "ru" ? Mkt() : t === "uk" ? Ckt() : Ikt()
  },
  Akt = () => "Aruba",
  Ekt = () => "Aruba",
  jkt = () => "é˜¿é²å·´",
  Lkt = () => "Aruba",
  Dkt = () => "Aruba",
  Rkt = () => "Aruba",
  Bkt = () => "Aruba",
  Fkt = () => "ã‚¢ãƒ«ãƒ",
  Okt = () => "Aruba",
  qkt = () => "ĞÑ€ÑƒĞ±Ğ°",
  Nkt = () => "ĞÑ€ÑƒĞ±Ğ°",
  Vkt = () => "Aruba",
  Ukt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Akt() : t === "pt" ? Ekt() : t === "ch" ? jkt() : t === "de" ? Lkt() : t === "es" ? Dkt() : t === "fr" ? Rkt() : t === "it" ? Bkt() : t === "jp" ? Fkt() : t === "pl" ? Okt() : t === "ru" ? qkt() : t === "uk" ? Nkt() : Vkt()
  },
  Zkt = () => "Australia",
  Gkt = () => "AustrÃ¡lia",
  Hkt = () => "æ¾³å¤§åˆ©äºš",
  Wkt = () => "Australien",
  $kt = () => "Australia",
  Xkt = () => "Australie",
  Ykt = () => "Australia",
  Kkt = () => "ã‚ªãƒ¼ã‚¹ãƒˆãƒ©ãƒªã‚¢",
  Jkt = () => "Australia",
  Qkt = () => "ĞĞ²ÑÑ‚Ñ€Ğ°Ğ»Ğ¸Ñ",
  t5t = () => "ĞĞ²ÑÑ‚Ñ€Ğ°Ğ»Ñ–Ñ",
  e5t = () => "Ãšc",
  r5t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Zkt() : t === "pt" ? Gkt() : t === "ch" ? Hkt() : t === "de" ? Wkt() : t === "es" ? $kt() : t === "fr" ? Xkt() : t === "it" ? Ykt() : t === "jp" ? Kkt() : t === "pl" ? Jkt() : t === "ru" ? Qkt() : t === "uk" ? t5t() : e5t()
  },
  n5t = () => "Austria",
  i5t = () => "Ãustria",
  o5t = () => "å¥¥åœ°åˆ©",
  s5t = () => "Ã–sterreich",
  a5t = () => "Austria",
  u5t = () => "Autriche",
  c5t = () => "Austria",
  l5t = () => "ã‚ªãƒ¼ã‚¹ãƒˆãƒªã‚¢",
  _5t = () => "Austria",
  h5t = () => "ĞĞ²ÑÑ‚Ñ€Ğ¸Ñ",
  d5t = () => "ĞĞ²ÑÑ‚Ñ€Ñ–Ñ",
  p5t = () => "Ão",
  f5t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? n5t() : t === "pt" ? i5t() : t === "ch" ? o5t() : t === "de" ? s5t() : t === "es" ? a5t() : t === "fr" ? u5t() : t === "it" ? c5t() : t === "jp" ? l5t() : t === "pl" ? _5t() : t === "ru" ? h5t() : t === "uk" ? d5t() : p5t()
  },
  m5t = () => "Azerbaijan",
  g5t = () => "AzerbaijÃ£o",
  y5t = () => "é˜¿å¡æ‹œç–†",
  v5t = () => "Aserbaidschan",
  b5t = () => "AzerbaiyÃ¡n",
  x5t = () => "AzerbaÃ¯djan",
  w5t = () => "Azerbaigian",
  k5t = () => "ã‚¢ã‚¼ãƒ«ãƒã‚¤ã‚¸ãƒ£ãƒ³",
  T5t = () => "AzerbejdÅ¼an",
  S5t = () => "ĞĞ·ĞµÑ€Ğ±Ğ°Ğ¹Ğ´Ğ¶Ğ°Ğ½",
  P5t = () => "ĞĞ·ĞµÑ€Ğ±Ğ°Ğ¹Ğ´Ğ¶Ğ°Ğ½",
  M5t = () => "Azerbaijan",
  C5t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? m5t() : t === "pt" ? g5t() : t === "ch" ? y5t() : t === "de" ? v5t() : t === "es" ? b5t() : t === "fr" ? x5t() : t === "it" ? w5t() : t === "jp" ? k5t() : t === "pl" ? T5t() : t === "ru" ? S5t() : t === "uk" ? P5t() : M5t()
  },
  I5t = () => "Bahamas",
  z5t = () => "Bahamas",
  A5t = () => "å·´å“ˆé©¬",
  E5t = () => "Bahamas",
  j5t = () => "Bahamas",
  L5t = () => "Bahamas",
  D5t = () => "Bahamas",
  R5t = () => "ãƒãƒãƒ",
  B5t = () => "Bahamy",
  F5t = () => "Ğ‘Ğ°Ğ³Ğ°Ğ¼Ñ‹",
  O5t = () => "Ğ‘Ğ°Ğ³Ğ°Ğ¼Ğ¸",
  q5t = () => "Bahamas",
  N5t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? I5t() : t === "pt" ? z5t() : t === "ch" ? A5t() : t === "de" ? E5t() : t === "es" ? j5t() : t === "fr" ? L5t() : t === "it" ? D5t() : t === "jp" ? R5t() : t === "pl" ? B5t() : t === "ru" ? F5t() : t === "uk" ? O5t() : q5t()
  },
  V5t = () => "Bahrain",
  U5t = () => "Bahrein",
  Z5t = () => "å·´æ—",
  G5t = () => "Bahrain",
  H5t = () => "BarÃ©in",
  W5t = () => "BahreÃ¯n",
  $5t = () => "Bahrain",
  X5t = () => "ãƒãƒ¼ãƒ¬ãƒ¼ãƒ³",
  Y5t = () => "Bahrajn",
  K5t = () => "Ğ‘Ğ°Ñ…Ñ€ĞµĞ¹Ğ½",
  J5t = () => "Ğ‘Ğ°Ñ…Ñ€ĞµĞ¹Ğ½",
  Q5t = () => "Bahrain",
  t3t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? V5t() : t === "pt" ? U5t() : t === "ch" ? Z5t() : t === "de" ? G5t() : t === "es" ? H5t() : t === "fr" ? W5t() : t === "it" ? $5t() : t === "jp" ? X5t() : t === "pl" ? Y5t() : t === "ru" ? K5t() : t === "uk" ? J5t() : Q5t()
  },
  e3t = () => "Bangladesh",
  r3t = () => "Bangladesh",
  n3t = () => "å­ŸåŠ æ‹‰å›½",
  i3t = () => "Bangladesch",
  o3t = () => "BangladÃ©s",
  s3t = () => "Bangladesh",
  a3t = () => "Bangladesh",
  u3t = () => "ãƒãƒ³ã‚°ãƒ©ãƒ‡ã‚·ãƒ¥",
  c3t = () => "Bangladesz",
  l3t = () => "Ğ‘Ğ°Ğ½Ğ³Ğ»Ğ°Ğ´ĞµÑˆ",
  _3t = () => "Ğ‘Ğ°Ğ½Ğ³Ğ»Ğ°Ğ´ĞµÑˆ",
  h3t = () => "Bangladesh",
  d3t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? e3t() : t === "pt" ? r3t() : t === "ch" ? n3t() : t === "de" ? i3t() : t === "es" ? o3t() : t === "fr" ? s3t() : t === "it" ? a3t() : t === "jp" ? u3t() : t === "pl" ? c3t() : t === "ru" ? l3t() : t === "uk" ? _3t() : h3t()
  },
  p3t = () => "Barbados",
  f3t = () => "Barbados",
  m3t = () => "å·´å·´å¤šæ–¯",
  g3t = () => "Barbados",
  y3t = () => "Barbados",
  v3t = () => "La Barbade",
  b3t = () => "Barbados",
  x3t = () => "ãƒãƒ«ãƒãƒ‰ã‚¹",
  w3t = () => "Barbados",
  k3t = () => "Ğ‘Ğ°Ñ€Ğ±Ğ°Ğ´Ğ¾Ñ",
  T3t = () => "Ğ‘Ğ°Ñ€Ğ±Ğ°Ğ´Ğ¾Ñ",
  S3t = () => "Barbados",
  P3t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? p3t() : t === "pt" ? f3t() : t === "ch" ? m3t() : t === "de" ? g3t() : t === "es" ? y3t() : t === "fr" ? v3t() : t === "it" ? b3t() : t === "jp" ? x3t() : t === "pl" ? w3t() : t === "ru" ? k3t() : t === "uk" ? T3t() : S3t()
  },
  M3t = () => "Belarus",
  C3t = () => "Belarus",
  I3t = () => "ç™½ä¿„ç½—æ–¯",
  z3t = () => "Belarus",
  A3t = () => "Bielorrusia",
  E3t = () => "BiÃ©lorussie",
  j3t = () => "Bielorussia",
  L3t = () => "ãƒ™ãƒ©ãƒ«ãƒ¼ã‚·",
  D3t = () => "BiaÅ‚oruÅ›",
  R3t = () => "Ğ‘ĞµĞ»Ğ°Ñ€ÑƒÑÑŒ",
  B3t = () => "Ğ‘Ñ–Ğ»Ğ¾Ñ€ÑƒÑÑŒ",
  F3t = () => "Belarus",
  O3t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? M3t() : t === "pt" ? C3t() : t === "ch" ? I3t() : t === "de" ? z3t() : t === "es" ? A3t() : t === "fr" ? E3t() : t === "it" ? j3t() : t === "jp" ? L3t() : t === "pl" ? D3t() : t === "ru" ? R3t() : t === "uk" ? B3t() : F3t()
  },
  q3t = () => "Belgium",
  N3t = () => "BÃ©lgica",
  V3t = () => "æ¯”åˆ©æ—¶",
  U3t = () => "Belgien",
  Z3t = () => "BÃ©lgica",
  G3t = () => "Belgique",
  H3t = () => "Belgio",
  W3t = () => "ãƒ™ãƒ«ã‚®ãƒ¼",
  $3t = () => "Belgia",
  X3t = () => "Ğ‘ĞµĞ»ÑŒĞ³Ğ¸Ñ",
  Y3t = () => "Ğ‘ĞµĞ»ÑŒĞ³Ñ–Ñ",
  K3t = () => "Bá»‰",
  J3t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? q3t() : t === "pt" ? N3t() : t === "ch" ? V3t() : t === "de" ? U3t() : t === "es" ? Z3t() : t === "fr" ? G3t() : t === "it" ? H3t() : t === "jp" ? W3t() : t === "pl" ? $3t() : t === "ru" ? X3t() : t === "uk" ? Y3t() : K3t()
  },
  Q3t = () => "Belize",
  tTt = () => "Belize",
  eTt = () => "ä¼¯åˆ©å…¹",
  rTt = () => "Belize",
  nTt = () => "Belice",
  iTt = () => "Belize",
  oTt = () => "Belize",
  sTt = () => "ãƒ™ãƒªãƒ¼ã‚º",
  aTt = () => "Belize",
  uTt = () => "Ğ‘ĞµĞ»Ğ¸Ğ·",
  cTt = () => "Ğ‘ĞµĞ»Ñ–Ğ·",
  lTt = () => "Belize",
  _Tt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Q3t() : t === "pt" ? tTt() : t === "ch" ? eTt() : t === "de" ? rTt() : t === "es" ? nTt() : t === "fr" ? iTt() : t === "it" ? oTt() : t === "jp" ? sTt() : t === "pl" ? aTt() : t === "ru" ? uTt() : t === "uk" ? cTt() : lTt()
  },
  hTt = () => "Benin",
  dTt = () => "Benin",
  pTt = () => "è´å®",
  fTt = () => "Benin",
  mTt = () => "BenÃ­n",
  gTt = () => "BÃ©nin",
  yTt = () => "Benin",
  vTt = () => "ãƒ™ãƒŠãƒ³",
  bTt = () => "Benin",
  xTt = () => "Ğ‘ĞµĞ½Ğ¸Ğ½",
  wTt = () => "Ğ‘ĞµĞ½Ñ–Ğ½",
  kTt = () => "BÃª-nanh",
  TTt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hTt() : t === "pt" ? dTt() : t === "ch" ? pTt() : t === "de" ? fTt() : t === "es" ? mTt() : t === "fr" ? gTt() : t === "it" ? yTt() : t === "jp" ? vTt() : t === "pl" ? bTt() : t === "ru" ? xTt() : t === "uk" ? wTt() : kTt()
  },
  STt = () => "Bermuda",
  PTt = () => "Bermuda",
  MTt = () => "ç™¾æ…•å¤§",
  CTt = () => "Bermuda",
  ITt = () => "Bermudas",
  zTt = () => "Bermudes",
  ATt = () => "Bermuda",
  ETt = () => "ãƒãƒŸãƒ¥ãƒ¼ãƒ€",
  jTt = () => "Bermudy",
  LTt = () => "Ğ‘ĞµÑ€Ğ¼ÑƒĞ´Ñ‹",
  DTt = () => "Ğ‘ĞµÑ€Ğ¼ÑƒĞ´Ğ¸",
  RTt = () => "Bermuda",
  BTt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? STt() : t === "pt" ? PTt() : t === "ch" ? MTt() : t === "de" ? CTt() : t === "es" ? ITt() : t === "fr" ? zTt() : t === "it" ? ATt() : t === "jp" ? ETt() : t === "pl" ? jTt() : t === "ru" ? LTt() : t === "uk" ? DTt() : RTt()
  },
  FTt = () => "Bhutan",
  OTt = () => "ButÃ£o",
  qTt = () => "ä¸ä¸¹",
  NTt = () => "Bhutan",
  VTt = () => "ButÃ¡n",
  UTt = () => "Bhoutan",
  ZTt = () => "Bhutan",
  GTt = () => "ãƒ–ãƒ¼ã‚¿ãƒ³",
  HTt = () => "Bhutan",
  WTt = () => "Ğ‘ÑƒÑ‚Ğ°Ğ½",
  $Tt = () => "Ğ‘ÑƒÑ‚Ğ°Ğ½",
  XTt = () => "Bhutan",
  YTt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? FTt() : t === "pt" ? OTt() : t === "ch" ? qTt() : t === "de" ? NTt() : t === "es" ? VTt() : t === "fr" ? UTt() : t === "it" ? ZTt() : t === "jp" ? GTt() : t === "pl" ? HTt() : t === "ru" ? WTt() : t === "uk" ? $Tt() : XTt()
  },
  KTt = () => "Bolivia",
  JTt = () => "BolÃ­via",
  QTt = () => "ç»åˆ©ç»´äºš",
  tSt = () => "Bolivien",
  eSt = () => "Bolivia",
  rSt = () => "Bolivie",
  nSt = () => "Bolivia",
  iSt = () => "ãƒœãƒªãƒ“ã‚¢",
  oSt = () => "Boliwia",
  sSt = () => "Ğ‘Ğ¾Ğ»Ğ¸Ğ²Ğ¸Ñ",
  aSt = () => "Ğ‘Ğ¾Ğ»Ñ–Ğ²Ñ–Ñ",
  uSt = () => "Bolivia",
  cSt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? KTt() : t === "pt" ? JTt() : t === "ch" ? QTt() : t === "de" ? tSt() : t === "es" ? eSt() : t === "fr" ? rSt() : t === "it" ? nSt() : t === "jp" ? iSt() : t === "pl" ? oSt() : t === "ru" ? sSt() : t === "uk" ? aSt() : uSt()
  },
  lSt = () => "Bonaire",
  _St = () => "Bonaire",
  hSt = () => "åšå¥ˆå°”",
  dSt = () => "Bonaire",
  pSt = () => "Bonaire",
  fSt = () => "Bonaire",
  mSt = () => "Bonaire",
  gSt = () => "ãƒœãƒãƒ¼ãƒ«",
  ySt = () => "Bonaire",
  vSt = () => "Ğ‘Ğ¾Ğ½ÑĞ¹Ñ€",
  bSt = () => "Ğ‘Ğ¾Ğ½ÑĞ¹Ñ€",
  xSt = () => "Bonaire",
  wSt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lSt() : t === "pt" ? _St() : t === "ch" ? hSt() : t === "de" ? dSt() : t === "es" ? pSt() : t === "fr" ? fSt() : t === "it" ? mSt() : t === "jp" ? gSt() : t === "pl" ? ySt() : t === "ru" ? vSt() : t === "uk" ? bSt() : xSt()
  },
  kSt = () => "Bosnia and Herzegovina",
  TSt = () => "BÃ³snia e Herzegovina",
  SSt = () => "æ³¢æ–¯å°¼äºšå’Œé»‘å¡å“¥ç»´é‚£",
  PSt = () => "Bosnien und Herzegowina",
  MSt = () => "Bosnia y Herzegovina",
  CSt = () => "Bosnie-HerzÃ©govine",
  ISt = () => "Bosnia ed Erzegovina",
  zSt = () => "ãƒœã‚¹ãƒ‹ã‚¢ãƒ»ãƒ˜ãƒ«ãƒ„ã‚§ã‚´ãƒ“ãƒŠ",
  ASt = () => "BoÅ›nia i Hercegowina",
  ESt = () => "Ğ‘Ğ¾ÑĞ½Ğ¸Ñ Ğ¸ Ğ“ĞµÑ€Ñ†ĞµĞ³Ğ¾Ğ²Ğ¸Ğ½Ğ°",
  jSt = () => "Ğ‘Ğ¾ÑĞ½Ñ–Ñ Ñ– Ğ“ĞµÑ€Ñ†ĞµĞ³Ğ¾Ğ²Ğ¸Ğ½Ğ°",
  LSt = () => "Bosna vÃ  Hercegovina",
  DSt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kSt() : t === "pt" ? TSt() : t === "ch" ? SSt() : t === "de" ? PSt() : t === "es" ? MSt() : t === "fr" ? CSt() : t === "it" ? ISt() : t === "jp" ? zSt() : t === "pl" ? ASt() : t === "ru" ? ESt() : t === "uk" ? jSt() : LSt()
  },
  RSt = () => "Botswana",
  BSt = () => "Botsuana",
  FSt = () => "åšèŒ¨ç“¦çº³",
  OSt = () => "Botswana",
  qSt = () => "Botsuana",
  NSt = () => "Botswana",
  VSt = () => "Botswana",
  USt = () => "ãƒœãƒ„ãƒ¯ãƒŠ",
  ZSt = () => "Botswana",
  GSt = () => "Ğ‘Ğ¾Ñ‚ÑĞ²Ğ°Ğ½Ğ°",
  HSt = () => "Ğ‘Ğ¾Ñ‚ÑĞ²Ğ°Ğ½Ğ°",
  WSt = () => "Botswana",
  $St = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? RSt() : t === "pt" ? BSt() : t === "ch" ? FSt() : t === "de" ? OSt() : t === "es" ? qSt() : t === "fr" ? NSt() : t === "it" ? VSt() : t === "jp" ? USt() : t === "pl" ? ZSt() : t === "ru" ? GSt() : t === "uk" ? HSt() : WSt()
  },
  XSt = () => "Bouvet Island",
  YSt = () => "Ilha Bouvet",
  KSt = () => "å¸ƒéŸ¦å²›",
  JSt = () => "Bouvetinsel",
  QSt = () => "Isla Bouvet",
  tPt = () => "Ãle Bouvet",
  ePt = () => "Isola Bouvet",
  rPt = () => "ãƒ–ãƒ¼ãƒ™å³¶",
  nPt = () => "Wyspa Bouveta",
  iPt = () => "ĞÑÑ‚Ñ€Ğ¾Ğ² Ğ‘ÑƒĞ²Ğµ",
  oPt = () => "ĞÑÑ‚Ñ€Ñ–Ğ² Ğ‘ÑƒĞ²Ğµ",
  sPt = () => "Äáº£o Bouvet",
  aPt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? XSt() : t === "pt" ? YSt() : t === "ch" ? KSt() : t === "de" ? JSt() : t === "es" ? QSt() : t === "fr" ? tPt() : t === "it" ? ePt() : t === "jp" ? rPt() : t === "pl" ? nPt() : t === "ru" ? iPt() : t === "uk" ? oPt() : sPt()
  },
  uPt = () => "Brazil",
  cPt = () => "Brasil",
  lPt = () => "å·´è¥¿",
  _Pt = () => "Brasilien",
  hPt = () => "Brasil",
  dPt = () => "BrÃ©sil",
  pPt = () => "Brasile",
  fPt = () => "ãƒ–ãƒ©ã‚¸ãƒ«",
  mPt = () => "Brazylia",
  gPt = () => "Ğ‘Ñ€Ğ°Ğ·Ğ¸Ğ»Ğ¸Ñ",
  yPt = () => "Ğ‘Ñ€Ğ°Ğ·Ğ¸Ğ»Ñ–Ñ",
  vPt = () => "Bra-xin",
  bPt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? uPt() : t === "pt" ? cPt() : t === "ch" ? lPt() : t === "de" ? _Pt() : t === "es" ? hPt() : t === "fr" ? dPt() : t === "it" ? pPt() : t === "jp" ? fPt() : t === "pl" ? mPt() : t === "ru" ? gPt() : t === "uk" ? yPt() : vPt()
  },
  xPt = () => "British Indian Ocean Territory",
  wPt = () => "TerritÃ³rio BritÃ¢nico do Oceano Ãndico",
  kPt = () => "è‹±å±å°åº¦æ´‹é¢†åœ°",
  TPt = () => "Britisches Territorium im Indischen Ozean",
  SPt = () => "Territorio BritÃ¡nico del OcÃ©ano Ãndico",
  PPt = () => "Territoire britannique de l'ocÃ©an Indien",
  MPt = () => "Territorio britannico dell'Oceano Indiano",
  CPt = () => "ã‚¤ã‚®ãƒªã‚¹é ˜ã‚¤ãƒ³ãƒ‰æ´‹åœ°åŸŸ",
  IPt = () => "Brytyjskie Terytorium Oceanu Indyjskiego",
  zPt = () => "Ğ‘Ñ€Ğ¸Ñ‚Ğ°Ğ½ÑĞºĞ°Ñ Ñ‚ĞµÑ€Ñ€Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ Ğ² Ğ˜Ğ½Ğ´Ğ¸Ğ¹ÑĞºĞ¾Ğ¼ Ğ¾ĞºĞµĞ°Ğ½Ğµ",
  APt = () => "Ğ‘Ñ€Ğ¸Ñ‚Ğ°Ğ½ÑÑŒĞºĞ° Ñ‚ĞµÑ€Ğ¸Ñ‚Ğ¾Ñ€Ñ–Ñ Ğ² Ğ†Ğ½Ğ´Ñ–Ğ¹ÑÑŒĞºĞ¾Ğ¼Ñƒ Ğ¾ĞºĞµĞ°Ğ½Ñ–",
  EPt = () => "LÃ£nh thá»• áº¤n Äá»™ DÆ°Æ¡ng thuá»™c Anh",
  jPt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xPt() : t === "pt" ? wPt() : t === "ch" ? kPt() : t === "de" ? TPt() : t === "es" ? SPt() : t === "fr" ? PPt() : t === "it" ? MPt() : t === "jp" ? CPt() : t === "pl" ? IPt() : t === "ru" ? zPt() : t === "uk" ? APt() : EPt()
  },
  LPt = () => "Brunei Darussalam",
  DPt = () => "Brunei Darussalam",
  RPt = () => "æ–‡è±è¾¾é²è¨å…°å›½",
  BPt = () => "Brunei Darussalam",
  FPt = () => "BrunÃ©i Darussalam",
  OPt = () => "BrunÃ©i Darussalam",
  qPt = () => "Brunei Darussalam",
  NPt = () => "ãƒ–ãƒ«ãƒã‚¤ãƒ»ãƒ€ãƒ«ã‚µãƒ©ãƒ¼ãƒ ",
  VPt = () => "Brunei Darussalam",
  UPt = () => "Ğ‘Ñ€ÑƒĞ½ĞµĞ¹-Ğ”Ğ°Ñ€ÑƒÑÑĞ°Ğ»Ğ°Ğ¼",
  ZPt = () => "Ğ‘Ñ€ÑƒĞ½ĞµĞ¹-Ğ”Ğ°Ñ€ÑƒÑÑĞ°Ğ»Ğ°Ğ¼",
  GPt = () => "Brunei Darussalam",
  HPt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? LPt() : t === "pt" ? DPt() : t === "ch" ? RPt() : t === "de" ? BPt() : t === "es" ? FPt() : t === "fr" ? OPt() : t === "it" ? qPt() : t === "jp" ? NPt() : t === "pl" ? VPt() : t === "ru" ? UPt() : t === "uk" ? ZPt() : GPt()
  },
  WPt = () => "Bulgaria",
  $Pt = () => "BulgÃ¡ria",
  XPt = () => "ä¿åŠ åˆ©äºš",
  YPt = () => "Bulgarien",
  KPt = () => "Bulgaria",
  JPt = () => "Bulgarie",
  QPt = () => "Bulgaria",
  tMt = () => "ãƒ–ãƒ«ã‚¬ãƒªã‚¢",
  eMt = () => "BuÅ‚garia",
  rMt = () => "Ğ‘Ğ¾Ğ»Ğ³Ğ°Ñ€Ğ¸Ñ",
  nMt = () => "Ğ‘Ğ¾Ğ»Ğ³Ğ°Ñ€Ñ–Ñ",
  iMt = () => "Bulgaria",
  oMt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? WPt() : t === "pt" ? $Pt() : t === "ch" ? XPt() : t === "de" ? YPt() : t === "es" ? KPt() : t === "fr" ? JPt() : t === "it" ? QPt() : t === "jp" ? tMt() : t === "pl" ? eMt() : t === "ru" ? rMt() : t === "uk" ? nMt() : iMt()
  },
  sMt = () => "Burkina Faso",
  aMt = () => "Burkina Faso",
  uMt = () => "å¸ƒåŸºçº³æ³•ç´¢",
  cMt = () => "Burkina Faso",
  lMt = () => "Burkina Faso",
  _Mt = () => "Burkina Faso",
  hMt = () => "Burkina Faso",
  dMt = () => "ãƒ–ãƒ«ã‚­ãƒŠãƒ•ã‚¡ã‚½",
  pMt = () => "Burkina Faso",
  fMt = () => "Ğ‘ÑƒÑ€ĞºĞ¸Ğ½Ğ°-Ğ¤Ğ°ÑĞ¾",
  mMt = () => "Ğ‘ÑƒÑ€ĞºÑ–Ğ½Ğ°-Ğ¤Ğ°ÑĞ¾",
  gMt = () => "Burkina Faso",
  yMt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? sMt() : t === "pt" ? aMt() : t === "ch" ? uMt() : t === "de" ? cMt() : t === "es" ? lMt() : t === "fr" ? _Mt() : t === "it" ? hMt() : t === "jp" ? dMt() : t === "pl" ? pMt() : t === "ru" ? fMt() : t === "uk" ? mMt() : gMt()
  },
  vMt = () => "Burundi",
  bMt = () => "Burundi",
  xMt = () => "å¸ƒéš†è¿ª",
  wMt = () => "Burundi",
  kMt = () => "Burundi",
  TMt = () => "Burundi",
  SMt = () => "Burundi",
  PMt = () => "ãƒ–ãƒ«ãƒ³ã‚¸",
  MMt = () => "Burundi",
  CMt = () => "Ğ‘ÑƒÑ€ÑƒĞ½Ğ´Ğ¸",
  IMt = () => "Ğ‘ÑƒÑ€ÑƒĞ½Ğ´Ñ–",
  zMt = () => "Burundi",
  AMt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vMt() : t === "pt" ? bMt() : t === "ch" ? xMt() : t === "de" ? wMt() : t === "es" ? kMt() : t === "fr" ? TMt() : t === "it" ? SMt() : t === "jp" ? PMt() : t === "pl" ? MMt() : t === "ru" ? CMt() : t === "uk" ? IMt() : zMt()
  },
  EMt = () => "Cabo Verde",
  jMt = () => "Cabo Verde",
  LMt = () => "ä½›å¾—è§’",
  DMt = () => "Cabo Verde",
  RMt = () => "Cabo Verde",
  BMt = () => "Cabo Verde",
  FMt = () => "Capo Verde",
  OMt = () => "ã‚«ãƒ¼ãƒœãƒ™ãƒ«ãƒ‡",
  qMt = () => "Zielony PrzylÄ…dek",
  NMt = () => "ĞšĞ°Ğ±Ğ¾-Ğ’ĞµÑ€Ğ´Ğµ",
  VMt = () => "ĞšĞ°Ğ±Ğ¾-Ğ’ĞµÑ€Ğ´Ğµ",
  UMt = () => "Cabo Verde",
  ZMt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? EMt() : t === "pt" ? jMt() : t === "ch" ? LMt() : t === "de" ? DMt() : t === "es" ? RMt() : t === "fr" ? BMt() : t === "it" ? FMt() : t === "jp" ? OMt() : t === "pl" ? qMt() : t === "ru" ? NMt() : t === "uk" ? VMt() : UMt()
  },
  GMt = () => "Cambodia",
  HMt = () => "Camboja",
  WMt = () => "æŸ¬åŸ”å¯¨",
  $Mt = () => "Kambodscha",
  XMt = () => "Camboya",
  YMt = () => "Cambodge",
  KMt = () => "Cambogia",
  JMt = () => "ã‚«ãƒ³ãƒœã‚¸ã‚¢",
  QMt = () => "KambodÅ¼a",
  tCt = () => "ĞšĞ°Ğ¼Ğ±Ğ¾Ğ´Ğ¶Ğ°",
  eCt = () => "ĞšĞ°Ğ¼Ğ±Ğ¾Ğ´Ğ¶Ğ°",
  rCt = () => "Campuchia",
  nCt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? GMt() : t === "pt" ? HMt() : t === "ch" ? WMt() : t === "de" ? $Mt() : t === "es" ? XMt() : t === "fr" ? YMt() : t === "it" ? KMt() : t === "jp" ? JMt() : t === "pl" ? QMt() : t === "ru" ? tCt() : t === "uk" ? eCt() : rCt()
  },
  iCt = () => "Cameroon",
  oCt = () => "CamarÃµes",
  sCt = () => "å–€éº¦éš†",
  aCt = () => "Kamerun",
  uCt = () => "CamerÃºn",
  cCt = () => "Cameroun",
  lCt = () => "Camerun",
  _Ct = () => "ã‚«ãƒ¡ãƒ«ãƒ¼ãƒ³",
  hCt = () => "Kamerun",
  dCt = () => "ĞšĞ°Ğ¼ĞµÑ€ÑƒĞ½",
  pCt = () => "ĞšĞ°Ğ¼ĞµÑ€ÑƒĞ½",
  fCt = () => "Cameroon",
  mCt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? iCt() : t === "pt" ? oCt() : t === "ch" ? sCt() : t === "de" ? aCt() : t === "es" ? uCt() : t === "fr" ? cCt() : t === "it" ? lCt() : t === "jp" ? _Ct() : t === "pl" ? hCt() : t === "ru" ? dCt() : t === "uk" ? pCt() : fCt()
  },
  gCt = () => "Canada",
  yCt = () => "CanadÃ¡",
  vCt = () => "åŠ æ‹¿å¤§",
  bCt = () => "Kanada",
  xCt = () => "CanadÃ¡",
  wCt = () => "Canada",
  kCt = () => "Canada",
  TCt = () => "ã‚«ãƒŠãƒ€",
  SCt = () => "Kanada",
  PCt = () => "ĞšĞ°Ğ½Ğ°Ğ´Ğ°",
  MCt = () => "ĞšĞ°Ğ½Ğ°Ğ´Ğ°",
  CCt = () => "Canada",
  ICt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? gCt() : t === "pt" ? yCt() : t === "ch" ? vCt() : t === "de" ? bCt() : t === "es" ? xCt() : t === "fr" ? wCt() : t === "it" ? kCt() : t === "jp" ? TCt() : t === "pl" ? SCt() : t === "ru" ? PCt() : t === "uk" ? MCt() : CCt()
  },
  zCt = () => "Cayman Islands",
  ACt = () => "Ilhas Cayman",
  ECt = () => "å¼€æ›¼ç¾¤å²›",
  jCt = () => "Kaimaninseln",
  LCt = () => "Islas CaimÃ¡n",
  DCt = () => "Ãles CaÃ¯mans",
  RCt = () => "Isole Cayman",
  BCt = () => "ã‚±ã‚¤ãƒãƒ³è«¸å³¶",
  FCt = () => "Kajmany",
  OCt = () => "ĞšĞ°Ğ¹Ğ¼Ğ°Ğ½Ğ¾Ğ²Ñ‹ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  qCt = () => "ĞšĞ°Ğ¹Ğ¼Ğ°Ğ½Ğ¾Ğ²Ñ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  NCt = () => "Quáº§n Ä‘áº£o Cayman",
  VCt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? zCt() : t === "pt" ? ACt() : t === "ch" ? ECt() : t === "de" ? jCt() : t === "es" ? LCt() : t === "fr" ? DCt() : t === "it" ? RCt() : t === "jp" ? BCt() : t === "pl" ? FCt() : t === "ru" ? OCt() : t === "uk" ? qCt() : NCt()
  },
  UCt = () => "Central African Republic",
  ZCt = () => "RepÃºblica Centro-Africana",
  GCt = () => "ä¸­éå…±å’Œå›½",
  HCt = () => "Zentralafrikanische Republik",
  WCt = () => "RepÃºblica Centroafricana",
  $Ct = () => "RÃ©publique centrafricaine",
  XCt = () => "Repubblica Centrafricana",
  YCt = () => "ä¸­å¤®ã‚¢ãƒ•ãƒªã‚«å…±å’Œå›½",
  KCt = () => "Republika ÅšrodkowoafrykaÅ„ska",
  JCt = () => "Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ¾Ğ°Ñ„Ñ€Ğ¸ĞºĞ°Ğ½ÑĞºĞ°Ñ Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°",
  QCt = () => "Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ¾Ğ°Ñ„Ñ€Ğ¸ĞºĞ°Ğ½ÑÑŒĞºĞ° Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ñ–ĞºĞ°",
  tIt = () => "Cá»™ng hÃ²a Trung Phi",
  eIt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? UCt() : t === "pt" ? ZCt() : t === "ch" ? GCt() : t === "de" ? HCt() : t === "es" ? WCt() : t === "fr" ? $Ct() : t === "it" ? XCt() : t === "jp" ? YCt() : t === "pl" ? KCt() : t === "ru" ? JCt() : t === "uk" ? QCt() : tIt()
  },
  rIt = () => "Chad",
  nIt = () => "Chade",
  iIt = () => "ä¹å¾—",
  oIt = () => "Tschad",
  sIt = () => "Chad",
  aIt = () => "Tchad",
  uIt = () => "Ciad",
  cIt = () => "ãƒãƒ£ãƒ‰",
  lIt = () => "Czad",
  _It = () => "Ğ§Ğ°Ğ´",
  hIt = () => "Ğ§Ğ°Ğ´",
  dIt = () => "SÃ¡t",
  pIt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rIt() : t === "pt" ? nIt() : t === "ch" ? iIt() : t === "de" ? oIt() : t === "es" ? sIt() : t === "fr" ? aIt() : t === "it" ? uIt() : t === "jp" ? cIt() : t === "pl" ? lIt() : t === "ru" ? _It() : t === "uk" ? hIt() : dIt()
  },
  fIt = () => "Chile",
  mIt = () => "Chile",
  gIt = () => "æ™ºåˆ©",
  yIt = () => "Chile",
  vIt = () => "Chile",
  bIt = () => "Chili",
  xIt = () => "Cile",
  wIt = () => "ãƒãƒª",
  kIt = () => "Chile",
  TIt = () => "Ğ§Ğ¸Ğ»Ğ¸",
  SIt = () => "Ğ§Ğ¸Ğ»Ñ–",
  PIt = () => "Chile",
  MIt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? fIt() : t === "pt" ? mIt() : t === "ch" ? gIt() : t === "de" ? yIt() : t === "es" ? vIt() : t === "fr" ? bIt() : t === "it" ? xIt() : t === "jp" ? wIt() : t === "pl" ? kIt() : t === "ru" ? TIt() : t === "uk" ? SIt() : PIt()
  },
  CIt = () => "China",
  IIt = () => "China",
  zIt = () => "ä¸­å›½",
  AIt = () => "China",
  EIt = () => "China",
  jIt = () => "Chine",
  LIt = () => "Cina",
  DIt = () => "ä¸­å›½",
  RIt = () => "Chiny",
  BIt = () => "ĞšĞ¸Ñ‚Ğ°Ğ¹",
  FIt = () => "ĞšĞ¸Ñ‚Ğ°Ğ¹",
  OIt = () => "Trung Quá»‘c",
  qIt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? CIt() : t === "pt" ? IIt() : t === "ch" ? zIt() : t === "de" ? AIt() : t === "es" ? EIt() : t === "fr" ? jIt() : t === "it" ? LIt() : t === "jp" ? DIt() : t === "pl" ? RIt() : t === "ru" ? BIt() : t === "uk" ? FIt() : OIt()
  },
  NIt = () => "Christmas Island",
  VIt = () => "Ilha do Natal",
  UIt = () => "åœ£è¯å²›",
  ZIt = () => "Weihnachtsinsel",
  GIt = () => "Isla de Navidad",
  HIt = () => "Ãle Christmas",
  WIt = () => "Isola di Natale",
  $It = () => "ã‚¯ãƒªã‚¹ãƒã‚¹å³¶",
  XIt = () => "Wyspa BoÅ¼ego Narodzenia",
  YIt = () => "ĞÑÑ‚Ñ€Ğ¾Ğ² Ğ Ğ¾Ğ¶Ğ´ĞµÑÑ‚Ğ²Ğ°",
  KIt = () => "ĞÑÑ‚Ñ€Ñ–Ğ² Ğ Ñ–Ğ·Ğ´Ğ²Ğ°",
  JIt = () => "Äáº£o GiÃ¡ng Sinh",
  QIt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? NIt() : t === "pt" ? VIt() : t === "ch" ? UIt() : t === "de" ? ZIt() : t === "es" ? GIt() : t === "fr" ? HIt() : t === "it" ? WIt() : t === "jp" ? $It() : t === "pl" ? XIt() : t === "ru" ? YIt() : t === "uk" ? KIt() : JIt()
  },
  tzt = () => "Cocos (Keeling) Islands",
  ezt = () => "Ilhas Cocos (Keeling)",
  rzt = () => "ç§‘ç§‘æ–¯ï¼ˆåŸºæ—ï¼‰ç¾¤å²›",
  nzt = () => "Kokosinseln (Keelinginseln)",
  izt = () => "Islas Cocos (Keeling)",
  ozt = () => "Ãles Cocos (Keeling)",
  szt = () => "Isole Cocos (Keeling)",
  azt = () => "ã‚³ã‚³ã‚¹è«¸å³¶ (ã‚­ãƒ¼ãƒªãƒ³ã‚°è«¸å³¶)",
  uzt = () => "Wyspy Kokosowe (Keelinga)",
  czt = () => "ĞšĞ¾ĞºĞ¾ÑĞ¾Ğ²Ñ‹Ğµ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ° (ĞšĞ¸Ğ»Ğ¸Ğ½Ğ³)",
  lzt = () => "ĞšĞ¾ĞºĞ¾ÑĞ¾Ğ²Ñ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸ (ĞšÑ–Ğ»Ñ–Ğ½Ò‘)",
  _zt = () => "Quáº§n Ä‘áº£o Cocos (Keeling)",
  hzt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? tzt() : t === "pt" ? ezt() : t === "ch" ? rzt() : t === "de" ? nzt() : t === "es" ? izt() : t === "fr" ? ozt() : t === "it" ? szt() : t === "jp" ? azt() : t === "pl" ? uzt() : t === "ru" ? czt() : t === "uk" ? lzt() : _zt()
  },
  dzt = () => "Colombia",
  pzt = () => "ColÃ´mbia",
  fzt = () => "å“¥ä¼¦æ¯”äºš",
  mzt = () => "Kolumbien",
  gzt = () => "Colombia",
  yzt = () => "Colombie",
  vzt = () => "Colombia",
  bzt = () => "ã‚³ãƒ­ãƒ³ãƒ“ã‚¢",
  xzt = () => "Kolumbia",
  wzt = () => "ĞšĞ¾Ğ»ÑƒĞ¼Ğ±Ğ¸Ñ",
  kzt = () => "ĞšĞ¾Ğ»ÑƒĞ¼Ğ±Ñ–Ñ",
  Tzt = () => "Colombia",
  Szt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? dzt() : t === "pt" ? pzt() : t === "ch" ? fzt() : t === "de" ? mzt() : t === "es" ? gzt() : t === "fr" ? yzt() : t === "it" ? vzt() : t === "jp" ? bzt() : t === "pl" ? xzt() : t === "ru" ? wzt() : t === "uk" ? kzt() : Tzt()
  },
  Pzt = () => "Comoros",
  Mzt = () => "Comores",
  Czt = () => "ç§‘æ‘©ç½—",
  Izt = () => "Komoren",
  zzt = () => "Comoras",
  Azt = () => "Comores",
  Ezt = () => "Comore",
  jzt = () => "ã‚³ãƒ¢ãƒ­",
  Lzt = () => "Komory",
  Dzt = () => "ĞšĞ¾Ğ¼Ğ¾Ñ€Ñ‹",
  Rzt = () => "ĞšĞ¾Ğ¼Ğ¾Ñ€ÑÑŒĞºÑ– ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  Bzt = () => "Comoros",
  Fzt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Pzt() : t === "pt" ? Mzt() : t === "ch" ? Czt() : t === "de" ? Izt() : t === "es" ? zzt() : t === "fr" ? Azt() : t === "it" ? Ezt() : t === "jp" ? jzt() : t === "pl" ? Lzt() : t === "ru" ? Dzt() : t === "uk" ? Rzt() : Bzt()
  },
  Ozt = () => "Congo",
  qzt = () => "Congo",
  Nzt = () => "åˆšæœ",
  Vzt = () => "Kongo",
  Uzt = () => "Congo",
  Zzt = () => "Congo",
  Gzt = () => "Congo",
  Hzt = () => "ã‚³ãƒ³ã‚´",
  Wzt = () => "Kongo",
  $zt = () => "ĞšĞ¾Ğ½Ğ³Ğ¾",
  Xzt = () => "ĞšĞ¾Ğ½Ğ³Ğ¾",
  Yzt = () => "Congo",
  Kzt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ozt() : t === "pt" ? qzt() : t === "ch" ? Nzt() : t === "de" ? Vzt() : t === "es" ? Uzt() : t === "fr" ? Zzt() : t === "it" ? Gzt() : t === "jp" ? Hzt() : t === "pl" ? Wzt() : t === "ru" ? $zt() : t === "uk" ? Xzt() : Yzt()
  },
  Jzt = () => "Cook Islands",
  Qzt = () => "Ilhas Cook",
  t4t = () => "åº“å…‹ç¾¤å²›",
  e4t = () => "Cookinseln",
  r4t = () => "Islas Cook",
  n4t = () => "Ãles Cook",
  i4t = () => "Isole Cook",
  o4t = () => "ã‚¯ãƒƒã‚¯è«¸å³¶",
  s4t = () => "Wyspy Cooka",
  a4t = () => "ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ° ĞšÑƒĞºĞ°",
  u4t = () => "ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ¸ ĞšÑƒĞºĞ°",
  c4t = () => "Quáº§n Ä‘áº£o Cook",
  l4t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Jzt() : t === "pt" ? Qzt() : t === "ch" ? t4t() : t === "de" ? e4t() : t === "es" ? r4t() : t === "fr" ? n4t() : t === "it" ? i4t() : t === "jp" ? o4t() : t === "pl" ? s4t() : t === "ru" ? a4t() : t === "uk" ? u4t() : c4t()
  },
  _4t = () => "Costa Rica",
  h4t = () => "Costa Rica",
  d4t = () => "å“¥æ–¯è¾¾é»åŠ ",
  p4t = () => "Costa Rica",
  f4t = () => "Costa Rica",
  m4t = () => "Costa Rica",
  g4t = () => "Costa Rica",
  y4t = () => "ã‚³ã‚¹ã‚¿ãƒªã‚«",
  v4t = () => "Kostaryka",
  b4t = () => "ĞšĞ¾ÑÑ‚Ğ°-Ğ Ğ¸ĞºĞ°",
  x4t = () => "ĞšĞ¾ÑÑ‚Ğ°-Ğ Ğ¸ĞºĞ°",
  w4t = () => "Costa Rica",
  k4t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? _4t() : t === "pt" ? h4t() : t === "ch" ? d4t() : t === "de" ? p4t() : t === "es" ? f4t() : t === "fr" ? m4t() : t === "it" ? g4t() : t === "jp" ? y4t() : t === "pl" ? v4t() : t === "ru" ? b4t() : t === "uk" ? x4t() : w4t()
  },
  T4t = () => "Croatia",
  S4t = () => "CroÃ¡cia",
  P4t = () => "å…‹ç½—åœ°äºš",
  M4t = () => "Kroatien",
  C4t = () => "Croacia",
  I4t = () => "Croatie",
  z4t = () => "Croazia",
  A4t = () => "ã‚¯ãƒ­ã‚¢ãƒã‚¢",
  E4t = () => "Chorwacja",
  j4t = () => "Ğ¥Ğ¾Ñ€Ğ²Ğ°Ñ‚Ğ¸Ñ",
  L4t = () => "Ğ¥Ğ¾Ñ€Ğ²Ğ°Ñ‚Ñ–Ñ",
  D4t = () => "Croatia",
  R4t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? T4t() : t === "pt" ? S4t() : t === "ch" ? P4t() : t === "de" ? M4t() : t === "es" ? C4t() : t === "fr" ? I4t() : t === "it" ? z4t() : t === "jp" ? A4t() : t === "pl" ? E4t() : t === "ru" ? j4t() : t === "uk" ? L4t() : D4t()
  },
  B4t = () => "Cuba",
  F4t = () => "Cuba",
  O4t = () => "å¤å·´",
  q4t = () => "Kuba",
  N4t = () => "Cuba",
  V4t = () => "Cuba",
  U4t = () => "Cuba",
  Z4t = () => "ã‚­ãƒ¥ãƒ¼ãƒ",
  G4t = () => "Kuba",
  H4t = () => "ĞšÑƒĞ±Ğ°",
  W4t = () => "ĞšÑƒĞ±Ğ°",
  $4t = () => "Cuba",
  X4t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? B4t() : t === "pt" ? F4t() : t === "ch" ? O4t() : t === "de" ? q4t() : t === "es" ? N4t() : t === "fr" ? V4t() : t === "it" ? U4t() : t === "jp" ? Z4t() : t === "pl" ? G4t() : t === "ru" ? H4t() : t === "uk" ? W4t() : $4t()
  },
  Y4t = () => "CuraÃ§ao",
  K4t = () => "CuraÃ§ao",
  J4t = () => "åº“æ‹‰ç´¢",
  Q4t = () => "CuraÃ§ao",
  tAt = () => "CuraÃ§ao",
  eAt = () => "CuraÃ§ao",
  rAt = () => "CuraÃ§ao",
  nAt = () => "ã‚­ãƒ¥ãƒ©ã‚½ãƒ¼",
  iAt = () => "CuraÃ§ao",
  oAt = () => "ĞšÑÑ€Ğ°ÑĞ°Ğ¾",
  sAt = () => "ĞšÑÑ€Ğ°ÑĞ°Ğ¾",
  aAt = () => "CuraÃ§ao",
  uAt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Y4t() : t === "pt" ? K4t() : t === "ch" ? J4t() : t === "de" ? Q4t() : t === "es" ? tAt() : t === "fr" ? eAt() : t === "it" ? rAt() : t === "jp" ? nAt() : t === "pl" ? iAt() : t === "ru" ? oAt() : t === "uk" ? sAt() : aAt()
  },
  cAt = () => "Cyprus",
  lAt = () => "Chipre",
  _At = () => "å¡æµ¦è·¯æ–¯",
  hAt = () => "Zypern",
  dAt = () => "Chipre",
  pAt = () => "Chypre",
  fAt = () => "Cipro",
  mAt = () => "ã‚­ãƒ—ãƒ­ã‚¹",
  gAt = () => "Cypr",
  yAt = () => "ĞšĞ¸Ğ¿Ñ€",
  vAt = () => "ĞšÑ–Ğ¿Ñ€",
  bAt = () => "SÃ­p",
  xAt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? cAt() : t === "pt" ? lAt() : t === "ch" ? _At() : t === "de" ? hAt() : t === "es" ? dAt() : t === "fr" ? pAt() : t === "it" ? fAt() : t === "jp" ? mAt() : t === "pl" ? gAt() : t === "ru" ? yAt() : t === "uk" ? vAt() : bAt()
  },
  wAt = () => "Czechia",
  kAt = () => "ChÃ©quia",
  TAt = () => "æ·å…‹",
  SAt = () => "Tschechien",
  PAt = () => "Chequia",
  MAt = () => "TchÃ©quie",
  CAt = () => "Cechia",
  IAt = () => "ãƒã‚§ã‚³",
  zAt = () => "Czechy",
  AAt = () => "Ğ§ĞµÑ…Ğ¸Ñ",
  EAt = () => "Ğ§ĞµÑ…Ñ–Ñ",
  jAt = () => "SÃ©c",
  LAt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? wAt() : t === "pt" ? kAt() : t === "ch" ? TAt() : t === "de" ? SAt() : t === "es" ? PAt() : t === "fr" ? MAt() : t === "it" ? CAt() : t === "jp" ? IAt() : t === "pl" ? zAt() : t === "ru" ? AAt() : t === "uk" ? EAt() : jAt()
  },
  DAt = () => "CÃ´te d'Ivoire",
  RAt = () => "Costa do Marfim",
  BAt = () => "ç§‘ç‰¹è¿ªç“¦",
  FAt = () => "ElfenbeinkÃ¼ste",
  OAt = () => "Costa de Marfil",
  qAt = () => "CÃ´te d'Ivoire",
  NAt = () => "Costa d'Avorio",
  VAt = () => "ã‚³ãƒ¼ãƒˆã‚¸ãƒœãƒ¯ãƒ¼ãƒ«",
  UAt = () => "WybrzeÅ¼e KoÅ›ci SÅ‚oniowej",
  ZAt = () => "ĞšĞ¾Ñ‚-Ğ´'Ğ˜Ğ²ÑƒĞ°Ñ€",
  GAt = () => "ĞšĞ¾Ñ‚-Ğ´'Ğ†Ğ²ÑƒĞ°Ñ€",
  HAt = () => "Bá» Biá»ƒn NgÃ ",
  WAt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? DAt() : t === "pt" ? RAt() : t === "ch" ? BAt() : t === "de" ? FAt() : t === "es" ? OAt() : t === "fr" ? qAt() : t === "it" ? NAt() : t === "jp" ? VAt() : t === "pl" ? UAt() : t === "ru" ? ZAt() : t === "uk" ? GAt() : HAt()
  },
  $At = () => "Denmark",
  XAt = () => "Dinamarca",
  YAt = () => "ä¸¹éº¦",
  KAt = () => "DÃ¤nemark",
  JAt = () => "Dinamarca",
  QAt = () => "Danemark",
  t6t = () => "Danimarca",
  e6t = () => "ãƒ‡ãƒ³ãƒãƒ¼ã‚¯",
  r6t = () => "Dania",
  n6t = () => "Ğ”Ğ°Ğ½Ğ¸Ñ",
  i6t = () => "Ğ”Ğ°Ğ½Ñ–Ñ",
  o6t = () => "Äan Máº¡ch",
  s6t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $At() : t === "pt" ? XAt() : t === "ch" ? YAt() : t === "de" ? KAt() : t === "es" ? JAt() : t === "fr" ? QAt() : t === "it" ? t6t() : t === "jp" ? e6t() : t === "pl" ? r6t() : t === "ru" ? n6t() : t === "uk" ? i6t() : o6t()
  },
  a6t = () => "Djibouti",
  u6t = () => "Djibouti",
  c6t = () => "å‰å¸ƒæ",
  l6t = () => "Dschibuti",
  _6t = () => "Yibuti",
  h6t = () => "Djibouti",
  d6t = () => "Gibuti",
  p6t = () => "ã‚¸ãƒ–ãƒ",
  f6t = () => "DÅ¼ibuti",
  m6t = () => "Ğ”Ğ¶Ğ¸Ğ±ÑƒÑ‚Ğ¸",
  g6t = () => "Ğ”Ğ¶Ğ¸Ğ±ÑƒÑ‚Ñ–",
  y6t = () => "Djibouti",
  v6t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? a6t() : t === "pt" ? u6t() : t === "ch" ? c6t() : t === "de" ? l6t() : t === "es" ? _6t() : t === "fr" ? h6t() : t === "it" ? d6t() : t === "jp" ? p6t() : t === "pl" ? f6t() : t === "ru" ? m6t() : t === "uk" ? g6t() : y6t()
  },
  b6t = () => "Dominica",
  x6t = () => "Dominica",
  w6t = () => "å¤šç±³å°¼å…‹",
  k6t = () => "Dominica",
  T6t = () => "Dominica",
  S6t = () => "La Dominique",
  P6t = () => "Dominica",
  M6t = () => "ãƒ‰ãƒŸãƒ‹ã‚«",
  C6t = () => "Dominika",
  I6t = () => "Ğ”Ğ¾Ğ¼Ğ¸Ğ½Ğ¸ĞºĞ°",
  z6t = () => "Ğ”Ğ¾Ğ¼Ñ–Ğ½Ñ–ĞºĞ°",
  A6t = () => "Dominica",
  E6t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? b6t() : t === "pt" ? x6t() : t === "ch" ? w6t() : t === "de" ? k6t() : t === "es" ? T6t() : t === "fr" ? S6t() : t === "it" ? P6t() : t === "jp" ? M6t() : t === "pl" ? C6t() : t === "ru" ? I6t() : t === "uk" ? z6t() : A6t()
  },
  j6t = () => "Dominican Republic",
  L6t = () => "RepÃºblica Dominicana",
  D6t = () => "å¤šç±³å°¼åŠ å…±å’Œå›½",
  R6t = () => "Dominikanische Republik",
  B6t = () => "RepÃºblica Dominicana",
  F6t = () => "RÃ©publique dominicaine",
  O6t = () => "Repubblica Dominicana",
  q6t = () => "ãƒ‰ãƒŸãƒ‹ã‚«å…±å’Œå›½",
  N6t = () => "Republika DominikaÅ„ska",
  V6t = () => "Ğ”Ğ¾Ğ¼Ğ¸Ğ½Ğ¸ĞºĞ°Ğ½ÑĞºĞ°Ñ Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°",
  U6t = () => "Ğ”Ğ¾Ğ¼Ñ–Ğ½Ñ–ĞºĞ°Ğ½ÑÑŒĞºĞ° Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ñ–ĞºĞ°",
  Z6t = () => "Cá»™ng hÃ²a ÄÃ´-mi-ni-ca",
  G6t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? j6t() : t === "pt" ? L6t() : t === "ch" ? D6t() : t === "de" ? R6t() : t === "es" ? B6t() : t === "fr" ? F6t() : t === "it" ? O6t() : t === "jp" ? q6t() : t === "pl" ? N6t() : t === "ru" ? V6t() : t === "uk" ? U6t() : Z6t()
  },
  H6t = () => "Ecuador",
  W6t = () => "Equador",
  $6t = () => "å„ç“œå¤šå°”",
  X6t = () => "Ecuador",
  Y6t = () => "Ecuador",
  K6t = () => "Ã‰quateur",
  J6t = () => "Ecuador",
  Q6t = () => "ã‚¨ã‚¯ã‚¢ãƒ‰ãƒ«",
  tEt = () => "Ekwador",
  eEt = () => "Ğ­ĞºĞ²Ğ°Ğ´Ğ¾Ñ€",
  rEt = () => "Ğ•ĞºĞ²Ğ°Ğ´Ğ¾Ñ€",
  nEt = () => "Ecuador",
  iEt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? H6t() : t === "pt" ? W6t() : t === "ch" ? $6t() : t === "de" ? X6t() : t === "es" ? Y6t() : t === "fr" ? K6t() : t === "it" ? J6t() : t === "jp" ? Q6t() : t === "pl" ? tEt() : t === "ru" ? eEt() : t === "uk" ? rEt() : nEt()
  },
  oEt = () => "Egypt",
  sEt = () => "Egito",
  aEt = () => "åŸƒåŠ",
  uEt = () => "Ã„gypten",
  cEt = () => "Egipto",
  lEt = () => "Ã‰gypte",
  _Et = () => "Egitto",
  hEt = () => "ã‚¨ã‚¸ãƒ—ãƒˆ",
  dEt = () => "Egipt",
  pEt = () => "Ğ•Ğ³Ğ¸Ğ¿ĞµÑ‚",
  fEt = () => "Ğ„Ğ³Ğ¸Ğ¿ĞµÑ‚",
  mEt = () => "Ai Cáº­p",
  gEt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? oEt() : t === "pt" ? sEt() : t === "ch" ? aEt() : t === "de" ? uEt() : t === "es" ? cEt() : t === "fr" ? lEt() : t === "it" ? _Et() : t === "jp" ? hEt() : t === "pl" ? dEt() : t === "ru" ? pEt() : t === "uk" ? fEt() : mEt()
  },
  yEt = () => "El Salvador",
  vEt = () => "El Salvador",
  bEt = () => "è¨å°”ç“¦å¤š",
  xEt = () => "El Salvador",
  wEt = () => "El Salvador",
  kEt = () => "Le Salvador",
  TEt = () => "El Salvador",
  SEt = () => "ã‚¨ãƒ«ã‚µãƒ«ãƒãƒ‰ãƒ«",
  PEt = () => "Salwador",
  MEt = () => "Ğ¡Ğ°Ğ»ÑŒĞ²Ğ°Ğ´Ğ¾Ñ€",
  CEt = () => "Ğ¡Ğ°Ğ»ÑŒĞ²Ğ°Ğ´Ğ¾Ñ€",
  IEt = () => "El Salvador",
  zEt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? yEt() : t === "pt" ? vEt() : t === "ch" ? bEt() : t === "de" ? xEt() : t === "es" ? wEt() : t === "fr" ? kEt() : t === "it" ? TEt() : t === "jp" ? SEt() : t === "pl" ? PEt() : t === "ru" ? MEt() : t === "uk" ? CEt() : IEt()
  },
  AEt = () => "Equatorial Guinea",
  EEt = () => "GuinÃ© Equatorial",
  jEt = () => "èµ¤é“å‡ å†…äºš",
  LEt = () => "Ã„quatorialguinea",
  DEt = () => "Guinea Ecuatorial",
  REt = () => "GuinÃ©e Ã©quatoriale",
  BEt = () => "Guinea Equatoriale",
  FEt = () => "èµ¤é“ã‚®ãƒ‹ã‚¢",
  OEt = () => "Gwinea RÃ³wnikowa",
  qEt = () => "Ğ­ĞºĞ²Ğ°Ñ‚Ğ¾Ñ€Ğ¸Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ“Ğ²Ğ¸Ğ½ĞµÑ",
  NEt = () => "Ğ•ĞºĞ²Ğ°Ñ‚Ğ¾Ñ€Ñ–Ğ°Ğ»ÑŒĞ½Ğ° Ğ“Ğ²Ñ–Ğ½ĞµÑ",
  VEt = () => "Ghi-nÃª XÃ­ch Äáº¡o",
  UEt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? AEt() : t === "pt" ? EEt() : t === "ch" ? jEt() : t === "de" ? LEt() : t === "es" ? DEt() : t === "fr" ? REt() : t === "it" ? BEt() : t === "jp" ? FEt() : t === "pl" ? OEt() : t === "ru" ? qEt() : t === "uk" ? NEt() : VEt()
  },
  ZEt = () => "Eritrea",
  GEt = () => "Eritreia",
  HEt = () => "å„ç«‹ç‰¹é‡Œäºš",
  WEt = () => "Eritrea",
  $Et = () => "Eritrea",
  XEt = () => "Ã‰rythrÃ©e",
  YEt = () => "Eritrea",
  KEt = () => "ã‚¨ãƒªãƒˆãƒªã‚¢",
  JEt = () => "Erytrea",
  QEt = () => "Ğ­Ñ€Ğ¸Ñ‚Ñ€ĞµÑ",
  t8t = () => "Ğ•Ñ€Ğ¸Ñ‚Ñ€ĞµÑ",
  e8t = () => "Eritrea",
  r8t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ZEt() : t === "pt" ? GEt() : t === "ch" ? HEt() : t === "de" ? WEt() : t === "es" ? $Et() : t === "fr" ? XEt() : t === "it" ? YEt() : t === "jp" ? KEt() : t === "pl" ? JEt() : t === "ru" ? QEt() : t === "uk" ? t8t() : e8t()
  },
  n8t = () => "Estonia",
  i8t = () => "EstÃ´nia",
  o8t = () => "çˆ±æ²™å°¼äºš",
  s8t = () => "Estland",
  a8t = () => "Estonia",
  u8t = () => "Estonie",
  c8t = () => "Estonia",
  l8t = () => "ã‚¨ã‚¹ãƒˆãƒ‹ã‚¢",
  _8t = () => "Estonia",
  h8t = () => "Ğ­ÑÑ‚Ğ¾Ğ½Ğ¸Ñ",
  d8t = () => "Ğ•ÑÑ‚Ğ¾Ğ½Ñ–Ñ",
  p8t = () => "Estonia",
  f8t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? n8t() : t === "pt" ? i8t() : t === "ch" ? o8t() : t === "de" ? s8t() : t === "es" ? a8t() : t === "fr" ? u8t() : t === "it" ? c8t() : t === "jp" ? l8t() : t === "pl" ? _8t() : t === "ru" ? h8t() : t === "uk" ? d8t() : p8t()
  },
  m8t = () => "Eswatini",
  g8t = () => "EssuatÃ­ni",
  y8t = () => "æ–¯å¨å£«å…°",
  v8t = () => "Eswatini",
  b8t = () => "Eswatini",
  x8t = () => "Eswatini",
  w8t = () => "Eswatini",
  k8t = () => "ã‚¨ã‚¹ãƒ¯ãƒ†ã‚£ãƒ‹",
  T8t = () => "Eswatini",
  S8t = () => "Ğ­ÑĞ²Ğ°Ñ‚Ğ¸Ğ½Ğ¸",
  P8t = () => "Ğ•ÑĞ²Ğ°Ñ‚Ñ–Ğ½Ñ–",
  M8t = () => "Eswatini",
  C8t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? m8t() : t === "pt" ? g8t() : t === "ch" ? y8t() : t === "de" ? v8t() : t === "es" ? b8t() : t === "fr" ? x8t() : t === "it" ? w8t() : t === "jp" ? k8t() : t === "pl" ? T8t() : t === "ru" ? S8t() : t === "uk" ? P8t() : M8t()
  },
  I8t = () => "Ethiopia",
  z8t = () => "EtiÃ³pia",
  A8t = () => "åŸƒå¡ä¿„æ¯”äºš",
  E8t = () => "Ã„thiopien",
  j8t = () => "EtiopÃ­a",
  L8t = () => "Ã‰thiopie",
  D8t = () => "Etiopia",
  R8t = () => "ã‚¨ãƒã‚ªãƒ”ã‚¢",
  B8t = () => "Etiopia",
  F8t = () => "Ğ­Ñ„Ğ¸Ğ¾Ğ¿Ğ¸Ñ",
  O8t = () => "Ğ•Ñ„Ñ–Ğ¾Ğ¿Ñ–Ñ",
  q8t = () => "Ethiopia",
  N8t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? I8t() : t === "pt" ? z8t() : t === "ch" ? A8t() : t === "de" ? E8t() : t === "es" ? j8t() : t === "fr" ? L8t() : t === "it" ? D8t() : t === "jp" ? R8t() : t === "pl" ? B8t() : t === "ru" ? F8t() : t === "uk" ? O8t() : q8t()
  },
  V8t = () => "Falkland Islands (Malvinas)",
  U8t = () => "Ilhas Falkland (Malvinas)",
  Z8t = () => "ç¦å…‹å…°ç¾¤å²› (é©¬å°”ç»´çº³æ–¯ç¾¤å²›)",
  G8t = () => "Falklandinseln (Malwinen)",
  H8t = () => "Islas Malvinas",
  W8t = () => "Ãles Falkland (Malouines)",
  $8t = () => "Isole Falkland (Malvine)",
  X8t = () => "ãƒ•ã‚©ãƒ¼ã‚¯ãƒ©ãƒ³ãƒ‰è«¸å³¶ (ãƒãƒ«ãƒ“ãƒŠã‚¹è«¸å³¶)",
  Y8t = () => "Falklandy (Malwiny)",
  K8t = () => "Ğ¤Ğ¾Ğ»ĞºĞ»ĞµĞ½Ğ´ÑĞºĞ¸Ğµ (ĞœĞ°Ğ»ÑŒĞ²Ğ¸Ğ½ÑĞºĞ¸Ğµ) Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  J8t = () => "Ğ¤Ğ¾Ğ»ĞºĞ»ĞµĞ½Ğ´ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸ (ĞœĞ°Ğ»ÑŒĞ²Ñ–Ğ½ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸)",
  Q8t = () => "Quáº§n Ä‘áº£o Falkland (Malvinas)",
  tjt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? V8t() : t === "pt" ? U8t() : t === "ch" ? Z8t() : t === "de" ? G8t() : t === "es" ? H8t() : t === "fr" ? W8t() : t === "it" ? $8t() : t === "jp" ? X8t() : t === "pl" ? Y8t() : t === "ru" ? K8t() : t === "uk" ? J8t() : Q8t()
  },
  ejt = () => "Faroe Islands",
  rjt = () => "Ilhas FaroÃ©",
  njt = () => "æ³•ç½—ç¾¤å²›",
  ijt = () => "FÃ¤rÃ¶er",
  ojt = () => "Islas Feroe",
  sjt = () => "Ãles FÃ©roÃ©",
  ajt = () => "Isole FÃ¦r Ã˜er",
  ujt = () => "ãƒ•ã‚§ãƒ­ãƒ¼è«¸å³¶",
  cjt = () => "Wyspy Owcze",
  ljt = () => "Ğ¤Ğ°Ñ€ĞµÑ€ÑĞºĞ¸Ğµ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  _jt = () => "Ğ¤Ğ°Ñ€ĞµÑ€ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  hjt = () => "Quáº§n Ä‘áº£o Faroe",
  djt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ejt() : t === "pt" ? rjt() : t === "ch" ? njt() : t === "de" ? ijt() : t === "es" ? ojt() : t === "fr" ? sjt() : t === "it" ? ajt() : t === "jp" ? ujt() : t === "pl" ? cjt() : t === "ru" ? ljt() : t === "uk" ? _jt() : hjt()
  },
  pjt = () => "Fiji",
  fjt = () => "Fiji",
  mjt = () => "æ–æµ",
  gjt = () => "Fidschi",
  yjt = () => "Fiyi",
  vjt = () => "Fidji",
  bjt = () => "Figi",
  xjt = () => "ãƒ•ã‚£ã‚¸ãƒ¼",
  wjt = () => "FidÅ¼i",
  kjt = () => "Ğ¤Ğ¸Ğ´Ğ¶Ğ¸",
  Tjt = () => "Ğ¤Ñ–Ğ´Ğ¶Ñ–",
  Sjt = () => "Fiji",
  Pjt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pjt() : t === "pt" ? fjt() : t === "ch" ? mjt() : t === "de" ? gjt() : t === "es" ? yjt() : t === "fr" ? vjt() : t === "it" ? bjt() : t === "jp" ? xjt() : t === "pl" ? wjt() : t === "ru" ? kjt() : t === "uk" ? Tjt() : Sjt()
  },
  Mjt = () => "Finland",
  Cjt = () => "FinlÃ¢ndia",
  Ijt = () => "èŠ¬å…°",
  zjt = () => "Finnland",
  Ajt = () => "Finlandia",
  Ejt = () => "Finlande",
  jjt = () => "Finlandia",
  Ljt = () => "ãƒ•ã‚£ãƒ³ãƒ©ãƒ³ãƒ‰",
  Djt = () => "Finlandia",
  Rjt = () => "Ğ¤Ğ¸Ğ½Ğ»ÑĞ½Ğ´Ğ¸Ñ",
  Bjt = () => "Ğ¤Ñ–Ğ½Ğ»ÑĞ½Ğ´Ñ–Ñ",
  Fjt = () => "Pháº§n Lan",
  Ojt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Mjt() : t === "pt" ? Cjt() : t === "ch" ? Ijt() : t === "de" ? zjt() : t === "es" ? Ajt() : t === "fr" ? Ejt() : t === "it" ? jjt() : t === "jp" ? Ljt() : t === "pl" ? Djt() : t === "ru" ? Rjt() : t === "uk" ? Bjt() : Fjt()
  },
  qjt = () => "France",
  Njt = () => "FranÃ§a",
  Vjt = () => "æ³•å›½",
  Ujt = () => "Frankreich",
  Zjt = () => "Francia",
  Gjt = () => "France",
  Hjt = () => "Francia",
  Wjt = () => "ãƒ•ãƒ©ãƒ³ã‚¹",
  $jt = () => "Francja",
  Xjt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†Ğ¸Ñ",
  Yjt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†Ñ–Ñ",
  Kjt = () => "PhÃ¡p",
  Jjt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qjt() : t === "pt" ? Njt() : t === "ch" ? Vjt() : t === "de" ? Ujt() : t === "es" ? Zjt() : t === "fr" ? Gjt() : t === "it" ? Hjt() : t === "jp" ? Wjt() : t === "pl" ? $jt() : t === "ru" ? Xjt() : t === "uk" ? Yjt() : Kjt()
  },
  Qjt = () => "French Guiana",
  tLt = () => "Guiana Francesa",
  eLt = () => "æ³•å±åœ­äºšé‚£",
  rLt = () => "FranzÃ¶sisch-Guayana",
  nLt = () => "Guayana Francesa",
  iLt = () => "Guyane franÃ§aise",
  oLt = () => "Guyana francese",
  sLt = () => "ãƒ•ãƒ©ãƒ³ã‚¹é ˜ã‚®ã‚¢ãƒŠ",
  aLt = () => "Gujana Francuska",
  uLt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑĞºĞ°Ñ Ğ“Ğ²Ğ¸Ğ°Ğ½Ğ°",
  cLt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑŒĞºĞ° Ğ“Ğ²Ñ–Ğ°Ğ½Ğ°",
  lLt = () => "Guyane thuá»™c PhÃ¡p",
  _Lt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Qjt() : t === "pt" ? tLt() : t === "ch" ? eLt() : t === "de" ? rLt() : t === "es" ? nLt() : t === "fr" ? iLt() : t === "it" ? oLt() : t === "jp" ? sLt() : t === "pl" ? aLt() : t === "ru" ? uLt() : t === "uk" ? cLt() : lLt()
  },
  hLt = () => "French Polynesia",
  dLt = () => "PolinÃ©sia Francesa",
  pLt = () => "æ³•å±æ³¢åˆ©å°¼è¥¿äºš",
  fLt = () => "FranzÃ¶sisch-Polynesien",
  mLt = () => "Polinesia Francesa",
  gLt = () => "PolynÃ©sie franÃ§aise",
  yLt = () => "Polinesia Francese",
  vLt = () => "ãƒ•ãƒ©ãƒ³ã‚¹é ˜ãƒãƒªãƒã‚·ã‚¢",
  bLt = () => "Polinezja Francuska",
  xLt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑĞºĞ°Ñ ĞŸĞ¾Ğ»Ğ¸Ğ½ĞµĞ·Ğ¸Ñ",
  wLt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑŒĞºĞ° ĞŸĞ¾Ğ»Ñ–Ğ½ĞµĞ·Ñ–Ñ",
  kLt = () => "Polynesia thuá»™c PhÃ¡p",
  TLt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hLt() : t === "pt" ? dLt() : t === "ch" ? pLt() : t === "de" ? fLt() : t === "es" ? mLt() : t === "fr" ? gLt() : t === "it" ? yLt() : t === "jp" ? vLt() : t === "pl" ? bLt() : t === "ru" ? xLt() : t === "uk" ? wLt() : kLt()
  },
  SLt = () => "French Southern Territories",
  PLt = () => "TerritÃ³rios Austrais Franceses",
  MLt = () => "æ³•å±å—éƒ¨é¢†åœ°",
  CLt = () => "FranzÃ¶sische SÃ¼d- und Antarktisgebiete",
  ILt = () => "Territorios Australes Franceses",
  zLt = () => "Terres australes et antarctiques franÃ§aises",
  ALt = () => "Territori australi francesi",
  ELt = () => "ãƒ•ãƒ©ãƒ³ã‚¹é ˜å—æ–¹åœ°åŸŸ",
  jLt = () => "Francuskie Terytoria PoÅ‚udniowe",
  LLt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑĞºĞ¸Ğµ Ğ®Ğ¶Ğ½Ñ‹Ğµ Ñ‚ĞµÑ€Ñ€Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¸",
  DLt = () => "Ğ¤Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑŒĞºÑ– ĞŸÑ–Ğ²Ğ´ĞµĞ½Ğ½Ñ– Ğ¢ĞµÑ€Ğ¸Ñ‚Ğ¾Ñ€Ñ–Ñ—",
  RLt = () => "LÃ£nh thá»• phÃ­a Nam nÆ°á»›c PhÃ¡p",
  BLt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? SLt() : t === "pt" ? PLt() : t === "ch" ? MLt() : t === "de" ? CLt() : t === "es" ? ILt() : t === "fr" ? zLt() : t === "it" ? ALt() : t === "jp" ? ELt() : t === "pl" ? jLt() : t === "ru" ? LLt() : t === "uk" ? DLt() : RLt()
  },
  FLt = () => "Gabon",
  OLt = () => "GabÃ£o",
  qLt = () => "åŠ è“¬",
  NLt = () => "Gabun",
  VLt = () => "GabÃ³n",
  ULt = () => "Gabon",
  ZLt = () => "Gabon",
  GLt = () => "ã‚¬ãƒœãƒ³",
  HLt = () => "Gabon",
  WLt = () => "Ğ“Ğ°Ğ±Ğ¾Ğ½",
  $Lt = () => "Ğ“Ğ°Ğ±Ğ¾Ğ½",
  XLt = () => "Gabon",
  YLt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? FLt() : t === "pt" ? OLt() : t === "ch" ? qLt() : t === "de" ? NLt() : t === "es" ? VLt() : t === "fr" ? ULt() : t === "it" ? ZLt() : t === "jp" ? GLt() : t === "pl" ? HLt() : t === "ru" ? WLt() : t === "uk" ? $Lt() : XLt()
  },
  KLt = () => "Gambia",
  JLt = () => "GÃ¢mbia",
  QLt = () => "å†ˆæ¯”äºš",
  tDt = () => "Gambia",
  eDt = () => "Gambia",
  rDt = () => "Gambie",
  nDt = () => "Gambia",
  iDt = () => "ã‚¬ãƒ³ãƒ“ã‚¢",
  oDt = () => "Gambia",
  sDt = () => "Ğ“Ğ°Ğ¼Ğ±Ğ¸Ñ",
  aDt = () => "Ğ“Ğ°Ğ¼Ğ±Ñ–Ñ",
  uDt = () => "Gambia",
  cDt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? KLt() : t === "pt" ? JLt() : t === "ch" ? QLt() : t === "de" ? tDt() : t === "es" ? eDt() : t === "fr" ? rDt() : t === "it" ? nDt() : t === "jp" ? iDt() : t === "pl" ? oDt() : t === "ru" ? sDt() : t === "uk" ? aDt() : uDt()
  },
  lDt = () => "Georgia",
  _Dt = () => "GeÃ³rgia",
  hDt = () => "æ ¼é²å‰äºš",
  dDt = () => "Georgien",
  pDt = () => "Georgia",
  fDt = () => "GÃ©orgie",
  mDt = () => "Georgia",
  gDt = () => "ã‚¸ãƒ§ãƒ¼ã‚¸ã‚¢",
  yDt = () => "Gruzja",
  vDt = () => "Ğ“Ñ€ÑƒĞ·Ğ¸Ñ",
  bDt = () => "Ğ“Ñ€ÑƒĞ·Ñ–Ñ",
  xDt = () => "Gruzia",
  wDt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lDt() : t === "pt" ? _Dt() : t === "ch" ? hDt() : t === "de" ? dDt() : t === "es" ? pDt() : t === "fr" ? fDt() : t === "it" ? mDt() : t === "jp" ? gDt() : t === "pl" ? yDt() : t === "ru" ? vDt() : t === "uk" ? bDt() : xDt()
  },
  kDt = () => "Germany",
  TDt = () => "Alemanha",
  SDt = () => "å¾·å›½",
  PDt = () => "Deutschland",
  MDt = () => "Alemania",
  CDt = () => "Allemagne",
  IDt = () => "Germania",
  zDt = () => "ãƒ‰ã‚¤ãƒ„",
  ADt = () => "Niemcy",
  EDt = () => "Ğ“ĞµÑ€Ğ¼Ğ°Ğ½Ğ¸Ñ",
  jDt = () => "ĞÑ–Ğ¼ĞµÑ‡Ñ‡Ğ¸Ğ½Ğ°",
  LDt = () => "Äá»©c",
  DDt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kDt() : t === "pt" ? TDt() : t === "ch" ? SDt() : t === "de" ? PDt() : t === "es" ? MDt() : t === "fr" ? CDt() : t === "it" ? IDt() : t === "jp" ? zDt() : t === "pl" ? ADt() : t === "ru" ? EDt() : t === "uk" ? jDt() : LDt()
  },
  RDt = () => "Ghana",
  BDt = () => "Gana",
  FDt = () => "åŠ çº³",
  ODt = () => "Ghana",
  qDt = () => "Ghana",
  NDt = () => "Ghana",
  VDt = () => "Ghana",
  UDt = () => "ã‚¬ãƒ¼ãƒŠ",
  ZDt = () => "Ghana",
  GDt = () => "Ğ“Ğ°Ğ½Ğ°",
  HDt = () => "Ğ“Ğ°Ğ½Ğ°",
  WDt = () => "Ghana",
  $Dt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? RDt() : t === "pt" ? BDt() : t === "ch" ? FDt() : t === "de" ? ODt() : t === "es" ? qDt() : t === "fr" ? NDt() : t === "it" ? VDt() : t === "jp" ? UDt() : t === "pl" ? ZDt() : t === "ru" ? GDt() : t === "uk" ? HDt() : WDt()
  },
  XDt = () => "Gibraltar",
  YDt = () => "Gibraltar",
  KDt = () => "ç›´å¸ƒç½—é™€",
  JDt = () => "Gibraltar",
  QDt = () => "Gibraltar",
  tRt = () => "Gibraltar",
  eRt = () => "Gibilterra",
  rRt = () => "ã‚¸ãƒ–ãƒ©ãƒ«ã‚¿ãƒ«",
  nRt = () => "Gibraltar",
  iRt = () => "Ğ“Ğ¸Ğ±Ñ€Ğ°Ğ»Ñ‚Ğ°Ñ€",
  oRt = () => "Ğ“Ñ–Ğ±Ñ€Ğ°Ğ»Ñ‚Ğ°Ñ€",
  sRt = () => "Gibraltar",
  aRt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? XDt() : t === "pt" ? YDt() : t === "ch" ? KDt() : t === "de" ? JDt() : t === "es" ? QDt() : t === "fr" ? tRt() : t === "it" ? eRt() : t === "jp" ? rRt() : t === "pl" ? nRt() : t === "ru" ? iRt() : t === "uk" ? oRt() : sRt()
  },
  uRt = () => "Greece",
  cRt = () => "GrÃ©cia",
  lRt = () => "å¸Œè…Š",
  _Rt = () => "Griechenland",
  hRt = () => "Grecia",
  dRt = () => "GrÃ¨ce",
  pRt = () => "Grecia",
  fRt = () => "ã‚®ãƒªã‚·ãƒ£",
  mRt = () => "Grecja",
  gRt = () => "Ğ“Ñ€ĞµÑ†Ğ¸Ñ",
  yRt = () => "Ğ“Ñ€ĞµÑ†Ñ–Ñ",
  vRt = () => "Hy Láº¡p",
  bRt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? uRt() : t === "pt" ? cRt() : t === "ch" ? lRt() : t === "de" ? _Rt() : t === "es" ? hRt() : t === "fr" ? dRt() : t === "it" ? pRt() : t === "jp" ? fRt() : t === "pl" ? mRt() : t === "ru" ? gRt() : t === "uk" ? yRt() : vRt()
  },
  xRt = () => "Greenland",
  wRt = () => "GroenlÃ¢ndia",
  kRt = () => "æ ¼é™µå…°",
  TRt = () => "GrÃ¶nland",
  SRt = () => "Groenlandia",
  PRt = () => "Groenland",
  MRt = () => "Groenlandia",
  CRt = () => "ã‚°ãƒªãƒ¼ãƒ³ãƒ©ãƒ³ãƒ‰",
  IRt = () => "Grenlandia",
  zRt = () => "Ğ“Ñ€ĞµĞ½Ğ»Ğ°Ğ½Ğ´Ğ¸Ñ",
  ARt = () => "Ğ“Ñ€ĞµĞ½Ğ»Ğ°Ğ½Ğ´Ñ–Ñ",
  ERt = () => "Greenland",
  jRt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xRt() : t === "pt" ? wRt() : t === "ch" ? kRt() : t === "de" ? TRt() : t === "es" ? SRt() : t === "fr" ? PRt() : t === "it" ? MRt() : t === "jp" ? CRt() : t === "pl" ? IRt() : t === "ru" ? zRt() : t === "uk" ? ARt() : ERt()
  },
  LRt = () => "Grenada",
  DRt = () => "Granada",
  RRt = () => "æ ¼æ—çº³è¾¾",
  BRt = () => "Grenada",
  FRt = () => "Granada",
  ORt = () => "Grenade",
  qRt = () => "Grenada",
  NRt = () => "ã‚°ãƒ¬ãƒŠãƒ€",
  VRt = () => "Grenada",
  URt = () => "Ğ“Ñ€ĞµĞ½Ğ°Ğ´Ğ°",
  ZRt = () => "Ğ“Ñ€ĞµĞ½Ğ°Ğ´Ğ°",
  GRt = () => "Grenada",
  HRt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? LRt() : t === "pt" ? DRt() : t === "ch" ? RRt() : t === "de" ? BRt() : t === "es" ? FRt() : t === "fr" ? ORt() : t === "it" ? qRt() : t === "jp" ? NRt() : t === "pl" ? VRt() : t === "ru" ? URt() : t === "uk" ? ZRt() : GRt()
  },
  WRt = () => "Guadeloupe",
  $Rt = () => "Guadalupe",
  XRt = () => "ç“œå¾·ç½—æ™®",
  YRt = () => "Guadeloupe",
  KRt = () => "Guadalupe",
  JRt = () => "Guadeloupe",
  QRt = () => "Guadeloupe",
  tBt = () => "ã‚°ã‚¢ãƒ‰ãƒ«ãƒ¼ãƒ—",
  eBt = () => "Gwadelupa",
  rBt = () => "Ğ“Ğ²Ğ°Ğ´ĞµĞ»ÑƒĞ¿Ğ°",
  nBt = () => "Ğ“Ğ²Ğ°Ğ´ĞµĞ»ÑƒĞ¿Ğ°",
  iBt = () => "Guadeloupe",
  oBt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? WRt() : t === "pt" ? $Rt() : t === "ch" ? XRt() : t === "de" ? YRt() : t === "es" ? KRt() : t === "fr" ? JRt() : t === "it" ? QRt() : t === "jp" ? tBt() : t === "pl" ? eBt() : t === "ru" ? rBt() : t === "uk" ? nBt() : iBt()
  },
  sBt = () => "Guam",
  aBt = () => "Guam",
  uBt = () => "å…³å²›",
  cBt = () => "Guam",
  lBt = () => "Guam",
  _Bt = () => "Guam",
  hBt = () => "Guam",
  dBt = () => "ã‚°ã‚¢ãƒ ",
  pBt = () => "Guam",
  fBt = () => "Ğ“ÑƒĞ°Ğ¼",
  mBt = () => "Ğ“ÑƒĞ°Ğ¼",
  gBt = () => "Guam",
  yBt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? sBt() : t === "pt" ? aBt() : t === "ch" ? uBt() : t === "de" ? cBt() : t === "es" ? lBt() : t === "fr" ? _Bt() : t === "it" ? hBt() : t === "jp" ? dBt() : t === "pl" ? pBt() : t === "ru" ? fBt() : t === "uk" ? mBt() : gBt()
  },
  vBt = () => "Guatemala",
  bBt = () => "Guatemala",
  xBt = () => "å±åœ°é©¬æ‹‰",
  wBt = () => "Guatemala",
  kBt = () => "Guatemala",
  TBt = () => "Guatemala",
  SBt = () => "Guatemala",
  PBt = () => "ã‚°ã‚¢ãƒ†ãƒãƒ©",
  MBt = () => "Gwatemala",
  CBt = () => "Ğ“Ğ²Ğ°Ñ‚ĞµĞ¼Ğ°Ğ»Ğ°",
  IBt = () => "Ğ“Ğ²Ğ°Ñ‚ĞµĞ¼Ğ°Ğ»Ğ°",
  zBt = () => "Guatemala",
  ABt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vBt() : t === "pt" ? bBt() : t === "ch" ? xBt() : t === "de" ? wBt() : t === "es" ? kBt() : t === "fr" ? TBt() : t === "it" ? SBt() : t === "jp" ? PBt() : t === "pl" ? MBt() : t === "ru" ? CBt() : t === "uk" ? IBt() : zBt()
  },
  EBt = () => "Guernsey",
  jBt = () => "Guernsey",
  LBt = () => "æ ¹è¥¿å²›",
  DBt = () => "Guernsey",
  RBt = () => "Guernsey",
  BBt = () => "Guernesey",
  FBt = () => "Guernsey",
  OBt = () => "ã‚¬ãƒ¼ãƒ³ã‚¸ãƒ¼",
  qBt = () => "Guernsey",
  NBt = () => "Ğ“ĞµÑ€Ğ½ÑĞ¸",
  VBt = () => "Ğ“ĞµÑ€Ğ½ÑÑ–",
  UBt = () => "Guernsey",
  ZBt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? EBt() : t === "pt" ? jBt() : t === "ch" ? LBt() : t === "de" ? DBt() : t === "es" ? RBt() : t === "fr" ? BBt() : t === "it" ? FBt() : t === "jp" ? OBt() : t === "pl" ? qBt() : t === "ru" ? NBt() : t === "uk" ? VBt() : UBt()
  },
  GBt = () => "Guinea",
  HBt = () => "GuinÃ©",
  WBt = () => "å‡ å†…äºš",
  $Bt = () => "Guinea",
  XBt = () => "Guinea",
  YBt = () => "GuinÃ©e",
  KBt = () => "Guinea",
  JBt = () => "ã‚®ãƒ‹ã‚¢",
  QBt = () => "Gwinea",
  tFt = () => "Ğ“Ğ²Ğ¸Ğ½ĞµÑ",
  eFt = () => "Ğ“Ğ²Ñ–Ğ½ĞµÑ",
  rFt = () => "Ghi-nÃª",
  nFt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? GBt() : t === "pt" ? HBt() : t === "ch" ? WBt() : t === "de" ? $Bt() : t === "es" ? XBt() : t === "fr" ? YBt() : t === "it" ? KBt() : t === "jp" ? JBt() : t === "pl" ? QBt() : t === "ru" ? tFt() : t === "uk" ? eFt() : rFt()
  },
  iFt = () => "Guinea-Bissau",
  oFt = () => "GuinÃ©-Bissau",
  sFt = () => "å‡ å†…äºšæ¯”ç»",
  aFt = () => "Guinea-Bissau",
  uFt = () => "Guinea-Bissau",
  cFt = () => "GuinÃ©e-Bissau",
  lFt = () => "Guinea-Bissau",
  _Ft = () => "ã‚®ãƒ‹ã‚¢ãƒ“ã‚µã‚¦",
  hFt = () => "Gwinea Bissau",
  dFt = () => "Ğ“Ğ²Ğ¸Ğ½ĞµÑ-Ğ‘Ğ¸ÑĞ°Ñƒ",
  pFt = () => "Ğ“Ğ²Ñ–Ğ½ĞµÑ-Ğ‘Ñ–ÑĞ°Ñƒ",
  fFt = () => "Guinea-Bissau",
  mFt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? iFt() : t === "pt" ? oFt() : t === "ch" ? sFt() : t === "de" ? aFt() : t === "es" ? uFt() : t === "fr" ? cFt() : t === "it" ? lFt() : t === "jp" ? _Ft() : t === "pl" ? hFt() : t === "ru" ? dFt() : t === "uk" ? pFt() : fFt()
  },
  gFt = () => "Guyana",
  yFt = () => "Guiana",
  vFt = () => "åœ­äºšé‚£",
  bFt = () => "Guyana",
  xFt = () => "Guyana",
  wFt = () => "Guyana",
  kFt = () => "Guyana",
  TFt = () => "ã‚¬ã‚¤ã‚¢ãƒŠ",
  SFt = () => "Gujana",
  PFt = () => "Ğ“Ğ°Ğ¹Ğ°Ğ½Ğ°",
  MFt = () => "Ğ“Ğ°ÑĞ½Ğ°",
  CFt = () => "Guyana",
  IFt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? gFt() : t === "pt" ? yFt() : t === "ch" ? vFt() : t === "de" ? bFt() : t === "es" ? xFt() : t === "fr" ? wFt() : t === "it" ? kFt() : t === "jp" ? TFt() : t === "pl" ? SFt() : t === "ru" ? PFt() : t === "uk" ? MFt() : CFt()
  },
  zFt = () => "Haiti",
  AFt = () => "Haiti",
  EFt = () => "æµ·åœ°",
  jFt = () => "Haiti",
  LFt = () => "HaitÃ­",
  DFt = () => "HaÃ¯ti",
  RFt = () => "Haiti",
  BFt = () => "ãƒã‚¤ãƒ",
  FFt = () => "Haiti",
  OFt = () => "Ğ“Ğ°Ğ¸Ñ‚Ğ¸",
  qFt = () => "Ğ“Ğ°Ñ—Ñ‚Ñ–",
  NFt = () => "Haiti",
  VFt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? zFt() : t === "pt" ? AFt() : t === "ch" ? EFt() : t === "de" ? jFt() : t === "es" ? LFt() : t === "fr" ? DFt() : t === "it" ? RFt() : t === "jp" ? BFt() : t === "pl" ? FFt() : t === "ru" ? OFt() : t === "uk" ? qFt() : NFt()
  },
  UFt = () => "Heard Island and McDonald Islands",
  ZFt = () => "Ilha Heard e Ilhas McDonald",
  GFt = () => "èµ«å¾·å²›å’Œéº¦å…‹å”çº³ç¾¤å²›",
  HFt = () => "Heard- und McDonald-Inseln",
  WFt = () => "Islas Heard y McDonald",
  $Ft = () => "Ãle Heard et Ã®les McDonald",
  XFt = () => "Isole Heard e McDonald",
  YFt = () => "ãƒãƒ¼ãƒ‰å³¶ãŠã‚ˆã³ãƒã‚¯ãƒ‰ãƒŠãƒ«ãƒ‰è«¸å³¶",
  KFt = () => "Wyspy Heard i McDonalda",
  JFt = () => "ĞÑÑ‚Ñ€Ğ¾Ğ² Ğ¥ĞµÑ€Ğ´ Ğ¸ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ° ĞœĞ°ĞºĞ´Ğ¾Ğ½Ğ°Ğ»ÑŒĞ´",
  QFt = () => "ĞÑÑ‚Ñ€Ñ–Ğ² Ğ¥ĞµÑ€Ğ´ Ñ‚Ğ° Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸ ĞœĞ°ĞºĞ´Ğ¾Ğ½Ğ°Ğ»ÑŒĞ´",
  t7t = () => "Äáº£o Heard vÃ  Quáº§n Ä‘áº£o McDonald",
  e7t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? UFt() : t === "pt" ? ZFt() : t === "ch" ? GFt() : t === "de" ? HFt() : t === "es" ? WFt() : t === "fr" ? $Ft() : t === "it" ? XFt() : t === "jp" ? YFt() : t === "pl" ? KFt() : t === "ru" ? JFt() : t === "uk" ? QFt() : t7t()
  },
  r7t = () => "Honduras",
  n7t = () => "Honduras",
  i7t = () => "æ´ªéƒ½æ‹‰æ–¯",
  o7t = () => "Honduras",
  s7t = () => "Honduras",
  a7t = () => "Honduras",
  u7t = () => "Honduras",
  c7t = () => "ãƒ›ãƒ³ã‚¸ãƒ¥ãƒ©ã‚¹",
  l7t = () => "Honduras",
  _7t = () => "Ğ“Ğ¾Ğ½Ğ´ÑƒÑ€Ğ°Ñ",
  h7t = () => "Ğ“Ğ¾Ğ½Ğ´ÑƒÑ€Ğ°Ñ",
  d7t = () => "Honduras",
  p7t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? r7t() : t === "pt" ? n7t() : t === "ch" ? i7t() : t === "de" ? o7t() : t === "es" ? s7t() : t === "fr" ? a7t() : t === "it" ? u7t() : t === "jp" ? c7t() : t === "pl" ? l7t() : t === "ru" ? _7t() : t === "uk" ? h7t() : d7t()
  },
  f7t = () => "Hong Kong",
  m7t = () => "Hong Kong",
  g7t = () => "é¦™æ¸¯",
  y7t = () => "Hongkong",
  v7t = () => "Hong Kong",
  b7t = () => "Hong Kong",
  x7t = () => "Hong Kong",
  w7t = () => "é¦™æ¸¯",
  k7t = () => "Hongkong",
  T7t = () => "Ğ“Ğ¾Ğ½ĞºĞ¾Ğ½Ğ³",
  S7t = () => "Ğ“Ğ¾Ğ½ĞºĞ¾Ğ½Ğ³",
  P7t = () => "Há»“ng KÃ´ng",
  M7t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? f7t() : t === "pt" ? m7t() : t === "ch" ? g7t() : t === "de" ? y7t() : t === "es" ? v7t() : t === "fr" ? b7t() : t === "it" ? x7t() : t === "jp" ? w7t() : t === "pl" ? k7t() : t === "ru" ? T7t() : t === "uk" ? S7t() : P7t()
  },
  C7t = () => "Hungary",
  I7t = () => "Hungria",
  z7t = () => "åŒˆç‰™åˆ©",
  A7t = () => "Ungarn",
  E7t = () => "HungrÃ­a",
  j7t = () => "Hongrie",
  L7t = () => "Ungheria",
  D7t = () => "ãƒãƒ³ã‚¬ãƒªãƒ¼",
  R7t = () => "WÄ™gry",
  B7t = () => "Ğ’ĞµĞ½Ğ³Ñ€Ğ¸Ñ",
  F7t = () => "Ğ£Ğ³Ğ¾Ñ€Ñ‰Ğ¸Ğ½Ğ°",
  O7t = () => "Hungary",
  q7t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? C7t() : t === "pt" ? I7t() : t === "ch" ? z7t() : t === "de" ? A7t() : t === "es" ? E7t() : t === "fr" ? j7t() : t === "it" ? L7t() : t === "jp" ? D7t() : t === "pl" ? R7t() : t === "ru" ? B7t() : t === "uk" ? F7t() : O7t()
  },
  N7t = () => "Iceland",
  V7t = () => "IslÃ¢ndia",
  U7t = () => "å†°å²›",
  Z7t = () => "Island",
  G7t = () => "Islandia",
  H7t = () => "Islande",
  W7t = () => "Islanda",
  $7t = () => "ã‚¢ã‚¤ã‚¹ãƒ©ãƒ³ãƒ‰",
  X7t = () => "Islandia",
  Y7t = () => "Ğ˜ÑĞ»Ğ°Ğ½Ğ´Ğ¸Ñ",
  K7t = () => "Ğ†ÑĞ»Ğ°Ğ½Ğ´Ñ–Ñ",
  J7t = () => "Iceland",
  Q7t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? N7t() : t === "pt" ? V7t() : t === "ch" ? U7t() : t === "de" ? Z7t() : t === "es" ? G7t() : t === "fr" ? H7t() : t === "it" ? W7t() : t === "jp" ? $7t() : t === "pl" ? X7t() : t === "ru" ? Y7t() : t === "uk" ? K7t() : J7t()
  },
  t9t = () => "India",
  e9t = () => "Ãndia",
  r9t = () => "å°åº¦",
  n9t = () => "Indien",
  i9t = () => "India",
  o9t = () => "Inde",
  s9t = () => "India",
  a9t = () => "ã‚¤ãƒ³ãƒ‰",
  u9t = () => "Indie",
  c9t = () => "Ğ˜Ğ½Ğ´Ğ¸Ñ",
  l9t = () => "Ğ†Ğ½Ğ´Ñ–Ñ",
  _9t = () => "áº¤n Äá»™",
  h9t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? t9t() : t === "pt" ? e9t() : t === "ch" ? r9t() : t === "de" ? n9t() : t === "es" ? i9t() : t === "fr" ? o9t() : t === "it" ? s9t() : t === "jp" ? a9t() : t === "pl" ? u9t() : t === "ru" ? c9t() : t === "uk" ? l9t() : _9t()
  },
  d9t = () => "Indonesia",
  p9t = () => "IndonÃ©sia",
  f9t = () => "å°åº¦å°¼è¥¿äºš",
  m9t = () => "Indonesien",
  g9t = () => "Indonesia",
  y9t = () => "IndonÃ©sie",
  v9t = () => "Indonesia",
  b9t = () => "ã‚¤ãƒ³ãƒ‰ãƒã‚·ã‚¢",
  x9t = () => "Indonezja",
  w9t = () => "Ğ˜Ğ½Ğ´Ğ¾Ğ½ĞµĞ·Ğ¸Ñ",
  k9t = () => "Ğ†Ğ½Ğ´Ğ¾Ğ½ĞµĞ·Ñ–Ñ",
  T9t = () => "Indonesia",
  S9t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? d9t() : t === "pt" ? p9t() : t === "ch" ? f9t() : t === "de" ? m9t() : t === "es" ? g9t() : t === "fr" ? y9t() : t === "it" ? v9t() : t === "jp" ? b9t() : t === "pl" ? x9t() : t === "ru" ? w9t() : t === "uk" ? k9t() : T9t()
  },
  P9t = () => "Iran",
  M9t = () => "IrÃ£",
  C9t = () => "ä¼Šæœ—",
  I9t = () => "Iran",
  z9t = () => "IrÃ¡n",
  A9t = () => "Iran",
  E9t = () => "Iran",
  j9t = () => "ã‚¤ãƒ©ãƒ³",
  L9t = () => "Iran",
  D9t = () => "Ğ˜Ñ€Ğ°Ğ½",
  R9t = () => "Ğ†Ñ€Ğ°Ğ½",
  B9t = () => "Iran",
  F9t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? P9t() : t === "pt" ? M9t() : t === "ch" ? C9t() : t === "de" ? I9t() : t === "es" ? z9t() : t === "fr" ? A9t() : t === "it" ? E9t() : t === "jp" ? j9t() : t === "pl" ? L9t() : t === "ru" ? D9t() : t === "uk" ? R9t() : B9t()
  },
  O9t = () => "Iraq",
  q9t = () => "Iraque",
  N9t = () => "ä¼Šæ‹‰å…‹",
  V9t = () => "Irak",
  U9t = () => "Irak",
  Z9t = () => "Irak",
  G9t = () => "Iraq",
  H9t = () => "ã‚¤ãƒ©ã‚¯",
  W9t = () => "Irak",
  $9t = () => "Ğ˜Ñ€Ğ°Ğº",
  X9t = () => "Ğ†Ñ€Ğ°Ğº",
  Y9t = () => "Iraq",
  K9t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? O9t() : t === "pt" ? q9t() : t === "ch" ? N9t() : t === "de" ? V9t() : t === "es" ? U9t() : t === "fr" ? Z9t() : t === "it" ? G9t() : t === "jp" ? H9t() : t === "pl" ? W9t() : t === "ru" ? $9t() : t === "uk" ? X9t() : Y9t()
  },
  J9t = () => "Ireland",
  Q9t = () => "Irlanda",
  tOt = () => "çˆ±å°”å…°",
  eOt = () => "Irland",
  rOt = () => "Irlanda",
  nOt = () => "Irlande",
  iOt = () => "Irlanda",
  oOt = () => "ã‚¢ã‚¤ãƒ«ãƒ©ãƒ³ãƒ‰",
  sOt = () => "Irlandia",
  aOt = () => "Ğ˜Ñ€Ğ»Ğ°Ğ½Ğ´Ğ¸Ñ",
  uOt = () => "Ğ†Ñ€Ğ»Ğ°Ğ½Ğ´Ñ–Ñ",
  cOt = () => "Ireland",
  lOt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? J9t() : t === "pt" ? Q9t() : t === "ch" ? tOt() : t === "de" ? eOt() : t === "es" ? rOt() : t === "fr" ? nOt() : t === "it" ? iOt() : t === "jp" ? oOt() : t === "pl" ? sOt() : t === "ru" ? aOt() : t === "uk" ? uOt() : cOt()
  },
  _Ot = () => "Isle of Man",
  hOt = () => "Ilha de Man",
  dOt = () => "é©¬æ©å²›",
  pOt = () => "Isle of Man",
  fOt = () => "Isla de Man",
  mOt = () => "Ãle de Man",
  gOt = () => "Isola di Man",
  yOt = () => "ãƒãƒ³å³¶",
  vOt = () => "Wyspa Man",
  bOt = () => "ĞÑÑ‚Ñ€Ğ¾Ğ² ĞœÑĞ½",
  xOt = () => "ĞÑÑ‚Ñ€Ñ–Ğ² ĞœĞµĞ½",
  wOt = () => "Äáº£o Man",
  kOt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? _Ot() : t === "pt" ? hOt() : t === "ch" ? dOt() : t === "de" ? pOt() : t === "es" ? fOt() : t === "fr" ? mOt() : t === "it" ? gOt() : t === "jp" ? yOt() : t === "pl" ? vOt() : t === "ru" ? bOt() : t === "uk" ? xOt() : wOt()
  },
  TOt = () => "Israel",
  SOt = () => "Israel",
  POt = () => "ä»¥è‰²åˆ—",
  MOt = () => "Israel",
  COt = () => "Israel",
  IOt = () => "IsraÃ«l",
  zOt = () => "Israele",
  AOt = () => "ã‚¤ã‚¹ãƒ©ã‚¨ãƒ«",
  EOt = () => "Izrael",
  jOt = () => "Ğ˜Ğ·Ñ€Ğ°Ğ¸Ğ»ÑŒ",
  LOt = () => "Ğ†Ğ·Ñ€Ğ°Ñ—Ğ»ÑŒ",
  DOt = () => "Israel",
  ROt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? TOt() : t === "pt" ? SOt() : t === "ch" ? POt() : t === "de" ? MOt() : t === "es" ? COt() : t === "fr" ? IOt() : t === "it" ? zOt() : t === "jp" ? AOt() : t === "pl" ? EOt() : t === "ru" ? jOt() : t === "uk" ? LOt() : DOt()
  },
  BOt = () => "Italy",
  FOt = () => "ItÃ¡lia",
  OOt = () => "æ„å¤§åˆ©",
  qOt = () => "Italien",
  NOt = () => "Italia",
  VOt = () => "Italie",
  UOt = () => "Italia",
  ZOt = () => "ã‚¤ã‚¿ãƒªã‚¢",
  GOt = () => "WÅ‚ochy",
  HOt = () => "Ğ˜Ñ‚Ğ°Ğ»Ğ¸Ñ",
  WOt = () => "Ğ†Ñ‚Ğ°Ğ»Ñ–Ñ",
  $Ot = () => "Ã",
  XOt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? BOt() : t === "pt" ? FOt() : t === "ch" ? OOt() : t === "de" ? qOt() : t === "es" ? NOt() : t === "fr" ? VOt() : t === "it" ? UOt() : t === "jp" ? ZOt() : t === "pl" ? GOt() : t === "ru" ? HOt() : t === "uk" ? WOt() : $Ot()
  },
  YOt = () => "Jamaica",
  KOt = () => "Jamaica",
  JOt = () => "ç‰™ä¹°åŠ ",
  QOt = () => "Jamaika",
  tqt = () => "Jamaica",
  eqt = () => "JamaÃ¯que",
  rqt = () => "Giamaica",
  nqt = () => "ã‚¸ãƒ£ãƒã‚¤ã‚«",
  iqt = () => "Jamajka",
  oqt = () => "Ğ¯Ğ¼Ğ°Ğ¹ĞºĞ°",
  sqt = () => "Ğ¯Ğ¼Ğ°Ğ¹ĞºĞ°",
  aqt = () => "Jamaica",
  uqt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? YOt() : t === "pt" ? KOt() : t === "ch" ? JOt() : t === "de" ? QOt() : t === "es" ? tqt() : t === "fr" ? eqt() : t === "it" ? rqt() : t === "jp" ? nqt() : t === "pl" ? iqt() : t === "ru" ? oqt() : t === "uk" ? sqt() : aqt()
  },
  cqt = () => "Japan",
  lqt = () => "JapÃ£o",
  _qt = () => "æ—¥æœ¬",
  hqt = () => "Japan",
  dqt = () => "JapÃ³n",
  pqt = () => "Japon",
  fqt = () => "Giappone",
  mqt = () => "æ—¥æœ¬",
  gqt = () => "Japonia",
  yqt = () => "Ğ¯Ğ¿Ğ¾Ğ½Ğ¸Ñ",
  vqt = () => "Ğ¯Ğ¿Ğ¾Ğ½Ñ–Ñ",
  bqt = () => "Nháº­t Báº£n",
  xqt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? cqt() : t === "pt" ? lqt() : t === "ch" ? _qt() : t === "de" ? hqt() : t === "es" ? dqt() : t === "fr" ? pqt() : t === "it" ? fqt() : t === "jp" ? mqt() : t === "pl" ? gqt() : t === "ru" ? yqt() : t === "uk" ? vqt() : bqt()
  },
  wqt = () => "Jersey",
  kqt = () => "Camisa",
  Tqt = () => "æ³½è¥¿",
  Sqt = () => "Jersey",
  Pqt = () => "Jersey",
  Mqt = () => "Jersey",
  Cqt = () => "Maglia",
  Iqt = () => "ã‚¸ãƒ£ãƒ¼ã‚¸",
  zqt = () => "dÅ¼ersej",
  Aqt = () => "Ğ”Ğ¶ĞµÑ€ÑĞ¸",
  Eqt = () => "Ğ”Ğ¶ĞµÑ€ÑÑ–",
  jqt = () => "Ão jersey",
  Lqt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? wqt() : t === "pt" ? kqt() : t === "ch" ? Tqt() : t === "de" ? Sqt() : t === "es" ? Pqt() : t === "fr" ? Mqt() : t === "it" ? Cqt() : t === "jp" ? Iqt() : t === "pl" ? zqt() : t === "ru" ? Aqt() : t === "uk" ? Eqt() : jqt()
  },
  Dqt = () => "Jordan",
  Rqt = () => "JordÃ¢nia",
  Bqt = () => "çº¦æ—¦",
  Fqt = () => "Jordanien",
  Oqt = () => "Jordania",
  qqt = () => "Jordanie",
  Nqt = () => "Giordania",
  Vqt = () => "ãƒ¨ãƒ«ãƒ€ãƒ³",
  Uqt = () => "Jordania",
  Zqt = () => "Ğ˜Ğ¾Ñ€Ğ´Ğ°Ğ½Ğ¸Ñ",
  Gqt = () => "Ğ™Ğ¾Ñ€Ğ´Ğ°Ğ½Ñ–Ñ",
  Hqt = () => "Jordan",
  Wqt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Dqt() : t === "pt" ? Rqt() : t === "ch" ? Bqt() : t === "de" ? Fqt() : t === "es" ? Oqt() : t === "fr" ? qqt() : t === "it" ? Nqt() : t === "jp" ? Vqt() : t === "pl" ? Uqt() : t === "ru" ? Zqt() : t === "uk" ? Gqt() : Hqt()
  },
  $qt = () => "Kazakhstan",
  Xqt = () => "CazaquistÃ£o",
  Yqt = () => "å“ˆè¨å…‹æ–¯å¦",
  Kqt = () => "Kasachstan",
  Jqt = () => "KazajistÃ¡n",
  Qqt = () => "Kazakhstan",
  tNt = () => "Kazakistan",
  eNt = () => "ã‚«ã‚¶ãƒ•ã‚¹ã‚¿ãƒ³",
  rNt = () => "Kazachstan",
  nNt = () => "ĞšĞ°Ğ·Ğ°Ñ…ÑÑ‚Ğ°Ğ½",
  iNt = () => "ĞšĞ°Ğ·Ğ°Ñ…ÑÑ‚Ğ°Ğ½",
  oNt = () => "Kazakhstan",
  sNt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $qt() : t === "pt" ? Xqt() : t === "ch" ? Yqt() : t === "de" ? Kqt() : t === "es" ? Jqt() : t === "fr" ? Qqt() : t === "it" ? tNt() : t === "jp" ? eNt() : t === "pl" ? rNt() : t === "ru" ? nNt() : t === "uk" ? iNt() : oNt()
  },
  aNt = () => "Kenya",
  uNt = () => "QuÃªnia",
  cNt = () => "è‚¯å°¼äºš",
  lNt = () => "Kenia",
  _Nt = () => "Kenia",
  hNt = () => "Kenya",
  dNt = () => "Kenya",
  pNt = () => "ã‚±ãƒ‹ã‚¢",
  fNt = () => "Kenia",
  mNt = () => "ĞšĞµĞ½Ğ¸Ñ",
  gNt = () => "ĞšĞµĞ½Ñ–Ñ",
  yNt = () => "Kenya",
  vNt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? aNt() : t === "pt" ? uNt() : t === "ch" ? cNt() : t === "de" ? lNt() : t === "es" ? _Nt() : t === "fr" ? hNt() : t === "it" ? dNt() : t === "jp" ? pNt() : t === "pl" ? fNt() : t === "ru" ? mNt() : t === "uk" ? gNt() : yNt()
  },
  bNt = () => "Kiribati",
  xNt = () => "Kiribati",
  wNt = () => "åŸºé‡Œå·´æ–¯",
  kNt = () => "Kiribati",
  TNt = () => "Kiribati",
  SNt = () => "Kiribati",
  PNt = () => "Kiribati",
  MNt = () => "ã‚­ãƒªãƒã‚¹",
  CNt = () => "Kiribati",
  INt = () => "ĞšĞ¸Ñ€Ğ¸Ğ±Ğ°Ñ‚Ğ¸",
  zNt = () => "ĞšÑ–Ñ€Ğ¸Ğ±Ğ°Ñ‚Ñ–",
  ANt = () => "Kiribati",
  ENt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? bNt() : t === "pt" ? xNt() : t === "ch" ? wNt() : t === "de" ? kNt() : t === "es" ? TNt() : t === "fr" ? SNt() : t === "it" ? PNt() : t === "jp" ? MNt() : t === "pl" ? CNt() : t === "ru" ? INt() : t === "uk" ? zNt() : ANt()
  },
  jNt = () => "Kosovo",
  LNt = () => "Kosovo",
  DNt = () => "ç§‘ç´¢æ²ƒ",
  RNt = () => "Kosovo",
  BNt = () => "Kosovo",
  FNt = () => "Kosovo",
  ONt = () => "Kosovo",
  qNt = () => "ã‚³ã‚½ãƒœ",
  NNt = () => "Kosowo",
  VNt = () => "ĞšĞ¾ÑĞ¾Ğ²Ğ¾",
  UNt = () => "ĞšĞ¾ÑĞ¾Ğ²Ğ¾",
  ZNt = () => "Kosovo",
  GNt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? jNt() : t === "pt" ? LNt() : t === "ch" ? DNt() : t === "de" ? RNt() : t === "es" ? BNt() : t === "fr" ? FNt() : t === "it" ? ONt() : t === "jp" ? qNt() : t === "pl" ? NNt() : t === "ru" ? VNt() : t === "uk" ? UNt() : ZNt()
  },
  HNt = () => "Kuwait",
  WNt = () => "Kuwait",
  $Nt = () => "ç§‘å¨ç‰¹",
  XNt = () => "Kuwait",
  YNt = () => "Kuwait",
  KNt = () => "KoweÃ¯t",
  JNt = () => "Kuwait",
  QNt = () => "ã‚¯ã‚¦ã‚§ãƒ¼ãƒˆ",
  tVt = () => "Kuwejt",
  eVt = () => "ĞšÑƒĞ²ĞµĞ¹Ñ‚",
  rVt = () => "ĞšÑƒĞ²ĞµĞ¹Ñ‚",
  nVt = () => "CÃ´-oÃ©t",
  iVt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? HNt() : t === "pt" ? WNt() : t === "ch" ? $Nt() : t === "de" ? XNt() : t === "es" ? YNt() : t === "fr" ? KNt() : t === "it" ? JNt() : t === "jp" ? QNt() : t === "pl" ? tVt() : t === "ru" ? eVt() : t === "uk" ? rVt() : nVt()
  },
  oVt = () => "Kyrgyzstan",
  sVt = () => "QuirguistÃ£o",
  aVt = () => "å‰å°”å‰æ–¯æ–¯å¦",
  uVt = () => "Kirgisistan",
  cVt = () => "KirguistÃ¡n",
  lVt = () => "Kirghizistan",
  _Vt = () => "Kirghizistan",
  hVt = () => "ã‚­ãƒ«ã‚®ã‚¹",
  dVt = () => "Kirgistan",
  pVt = () => "ĞšÑ‹Ñ€Ğ³Ñ‹Ğ·ÑÑ‚Ğ°Ğ½",
  fVt = () => "ĞšĞ¸Ñ€Ğ³Ğ¸Ğ·ÑÑ‚Ğ°Ğ½",
  mVt = () => "Kyrgyzstan",
  gVt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? oVt() : t === "pt" ? sVt() : t === "ch" ? aVt() : t === "de" ? uVt() : t === "es" ? cVt() : t === "fr" ? lVt() : t === "it" ? _Vt() : t === "jp" ? hVt() : t === "pl" ? dVt() : t === "ru" ? pVt() : t === "uk" ? fVt() : mVt()
  },
  yVt = () => "Laos",
  vVt = () => "Laos",
  bVt = () => "è€æŒ",
  xVt = () => "Laos",
  wVt = () => "Laos",
  kVt = () => "Laos",
  TVt = () => "Laos",
  SVt = () => "ãƒ©ã‚ªã‚¹",
  PVt = () => "Laos",
  MVt = () => "Ğ›Ğ°Ğ¾Ñ",
  CVt = () => "Ğ›Ğ°Ğ¾Ñ",
  IVt = () => "LÃ o",
  zVt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? yVt() : t === "pt" ? vVt() : t === "ch" ? bVt() : t === "de" ? xVt() : t === "es" ? wVt() : t === "fr" ? kVt() : t === "it" ? TVt() : t === "jp" ? SVt() : t === "pl" ? PVt() : t === "ru" ? MVt() : t === "uk" ? CVt() : IVt()
  },
  AVt = () => "Latvia",
  EVt = () => "LetÃ´nia",
  jVt = () => "æ‹‰è„±ç»´äºš",
  LVt = () => "Lettland",
  DVt = () => "Letonia",
  RVt = () => "Lettonie",
  BVt = () => "Lettonia",
  FVt = () => "ãƒ©ãƒˆãƒ“ã‚¢",
  OVt = () => "Åotwa",
  qVt = () => "Ğ›Ğ°Ñ‚Ğ²Ğ¸Ñ",
  NVt = () => "Ğ›Ğ°Ñ‚Ğ²Ñ–Ñ",
  VVt = () => "Latvia",
  UVt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? AVt() : t === "pt" ? EVt() : t === "ch" ? jVt() : t === "de" ? LVt() : t === "es" ? DVt() : t === "fr" ? RVt() : t === "it" ? BVt() : t === "jp" ? FVt() : t === "pl" ? OVt() : t === "ru" ? qVt() : t === "uk" ? NVt() : VVt()
  },
  ZVt = () => "Lebanon",
  GVt = () => "LÃ­bano",
  HVt = () => "é»å·´å«©",
  WVt = () => "Libanon",
  $Vt = () => "LÃ­bano",
  XVt = () => "Liban",
  YVt = () => "Libano",
  KVt = () => "ãƒ¬ãƒãƒãƒ³",
  JVt = () => "Liban",
  QVt = () => "Ğ›Ğ¸Ğ²Ğ°Ğ½",
  tUt = () => "Ğ›Ñ–Ğ²Ğ°Ğ½",
  eUt = () => "Li BÄƒng",
  rUt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ZVt() : t === "pt" ? GVt() : t === "ch" ? HVt() : t === "de" ? WVt() : t === "es" ? $Vt() : t === "fr" ? XVt() : t === "it" ? YVt() : t === "jp" ? KVt() : t === "pl" ? JVt() : t === "ru" ? QVt() : t === "uk" ? tUt() : eUt()
  },
  nUt = () => "Lesotho",
  iUt = () => "Lesotho",
  oUt = () => "è±ç´¢æ‰˜",
  sUt = () => "Lesotho",
  aUt = () => "Lesoto",
  uUt = () => "Lesotho",
  cUt = () => "Lesotho",
  lUt = () => "ãƒ¬ã‚½ãƒˆ",
  _Ut = () => "Lesotho",
  hUt = () => "Ğ›ĞµÑĞ¾Ñ‚Ğ¾",
  dUt = () => "Ğ›ĞµÑĞ¾Ñ‚Ğ¾",
  pUt = () => "Lesotho",
  fUt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? nUt() : t === "pt" ? iUt() : t === "ch" ? oUt() : t === "de" ? sUt() : t === "es" ? aUt() : t === "fr" ? uUt() : t === "it" ? cUt() : t === "jp" ? lUt() : t === "pl" ? _Ut() : t === "ru" ? hUt() : t === "uk" ? dUt() : pUt()
  },
  mUt = () => "Liberia",
  gUt = () => "LibÃ©ria",
  yUt = () => "åˆ©æ¯”é‡Œäºš",
  vUt = () => "Liberia",
  bUt = () => "Liberia",
  xUt = () => "LibÃ©ria",
  wUt = () => "Liberia",
  kUt = () => "ãƒªãƒ™ãƒªã‚¢",
  TUt = () => "Liberia",
  SUt = () => "Ğ›Ğ¸Ğ±ĞµÑ€Ğ¸Ñ",
  PUt = () => "Ğ›Ñ–Ğ±ĞµÑ€Ñ–Ñ",
  MUt = () => "Liberia",
  CUt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mUt() : t === "pt" ? gUt() : t === "ch" ? yUt() : t === "de" ? vUt() : t === "es" ? bUt() : t === "fr" ? xUt() : t === "it" ? wUt() : t === "jp" ? kUt() : t === "pl" ? TUt() : t === "ru" ? SUt() : t === "uk" ? PUt() : MUt()
  },
  IUt = () => "Libya",
  zUt = () => "LÃ­bia",
  AUt = () => "åˆ©æ¯”äºš",
  EUt = () => "Libyen",
  jUt = () => "Libia",
  LUt = () => "Libye",
  DUt = () => "Libia",
  RUt = () => "ãƒªãƒ“ã‚¢",
  BUt = () => "Libia",
  FUt = () => "Ğ›Ğ¸Ğ²Ğ¸Ñ",
  OUt = () => "Ğ›Ñ–Ğ²Ñ–Ñ",
  qUt = () => "Libya",
  NUt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? IUt() : t === "pt" ? zUt() : t === "ch" ? AUt() : t === "de" ? EUt() : t === "es" ? jUt() : t === "fr" ? LUt() : t === "it" ? DUt() : t === "jp" ? RUt() : t === "pl" ? BUt() : t === "ru" ? FUt() : t === "uk" ? OUt() : qUt()
  },
  VUt = () => "Liechtenstein",
  UUt = () => "Liechtenstein",
  ZUt = () => "åˆ—æ”¯æ•¦å£«ç™»",
  GUt = () => "Liechtenstein",
  HUt = () => "Liechtenstein",
  WUt = () => "Liechtenstein",
  $Ut = () => "Liechtenstein",
  XUt = () => "ãƒªãƒ’ãƒ†ãƒ³ã‚·ãƒ¥ã‚¿ã‚¤ãƒ³",
  YUt = () => "Liechtenstein",
  KUt = () => "Ğ›Ğ¸Ñ…Ñ‚ĞµĞ½ÑˆÑ‚ĞµĞ¹Ğ½",
  JUt = () => "Ğ›Ñ–Ñ…Ñ‚ĞµĞ½ÑˆÑ‚ĞµĞ¹Ğ½",
  QUt = () => "Liechtenstein",
  tZt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? VUt() : t === "pt" ? UUt() : t === "ch" ? ZUt() : t === "de" ? GUt() : t === "es" ? HUt() : t === "fr" ? WUt() : t === "it" ? $Ut() : t === "jp" ? XUt() : t === "pl" ? YUt() : t === "ru" ? KUt() : t === "uk" ? JUt() : QUt()
  },
  eZt = () => "Lithuania",
  rZt = () => "LituÃ¢nia",
  nZt = () => "ç«‹é™¶å®›",
  iZt = () => "Litauen",
  oZt = () => "Lituania",
  sZt = () => "Lituanie",
  aZt = () => "Lituania",
  uZt = () => "ãƒªãƒˆã‚¢ãƒ‹ã‚¢",
  cZt = () => "Litwa",
  lZt = () => "Ğ›Ğ¸Ñ‚Ğ²Ğ°",
  _Zt = () => "Ğ›Ğ¸Ñ‚Ğ²Ğ°",
  hZt = () => "Litva",
  dZt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? eZt() : t === "pt" ? rZt() : t === "ch" ? nZt() : t === "de" ? iZt() : t === "es" ? oZt() : t === "fr" ? sZt() : t === "it" ? aZt() : t === "jp" ? uZt() : t === "pl" ? cZt() : t === "ru" ? lZt() : t === "uk" ? _Zt() : hZt()
  },
  pZt = () => "Luxembourg",
  fZt = () => "Luxemburgo",
  mZt = () => "å¢æ£®å ¡",
  gZt = () => "Luxemburg",
  yZt = () => "Luxemburgo",
  vZt = () => "Luxembourg",
  bZt = () => "Lussemburgo",
  xZt = () => "ãƒ«ã‚¯ã‚»ãƒ³ãƒ–ãƒ«ã‚¯",
  wZt = () => "Luksemburg",
  kZt = () => "Ğ›ÑĞºÑĞµĞ¼Ğ±ÑƒÑ€Ğ³",
  TZt = () => "Ğ›ÑĞºÑĞµĞ¼Ğ±ÑƒÑ€Ğ³",
  SZt = () => "Luxembourg",
  PZt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pZt() : t === "pt" ? fZt() : t === "ch" ? mZt() : t === "de" ? gZt() : t === "es" ? yZt() : t === "fr" ? vZt() : t === "it" ? bZt() : t === "jp" ? xZt() : t === "pl" ? wZt() : t === "ru" ? kZt() : t === "uk" ? TZt() : SZt()
  },
  MZt = () => "Macao",
  CZt = () => "Macau",
  IZt = () => "æ¾³é—¨",
  zZt = () => "Macau",
  AZt = () => "Macao",
  EZt = () => "Macao",
  jZt = () => "Macao",
  LZt = () => "ãƒã‚«ã‚ª",
  DZt = () => "Makau",
  RZt = () => "ĞœĞ°ĞºĞ°Ğ¾",
  BZt = () => "ĞœĞ°ĞºĞ°Ğ¾",
  FZt = () => "Ma Cao",
  OZt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? MZt() : t === "pt" ? CZt() : t === "ch" ? IZt() : t === "de" ? zZt() : t === "es" ? AZt() : t === "fr" ? EZt() : t === "it" ? jZt() : t === "jp" ? LZt() : t === "pl" ? DZt() : t === "ru" ? RZt() : t === "uk" ? BZt() : FZt()
  },
  qZt = () => "Madagascar",
  NZt = () => "Madagascar",
  VZt = () => "é©¬è¾¾åŠ æ–¯åŠ ",
  UZt = () => "Madagaskar",
  ZZt = () => "Madagascar",
  GZt = () => "Madagascar",
  HZt = () => "Madagascar",
  WZt = () => "ãƒãƒ€ã‚¬ã‚¹ã‚«ãƒ«",
  $Zt = () => "Madagaskar",
  XZt = () => "ĞœĞ°Ğ´Ğ°Ğ³Ğ°ÑĞºĞ°Ñ€",
  YZt = () => "ĞœĞ°Ğ´Ğ°Ğ³Ğ°ÑĞºĞ°Ñ€",
  KZt = () => "Madagascar",
  JZt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qZt() : t === "pt" ? NZt() : t === "ch" ? VZt() : t === "de" ? UZt() : t === "es" ? ZZt() : t === "fr" ? GZt() : t === "it" ? HZt() : t === "jp" ? WZt() : t === "pl" ? $Zt() : t === "ru" ? XZt() : t === "uk" ? YZt() : KZt()
  },
  QZt = () => "Malawi",
  tGt = () => "Malawi",
  eGt = () => "é©¬æ‹‰ç»´",
  rGt = () => "Malawi",
  nGt = () => "Malawi",
  iGt = () => "Malawi",
  oGt = () => "Malawi",
  sGt = () => "ãƒãƒ©ã‚¦ã‚¤",
  aGt = () => "Malawi",
  uGt = () => "ĞœĞ°Ğ»Ğ°Ğ²Ğ¸",
  cGt = () => "ĞœĞ°Ğ»Ğ°Ğ²Ñ–",
  lGt = () => "Malawi",
  _Gt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? QZt() : t === "pt" ? tGt() : t === "ch" ? eGt() : t === "de" ? rGt() : t === "es" ? nGt() : t === "fr" ? iGt() : t === "it" ? oGt() : t === "jp" ? sGt() : t === "pl" ? aGt() : t === "ru" ? uGt() : t === "uk" ? cGt() : lGt()
  },
  hGt = () => "Malaysia",
  dGt = () => "MalÃ¡sia",
  pGt = () => "é©¬æ¥è¥¿äºš",
  fGt = () => "Malaysia",
  mGt = () => "Malasia",
  gGt = () => "Malaisie",
  yGt = () => "Malesia",
  vGt = () => "ãƒãƒ¬ãƒ¼ã‚·ã‚¢",
  bGt = () => "Malezja",
  xGt = () => "ĞœĞ°Ğ»Ğ°Ğ¹Ğ·Ğ¸Ñ",
  wGt = () => "ĞœĞ°Ğ»Ğ°Ğ¹Ğ·Ñ–Ñ",
  kGt = () => "Malaysia",
  TGt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hGt() : t === "pt" ? dGt() : t === "ch" ? pGt() : t === "de" ? fGt() : t === "es" ? mGt() : t === "fr" ? gGt() : t === "it" ? yGt() : t === "jp" ? vGt() : t === "pl" ? bGt() : t === "ru" ? xGt() : t === "uk" ? wGt() : kGt()
  },
  SGt = () => "Maldives",
  PGt = () => "Maldivas",
  MGt = () => "é©¬å°”ä»£å¤«",
  CGt = () => "Malediven",
  IGt = () => "Maldivas",
  zGt = () => "Maldives",
  AGt = () => "Maldive",
  EGt = () => "ãƒ¢ãƒ«ãƒ‡ã‚£ãƒ–",
  jGt = () => "Malediwy",
  LGt = () => "ĞœĞ°Ğ»ÑŒĞ´Ğ¸Ğ²Ñ‹",
  DGt = () => "ĞœĞ°Ğ»ÑŒĞ´Ñ–Ğ²Ğ¸",
  RGt = () => "Maldives",
  BGt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? SGt() : t === "pt" ? PGt() : t === "ch" ? MGt() : t === "de" ? CGt() : t === "es" ? IGt() : t === "fr" ? zGt() : t === "it" ? AGt() : t === "jp" ? EGt() : t === "pl" ? jGt() : t === "ru" ? LGt() : t === "uk" ? DGt() : RGt()
  },
  FGt = () => "Mali",
  OGt = () => "Mali",
  qGt = () => "é©¬é‡Œ",
  NGt = () => "Mali",
  VGt = () => "MalÃ­",
  UGt = () => "Mali",
  ZGt = () => "Mali",
  GGt = () => "ãƒãƒª",
  HGt = () => "Mali",
  WGt = () => "ĞœĞ°Ğ»Ğ¸",
  $Gt = () => "ĞœĞ°Ğ»Ñ–",
  XGt = () => "Mali",
  YGt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? FGt() : t === "pt" ? OGt() : t === "ch" ? qGt() : t === "de" ? NGt() : t === "es" ? VGt() : t === "fr" ? UGt() : t === "it" ? ZGt() : t === "jp" ? GGt() : t === "pl" ? HGt() : t === "ru" ? WGt() : t === "uk" ? $Gt() : XGt()
  },
  KGt = () => "Malta",
  JGt = () => "Malta",
  QGt = () => "é©¬è€³ä»–",
  tHt = () => "Malta",
  eHt = () => "Malta",
  rHt = () => "Malte",
  nHt = () => "Malta",
  iHt = () => "ãƒãƒ«ã‚¿",
  oHt = () => "Malta",
  sHt = () => "ĞœĞ°Ğ»ÑŒÑ‚Ğ°",
  aHt = () => "ĞœĞ°Ğ»ÑŒÑ‚Ğ°",
  uHt = () => "Malta",
  cHt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? KGt() : t === "pt" ? JGt() : t === "ch" ? QGt() : t === "de" ? tHt() : t === "es" ? eHt() : t === "fr" ? rHt() : t === "it" ? nHt() : t === "jp" ? iHt() : t === "pl" ? oHt() : t === "ru" ? sHt() : t === "uk" ? aHt() : uHt()
  },
  lHt = () => "Marshall Islands",
  _Ht = () => "Ilhas Marshall",
  hHt = () => "é©¬ç»å°”ç¾¤å²›",
  dHt = () => "Marshallinseln",
  pHt = () => "Islas Marshall",
  fHt = () => "Ãles Marshall",
  mHt = () => "Isole Marshall",
  gHt = () => "ãƒãƒ¼ã‚·ãƒ£ãƒ«è«¸å³¶",
  yHt = () => "Wyspy Marshalla",
  vHt = () => "ĞœĞ°Ñ€ÑˆĞ°Ğ»Ğ»Ğ¾Ğ²Ñ‹ ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  bHt = () => "ĞœĞ°Ñ€ÑˆĞ°Ğ»Ğ»Ğ¾Ğ²Ñ– ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  xHt = () => "Quáº§n Ä‘áº£o Marshall",
  wHt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lHt() : t === "pt" ? _Ht() : t === "ch" ? hHt() : t === "de" ? dHt() : t === "es" ? pHt() : t === "fr" ? fHt() : t === "it" ? mHt() : t === "jp" ? gHt() : t === "pl" ? yHt() : t === "ru" ? vHt() : t === "uk" ? bHt() : xHt()
  },
  kHt = () => "Martinique",
  THt = () => "Martinica",
  SHt = () => "é©¬æå°¼å…‹",
  PHt = () => "Martinique",
  MHt = () => "Martinica",
  CHt = () => "Martinique",
  IHt = () => "Martinica",
  zHt = () => "ãƒãƒ«ãƒ†ã‚£ãƒ‹ãƒ¼ã‚¯",
  AHt = () => "Martynika",
  EHt = () => "ĞœĞ°Ñ€Ñ‚Ğ¸Ğ½Ğ¸ĞºĞ°",
  jHt = () => "ĞœĞ°Ñ€Ñ‚Ğ¸Ğ½Ñ–ĞºĞ°",
  LHt = () => "Martinique",
  DHt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kHt() : t === "pt" ? THt() : t === "ch" ? SHt() : t === "de" ? PHt() : t === "es" ? MHt() : t === "fr" ? CHt() : t === "it" ? IHt() : t === "jp" ? zHt() : t === "pl" ? AHt() : t === "ru" ? EHt() : t === "uk" ? jHt() : LHt()
  },
  RHt = () => "Mauritania",
  BHt = () => "MauritÃ¢nia",
  FHt = () => "æ¯›é‡Œå¡”å°¼äºš",
  OHt = () => "Mauretanien",
  qHt = () => "Mauritania",
  NHt = () => "Mauritanie",
  VHt = () => "Mauritania",
  UHt = () => "ãƒ¢ãƒ¼ãƒªã‚¿ãƒ‹ã‚¢",
  ZHt = () => "Mauretania",
  GHt = () => "ĞœĞ°Ğ²Ñ€Ğ¸Ñ‚Ğ°Ğ½Ğ¸Ñ",
  HHt = () => "ĞœĞ°Ğ²Ñ€Ğ¸Ñ‚Ğ°Ğ½Ñ–Ñ",
  WHt = () => "Mauritania",
  $Ht = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? RHt() : t === "pt" ? BHt() : t === "ch" ? FHt() : t === "de" ? OHt() : t === "es" ? qHt() : t === "fr" ? NHt() : t === "it" ? VHt() : t === "jp" ? UHt() : t === "pl" ? ZHt() : t === "ru" ? GHt() : t === "uk" ? HHt() : WHt()
  },
  XHt = () => "Mauritius",
  YHt = () => "MaurÃ­cio",
  KHt = () => "æ¯›é‡Œæ±‚æ–¯",
  JHt = () => "Mauritius",
  QHt = () => "Mauricio",
  tWt = () => "Maurice",
  eWt = () => "Mauritius",
  rWt = () => "ãƒ¢ãƒ¼ãƒªã‚·ãƒ£ã‚¹",
  nWt = () => "Mauritius",
  iWt = () => "ĞœĞ°Ğ²Ñ€Ğ¸ĞºĞ¸Ğ¹",
  oWt = () => "ĞœĞ°Ğ²Ñ€Ğ¸ĞºÑ–Ğ¹",
  sWt = () => "Mauritius",
  aWt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? XHt() : t === "pt" ? YHt() : t === "ch" ? KHt() : t === "de" ? JHt() : t === "es" ? QHt() : t === "fr" ? tWt() : t === "it" ? eWt() : t === "jp" ? rWt() : t === "pl" ? nWt() : t === "ru" ? iWt() : t === "uk" ? oWt() : sWt()
  },
  uWt = () => "Mayotte",
  cWt = () => "Mayotte",
  lWt = () => "é©¬çº¦ç‰¹",
  _Wt = () => "Mayotte",
  hWt = () => "Mayotte",
  dWt = () => "Mayotte",
  pWt = () => "Mayotte",
  fWt = () => "ãƒãƒ¨ãƒƒãƒˆ",
  mWt = () => "Majotta",
  gWt = () => "ĞœĞ°Ğ¹Ğ¾Ñ‚Ñ‚Ğ°",
  yWt = () => "ĞœĞ°Ğ¹Ğ¾Ñ‚Ñ‚Ğ°",
  vWt = () => "Mayotte",
  bWt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? uWt() : t === "pt" ? cWt() : t === "ch" ? lWt() : t === "de" ? _Wt() : t === "es" ? hWt() : t === "fr" ? dWt() : t === "it" ? pWt() : t === "jp" ? fWt() : t === "pl" ? mWt() : t === "ru" ? gWt() : t === "uk" ? yWt() : vWt()
  },
  xWt = () => "Mexico",
  wWt = () => "MÃ©xico",
  kWt = () => "å¢¨è¥¿å“¥",
  TWt = () => "Mexiko",
  SWt = () => "MÃ©xico",
  PWt = () => "Mexique",
  MWt = () => "Messico",
  CWt = () => "ãƒ¡ã‚­ã‚·ã‚³",
  IWt = () => "Meksyk",
  zWt = () => "ĞœĞµĞºÑĞ¸ĞºĞ°",
  AWt = () => "ĞœĞµĞºÑĞ¸ĞºĞ°",
  EWt = () => "Mexico",
  jWt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xWt() : t === "pt" ? wWt() : t === "ch" ? kWt() : t === "de" ? TWt() : t === "es" ? SWt() : t === "fr" ? PWt() : t === "it" ? MWt() : t === "jp" ? CWt() : t === "pl" ? IWt() : t === "ru" ? zWt() : t === "uk" ? AWt() : EWt()
  },
  LWt = () => "Micronesia",
  DWt = () => "MicronÃ©sia",
  RWt = () => "å¯†å…‹ç½—å°¼è¥¿äºš",
  BWt = () => "Mikronesien",
  FWt = () => "Micronesia",
  OWt = () => "MicronÃ©sie",
  qWt = () => "Micronesia",
  NWt = () => "ãƒŸã‚¯ãƒ­ãƒã‚·ã‚¢",
  VWt = () => "Mikronezja",
  UWt = () => "ĞœĞ¸ĞºÑ€Ğ¾Ğ½ĞµĞ·Ğ¸Ñ",
  ZWt = () => "ĞœÑ–ĞºÑ€Ğ¾Ğ½ĞµĞ·Ñ–Ñ",
  GWt = () => "LiÃªn bang Micronesia",
  HWt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? LWt() : t === "pt" ? DWt() : t === "ch" ? RWt() : t === "de" ? BWt() : t === "es" ? FWt() : t === "fr" ? OWt() : t === "it" ? qWt() : t === "jp" ? NWt() : t === "pl" ? VWt() : t === "ru" ? UWt() : t === "uk" ? ZWt() : GWt()
  },
  WWt = () => "Moldova",
  $Wt = () => "MoldÃ¡via",
  XWt = () => "æ‘©å°”å¤šç“¦",
  YWt = () => "Moldau",
  KWt = () => "Moldavia",
  JWt = () => "Moldavie",
  QWt = () => "Moldavia",
  t$t = () => "ãƒ¢ãƒ«ãƒ‰ãƒ",
  e$t = () => "MoÅ‚dawia",
  r$t = () => "ĞœĞ¾Ğ»Ğ´Ğ¾Ğ²Ğ°",
  n$t = () => "ĞœĞ¾Ğ»Ğ´Ğ¾Ğ²Ğ°",
  i$t = () => "Moldova",
  o$t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? WWt() : t === "pt" ? $Wt() : t === "ch" ? XWt() : t === "de" ? YWt() : t === "es" ? KWt() : t === "fr" ? JWt() : t === "it" ? QWt() : t === "jp" ? t$t() : t === "pl" ? e$t() : t === "ru" ? r$t() : t === "uk" ? n$t() : i$t()
  },
  s$t = () => "Monaco",
  a$t = () => "MÃ´naco",
  u$t = () => "æ‘©çº³å“¥",
  c$t = () => "Monaco",
  l$t = () => "MÃ³naco",
  _$t = () => "Monaco",
  h$t = () => "Monaco",
  d$t = () => "ãƒ¢ãƒŠã‚³",
  p$t = () => "Monako",
  f$t = () => "ĞœĞ¾Ğ½Ğ°ĞºĞ¾",
  m$t = () => "ĞœĞ¾Ğ½Ğ°ĞºĞ¾",
  g$t = () => "Monaco",
  y$t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? s$t() : t === "pt" ? a$t() : t === "ch" ? u$t() : t === "de" ? c$t() : t === "es" ? l$t() : t === "fr" ? _$t() : t === "it" ? h$t() : t === "jp" ? d$t() : t === "pl" ? p$t() : t === "ru" ? f$t() : t === "uk" ? m$t() : g$t()
  },
  v$t = () => "Mongolia",
  b$t = () => "MongÃ³lia",
  x$t = () => "è’™å¤",
  w$t = () => "Mongolei",
  k$t = () => "Mongolia",
  T$t = () => "Mongolie",
  S$t = () => "Mongolia",
  P$t = () => "ãƒ¢ãƒ³ã‚´ãƒ«",
  M$t = () => "Mongolia",
  C$t = () => "ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»Ğ¸Ñ",
  I$t = () => "ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»Ñ–Ñ",
  z$t = () => "MÃ´ng Cá»•",
  A$t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? v$t() : t === "pt" ? b$t() : t === "ch" ? x$t() : t === "de" ? w$t() : t === "es" ? k$t() : t === "fr" ? T$t() : t === "it" ? S$t() : t === "jp" ? P$t() : t === "pl" ? M$t() : t === "ru" ? C$t() : t === "uk" ? I$t() : z$t()
  },
  E$t = () => "Montenegro",
  j$t = () => "Montenegro",
  L$t = () => "é»‘å±±",
  D$t = () => "Montenegro",
  R$t = () => "Montenegro",
  B$t = () => "MontÃ©nÃ©gro",
  F$t = () => "Montenegro",
  O$t = () => "ãƒ¢ãƒ³ãƒ†ãƒã‚°ãƒ­",
  q$t = () => "CzarnogÃ³ra",
  N$t = () => "Ğ§ĞµÑ€Ğ½Ğ¾Ğ³Ğ¾Ñ€Ğ¸Ñ",
  V$t = () => "Ğ§Ğ¾Ñ€Ğ½Ğ¾Ğ³Ğ¾Ñ€Ñ–Ñ",
  U$t = () => "Montenegro",
  Z$t = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? E$t() : t === "pt" ? j$t() : t === "ch" ? L$t() : t === "de" ? D$t() : t === "es" ? R$t() : t === "fr" ? B$t() : t === "it" ? F$t() : t === "jp" ? O$t() : t === "pl" ? q$t() : t === "ru" ? N$t() : t === "uk" ? V$t() : U$t()
  },
  G$t = () => "Montserrat",
  H$t = () => "Montserrat",
  W$t = () => "è’™ç‰¹å¡æ‹‰ç‰¹",
  $$t = () => "Montserrat",
  X$t = () => "Montserrat",
  Y$t = () => "Montserrat",
  K$t = () => "Montserrat",
  J$t = () => "ãƒ¢ãƒ³ãƒˆã‚»ãƒ©ãƒˆ",
  Q$t = () => "Montserrat",
  tXt = () => "ĞœĞ¾Ğ½Ñ‚ÑĞµÑ€Ñ€Ğ°Ñ‚",
  eXt = () => "ĞœĞ¾Ğ½Ñ‚ÑĞµÑ€Ñ€Ğ°Ñ‚",
  rXt = () => "Montserrat",
  nXt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? G$t() : t === "pt" ? H$t() : t === "ch" ? W$t() : t === "de" ? $$t() : t === "es" ? X$t() : t === "fr" ? Y$t() : t === "it" ? K$t() : t === "jp" ? J$t() : t === "pl" ? Q$t() : t === "ru" ? tXt() : t === "uk" ? eXt() : rXt()
  },
  iXt = () => "Morocco",
  oXt = () => "Marrocos",
  sXt = () => "æ‘©æ´›å“¥",
  aXt = () => "Marokko",
  uXt = () => "Marruecos",
  cXt = () => "Maroc",
  lXt = () => "Marocco",
  _Xt = () => "ãƒ¢ãƒ­ãƒƒã‚³",
  hXt = () => "Maroko",
  dXt = () => "ĞœĞ°Ñ€Ğ¾ĞºĞºĞ¾",
  pXt = () => "ĞœĞ°Ñ€Ğ¾ĞºĞºĞ¾",
  fXt = () => "Maroc",
  mXt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? iXt() : t === "pt" ? oXt() : t === "ch" ? sXt() : t === "de" ? aXt() : t === "es" ? uXt() : t === "fr" ? cXt() : t === "it" ? lXt() : t === "jp" ? _Xt() : t === "pl" ? hXt() : t === "ru" ? dXt() : t === "uk" ? pXt() : fXt()
  },
  gXt = () => "Mozambique",
  yXt = () => "MoÃ§ambique",
  vXt = () => "è«æ¡‘æ¯”å…‹",
  bXt = () => "Mosambik",
  xXt = () => "Mozambique",
  wXt = () => "Mozambique",
  kXt = () => "Mozambico",
  TXt = () => "ãƒ¢ã‚¶ãƒ³ãƒ“ãƒ¼ã‚¯",
  SXt = () => "Mozambik",
  PXt = () => "ĞœĞ¾Ğ·Ğ°Ğ¼Ğ±Ğ¸Ğº",
  MXt = () => "ĞœĞ¾Ğ·Ğ°Ğ¼Ğ±Ñ–Ğº",
  CXt = () => "MÃ´-dÄƒm-bÃ­ch",
  IXt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? gXt() : t === "pt" ? yXt() : t === "ch" ? vXt() : t === "de" ? bXt() : t === "es" ? xXt() : t === "fr" ? wXt() : t === "it" ? kXt() : t === "jp" ? TXt() : t === "pl" ? SXt() : t === "ru" ? PXt() : t === "uk" ? MXt() : CXt()
  },
  zXt = () => "Myanmar",
  AXt = () => "Mianmar",
  EXt = () => "ç¼…ç”¸",
  jXt = () => "Myanmar",
  LXt = () => "Myanmar",
  DXt = () => "Myanmar",
  RXt = () => "Myanmar",
  BXt = () => "ãƒŸãƒ£ãƒ³ãƒãƒ¼",
  FXt = () => "Mjanma",
  OXt = () => "ĞœÑŒÑĞ½Ğ¼Ğ°",
  qXt = () => "Ğœ'ÑĞ½Ğ¼Ğ°",
  NXt = () => "Myanmar",
  VXt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? zXt() : t === "pt" ? AXt() : t === "ch" ? EXt() : t === "de" ? jXt() : t === "es" ? LXt() : t === "fr" ? DXt() : t === "it" ? RXt() : t === "jp" ? BXt() : t === "pl" ? FXt() : t === "ru" ? OXt() : t === "uk" ? qXt() : NXt()
  },
  UXt = () => "Namibia",
  ZXt = () => "NamÃ­bia",
  GXt = () => "çº³ç±³æ¯”äºš",
  HXt = () => "Namibia",
  WXt = () => "Namibia",
  $Xt = () => "Namibie",
  XXt = () => "Namibia",
  YXt = () => "ãƒŠãƒŸãƒ“ã‚¢",
  KXt = () => "Namibia",
  JXt = () => "ĞĞ°Ğ¼Ğ¸Ğ±Ğ¸Ñ",
  QXt = () => "ĞĞ°Ğ¼Ñ–Ğ±Ñ–Ñ",
  tYt = () => "Namibia",
  eYt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? UXt() : t === "pt" ? ZXt() : t === "ch" ? GXt() : t === "de" ? HXt() : t === "es" ? WXt() : t === "fr" ? $Xt() : t === "it" ? XXt() : t === "jp" ? YXt() : t === "pl" ? KXt() : t === "ru" ? JXt() : t === "uk" ? QXt() : tYt()
  },
  rYt = () => "Nauru",
  nYt = () => "Nauru",
  iYt = () => "ç‘™é²",
  oYt = () => "Nauru",
  sYt = () => "Nauru",
  aYt = () => "Nauru",
  uYt = () => "Nauru",
  cYt = () => "ãƒŠã‚¦ãƒ«",
  lYt = () => "Nauru",
  _Yt = () => "ĞĞ°ÑƒÑ€Ñƒ",
  hYt = () => "ĞĞ°ÑƒÑ€Ñƒ",
  dYt = () => "Nauru",
  pYt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rYt() : t === "pt" ? nYt() : t === "ch" ? iYt() : t === "de" ? oYt() : t === "es" ? sYt() : t === "fr" ? aYt() : t === "it" ? uYt() : t === "jp" ? cYt() : t === "pl" ? lYt() : t === "ru" ? _Yt() : t === "uk" ? hYt() : dYt()
  },
  fYt = () => "Nepal",
  mYt = () => "Nepal",
  gYt = () => "å°¼æ³Šå°”",
  yYt = () => "Nepal",
  vYt = () => "Nepal",
  bYt = () => "NÃ©pal",
  xYt = () => "Nepal",
  wYt = () => "ãƒãƒ‘ãƒ¼ãƒ«",
  kYt = () => "Nepal",
  TYt = () => "ĞĞµĞ¿Ğ°Ğ»",
  SYt = () => "ĞĞµĞ¿Ğ°Ğ»",
  PYt = () => "Nepal",
  MYt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? fYt() : t === "pt" ? mYt() : t === "ch" ? gYt() : t === "de" ? yYt() : t === "es" ? vYt() : t === "fr" ? bYt() : t === "it" ? xYt() : t === "jp" ? wYt() : t === "pl" ? kYt() : t === "ru" ? TYt() : t === "uk" ? SYt() : PYt()
  },
  CYt = () => "Netherlands",
  IYt = () => "Holanda",
  zYt = () => "è·å…°",
  AYt = () => "Niederlande",
  EYt = () => "PaÃ­ses Bajos",
  jYt = () => "Pays-Bas",
  LYt = () => "Paesi Bassi",
  DYt = () => "ã‚ªãƒ©ãƒ³ãƒ€",
  RYt = () => "Niderlandy",
  BYt = () => "ĞĞ¸Ğ´ĞµÑ€Ğ»Ğ°Ğ½Ğ´Ñ‹",
  FYt = () => "ĞÑ–Ğ´ĞµÑ€Ğ»Ğ°Ğ½Ğ´Ğ¸",
  OYt = () => "HÃ  Lan",
  qYt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? CYt() : t === "pt" ? IYt() : t === "ch" ? zYt() : t === "de" ? AYt() : t === "es" ? EYt() : t === "fr" ? jYt() : t === "it" ? LYt() : t === "jp" ? DYt() : t === "pl" ? RYt() : t === "ru" ? BYt() : t === "uk" ? FYt() : OYt()
  },
  NYt = () => "New Caledonia",
  VYt = () => "Nova CaledÃ´nia",
  UYt = () => "æ–°å–€é‡Œå¤šå°¼äºš",
  ZYt = () => "Neukaledonien",
  GYt = () => "Nueva Caledonia",
  HYt = () => "Nouvelle-CalÃ©donie",
  WYt = () => "Nuova Caledonia",
  $Yt = () => "ãƒ‹ãƒ¥ãƒ¼ã‚«ãƒ¬ãƒ‰ãƒ‹ã‚¢",
  XYt = () => "Nowa Kaledonia",
  YYt = () => "ĞĞ¾Ğ²Ğ°Ñ ĞšĞ°Ğ»ĞµĞ´Ğ¾Ğ½Ğ¸Ñ",
  KYt = () => "ĞĞ¾Ğ²Ğ° ĞšĞ°Ğ»ĞµĞ´Ğ¾Ğ½Ñ–Ñ",
  JYt = () => "Nouvelle-CalÃ©donie",
  QYt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? NYt() : t === "pt" ? VYt() : t === "ch" ? UYt() : t === "de" ? ZYt() : t === "es" ? GYt() : t === "fr" ? HYt() : t === "it" ? WYt() : t === "jp" ? $Yt() : t === "pl" ? XYt() : t === "ru" ? YYt() : t === "uk" ? KYt() : JYt()
  },
  tKt = () => "New Zealand",
  eKt = () => "Nova ZelÃ¢ndia",
  rKt = () => "æ–°è¥¿å…°",
  nKt = () => "Neuseeland",
  iKt = () => "Nueva Zelanda",
  oKt = () => "Nouvelle-ZÃ©lande",
  sKt = () => "Nuova Zelanda",
  aKt = () => "ãƒ‹ãƒ¥ãƒ¼ã‚¸ãƒ¼ãƒ©ãƒ³ãƒ‰",
  uKt = () => "Nowa Zelandia",
  cKt = () => "ĞĞ¾Ğ²Ğ°Ñ Ğ—ĞµĞ»Ğ°Ğ½Ğ´Ğ¸Ñ",
  lKt = () => "ĞĞ¾Ğ²Ğ° Ğ—ĞµĞ»Ğ°Ğ½Ğ´Ñ–Ñ",
  _Kt = () => "New Zealand",
  hKt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? tKt() : t === "pt" ? eKt() : t === "ch" ? rKt() : t === "de" ? nKt() : t === "es" ? iKt() : t === "fr" ? oKt() : t === "it" ? sKt() : t === "jp" ? aKt() : t === "pl" ? uKt() : t === "ru" ? cKt() : t === "uk" ? lKt() : _Kt()
  },
  dKt = () => "Nicaragua",
  pKt = () => "NicarÃ¡gua",
  fKt = () => "å°¼åŠ æ‹‰ç“œ",
  mKt = () => "Nicaragua",
  gKt = () => "Nicaragua",
  yKt = () => "Nicaragua",
  vKt = () => "Nicaragua",
  bKt = () => "ãƒ‹ã‚«ãƒ©ã‚°ã‚¢",
  xKt = () => "Nikaragua",
  wKt = () => "ĞĞ¸ĞºĞ°Ñ€Ğ°Ğ³ÑƒĞ°",
  kKt = () => "ĞÑ–ĞºĞ°Ñ€Ğ°Ğ³ÑƒĞ°",
  TKt = () => "Nicaragua",
  SKt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? dKt() : t === "pt" ? pKt() : t === "ch" ? fKt() : t === "de" ? mKt() : t === "es" ? gKt() : t === "fr" ? yKt() : t === "it" ? vKt() : t === "jp" ? bKt() : t === "pl" ? xKt() : t === "ru" ? wKt() : t === "uk" ? kKt() : TKt()
  },
  PKt = () => "Niger",
  MKt = () => "NÃ­ger",
  CKt = () => "å°¼æ—¥å°”",
  IKt = () => "Niger",
  zKt = () => "NÃ­ger",
  AKt = () => "Niger",
  EKt = () => "Niger",
  jKt = () => "ãƒ‹ã‚¸ã‚§ãƒ¼ãƒ«",
  LKt = () => "Niger",
  DKt = () => "ĞĞ¸Ğ³ĞµÑ€",
  RKt = () => "ĞÑ–Ğ³ĞµÑ€",
  BKt = () => "Ni-giÃª",
  FKt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? PKt() : t === "pt" ? MKt() : t === "ch" ? CKt() : t === "de" ? IKt() : t === "es" ? zKt() : t === "fr" ? AKt() : t === "it" ? EKt() : t === "jp" ? jKt() : t === "pl" ? LKt() : t === "ru" ? DKt() : t === "uk" ? RKt() : BKt()
  },
  OKt = () => "Nigeria",
  qKt = () => "NigÃ©ria",
  NKt = () => "å°¼æ—¥åˆ©äºš",
  VKt = () => "Nigeria",
  UKt = () => "Nigeria",
  ZKt = () => "Nigeria",
  GKt = () => "Nigeria",
  HKt = () => "ãƒŠã‚¤ã‚¸ã‚§ãƒªã‚¢",
  WKt = () => "Nigeria",
  $Kt = () => "ĞĞ¸Ğ³ĞµÑ€Ğ¸Ñ",
  XKt = () => "ĞÑ–Ğ³ĞµÑ€Ñ–Ñ",
  YKt = () => "Nigeria",
  KKt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? OKt() : t === "pt" ? qKt() : t === "ch" ? NKt() : t === "de" ? VKt() : t === "es" ? UKt() : t === "fr" ? ZKt() : t === "it" ? GKt() : t === "jp" ? HKt() : t === "pl" ? WKt() : t === "ru" ? $Kt() : t === "uk" ? XKt() : YKt()
  },
  JKt = () => "Niue",
  QKt = () => "Niue",
  tJt = () => "çº½åŸƒ",
  eJt = () => "Niue",
  rJt = () => "Niue",
  nJt = () => "Niue",
  iJt = () => "Niue",
  oJt = () => "ãƒ‹ã‚¦ã‚¨",
  sJt = () => "Niue",
  aJt = () => "ĞĞ¸ÑƒÑ",
  uJt = () => "ĞÑ–ÑƒĞµ",
  cJt = () => "Niue",
  lJt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? JKt() : t === "pt" ? QKt() : t === "ch" ? tJt() : t === "de" ? eJt() : t === "es" ? rJt() : t === "fr" ? nJt() : t === "it" ? iJt() : t === "jp" ? oJt() : t === "pl" ? sJt() : t === "ru" ? aJt() : t === "uk" ? uJt() : cJt()
  },
  _Jt = () => "Norfolk Island",
  hJt = () => "Ilha Norfolk",
  dJt = () => "è¯ºç¦å…‹å²›",
  pJt = () => "Norfolkinsel",
  fJt = () => "Isla Norfolk",
  mJt = () => "Ãle Norfolk",
  gJt = () => "Isola Norfolk",
  yJt = () => "ãƒãƒ¼ãƒ•ã‚©ãƒ¼ã‚¯å³¶",
  vJt = () => "Wyspa Norfolk",
  bJt = () => "ĞÑÑ‚Ñ€Ğ¾Ğ² ĞĞ¾Ñ€Ñ„Ğ¾Ğ»Ğº",
  xJt = () => "ĞÑÑ‚Ñ€Ñ–Ğ² ĞĞ¾Ñ€Ñ„Ğ¾Ğ»Ğº",
  wJt = () => "Äáº£o Norfolk",
  kJt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? _Jt() : t === "pt" ? hJt() : t === "ch" ? dJt() : t === "de" ? pJt() : t === "es" ? fJt() : t === "fr" ? mJt() : t === "it" ? gJt() : t === "jp" ? yJt() : t === "pl" ? vJt() : t === "ru" ? bJt() : t === "uk" ? xJt() : wJt()
  },
  TJt = () => "North Korea",
  SJt = () => "Coreia do Norte",
  PJt = () => "æœé²œ",
  MJt = () => "Nordkorea",
  CJt = () => "Corea del Norte",
  IJt = () => "CorÃ©e du Nord",
  zJt = () => "Corea del Nord",
  AJt = () => "åŒ—æœé®®",
  EJt = () => "Korea PÃ³Å‚nocna",
  jJt = () => "Ğ¡ĞµĞ²ĞµÑ€Ğ½Ğ°Ñ ĞšĞ¾Ñ€ĞµÑ",
  LJt = () => "ĞŸÑ–Ğ²Ğ½Ñ–Ñ‡Ğ½Ğ° ĞšĞ¾Ñ€ĞµÑ",
  DJt = () => "Triá»u TiÃªn",
  RJt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? TJt() : t === "pt" ? SJt() : t === "ch" ? PJt() : t === "de" ? MJt() : t === "es" ? CJt() : t === "fr" ? IJt() : t === "it" ? zJt() : t === "jp" ? AJt() : t === "pl" ? EJt() : t === "ru" ? jJt() : t === "uk" ? LJt() : DJt()
  },
  BJt = () => "North Macedonia",
  FJt = () => "MacedÃ´nia do Norte",
  OJt = () => "åŒ—é©¬å…¶é¡¿",
  qJt = () => "Nordmazedonien",
  NJt = () => "Macedonia del Norte",
  VJt = () => "MacÃ©doine du Nord",
  UJt = () => "Macedonia del Nord",
  ZJt = () => "åŒ—ãƒã‚±ãƒ‰ãƒ‹ã‚¢",
  GJt = () => "Macedonia PÃ³Å‚nocna",
  HJt = () => "Ğ¡ĞµĞ²ĞµÑ€Ğ½Ğ°Ñ ĞœĞ°ĞºĞµĞ´Ğ¾Ğ½Ğ¸Ñ",
  WJt = () => "ĞŸÑ–Ğ²Ğ½Ñ–Ñ‡Ğ½Ğ° ĞœĞ°ĞºĞµĞ´Ğ¾Ğ½Ñ–Ñ",
  $Jt = () => "Báº¯c Macedonia",
  XJt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? BJt() : t === "pt" ? FJt() : t === "ch" ? OJt() : t === "de" ? qJt() : t === "es" ? NJt() : t === "fr" ? VJt() : t === "it" ? UJt() : t === "jp" ? ZJt() : t === "pl" ? GJt() : t === "ru" ? HJt() : t === "uk" ? WJt() : $Jt()
  },
  YJt = () => "Northern Mariana Islands",
  KJt = () => "Ilhas Marianas Setentrionais",
  JJt = () => "åŒ—é©¬é‡Œäºšçº³ç¾¤å²›",
  QJt = () => "NÃ¶rdliche Marianen",
  tQt = () => "Islas Marianas del Norte",
  eQt = () => "Ãles Mariannes du Nord",
  rQt = () => "Isole Marianne Settentrionali",
  nQt = () => "åŒ—ãƒãƒªã‚¢ãƒŠè«¸å³¶",
  iQt = () => "Mariany PÃ³Å‚nocne",
  oQt = () => "Ğ¡ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğµ ĞœĞ°Ñ€Ğ¸Ğ°Ğ½ÑĞºĞ¸Ğµ ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  sQt = () => "ĞŸÑ–Ğ²Ğ½Ñ–Ñ‡Ğ½Ñ– ĞœĞ°Ñ€Ñ–Ğ°Ğ½ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  aQt = () => "Quáº§n Ä‘áº£o Báº¯c Mariana",
  uQt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? YJt() : t === "pt" ? KJt() : t === "ch" ? JJt() : t === "de" ? QJt() : t === "es" ? tQt() : t === "fr" ? eQt() : t === "it" ? rQt() : t === "jp" ? nQt() : t === "pl" ? iQt() : t === "ru" ? oQt() : t === "uk" ? sQt() : aQt()
  },
  cQt = () => "Norway",
  lQt = () => "Noruega",
  _Qt = () => "æŒªå¨",
  hQt = () => "Norwegen",
  dQt = () => "Noruega",
  pQt = () => "NorvÃ¨ge",
  fQt = () => "Norvegia",
  mQt = () => "ãƒãƒ«ã‚¦ã‚§ãƒ¼",
  gQt = () => "Norwegia",
  yQt = () => "ĞĞ¾Ñ€Ğ²ĞµĞ³Ğ¸Ñ",
  vQt = () => "ĞĞ¾Ñ€Ğ²ĞµĞ³Ñ–Ñ",
  bQt = () => "Na Uy",
  xQt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? cQt() : t === "pt" ? lQt() : t === "ch" ? _Qt() : t === "de" ? hQt() : t === "es" ? dQt() : t === "fr" ? pQt() : t === "it" ? fQt() : t === "jp" ? mQt() : t === "pl" ? gQt() : t === "ru" ? yQt() : t === "uk" ? vQt() : bQt()
  },
  wQt = () => "Oman",
  kQt = () => "OmÃ£",
  TQt = () => "é˜¿æ›¼",
  SQt = () => "Oman",
  PQt = () => "OmÃ¡n",
  MQt = () => "Oman",
  CQt = () => "Oman",
  IQt = () => "ã‚ªãƒãƒ¼ãƒ³",
  zQt = () => "Oman",
  AQt = () => "ĞĞ¼Ğ°Ğ½",
  EQt = () => "ĞĞ¼Ğ°Ğ½",
  jQt = () => "Oman",
  LQt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? wQt() : t === "pt" ? kQt() : t === "ch" ? TQt() : t === "de" ? SQt() : t === "es" ? PQt() : t === "fr" ? MQt() : t === "it" ? CQt() : t === "jp" ? IQt() : t === "pl" ? zQt() : t === "ru" ? AQt() : t === "uk" ? EQt() : jQt()
  },
  DQt = () => "Pakistan",
  RQt = () => "PaquistÃ£o",
  BQt = () => "å·´åŸºæ–¯å¦",
  FQt = () => "Pakistan",
  OQt = () => "PakistÃ¡n",
  qQt = () => "Pakistan",
  NQt = () => "Pakistan",
  VQt = () => "ãƒ‘ã‚­ã‚¹ã‚¿ãƒ³",
  UQt = () => "Pakistan",
  ZQt = () => "ĞŸĞ°ĞºĞ¸ÑÑ‚Ğ°Ğ½",
  GQt = () => "ĞŸĞ°ĞºĞ¸ÑÑ‚Ğ°Ğ½",
  HQt = () => "Pakistan",
  WQt = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? DQt() : t === "pt" ? RQt() : t === "ch" ? BQt() : t === "de" ? FQt() : t === "es" ? OQt() : t === "fr" ? qQt() : t === "it" ? NQt() : t === "jp" ? VQt() : t === "pl" ? UQt() : t === "ru" ? ZQt() : t === "uk" ? GQt() : HQt()
  },
  $Qt = () => "Palau",
  XQt = () => "Palau",
  YQt = () => "å¸•åŠ³",
  KQt = () => "Palau",
  JQt = () => "Palau",
  QQt = () => "Palaos",
  tte = () => "Palau",
  ete = () => "ãƒ‘ãƒ©ã‚ª",
  rte = () => "Palau",
  nte = () => "ĞŸĞ°Ğ»Ğ°Ñƒ",
  ite = () => "ĞŸĞ°Ğ»Ğ°Ñƒ",
  ote = () => "Palau",
  ste = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $Qt() : t === "pt" ? XQt() : t === "ch" ? YQt() : t === "de" ? KQt() : t === "es" ? JQt() : t === "fr" ? QQt() : t === "it" ? tte() : t === "jp" ? ete() : t === "pl" ? rte() : t === "ru" ? nte() : t === "uk" ? ite() : ote()
  },
  ate = () => "Palestine",
  ute = () => "Palestina",
  cte = () => "å·´å‹’æ–¯å¦",
  lte = () => "PalÃ¤stina",
  _te = () => "Palestina",
  hte = () => "Palestine",
  dte = () => "Palestina",
  pte = () => "ãƒ‘ãƒ¬ã‚¹ãƒãƒŠ",
  fte = () => "Palestyna",
  mte = () => "ĞŸĞ°Ğ»ĞµÑÑ‚Ğ¸Ğ½Ğ°",
  gte = () => "ĞŸĞ°Ğ»ĞµÑÑ‚Ğ¸Ğ½Ğ°",
  yte = () => "Palestine",
  vte = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ate() : t === "pt" ? ute() : t === "ch" ? cte() : t === "de" ? lte() : t === "es" ? _te() : t === "fr" ? hte() : t === "it" ? dte() : t === "jp" ? pte() : t === "pl" ? fte() : t === "ru" ? mte() : t === "uk" ? gte() : yte()
  },
  bte = () => "Panama",
  xte = () => "PanamÃ¡",
  wte = () => "å·´æ‹¿é©¬",
  kte = () => "Panama",
  Tte = () => "PanamÃ¡",
  Ste = () => "Panama",
  Pte = () => "Panama",
  Mte = () => "ãƒ‘ãƒŠãƒ",
  Cte = () => "Panama",
  Ite = () => "ĞŸĞ°Ğ½Ğ°Ğ¼Ğ°",
  zte = () => "ĞŸĞ°Ğ½Ğ°Ğ¼Ğ°",
  Ate = () => "Panama",
  Ete = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? bte() : t === "pt" ? xte() : t === "ch" ? wte() : t === "de" ? kte() : t === "es" ? Tte() : t === "fr" ? Ste() : t === "it" ? Pte() : t === "jp" ? Mte() : t === "pl" ? Cte() : t === "ru" ? Ite() : t === "uk" ? zte() : Ate()
  },
  jte = () => "Papua New Guinea",
  Lte = () => "Papua-Nova GuinÃ©",
  Dte = () => "å·´å¸ƒäºšæ–°å‡ å†…äºš",
  Rte = () => "Papua-Neuguinea",
  Bte = () => "PapÃºa Nueva Guinea",
  Fte = () => "Papouasie-Nouvelle-GuinÃ©e",
  Ote = () => "Papua Nuova Guinea",
  qte = () => "ãƒ‘ãƒ—ã‚¢ãƒ‹ãƒ¥ãƒ¼ã‚®ãƒ‹ã‚¢",
  Nte = () => "Papua-Nowa Gwinea",
  Vte = () => "ĞŸĞ°Ğ¿ÑƒĞ° â€” ĞĞ¾Ğ²Ğ°Ñ Ğ“Ğ²Ğ¸Ğ½ĞµÑ",
  Ute = () => "ĞŸĞ°Ğ¿ÑƒĞ° ĞĞ¾Ğ²Ğ° Ğ“Ğ²Ñ–Ğ½ĞµÑ",
  Zte = () => "Papua New Guinea",
  Gte = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? jte() : t === "pt" ? Lte() : t === "ch" ? Dte() : t === "de" ? Rte() : t === "es" ? Bte() : t === "fr" ? Fte() : t === "it" ? Ote() : t === "jp" ? qte() : t === "pl" ? Nte() : t === "ru" ? Vte() : t === "uk" ? Ute() : Zte()
  },
  Hte = () => "Paraguay",
  Wte = () => "Paraguai",
  $te = () => "å·´æ‹‰åœ­",
  Xte = () => "Paraguay",
  Yte = () => "Paraguay",
  Kte = () => "Paraguay",
  Jte = () => "Paraguay",
  Qte = () => "ãƒ‘ãƒ©ã‚°ã‚¢ã‚¤",
  tee = () => "Paragwaj",
  eee = () => "ĞŸĞ°Ñ€Ğ°Ğ³Ğ²Ğ°Ğ¹",
  ree = () => "ĞŸĞ°Ñ€Ğ°Ğ³Ğ²Ğ°Ğ¹",
  nee = () => "Paragoay",
  iee = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Hte() : t === "pt" ? Wte() : t === "ch" ? $te() : t === "de" ? Xte() : t === "es" ? Yte() : t === "fr" ? Kte() : t === "it" ? Jte() : t === "jp" ? Qte() : t === "pl" ? tee() : t === "ru" ? eee() : t === "uk" ? ree() : nee()
  },
  oee = () => "Peru",
  see = () => "Peru",
  aee = () => "ç§˜é²",
  uee = () => "Peru",
  cee = () => "PerÃº",
  lee = () => "PÃ©rou",
  _ee = () => "PerÃ¹",
  hee = () => "ãƒšãƒ«ãƒ¼",
  dee = () => "Peru",
  pee = () => "ĞŸĞµÑ€Ñƒ",
  fee = () => "ĞŸĞµÑ€Ñƒ",
  mee = () => "Peru",
  gee = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? oee() : t === "pt" ? see() : t === "ch" ? aee() : t === "de" ? uee() : t === "es" ? cee() : t === "fr" ? lee() : t === "it" ? _ee() : t === "jp" ? hee() : t === "pl" ? dee() : t === "ru" ? pee() : t === "uk" ? fee() : mee()
  },
  yee = () => "Philippines",
  vee = () => "Filipinas",
  bee = () => "è²å¾‹å®¾",
  xee = () => "Philippinen",
  wee = () => "Filipinas",
  kee = () => "Philippines",
  Tee = () => "Filippine",
  See = () => "ãƒ•ã‚£ãƒªãƒ”ãƒ³",
  Pee = () => "Filipiny",
  Mee = () => "Ğ¤Ğ¸Ğ»Ğ¸Ğ¿Ğ¿Ğ¸Ğ½Ñ‹",
  Cee = () => "Ğ¤Ñ–Ğ»Ñ–Ğ¿Ğ¿Ñ–Ğ½Ğ¸",
  Iee = () => "Philippines",
  zee = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? yee() : t === "pt" ? vee() : t === "ch" ? bee() : t === "de" ? xee() : t === "es" ? wee() : t === "fr" ? kee() : t === "it" ? Tee() : t === "jp" ? See() : t === "pl" ? Pee() : t === "ru" ? Mee() : t === "uk" ? Cee() : Iee()
  },
  Aee = () => "Pitcairn",
  Eee = () => "Pitcairn",
  jee = () => "çš®ç‰¹å‡¯æ©",
  Lee = () => "Pitcairn",
  Dee = () => "Pitcairn",
  Ree = () => "Pitcairn",
  Bee = () => "Pitcairn",
  Fee = () => "ãƒ”ãƒˆã‚±ã‚¢ãƒ³",
  Oee = () => "Pitcairn",
  qee = () => "ĞŸĞ¸Ñ‚ĞºÑÑ€Ğ½",
  Nee = () => "ĞŸÑ–Ñ‚ĞºĞµÑ€Ğ½",
  Vee = () => "Pitcairn",
  Uee = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Aee() : t === "pt" ? Eee() : t === "ch" ? jee() : t === "de" ? Lee() : t === "es" ? Dee() : t === "fr" ? Ree() : t === "it" ? Bee() : t === "jp" ? Fee() : t === "pl" ? Oee() : t === "ru" ? qee() : t === "uk" ? Nee() : Vee()
  },
  Zee = () => "Poland",
  Gee = () => "PolÃ´nia",
  Hee = () => "æ³¢å…°",
  Wee = () => "Polen",
  $ee = () => "Polonia",
  Xee = () => "Pologne",
  Yee = () => "Polonia",
  Kee = () => "ãƒãƒ¼ãƒ©ãƒ³ãƒ‰",
  Jee = () => "Polska",
  Qee = () => "ĞŸĞ¾Ğ»ÑŒÑˆĞ°",
  tre = () => "ĞŸĞ¾Ğ»ÑŒÑ‰Ğ°",
  ere = () => "Ba Lan",
  rre = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Zee() : t === "pt" ? Gee() : t === "ch" ? Hee() : t === "de" ? Wee() : t === "es" ? $ee() : t === "fr" ? Xee() : t === "it" ? Yee() : t === "jp" ? Kee() : t === "pl" ? Jee() : t === "ru" ? Qee() : t === "uk" ? tre() : ere()
  },
  nre = () => "Portugal",
  ire = () => "Portugal",
  ore = () => "è‘¡è„ç‰™",
  sre = () => "Portugal",
  are = () => "Portugal",
  ure = () => "Portugal",
  cre = () => "Portogallo",
  lre = () => "ãƒãƒ«ãƒˆã‚¬ãƒ«",
  _re = () => "Portugalia",
  hre = () => "ĞŸĞ¾Ñ€Ñ‚ÑƒĞ³Ğ°Ğ»Ğ¸Ñ",
  dre = () => "ĞŸĞ¾Ñ€Ñ‚ÑƒĞ³Ğ°Ğ»Ñ–Ñ",
  pre = () => "Bá»“ ÄÃ o Nha",
  fre = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? nre() : t === "pt" ? ire() : t === "ch" ? ore() : t === "de" ? sre() : t === "es" ? are() : t === "fr" ? ure() : t === "it" ? cre() : t === "jp" ? lre() : t === "pl" ? _re() : t === "ru" ? hre() : t === "uk" ? dre() : pre()
  },
  mre = () => "Puerto Rico",
  gre = () => "Porto Rico",
  yre = () => "æ³¢å¤šé»å„",
  vre = () => "Puerto Rico",
  bre = () => "Puerto Rico",
  xre = () => "Porto Rico",
  wre = () => "Porto Rico",
  kre = () => "ãƒ—ã‚¨ãƒ«ãƒˆãƒªã‚³",
  Tre = () => "Portoryko",
  Sre = () => "ĞŸÑƒÑÑ€Ñ‚Ğ¾-Ğ Ğ¸ĞºĞ¾",
  Pre = () => "ĞŸÑƒĞµÑ€Ñ‚Ğ¾-Ğ Ğ¸ĞºĞ¾",
  Mre = () => "Puerto Rico",
  Cre = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mre() : t === "pt" ? gre() : t === "ch" ? yre() : t === "de" ? vre() : t === "es" ? bre() : t === "fr" ? xre() : t === "it" ? wre() : t === "jp" ? kre() : t === "pl" ? Tre() : t === "ru" ? Sre() : t === "uk" ? Pre() : Mre()
  },
  Ire = () => "Qatar",
  zre = () => "Catar",
  Are = () => "å¡å¡”å°”",
  Ere = () => "Katar",
  jre = () => "Catar",
  Lre = () => "Qatar",
  Dre = () => "Qatar",
  Rre = () => "ã‚«ã‚¿ãƒ¼ãƒ«",
  Bre = () => "Katar",
  Fre = () => "ĞšĞ°Ñ‚Ğ°Ñ€",
  Ore = () => "ĞšĞ°Ñ‚Ğ°Ñ€",
  qre = () => "Qatar",
  Nre = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ire() : t === "pt" ? zre() : t === "ch" ? Are() : t === "de" ? Ere() : t === "es" ? jre() : t === "fr" ? Lre() : t === "it" ? Dre() : t === "jp" ? Rre() : t === "pl" ? Bre() : t === "ru" ? Fre() : t === "uk" ? Ore() : qre()
  },
  Vre = () => "Republic of the Congo",
  Ure = () => "RepÃºblica do Congo",
  Zre = () => "åˆšæœå…±å’Œå›½",
  Gre = () => "Republik Kongo",
  Hre = () => "RepÃºblica del Congo",
  Wre = () => "RÃ©publique du Congo",
  $re = () => "Repubblica del Congo",
  Xre = () => "ã‚³ãƒ³ã‚´å…±å’Œå›½",
  Yre = () => "Republika Konga",
  Kre = () => "Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ° ĞšĞ¾Ğ½Ğ³Ğ¾",
  Jre = () => "Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ñ–ĞºĞ° ĞšĞ¾Ğ½Ğ³Ğ¾",
  Qre = () => "Cá»™ng hÃ²a Congo",
  tne = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Vre() : t === "pt" ? Ure() : t === "ch" ? Zre() : t === "de" ? Gre() : t === "es" ? Hre() : t === "fr" ? Wre() : t === "it" ? $re() : t === "jp" ? Xre() : t === "pl" ? Yre() : t === "ru" ? Kre() : t === "uk" ? Jre() : Qre()
  },
  ene = () => "Romania",
  rne = () => "RomÃªnia",
  nne = () => "ç½—é©¬å°¼äºš",
  ine = () => "RumÃ¤nien",
  one = () => "RumanÃ­a",
  sne = () => "Roumanie",
  ane = () => "Romania",
  une = () => "ãƒ«ãƒ¼ãƒãƒ‹ã‚¢",
  cne = () => "Rumunia",
  lne = () => "Ğ ÑƒĞ¼Ñ‹Ğ½Ğ¸Ñ",
  _ne = () => "Ğ ÑƒĞ¼ÑƒĞ½Ñ–Ñ",
  hne = () => "Rumani",
  dne = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ene() : t === "pt" ? rne() : t === "ch" ? nne() : t === "de" ? ine() : t === "es" ? one() : t === "fr" ? sne() : t === "it" ? ane() : t === "jp" ? une() : t === "pl" ? cne() : t === "ru" ? lne() : t === "uk" ? _ne() : hne()
  },
  pne = () => "Russia",
  fne = () => "RÃºssia",
  mne = () => "ä¿„ç½—æ–¯",
  gne = () => "Russland",
  yne = () => "Rusia",
  vne = () => "Russie",
  bne = () => "Russia",
  xne = () => "ãƒ­ã‚·ã‚¢",
  wne = () => "Rosja",
  kne = () => "Ğ Ğ¾ÑÑĞ¸Ñ",
  Tne = () => "Ğ Ğ¾ÑÑ–Ñ",
  Sne = () => "Nga",
  Pne = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pne() : t === "pt" ? fne() : t === "ch" ? mne() : t === "de" ? gne() : t === "es" ? yne() : t === "fr" ? vne() : t === "it" ? bne() : t === "jp" ? xne() : t === "pl" ? wne() : t === "ru" ? kne() : t === "uk" ? Tne() : Sne()
  },
  Mne = () => "Rwanda",
  Cne = () => "Ruanda",
  Ine = () => "å¢æ—ºè¾¾",
  zne = () => "Ruanda",
  Ane = () => "Ruanda",
  Ene = () => "Rwanda",
  jne = () => "Ruanda",
  Lne = () => "ãƒ«ãƒ¯ãƒ³ãƒ€",
  Dne = () => "Rwanda",
  Rne = () => "Ğ ÑƒĞ°Ğ½Ğ´Ğ°",
  Bne = () => "Ğ ÑƒĞ°Ğ½Ğ´Ğ°",
  Fne = () => "Rwanda",
  One = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Mne() : t === "pt" ? Cne() : t === "ch" ? Ine() : t === "de" ? zne() : t === "es" ? Ane() : t === "fr" ? Ene() : t === "it" ? jne() : t === "jp" ? Lne() : t === "pl" ? Dne() : t === "ru" ? Rne() : t === "uk" ? Bne() : Fne()
  },
  qne = () => "RÃ©union",
  Nne = () => "ReuniÃ£o",
  Vne = () => "ç•™å°¼æ±ª",
  Une = () => "RÃ©union",
  Zne = () => "ReuniÃ³n",
  Gne = () => "RÃ©union",
  Hne = () => "RÃ©union",
  Wne = () => "ãƒ¬ãƒ¦ãƒ‹ã‚ªãƒ³",
  $ne = () => "Reunion",
  Xne = () => "Ğ ĞµÑĞ½ÑŒĞ¾Ğ½",
  Yne = () => "Ğ ĞµÑĞ½ÑŒĞ¹Ğ¾Ğ½",
  Kne = () => "RÃ©union",
  Jne = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qne() : t === "pt" ? Nne() : t === "ch" ? Vne() : t === "de" ? Une() : t === "es" ? Zne() : t === "fr" ? Gne() : t === "it" ? Hne() : t === "jp" ? Wne() : t === "pl" ? $ne() : t === "ru" ? Xne() : t === "uk" ? Yne() : Kne()
  },
  Qne = () => "Saint BarthÃ©lemy",
  tie = () => "SÃ£o Bartolomeu",
  eie = () => "åœ£å·´æ³°å‹’ç±³",
  rie = () => "Saint BarthÃ©lemy",
  nie = () => "San BartolomÃ©",
  iie = () => "Saint BarthÃ©lemy",
  oie = () => "Saint BarthÃ©lemy",
  sie = () => "ã‚µãƒ³ãƒ»ãƒãƒ«ãƒ†ãƒ«ãƒŸãƒ¼",
  aie = () => "Saint BarthÃ©lemy",
  uie = () => "Ğ¡ĞµĞ½-Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ğ¸",
  cie = () => "Ğ¡ĞµĞ½-Ğ‘Ğ°Ñ€Ñ‚ĞµĞ»ĞµĞ¼Ñ–",
  lie = () => "Saint BarthÃ©lemy",
  _ie = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Qne() : t === "pt" ? tie() : t === "ch" ? eie() : t === "de" ? rie() : t === "es" ? nie() : t === "fr" ? iie() : t === "it" ? oie() : t === "jp" ? sie() : t === "pl" ? aie() : t === "ru" ? uie() : t === "uk" ? cie() : lie()
  },
  hie = () => "Saint Helena",
  die = () => "Santa Helena",
  pie = () => "åœ£èµ«å‹’æ‹¿",
  fie = () => "Sankt Helena",
  mie = () => "Santa Elena",
  gie = () => "Sainte-HÃ©lÃ¨ne",
  yie = () => "Sant'Elena",
  vie = () => "ã‚»ãƒ³ãƒˆãƒ˜ãƒ¬ãƒŠ",
  bie = () => "ÅšwiÄ™ta Helena",
  xie = () => "ĞÑÑ‚Ñ€Ğ¾Ğ² Ğ¡Ğ²ÑÑ‚Ğ¾Ğ¹ Ğ•Ğ»ĞµĞ½Ñ‹",
  wie = () => "Ğ¡Ğ²ÑÑ‚Ğ° Ğ„Ğ»ĞµĞ½Ğ°",
  kie = () => "Saint Helena",
  Tie = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hie() : t === "pt" ? die() : t === "ch" ? pie() : t === "de" ? fie() : t === "es" ? mie() : t === "fr" ? gie() : t === "it" ? yie() : t === "jp" ? vie() : t === "pl" ? bie() : t === "ru" ? xie() : t === "uk" ? wie() : kie()
  },
  Sie = () => "Saint Kitts and Nevis",
  Pie = () => "SÃ£o CristÃ³vÃ£o e Neves",
  Mie = () => "åœ£åŸºèŒ¨å’Œå°¼ç»´æ–¯",
  Cie = () => "St. Kitts und Nevis",
  Iie = () => "San CristÃ³bal y Nieves",
  zie = () => "Saint-Christophe-et-NiÃ©vÃ¨s",
  Aie = () => "Saint Kitts e Nevis",
  Eie = () => "ã‚»ãƒ³ãƒˆã‚¯ãƒªã‚¹ãƒˆãƒ•ã‚¡ãƒ¼ãƒ»ãƒã‚¤ãƒ“ã‚¹",
  jie = () => "Saint Kitts i Nevis",
  Lie = () => "Ğ¡ĞµĞ½Ñ‚-ĞšĞ¸Ñ‚Ñ Ğ¸ ĞĞµĞ²Ğ¸Ñ",
  Die = () => "Ğ¡ĞµĞ½Ñ‚-ĞšÑ–Ñ‚Ñ Ñ– ĞĞµĞ²Ñ–Ñ",
  Rie = () => "Saint Kitts vÃ  Nevis",
  Bie = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Sie() : t === "pt" ? Pie() : t === "ch" ? Mie() : t === "de" ? Cie() : t === "es" ? Iie() : t === "fr" ? zie() : t === "it" ? Aie() : t === "jp" ? Eie() : t === "pl" ? jie() : t === "ru" ? Lie() : t === "uk" ? Die() : Rie()
  },
  Fie = () => "Saint Lucia",
  Oie = () => "Santa LÃºcia",
  qie = () => "åœ£å¢è¥¿äºš",
  Nie = () => "St. Lucia",
  Vie = () => "Santa LucÃ­a",
  Uie = () => "Sainte-Lucie",
  Zie = () => "Santa Lucia",
  Gie = () => "ã‚»ãƒ³ãƒˆãƒ«ã‚·ã‚¢",
  Hie = () => "Saint Lucia",
  Wie = () => "Ğ¡ĞµĞ½Ñ‚-Ğ›ÑÑĞ¸Ñ",
  $ie = () => "Ğ¡ĞµĞ½Ñ‚-Ğ›ÑÑÑ–Ñ",
  Xie = () => "Saint Lucia",
  Yie = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Fie() : t === "pt" ? Oie() : t === "ch" ? qie() : t === "de" ? Nie() : t === "es" ? Vie() : t === "fr" ? Uie() : t === "it" ? Zie() : t === "jp" ? Gie() : t === "pl" ? Hie() : t === "ru" ? Wie() : t === "uk" ? $ie() : Xie()
  },
  Kie = () => "Saint Martin (French part)",
  Jie = () => "SÃ£o Martinho (parte francesa)",
  Qie = () => "åœ£é©¬ä¸ (æ³•å±éƒ¨åˆ†)",
  toe = () => "Sankt Martin (franzÃ¶sischer Teil)",
  eoe = () => "San MartÃ­n (parte francesa)",
  roe = () => "Saint-Martin (partie franÃ§aise)",
  noe = () => "Saint Martin (parte francese)",
  ioe = () => "ã‚µãƒ³ãƒ»ãƒãƒ«ã‚¿ãƒ³ (ãƒ•ãƒ©ãƒ³ã‚¹é ˜éƒ¨åˆ†)",
  ooe = () => "Saint-Martin (czÄ™Å›Ä‡ francuska)",
  soe = () => "Ğ¡ĞµĞ½-ĞœĞ°Ñ€Ñ‚ĞµĞ½ (Ñ„Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑĞºĞ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ)",
  aoe = () => "Ğ¡ĞµĞ½-ĞœĞ°Ñ€Ñ‚ĞµĞ½ (Ñ„Ñ€Ğ°Ğ½Ñ†ÑƒĞ·ÑŒĞºĞ° Ñ‡Ğ°ÑÑ‚Ğ¸Ğ½Ğ°)",
  uoe = () => "Saint Martin (pháº§n thuá»™c PhÃ¡p)",
  coe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Kie() : t === "pt" ? Jie() : t === "ch" ? Qie() : t === "de" ? toe() : t === "es" ? eoe() : t === "fr" ? roe() : t === "it" ? noe() : t === "jp" ? ioe() : t === "pl" ? ooe() : t === "ru" ? soe() : t === "uk" ? aoe() : uoe()
  },
  loe = () => "Saint Pierre and Miquelon",
  _oe = () => "Saint-Pierre e Miquelon",
  hoe = () => "åœ£çš®åŸƒå°”å’Œå¯†å…‹éš†",
  doe = () => "Saint-Pierre und Miquelon",
  poe = () => "San Pedro y MiquelÃ³n",
  foe = () => "Saint-Pierre-et-Miquelon",
  moe = () => "Saint-Pierre e Miquelon",
  goe = () => "ã‚µãƒ³ãƒ”ã‚¨ãƒ¼ãƒ«å³¶ãƒ»ãƒŸã‚¯ãƒ­ãƒ³å³¶",
  yoe = () => "Saint-Pierre i Miquelon",
  voe = () => "Ğ¡ĞµĞ½-ĞŸÑŒĞµÑ€ Ğ¸ ĞœĞ¸ĞºĞµĞ»Ğ¾Ğ½",
  boe = () => "Ğ¡ĞµĞ½-ĞŸ'Ñ”Ñ€ Ñ– ĞœÑ–ĞºĞµĞ»Ğ¾Ğ½",
  xoe = () => "Saint Pierre vÃ  Miquelon",
  woe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? loe() : t === "pt" ? _oe() : t === "ch" ? hoe() : t === "de" ? doe() : t === "es" ? poe() : t === "fr" ? foe() : t === "it" ? moe() : t === "jp" ? goe() : t === "pl" ? yoe() : t === "ru" ? voe() : t === "uk" ? boe() : xoe()
  },
  koe = () => "Saint Vincent and the Grenadines",
  Toe = () => "SÃ£o Vicente e Granadinas",
  Soe = () => "åœ£æ–‡æ£®ç‰¹å’Œæ ¼æ—çº³ä¸æ–¯",
  Poe = () => "St. Vincent und die Grenadinen",
  Moe = () => "San Vicente y las Granadinas",
  Coe = () => "Saint-Vincent-et-les-Grenadines",
  Ioe = () => "Saint Vincent e Grenadine",
  zoe = () => "ã‚»ãƒ³ãƒˆãƒ“ãƒ³ã‚»ãƒ³ãƒˆãŠã‚ˆã³ã‚°ãƒ¬ãƒŠãƒ‡ã‚£ãƒ¼ãƒ³è«¸å³¶",
  Aoe = () => "Saint Vincent i Grenadyny",
  Eoe = () => "Ğ¡ĞµĞ½Ñ‚-Ğ’Ğ¸Ğ½ÑĞµĞ½Ñ‚ Ğ¸ Ğ“Ñ€ĞµĞ½Ğ°Ğ´Ğ¸Ğ½Ñ‹",
  joe = () => "Ğ¡ĞµĞ½Ñ‚-Ğ’Ñ–Ğ½ÑĞµĞ½Ñ‚ Ñ– Ğ“Ñ€ĞµĞ½Ğ°Ğ´Ğ¸Ğ½Ğ¸",
  Loe = () => "Saint Vincent vÃ  Grenadines",
  Doe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? koe() : t === "pt" ? Toe() : t === "ch" ? Soe() : t === "de" ? Poe() : t === "es" ? Moe() : t === "fr" ? Coe() : t === "it" ? Ioe() : t === "jp" ? zoe() : t === "pl" ? Aoe() : t === "ru" ? Eoe() : t === "uk" ? joe() : Loe()
  },
  Roe = () => "Samoa",
  Boe = () => "Samoa",
  Foe = () => "è¨æ‘©äºš",
  Ooe = () => "Samoa",
  qoe = () => "Samoa",
  Noe = () => "Samoa",
  Voe = () => "Samoa",
  Uoe = () => "ã‚µãƒ¢ã‚¢",
  Zoe = () => "Samoa",
  Goe = () => "Ğ¡Ğ°Ğ¼Ğ¾Ğ°",
  Hoe = () => "Ğ¡Ğ°Ğ¼Ğ¾Ğ°",
  Woe = () => "Samoa",
  $oe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Roe() : t === "pt" ? Boe() : t === "ch" ? Foe() : t === "de" ? Ooe() : t === "es" ? qoe() : t === "fr" ? Noe() : t === "it" ? Voe() : t === "jp" ? Uoe() : t === "pl" ? Zoe() : t === "ru" ? Goe() : t === "uk" ? Hoe() : Woe()
  },
  Xoe = () => "San Marino",
  Yoe = () => "San Marino",
  Koe = () => "åœ£é©¬åŠ›è¯º",
  Joe = () => "San Marino",
  Qoe = () => "San Marino",
  tse = () => "San Marino",
  ese = () => "San Marino",
  rse = () => "ã‚µãƒ³ãƒãƒªãƒ",
  nse = () => "San Marino",
  ise = () => "Ğ¡Ğ°Ğ½-ĞœĞ°Ñ€Ğ¸Ğ½Ğ¾",
  ose = () => "Ğ¡Ğ°Ğ½-ĞœĞ°Ñ€Ğ¸Ğ½Ğ¾",
  sse = () => "San Marino",
  ase = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Xoe() : t === "pt" ? Yoe() : t === "ch" ? Koe() : t === "de" ? Joe() : t === "es" ? Qoe() : t === "fr" ? tse() : t === "it" ? ese() : t === "jp" ? rse() : t === "pl" ? nse() : t === "ru" ? ise() : t === "uk" ? ose() : sse()
  },
  use = () => "Sao Tome and Principe",
  cse = () => "SÃ£o TomÃ© e PrÃ­ncipe",
  lse = () => "åœ£å¤šç¾å’Œæ™®æ—è¥¿æ¯”",
  _se = () => "SÃ£o TomÃ© und PrÃ­ncipe",
  hse = () => "Santo TomÃ© y PrÃ­ncipe",
  dse = () => "Sao TomÃ©-et-Principe",
  pse = () => "SÃ£o TomÃ© e PrÃ­ncipe",
  fse = () => "ã‚µãƒ³ãƒˆãƒ¡ãƒ»ãƒ—ãƒªãƒ³ã‚·ãƒš",
  mse = () => "Wyspy ÅšwiÄ™tego Tomasza i KsiÄ…Å¼Ä™ca",
  gse = () => "Ğ¡Ğ°Ğ½-Ğ¢Ğ¾Ğ¼Ğµ Ğ¸ ĞŸÑ€Ğ¸Ğ½ÑĞ¸Ğ¿Ğ¸",
  yse = () => "Ğ¡Ğ°Ğ½-Ğ¢Ğ¾Ğ¼Ğµ Ñ– ĞŸÑ€Ğ¸Ğ½ÑÑ–Ğ¿Ñ–",
  vse = () => "SÃ£o TomÃ© vÃ  PrÃ­ncipe",
  bse = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? use() : t === "pt" ? cse() : t === "ch" ? lse() : t === "de" ? _se() : t === "es" ? hse() : t === "fr" ? dse() : t === "it" ? pse() : t === "jp" ? fse() : t === "pl" ? mse() : t === "ru" ? gse() : t === "uk" ? yse() : vse()
  },
  xse = () => "Saudi Arabia",
  wse = () => "ArÃ¡bia Saudita",
  kse = () => "æ²™ç‰¹é˜¿æ‹‰ä¼¯",
  Tse = () => "Saudi-Arabien",
  Sse = () => "Arabia Saudita",
  Pse = () => "Arabie Saoudite",
  Mse = () => "Arabia Saudita",
  Cse = () => "ã‚µã‚¦ã‚¸ã‚¢ãƒ©ãƒ“ã‚¢",
  Ise = () => "Arabia Saudyjska",
  zse = () => "Ğ¡Ğ°ÑƒĞ´Ğ¾Ğ²ÑĞºĞ°Ñ ĞÑ€Ğ°Ğ²Ğ¸Ñ",
  Ase = () => "Ğ¡Ğ°ÑƒĞ´Ñ–Ğ²ÑÑŒĞºĞ° ĞÑ€Ğ°Ğ²Ñ–Ñ",
  Ese = () => "áº¢ Ráº­p XÃª Ãšt",
  jse = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xse() : t === "pt" ? wse() : t === "ch" ? kse() : t === "de" ? Tse() : t === "es" ? Sse() : t === "fr" ? Pse() : t === "it" ? Mse() : t === "jp" ? Cse() : t === "pl" ? Ise() : t === "ru" ? zse() : t === "uk" ? Ase() : Ese()
  },
  Lse = () => "Senegal",
  Dse = () => "Senegal",
  Rse = () => "å¡å†…åŠ å°”",
  Bse = () => "Senegal",
  Fse = () => "Senegal",
  Ose = () => "SÃ©nÃ©gal",
  qse = () => "Senegal",
  Nse = () => "ã‚»ãƒã‚¬ãƒ«",
  Vse = () => "Senegal",
  Use = () => "Ğ¡ĞµĞ½ĞµĞ³Ğ°Ğ»",
  Zse = () => "Ğ¡ĞµĞ½ĞµĞ³Ğ°Ğ»",
  Gse = () => "SÃª-nÃª-gan",
  Hse = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Lse() : t === "pt" ? Dse() : t === "ch" ? Rse() : t === "de" ? Bse() : t === "es" ? Fse() : t === "fr" ? Ose() : t === "it" ? qse() : t === "jp" ? Nse() : t === "pl" ? Vse() : t === "ru" ? Use() : t === "uk" ? Zse() : Gse()
  },
  Wse = () => "Serbia",
  $se = () => "SÃ©rvia",
  Xse = () => "å¡å°”ç»´äºš",
  Yse = () => "Serbien",
  Kse = () => "Serbia",
  Jse = () => "Serbie",
  Qse = () => "Serbia",
  tae = () => "ã‚»ãƒ«ãƒ“ã‚¢",
  eae = () => "Serbia",
  rae = () => "Ğ¡ĞµÑ€Ğ±Ğ¸Ñ",
  nae = () => "Ğ¡ĞµÑ€Ğ±Ñ–Ñ",
  iae = () => "Serbia",
  oae = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Wse() : t === "pt" ? $se() : t === "ch" ? Xse() : t === "de" ? Yse() : t === "es" ? Kse() : t === "fr" ? Jse() : t === "it" ? Qse() : t === "jp" ? tae() : t === "pl" ? eae() : t === "ru" ? rae() : t === "uk" ? nae() : iae()
  },
  sae = () => "Seychelles",
  aae = () => "Seicheles",
  uae = () => "å¡èˆŒå°”",
  cae = () => "Seychellen",
  lae = () => "Seychelles",
  _ae = () => "Seychelles",
  hae = () => "Seychelles",
  dae = () => "ã‚»ãƒ¼ã‚·ã‚§ãƒ«",
  pae = () => "Seszele",
  fae = () => "Ğ¡ĞµĞ¹ÑˆĞµĞ»ÑŒÑĞºĞ¸Ğµ ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  mae = () => "Ğ¡ĞµĞ¹ÑˆĞµĞ»ÑŒÑÑŒĞºÑ– ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  gae = () => "Seychelles",
  yae = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? sae() : t === "pt" ? aae() : t === "ch" ? uae() : t === "de" ? cae() : t === "es" ? lae() : t === "fr" ? _ae() : t === "it" ? hae() : t === "jp" ? dae() : t === "pl" ? pae() : t === "ru" ? fae() : t === "uk" ? mae() : gae()
  },
  vae = () => "Sierra Leone",
  bae = () => "Serra Leoa",
  xae = () => "å¡æ‹‰åˆ©æ˜‚",
  wae = () => "Sierra Leone",
  kae = () => "Sierra Leona",
  Tae = () => "Sierra Leone",
  Sae = () => "Sierra Leone",
  Pae = () => "ã‚·ã‚¨ãƒ©ãƒ¬ã‚ªãƒ",
  Mae = () => "Sierra Leone",
  Cae = () => "Ğ¡ÑŒĞµÑ€Ñ€Ğ°-Ğ›ĞµĞ¾Ğ½Ğµ",
  Iae = () => "Ğ¡ÑŒÑ”Ñ€Ñ€Ğ°-Ğ›ĞµĞ¾Ğ½Ğµ",
  zae = () => "Sierra Leone",
  Aae = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? vae() : t === "pt" ? bae() : t === "ch" ? xae() : t === "de" ? wae() : t === "es" ? kae() : t === "fr" ? Tae() : t === "it" ? Sae() : t === "jp" ? Pae() : t === "pl" ? Mae() : t === "ru" ? Cae() : t === "uk" ? Iae() : zae()
  },
  Eae = () => "Singapore",
  jae = () => "Singapura",
  Lae = () => "æ–°åŠ å¡",
  Dae = () => "Singapur",
  Rae = () => "Singapur",
  Bae = () => "Singapour",
  Fae = () => "Singapore",
  Oae = () => "ã‚·ãƒ³ã‚¬ãƒãƒ¼ãƒ«",
  qae = () => "Singapur",
  Nae = () => "Ğ¡Ğ¸Ğ½Ğ³Ğ°Ğ¿ÑƒÑ€",
  Vae = () => "Ğ¡Ñ–Ğ½Ğ³Ğ°Ğ¿ÑƒÑ€",
  Uae = () => "Singapore",
  Zae = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Eae() : t === "pt" ? jae() : t === "ch" ? Lae() : t === "de" ? Dae() : t === "es" ? Rae() : t === "fr" ? Bae() : t === "it" ? Fae() : t === "jp" ? Oae() : t === "pl" ? qae() : t === "ru" ? Nae() : t === "uk" ? Vae() : Uae()
  },
  Gae = () => "Sint Maarten (Dutch part)",
  Hae = () => "Sint Maarten (parte holandesa)",
  Wae = () => "è·å±åœ£é©¬ä¸",
  $ae = () => "Sint Maarten (niederlÃ¤ndischer Teil)",
  Xae = () => "Sint Maarten (parte neerlandesa)",
  Yae = () => "Sint Maarten (partie nÃ©erlandaise)",
  Kae = () => "Sint Maarten (parte olandese)",
  Jae = () => "ã‚·ãƒ³ãƒˆãƒ»ãƒãƒ¼ãƒ«ãƒ†ãƒ³ (ã‚ªãƒ©ãƒ³ãƒ€é ˜)",
  Qae = () => "Sint Maarten (czÄ™Å›Ä‡ holenderska)",
  tue = () => "Ğ¡Ğ¸Ğ½Ñ‚-ĞœĞ°Ñ€Ñ‚ĞµĞ½ (Ğ½Ğ¸Ğ´ĞµÑ€Ğ»Ğ°Ğ½Ğ´ÑĞºĞ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ)",
  eue = () => "Ğ¡Ñ–Ğ½Ñ‚-ĞœĞ°Ñ€Ñ‚ĞµĞ½ (Ğ½Ñ–Ğ´ĞµÑ€Ğ»Ğ°Ğ½Ğ´ÑÑŒĞºĞ° Ñ‡Ğ°ÑÑ‚Ğ¸Ğ½Ğ°)",
  rue = () => "Sint Maarten (pháº§n HÃ  Lan)",
  nue = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Gae() : t === "pt" ? Hae() : t === "ch" ? Wae() : t === "de" ? $ae() : t === "es" ? Xae() : t === "fr" ? Yae() : t === "it" ? Kae() : t === "jp" ? Jae() : t === "pl" ? Qae() : t === "ru" ? tue() : t === "uk" ? eue() : rue()
  },
  iue = () => "Slovakia",
  oue = () => "EslovÃ¡quia",
  sue = () => "æ–¯æ´›ä¼å…‹",
  aue = () => "Slowakei",
  uue = () => "Eslovaquia",
  cue = () => "Slovaquie",
  lue = () => "Slovacchia",
  _ue = () => "ã‚¹ãƒ­ãƒã‚­ã‚¢",
  hue = () => "SÅ‚owacja",
  due = () => "Ğ¡Ğ»Ğ¾Ğ²Ğ°ĞºĞ¸Ñ",
  pue = () => "Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ‡Ñ‡Ğ¸Ğ½Ğ°",
  fue = () => "Slovakia",
  mue = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? iue() : t === "pt" ? oue() : t === "ch" ? sue() : t === "de" ? aue() : t === "es" ? uue() : t === "fr" ? cue() : t === "it" ? lue() : t === "jp" ? _ue() : t === "pl" ? hue() : t === "ru" ? due() : t === "uk" ? pue() : fue()
  },
  gue = () => "Slovenia",
  yue = () => "EslovÃªnia",
  vue = () => "æ–¯æ´›æ–‡å°¼äºš",
  bue = () => "Slowenien",
  xue = () => "Eslovenia",
  wue = () => "SlovÃ©nie",
  kue = () => "Slovenia",
  Tue = () => "ã‚¹ãƒ­ãƒ™ãƒ‹ã‚¢",
  Sue = () => "SÅ‚owenia",
  Pue = () => "Ğ¡Ğ»Ğ¾Ğ²ĞµĞ½Ğ¸Ñ",
  Mue = () => "Ğ¡Ğ»Ğ¾Ğ²ĞµĞ½Ñ–Ñ",
  Cue = () => "Slovenia",
  Iue = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? gue() : t === "pt" ? yue() : t === "ch" ? vue() : t === "de" ? bue() : t === "es" ? xue() : t === "fr" ? wue() : t === "it" ? kue() : t === "jp" ? Tue() : t === "pl" ? Sue() : t === "ru" ? Pue() : t === "uk" ? Mue() : Cue()
  },
  zue = () => "Solomon Islands",
  Aue = () => "Ilhas SalomÃ£o",
  Eue = () => "æ‰€ç½—é—¨ç¾¤å²›",
  jue = () => "Salomonen",
  Lue = () => "Islas SalomÃ³n",
  Due = () => "Ãles Salomon",
  Rue = () => "Isole Salomone",
  Bue = () => "ã‚½ãƒ­ãƒ¢ãƒ³è«¸å³¶",
  Fue = () => "Wyspy Salomona",
  Oue = () => "Ğ¡Ğ¾Ğ»Ğ¾Ğ¼Ğ¾Ğ½Ğ¾Ğ²Ñ‹ ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  que = () => "Ğ¡Ğ¾Ğ»Ğ¾Ğ¼Ğ¾Ğ½Ğ¾Ğ²Ñ– ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  Nue = () => "Quáº§n Ä‘áº£o Solomon",
  Vue = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? zue() : t === "pt" ? Aue() : t === "ch" ? Eue() : t === "de" ? jue() : t === "es" ? Lue() : t === "fr" ? Due() : t === "it" ? Rue() : t === "jp" ? Bue() : t === "pl" ? Fue() : t === "ru" ? Oue() : t === "uk" ? que() : Nue()
  },
  Uue = () => "Somalia",
  Zue = () => "SomÃ¡lia",
  Gue = () => "ç´¢é©¬é‡Œ",
  Hue = () => "Somalia",
  Wue = () => "Somalia",
  $ue = () => "Somalie",
  Xue = () => "Somalia",
  Yue = () => "ã‚½ãƒãƒªã‚¢",
  Kue = () => "Somalia",
  Jue = () => "Ğ¡Ğ¾Ğ¼Ğ°Ğ»Ğ¸",
  Que = () => "Ğ¡Ğ¾Ğ¼Ğ°Ğ»Ñ–",
  tce = () => "Somalia",
  ece = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Uue() : t === "pt" ? Zue() : t === "ch" ? Gue() : t === "de" ? Hue() : t === "es" ? Wue() : t === "fr" ? $ue() : t === "it" ? Xue() : t === "jp" ? Yue() : t === "pl" ? Kue() : t === "ru" ? Jue() : t === "uk" ? Que() : tce()
  },
  rce = () => "South Africa",
  nce = () => "Ãfrica do Sul",
  ice = () => "å—é",
  oce = () => "SÃ¼dafrika",
  sce = () => "SudÃ¡frica",
  ace = () => "Afrique du Sud",
  uce = () => "Sudafrica",
  cce = () => "å—ã‚¢ãƒ•ãƒªã‚«",
  lce = () => "Afryka PoÅ‚udniowa",
  _ce = () => "Ğ®Ğ¶Ğ½Ğ°Ñ ĞÑ„Ñ€Ğ¸ĞºĞ°",
  hce = () => "ĞŸÑ–Ğ²Ğ´ĞµĞ½Ğ½Ğ° ĞÑ„Ñ€Ğ¸ĞºĞ°",
  dce = () => "Nam Phi",
  pce = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? rce() : t === "pt" ? nce() : t === "ch" ? ice() : t === "de" ? oce() : t === "es" ? sce() : t === "fr" ? ace() : t === "it" ? uce() : t === "jp" ? cce() : t === "pl" ? lce() : t === "ru" ? _ce() : t === "uk" ? hce() : dce()
  },
  fce = () => "South Georgia and the South Sandwich Islands",
  mce = () => "Ilhas GeÃ³rgia do Sul e Sandwich do Sul",
  gce = () => "å—ä¹”æ²»äºšå’Œå—æ¡‘å¨å¥‡ç¾¤å²›",
  yce = () => "SÃ¼dgeorgien und die SÃ¼dlichen Sandwichinseln",
  vce = () => "Islas Georgias del Sur y Sandwich del Sur",
  bce = () => "GÃ©orgie du Sud et Ã®les Sandwich du Sud",
  xce = () => "Georgia del Sud e Isole Sandwich del Sud",
  wce = () => "ã‚µã‚¦ã‚¹ã‚¸ãƒ§ãƒ¼ã‚¸ã‚¢ãƒ»ã‚µã‚¦ã‚¹ã‚µãƒ³ãƒ‰ã‚¦ã‚£ãƒƒãƒè«¸å³¶",
  kce = () => "Georgia PoÅ‚udniowa i Sandwich PoÅ‚udniowy",
  Tce = () => "Ğ®Ğ¶Ğ½Ğ°Ñ Ğ“ĞµĞ¾Ñ€Ğ³Ğ¸Ñ Ğ¸ Ğ®Ğ¶Ğ½Ñ‹Ğµ Ğ¡Ğ°Ğ½Ğ´Ğ²Ğ¸Ñ‡ĞµĞ²Ñ‹ ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  Sce = () => "ĞŸÑ–Ğ²Ğ´ĞµĞ½Ğ½Ğ° Ğ”Ğ¶Ğ¾Ñ€Ğ´Ğ¶Ñ–Ñ Ñ‚Ğ° ĞŸÑ–Ğ²Ğ´ĞµĞ½Ğ½Ñ– Ğ¡Ğ°Ğ½Ğ´Ğ²Ñ–Ñ‡ĞµĞ²Ñ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  Pce = () => "Nam Georgia vÃ  Quáº§n Ä‘áº£o Nam Sandwich",
  Mce = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? fce() : t === "pt" ? mce() : t === "ch" ? gce() : t === "de" ? yce() : t === "es" ? vce() : t === "fr" ? bce() : t === "it" ? xce() : t === "jp" ? wce() : t === "pl" ? kce() : t === "ru" ? Tce() : t === "uk" ? Sce() : Pce()
  },
  Cce = () => "South Korea",
  Ice = () => "Coreia do Sul",
  zce = () => "éŸ©å›½",
  Ace = () => "SÃ¼dkorea",
  Ece = () => "Corea del Sur",
  jce = () => "CorÃ©e du Sud",
  Lce = () => "Corea del Sud",
  Dce = () => "éŸ“å›½",
  Rce = () => "Korea PoÅ‚udniowa",
  Bce = () => "Ğ®Ğ¶Ğ½Ğ°Ñ ĞšĞ¾Ñ€ĞµÑ",
  Fce = () => "ĞŸÑ–Ğ²Ğ´ĞµĞ½Ğ½Ğ° ĞšĞ¾Ñ€ĞµÑ",
  Oce = () => "HÃ n Quá»‘c",
  qce = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Cce() : t === "pt" ? Ice() : t === "ch" ? zce() : t === "de" ? Ace() : t === "es" ? Ece() : t === "fr" ? jce() : t === "it" ? Lce() : t === "jp" ? Dce() : t === "pl" ? Rce() : t === "ru" ? Bce() : t === "uk" ? Fce() : Oce()
  },
  Nce = () => "South Sudan",
  Vce = () => "SudÃ£o do Sul",
  Uce = () => "å—è‹ä¸¹",
  Zce = () => "SÃ¼dsudan",
  Gce = () => "SudÃ¡n del Sur",
  Hce = () => "Soudan du Sud",
  Wce = () => "Sud Sudan",
  $ce = () => "å—ã‚¹ãƒ¼ãƒ€ãƒ³",
  Xce = () => "Sudan PoÅ‚udniowy",
  Yce = () => "Ğ®Ğ¶Ğ½Ñ‹Ğ¹ Ğ¡ÑƒĞ´Ğ°Ğ½",
  Kce = () => "ĞŸÑ–Ğ²Ğ´ĞµĞ½Ğ½Ğ¸Ğ¹ Ğ¡ÑƒĞ´Ğ°Ğ½",
  Jce = () => "Nam Sudan",
  Qce = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Nce() : t === "pt" ? Vce() : t === "ch" ? Uce() : t === "de" ? Zce() : t === "es" ? Gce() : t === "fr" ? Hce() : t === "it" ? Wce() : t === "jp" ? $ce() : t === "pl" ? Xce() : t === "ru" ? Yce() : t === "uk" ? Kce() : Jce()
  },
  tle = () => "Spain",
  ele = () => "Espanha",
  rle = () => "è¥¿ç­ç‰™",
  nle = () => "Spanien",
  ile = () => "EspaÃ±a",
  ole = () => "Espagne",
  sle = () => "Spagna",
  ale = () => "ã‚¹ãƒšã‚¤ãƒ³",
  ule = () => "Hiszpania",
  cle = () => "Ğ˜ÑĞ¿Ğ°Ğ½Ğ¸Ñ",
  lle = () => "Ğ†ÑĞ¿Ğ°Ğ½Ñ–Ñ",
  _le = () => "TÃ¢y Ban Nha",
  hle = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? tle() : t === "pt" ? ele() : t === "ch" ? rle() : t === "de" ? nle() : t === "es" ? ile() : t === "fr" ? ole() : t === "it" ? sle() : t === "jp" ? ale() : t === "pl" ? ule() : t === "ru" ? cle() : t === "uk" ? lle() : _le()
  },
  dle = () => "Sri Lanka",
  ple = () => "Sri Lanka",
  fle = () => "æ–¯é‡Œå…°å¡",
  mle = () => "Sri Lanka",
  gle = () => "Sri Lanka",
  yle = () => "Sri Lanka",
  vle = () => "Sri Lanka",
  ble = () => "ã‚¹ãƒªãƒ©ãƒ³ã‚«",
  xle = () => "Sri Lanka",
  wle = () => "Ğ¨Ñ€Ğ¸-Ğ›Ğ°Ğ½ĞºĞ°",
  kle = () => "Ğ¨Ñ€Ñ–-Ğ›Ğ°Ğ½ĞºĞ°",
  Tle = () => "Sri Lanka",
  Sle = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? dle() : t === "pt" ? ple() : t === "ch" ? fle() : t === "de" ? mle() : t === "es" ? gle() : t === "fr" ? yle() : t === "it" ? vle() : t === "jp" ? ble() : t === "pl" ? xle() : t === "ru" ? wle() : t === "uk" ? kle() : Tle()
  },
  Ple = () => "Sudan",
  Mle = () => "SudÃ£o",
  Cle = () => "è‹ä¸¹",
  Ile = () => "Sudan",
  zle = () => "SudÃ¡n",
  Ale = () => "Soudan",
  Ele = () => "Sudan",
  jle = () => "ã‚¹ãƒ¼ãƒ€ãƒ³",
  Lle = () => "Sudan",
  Dle = () => "Ğ¡ÑƒĞ´Ğ°Ğ½",
  Rle = () => "Ğ¡ÑƒĞ´Ğ°Ğ½",
  Ble = () => "Sudan",
  Fle = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ple() : t === "pt" ? Mle() : t === "ch" ? Cle() : t === "de" ? Ile() : t === "es" ? zle() : t === "fr" ? Ale() : t === "it" ? Ele() : t === "jp" ? jle() : t === "pl" ? Lle() : t === "ru" ? Dle() : t === "uk" ? Rle() : Ble()
  },
  Ole = () => "Suriname",
  qle = () => "Suriname",
  Nle = () => "è‹é‡Œå—",
  Vle = () => "Suriname",
  Ule = () => "Surinam",
  Zle = () => "Suriname",
  Gle = () => "Suriname",
  Hle = () => "ã‚¹ãƒªãƒŠãƒ ",
  Wle = () => "Surinam",
  $le = () => "Ğ¡ÑƒÑ€Ğ¸Ğ½Ğ°Ğ¼",
  Xle = () => "Ğ¡ÑƒÑ€Ğ¸Ğ½Ğ°Ğ¼",
  Yle = () => "Suriname",
  Kle = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ole() : t === "pt" ? qle() : t === "ch" ? Nle() : t === "de" ? Vle() : t === "es" ? Ule() : t === "fr" ? Zle() : t === "it" ? Gle() : t === "jp" ? Hle() : t === "pl" ? Wle() : t === "ru" ? $le() : t === "uk" ? Xle() : Yle()
  },
  Jle = () => "Svalbard and Jan Mayen",
  Qle = () => "Svalbard e Jan Mayen",
  t_e = () => "æ–¯ç“¦å°”å·´å’Œæ‰¬é©¬å»¶",
  e_e = () => "Spitzbergen und Jan Mayen",
  r_e = () => "Svalbard y Jan Mayen",
  n_e = () => "Svalbard et Jan Mayen",
  i_e = () => "Svalbard e Jan Mayen",
  o_e = () => "ã‚¹ãƒ´ã‚¡ãƒ¼ãƒ«ãƒãƒ«è«¸å³¶ãŠã‚ˆã³ãƒ¤ãƒ³ãƒã‚¤ã‚¨ãƒ³",
  s_e = () => "Svalbard i Jan Mayen",
  a_e = () => "Ğ¨Ğ¿Ğ¸Ñ†Ğ±ĞµÑ€Ğ³ĞµĞ½ Ğ¸ Ğ¯Ğ½-ĞœĞ°Ğ¹ĞµĞ½",
  u_e = () => "Ğ¨Ğ¿Ñ–Ñ†Ğ±ĞµÑ€Ğ³ĞµĞ½ Ñ‚Ğ° Ğ¯Ğ½-ĞœĞ°Ñ”Ğ½",
  c_e = () => "Svalbard vÃ  Jan Mayen",
  l_e = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Jle() : t === "pt" ? Qle() : t === "ch" ? t_e() : t === "de" ? e_e() : t === "es" ? r_e() : t === "fr" ? n_e() : t === "it" ? i_e() : t === "jp" ? o_e() : t === "pl" ? s_e() : t === "ru" ? a_e() : t === "uk" ? u_e() : c_e()
  },
  __e = () => "Sweden",
  h_e = () => "SuÃ©cia",
  d_e = () => "ç‘å…¸",
  p_e = () => "Schweden",
  f_e = () => "Suecia",
  m_e = () => "SuÃ¨de",
  g_e = () => "Svezia",
  y_e = () => "ã‚¹ã‚¦ã‚§ãƒ¼ãƒ‡ãƒ³",
  v_e = () => "Szwecja",
  b_e = () => "Ğ¨Ğ²ĞµÑ†Ğ¸Ñ",
  x_e = () => "Ğ¨Ğ²ĞµÑ†Ñ–Ñ",
  w_e = () => "Thá»¥y Äiá»ƒn",
  k_e = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? __e() : t === "pt" ? h_e() : t === "ch" ? d_e() : t === "de" ? p_e() : t === "es" ? f_e() : t === "fr" ? m_e() : t === "it" ? g_e() : t === "jp" ? y_e() : t === "pl" ? v_e() : t === "ru" ? b_e() : t === "uk" ? x_e() : w_e()
  },
  T_e = () => "Switzerland",
  S_e = () => "SuÃ­Ã§a",
  P_e = () => "ç‘å£«",
  M_e = () => "Schweiz",
  C_e = () => "Suiza",
  I_e = () => "Suisse",
  z_e = () => "Svizzera",
  A_e = () => "ã‚¹ã‚¤ã‚¹",
  E_e = () => "Szwajcaria",
  j_e = () => "Ğ¨Ğ²ĞµĞ¹Ñ†Ğ°Ñ€Ğ¸Ñ",
  L_e = () => "Ğ¨Ğ²ĞµĞ¹Ñ†Ğ°Ñ€Ñ–Ñ",
  D_e = () => "Thá»¥y SÄ©",
  R_e = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? T_e() : t === "pt" ? S_e() : t === "ch" ? P_e() : t === "de" ? M_e() : t === "es" ? C_e() : t === "fr" ? I_e() : t === "it" ? z_e() : t === "jp" ? A_e() : t === "pl" ? E_e() : t === "ru" ? j_e() : t === "uk" ? L_e() : D_e()
  },
  B_e = () => "Syrian Arab Republic",
  F_e = () => "RepÃºblica Ãrabe SÃ­ria",
  O_e = () => "é˜¿æ‹‰ä¼¯å™åˆ©äºšå…±å’Œå›½",
  q_e = () => "Syrische Arabische Republik",
  N_e = () => "RepÃºblica Ãrabe Siria",
  V_e = () => "RÃ©publique arabe syrienne",
  U_e = () => "Repubblica Araba Siriana",
  Z_e = () => "ã‚·ãƒªã‚¢ãƒ»ã‚¢ãƒ©ãƒ–å…±å’Œå›½",
  G_e = () => "Syryjska Republika Arabska",
  H_e = () => "Ğ¡Ğ¸Ñ€Ğ¸Ğ¹ÑĞºĞ°Ñ ĞÑ€Ğ°Ğ±ÑĞºĞ°Ñ Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°",
  W_e = () => "Ğ¡Ğ¸Ñ€Ñ–Ğ¹ÑÑŒĞºĞ° ĞÑ€Ğ°Ğ±ÑÑŒĞºĞ° Ğ ĞµÑĞ¿ÑƒĞ±Ğ»Ñ–ĞºĞ°",
  $_e = () => "Cá»™ng hÃ²a áº¢ Ráº­p Syria",
  X_e = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? B_e() : t === "pt" ? F_e() : t === "ch" ? O_e() : t === "de" ? q_e() : t === "es" ? N_e() : t === "fr" ? V_e() : t === "it" ? U_e() : t === "jp" ? Z_e() : t === "pl" ? G_e() : t === "ru" ? H_e() : t === "uk" ? W_e() : $_e()
  },
  Y_e = () => "Taiwan",
  K_e = () => "Taiwan",
  J_e = () => "å°æ¹¾",
  Q_e = () => "Taiwan",
  the = () => "TaiwÃ¡n",
  ehe = () => "TaÃ¯wan",
  rhe = () => "Taiwan",
  nhe = () => "å°æ¹¾",
  ihe = () => "Tajwan",
  ohe = () => "Ğ¢Ğ°Ğ¹Ğ²Ğ°Ğ½ÑŒ",
  she = () => "Ğ¢Ğ°Ğ¹Ğ²Ğ°Ğ½ÑŒ",
  ahe = () => "ÄÃ i Loan",
  uhe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Y_e() : t === "pt" ? K_e() : t === "ch" ? J_e() : t === "de" ? Q_e() : t === "es" ? the() : t === "fr" ? ehe() : t === "it" ? rhe() : t === "jp" ? nhe() : t === "pl" ? ihe() : t === "ru" ? ohe() : t === "uk" ? she() : ahe()
  },
  che = () => "Tajikistan",
  lhe = () => "TajiquistÃ£o",
  _he = () => "å¡”å‰å…‹æ–¯å¦",
  hhe = () => "Tadschikistan",
  dhe = () => "TayikistÃ¡n",
  phe = () => "Tadjikistan",
  fhe = () => "Tagikistan",
  mhe = () => "ã‚¿ã‚¸ã‚­ã‚¹ã‚¿ãƒ³",
  ghe = () => "TadÅ¼ykistan",
  yhe = () => "Ğ¢Ğ°Ğ´Ğ¶Ğ¸ĞºĞ¸ÑÑ‚Ğ°Ğ½",
  vhe = () => "Ğ¢Ğ°Ğ´Ğ¶Ğ¸ĞºĞ¸ÑÑ‚Ğ°Ğ½",
  bhe = () => "Tajikistan",
  xhe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? che() : t === "pt" ? lhe() : t === "ch" ? _he() : t === "de" ? hhe() : t === "es" ? dhe() : t === "fr" ? phe() : t === "it" ? fhe() : t === "jp" ? mhe() : t === "pl" ? ghe() : t === "ru" ? yhe() : t === "uk" ? vhe() : bhe()
  },
  whe = () => "Tanzania",
  khe = () => "TanzÃ¢nia",
  The = () => "å¦æ¡‘å°¼äºš",
  She = () => "Tansania",
  Phe = () => "Tanzania",
  Mhe = () => "Tanzanie",
  Che = () => "Tanzania",
  Ihe = () => "ã‚¿ãƒ³ã‚¶ãƒ‹ã‚¢",
  zhe = () => "Tanzania",
  Ahe = () => "Ğ¢Ğ°Ğ½Ğ·Ğ°Ğ½Ğ¸Ñ",
  Ehe = () => "Ğ¢Ğ°Ğ½Ğ·Ğ°Ğ½Ñ–Ñ",
  jhe = () => "Tanzania",
  Lhe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? whe() : t === "pt" ? khe() : t === "ch" ? The() : t === "de" ? She() : t === "es" ? Phe() : t === "fr" ? Mhe() : t === "it" ? Che() : t === "jp" ? Ihe() : t === "pl" ? zhe() : t === "ru" ? Ahe() : t === "uk" ? Ehe() : jhe()
  },
  Dhe = () => "Thailand",
  Rhe = () => "TailÃ¢ndia",
  Bhe = () => "æ³°å›½",
  Fhe = () => "Thailand",
  Ohe = () => "Tailandia",
  qhe = () => "ThaÃ¯lande",
  Nhe = () => "Thailandia",
  Vhe = () => "ã‚¿ã‚¤",
  Uhe = () => "Tajlandia",
  Zhe = () => "Ğ¢Ğ°Ğ¸Ğ»Ğ°Ğ½Ğ´",
  Ghe = () => "Ğ¢Ğ°Ñ—Ğ»Ğ°Ğ½Ğ´",
  Hhe = () => "ThÃ¡i Lan",
  Whe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Dhe() : t === "pt" ? Rhe() : t === "ch" ? Bhe() : t === "de" ? Fhe() : t === "es" ? Ohe() : t === "fr" ? qhe() : t === "it" ? Nhe() : t === "jp" ? Vhe() : t === "pl" ? Uhe() : t === "ru" ? Zhe() : t === "uk" ? Ghe() : Hhe()
  },
  $he = () => "Timor-Leste",
  Xhe = () => "Timor-Leste",
  Yhe = () => "ä¸œå¸æ±¶",
  Khe = () => "Timor-Leste",
  Jhe = () => "Timor-Leste",
  Qhe = () => "Timor-Leste",
  tde = () => "Timor-Leste",
  ede = () => "æ±ãƒ†ã‚£ãƒ¢ãƒ¼ãƒ«",
  rde = () => "Timor Wschodni",
  nde = () => "Ğ¢Ğ¸Ğ¼Ğ¾Ñ€-Ğ›ĞµÑˆÑ‚Ğ¸",
  ide = () => "Ğ¢Ñ–Ğ¼Ğ¾Ñ€-Ğ›ĞµÑˆÑ‚Ñ–",
  ode = () => "Timor-Leste",
  sde = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? $he() : t === "pt" ? Xhe() : t === "ch" ? Yhe() : t === "de" ? Khe() : t === "es" ? Jhe() : t === "fr" ? Qhe() : t === "it" ? tde() : t === "jp" ? ede() : t === "pl" ? rde() : t === "ru" ? nde() : t === "uk" ? ide() : ode()
  },
  ade = () => "Togo",
  ude = () => "Togo",
  cde = () => "å¤šå“¥",
  lde = () => "Togo",
  _de = () => "Togo",
  hde = () => "Togo",
  dde = () => "Togo",
  pde = () => "ãƒˆãƒ¼ã‚´",
  fde = () => "Togo",
  mde = () => "Ğ¢Ğ¾Ğ³Ğ¾",
  gde = () => "Ğ¢Ğ¾Ğ³Ğ¾",
  yde = () => "TÃ´-gÃ´",
  vde = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ade() : t === "pt" ? ude() : t === "ch" ? cde() : t === "de" ? lde() : t === "es" ? _de() : t === "fr" ? hde() : t === "it" ? dde() : t === "jp" ? pde() : t === "pl" ? fde() : t === "ru" ? mde() : t === "uk" ? gde() : yde()
  },
  bde = () => "Tokelau",
  xde = () => "Tokelau",
  wde = () => "æ‰˜å…‹åŠ³",
  kde = () => "Tokelau",
  Tde = () => "Tokelau",
  Sde = () => "Tokelau",
  Pde = () => "Tokelau",
  Mde = () => "ãƒˆã‚±ãƒ©ã‚¦",
  Cde = () => "Tokelau",
  Ide = () => "Ğ¢Ğ¾ĞºĞµĞ»Ğ°Ñƒ",
  zde = () => "Ğ¢Ğ¾ĞºĞµĞ»Ğ°Ñƒ",
  Ade = () => "Tokelau",
  Ede = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? bde() : t === "pt" ? xde() : t === "ch" ? wde() : t === "de" ? kde() : t === "es" ? Tde() : t === "fr" ? Sde() : t === "it" ? Pde() : t === "jp" ? Mde() : t === "pl" ? Cde() : t === "ru" ? Ide() : t === "uk" ? zde() : Ade()
  },
  jde = () => "Tonga",
  Lde = () => "Tonga",
  Dde = () => "æ±¤åŠ ",
  Rde = () => "Tonga",
  Bde = () => "Tonga",
  Fde = () => "Tonga",
  Ode = () => "Tonga",
  qde = () => "ãƒˆãƒ³ã‚¬",
  Nde = () => "Tonga",
  Vde = () => "Ğ¢Ğ¾Ğ½Ğ³Ğ°",
  Ude = () => "Ğ¢Ğ¾Ğ½Ğ³Ğ°",
  Zde = () => "Tonga",
  Gde = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? jde() : t === "pt" ? Lde() : t === "ch" ? Dde() : t === "de" ? Rde() : t === "es" ? Bde() : t === "fr" ? Fde() : t === "it" ? Ode() : t === "jp" ? qde() : t === "pl" ? Nde() : t === "ru" ? Vde() : t === "uk" ? Ude() : Zde()
  },
  Hde = () => "Trinidad and Tobago",
  Wde = () => "Trinidade e Tobago",
  $de = () => "ç‰¹ç«‹å°¼è¾¾å’Œå¤šå·´å“¥",
  Xde = () => "Trinidad und Tobago",
  Yde = () => "Trinidad y Tobago",
  Kde = () => "TrinitÃ©-et-Tobago",
  Jde = () => "Trinidad e Tobago",
  Qde = () => "ãƒˆãƒªãƒ‹ãƒ€ãƒ¼ãƒ‰ãƒ»ãƒˆãƒã‚´",
  tpe = () => "Trynidad i Tobago",
  epe = () => "Ğ¢Ñ€Ğ¸Ğ½Ğ¸Ğ´Ğ°Ğ´ Ğ¸ Ğ¢Ğ¾Ğ±Ğ°Ğ³Ğ¾",
  rpe = () => "Ğ¢Ñ€Ğ¸Ğ½Ñ–Ğ´Ğ°Ğ´ Ñ– Ğ¢Ğ¾Ğ±Ğ°Ğ³Ğ¾",
  npe = () => "Trinidad vÃ  Tobago",
  ipe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Hde() : t === "pt" ? Wde() : t === "ch" ? $de() : t === "de" ? Xde() : t === "es" ? Yde() : t === "fr" ? Kde() : t === "it" ? Jde() : t === "jp" ? Qde() : t === "pl" ? tpe() : t === "ru" ? epe() : t === "uk" ? rpe() : npe()
  },
  ope = () => "Tunisia",
  spe = () => "TunÃ­sia",
  ape = () => "çªå°¼æ–¯",
  upe = () => "Tunesien",
  cpe = () => "TÃºnez",
  lpe = () => "Tunisie",
  _pe = () => "Tunisia",
  hpe = () => "ãƒãƒ¥ãƒ‹ã‚¸ã‚¢",
  dpe = () => "Tunezja",
  ppe = () => "Ğ¢ÑƒĞ½Ğ¸Ñ",
  fpe = () => "Ğ¢ÑƒĞ½Ñ–Ñ",
  mpe = () => "Tunisia",
  gpe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ope() : t === "pt" ? spe() : t === "ch" ? ape() : t === "de" ? upe() : t === "es" ? cpe() : t === "fr" ? lpe() : t === "it" ? _pe() : t === "jp" ? hpe() : t === "pl" ? dpe() : t === "ru" ? ppe() : t === "uk" ? fpe() : mpe()
  },
  ype = () => "Turkmenistan",
  vpe = () => "TurcomenistÃ£o",
  bpe = () => "åœŸåº“æ›¼æ–¯å¦",
  xpe = () => "Turkmenistan",
  wpe = () => "TurkmenistÃ¡n",
  kpe = () => "TurkmÃ©nistan",
  Tpe = () => "Turkmenistan",
  Spe = () => "ãƒˆãƒ«ã‚¯ãƒ¡ãƒ‹ã‚¹ã‚¿ãƒ³",
  Ppe = () => "Turkmenistan",
  Mpe = () => "Ğ¢ÑƒÑ€ĞºĞ¼ĞµĞ½Ğ¸ÑÑ‚Ğ°Ğ½",
  Cpe = () => "Ğ¢ÑƒÑ€ĞºĞ¼ĞµĞ½Ñ–ÑÑ‚Ğ°Ğ½",
  Ipe = () => "Turkmenistan",
  zpe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? ype() : t === "pt" ? vpe() : t === "ch" ? bpe() : t === "de" ? xpe() : t === "es" ? wpe() : t === "fr" ? kpe() : t === "it" ? Tpe() : t === "jp" ? Spe() : t === "pl" ? Ppe() : t === "ru" ? Mpe() : t === "uk" ? Cpe() : Ipe()
  },
  Ape = () => "Turks and Caicos Islands",
  Epe = () => "Ilhas Turcas e Caicos",
  jpe = () => "ç‰¹å…‹æ–¯å’Œå‡¯ç§‘æ–¯ç¾¤å²›",
  Lpe = () => "Turks- und Caicosinseln",
  Dpe = () => "Islas Turcas y Caicos",
  Rpe = () => "Ãles Turques-et-CaÃ¯ques",
  Bpe = () => "Isole Turks e Caicos",
  Fpe = () => "ã‚¿ãƒ¼ã‚¯ã‚¹ãƒ»ã‚«ã‚¤ã‚³ã‚¹è«¸å³¶",
  Ope = () => "Wyspy Turks i Caicos",
  qpe = () => "ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ° Ğ¢ĞµÑ€ĞºÑ Ğ¸ ĞšĞ°Ğ¹ĞºĞ¾Ñ",
  Npe = () => "ĞÑÑ‚Ñ€Ğ¾Ğ²Ğ¸ Ğ¢ĞµÑ€ĞºÑ Ñ– ĞšĞ°Ğ¹ĞºĞ¾Ñ",
  Vpe = () => "Quáº§n Ä‘áº£o Turks vÃ  Caicos",
  Upe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ape() : t === "pt" ? Epe() : t === "ch" ? jpe() : t === "de" ? Lpe() : t === "es" ? Dpe() : t === "fr" ? Rpe() : t === "it" ? Bpe() : t === "jp" ? Fpe() : t === "pl" ? Ope() : t === "ru" ? qpe() : t === "uk" ? Npe() : Vpe()
  },
  Zpe = () => "Tuvalu",
  Gpe = () => "Tuvalu",
  Hpe = () => "å›¾ç“¦å¢",
  Wpe = () => "Tuvalu",
  $pe = () => "Tuvalu",
  Xpe = () => "Tuvalu",
  Ype = () => "Tuvalu",
  Kpe = () => "ãƒ„ãƒãƒ«",
  Jpe = () => "Tuvalu",
  Qpe = () => "Ğ¢ÑƒĞ²Ğ°Ğ»Ñƒ",
  tfe = () => "Ğ¢ÑƒĞ²Ğ°Ğ»Ñƒ",
  efe = () => "Tuvalu",
  rfe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Zpe() : t === "pt" ? Gpe() : t === "ch" ? Hpe() : t === "de" ? Wpe() : t === "es" ? $pe() : t === "fr" ? Xpe() : t === "it" ? Ype() : t === "jp" ? Kpe() : t === "pl" ? Jpe() : t === "ru" ? Qpe() : t === "uk" ? tfe() : efe()
  },
  nfe = () => "TÃ¼rkiye",
  ife = () => "Turquia",
  ofe = () => "åœŸè€³å…¶",
  sfe = () => "TÃ¼rkei",
  afe = () => "TurquÃ­a",
  ufe = () => "Turquie",
  cfe = () => "Turchia",
  lfe = () => "ãƒˆãƒ«ã‚³",
  _fe = () => "Turcja",
  hfe = () => "Ğ¢ÑƒÑ€Ñ†Ğ¸Ñ",
  dfe = () => "Ğ¢ÑƒÑ€ĞµÑ‡Ñ‡Ğ¸Ğ½Ğ°",
  pfe = () => "Thá»• NhÄ© Ká»³",
  ffe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? nfe() : t === "pt" ? ife() : t === "ch" ? ofe() : t === "de" ? sfe() : t === "es" ? afe() : t === "fr" ? ufe() : t === "it" ? cfe() : t === "jp" ? lfe() : t === "pl" ? _fe() : t === "ru" ? hfe() : t === "uk" ? dfe() : pfe()
  },
  mfe = () => "Uganda",
  gfe = () => "Uganda",
  yfe = () => "ä¹Œå¹²è¾¾",
  vfe = () => "Uganda",
  bfe = () => "Uganda",
  xfe = () => "Ouganda",
  wfe = () => "Uganda",
  kfe = () => "ã‚¦ã‚¬ãƒ³ãƒ€",
  Tfe = () => "Uganda",
  Sfe = () => "Ğ£Ğ³Ğ°Ğ½Ğ´Ğ°",
  Pfe = () => "Ğ£Ğ³Ğ°Ğ½Ğ´Ğ°",
  Mfe = () => "Uganda",
  Cfe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? mfe() : t === "pt" ? gfe() : t === "ch" ? yfe() : t === "de" ? vfe() : t === "es" ? bfe() : t === "fr" ? xfe() : t === "it" ? wfe() : t === "jp" ? kfe() : t === "pl" ? Tfe() : t === "ru" ? Sfe() : t === "uk" ? Pfe() : Mfe()
  },
  Ife = () => "Ukraine",
  zfe = () => "UcrÃ¢nia",
  Afe = () => "ä¹Œå…‹å…°",
  Efe = () => "Ukraine",
  jfe = () => "Ucrania",
  Lfe = () => "Ukraine",
  Dfe = () => "Ucraina",
  Rfe = () => "ã‚¦ã‚¯ãƒ©ã‚¤ãƒŠ",
  Bfe = () => "Ukraina",
  Ffe = () => "Ğ£ĞºÑ€Ğ°Ğ¸Ğ½Ğ°",
  Ofe = () => "Ğ£ĞºÑ€Ğ°Ñ—Ğ½Ğ°",
  qfe = () => "Ukraina",
  Nfe = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Ife() : t === "pt" ? zfe() : t === "ch" ? Afe() : t === "de" ? Efe() : t === "es" ? jfe() : t === "fr" ? Lfe() : t === "it" ? Dfe() : t === "jp" ? Rfe() : t === "pl" ? Bfe() : t === "ru" ? Ffe() : t === "uk" ? Ofe() : qfe()
  },
  Vfe = () => "United Arab Emirates",
  Ufe = () => "Emirados Ãrabes Unidos",
  Zfe = () => "é˜¿æ‹‰ä¼¯è”åˆé…‹é•¿å›½",
  Gfe = () => "Vereinigte Arabische Emirate",
  Hfe = () => "Emiratos Ãrabes Unidos",
  Wfe = () => "Ã‰mirats arabes unis",
  $fe = () => "Emirati Arabi Uniti",
  Xfe = () => "ã‚¢ãƒ©ãƒ–é¦–é•·å›½é€£é‚¦",
  Yfe = () => "Zjednoczone Emiraty Arabskie",
  Kfe = () => "ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ½Ñ‹Ğµ ĞÑ€Ğ°Ğ±ÑĞºĞ¸Ğµ Ğ­Ğ¼Ğ¸Ñ€Ğ°Ñ‚Ñ‹",
  Jfe = () => "ĞĞ±'Ñ”Ğ´Ğ½Ğ°Ğ½Ñ– ĞÑ€Ğ°Ğ±ÑÑŒĞºÑ– Ğ•Ğ¼Ñ–Ñ€Ğ°Ñ‚Ğ¸",
  Qfe = () => "CÃ¡c Tiá»ƒu vÆ°Æ¡ng quá»‘c áº¢ Ráº­p Thá»‘ng nháº¥t",
  tme = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Vfe() : t === "pt" ? Ufe() : t === "ch" ? Zfe() : t === "de" ? Gfe() : t === "es" ? Hfe() : t === "fr" ? Wfe() : t === "it" ? $fe() : t === "jp" ? Xfe() : t === "pl" ? Yfe() : t === "ru" ? Kfe() : t === "uk" ? Jfe() : Qfe()
  },
  eme = () => "United Kingdom",
  rme = () => "Reino Unido",
  nme = () => "è‹±å›½",
  ime = () => "Vereinigtes KÃ¶nigreich",
  ome = () => "Reino Unido",
  sme = () => "Royaume-Uni",
  ame = () => "Regno Unito",
  ume = () => "ã‚¤ã‚®ãƒªã‚¹",
  cme = () => "Zjednoczone KrÃ³lestwo",
  lme = () => "Ğ’ĞµĞ»Ğ¸ĞºĞ¾Ğ±Ñ€Ğ¸Ñ‚Ğ°Ğ½Ğ¸Ñ",
  _me = () => "ĞĞ±'Ñ”Ğ´Ğ½Ğ°Ğ½Ğµ ĞšĞ¾Ñ€Ğ¾Ğ»Ñ–Ğ²ÑÑ‚Ğ²Ğ¾",
  hme = () => "VÆ°Æ¡ng quá»‘c Anh",
  dme = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? eme() : t === "pt" ? rme() : t === "ch" ? nme() : t === "de" ? ime() : t === "es" ? ome() : t === "fr" ? sme() : t === "it" ? ame() : t === "jp" ? ume() : t === "pl" ? cme() : t === "ru" ? lme() : t === "uk" ? _me() : hme()
  },
  pme = () => "United States",
  fme = () => "Estados Unidos",
  mme = () => "ç¾å›½",
  gme = () => "Vereinigte Staaten",
  yme = () => "Estados Unidos",
  vme = () => "Ã‰tats-Unis",
  bme = () => "Stati Uniti",
  xme = () => "ã‚¢ãƒ¡ãƒªã‚«åˆè¡†å›½",
  wme = () => "Stany Zjednoczone",
  kme = () => "Ğ¡Ğ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ½Ñ‹Ğµ Ğ¨Ñ‚Ğ°Ñ‚Ñ‹",
  Tme = () => "Ğ¡Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ñ– Ğ¨Ñ‚Ğ°Ñ‚Ğ¸",
  Sme = () => "Hoa Ká»³",
  Pme = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? pme() : t === "pt" ? fme() : t === "ch" ? mme() : t === "de" ? gme() : t === "es" ? yme() : t === "fr" ? vme() : t === "it" ? bme() : t === "jp" ? xme() : t === "pl" ? wme() : t === "ru" ? kme() : t === "uk" ? Tme() : Sme()
  },
  Mme = () => "United States Minor Outlying Islands",
  Cme = () => "Ilhas Menores Distantes dos Estados Unidos",
  Ime = () => "ç¾å›½æœ¬åœŸå¤–å°å²›å±¿",
  zme = () => "Kleinere Outlying Islands der Vereinigten Staaten",
  Ame = () => "Islas Ultramarinas Menores de Estados Unidos",
  Eme = () => "Ãles mineures Ã©loignÃ©es des Ã‰tats-Unis",
  jme = () => "Isole minori esterne degli Stati Uniti",
  Lme = () => "åˆè¡†å›½é ˜æœ‰å°é›¢å³¶",
  Dme = () => "Dalekie Wyspy Mniejsze StanÃ³w Zjednoczonych",
  Rme = () => "Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğµ Ğ¼Ğ°Ğ»Ñ‹Ğµ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ° Ğ¡Ğ¨Ğ",
  Bme = () => "Ğ—Ğ¾Ğ²Ğ½Ñ–ÑˆĞ½Ñ– Ğ¼Ğ°Ğ»Ñ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸ Ğ¡Ğ¨Ğ",
  Fme = () => "CÃ¡c tiá»ƒu Ä‘áº£o xa cá»§a Hoa Ká»³",
  Ome = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Mme() : t === "pt" ? Cme() : t === "ch" ? Ime() : t === "de" ? zme() : t === "es" ? Ame() : t === "fr" ? Eme() : t === "it" ? jme() : t === "jp" ? Lme() : t === "pl" ? Dme() : t === "ru" ? Rme() : t === "uk" ? Bme() : Fme()
  },
  qme = () => "Uruguay",
  Nme = () => "Uruguai",
  Vme = () => "ä¹Œæ‹‰åœ­",
  Ume = () => "Uruguay",
  Zme = () => "Uruguay",
  Gme = () => "Uruguay",
  Hme = () => "Uruguay",
  Wme = () => "ã‚¦ãƒ«ã‚°ã‚¢ã‚¤",
  $me = () => "Urugwaj",
  Xme = () => "Ğ£Ñ€ÑƒĞ³Ğ²Ğ°Ğ¹",
  Yme = () => "Ğ£Ñ€ÑƒĞ³Ğ²Ğ°Ğ¹",
  Kme = () => "Uruguay",
  Jme = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? qme() : t === "pt" ? Nme() : t === "ch" ? Vme() : t === "de" ? Ume() : t === "es" ? Zme() : t === "fr" ? Gme() : t === "it" ? Hme() : t === "jp" ? Wme() : t === "pl" ? $me() : t === "ru" ? Xme() : t === "uk" ? Yme() : Kme()
  },
  Qme = () => "Uzbekistan",
  tge = () => "UzbequistÃ£o",
  ege = () => "ä¹Œå…¹åˆ«å…‹æ–¯å¦",
  rge = () => "Usbekistan",
  nge = () => "UzbekistÃ¡n",
  ige = () => "OuzbÃ©kistan",
  oge = () => "Uzbekistan",
  sge = () => "ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³",
  age = () => "Uzbekistan",
  uge = () => "Ğ£Ğ·Ğ±ĞµĞºĞ¸ÑÑ‚Ğ°Ğ½",
  cge = () => "Ğ£Ğ·Ğ±ĞµĞºĞ¸ÑÑ‚Ğ°Ğ½",
  lge = () => "Uzbekistan",
  _ge = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Qme() : t === "pt" ? tge() : t === "ch" ? ege() : t === "de" ? rge() : t === "es" ? nge() : t === "fr" ? ige() : t === "it" ? oge() : t === "jp" ? sge() : t === "pl" ? age() : t === "ru" ? uge() : t === "uk" ? cge() : lge()
  },
  hge = () => "Vanuatu",
  dge = () => "Vanuatu",
  pge = () => "ç“¦åŠªé˜¿å›¾",
  fge = () => "Vanuatu",
  mge = () => "Vanuatu",
  gge = () => "Vanuatu",
  yge = () => "Vanuatu",
  vge = () => "ãƒãƒŒã‚¢ãƒ„",
  bge = () => "Vanuatu",
  xge = () => "Ğ’Ğ°Ğ½ÑƒĞ°Ñ‚Ñƒ",
  wge = () => "Ğ’Ğ°Ğ½ÑƒĞ°Ñ‚Ñƒ",
  kge = () => "Vanuatu",
  Tge = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? hge() : t === "pt" ? dge() : t === "ch" ? pge() : t === "de" ? fge() : t === "es" ? mge() : t === "fr" ? gge() : t === "it" ? yge() : t === "jp" ? vge() : t === "pl" ? bge() : t === "ru" ? xge() : t === "uk" ? wge() : kge()
  },
  Sge = () => "Vatican City",
  Pge = () => "Cidade do Vaticano",
  Mge = () => "æ¢µè’‚å†ˆåŸ",
  Cge = () => "Vatikanstadt",
  Ige = () => "Ciudad del Vaticano",
  zge = () => "CitÃ© du Vatican",
  Age = () => "CittÃ  del Vaticano",
  Ege = () => "ãƒãƒã‚«ãƒ³å¸‚å›½",
  jge = () => "Watykan",
  Lge = () => "Ğ’Ğ°Ñ‚Ğ¸ĞºĞ°Ğ½",
  Dge = () => "Ğ’Ğ°Ñ‚Ğ¸ĞºĞ°Ğ½",
  Rge = () => "ThÃ nh phá»‘ Vatican",
  Bge = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Sge() : t === "pt" ? Pge() : t === "ch" ? Mge() : t === "de" ? Cge() : t === "es" ? Ige() : t === "fr" ? zge() : t === "it" ? Age() : t === "jp" ? Ege() : t === "pl" ? jge() : t === "ru" ? Lge() : t === "uk" ? Dge() : Rge()
  },
  Fge = () => "Venezuela",
  Oge = () => "Venezuela",
  qge = () => "å§”å†…ç‘æ‹‰",
  Nge = () => "Venezuela",
  Vge = () => "Venezuela",
  Uge = () => "Venezuela",
  Zge = () => "Venezuela",
  Gge = () => "ãƒ™ãƒã‚ºã‚¨ãƒ©",
  Hge = () => "Wenezuela",
  Wge = () => "Ğ’ĞµĞ½ĞµÑÑƒÑĞ»Ğ°",
  $ge = () => "Ğ’ĞµĞ½ĞµÑÑƒĞµĞ»Ğ°",
  Xge = () => "Venezuela",
  Yge = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Fge() : t === "pt" ? Oge() : t === "ch" ? qge() : t === "de" ? Nge() : t === "es" ? Vge() : t === "fr" ? Uge() : t === "it" ? Zge() : t === "jp" ? Gge() : t === "pl" ? Hge() : t === "ru" ? Wge() : t === "uk" ? $ge() : Xge()
  },
  Kge = () => "Viet Nam",
  Jge = () => "VietnÃ£",
  Qge = () => "è¶Šå—",
  tye = () => "Vietnam",
  eye = () => "Vietnam",
  rye = () => "ViÃªt Nam",
  nye = () => "Vietnam",
  iye = () => "ãƒ™ãƒˆãƒŠãƒ ",
  oye = () => "Wietnam",
  sye = () => "Ğ’ÑŒĞµÑ‚Ğ½Ğ°Ğ¼",
  aye = () => "Ğ’'Ñ”Ñ‚Ğ½Ğ°Ğ¼",
  uye = () => "Viá»‡t Nam",
  cye = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Kge() : t === "pt" ? Jge() : t === "ch" ? Qge() : t === "de" ? tye() : t === "es" ? eye() : t === "fr" ? rye() : t === "it" ? nye() : t === "jp" ? iye() : t === "pl" ? oye() : t === "ru" ? sye() : t === "uk" ? aye() : uye()
  },
  lye = () => "Virgin Islands",
  _ye = () => "Ilhas Virgens",
  hye = () => "ç»´å°”äº¬ç¾¤å²›",
  dye = () => "Jungferninseln",
  pye = () => "Islas VÃ­rgenes",
  fye = () => "Ãles Vierges",
  mye = () => "Isole Vergini",
  gye = () => "ãƒãƒ¼ã‚¸ãƒ³è«¸å³¶",
  yye = () => "Wyspy Dziewicze",
  vye = () => "Ğ’Ğ¸Ñ€Ğ³Ğ¸Ğ½ÑĞºĞ¸Ğµ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  bye = () => "Ğ’Ñ–Ñ€Ğ³Ñ–Ğ½ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  xye = () => "Quáº§n Ä‘áº£o Virgin",
  wye = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? lye() : t === "pt" ? _ye() : t === "ch" ? hye() : t === "de" ? dye() : t === "es" ? pye() : t === "fr" ? fye() : t === "it" ? mye() : t === "jp" ? gye() : t === "pl" ? yye() : t === "ru" ? vye() : t === "uk" ? bye() : xye()
  },
  kye = () => "Virgin Islands",
  Tye = () => "Ilhas Virgens",
  Sye = () => "ç»´å°”äº¬ç¾¤å²›",
  Pye = () => "Jungferninseln",
  Mye = () => "Islas VÃ­rgenes",
  Cye = () => "Ãles Vierges",
  Iye = () => "Isole Vergini",
  zye = () => "ãƒãƒ¼ã‚¸ãƒ³è«¸å³¶",
  Aye = () => "Wyspy Dziewicze",
  Eye = () => "Ğ’Ğ¸Ñ€Ğ³Ğ¸Ğ½ÑĞºĞ¸Ğµ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  jye = () => "Ğ’Ñ–Ñ€Ğ³Ñ–Ğ½ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  Lye = () => "Quáº§n Ä‘áº£o Virgin",
  Dye = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? kye() : t === "pt" ? Tye() : t === "ch" ? Sye() : t === "de" ? Pye() : t === "es" ? Mye() : t === "fr" ? Cye() : t === "it" ? Iye() : t === "jp" ? zye() : t === "pl" ? Aye() : t === "ru" ? Eye() : t === "uk" ? jye() : Lye()
  },
  Rye = () => "Wallis and Futuna",
  Bye = () => "Wallis e Futuna",
  Fye = () => "ç“¦åˆ©æ–¯å’Œå¯Œå›¾çº³",
  Oye = () => "Wallis und Futuna",
  qye = () => "Wallis y Futuna",
  Nye = () => "Wallis-et-Futuna",
  Vye = () => "Wallis e Futuna",
  Uye = () => "ã‚¦ã‚©ãƒªã‚¹ãƒ»ãƒ•ãƒ„ãƒŠ",
  Zye = () => "Wallis i Futuna",
  Gye = () => "Ğ£Ğ¾Ğ»Ğ»Ğ¸Ñ Ğ¸ Ğ¤ÑƒÑ‚ÑƒĞ½Ğ°",
  Hye = () => "Ğ£Ğ¾Ğ»Ğ»Ñ–Ñ Ñ– Ğ¤ÑƒÑ‚ÑƒĞ½Ğ°",
  Wye = () => "Wallis vÃ  Futuna",
  $ye = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Rye() : t === "pt" ? Bye() : t === "ch" ? Fye() : t === "de" ? Oye() : t === "es" ? qye() : t === "fr" ? Nye() : t === "it" ? Vye() : t === "jp" ? Uye() : t === "pl" ? Zye() : t === "ru" ? Gye() : t === "uk" ? Hye() : Wye()
  },
  Xye = () => "Western Sahara",
  Yye = () => "Saara Ocidental",
  Kye = () => "è¥¿æ’’å“ˆæ‹‰",
  Jye = () => "Westsahara",
  Qye = () => "Sahara Occidental",
  tve = () => "Sahara occidental",
  eve = () => "Sahara Occidentale",
  rve = () => "è¥¿ã‚µãƒãƒ©",
  nve = () => "Sahara Zachodnia",
  ive = () => "Ğ—Ğ°Ğ¿Ğ°Ğ´Ğ½Ğ°Ñ Ğ¡Ğ°Ñ…Ğ°Ñ€Ğ°",
  ove = () => "Ğ—Ğ°Ñ…Ñ–Ğ´Ğ½Ğ° Ğ¡Ğ°Ñ…Ğ°Ñ€Ğ°",
  sve = () => "TÃ¢y Sahara",
  ave = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Xye() : t === "pt" ? Yye() : t === "ch" ? Kye() : t === "de" ? Jye() : t === "es" ? Qye() : t === "fr" ? tve() : t === "it" ? eve() : t === "jp" ? rve() : t === "pl" ? nve() : t === "ru" ? ive() : t === "uk" ? ove() : sve()
  },
  uve = () => "Yemen",
  cve = () => "IÃªmen",
  lve = () => "ä¹Ÿé—¨",
  _ve = () => "Jemen",
  hve = () => "Yemen",
  dve = () => "YÃ©men",
  pve = () => "Yemen",
  fve = () => "ã‚¤ã‚¨ãƒ¡ãƒ³",
  mve = () => "Jemen",
  gve = () => "Ğ™ĞµĞ¼ĞµĞ½",
  yve = () => "Ğ„Ğ¼ĞµĞ½",
  vve = () => "Yemen",
  bve = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? uve() : t === "pt" ? cve() : t === "ch" ? lve() : t === "de" ? _ve() : t === "es" ? hve() : t === "fr" ? dve() : t === "it" ? pve() : t === "jp" ? fve() : t === "pl" ? mve() : t === "ru" ? gve() : t === "uk" ? yve() : vve()
  },
  xve = () => "Zambia",
  wve = () => "ZÃ¢mbia",
  kve = () => "èµæ¯”äºš",
  Tve = () => "Sambia",
  Sve = () => "Zambia",
  Pve = () => "Zambie",
  Mve = () => "Zambia",
  Cve = () => "ã‚¶ãƒ³ãƒ“ã‚¢",
  Ive = () => "Zambia",
  zve = () => "Ğ—Ğ°Ğ¼Ğ±Ğ¸Ñ",
  Ave = () => "Ğ—Ğ°Ğ¼Ğ±Ñ–Ñ",
  Eve = () => "Zambia",
  jve = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? xve() : t === "pt" ? wve() : t === "ch" ? kve() : t === "de" ? Tve() : t === "es" ? Sve() : t === "fr" ? Pve() : t === "it" ? Mve() : t === "jp" ? Cve() : t === "pl" ? Ive() : t === "ru" ? zve() : t === "uk" ? Ave() : Eve()
  },
  Lve = () => "Zimbabwe",
  Dve = () => "ZimbÃ¡bue",
  Rve = () => "æ´¥å·´å¸ƒéŸ¦",
  Bve = () => "Simbabwe",
  Fve = () => "Zimbabue",
  Ove = () => "Zimbabwe",
  qve = () => "Zimbabwe",
  Nve = () => "ã‚¸ãƒ³ãƒãƒ–ã‚¨",
  Vve = () => "Zimbabwe",
  Uve = () => "Ğ—Ğ¸Ğ¼Ğ±Ğ°Ğ±Ğ²Ğµ",
  Zve = () => "Ğ—Ñ–Ğ¼Ğ±Ğ°Ğ±Ğ²Ğµ",
  Gve = () => "Zimbabwe",
  Hve = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Lve() : t === "pt" ? Dve() : t === "ch" ? Rve() : t === "de" ? Bve() : t === "es" ? Fve() : t === "fr" ? Ove() : t === "it" ? qve() : t === "jp" ? Nve() : t === "pl" ? Vve() : t === "ru" ? Uve() : t === "uk" ? Zve() : Gve()
  },
  Wve = () => "Ã…land Islands",
  $ve = () => "Ilhas Ã…land",
  Xve = () => "å¥¥å…°ç¾¤å²›",
  Yve = () => "Ã…landinseln",
  Kve = () => "Islas Ã…land",
  Jve = () => "Ãles Ã…land",
  Qve = () => "Isole Ã…land",
  t0e = () => "ã‚ªãƒ¼ãƒ©ãƒ³ãƒ‰è«¸å³¶",
  e0e = () => "Wyspy Alandzkie",
  r0e = () => "ĞĞ»Ğ°Ğ½Ğ´ÑĞºĞ¸Ğµ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  n0e = () => "ĞĞ»Ğ°Ğ½Ğ´ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  i0e = () => "Quáº§n Ä‘áº£o Ã…land",
  o0e = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? Wve() : t === "pt" ? $ve() : t === "ch" ? Xve() : t === "de" ? Yve() : t === "es" ? Kve() : t === "fr" ? Jve() : t === "it" ? Qve() : t === "jp" ? t0e() : t === "pl" ? e0e() : t === "ru" ? r0e() : t === "uk" ? n0e() : i0e()
  },
  s0e = () => "Canary Islands",
  a0e = () => "Ilhas CanÃ¡rias",
  u0e = () => "åŠ é‚£åˆ©ç¾¤å²›",
  c0e = () => "Kanarische Inseln",
  l0e = () => "Islas Canarias",
  _0e = () => "Ãles Canaries",
  h0e = () => "Isole Canarie",
  d0e = () => "ã‚«ãƒŠãƒªã‚¢è«¸å³¶",
  p0e = () => "Wyspy Kanaryjskie",
  f0e = () => "ĞšĞ°Ğ½Ğ°Ñ€ÑĞºĞ¸Ğµ Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ°",
  m0e = () => "ĞšĞ°Ğ½Ğ°Ñ€ÑÑŒĞºÑ– Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğ¸",
  g0e = () => "Quáº§n Ä‘áº£o Canary",
  y0e = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? s0e() : t === "pt" ? a0e() : t === "ch" ? u0e() : t === "de" ? c0e() : t === "es" ? l0e() : t === "fr" ? _0e() : t === "it" ? h0e() : t === "jp" ? d0e() : t === "pl" ? p0e() : t === "ru" ? f0e() : t === "uk" ? m0e() : g0e()
  },
  v0e = () => "Flags",
  b0e = () => "Bandeiras",
  x0e = () => "æ——å¸œ",
  w0e = () => "Flaggen",
  k0e = () => "Banderas",
  T0e = () => "Drapeaux",
  S0e = () => "Bandiere",
  P0e = () => "æ——",
  M0e = () => "Flagi",
  C0e = () => "Ğ¤Ğ»Ğ°Ğ³Ğ¸",
  I0e = () => "ĞŸÑ€Ğ°Ğ¿Ğ¾Ñ€Ğ¸",
  z0e = () => "Cá»",
  A0e = (l = {}, s = {}) => {
    const t = s.locale ?? B();
    return t === "en" ? v0e() : t === "pt" ? b0e() : t === "ch" ? x0e() : t === "de" ? w0e() : t === "es" ? k0e() : t === "fr" ? T0e() : t === "it" ? S0e() : t === "jp" ? P0e() : t === "pl" ? M0e() : t === "ru" ? C0e() : t === "uk" ? I0e() : z0e()
  },
  oa = 2 * Math.PI * 6378137 / 2;
class Bo {
  constructor(s = 256) {
    dn(this, "initialResolution");
    this.tileSize = s, this.initialResolution = 2 * oa / this.tileSize
  }
  latLonToMeters(s, t) {
    const w = t / 180 * oa,
      z = Math.log(Math.tan((90 + s) * Math.PI / 360)) / (Math.PI / 180) * oa / 180;
    return [w, z]
  }
  metersToLatLon(s, t) {
    const w = s / oa * 180;
    let z = t / oa * 180;
    return z = 180 / Math.PI * (2 * Math.atan(Math.exp(z * Math.PI / 180)) - Math.PI / 2), [z, w]
  }
  pixelsToMeters(s, t, w) {
    const z = this.resolution(w),
      E = s * z - oa,
      k = oa - t * z;
    return [E, k]
  }
  pixelsToLatLon(s, t, w) {
    const [z, E] = this.pixelsToMeters(s, t, w);
    return this.metersToLatLon(z, E)
  }
  latLonToPixels(s, t, w) {
    const [z, E] = this.latLonToMeters(s, t);
    return this.metersToPixels(z, E, w)
  }
  latLonToPixelsFloor(s, t, w) {
    const [z, E] = this.latLonToPixels(s, t, w);
    return [Math.floor(z), Math.floor(E)]
  }
  metersToPixels(s, t, w) {
    const z = this.resolution(w),
      E = (s + oa) / z,
      k = (oa - t) / z;
    return [E, k]
  }
  latLonToTile(s, t, w) {
    const [z, E] = this.latLonToMeters(s, t);
    return this.metersToTile(z, E, w)
  }
  metersToTile(s, t, w) {
    const [z, E] = this.metersToPixels(s, t, w);
    return this.pixelsToTile(z, E)
  }
  pixelsToTile(s, t) {
    const w = Math.ceil(s / this.tileSize) - 1,
      z = Math.ceil(t / this.tileSize) - 1;
    return [w, z]
  }
  pixelsToTileLocal(s, t) {
    return {
      tile: this.pixelsToTile(s, t),
      pixel: [Math.floor(s) % this.tileSize, Math.floor(t) % this.tileSize]
    }
  }
  tileBounds(s, t, w) {
    const [z, E] = this.pixelsToMeters(s * this.tileSize, t * this.tileSize, w), [k, c] = this.pixelsToMeters((s + 1) * this.tileSize, (t + 1) * this.tileSize, w);
    return {
      min: [z, E],
      max: [k, c]
    }
  }
  tileBoundsLatLon(s, t, w) {
    const z = this.tileBounds(s, t, w);
    return {
      min: this.metersToLatLon(z.min[0], z.min[1]),
      max: this.metersToLatLon(z.max[0], z.max[1])
    }
  }
  resolution(s) {
    return this.initialResolution / 2 ** s
  }
  latLonToTileAndPixel(s, t, w) {
    const [z, E] = this.latLonToMeters(s, t), [k, c] = this.metersToTile(z, E, w), [R, X] = this.metersToPixels(z, E, w);
    return {
      tile: [k, c],
      pixel: [Math.floor(R) % this.tileSize, Math.floor(X) % this.tileSize]
    }
  }
  pixelBounds(s, t, w) {
    return {
      min: this.pixelsToMeters(s, t, w),
      max: this.pixelsToMeters(s + 1, t + 1, w)
    }
  }
  pixelToBoundsLatLon(s, t, w) {
    const z = this.pixelBounds(s, t, w),
      E = .001885,
      k = (z.max[0] - z.min[0]) * E,
      c = (z.max[1] - z.min[1]) * E;
    return z.min[0] -= k, z.max[0] -= k, z.min[1] -= c, z.max[1] -= c, {
      min: this.metersToLatLon(z.min[0], z.min[1]),
      max: this.metersToLatLon(z.max[0], z.max[1])
    }
  }
  latLonToTileBoundsLatLon(s, t, w) {
    const [z, E] = this.latLonToMeters(s, t), [k, c] = this.metersToTile(z, E, w);
    return this.tileBoundsLatLon(k, c, w)
  }
  latLonToPixelBoundsLatLon(s, t, w) {
    const [z, E] = this.latLonToMeters(s, t), [k, c] = this.metersToPixels(z, E, w);
    return this.pixelToBoundsLatLon(Math.floor(k), Math.floor(c), w)
  }
  latLonToRegionAndPixel(s, t, w, z = Ao.regionSize) {
    const [E, k] = this.latLonToPixelsFloor(s, t, w), c = this.tileSize * z;
    return {
      region: [Math.floor(E / c), Math.floor(k / c)],
      pixel: [E % c, k % c]
    }
  }
}

function rm(l, s = !0) {
  const {
    min: t,
    max: w
  } = l;
  return s ? [
    [t[1], w[0]],
    [w[1], w[0]],
    [w[1], t[0]],
    [t[1], t[0]]
  ] : [
    [t[0], w[1]],
    [w[0], w[1]],
    [w[0], t[1]],
    [t[0], t[1]]
  ]
}

function nm(l) {
  return [(l.min[0] + l.max[0]) / 2, (l.min[1] + l.max[1]) / 2]
}
const E0e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  my = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function j0e(l) {
  return Math.floor(Math.random() * l)
}
const nf = 14.5;
async function L0e() {
  const l = R0e();
  if (l) return l;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const t = await new Promise((w, z) => navigator.geolocation.getCurrentPosition(E => w(E), E => z(E)));
      return {
        lat: t.coords.latitude,
        lng: t.coords.longitude,
        zoom: nf
      }
    }
  } catch (s) {
    console.error(s)
  }
  return {
    ...D0e().pos,
    zoom: nf
  }
}

function D0e() {
  const l = Object.entries(wv),
    s = j0e(l.length),
    [t, w] = l[s];
  return {
    city: t,
    pos: w
  }
}
const wv = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  kv = "location";

function sa(l, s) {
  localStorage.setItem(kv, JSON.stringify({
    ...l,
    zoom: s
  }))
}

function R0e() {
  const l = localStorage.getItem(kv);
  if (!l) return;
  const s = JSON.parse(l);
  return s.zoom ?? (s.zoom = nf), s
}

function B0e(l) {
  return l.lat >= -90 && l.lat <= 90 && l.lng >= -180 && l.lng <= 180
}
var Kl, Jl;
class F0e {
  constructor() {
    yn(this, Kl, ee(-1));
    yn(this, Jl, ee([]))
  }
  get idx() {
    return y(We(this, Kl))
  }
  set idx(s) {
    Y(We(this, Kl), s, !0)
  }
  get entries() {
    return y(We(this, Jl))
  }
  set entries(s) {
    Y(We(this, Jl), s)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(s) {
    const t = this.idx + 1,
      w = this.entries[t];
    w && (this.idx = t, s.flyTo({
      center: w.pos,
      zoom: w.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(s) {
    const t = this.idx - 1,
      w = this.entries[t];
    w && (this.idx = t, s.flyTo({
      center: w.pos,
      zoom: w.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(s) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), s]
  }
}
Kl = new WeakMap, Jl = new WeakMap;
const O0e = new F0e;

function q0e(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l
}
var od = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */
var N0e = od.exports,
  gy;

function V0e() {
  return gy || (gy = 1, (function(l, s) {
    (function(t, w) {
      l.exports = w()
    })(N0e, (function() {
      var t = {},
        w = {};

      function z(k, c, R) {
        if (w[k] = R, k === "index") {
          var X = "var sharedModule = {}; (" + w.shared + ")(sharedModule); (" + w.worker + ")(sharedModule);",
            $ = {};
          return w.shared($), w.index(t, $), typeof window < "u" && t.setWorkerUrl(window.URL.createObjectURL(new Blob([X], {
            type: "text/javascript"
          }))), t
        }
      }
      z("shared", ["exports"], (function(k) {
        function c(i, r, n, a) {
          return new(n || (n = Promise))((function(_, f) {
            function m(S) {
              try {
                b(a.next(S))
              } catch (M) {
                f(M)
              }
            }

            function v(S) {
              try {
                b(a.throw(S))
              } catch (M) {
                f(M)
              }
            }

            function b(S) {
              var M;
              S.done ? _(S.value) : (M = S.value, M instanceof n ? M : new n((function(j) {
                j(M)
              }))).then(m, v)
            }
            b((a = a.apply(i, r || [])).next())
          }))
        }

        function R(i, r) {
          this.x = i, this.y = r
        }

        function X(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var $, tt;
        typeof SuppressedError == "function" && SuppressedError, R.prototype = {
          clone() {
            return new R(this.x, this.y)
          },
          add(i) {
            return this.clone()._add(i)
          },
          sub(i) {
            return this.clone()._sub(i)
          },
          multByPoint(i) {
            return this.clone()._multByPoint(i)
          },
          divByPoint(i) {
            return this.clone()._divByPoint(i)
          },
          mult(i) {
            return this.clone()._mult(i)
          },
          div(i) {
            return this.clone()._div(i)
          },
          rotate(i) {
            return this.clone()._rotate(i)
          },
          rotateAround(i, r) {
            return this.clone()._rotateAround(i, r)
          },
          matMult(i) {
            return this.clone()._matMult(i)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(i) {
            return this.x === i.x && this.y === i.y
          },
          dist(i) {
            return Math.sqrt(this.distSqr(i))
          },
          distSqr(i) {
            const r = i.x - this.x,
              n = i.y - this.y;
            return r * r + n * n
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(i) {
            return Math.atan2(this.y - i.y, this.x - i.x)
          },
          angleWith(i) {
            return this.angleWithSep(i.x, i.y)
          },
          angleWithSep(i, r) {
            return Math.atan2(this.x * r - this.y * i, this.x * i + this.y * r)
          },
          _matMult(i) {
            const r = i[2] * this.x + i[3] * this.y;
            return this.x = i[0] * this.x + i[1] * this.y, this.y = r, this
          },
          _add(i) {
            return this.x += i.x, this.y += i.y, this
          },
          _sub(i) {
            return this.x -= i.x, this.y -= i.y, this
          },
          _mult(i) {
            return this.x *= i, this.y *= i, this
          },
          _div(i) {
            return this.x /= i, this.y /= i, this
          },
          _multByPoint(i) {
            return this.x *= i.x, this.y *= i.y, this
          },
          _divByPoint(i) {
            return this.x /= i.x, this.y /= i.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const i = this.y;
            return this.y = this.x, this.x = -i, this
          },
          _rotate(i) {
            const r = Math.cos(i),
              n = Math.sin(i),
              a = n * this.x + r * this.y;
            return this.x = r * this.x - n * this.y, this.y = a, this
          },
          _rotateAround(i, r) {
            const n = Math.cos(i),
              a = Math.sin(i),
              _ = r.y + a * (this.x - r.x) + n * (this.y - r.y);
            return this.x = r.x + n * (this.x - r.x) - a * (this.y - r.y), this.y = _, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: R
        }, R.convert = function(i) {
          if (i instanceof R) return i;
          if (Array.isArray(i)) return new R(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new R(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var ut = (function() {
            if (tt) return $;

            function i(r, n, a, _) {
              this.cx = 3 * r, this.bx = 3 * (a - r) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (_ - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r, this.p1y = n, this.p2x = a, this.p2y = _
            }
            return tt = 1, $ = i, i.prototype = {
              sampleCurveX: function(r) {
                return ((this.ax * r + this.bx) * r + this.cx) * r
              },
              sampleCurveY: function(r) {
                return ((this.ay * r + this.by) * r + this.cy) * r
              },
              sampleCurveDerivativeX: function(r) {
                return (3 * this.ax * r + 2 * this.bx) * r + this.cx
              },
              solveCurveX: function(r, n) {
                if (n === void 0 && (n = 1e-6), r < 0) return 0;
                if (r > 1) return 1;
                for (var a = r, _ = 0; _ < 8; _++) {
                  var f = this.sampleCurveX(a) - r;
                  if (Math.abs(f) < n) return a;
                  var m = this.sampleCurveDerivativeX(a);
                  if (Math.abs(m) < 1e-6) break;
                  a -= f / m
                }
                var v = 0,
                  b = 1;
                for (a = r, _ = 0; _ < 20 && (f = this.sampleCurveX(a), !(Math.abs(f - r) < n)); _++) r > f ? v = a : b = a, a = .5 * (b - v) + v;
                return a
              },
              solve: function(r, n) {
                return this.sampleCurveY(this.solveCurveX(r, n))
              }
            }, $
          })(),
          xt = X(ut);
        let lt, G;

        function yt() {
          return lt == null && (lt = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), lt
        }

        function Lt() {
          if (G == null && (G = !1, yt())) {
            const r = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (r) {
              for (let a = 0; a < 25; a++) {
                const _ = 4 * a;
                r.fillStyle = `rgb(${_},${_+1},${_+2})`, r.fillRect(a % 5, Math.floor(a / 5), 1, 1)
              }
              const n = r.getImageData(0, 0, 5, 5).data;
              for (let a = 0; a < 100; a++)
                if (a % 4 != 3 && n[a] !== a) {
                  G = !0;
                  break
                }
            }
          }
          return G || !1
        }
        var Dt = 1e-6,
          St = typeof Float32Array < "u" ? Float32Array : Array;

        function qt() {
          var i = new St(9);
          return St != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i
        }

        function Vt(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }

        function Zt() {
          var i = new St(3);
          return St != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i
        }

        function Et(i) {
          var r = i[0],
            n = i[1],
            a = i[2];
          return Math.sqrt(r * r + n * n + a * a)
        }

        function Ct(i, r, n) {
          var a = new St(3);
          return a[0] = i, a[1] = r, a[2] = n, a
        }

        function Wt(i, r, n) {
          return i[0] = r[0] + n[0], i[1] = r[1] + n[1], i[2] = r[2] + n[2], i
        }

        function jt(i, r, n) {
          return i[0] = r[0] * n, i[1] = r[1] * n, i[2] = r[2] * n, i
        }

        function Ht(i, r, n) {
          var a = r[0],
            _ = r[1],
            f = r[2],
            m = n[0],
            v = n[1],
            b = n[2];
          return i[0] = _ * b - f * v, i[1] = f * m - a * b, i[2] = a * v - _ * m, i
        }
        var _e, Ut = Et;

        function Xt(i, r, n) {
          var a = r[0],
            _ = r[1],
            f = r[2],
            m = r[3];
          return i[0] = n[0] * a + n[4] * _ + n[8] * f + n[12] * m, i[1] = n[1] * a + n[5] * _ + n[9] * f + n[13] * m, i[2] = n[2] * a + n[6] * _ + n[10] * f + n[14] * m, i[3] = n[3] * a + n[7] * _ + n[11] * f + n[15] * m, i
        }

        function me() {
          var i = new St(4);
          return St != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i
        }

        function Ce(i, r, n, a) {
          var _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx",
            f = Math.PI / 360;
          r *= f, a *= f, n *= f;
          var m = Math.sin(r),
            v = Math.cos(r),
            b = Math.sin(n),
            S = Math.cos(n),
            M = Math.sin(a),
            j = Math.cos(a);
          switch (_) {
            case "xyz":
              i[0] = m * S * j + v * b * M, i[1] = v * b * j - m * S * M, i[2] = v * S * M + m * b * j, i[3] = v * S * j - m * b * M;
              break;
            case "xzy":
              i[0] = m * S * j - v * b * M, i[1] = v * b * j - m * S * M, i[2] = v * S * M + m * b * j, i[3] = v * S * j + m * b * M;
              break;
            case "yxz":
              i[0] = m * S * j + v * b * M, i[1] = v * b * j - m * S * M, i[2] = v * S * M - m * b * j, i[3] = v * S * j + m * b * M;
              break;
            case "yzx":
              i[0] = m * S * j + v * b * M, i[1] = v * b * j + m * S * M, i[2] = v * S * M - m * b * j, i[3] = v * S * j - m * b * M;
              break;
            case "zxy":
              i[0] = m * S * j - v * b * M, i[1] = v * b * j + m * S * M, i[2] = v * S * M + m * b * j, i[3] = v * S * j - m * b * M;
              break;
            case "zyx":
              i[0] = m * S * j - v * b * M, i[1] = v * b * j + m * S * M, i[2] = v * S * M - m * b * j, i[3] = v * S * j + m * b * M;
              break;
            default:
              throw new Error("Unknown angle order " + _)
          }
          return i
        }

        function Ve() {
          var i = new St(2);
          return St != Float32Array && (i[0] = 0, i[1] = 0), i
        }

        function Ie(i, r) {
          var n = new St(2);
          return n[0] = i, n[1] = r, n
        }
        Zt(), _e = new St(4), St != Float32Array && (_e[0] = 0, _e[1] = 0, _e[2] = 0, _e[3] = 0), Zt(), Ct(1, 0, 0), Ct(0, 1, 0), me(), me(), qt(), Ve();
        const ne = 8192;

        function Xe(i, r, n) {
          return r * (ne / (i.tileSize * Math.pow(2, n - i.tileID.overscaledZ)))
        }

        function pe(i, r) {
          return (i % r + r) % r
        }

        function Ue(i, r, n) {
          return i * (1 - n) + r * n
        }

        function Ae(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const r = i * i,
            n = r * i;
          return 4 * (i < .5 ? n : 3 * (i - r) + n - .75)
        }

        function He(i, r, n, a) {
          const _ = new xt(i, r, n, a);
          return f => _.solve(f)
        }
        const Tr = He(.25, .1, .25, 1);

        function Ye(i, r, n) {
          return Math.min(n, Math.max(r, i))
        }

        function mr(i, r, n) {
          const a = n - r,
            _ = ((i - r) % a + a) % a + r;
          return _ === r ? n : _
        }

        function se(i, ...r) {
          for (const n of r)
            for (const a in n) i[a] = n[a];
          return i
        }
        let ce = 1;

        function ur(i, r, n) {
          const a = {};
          for (const _ in i) a[_] = r.call(this, i[_], _, i);
          return a
        }

        function Ke(i, r, n) {
          const a = {};
          for (const _ in i) r.call(this, i[_], _, i) && (a[_] = i[_]);
          return a
        }

        function ve(i) {
          return Array.isArray(i) ? i.map(ve) : typeof i == "object" && i ? ur(i, ve) : i
        }
        const _r = {};

        function nr(i) {
          _r[i] || (typeof console < "u" && console.warn(i), _r[i] = !0)
        }

        function gr(i, r, n) {
          return (n.y - i.y) * (r.x - i.x) > (r.y - i.y) * (n.x - i.x)
        }

        function ir(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope
        }
        let Ze = null;

        function or(i) {
          if (Ze == null) {
            const r = i.navigator ? i.navigator.userAgent : null;
            Ze = !!i.safari || !(!r || !(/\b(iPad|iPhone|iPod)\b/.test(r) || r.match("Safari") && !r.match("Chrome")))
          }
          return Ze
        }

        function de(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap
        }
        const zr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function er(i, r, n, a, _) {
          return c(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const f = new VideoFrame(i, {
              timestamp: 0
            });
            try {
              const m = f == null ? void 0 : f.format;
              if (!m || !m.startsWith("BGR") && !m.startsWith("RGB")) throw new Error(`Unrecognized format ${m}`);
              const v = m.startsWith("BGR"),
                b = new Uint8ClampedArray(a * _ * 4);
              if (yield f.copyTo(b, (function(S, M, j, O, N) {
                  const H = 4 * Math.max(-M, 0),
                    J = (Math.max(0, j) - j) * O * 4 + H,
                    rt = 4 * O,
                    ht = Math.max(0, M),
                    Ot = Math.max(0, j);
                  return {
                    rect: {
                      x: ht,
                      y: Ot,
                      width: Math.min(S.width, M + O) - ht,
                      height: Math.min(S.height, j + N) - Ot
                    },
                    layout: [{
                      offset: J,
                      stride: rt
                    }]
                  }
                })(i, r, n, a, _)), v)
                for (let S = 0; S < b.length; S += 4) {
                  const M = b[S];
                  b[S] = b[S + 2], b[S + 2] = M
                }
              return b
            } finally {
              f.close()
            }
          }))
        }
        let hr, Mr;

        function Pr(i, r, n, a) {
          return i.addEventListener(r, n, a), {
            unsubscribe: () => {
              i.removeEventListener(r, n, a)
            }
          }
        }

        function Or(i) {
          return i * Math.PI / 180
        }

        function jr(i) {
          return i / Math.PI * 180
        }
        const Lr = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          _n = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          dr = "AbortError";

        function ct() {
          return new Error(dr)
        }
        const q = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function U(i) {
          return q.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
        }
        const Q = "global-dispatcher";
        class nt extends Error {
          constructor(r, n, a, _) {
            super(`AJAXError: ${n} (${r}): ${a}`), this.status = r, this.statusText = n, this.url = a, this.body = _
          }
        }
        const _t = () => ir(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          Tt = function(i, r) {
            if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
              const a = U(i.url);
              if (a) return a(i, r);
              if (ir(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                targetMapId: Q
              }, r)
            }
            if (!(/^file:/.test(n = i.url) || /^file:/.test(_t()) && !/^\w+:/.test(n))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(a, _) {
                return c(this, void 0, void 0, (function*() {
                  const f = new Request(a.url, {
                    method: a.method || "GET",
                    body: a.body,
                    credentials: a.credentials,
                    headers: a.headers,
                    cache: a.cache,
                    referrer: _t(),
                    signal: _.signal
                  });
                  let m, v;
                  a.type !== "json" || f.headers.has("Accept") || f.headers.set("Accept", "application/json");
                  try {
                    m = yield fetch(f)
                  } catch (S) {
                    throw new nt(0, S.message, a.url, new Blob)
                  }
                  if (!m.ok) {
                    const S = yield m.blob();
                    throw new nt(m.status, m.statusText, a.url, S)
                  }
                  v = a.type === "arrayBuffer" || a.type === "image" ? m.arrayBuffer() : a.type === "json" ? m.json() : m.text();
                  const b = yield v;
                  if (_.signal.aborted) throw ct();
                  return {
                    data: b,
                    cacheControl: m.headers.get("Cache-Control"),
                    expires: m.headers.get("Expires")
                  }
                }))
              })(i, r);
              if (ir(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                mustQueue: !0,
                targetMapId: Q
              }, r)
            }
            var n;
            return (function(a, _) {
              return new Promise(((f, m) => {
                var v;
                const b = new XMLHttpRequest;
                b.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (b.responseType = "arraybuffer");
                for (const S in a.headers) b.setRequestHeader(S, a.headers[S]);
                a.type === "json" && (b.responseType = "text", !((v = a.headers) === null || v === void 0) && v.Accept || b.setRequestHeader("Accept", "application/json")), b.withCredentials = a.credentials === "include", b.onerror = () => {
                  m(new Error(b.statusText))
                }, b.onload = () => {
                  if (!_.signal.aborted)
                    if ((b.status >= 200 && b.status < 300 || b.status === 0) && b.response !== null) {
                      let S = b.response;
                      if (a.type === "json") try {
                        S = JSON.parse(b.response)
                      } catch (M) {
                        return void m(M)
                      }
                      f({
                        data: S,
                        cacheControl: b.getResponseHeader("Cache-Control"),
                        expires: b.getResponseHeader("Expires")
                      })
                    } else {
                      const S = new Blob([b.response], {
                        type: b.getResponseHeader("Content-Type")
                      });
                      m(new nt(b.status, b.statusText, a.url, S))
                    }
                }, _.signal.addEventListener("abort", (() => {
                  b.abort(), m(ct())
                })), b.send(a.body)
              }))
            })(i, r)
          };

        function Ft(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const r = new URL(i),
            n = window.location;
          return r.protocol === n.protocol && r.host === n.host
        }

        function zt(i, r, n) {
          n[i] && n[i].indexOf(r) !== -1 || (n[i] = n[i] || [], n[i].push(r))
        }

        function Nt(i, r, n) {
          if (n && n[i]) {
            const a = n[i].indexOf(r);
            a !== -1 && n[i].splice(a, 1)
          }
        }
        class ie {
          constructor(r, n = {}) {
            se(this, n), this.type = r
          }
        }
        class mt extends ie {
          constructor(r, n = {}) {
            super("error", se({
              error: r
            }, n))
          }
        }
        class et {
          on(r, n) {
            return this._listeners = this._listeners || {}, zt(r, n, this._listeners), {
              unsubscribe: () => {
                this.off(r, n)
              }
            }
          }
          off(r, n) {
            return Nt(r, n, this._listeners), Nt(r, n, this._oneTimeListeners), this
          }
          once(r, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, zt(r, n, this._oneTimeListeners), this) : new Promise((a => this.once(r, a)))
          }
          fire(r, n) {
            typeof r == "string" && (r = new ie(r, n || {}));
            const a = r.type;
            if (this.listens(a)) {
              r.target = this;
              const _ = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
              for (const v of _) v.call(this, r);
              const f = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
              for (const v of f) Nt(a, v, this._oneTimeListeners), v.call(this, r);
              const m = this._eventedParent;
              m && (se(r, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), m.fire(r))
            } else r instanceof mt && console.error(r.error);
            return this
          }
          listens(r) {
            return this._listeners && this._listeners[r] && this._listeners[r].length > 0 || this._oneTimeListeners && this._oneTimeListeners[r] && this._oneTimeListeners[r].length > 0 || this._eventedParent && this._eventedParent.listens(r)
          }
          setEventedParent(r, n) {
            return this._eventedParent = r, this._eventedParentData = n, this
          }
        }
        var W = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            "font-faces": {
              type: "array",
              value: "fontFaces"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            encoding: {
              type: "enum",
              values: {
                mvt: {},
                mlt: {}
              },
              default: "mvt"
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const vt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function $t(i, r) {
          const n = {};
          for (const a in i) a !== "ref" && (n[a] = i[a]);
          return vt.forEach((a => {
            a in r && (n[a] = r[a])
          })), n
        }

        function Pt(i, r) {
          if (Array.isArray(i)) {
            if (!Array.isArray(r) || i.length !== r.length) return !1;
            for (let n = 0; n < i.length; n++)
              if (!Pt(i[n], r[n])) return !1;
            return !0
          }
          if (typeof i == "object" && i !== null && r !== null) {
            if (typeof r != "object" || Object.keys(i).length !== Object.keys(r).length) return !1;
            for (const n in i)
              if (!Pt(i[n], r[n])) return !1;
            return !0
          }
          return i === r
        }

        function Gt(i, r) {
          i.push(r)
        }

        function ae(i, r, n) {
          Gt(n, {
            command: "addSource",
            args: [i, r[i]]
          })
        }

        function ye(i, r, n) {
          Gt(r, {
            command: "removeSource",
            args: [i]
          }), n[i] = !0
        }

        function Te(i, r, n, a) {
          ye(i, n, a), ae(i, r, n)
        }

        function we(i, r, n) {
          let a;
          for (a in i[n])
            if (Object.prototype.hasOwnProperty.call(i[n], a) && a !== "data" && !Pt(i[n][a], r[n][a])) return !1;
          for (a in r[n])
            if (Object.prototype.hasOwnProperty.call(r[n], a) && a !== "data" && !Pt(i[n][a], r[n][a])) return !1;
          return !0
        }

        function be(i, r, n, a, _, f) {
          i = i || {}, r = r || {};
          for (const m in i) Object.prototype.hasOwnProperty.call(i, m) && (Pt(i[m], r[m]) || n.push({
            command: f,
            args: [a, m, r[m], _]
          }));
          for (const m in r) Object.prototype.hasOwnProperty.call(r, m) && !Object.prototype.hasOwnProperty.call(i, m) && (Pt(i[m], r[m]) || n.push({
            command: f,
            args: [a, m, r[m], _]
          }))
        }

        function Ee(i) {
          return i.id
        }

        function Qe(i, r) {
          return i[r.id] = r, i
        }
        class Yt {
          constructor(r, n, a, _) {
            this.message = (r ? `${r}: ` : "") + a, _ && (this.identifier = _), n != null && n.__line__ && (this.line = n.__line__)
          }
        }

        function je(i, ...r) {
          for (const n of r)
            for (const a in n) i[a] = n[a];
          return i
        }
        class Fe extends Error {
          constructor(r, n) {
            super(n), this.message = n, this.key = r
          }
        }
        class Nr {
          constructor(r, n = []) {
            this.parent = r, this.bindings = {};
            for (const [a, _] of n) this.bindings[a] = _
          }
          concat(r) {
            return new Nr(this, r)
          }
          get(r) {
            if (this.bindings[r]) return this.bindings[r];
            if (this.parent) return this.parent.get(r);
            throw new Error(`${r} not found in scope.`)
          }
          has(r) {
            return !!this.bindings[r] || !!this.parent && this.parent.has(r)
          }
        }
        const Ar = {
            kind: "null"
          },
          Kt = {
            kind: "number"
          },
          Oe = {
            kind: "string"
          },
          Be = {
            kind: "boolean"
          },
          fe = {
            kind: "color"
          },
          Me = {
            kind: "projectionDefinition"
          },
          cr = {
            kind: "object"
          },
          Ge = {
            kind: "value"
          },
          qr = {
            kind: "collator"
          },
          lr = {
            kind: "formatted"
          },
          Jt = {
            kind: "padding"
          },
          Se = {
            kind: "colorArray"
          },
          rr = {
            kind: "numberArray"
          },
          Le = {
            kind: "resolvedImage"
          },
          sr = {
            kind: "variableAnchorOffsetCollection"
          };

        function De(i, r) {
          return {
            kind: "array",
            itemType: i,
            N: r
          }
        }

        function Cr(i) {
          if (i.kind === "array") {
            const r = Cr(i.itemType);
            return typeof i.N == "number" ? `array<${r}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${r}>`
          }
          return i.kind
        }
        const on = [Ar, Kt, Oe, Be, fe, Me, lr, cr, De(Ge), Jt, rr, Se, Le, sr];

        function ln(i, r) {
          if (r.kind === "error") return null;
          if (i.kind === "array") {
            if (r.kind === "array" && (r.N === 0 && r.itemType.kind === "value" || !ln(i.itemType, r.itemType)) && (typeof i.N != "number" || i.N === r.N)) return null
          } else {
            if (i.kind === r.kind) return null;
            if (i.kind === "value") {
              for (const n of on)
                if (!ln(n, r)) return null
            }
          }
          return `Expected ${Cr(i)} but found ${Cr(r)} instead.`
        }

        function Br(i, r) {
          return r.some((n => n.kind === i.kind))
        }

        function Dr(i, r) {
          return r.some((n => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i))
        }

        function un(i, r) {
          return i.kind === "array" && r.kind === "array" ? i.itemType.kind === r.itemType.kind && typeof i.N == "number" : i.kind === r.kind
        }
        const Fn = .96422,
          Rn = .82521,
          Kr = 4 / 29,
          Hr = 6 / 29,
          An = 3 * Hr * Hr,
          Hi = Hr * Hr * Hr,
          Fi = Math.PI / 180,
          Ci = 180 / Math.PI;

        function he(i) {
          return (i %= 360) < 0 && (i += 360), i
        }

        function qe([i, r, n, a]) {
          let _, f;
          const m = Pn((.2225045 * (i = Vr(i)) + .7168786 * (r = Vr(r)) + .0606169 * (n = Vr(n))) / 1);
          i === r && r === n ? _ = f = m : (_ = Pn((.4360747 * i + .3850649 * r + .1430804 * n) / Fn), f = Pn((.0139322 * i + .0971045 * r + .7141733 * n) / Rn));
          const v = 116 * m - 16;
          return [v < 0 ? 0 : v, 500 * (_ - m), 200 * (m - f), a]
        }

        function Vr(i) {
          return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
        }

        function Pn(i) {
          return i > Hi ? Math.pow(i, 1 / 3) : i / An + Kr
        }

        function Gn([i, r, n, a]) {
          let _ = (i + 16) / 116,
            f = isNaN(r) ? _ : _ + r / 500,
            m = isNaN(n) ? _ : _ - n / 200;
          return _ = 1 * $n(_), f = Fn * $n(f), m = Rn * $n(m), [Xn(3.1338561 * f - 1.6168667 * _ - .4906146 * m), Xn(-.9787684 * f + 1.9161415 * _ + .033454 * m), Xn(.0719453 * f - .2289914 * _ + 1.4052427 * m), a]
        }

        function Xn(i) {
          return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
        }

        function $n(i) {
          return i > Hr ? i * i * i : An * (i - Kr)
        }
        const On = Object.hasOwn || function(i, r) {
          return Object.prototype.hasOwnProperty.call(i, r)
        };

        function Ai(i, r) {
          return On(i, r) ? i[r] : void 0
        }

        function Rr(i) {
          return parseInt(i.padEnd(2, i), 16) / 255
        }

        function wr(i, r) {
          return xn(r ? i / 100 : i, 0, 1)
        }

        function xn(i, r, n) {
          return Math.min(Math.max(r, i), n)
        }

        function qn(i) {
          return !i.some(Number.isNaN)
        }
        const wn = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function xr(i, r, n) {
          return i + n * (r - i)
        }

        function vn(i, r, n) {
          return i.map(((a, _) => xr(a, r[_], n)))
        }
        class Ur {
          constructor(r, n, a, _ = 1, f = !0) {
            this.r = r, this.g = n, this.b = a, this.a = _, f || (this.r *= _, this.g *= _, this.b *= _, _ || this.overwriteGetter("rgb", [r, n, a, _]))
          }
          static parse(r) {
            if (r instanceof Ur) return r;
            if (typeof r != "string") return;
            const n = (function(a) {
              if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const _ = Ai(wn, a);
              if (_) {
                const [m, v, b] = _;
                return [m / 255, v / 255, b / 255, 1]
              }
              if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
                const m = a.length < 6 ? 1 : 2;
                let v = 1;
                return [Rr(a.slice(v, v += m)), Rr(a.slice(v, v += m)), Rr(a.slice(v, v += m)), Rr(a.slice(v, v + m) || "ff")]
              }
              if (a.startsWith("rgb")) {
                const m = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (m) {
                  const [v, b, S, M, j, O, N, H, J, rt, ht, Ot] = m, bt = [M || " ", N || " ", rt].join("");
                  if (bt === "  " || bt === "  /" || bt === ",," || bt === ",,,") {
                    const Mt = [S, O, J].join(""),
                      te = Mt === "%%%" ? 100 : Mt === "" ? 255 : 0;
                    if (te) {
                      const le = [xn(+b / te, 0, 1), xn(+j / te, 0, 1), xn(+H / te, 0, 1), ht ? wr(+ht, Ot) : 1];
                      if (qn(le)) return le
                    }
                  }
                  return
                }
              }
              const f = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (f) {
                const [m, v, b, S, M, j, O, N, H] = f, J = [b || " ", M || " ", O].join("");
                if (J === "  " || J === "  /" || J === ",," || J === ",,,") {
                  const rt = [+v, xn(+S, 0, 100), xn(+j, 0, 100), N ? wr(+N, H) : 1];
                  if (qn(rt)) return (function([ht, Ot, bt, Mt]) {
                    function te(le) {
                      const Re = (le + ht / 30) % 12,
                        br = Ot * Math.min(bt, 1 - bt);
                      return bt - br * Math.max(-1, Math.min(Re - 3, 9 - Re, 1))
                    }
                    return ht = he(ht), Ot /= 100, bt /= 100, [te(0), te(8), te(4), Mt]
                  })(rt)
                }
              }
            })(r);
            return n ? new Ur(...n, !1) : void 0
          }
          get rgb() {
            const {
              r,
              g: n,
              b: a,
              a: _
            } = this, f = _ || 1 / 0;
            return this.overwriteGetter("rgb", [r / f, n / f, a / f, _])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(r) {
              const [n, a, _, f] = qe(r), m = Math.sqrt(a * a + _ * _);
              return [Math.round(1e4 * m) ? he(Math.atan2(_, a) * Ci) : NaN, m, n, f]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", qe(this.rgb))
          }
          overwriteGetter(r, n) {
            return Object.defineProperty(this, r, {
              value: n
            }), n
          }
          toString() {
            const [r, n, a, _] = this.rgb;
            return `rgba(${[r,n,a].map((f=>Math.round(255*f))).join(",")},${_})`
          }
          static interpolate(r, n, a, _ = "rgb") {
            switch (_) {
              case "rgb": {
                const [f, m, v, b] = vn(r.rgb, n.rgb, a);
                return new Ur(f, m, v, b, !1)
              }
              case "hcl": {
                const [f, m, v, b] = r.hcl, [S, M, j, O] = n.hcl;
                let N, H;
                if (isNaN(f) || isNaN(S)) isNaN(f) ? isNaN(S) ? N = NaN : (N = S, v !== 1 && v !== 0 || (H = M)) : (N = f, j !== 1 && j !== 0 || (H = m));
                else {
                  let bt = S - f;
                  S > f && bt > 180 ? bt -= 360 : S < f && f - S > 180 && (bt += 360), N = f + a * bt
                }
                const [J, rt, ht, Ot] = (function([bt, Mt, te, le]) {
                  return bt = isNaN(bt) ? 0 : bt * Fi, Gn([te, Math.cos(bt) * Mt, Math.sin(bt) * Mt, le])
                })([N, H ?? xr(m, M, a), xr(v, j, a), xr(b, O, a)]);
                return new Ur(J, rt, ht, Ot, !1)
              }
              case "lab": {
                const [f, m, v, b] = Gn(vn(r.lab, n.lab, a));
                return new Ur(f, m, v, b, !1)
              }
            }
          }
        }
        Ur.black = new Ur(0, 0, 0, 1), Ur.white = new Ur(1, 1, 1, 1), Ur.transparent = new Ur(0, 0, 0, 0), Ur.red = new Ur(1, 0, 0, 1);
        class Jr {
          constructor(r, n, a) {
            this.sensitivity = r ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(r, n) {
            return this.collator.compare(r, n)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Cn = ["bottom", "center", "top"];
        class kn {
          constructor(r, n, a, _, f, m) {
            this.text = r, this.image = n, this.scale = a, this.fontStack = _, this.textColor = f, this.verticalAlign = m
          }
        }
        class sn {
          constructor(r) {
            this.sections = r
          }
          static fromString(r) {
            return new sn([new kn(r, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((r => r.text.length !== 0 || r.image && r.image.name.length !== 0))
          }
          static factory(r) {
            return r instanceof sn ? r : sn.fromString(r)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((r => r.text)).join("")
          }
        }
        class Bn {
          constructor(r) {
            this.values = r.slice()
          }
          static parse(r) {
            if (r instanceof Bn) return r;
            if (typeof r == "number") return new Bn([r, r, r, r]);
            if (Array.isArray(r) && !(r.length < 1 || r.length > 4)) {
              for (const n of r)
                if (typeof n != "number") return;
              switch (r.length) {
                case 1:
                  r = [r[0], r[0], r[0], r[0]];
                  break;
                case 2:
                  r = [r[0], r[1], r[0], r[1]];
                  break;
                case 3:
                  r = [r[0], r[1], r[2], r[1]]
              }
              return new Bn(r)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(r, n, a) {
            return new Bn(vn(r.values, n.values, a))
          }
        }
        class Vn {
          constructor(r) {
            this.values = r.slice()
          }
          static parse(r) {
            if (r instanceof Vn) return r;
            if (typeof r == "number") return new Vn([r]);
            if (Array.isArray(r)) {
              for (const n of r)
                if (typeof n != "number") return;
              return new Vn(r)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(r, n, a) {
            return new Vn(vn(r.values, n.values, a))
          }
        }
        class bn {
          constructor(r) {
            this.values = r.slice()
          }
          static parse(r) {
            if (r instanceof bn) return r;
            if (typeof r == "string") {
              const a = Ur.parse(r);
              return a ? new bn([a]) : void 0
            }
            if (!Array.isArray(r)) return;
            const n = [];
            for (const a of r) {
              if (typeof a != "string") return;
              const _ = Ur.parse(a);
              if (!_) return;
              n.push(_)
            }
            return new bn(n)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(r, n, a, _ = "rgb") {
            const f = [];
            if (r.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${r.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let m = 0; m < r.values.length; m++) f.push(Ur.interpolate(r.values[m], n.values[m], a, _));
            return new bn(f)
          }
        }
        class In extends Error {
          constructor(r) {
            super(r), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const Ei = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Wn {
          constructor(r) {
            this.values = r.slice()
          }
          static parse(r) {
            if (r instanceof Wn) return r;
            if (Array.isArray(r) && !(r.length < 1) && r.length % 2 == 0) {
              for (let n = 0; n < r.length; n += 2) {
                const a = r[n],
                  _ = r[n + 1];
                if (typeof a != "string" || !Ei.has(a) || !Array.isArray(_) || _.length !== 2 || typeof _[0] != "number" || typeof _[1] != "number") return
              }
              return new Wn(r)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(r, n, a) {
            const _ = r.values,
              f = n.values;
            if (_.length !== f.length) throw new In(`Cannot interpolate values of different length. from: ${r.toString()}, to: ${n.toString()}`);
            const m = [];
            for (let v = 0; v < _.length; v += 2) {
              if (_[v] !== f[v]) throw new In(`Cannot interpolate values containing mismatched anchors. from[${v}]: ${_[v]}, to[${v}]: ${f[v]}`);
              m.push(_[v]);
              const [b, S] = _[v + 1], [M, j] = f[v + 1];
              m.push([xr(b, M, a), xr(S, j, a)])
            }
            return new Wn(m)
          }
        }
        class ki {
          constructor(r) {
            this.name = r.name, this.available = r.available
          }
          toString() {
            return this.name
          }
          static fromString(r) {
            return r ? new ki({
              name: r,
              available: !1
            }) : null
          }
        }
        class yi {
          constructor(r, n, a) {
            this.from = r, this.to = n, this.transition = a
          }
          static interpolate(r, n, a) {
            return new yi(r, n, a)
          }
          static parse(r) {
            return r instanceof yi ? r : Array.isArray(r) && r.length === 3 && typeof r[0] == "string" && typeof r[1] == "string" && typeof r[2] == "number" ? new yi(r[0], r[1], r[2]) : typeof r == "object" && typeof r.from == "string" && typeof r.to == "string" && typeof r.transition == "number" ? new yi(r.from, r.to, r.transition) : typeof r == "string" ? new yi(r, r, 1) : void 0
          }
        }

        function Wi(i, r, n, a) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof r == "number" && r >= 0 && r <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[i,r,n,a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a=="number"?[i,r,n,a]:[i,r,n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function $i(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof yi || i instanceof Ur || i instanceof Jr || i instanceof sn || i instanceof Bn || i instanceof Vn || i instanceof bn || i instanceof Wn || i instanceof ki) return !0;
          if (Array.isArray(i)) {
            for (const r of i)
              if (!$i(r)) return !1;
            return !0
          }
          if (typeof i == "object") {
            for (const r in i)
              if (!$i(i[r])) return !1;
            return !0
          }
          return !1
        }

        function Yn(i) {
          if (i === null) return Ar;
          if (typeof i == "string") return Oe;
          if (typeof i == "boolean") return Be;
          if (typeof i == "number") return Kt;
          if (i instanceof Ur) return fe;
          if (i instanceof yi) return Me;
          if (i instanceof Jr) return qr;
          if (i instanceof sn) return lr;
          if (i instanceof Bn) return Jt;
          if (i instanceof Vn) return rr;
          if (i instanceof bn) return Se;
          if (i instanceof Wn) return sr;
          if (i instanceof ki) return Le;
          if (Array.isArray(i)) {
            const r = i.length;
            let n;
            for (const a of i) {
              const _ = Yn(a);
              if (n) {
                if (n === _) continue;
                n = Ge;
                break
              }
              n = _
            }
            return De(n || Ge, r)
          }
          return cr
        }

        function ai(i) {
          const r = typeof i;
          return i === null ? "" : r === "string" || r === "number" || r === "boolean" ? String(i) : i instanceof Ur || i instanceof yi || i instanceof sn || i instanceof Bn || i instanceof Vn || i instanceof bn || i instanceof Wn || i instanceof ki ? i.toString() : JSON.stringify(i)
        }
        class pi {
          constructor(r, n) {
            this.type = r, this.value = n
          }
          static parse(r, n) {
            if (r.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${r.length-1} instead.`);
            if (!$i(r[1])) return n.error("invalid value");
            const a = r[1];
            let _ = Yn(a);
            const f = n.expectedType;
            return _.kind !== "array" || _.N !== 0 || !f || f.kind !== "array" || typeof f.N == "number" && f.N !== 0 || (_ = f), new pi(_, a)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const ji = {
          string: Oe,
          number: Kt,
          boolean: Be,
          object: cr
        };
        class Sn {
          constructor(r, n) {
            this.type = r, this.args = n
          }
          static parse(r, n) {
            if (r.length < 2) return n.error("Expected at least one argument.");
            let a, _ = 1;
            const f = r[0];
            if (f === "array") {
              let v, b;
              if (r.length > 2) {
                const S = r[1];
                if (typeof S != "string" || !(S in ji) || S === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                v = ji[S], _++
              } else v = Ge;
              if (r.length > 3) {
                if (r[2] !== null && (typeof r[2] != "number" || r[2] < 0 || r[2] !== Math.floor(r[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                b = r[2], _++
              }
              a = De(v, b)
            } else {
              if (!ji[f]) throw new Error(`Types doesn't contain name = ${f}`);
              a = ji[f]
            }
            const m = [];
            for (; _ < r.length; _++) {
              const v = n.parse(r[_], _, Ge);
              if (!v) return null;
              m.push(v)
            }
            return new Sn(a, m)
          }
          evaluate(r) {
            for (let n = 0; n < this.args.length; n++) {
              const a = this.args[n].evaluate(r);
              if (!ln(this.type, Yn(a))) return a;
              if (n === this.args.length - 1) throw new In(`Expected value to be of type ${Cr(this.type)}, but found ${Cr(Yn(a))} instead.`)
            }
            throw new Error
          }
          eachChild(r) {
            this.args.forEach(r)
          }
          outputDefined() {
            return this.args.every((r => r.outputDefined()))
          }
        }
        const jo = {
          "to-boolean": Be,
          "to-color": fe,
          "to-number": Kt,
          "to-string": Oe
        };
        class pn {
          constructor(r, n) {
            this.type = r, this.args = n
          }
          static parse(r, n) {
            if (r.length < 2) return n.error("Expected at least one argument.");
            const a = r[0];
            if (!jo[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`);
            if ((a === "to-boolean" || a === "to-string") && r.length !== 2) return n.error("Expected one argument.");
            const _ = jo[a],
              f = [];
            for (let m = 1; m < r.length; m++) {
              const v = n.parse(r[m], m, Ge);
              if (!v) return null;
              f.push(v)
            }
            return new pn(_, f)
          }
          evaluate(r) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(r);
              case "color": {
                let n, a;
                for (const _ of this.args) {
                  if (n = _.evaluate(r), a = null, n instanceof Ur) return n;
                  if (typeof n == "string") {
                    const f = r.parseColor(n);
                    if (f) return f
                  } else if (Array.isArray(n) && (a = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Wi(n[0], n[1], n[2], n[3]), !a)) return new Ur(n[0] / 255, n[1] / 255, n[2] / 255, n[3])
                }
                throw new In(a || `Could not parse color from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "padding": {
                let n;
                for (const a of this.args) {
                  n = a.evaluate(r);
                  const _ = Bn.parse(n);
                  if (_) return _
                }
                throw new In(`Could not parse padding from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "numberArray": {
                let n;
                for (const a of this.args) {
                  n = a.evaluate(r);
                  const _ = Vn.parse(n);
                  if (_) return _
                }
                throw new In(`Could not parse numberArray from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "colorArray": {
                let n;
                for (const a of this.args) {
                  n = a.evaluate(r);
                  const _ = bn.parse(n);
                  if (_) return _
                }
                throw new In(`Could not parse colorArray from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const a of this.args) {
                  n = a.evaluate(r);
                  const _ = Wn.parse(n);
                  if (_) return _
                }
                throw new In(`Could not parse variableAnchorOffsetCollection from value '${typeof n=="string"?n:JSON.stringify(n)}'`)
              }
              case "number": {
                let n = null;
                for (const a of this.args) {
                  if (n = a.evaluate(r), n === null) return 0;
                  const _ = Number(n);
                  if (!isNaN(_)) return _
                }
                throw new In(`Could not convert ${JSON.stringify(n)} to number.`)
              }
              case "formatted":
                return sn.fromString(ai(this.args[0].evaluate(r)));
              case "resolvedImage":
                return ki.fromString(ai(this.args[0].evaluate(r)));
              case "projectionDefinition":
                return this.args[0].evaluate(r);
              default:
                return ai(this.args[0].evaluate(r))
            }
          }
          eachChild(r) {
            this.args.forEach(r)
          }
          outputDefined() {
            return this.args.every((r => r.outputDefined()))
          }
        }
        const mn = ["Unknown", "Point", "LineString", "Polygon"];
        class Ko {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? mn[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(r) {
            let n = this._parseColorCache.get(r);
            return n || (n = Ur.parse(r), this._parseColorCache.set(r, n)), n
          }
        }
        class En {
          constructor(r, n, a = [], _, f = new Nr, m = []) {
            this.registry = r, this.path = a, this.key = a.map((v => `[${v}]`)).join(""), this.scope = f, this.errors = m, this.expectedType = _, this._isConstant = n
          }
          parse(r, n, a, _, f = {}) {
            return n ? this.concat(n, a, _)._parse(r, f) : this._parse(r, f)
          }
          _parse(r, n) {
            function a(_, f, m) {
              return m === "assert" ? new Sn(f, [_]) : m === "coerce" ? new pn(f, [_]) : _
            }
            if (r !== null && typeof r != "string" && typeof r != "boolean" && typeof r != "number" || (r = ["literal", r]), Array.isArray(r)) {
              if (r.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const _ = r[0];
              if (typeof _ != "string") return this.error(`Expression name must be a string, but found ${typeof _} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const f = this.registry[_];
              if (f) {
                let m = f.parse(r, this);
                if (!m) return null;
                if (this.expectedType) {
                  const v = this.expectedType,
                    b = m.type;
                  if (v.kind !== "string" && v.kind !== "number" && v.kind !== "boolean" && v.kind !== "object" && v.kind !== "array" || b.kind !== "value") {
                    if (v.kind === "projectionDefinition" && ["string", "array"].includes(b.kind) || ["color", "formatted", "resolvedImage"].includes(v.kind) && ["value", "string"].includes(b.kind) || ["padding", "numberArray"].includes(v.kind) && ["value", "number", "array"].includes(b.kind) || v.kind === "colorArray" && ["value", "string", "array"].includes(b.kind) || v.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(b.kind)) m = a(m, v, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(v, b)) return null
                  } else m = a(m, v, n.typeAnnotation || "assert")
                }
                if (!(m instanceof pi) && m.type.kind !== "resolvedImage" && this._isConstant(m)) {
                  const v = new Ko;
                  try {
                    m = new pi(m.type, m.evaluate(v))
                  } catch (b) {
                    return this.error(b.message), null
                  }
                }
                return m
              }
              return this.error(`Unknown expression "${_}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(r === void 0 ? "'undefined' value invalid. Use null instead." : typeof r == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof r} instead.`)
          }
          concat(r, n, a) {
            const _ = typeof r == "number" ? this.path.concat(r) : this.path,
              f = a ? this.scope.concat(a) : this.scope;
            return new En(this.registry, this._isConstant, _, n || null, f, this.errors)
          }
          error(r, ...n) {
            const a = `${this.key}${n.map((_=>`[${_}]`)).join("")}`;
            this.errors.push(new Fe(a, r))
          }
          checkSubtype(r, n) {
            const a = ln(r, n);
            return a && this.error(a), a
          }
        }
        class wo {
          constructor(r, n) {
            this.type = n.type, this.bindings = [].concat(r), this.result = n
          }
          evaluate(r) {
            return this.result.evaluate(r)
          }
          eachChild(r) {
            for (const n of this.bindings) r(n[1]);
            r(this.result)
          }
          static parse(r, n) {
            if (r.length < 4) return n.error(`Expected at least 3 arguments, but found ${r.length-1} instead.`);
            const a = [];
            for (let f = 1; f < r.length - 1; f += 2) {
              const m = r[f];
              if (typeof m != "string") return n.error(`Expected string, but found ${typeof m} instead.`, f);
              if (/[^a-zA-Z0-9_]/.test(m)) return n.error("Variable names must contain only alphanumeric characters or '_'.", f);
              const v = n.parse(r[f + 1], f + 1);
              if (!v) return null;
              a.push([m, v])
            }
            const _ = n.parse(r[r.length - 1], r.length - 1, n.expectedType, a);
            return _ ? new wo(a, _) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class ro {
          constructor(r, n) {
            this.type = n.type, this.name = r, this.boundExpression = n
          }
          static parse(r, n) {
            if (r.length !== 2 || typeof r[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const a = r[1];
            return n.scope.has(a) ? new ro(a, n.scope.get(a)) : n.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(r) {
            return this.boundExpression.evaluate(r)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class Oo {
          constructor(r, n, a) {
            this.type = r, this.index = n, this.input = a
          }
          static parse(r, n) {
            if (r.length !== 3) return n.error(`Expected 2 arguments, but found ${r.length-1} instead.`);
            const a = n.parse(r[1], 1, Kt),
              _ = n.parse(r[2], 2, De(n.expectedType || Ge));
            return a && _ ? new Oo(_.type.itemType, a, _) : null
          }
          evaluate(r) {
            const n = this.index.evaluate(r),
              a = this.input.evaluate(r);
            if (n < 0) throw new In(`Array index out of bounds: ${n} < 0.`);
            if (n >= a.length) throw new In(`Array index out of bounds: ${n} > ${a.length-1}.`);
            if (n !== Math.floor(n)) throw new In(`Array index must be an integer, but found ${n} instead.`);
            return a[n]
          }
          eachChild(r) {
            r(this.index), r(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class ko {
          constructor(r, n) {
            this.type = Be, this.needle = r, this.haystack = n
          }
          static parse(r, n) {
            if (r.length !== 3) return n.error(`Expected 2 arguments, but found ${r.length-1} instead.`);
            const a = n.parse(r[1], 1, Ge),
              _ = n.parse(r[2], 2, Ge);
            return a && _ ? Br(a.type, [Be, Oe, Kt, Ar, Ge]) ? new ko(a, _) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Cr(a.type)} instead`) : null
          }
          evaluate(r) {
            const n = this.needle.evaluate(r),
              a = this.haystack.evaluate(r);
            if (!a) return !1;
            if (!Dr(n, ["boolean", "string", "number", "null"])) throw new In(`Expected first argument to be of type boolean, string, number or null, but found ${Cr(Yn(n))} instead.`);
            if (!Dr(a, ["string", "array"])) throw new In(`Expected second argument to be of type array or string, but found ${Cr(Yn(a))} instead.`);
            return a.indexOf(n) >= 0
          }
          eachChild(r) {
            r(this.needle), r(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class Jo {
          constructor(r, n, a) {
            this.type = Kt, this.needle = r, this.haystack = n, this.fromIndex = a
          }
          static parse(r, n) {
            if (r.length <= 2 || r.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${r.length-1} instead.`);
            const a = n.parse(r[1], 1, Ge),
              _ = n.parse(r[2], 2, Ge);
            if (!a || !_) return null;
            if (!Br(a.type, [Be, Oe, Kt, Ar, Ge])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Cr(a.type)} instead`);
            if (r.length === 4) {
              const f = n.parse(r[3], 3, Kt);
              return f ? new Jo(a, _, f) : null
            }
            return new Jo(a, _)
          }
          evaluate(r) {
            const n = this.needle.evaluate(r),
              a = this.haystack.evaluate(r);
            if (!Dr(n, ["boolean", "string", "number", "null"])) throw new In(`Expected first argument to be of type boolean, string, number or null, but found ${Cr(Yn(n))} instead.`);
            let _;
            if (this.fromIndex && (_ = this.fromIndex.evaluate(r)), Dr(a, ["string"])) {
              const f = a.indexOf(n, _);
              return f === -1 ? -1 : [...a.slice(0, f)].length
            }
            if (Dr(a, ["array"])) return a.indexOf(n, _);
            throw new In(`Expected second argument to be of type array or string, but found ${Cr(Yn(a))} instead.`)
          }
          eachChild(r) {
            r(this.needle), r(this.haystack), this.fromIndex && r(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class Lo {
          constructor(r, n, a, _, f, m) {
            this.inputType = r, this.type = n, this.input = a, this.cases = _, this.outputs = f, this.otherwise = m
          }
          static parse(r, n) {
            if (r.length < 5) return n.error(`Expected at least 4 arguments, but found only ${r.length-1}.`);
            if (r.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let a, _;
            n.expectedType && n.expectedType.kind !== "value" && (_ = n.expectedType);
            const f = {},
              m = [];
            for (let S = 2; S < r.length - 1; S += 2) {
              let M = r[S];
              const j = r[S + 1];
              Array.isArray(M) || (M = [M]);
              const O = n.concat(S);
              if (M.length === 0) return O.error("Expected at least one branch label.");
              for (const H of M) {
                if (typeof H != "number" && typeof H != "string") return O.error("Branch labels must be numbers or strings.");
                if (typeof H == "number" && Math.abs(H) > Number.MAX_SAFE_INTEGER) return O.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof H == "number" && Math.floor(H) !== H) return O.error("Numeric branch labels must be integer values.");
                if (a) {
                  if (O.checkSubtype(a, Yn(H))) return null
                } else a = Yn(H);
                if (f[String(H)] !== void 0) return O.error("Branch labels must be unique.");
                f[String(H)] = m.length
              }
              const N = n.parse(j, S, _);
              if (!N) return null;
              _ = _ || N.type, m.push(N)
            }
            const v = n.parse(r[1], 1, Ge);
            if (!v) return null;
            const b = n.parse(r[r.length - 1], r.length - 1, _);
            return b ? v.type.kind !== "value" && n.concat(1).checkSubtype(a, v.type) ? null : new Lo(a, _, v, f, m, b) : null
          }
          evaluate(r) {
            const n = this.input.evaluate(r);
            return (Yn(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(r)
          }
          eachChild(r) {
            r(this.input), this.outputs.forEach(r), r(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((r => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Qo {
          constructor(r, n, a) {
            this.type = r, this.branches = n, this.otherwise = a
          }
          static parse(r, n) {
            if (r.length < 4) return n.error(`Expected at least 3 arguments, but found only ${r.length-1}.`);
            if (r.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let a;
            n.expectedType && n.expectedType.kind !== "value" && (a = n.expectedType);
            const _ = [];
            for (let m = 1; m < r.length - 1; m += 2) {
              const v = n.parse(r[m], m, Be);
              if (!v) return null;
              const b = n.parse(r[m + 1], m + 1, a);
              if (!b) return null;
              _.push([v, b]), a = a || b.type
            }
            const f = n.parse(r[r.length - 1], r.length - 1, a);
            if (!f) return null;
            if (!a) throw new Error("Can't infer output type");
            return new Qo(a, _, f)
          }
          evaluate(r) {
            for (const [n, a] of this.branches)
              if (n.evaluate(r)) return a.evaluate(r);
            return this.otherwise.evaluate(r)
          }
          eachChild(r) {
            for (const [n, a] of this.branches) r(n), r(a);
            r(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([r, n]) => n.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Ts {
          constructor(r, n, a, _) {
            this.type = r, this.input = n, this.beginIndex = a, this.endIndex = _
          }
          static parse(r, n) {
            if (r.length <= 2 || r.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${r.length-1} instead.`);
            const a = n.parse(r[1], 1, Ge),
              _ = n.parse(r[2], 2, Kt);
            if (!a || !_) return null;
            if (!Br(a.type, [De(Ge), Oe, Ge])) return n.error(`Expected first argument to be of type array or string, but found ${Cr(a.type)} instead`);
            if (r.length === 4) {
              const f = n.parse(r[3], 3, Kt);
              return f ? new Ts(a.type, a, _, f) : null
            }
            return new Ts(a.type, a, _)
          }
          evaluate(r) {
            const n = this.input.evaluate(r),
              a = this.beginIndex.evaluate(r);
            let _;
            if (this.endIndex && (_ = this.endIndex.evaluate(r)), Dr(n, ["string"])) return [...n].slice(a, _).join("");
            if (Dr(n, ["array"])) return n.slice(a, _);
            throw new In(`Expected first argument to be of type array or string, but found ${Cr(Yn(n))} instead.`)
          }
          eachChild(r) {
            r(this.input), r(this.beginIndex), this.endIndex && r(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function vi(i, r) {
          const n = i.length - 1;
          let a, _, f = 0,
            m = n,
            v = 0;
          for (; f <= m;)
            if (v = Math.floor((f + m) / 2), a = i[v], _ = i[v + 1], a <= r) {
              if (v === n || r < _) return v;
              f = v + 1
            } else {
              if (!(a > r)) throw new In("Input is not a number.");
              m = v - 1
            } return 0
        }
        class Ti {
          constructor(r, n, a) {
            this.type = r, this.input = n, this.labels = [], this.outputs = [];
            for (const [_, f] of a) this.labels.push(_), this.outputs.push(f)
          }
          static parse(r, n) {
            if (r.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${r.length-1}.`);
            if ((r.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const a = n.parse(r[1], 1, Kt);
            if (!a) return null;
            const _ = [];
            let f = null;
            n.expectedType && n.expectedType.kind !== "value" && (f = n.expectedType);
            for (let m = 1; m < r.length; m += 2) {
              const v = m === 1 ? -1 / 0 : r[m],
                b = r[m + 1],
                S = m,
                M = m + 1;
              if (typeof v != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', S);
              if (_.length && _[_.length - 1][0] >= v) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', S);
              const j = n.parse(b, M, f);
              if (!j) return null;
              f = f || j.type, _.push([v, j])
            }
            return new Ti(f, a, _)
          }
          evaluate(r) {
            const n = this.labels,
              a = this.outputs;
            if (n.length === 1) return a[0].evaluate(r);
            const _ = this.input.evaluate(r);
            if (_ <= n[0]) return a[0].evaluate(r);
            const f = n.length;
            return _ >= n[f - 1] ? a[f - 1].evaluate(r) : a[vi(n, _)].evaluate(r)
          }
          eachChild(r) {
            r(this.input);
            for (const n of this.outputs) r(n)
          }
          outputDefined() {
            return this.outputs.every((r => r.outputDefined()))
          }
        }

        function po(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var ui, qo, Bs = (function() {
            if (qo) return ui;

            function i(r, n, a, _) {
              this.cx = 3 * r, this.bx = 3 * (a - r) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (_ - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r, this.p1y = n, this.p2x = a, this.p2y = _
            }
            return qo = 1, ui = i, i.prototype = {
              sampleCurveX: function(r) {
                return ((this.ax * r + this.bx) * r + this.cx) * r
              },
              sampleCurveY: function(r) {
                return ((this.ay * r + this.by) * r + this.cy) * r
              },
              sampleCurveDerivativeX: function(r) {
                return (3 * this.ax * r + 2 * this.bx) * r + this.cx
              },
              solveCurveX: function(r, n) {
                if (n === void 0 && (n = 1e-6), r < 0) return 0;
                if (r > 1) return 1;
                for (var a = r, _ = 0; _ < 8; _++) {
                  var f = this.sampleCurveX(a) - r;
                  if (Math.abs(f) < n) return a;
                  var m = this.sampleCurveDerivativeX(a);
                  if (Math.abs(m) < 1e-6) break;
                  a -= f / m
                }
                var v = 0,
                  b = 1;
                for (a = r, _ = 0; _ < 20 && (f = this.sampleCurveX(a), !(Math.abs(f - r) < n)); _++) r > f ? v = a : b = a, a = .5 * (b - v) + v;
                return a
              },
              solve: function(r, n) {
                return this.sampleCurveY(this.solveCurveX(r, n))
              }
            }, ui
          })(),
          ya = po(Bs);
        class Un {
          constructor(r, n, a, _, f) {
            this.type = r, this.operator = n, this.interpolation = a, this.input = _, this.labels = [], this.outputs = [];
            for (const [m, v] of f) this.labels.push(m), this.outputs.push(v)
          }
          static interpolationFactor(r, n, a, _) {
            let f = 0;
            if (r.name === "exponential") f = xu(n, r.base, a, _);
            else if (r.name === "linear") f = xu(n, 1, a, _);
            else if (r.name === "cubic-bezier") {
              const m = r.controlPoints;
              f = new ya(m[0], m[1], m[2], m[3]).solve(xu(n, 1, a, _))
            }
            return f
          }
          static parse(r, n) {
            let [a, _, f, ...m] = r;
            if (!Array.isArray(_) || _.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (_[0] === "linear") _ = {
              name: "linear"
            };
            else if (_[0] === "exponential") {
              const S = _[1];
              if (typeof S != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              _ = {
                name: "exponential",
                base: S
              }
            } else {
              if (_[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(_[0])}`, 1, 0);
              {
                const S = _.slice(1);
                if (S.length !== 4 || S.some((M => typeof M != "number" || M < 0 || M > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                _ = {
                  name: "cubic-bezier",
                  controlPoints: S
                }
              }
            }
            if (r.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${r.length-1}.`);
            if ((r.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (f = n.parse(f, 2, Kt), !f) return null;
            const v = [];
            let b = null;
            a !== "interpolate-hcl" && a !== "interpolate-lab" || n.expectedType == Se ? n.expectedType && n.expectedType.kind !== "value" && (b = n.expectedType) : b = fe;
            for (let S = 0; S < m.length; S += 2) {
              const M = m[S],
                j = m[S + 1],
                O = S + 3,
                N = S + 4;
              if (typeof M != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', O);
              if (v.length && v[v.length - 1][0] >= M) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', O);
              const H = n.parse(j, N, b);
              if (!H) return null;
              b = b || H.type, v.push([M, H])
            }
            return un(b, Kt) || un(b, Me) || un(b, fe) || un(b, Jt) || un(b, rr) || un(b, Se) || un(b, sr) || un(b, De(Kt)) ? new Un(b, a, _, f, v) : n.error(`Type ${Cr(b)} is not interpolatable.`)
          }
          evaluate(r) {
            const n = this.labels,
              a = this.outputs;
            if (n.length === 1) return a[0].evaluate(r);
            const _ = this.input.evaluate(r);
            if (_ <= n[0]) return a[0].evaluate(r);
            const f = n.length;
            if (_ >= n[f - 1]) return a[f - 1].evaluate(r);
            const m = vi(n, _),
              v = Un.interpolationFactor(this.interpolation, _, n[m], n[m + 1]),
              b = a[m].evaluate(r),
              S = a[m + 1].evaluate(r);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return xr(b, S, v);
                  case "color":
                    return Ur.interpolate(b, S, v);
                  case "padding":
                    return Bn.interpolate(b, S, v);
                  case "colorArray":
                    return bn.interpolate(b, S, v);
                  case "numberArray":
                    return Vn.interpolate(b, S, v);
                  case "variableAnchorOffsetCollection":
                    return Wn.interpolate(b, S, v);
                  case "array":
                    return vn(b, S, v);
                  case "projectionDefinition":
                    return yi.interpolate(b, S, v)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Ur.interpolate(b, S, v, "hcl");
                  case "colorArray":
                    return bn.interpolate(b, S, v, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Ur.interpolate(b, S, v, "lab");
                  case "colorArray":
                    return bn.interpolate(b, S, v, "lab")
                }
            }
          }
          eachChild(r) {
            r(this.input);
            for (const n of this.outputs) r(n)
          }
          outputDefined() {
            return this.outputs.every((r => r.outputDefined()))
          }
        }

        function xu(i, r, n, a) {
          const _ = a - n,
            f = i - n;
          return _ === 0 ? 0 : r === 1 ? f / _ : (Math.pow(r, f) - 1) / (Math.pow(r, _) - 1)
        }
        const Do = {
          color: Ur.interpolate,
          number: xr,
          padding: Bn.interpolate,
          numberArray: Vn.interpolate,
          colorArray: bn.interpolate,
          variableAnchorOffsetCollection: Wn.interpolate,
          array: vn
        };
        class Na {
          constructor(r, n) {
            this.type = r, this.args = n
          }
          static parse(r, n) {
            if (r.length < 2) return n.error("Expected at least one argument.");
            let a = null;
            const _ = n.expectedType;
            _ && _.kind !== "value" && (a = _);
            const f = [];
            for (const v of r.slice(1)) {
              const b = n.parse(v, 1 + f.length, a, void 0, {
                typeAnnotation: "omit"
              });
              if (!b) return null;
              a = a || b.type, f.push(b)
            }
            if (!a) throw new Error("No output type");
            const m = _ && f.some((v => ln(_, v.type)));
            return new Na(m ? Ge : a, f)
          }
          evaluate(r) {
            let n, a = null,
              _ = 0;
            for (const f of this.args)
              if (_++, a = f.evaluate(r), a && a instanceof ki && !a.available && (n || (n = a.name), a = null, _ === this.args.length && (a = n)), a !== null) break;
            return a
          }
          eachChild(r) {
            this.args.forEach(r)
          }
          outputDefined() {
            return this.args.every((r => r.outputDefined()))
          }
        }

        function L_(i, r) {
          return i === "==" || i === "!=" ? r.kind === "boolean" || r.kind === "string" || r.kind === "number" || r.kind === "null" || r.kind === "value" : r.kind === "string" || r.kind === "number" || r.kind === "value"
        }

        function Fs(i, r, n, a) {
          return a.compare(r, n) === 0
        }

        function ss(i, r, n) {
          const a = i !== "==" && i !== "!=";
          return class Tv {
            constructor(f, m, v) {
              this.type = Be, this.lhs = f, this.rhs = m, this.collator = v, this.hasUntypedArgument = f.type.kind === "value" || m.type.kind === "value"
            }
            static parse(f, m) {
              if (f.length !== 3 && f.length !== 4) return m.error("Expected two or three arguments.");
              const v = f[0];
              let b = m.parse(f[1], 1, Ge);
              if (!b) return null;
              if (!L_(v, b.type)) return m.concat(1).error(`"${v}" comparisons are not supported for type '${Cr(b.type)}'.`);
              let S = m.parse(f[2], 2, Ge);
              if (!S) return null;
              if (!L_(v, S.type)) return m.concat(2).error(`"${v}" comparisons are not supported for type '${Cr(S.type)}'.`);
              if (b.type.kind !== S.type.kind && b.type.kind !== "value" && S.type.kind !== "value") return m.error(`Cannot compare types '${Cr(b.type)}' and '${Cr(S.type)}'.`);
              a && (b.type.kind === "value" && S.type.kind !== "value" ? b = new Sn(S.type, [b]) : b.type.kind !== "value" && S.type.kind === "value" && (S = new Sn(b.type, [S])));
              let M = null;
              if (f.length === 4) {
                if (b.type.kind !== "string" && S.type.kind !== "string" && b.type.kind !== "value" && S.type.kind !== "value") return m.error("Cannot use collator to compare non-string types.");
                if (M = m.parse(f[3], 3, qr), !M) return null
              }
              return new Tv(b, S, M)
            }
            evaluate(f) {
              const m = this.lhs.evaluate(f),
                v = this.rhs.evaluate(f);
              if (a && this.hasUntypedArgument) {
                const b = Yn(m),
                  S = Yn(v);
                if (b.kind !== S.kind || b.kind !== "string" && b.kind !== "number") throw new In(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${b.kind}, ${S.kind}) instead.`)
              }
              if (this.collator && !a && this.hasUntypedArgument) {
                const b = Yn(m),
                  S = Yn(v);
                if (b.kind !== "string" || S.kind !== "string") return r(f, m, v)
              }
              return this.collator ? n(f, m, v, this.collator.evaluate(f)) : r(f, m, v)
            }
            eachChild(f) {
              f(this.lhs), f(this.rhs), this.collator && f(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const Lc = ss("==", (function(i, r, n) {
            return r === n
          }), Fs),
          Ed = ss("!=", (function(i, r, n) {
            return r !== n
          }), (function(i, r, n, a) {
            return !Fs(0, r, n, a)
          })),
          D_ = ss("<", (function(i, r, n) {
            return r < n
          }), (function(i, r, n, a) {
            return a.compare(r, n) < 0
          })),
          wu = ss(">", (function(i, r, n) {
            return r > n
          }), (function(i, r, n, a) {
            return a.compare(r, n) > 0
          })),
          ku = ss("<=", (function(i, r, n) {
            return r <= n
          }), (function(i, r, n, a) {
            return a.compare(r, n) <= 0
          })),
          No = ss(">=", (function(i, r, n) {
            return r >= n
          }), (function(i, r, n, a) {
            return a.compare(r, n) >= 0
          }));
        class Va {
          constructor(r, n, a) {
            this.type = qr, this.locale = a, this.caseSensitive = r, this.diacriticSensitive = n
          }
          static parse(r, n) {
            if (r.length !== 2) return n.error("Expected one argument.");
            const a = r[1];
            if (typeof a != "object" || Array.isArray(a)) return n.error("Collator options argument must be an object.");
            const _ = n.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, Be);
            if (!_) return null;
            const f = n.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, Be);
            if (!f) return null;
            let m = null;
            return a.locale && (m = n.parse(a.locale, 1, Oe), !m) ? null : new Va(_, f, m)
          }
          evaluate(r) {
            return new Jr(this.caseSensitive.evaluate(r), this.diacriticSensitive.evaluate(r), this.locale ? this.locale.evaluate(r) : null)
          }
          eachChild(r) {
            r(this.caseSensitive), r(this.diacriticSensitive), this.locale && r(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class va {
          constructor(r, n, a, _, f) {
            this.type = Oe, this.number = r, this.locale = n, this.currency = a, this.minFractionDigits = _, this.maxFractionDigits = f
          }
          static parse(r, n) {
            if (r.length !== 3) return n.error("Expected two arguments.");
            const a = n.parse(r[1], 1, Kt);
            if (!a) return null;
            const _ = r[2];
            if (typeof _ != "object" || Array.isArray(_)) return n.error("NumberFormat options argument must be an object.");
            let f = null;
            if (_.locale && (f = n.parse(_.locale, 1, Oe), !f)) return null;
            let m = null;
            if (_.currency && (m = n.parse(_.currency, 1, Oe), !m)) return null;
            let v = null;
            if (_["min-fraction-digits"] && (v = n.parse(_["min-fraction-digits"], 1, Kt), !v)) return null;
            let b = null;
            return _["max-fraction-digits"] && (b = n.parse(_["max-fraction-digits"], 1, Kt), !b) ? null : new va(a, f, m, v, b)
          }
          evaluate(r) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(r) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(r) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(r) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(r) : void 0
            }).format(this.number.evaluate(r))
          }
          eachChild(r) {
            r(this.number), this.locale && r(this.locale), this.currency && r(this.currency), this.minFractionDigits && r(this.minFractionDigits), this.maxFractionDigits && r(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class Tu {
          constructor(r) {
            this.type = lr, this.sections = r
          }
          static parse(r, n) {
            if (r.length < 2) return n.error("Expected at least one argument.");
            const a = r[1];
            if (!Array.isArray(a) && typeof a == "object") return n.error("First argument must be an image or text section.");
            const _ = [];
            let f = !1;
            for (let m = 1; m <= r.length - 1; ++m) {
              const v = r[m];
              if (f && typeof v == "object" && !Array.isArray(v)) {
                f = !1;
                let b = null;
                if (v["font-scale"] && (b = n.parse(v["font-scale"], 1, Kt), !b)) return null;
                let S = null;
                if (v["text-font"] && (S = n.parse(v["text-font"], 1, De(Oe)), !S)) return null;
                let M = null;
                if (v["text-color"] && (M = n.parse(v["text-color"], 1, fe), !M)) return null;
                let j = null;
                if (v["vertical-align"]) {
                  if (typeof v["vertical-align"] == "string" && !Cn.includes(v["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${v["vertical-align"]}' instead.`);
                  if (j = n.parse(v["vertical-align"], 1, Oe), !j) return null
                }
                const O = _[_.length - 1];
                O.scale = b, O.font = S, O.textColor = M, O.verticalAlign = j
              } else {
                const b = n.parse(r[m], 1, Ge);
                if (!b) return null;
                const S = b.type.kind;
                if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                f = !0, _.push({
                  content: b,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new Tu(_)
          }
          evaluate(r) {
            return new sn(this.sections.map((n => {
              const a = n.content.evaluate(r);
              return Yn(a) === Le ? new kn("", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(r) : null) : new kn(ai(a), null, n.scale ? n.scale.evaluate(r) : null, n.font ? n.font.evaluate(r).join(",") : null, n.textColor ? n.textColor.evaluate(r) : null, n.verticalAlign ? n.verticalAlign.evaluate(r) : null)
            })))
          }
          eachChild(r) {
            for (const n of this.sections) r(n.content), n.scale && r(n.scale), n.font && r(n.font), n.textColor && r(n.textColor), n.verticalAlign && r(n.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Ua {
          constructor(r) {
            this.type = Le, this.input = r
          }
          static parse(r, n) {
            if (r.length !== 2) return n.error("Expected two arguments.");
            const a = n.parse(r[1], 1, Oe);
            return a ? new Ua(a) : n.error("No image name provided.")
          }
          evaluate(r) {
            const n = this.input.evaluate(r),
              a = ki.fromString(n);
            return a && r.availableImages && (a.available = r.availableImages.indexOf(n) > -1), a
          }
          eachChild(r) {
            r(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Dc {
          constructor(r) {
            this.type = Kt, this.input = r
          }
          static parse(r, n) {
            if (r.length !== 2) return n.error(`Expected 1 argument, but found ${r.length-1} instead.`);
            const a = n.parse(r[1], 1);
            return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${Cr(a.type)} instead.`) : new Dc(a) : null
          }
          evaluate(r) {
            const n = this.input.evaluate(r);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new In(`Expected value to be of type string or array, but found ${Cr(Yn(n))} instead.`)
          }
          eachChild(r) {
            r(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const ts = 8192;

        function jd(i, r) {
          const n = (180 + i[0]) / 360,
            a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360,
            _ = Math.pow(2, r.z);
          return [Math.round(n * _ * ts), Math.round(a * _ * ts)]
        }

        function Rc(i, r) {
          const n = Math.pow(2, r.z);
          return [(_ = (i[0] / ts + r.x) / n, 360 * _ - 180), (a = (i[1] / ts + r.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
          var a, _
        }

        function Ss(i, r) {
          i[0] = Math.min(i[0], r[0]), i[1] = Math.min(i[1], r[1]), i[2] = Math.max(i[2], r[0]), i[3] = Math.max(i[3], r[1])
        }

        function Za(i, r) {
          return !(i[0] <= r[0] || i[2] >= r[2] || i[1] <= r[1] || i[3] >= r[3])
        }

        function R_(i, r, n) {
          const a = i[0] - r[0],
            _ = i[1] - r[1],
            f = i[0] - n[0],
            m = i[1] - n[1];
          return a * m - f * _ == 0 && a * f <= 0 && _ * m <= 0
        }

        function Ga(i, r, n, a) {
          return (_ = [a[0] - n[0], a[1] - n[1]])[0] * (f = [r[0] - i[0], r[1] - i[1]])[1] - _[1] * f[0] != 0 && !(!F_(i, r, n, a) || !F_(n, a, i, r));
          var _, f
        }

        function Ld(i, r, n) {
          for (const a of n)
            for (let _ = 0; _ < a.length - 1; ++_)
              if (Ga(i, r, a[_], a[_ + 1])) return !0;
          return !1
        }

        function Os(i, r, n = !1) {
          let a = !1;
          for (const v of r)
            for (let b = 0; b < v.length - 1; b++) {
              if (R_(i, v[b], v[b + 1])) return n;
              (f = v[b])[1] > (_ = i)[1] != (m = v[b + 1])[1] > _[1] && _[0] < (m[0] - f[0]) * (_[1] - f[1]) / (m[1] - f[1]) + f[0] && (a = !a)
            }
          var _, f, m;
          return a
        }

        function Dd(i, r) {
          for (const n of r)
            if (Os(i, n)) return !0;
          return !1
        }

        function B_(i, r) {
          for (const n of i)
            if (!Os(n, r)) return !1;
          for (let n = 0; n < i.length - 1; ++n)
            if (Ld(i[n], i[n + 1], r)) return !1;
          return !0
        }

        function Rd(i, r) {
          for (const n of r)
            if (B_(i, n)) return !0;
          return !1
        }

        function F_(i, r, n, a) {
          const _ = a[0] - n[0],
            f = a[1] - n[1],
            m = (i[0] - n[0]) * f - _ * (i[1] - n[1]),
            v = (r[0] - n[0]) * f - _ * (r[1] - n[1]);
          return m > 0 && v < 0 || m < 0 && v > 0
        }

        function Bc(i, r, n) {
          const a = [];
          for (let _ = 0; _ < i.length; _++) {
            const f = [];
            for (let m = 0; m < i[_].length; m++) {
              const v = jd(i[_][m], n);
              Ss(r, v), f.push(v)
            }
            a.push(f)
          }
          return a
        }

        function Fc(i, r, n) {
          const a = [];
          for (let _ = 0; _ < i.length; _++) {
            const f = Bc(i[_], r, n);
            a.push(f)
          }
          return a
        }

        function Oc(i, r, n, a) {
          if (i[0] < n[0] || i[0] > n[2]) {
            const _ = .5 * a;
            let f = i[0] - n[0] > _ ? -a : n[0] - i[0] > _ ? a : 0;
            f === 0 && (f = i[0] - n[2] > _ ? -a : n[2] - i[0] > _ ? a : 0), i[0] += f
          }
          Ss(r, i)
        }

        function qc(i, r, n, a) {
          const _ = Math.pow(2, a.z) * ts,
            f = [a.x * ts, a.y * ts],
            m = [];
          for (const v of i)
            for (const b of v) {
              const S = [b.x + f[0], b.y + f[1]];
              Oc(S, r, n, _), m.push(S)
            }
          return m
        }

        function O_(i, r, n, a) {
          const _ = Math.pow(2, a.z) * ts,
            f = [a.x * ts, a.y * ts],
            m = [];
          for (const b of i) {
            const S = [];
            for (const M of b) {
              const j = [M.x + f[0], M.y + f[1]];
              Ss(r, j), S.push(j)
            }
            m.push(S)
          }
          if (r[2] - r[0] <= _ / 2) {
            (v = r)[0] = v[1] = 1 / 0, v[2] = v[3] = -1 / 0;
            for (const b of m)
              for (const S of b) Oc(S, r, n, _)
          }
          var v;
          return m
        }
        class qs {
          constructor(r, n) {
            this.type = Be, this.geojson = r, this.geometries = n
          }
          static parse(r, n) {
            if (r.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${r.length-1} instead.`);
            if ($i(r[1])) {
              const a = r[1];
              if (a.type === "FeatureCollection") {
                const _ = [];
                for (const f of a.features) {
                  const {
                    type: m,
                    coordinates: v
                  } = f.geometry;
                  m === "Polygon" && _.push(v), m === "MultiPolygon" && _.push(...v)
                }
                if (_.length) return new qs(a, {
                  type: "MultiPolygon",
                  coordinates: _
                })
              } else if (a.type === "Feature") {
                const _ = a.geometry.type;
                if (_ === "Polygon" || _ === "MultiPolygon") return new qs(a, a.geometry)
              } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new qs(a, a)
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(r) {
            if (r.geometry() != null && r.canonicalID() != null) {
              if (r.geometryType() === "Point") return (function(n, a) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = n.canonicalID();
                if (a.type === "Polygon") {
                  const v = Bc(a.coordinates, f, m),
                    b = qc(n.geometry(), _, f, m);
                  if (!Za(_, f)) return !1;
                  for (const S of b)
                    if (!Os(S, v)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const v = Fc(a.coordinates, f, m),
                    b = qc(n.geometry(), _, f, m);
                  if (!Za(_, f)) return !1;
                  for (const S of b)
                    if (!Dd(S, v)) return !1
                }
                return !0
              })(r, this.geometries);
              if (r.geometryType() === "LineString") return (function(n, a) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = n.canonicalID();
                if (a.type === "Polygon") {
                  const v = Bc(a.coordinates, f, m),
                    b = O_(n.geometry(), _, f, m);
                  if (!Za(_, f)) return !1;
                  for (const S of b)
                    if (!B_(S, v)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const v = Fc(a.coordinates, f, m),
                    b = O_(n.geometry(), _, f, m);
                  if (!Za(_, f)) return !1;
                  for (const S of b)
                    if (!Rd(S, v)) return !1
                }
                return !0
              })(r, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let q_ = class {
          constructor(i = [], r = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n)
          }
          push(i) {
            this.data.push(i), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), i
          }
          peek() {
            return this.data[0]
          }
          _up(i) {
            const {
              data: r,
              compare: n
            } = this, a = r[i];
            for (; i > 0;) {
              const _ = i - 1 >> 1,
                f = r[_];
              if (n(a, f) >= 0) break;
              r[i] = f, i = _
            }
            r[i] = a
          }
          _down(i) {
            const {
              data: r,
              compare: n
            } = this, a = this.length >> 1, _ = r[i];
            for (; i < a;) {
              let f = 1 + (i << 1);
              const m = f + 1;
              if (m < this.length && n(r[m], r[f]) < 0 && (f = m), n(r[f], _) >= 0) break;
              r[i] = r[f], i = f
            }
            r[i] = _
          }
        };

        function N_(i, r, n = 0, a = i.length - 1, _ = Bd) {
          for (; a > n;) {
            if (a - n > 600) {
              const b = a - n + 1,
                S = r - n + 1,
                M = Math.log(b),
                j = .5 * Math.exp(2 * M / 3),
                O = .5 * Math.sqrt(M * j * (b - j) / b) * (S - b / 2 < 0 ? -1 : 1);
              N_(i, r, Math.max(n, Math.floor(r - S * j / b + O)), Math.min(a, Math.floor(r + (b - S) * j / b + O)), _)
            }
            const f = i[r];
            let m = n,
              v = a;
            for (Ps(i, n, r), _(i[a], f) > 0 && Ps(i, n, a); m < v;) {
              for (Ps(i, m, v), m++, v--; _(i[m], f) < 0;) m++;
              for (; _(i[v], f) > 0;) v--
            }
            _(i[n], f) === 0 ? Ps(i, n, v) : (v++, Ps(i, v, a)), v <= r && (n = v + 1), r <= v && (a = v - 1)
          }
        }

        function Ps(i, r, n) {
          const a = i[r];
          i[r] = i[n], i[n] = a
        }

        function Bd(i, r) {
          return i < r ? -1 : i > r ? 1 : 0
        }

        function Su(i, r) {
          if (i.length <= 1) return [i];
          const n = [];
          let a, _;
          for (const f of i) {
            const m = Od(f);
            m !== 0 && (f.area = Math.abs(m), _ === void 0 && (_ = m < 0), _ === m < 0 ? (a && n.push(a), a = [f]) : a.push(f))
          }
          if (a && n.push(a), r > 1)
            for (let f = 0; f < n.length; f++) n[f].length <= r || (N_(n[f], r, 1, n[f].length - 1, Fd), n[f] = n[f].slice(0, r));
          return n
        }

        function Fd(i, r) {
          return r.area - i.area
        }

        function Od(i) {
          let r = 0;
          for (let n, a, _ = 0, f = i.length, m = f - 1; _ < f; m = _++) n = i[_], a = i[m], r += (a.x - n.x) * (n.y + a.y);
          return r
        }
        const Pu = 1 / 298.257223563,
          Nc = Pu * (2 - Pu),
          V_ = Math.PI / 180;
        class Vc {
          constructor(r) {
            const n = 6378.137 * V_ * 1e3,
              a = Math.cos(r * V_),
              _ = 1 / (1 - Nc * (1 - a * a)),
              f = Math.sqrt(_);
            this.kx = n * f * a, this.ky = n * f * _ * (1 - Nc)
          }
          distance(r, n) {
            const a = this.wrap(r[0] - n[0]) * this.kx,
              _ = (r[1] - n[1]) * this.ky;
            return Math.sqrt(a * a + _ * _)
          }
          pointOnLine(r, n) {
            let a, _, f, m, v = 1 / 0;
            for (let b = 0; b < r.length - 1; b++) {
              let S = r[b][0],
                M = r[b][1],
                j = this.wrap(r[b + 1][0] - S) * this.kx,
                O = (r[b + 1][1] - M) * this.ky,
                N = 0;
              j === 0 && O === 0 || (N = (this.wrap(n[0] - S) * this.kx * j + (n[1] - M) * this.ky * O) / (j * j + O * O), N > 1 ? (S = r[b + 1][0], M = r[b + 1][1]) : N > 0 && (S += j / this.kx * N, M += O / this.ky * N)), j = this.wrap(n[0] - S) * this.kx, O = (n[1] - M) * this.ky;
              const H = j * j + O * O;
              H < v && (v = H, a = S, _ = M, f = b, m = N)
            }
            return {
              point: [a, _],
              index: f,
              t: Math.max(0, Math.min(1, m))
            }
          }
          wrap(r) {
            for (; r < -180;) r += 360;
            for (; r > 180;) r -= 360;
            return r
          }
        }

        function Uc(i, r) {
          return r[0] - i[0]
        }

        function Ha(i) {
          return i[1] - i[0] + 1
        }

        function as(i, r) {
          return i[1] >= i[0] && i[1] < r
        }

        function Zc(i, r) {
          if (i[0] > i[1]) return [null, null];
          const n = Ha(i);
          if (r) {
            if (n === 2) return [i, null];
            const _ = Math.floor(n / 2);
            return [
              [i[0], i[0] + _],
              [i[0] + _, i[1]]
            ]
          }
          if (n === 1) return [i, null];
          const a = Math.floor(n / 2) - 1;
          return [
            [i[0], i[0] + a],
            [i[0] + a + 1, i[1]]
          ]
        }

        function Gc(i, r) {
          if (!as(r, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let a = r[0]; a <= r[1]; ++a) Ss(n, i[a]);
          return n
        }

        function Mu(i) {
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of i)
            for (const a of n) Ss(r, a);
          return r
        }

        function U_(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0
        }

        function Hc(i, r, n) {
          if (!U_(i) || !U_(r)) return NaN;
          let a = 0,
            _ = 0;
          return i[2] < r[0] && (a = r[0] - i[2]), i[0] > r[2] && (a = i[0] - r[2]), i[1] > r[3] && (_ = i[1] - r[3]), i[3] < r[1] && (_ = r[1] - i[3]), n.distance([0, 0], [a, _])
        }

        function Ns(i, r, n) {
          const a = n.pointOnLine(r, i);
          return n.distance(i, a.point)
        }

        function Wc(i, r, n, a, _) {
          const f = Math.min(Ns(i, [n, a], _), Ns(r, [n, a], _)),
            m = Math.min(Ns(n, [i, r], _), Ns(a, [i, r], _));
          return Math.min(f, m)
        }

        function Zn(i, r, n, a, _) {
          if (!as(r, i.length) || !as(a, n.length)) return 1 / 0;
          let f = 1 / 0;
          for (let m = r[0]; m < r[1]; ++m) {
            const v = i[m],
              b = i[m + 1];
            for (let S = a[0]; S < a[1]; ++S) {
              const M = n[S],
                j = n[S + 1];
              if (Ga(v, b, M, j)) return 0;
              f = Math.min(f, Wc(v, b, M, j, _))
            }
          }
          return f
        }

        function qd(i, r, n, a, _) {
          if (!as(r, i.length) || !as(a, n.length)) return NaN;
          let f = 1 / 0;
          for (let m = r[0]; m <= r[1]; ++m)
            for (let v = a[0]; v <= a[1]; ++v)
              if (f = Math.min(f, _.distance(i[m], n[v])), f === 0) return f;
          return f
        }

        function Nd(i, r, n) {
          if (Os(i, r, !0)) return 0;
          let a = 1 / 0;
          for (const _ of r) {
            const f = _[0],
              m = _[_.length - 1];
            if (f !== m && (a = Math.min(a, Ns(i, [m, f], n)), a === 0)) return a;
            const v = n.pointOnLine(_, i);
            if (a = Math.min(a, n.distance(i, v.point)), a === 0) return a
          }
          return a
        }

        function Vd(i, r, n, a) {
          if (!as(r, i.length)) return NaN;
          for (let f = r[0]; f <= r[1]; ++f)
            if (Os(i[f], n, !0)) return 0;
          let _ = 1 / 0;
          for (let f = r[0]; f < r[1]; ++f) {
            const m = i[f],
              v = i[f + 1];
            for (const b of n)
              for (let S = 0, M = b.length, j = M - 1; S < M; j = S++) {
                const O = b[j],
                  N = b[S];
                if (Ga(m, v, O, N)) return 0;
                _ = Math.min(_, Wc(m, v, O, N, a))
              }
          }
          return _
        }

        function Z_(i, r) {
          for (const n of i)
            for (const a of n)
              if (Os(a, r, !0)) return !0;
          return !1
        }

        function Ud(i, r, n, a = 1 / 0) {
          const _ = Mu(i),
            f = Mu(r);
          if (a !== 1 / 0 && Hc(_, f, n) >= a) return a;
          if (Za(_, f)) {
            if (Z_(i, r)) return 0
          } else if (Z_(r, i)) return 0;
          let m = 1 / 0;
          for (const v of i)
            for (let b = 0, S = v.length, M = S - 1; b < S; M = b++) {
              const j = v[M],
                O = v[b];
              for (const N of r)
                for (let H = 0, J = N.length, rt = J - 1; H < J; rt = H++) {
                  const ht = N[rt],
                    Ot = N[H];
                  if (Ga(j, O, ht, Ot)) return 0;
                  m = Math.min(m, Wc(j, O, ht, Ot, n))
                }
            }
          return m
        }

        function G_(i, r, n, a, _, f) {
          if (!f) return;
          const m = Hc(Gc(a, f), _, n);
          m < r && i.push([m, f, [0, 0]])
        }

        function Cu(i, r, n, a, _, f, m) {
          if (!f || !m) return;
          const v = Hc(Gc(a, f), Gc(_, m), n);
          v < r && i.push([v, f, m])
        }

        function Iu(i, r, n, a, _ = 1 / 0) {
          let f = Math.min(a.distance(i[0], n[0][0]), _);
          if (f === 0) return f;
          const m = new q_([
              [0, [0, i.length - 1],
                [0, 0]
              ]
            ], Uc),
            v = Mu(n);
          for (; m.length > 0;) {
            const b = m.pop();
            if (b[0] >= f) continue;
            const S = b[1],
              M = r ? 50 : 100;
            if (Ha(S) <= M) {
              if (!as(S, i.length)) return NaN;
              if (r) {
                const j = Vd(i, S, n, a);
                if (isNaN(j) || j === 0) return j;
                f = Math.min(f, j)
              } else
                for (let j = S[0]; j <= S[1]; ++j) {
                  const O = Nd(i[j], n, a);
                  if (f = Math.min(f, O), f === 0) return 0
                }
            } else {
              const j = Zc(S, r);
              G_(m, f, a, i, v, j[0]), G_(m, f, a, i, v, j[1])
            }
          }
          return f
        }

        function zu(i, r, n, a, _, f = 1 / 0) {
          let m = Math.min(f, _.distance(i[0], n[0]));
          if (m === 0) return m;
          const v = new q_([
            [0, [0, i.length - 1],
              [0, n.length - 1]
            ]
          ], Uc);
          for (; v.length > 0;) {
            const b = v.pop();
            if (b[0] >= m) continue;
            const S = b[1],
              M = b[2],
              j = r ? 50 : 100,
              O = a ? 50 : 100;
            if (Ha(S) <= j && Ha(M) <= O) {
              if (!as(S, i.length) && as(M, n.length)) return NaN;
              let N;
              if (r && a) N = Zn(i, S, n, M, _), m = Math.min(m, N);
              else if (r && !a) {
                const H = i.slice(S[0], S[1] + 1);
                for (let J = M[0]; J <= M[1]; ++J)
                  if (N = Ns(n[J], H, _), m = Math.min(m, N), m === 0) return m
              } else if (!r && a) {
                const H = n.slice(M[0], M[1] + 1);
                for (let J = S[0]; J <= S[1]; ++J)
                  if (N = Ns(i[J], H, _), m = Math.min(m, N), m === 0) return m
              } else N = qd(i, S, n, M, _), m = Math.min(m, N)
            } else {
              const N = Zc(S, r),
                H = Zc(M, a);
              Cu(v, m, _, i, n, N[0], H[0]), Cu(v, m, _, i, n, N[0], H[1]), Cu(v, m, _, i, n, N[1], H[0]), Cu(v, m, _, i, n, N[1], H[1])
            }
          }
          return m
        }

        function $c(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map((r => ({
            type: "Polygon",
            coordinates: r
          }))) : i.type === "MultiLineString" ? i.coordinates.map((r => ({
            type: "LineString",
            coordinates: r
          }))) : i.type === "MultiPoint" ? i.coordinates.map((r => ({
            type: "Point",
            coordinates: r
          }))) : [i]
        }
        class Vs {
          constructor(r, n) {
            this.type = Kt, this.geojson = r, this.geometries = n
          }
          static parse(r, n) {
            if (r.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${r.length-1} instead.`);
            if ($i(r[1])) {
              const a = r[1];
              if (a.type === "FeatureCollection") return new Vs(a, a.features.map((_ => $c(_.geometry))).flat());
              if (a.type === "Feature") return new Vs(a, $c(a.geometry));
              if ("type" in a && "coordinates" in a) return new Vs(a, $c(a))
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(r) {
            if (r.geometry() != null && r.canonicalID() != null) {
              if (r.geometryType() === "Point") return (function(n, a) {
                const _ = n.geometry(),
                  f = _.flat().map((b => Rc([b.x, b.y], n.canonical)));
                if (_.length === 0) return NaN;
                const m = new Vc(f[0][1]);
                let v = 1 / 0;
                for (const b of a) {
                  switch (b.type) {
                    case "Point":
                      v = Math.min(v, zu(f, !1, [b.coordinates], !1, m, v));
                      break;
                    case "LineString":
                      v = Math.min(v, zu(f, !1, b.coordinates, !0, m, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Iu(f, !1, b.coordinates, m, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(r, this.geometries);
              if (r.geometryType() === "LineString") return (function(n, a) {
                const _ = n.geometry(),
                  f = _.flat().map((b => Rc([b.x, b.y], n.canonical)));
                if (_.length === 0) return NaN;
                const m = new Vc(f[0][1]);
                let v = 1 / 0;
                for (const b of a) {
                  switch (b.type) {
                    case "Point":
                      v = Math.min(v, zu(f, !0, [b.coordinates], !1, m, v));
                      break;
                    case "LineString":
                      v = Math.min(v, zu(f, !0, b.coordinates, !0, m, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Iu(f, !0, b.coordinates, m, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(r, this.geometries);
              if (r.geometryType() === "Polygon") return (function(n, a) {
                const _ = n.geometry();
                if (_.length === 0 || _[0].length === 0) return NaN;
                const f = Su(_, 0).map((b => b.map((S => S.map((M => Rc([M.x, M.y], n.canonical))))))),
                  m = new Vc(f[0][0][0][1]);
                let v = 1 / 0;
                for (const b of a)
                  for (const S of f) {
                    switch (b.type) {
                      case "Point":
                        v = Math.min(v, Iu([b.coordinates], !1, S, m, v));
                        break;
                      case "LineString":
                        v = Math.min(v, Iu(b.coordinates, !0, S, m, v));
                        break;
                      case "Polygon":
                        v = Math.min(v, Ud(S, b.coordinates, m, v))
                    }
                    if (v === 0) return v
                  }
                return v
              })(r, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Wa {
          constructor(r) {
            this.type = Ge, this.key = r
          }
          static parse(r, n) {
            if (r.length !== 2) return n.error(`Expected 1 argument, but found ${r.length-1} instead.`);
            const a = r[1];
            return a == null ? n.error("Global state property must be defined.") : typeof a != "string" ? n.error(`Global state property must be string, but found ${typeof r[1]} instead.`) : new Wa(a)
          }
          evaluate(r) {
            var n;
            const a = (n = r.globals) === null || n === void 0 ? void 0 : n.globalState;
            return a && Object.keys(a).length !== 0 ? Ai(a, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const ba = {
          "==": Lc,
          "!=": Ed,
          ">": wu,
          "<": D_,
          ">=": No,
          "<=": ku,
          array: Sn,
          at: Oo,
          boolean: Sn,
          case: Qo,
          coalesce: Na,
          collator: Va,
          format: Tu,
          image: Ua,
          in: ko,
          "index-of": Jo,
          interpolate: Un,
          "interpolate-hcl": Un,
          "interpolate-lab": Un,
          length: Dc,
          let: wo,
          literal: pi,
          match: Lo,
          number: Sn,
          "number-format": va,
          object: Sn,
          slice: Ts,
          step: Ti,
          string: Sn,
          "to-boolean": pn,
          "to-color": pn,
          "to-number": pn,
          "to-string": pn,
          var: ro,
          within: qs,
          distance: Vs,
          "global-state": Wa
        };
        class Ro {
          constructor(r, n, a, _) {
            this.name = r, this.type = n, this._evaluate = a, this.args = _
          }
          evaluate(r) {
            return this._evaluate(r, this.args)
          }
          eachChild(r) {
            this.args.forEach(r)
          }
          outputDefined() {
            return !1
          }
          static parse(r, n) {
            const a = r[0],
              _ = Ro.definitions[a];
            if (!_) return n.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const f = Array.isArray(_) ? _[0] : _.type,
              m = Array.isArray(_) ? [
                [_[1], _[2]]
              ] : _.overloads,
              v = m.filter((([S]) => !Array.isArray(S) || S.length === r.length - 1));
            let b = null;
            for (const [S, M] of v) {
              b = new En(n.registry, Au, n.path, null, n.scope);
              const j = [];
              let O = !1;
              for (let N = 1; N < r.length; N++) {
                const H = r[N],
                  J = Array.isArray(S) ? S[N - 1] : S.type,
                  rt = b.parse(H, 1 + j.length, J);
                if (!rt) {
                  O = !0;
                  break
                }
                j.push(rt)
              }
              if (!O)
                if (Array.isArray(S) && S.length !== j.length) b.error(`Expected ${S.length} arguments, but found ${j.length} instead.`);
                else {
                  for (let N = 0; N < j.length; N++) {
                    const H = Array.isArray(S) ? S[N] : S.type,
                      J = j[N];
                    b.concat(N + 1).checkSubtype(H, J.type)
                  }
                  if (b.errors.length === 0) return new Ro(a, f, M, j)
                }
            }
            if (v.length === 1) n.errors.push(...b.errors);
            else {
              const S = (v.length ? v : m).map((([j]) => {
                  return O = j, Array.isArray(O) ? `(${O.map(Cr).join(", ")})` : `(${Cr(O.type)}...)`;
                  var O
                })).join(" | "),
                M = [];
              for (let j = 1; j < r.length; j++) {
                const O = n.parse(r[j], 1 + M.length);
                if (!O) return null;
                M.push(Cr(O.type))
              }
              n.error(`Expected arguments of type ${S}, but found (${M.join(", ")}) instead.`)
            }
            return null
          }
          static register(r, n) {
            Ro.definitions = n;
            for (const a in n) r[a] = Ro
          }
        }

        function H_(i, [r, n, a, _]) {
          r = r.evaluate(i), n = n.evaluate(i), a = a.evaluate(i);
          const f = _ ? _.evaluate(i) : 1,
            m = Wi(r, n, a, f);
          if (m) throw new In(m);
          return new Ur(r / 255, n / 255, a / 255, f, !1)
        }

        function W_(i, r) {
          return i in r
        }

        function Xc(i, r) {
          const n = r[i];
          return n === void 0 ? null : n
        }

        function Us(i) {
          return {
            type: i
          }
        }

        function Au(i) {
          if (i instanceof ro) return Au(i.boundExpression);
          if (i instanceof Ro && i.name === "error" || i instanceof Va || i instanceof qs || i instanceof Vs || i instanceof Wa) return !1;
          const r = i instanceof pn || i instanceof Sn;
          let n = !0;
          return i.eachChild((a => {
            n = r ? n && Au(a) : n && a instanceof pi
          })), !!n && Eu(i) && ju(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function Eu(i) {
          if (i instanceof Ro && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof qs || i instanceof Vs) return !1;
          let r = !0;
          return i.eachChild((n => {
            r && !Eu(n) && (r = !1)
          })), r
        }

        function $a(i) {
          if (i instanceof Ro && i.name === "feature-state") return !1;
          let r = !0;
          return i.eachChild((n => {
            r && !$a(n) && (r = !1)
          })), r
        }

        function ju(i, r) {
          if (i instanceof Ro && r.indexOf(i.name) >= 0) return !1;
          let n = !0;
          return i.eachChild((a => {
            n && !ju(a, r) && (n = !1)
          })), n
        }

        function $_(i) {
          return {
            result: "success",
            value: i
          }
        }

        function xa(i) {
          return {
            result: "error",
            value: i
          }
        }

        function wa(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
        }

        function X_(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
        }

        function Yc(i) {
          return !!i.expression && i.expression.interpolated
        }

        function Ln(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
        }

        function Lu(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && Yn(i) === cr
        }

        function Zd(i) {
          return i
        }

        function Y_(i, r) {
          const n = i.stops && typeof i.stops[0][0] == "object",
            a = n || !(n || i.property !== void 0),
            _ = i.type || (Yc(r) ? "exponential" : "interval"),
            f = (function(M) {
              switch (M.type) {
                case "color":
                  return Ur.parse;
                case "padding":
                  return Bn.parse;
                case "numberArray":
                  return Vn.parse;
                case "colorArray":
                  return bn.parse;
                default:
                  return null
              }
            })(r);
          if (f && ((i = je({}, i)).stops && (i.stops = i.stops.map((M => [M[0], f(M[1])]))), i.default = f(i.default ? i.default : r.default)), i.colorSpace && (m = i.colorSpace) !== "rgb" && m !== "hcl" && m !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var m;
          const v = (function(M) {
            switch (M) {
              case "exponential":
                return K_;
              case "interval":
                return Hd;
              case "categorical":
                return Gd;
              case "identity":
                return J_;
              default:
                throw new Error(`Unknown function type "${M}"`)
            }
          })(_);
          let b, S;
          if (_ === "categorical") {
            b = Object.create(null);
            for (const M of i.stops) b[M[0]] = M[1];
            S = typeof i.stops[0][0]
          }
          if (n) {
            const M = {},
              j = [];
            for (let H = 0; H < i.stops.length; H++) {
              const J = i.stops[H],
                rt = J[0].zoom;
              M[rt] === void 0 && (M[rt] = {
                zoom: rt,
                type: i.type,
                property: i.property,
                default: i.default,
                stops: []
              }, j.push(rt)), M[rt].stops.push([J[0].value, J[1]])
            }
            const O = [];
            for (const H of j) O.push([M[H].zoom, Y_(M[H], r)]);
            const N = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: N,
              interpolationFactor: Un.interpolationFactor.bind(void 0, N),
              zoomStops: O.map((H => H[0])),
              evaluate: ({
                zoom: H
              }, J) => K_({
                stops: O,
                base: i.base
              }, r, H).evaluate(H, J)
            }
          }
          if (a) {
            const M = _ === "exponential" ? {
              name: "exponential",
              base: i.base !== void 0 ? i.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: M,
              interpolationFactor: Un.interpolationFactor.bind(void 0, M),
              zoomStops: i.stops.map((j => j[0])),
              evaluate: ({
                zoom: j
              }) => v(i, r, j, b, S)
            }
          }
          return {
            kind: "source",
            evaluate(M, j) {
              const O = j && j.properties ? j.properties[i.property] : void 0;
              return O === void 0 ? Zs(i.default, r.default) : v(i, r, O, b, S)
            }
          }
        }

        function Zs(i, r, n) {
          return i !== void 0 ? i : r !== void 0 ? r : n !== void 0 ? n : void 0
        }

        function Gd(i, r, n, a, _) {
          return Zs(typeof n === _ ? a[n] : void 0, i.default, r.default)
        }

        function Hd(i, r, n) {
          if (Ln(n) !== "number") return Zs(i.default, r.default);
          const a = i.stops.length;
          if (a === 1 || n <= i.stops[0][0]) return i.stops[0][1];
          if (n >= i.stops[a - 1][0]) return i.stops[a - 1][1];
          const _ = vi(i.stops.map((f => f[0])), n);
          return i.stops[_][1]
        }

        function K_(i, r, n) {
          const a = i.base !== void 0 ? i.base : 1;
          if (Ln(n) !== "number") return Zs(i.default, r.default);
          const _ = i.stops.length;
          if (_ === 1 || n <= i.stops[0][0]) return i.stops[0][1];
          if (n >= i.stops[_ - 1][0]) return i.stops[_ - 1][1];
          const f = vi(i.stops.map((M => M[0])), n),
            m = (function(M, j, O, N) {
              const H = N - O,
                J = M - O;
              return H === 0 ? 0 : j === 1 ? J / H : (Math.pow(j, J) - 1) / (Math.pow(j, H) - 1)
            })(n, a, i.stops[f][0], i.stops[f + 1][0]),
            v = i.stops[f][1],
            b = i.stops[f + 1][1],
            S = Do[r.type] || Zd;
          return typeof v.evaluate == "function" ? {
            evaluate(...M) {
              const j = v.evaluate.apply(void 0, M),
                O = b.evaluate.apply(void 0, M);
              if (j !== void 0 && O !== void 0) return S(j, O, m, i.colorSpace)
            }
          } : S(v, b, m, i.colorSpace)
        }

        function J_(i, r, n) {
          switch (r.type) {
            case "color":
              n = Ur.parse(n);
              break;
            case "formatted":
              n = sn.fromString(n.toString());
              break;
            case "resolvedImage":
              n = ki.fromString(n.toString());
              break;
            case "padding":
              n = Bn.parse(n);
              break;
            case "colorArray":
              n = bn.parse(n);
              break;
            case "numberArray":
              n = Vn.parse(n);
              break;
            default:
              Ln(n) === r.type || r.type === "enum" && r.values[n] || (n = void 0)
          }
          return Zs(n, i.default, r.default)
        }
        Ro.register(ba, {
          error: [{
              kind: "error"
            },
            [Oe], (i, [r]) => {
              throw new In(r.evaluate(i))
            }
          ],
          typeof: [Oe, [Ge], (i, [r]) => Cr(Yn(r.evaluate(i)))],
          "to-rgba": [De(Kt, 4), [fe], (i, [r]) => {
            const [n, a, _, f] = r.evaluate(i).rgb;
            return [255 * n, 255 * a, 255 * _, f]
          }],
          rgb: [fe, [Kt, Kt, Kt], H_],
          rgba: [fe, [Kt, Kt, Kt, Kt], H_],
          has: {
            type: Be,
            overloads: [
              [
                [Oe], (i, [r]) => W_(r.evaluate(i), i.properties())
              ],
              [
                [Oe, cr], (i, [r, n]) => W_(r.evaluate(i), n.evaluate(i))
              ]
            ]
          },
          get: {
            type: Ge,
            overloads: [
              [
                [Oe], (i, [r]) => Xc(r.evaluate(i), i.properties())
              ],
              [
                [Oe, cr], (i, [r, n]) => Xc(r.evaluate(i), n.evaluate(i))
              ]
            ]
          },
          "feature-state": [Ge, [Oe], (i, [r]) => Xc(r.evaluate(i), i.featureState || {})],
          properties: [cr, [], i => i.properties()],
          "geometry-type": [Oe, [], i => i.geometryType()],
          id: [Ge, [], i => i.id()],
          zoom: [Kt, [], i => i.globals.zoom],
          "heatmap-density": [Kt, [], i => i.globals.heatmapDensity || 0],
          elevation: [Kt, [], i => i.globals.elevation || 0],
          "line-progress": [Kt, [], i => i.globals.lineProgress || 0],
          accumulated: [Ge, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
          "+": [Kt, Us(Kt), (i, r) => {
            let n = 0;
            for (const a of r) n += a.evaluate(i);
            return n
          }],
          "*": [Kt, Us(Kt), (i, r) => {
            let n = 1;
            for (const a of r) n *= a.evaluate(i);
            return n
          }],
          "-": {
            type: Kt,
            overloads: [
              [
                [Kt, Kt], (i, [r, n]) => r.evaluate(i) - n.evaluate(i)
              ],
              [
                [Kt], (i, [r]) => -r.evaluate(i)
              ]
            ]
          },
          "/": [Kt, [Kt, Kt], (i, [r, n]) => r.evaluate(i) / n.evaluate(i)],
          "%": [Kt, [Kt, Kt], (i, [r, n]) => r.evaluate(i) % n.evaluate(i)],
          ln2: [Kt, [], () => Math.LN2],
          pi: [Kt, [], () => Math.PI],
          e: [Kt, [], () => Math.E],
          "^": [Kt, [Kt, Kt], (i, [r, n]) => Math.pow(r.evaluate(i), n.evaluate(i))],
          sqrt: [Kt, [Kt], (i, [r]) => Math.sqrt(r.evaluate(i))],
          log10: [Kt, [Kt], (i, [r]) => Math.log(r.evaluate(i)) / Math.LN10],
          ln: [Kt, [Kt], (i, [r]) => Math.log(r.evaluate(i))],
          log2: [Kt, [Kt], (i, [r]) => Math.log(r.evaluate(i)) / Math.LN2],
          sin: [Kt, [Kt], (i, [r]) => Math.sin(r.evaluate(i))],
          cos: [Kt, [Kt], (i, [r]) => Math.cos(r.evaluate(i))],
          tan: [Kt, [Kt], (i, [r]) => Math.tan(r.evaluate(i))],
          asin: [Kt, [Kt], (i, [r]) => Math.asin(r.evaluate(i))],
          acos: [Kt, [Kt], (i, [r]) => Math.acos(r.evaluate(i))],
          atan: [Kt, [Kt], (i, [r]) => Math.atan(r.evaluate(i))],
          min: [Kt, Us(Kt), (i, r) => Math.min(...r.map((n => n.evaluate(i))))],
          max: [Kt, Us(Kt), (i, r) => Math.max(...r.map((n => n.evaluate(i))))],
          abs: [Kt, [Kt], (i, [r]) => Math.abs(r.evaluate(i))],
          round: [Kt, [Kt], (i, [r]) => {
            const n = r.evaluate(i);
            return n < 0 ? -Math.round(-n) : Math.round(n)
          }],
          floor: [Kt, [Kt], (i, [r]) => Math.floor(r.evaluate(i))],
          ceil: [Kt, [Kt], (i, [r]) => Math.ceil(r.evaluate(i))],
          "filter-==": [Be, [Oe, Ge], (i, [r, n]) => i.properties()[r.value] === n.value],
          "filter-id-==": [Be, [Ge], (i, [r]) => i.id() === r.value],
          "filter-type-==": [Be, [Oe], (i, [r]) => i.geometryType() === r.value],
          "filter-<": [Be, [Oe, Ge], (i, [r, n]) => {
            const a = i.properties()[r.value],
              _ = n.value;
            return typeof a == typeof _ && a < _
          }],
          "filter-id-<": [Be, [Ge], (i, [r]) => {
            const n = i.id(),
              a = r.value;
            return typeof n == typeof a && n < a
          }],
          "filter->": [Be, [Oe, Ge], (i, [r, n]) => {
            const a = i.properties()[r.value],
              _ = n.value;
            return typeof a == typeof _ && a > _
          }],
          "filter-id->": [Be, [Ge], (i, [r]) => {
            const n = i.id(),
              a = r.value;
            return typeof n == typeof a && n > a
          }],
          "filter-<=": [Be, [Oe, Ge], (i, [r, n]) => {
            const a = i.properties()[r.value],
              _ = n.value;
            return typeof a == typeof _ && a <= _
          }],
          "filter-id-<=": [Be, [Ge], (i, [r]) => {
            const n = i.id(),
              a = r.value;
            return typeof n == typeof a && n <= a
          }],
          "filter->=": [Be, [Oe, Ge], (i, [r, n]) => {
            const a = i.properties()[r.value],
              _ = n.value;
            return typeof a == typeof _ && a >= _
          }],
          "filter-id->=": [Be, [Ge], (i, [r]) => {
            const n = i.id(),
              a = r.value;
            return typeof n == typeof a && n >= a
          }],
          "filter-has": [Be, [Ge], (i, [r]) => r.value in i.properties()],
          "filter-has-id": [Be, [], i => i.id() !== null && i.id() !== void 0],
          "filter-type-in": [Be, [De(Oe)], (i, [r]) => r.value.indexOf(i.geometryType()) >= 0],
          "filter-id-in": [Be, [De(Ge)], (i, [r]) => r.value.indexOf(i.id()) >= 0],
          "filter-in-small": [Be, [Oe, De(Ge)], (i, [r, n]) => n.value.indexOf(i.properties()[r.value]) >= 0],
          "filter-in-large": [Be, [Oe, De(Ge)], (i, [r, n]) => (function(a, _, f, m) {
            for (; f <= m;) {
              const v = f + m >> 1;
              if (_[v] === a) return !0;
              _[v] > a ? m = v - 1 : f = v + 1
            }
            return !1
          })(i.properties()[r.value], n.value, 0, n.value.length - 1)],
          all: {
            type: Be,
            overloads: [
              [
                [Be, Be], (i, [r, n]) => r.evaluate(i) && n.evaluate(i)
              ],
              [Us(Be), (i, r) => {
                for (const n of r)
                  if (!n.evaluate(i)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: Be,
            overloads: [
              [
                [Be, Be], (i, [r, n]) => r.evaluate(i) || n.evaluate(i)
              ],
              [Us(Be), (i, r) => {
                for (const n of r)
                  if (n.evaluate(i)) return !0;
                return !1
              }]
            ]
          },
          "!": [Be, [Be], (i, [r]) => !r.evaluate(i)],
          "is-supported-script": [Be, [Oe], (i, [r]) => {
            const n = i.globals && i.globals.isSupportedScript;
            return !n || n(r.evaluate(i))
          }],
          upcase: [Oe, [Oe], (i, [r]) => r.evaluate(i).toUpperCase()],
          downcase: [Oe, [Oe], (i, [r]) => r.evaluate(i).toLowerCase()],
          concat: [Oe, Us(Ge), (i, r) => r.map((n => ai(n.evaluate(i)))).join("")],
          "resolved-locale": [Oe, [qr], (i, [r]) => r.evaluate(i).resolvedLocale()]
        });
        class Kc {
          constructor(r, n, a) {
            this.expression = r, this._warningHistory = {}, this._evaluator = new Ko, this._defaultValue = n ? (function(_) {
              if (_.type === "color" && Lu(_.default)) return new Ur(0, 0, 0, 0);
              switch (_.type) {
                case "color":
                  return Ur.parse(_.default) || null;
                case "padding":
                  return Bn.parse(_.default) || null;
                case "numberArray":
                  return Vn.parse(_.default) || null;
                case "colorArray":
                  return bn.parse(_.default) || null;
                case "variableAnchorOffsetCollection":
                  return Wn.parse(_.default) || null;
                case "projectionDefinition":
                  return yi.parse(_.default) || null;
                default:
                  return _.default === void 0 ? null : _.default
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this._globalState = a
          }
          evaluateWithoutErrorHandling(r, n, a, _, f, m) {
            return this._globalState && (r = Hs(r, this._globalState)), this._evaluator.globals = r, this._evaluator.feature = n, this._evaluator.featureState = a, this._evaluator.canonical = _, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = m, this.expression.evaluate(this._evaluator)
          }
          evaluate(r, n, a, _, f, m) {
            this._globalState && (r = Hs(r, this._globalState)), this._evaluator.globals = r, this._evaluator.feature = n || null, this._evaluator.featureState = a || null, this._evaluator.canonical = _, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = m || null;
            try {
              const v = this.expression.evaluate(this._evaluator);
              if (v == null || typeof v == "number" && v != v) return this._defaultValue;
              if (this._enumValues && !(v in this._enumValues)) throw new In(`Expected value to be one of ${Object.keys(this._enumValues).map((b=>JSON.stringify(b))).join(", ")}, but found ${JSON.stringify(v)} instead.`);
              return v
            } catch (v) {
              return this._warningHistory[v.message] || (this._warningHistory[v.message] = !0, typeof console < "u" && console.warn(v.message)), this._defaultValue
            }
          }
        }

        function Du(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in ba
        }

        function Gs(i, r, n) {
          const a = new En(ba, Au, [], r ? (function(f) {
              const m = {
                color: fe,
                string: Oe,
                number: Kt,
                enum: Oe,
                boolean: Be,
                formatted: lr,
                padding: Jt,
                numberArray: rr,
                colorArray: Se,
                projectionDefinition: Me,
                resolvedImage: Le,
                variableAnchorOffsetCollection: sr
              };
              return f.type === "array" ? De(m[f.value] || Ge, f.length) : m[f.type]
            })(r) : void 0),
            _ = a.parse(i, void 0, void 0, void 0, r && r.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return _ ? $_(new Kc(_, r, n)) : xa(a.errors)
        }
        class Xa {
          constructor(r, n, a) {
            this.kind = r, this._styleExpression = n, this.isStateDependent = r !== "constant" && !$a(n.expression), this.globalStateRefs = Fu(n.expression), this._globalState = a
          }
          evaluateWithoutErrorHandling(r, n, a, _, f, m) {
            return this._globalState && (r = Hs(r, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(r, n, a, _, f, m)
          }
          evaluate(r, n, a, _, f, m) {
            return this._globalState && (r = Hs(r, this._globalState)), this._styleExpression.evaluate(r, n, a, _, f, m)
          }
        }
        class Jc {
          constructor(r, n, a, _, f) {
            this.kind = r, this.zoomStops = a, this._styleExpression = n, this.isStateDependent = r !== "camera" && !$a(n.expression), this.globalStateRefs = Fu(n.expression), this.interpolationType = _, this._globalState = f
          }
          evaluateWithoutErrorHandling(r, n, a, _, f, m) {
            return this._globalState && (r = Hs(r, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(r, n, a, _, f, m)
          }
          evaluate(r, n, a, _, f, m) {
            return this._globalState && (r = Hs(r, this._globalState)), this._styleExpression.evaluate(r, n, a, _, f, m)
          }
          interpolationFactor(r, n, a) {
            return this.interpolationType ? Un.interpolationFactor(this.interpolationType, r, n, a) : 0
          }
        }

        function Q_(i, r, n) {
          const a = Gs(i, r, n);
          if (a.result === "error") return a;
          const _ = a.value.expression,
            f = Eu(_);
          if (!f && !wa(r)) return xa([new Fe("", "data expressions not supported")]);
          const m = ju(_, ["zoom"]);
          if (!m && !X_(r)) return xa([new Fe("", "zoom expressions not supported")]);
          const v = Bu(_);
          return v || m ? v instanceof Fe ? xa([v]) : v instanceof Un && !Yc(r) ? xa([new Fe("", '"interpolate" expressions cannot be used with this property')]) : $_(v ? new Jc(f ? "camera" : "composite", a.value, v.labels, v instanceof Un ? v.interpolation : void 0, n) : new Xa(f ? "constant" : "source", a.value, n)) : xa([new Fe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Ru {
          constructor(r, n) {
            this._parameters = r, this._specification = n, je(this, Y_(this._parameters, this._specification))
          }
          static deserialize(r) {
            return new Ru(r._parameters, r._specification)
          }
          static serialize(r) {
            return {
              _parameters: r._parameters,
              _specification: r._specification
            }
          }
        }

        function Bu(i) {
          let r = null;
          if (i instanceof wo) r = Bu(i.result);
          else if (i instanceof Na) {
            for (const n of i.args)
              if (r = Bu(n), r) break
          } else(i instanceof Ti || i instanceof Un) && i.input instanceof Ro && i.input.name === "zoom" && (r = i);
          return r instanceof Fe || i.eachChild((n => {
            const a = Bu(n);
            a instanceof Fe ? r = a : !r && a ? r = new Fe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : r && a && r !== a && (r = new Fe("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), r
        }

        function Fu(i, r = new Set) {
          return i instanceof Wa && r.add(i.key), i.eachChild((n => {
            Fu(n, r)
          })), r
        }

        function Hs(i, r) {
          const {
            zoom: n,
            heatmapDensity: a,
            elevation: _,
            lineProgress: f,
            isSupportedScript: m,
            accumulated: v
          } = i ?? {};
          return {
            zoom: n,
            heatmapDensity: a,
            elevation: _,
            lineProgress: f,
            isSupportedScript: m,
            accumulated: v,
            globalState: r
          }
        }

        function Ou(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const r of i.slice(1))
                if (!Ou(r) && typeof r != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const Wd = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function Ya(i, r) {
          if (i == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          Ou(i) || (i = Ka(i));
          const n = Gs(i, Wd, r);
          if (n.result === "error") throw new Error(n.value.map((a => `${a.key}: ${a.message}`)).join(", "));
          return {
            filter: (a, _, f) => n.value.evaluate(a, _, {}, f),
            needGeometry: Qc(i),
            getGlobalStateRefs: () => Fu(n.value.expression)
          }
        }

        function th(i, r) {
          return i < r ? -1 : i > r ? 1 : 0
        }

        function Qc(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let r = 1; r < i.length; r++)
            if (Qc(i[r])) return !0;
          return !1
        }

        function Ka(i) {
          if (!i) return !0;
          const r = i[0];
          return i.length <= 1 ? r !== "any" : r === "==" ? tl(i[1], i[2], "==") : r === "!=" ? qu(tl(i[1], i[2], "==")) : r === "<" || r === ">" || r === "<=" || r === ">=" ? tl(i[1], i[2], r) : r === "any" ? (n = i.slice(1), ["any"].concat(n.map(Ka))) : r === "all" ? ["all"].concat(i.slice(1).map(Ka)) : r === "none" ? ["all"].concat(i.slice(1).map(Ka).map(qu)) : r === "in" ? eh(i[1], i.slice(2)) : r === "!in" ? qu(eh(i[1], i.slice(2))) : r === "has" ? rh(i[1]) : r !== "!has" || qu(rh(i[1]));
          var n
        }

        function tl(i, r, n) {
          switch (i) {
            case "$type":
              return [`filter-type-${n}`, r];
            case "$id":
              return [`filter-id-${n}`, r];
            default:
              return [`filter-${n}`, i, r]
          }
        }

        function eh(i, r) {
          if (r.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", r]];
            case "$id":
              return ["filter-id-in", ["literal", r]];
            default:
              return r.length > 200 && !r.some((n => typeof n != typeof r[0])) ? ["filter-in-large", i, ["literal", r.sort(th)]] : ["filter-in-small", i, ["literal", r]]
          }
        }

        function rh(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i]
          }
        }

        function qu(i) {
          return ["!", i]
        }

        function Nu(i) {
          const r = typeof i;
          if (r === "number" || r === "boolean" || r === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let _ = "[";
            for (const f of i) _ += `${Nu(f)},`;
            return `${_}]`
          }
          const n = Object.keys(i).sort();
          let a = "{";
          for (let _ = 0; _ < n.length; _++) a += `${JSON.stringify(n[_])}:${Nu(i[n[_]])},`;
          return `${a}}`
        }

        function nh(i) {
          let r = "";
          for (const n of vt) r += `/${Nu(i[n])}`;
          return r
        }

        function Vu(i) {
          const r = i.value;
          return r ? [new Yt(i.key, r, "constants have been deprecated as of v8")] : []
        }

        function ci(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
        }

        function us(i) {
          if (Array.isArray(i)) return i.map(us);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const r = {};
            for (const n in i) r[n] = us(i[n]);
            return r
          }
          return ci(i)
        }

        function fo(i) {
          const r = i.key,
            n = i.value,
            a = i.valueSpec || {},
            _ = i.objectElementValidators || {},
            f = i.style,
            m = i.styleSpec,
            v = i.validateSpec;
          let b = [];
          const S = Ln(n);
          if (S !== "object") return [new Yt(r, n, `object expected, ${S} found`)];
          for (const M in n) {
            const j = M.split(".")[0],
              O = Ai(a, j) || a["*"];
            let N;
            if (Ai(_, j)) N = _[j];
            else if (Ai(a, j)) N = v;
            else if (_["*"]) N = _["*"];
            else {
              if (!a["*"]) {
                b.push(new Yt(r, n[M], `unknown property "${M}"`));
                continue
              }
              N = v
            }
            b = b.concat(N({
              key: (r && `${r}.`) + M,
              value: n[M],
              valueSpec: O,
              style: f,
              styleSpec: m,
              object: n,
              objectKey: M,
              validateSpec: v
            }, n))
          }
          for (const M in a) _[M] || a[M].required && a[M].default === void 0 && n[M] === void 0 && b.push(new Yt(r, n, `missing required property "${M}"`));
          return b
        }

        function ka(i) {
          const r = i.value,
            n = i.valueSpec,
            a = i.style,
            _ = i.styleSpec,
            f = i.key,
            m = i.arrayElementValidator || i.validateSpec;
          if (Ln(r) !== "array") return [new Yt(f, r, `array expected, ${Ln(r)} found`)];
          if (n.length && r.length !== n.length) return [new Yt(f, r, `array length ${n.length} expected, length ${r.length} found`)];
          if (n["min-length"] && r.length < n["min-length"]) return [new Yt(f, r, `array length at least ${n["min-length"]} expected, length ${r.length} found`)];
          let v = {
            type: n.value,
            values: n.values
          };
          _.$version < 7 && (v.function = n.function), Ln(n.value) === "object" && (v = n.value);
          let b = [];
          for (let S = 0; S < r.length; S++) b = b.concat(m({
            array: r,
            arrayIndex: S,
            value: r[S],
            valueSpec: v,
            validateSpec: i.validateSpec,
            style: a,
            styleSpec: _,
            key: `${f}[${S}]`
          }));
          return b
        }

        function Uu(i) {
          const r = i.key,
            n = i.value,
            a = i.valueSpec;
          let _ = Ln(n);
          return _ === "number" && n != n && (_ = "NaN"), _ !== "number" ? [new Yt(r, n, `number expected, ${_} found`)] : "minimum" in a && n < a.minimum ? [new Yt(r, n, `${n} is less than the minimum value ${a.minimum}`)] : "maximum" in a && n > a.maximum ? [new Yt(r, n, `${n} is greater than the maximum value ${a.maximum}`)] : []
        }

        function ih(i) {
          const r = i.valueSpec,
            n = ci(i.value.type);
          let a, _, f, m = {};
          const v = n !== "categorical" && i.value.property === void 0,
            b = !v,
            S = Ln(i.value.stops) === "array" && Ln(i.value.stops[0]) === "array" && Ln(i.value.stops[0][0]) === "object",
            M = fo({
              key: i.key,
              value: i.value,
              valueSpec: i.styleSpec.function,
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: i.styleSpec,
              objectElementValidators: {
                stops: function(N) {
                  if (n === "identity") return [new Yt(N.key, N.value, 'identity function may not have a "stops" property')];
                  let H = [];
                  const J = N.value;
                  return H = H.concat(ka({
                    key: N.key,
                    value: J,
                    valueSpec: N.valueSpec,
                    validateSpec: N.validateSpec,
                    style: N.style,
                    styleSpec: N.styleSpec,
                    arrayElementValidator: j
                  })), Ln(J) === "array" && J.length === 0 && H.push(new Yt(N.key, J, "array must have at least one stop")), H
                },
                default: function(N) {
                  return N.validateSpec({
                    key: N.key,
                    value: N.value,
                    valueSpec: r,
                    validateSpec: N.validateSpec,
                    style: N.style,
                    styleSpec: N.styleSpec
                  })
                }
              }
            });
          return n === "identity" && v && M.push(new Yt(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || M.push(new Yt(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !Yc(i.valueSpec) && M.push(new Yt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (b && !wa(i.valueSpec) ? M.push(new Yt(i.key, i.value, "property functions not supported")) : v && !X_(i.valueSpec) && M.push(new Yt(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !S || i.value.property !== void 0 || M.push(new Yt(i.key, i.value, '"property" property is required')), M;

          function j(N) {
            let H = [];
            const J = N.value,
              rt = N.key;
            if (Ln(J) !== "array") return [new Yt(rt, J, `array expected, ${Ln(J)} found`)];
            if (J.length !== 2) return [new Yt(rt, J, `array length 2 expected, length ${J.length} found`)];
            if (S) {
              if (Ln(J[0]) !== "object") return [new Yt(rt, J, `object expected, ${Ln(J[0])} found`)];
              if (J[0].zoom === void 0) return [new Yt(rt, J, "object stop key must have zoom")];
              if (J[0].value === void 0) return [new Yt(rt, J, "object stop key must have value")];
              if (f && f > ci(J[0].zoom)) return [new Yt(rt, J[0].zoom, "stop zoom values must appear in ascending order")];
              ci(J[0].zoom) !== f && (f = ci(J[0].zoom), _ = void 0, m = {}), H = H.concat(fo({
                key: `${rt}[0]`,
                value: J[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: N.validateSpec,
                style: N.style,
                styleSpec: N.styleSpec,
                objectElementValidators: {
                  zoom: Uu,
                  value: O
                }
              }))
            } else H = H.concat(O({
              key: `${rt}[0]`,
              value: J[0],
              validateSpec: N.validateSpec,
              style: N.style,
              styleSpec: N.styleSpec
            }, J));
            return Du(us(J[1])) ? H.concat([new Yt(`${rt}[1]`, J[1], "expressions are not allowed in function stops.")]) : H.concat(N.validateSpec({
              key: `${rt}[1]`,
              value: J[1],
              valueSpec: r,
              validateSpec: N.validateSpec,
              style: N.style,
              styleSpec: N.styleSpec
            }))
          }

          function O(N, H) {
            const J = Ln(N.value),
              rt = ci(N.value),
              ht = N.value !== null ? N.value : H;
            if (a) {
              if (J !== a) return [new Yt(N.key, ht, `${J} stop domain type must match previous stop domain type ${a}`)]
            } else a = J;
            if (J !== "number" && J !== "string" && J !== "boolean") return [new Yt(N.key, ht, "stop domain value must be a number, string, or boolean")];
            if (J !== "number" && n !== "categorical") {
              let Ot = `number expected, ${J} found`;
              return wa(r) && n === void 0 && (Ot += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Yt(N.key, ht, Ot)]
            }
            return n !== "categorical" || J !== "number" || isFinite(rt) && Math.floor(rt) === rt ? n !== "categorical" && J === "number" && _ !== void 0 && rt < _ ? [new Yt(N.key, ht, "stop domain values must appear in ascending order")] : (_ = rt, n === "categorical" && rt in m ? [new Yt(N.key, ht, "stop domain values must be unique")] : (m[rt] = !0, [])) : [new Yt(N.key, ht, `integer expected, found ${rt}`)]
          }
        }

        function Ta(i) {
          const r = (i.expressionContext === "property" ? Q_ : Gs)(us(i.value), i.valueSpec);
          if (r.result === "error") return r.value.map((a => new Yt(`${i.key}${a.key}`, i.value, a.message)));
          const n = r.value.expression || r.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new Yt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !$a(n)) return [new Yt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !$a(n)) return [new Yt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!ju(n, ["zoom", "feature-state"])) return [new Yt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !Eu(n)) return [new Yt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function el(i) {
          const r = i.key,
            n = i.value,
            a = Ln(n);
          return a !== "string" ? [new Yt(r, n, `color expected, ${a} found`)] : Ur.parse(String(n)) ? [] : [new Yt(r, n, `color expected, "${n}" found`)]
        }

        function Ja(i) {
          const r = i.key,
            n = i.value,
            a = i.valueSpec,
            _ = [];
          return Array.isArray(a.values) ? a.values.indexOf(ci(n)) === -1 && _.push(new Yt(r, n, `expected one of [${a.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(a.values).indexOf(ci(n)) === -1 && _.push(new Yt(r, n, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(n)} found`)), _
        }

        function rl(i) {
          return Ou(us(i.value)) ? Ta(je({}, i, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : nl(i)
        }

        function nl(i) {
          const r = i.value,
            n = i.key;
          if (Ln(r) !== "array") return [new Yt(n, r, `array expected, ${Ln(r)} found`)];
          const a = i.styleSpec;
          let _, f = [];
          if (r.length < 1) return [new Yt(n, r, "filter array must have at least 1 element")];
          switch (f = f.concat(Ja({
              key: `${n}[0]`,
              value: r[0],
              valueSpec: a.filter_operator,
              style: i.style,
              styleSpec: i.styleSpec
            })), ci(r[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              r.length >= 2 && ci(r[1]) === "$type" && f.push(new Yt(n, r, `"$type" cannot be use with operator "${r[0]}"`));
            case "==":
            case "!=":
              r.length !== 3 && f.push(new Yt(n, r, `filter array for operator "${r[0]}" must have 3 elements`));
            case "in":
            case "!in":
              r.length >= 2 && (_ = Ln(r[1]), _ !== "string" && f.push(new Yt(`${n}[1]`, r[1], `string expected, ${_} found`)));
              for (let m = 2; m < r.length; m++) _ = Ln(r[m]), ci(r[1]) === "$type" ? f = f.concat(Ja({
                key: `${n}[${m}]`,
                value: r[m],
                valueSpec: a.geometry_type,
                style: i.style,
                styleSpec: i.styleSpec
              })) : _ !== "string" && _ !== "number" && _ !== "boolean" && f.push(new Yt(`${n}[${m}]`, r[m], `string, number, or boolean expected, ${_} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let m = 1; m < r.length; m++) f = f.concat(nl({
                key: `${n}[${m}]`,
                value: r[m],
                style: i.style,
                styleSpec: i.styleSpec
              }));
              break;
            case "has":
            case "!has":
              _ = Ln(r[1]), r.length !== 2 ? f.push(new Yt(n, r, `filter array for "${r[0]}" operator must have 2 elements`)) : _ !== "string" && f.push(new Yt(`${n}[1]`, r[1], `string expected, ${_} found`))
          }
          return f
        }

        function il(i, r) {
          const n = i.key,
            a = i.validateSpec,
            _ = i.style,
            f = i.styleSpec,
            m = i.value,
            v = i.objectKey,
            b = f[`${r}_${i.layerType}`];
          if (!b) return [];
          const S = v.match(/^(.*)-transition$/);
          if (r === "paint" && S && b[S[1]] && b[S[1]].transition) return a({
            key: n,
            value: m,
            valueSpec: f.transition,
            style: _,
            styleSpec: f
          });
          const M = i.valueSpec || b[v];
          if (!M) return [new Yt(n, m, `unknown property "${v}"`)];
          let j;
          if (Ln(m) === "string" && wa(M) && !M.tokens && (j = /^{([^}]+)}$/.exec(m))) return [new Yt(n, m, `"${v}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(j[1])} }\`.`)];
          const O = [];
          return i.layerType === "symbol" && v === "text-font" && Lu(us(m)) && ci(m.type) === "identity" && O.push(new Yt(n, m, '"text-font" does not support identity functions')), O.concat(a({
            key: i.key,
            value: m,
            valueSpec: M,
            style: _,
            styleSpec: f,
            expressionContext: "property",
            propertyType: r,
            propertyKey: v
          }))
        }

        function Qa(i) {
          return il(i, "paint")
        }

        function oh(i) {
          return il(i, "layout")
        }

        function ol(i) {
          let r = [];
          const n = i.value,
            a = i.key,
            _ = i.style,
            f = i.styleSpec;
          if (Ln(n) !== "object") return [new Yt(a, n, `object expected, ${Ln(n)} found`)];
          n.type || n.ref || r.push(new Yt(a, n, 'either "type" or "ref" is required'));
          let m = ci(n.type);
          const v = ci(n.ref);
          if (n.id) {
            const b = ci(n.id);
            for (let S = 0; S < i.arrayIndex; S++) {
              const M = _.layers[S];
              ci(M.id) === b && r.push(new Yt(a, n.id, `duplicate layer id "${n.id}", previously used at line ${M.id.__line__}`))
            }
          }
          if ("ref" in n) {
            let b;
            ["type", "source", "source-layer", "filter", "layout"].forEach((S => {
              S in n && r.push(new Yt(a, n[S], `"${S}" is prohibited for ref layers`))
            })), _.layers.forEach((S => {
              ci(S.id) === v && (b = S)
            })), b ? b.ref ? r.push(new Yt(a, n.ref, "ref cannot reference another ref layer")) : m = ci(b.type) : r.push(new Yt(a, n.ref, `ref layer "${v}" not found`))
          } else if (m !== "background")
            if (n.source) {
              const b = _.sources && _.sources[n.source],
                S = b && ci(b.type);
              b ? S === "vector" && m === "raster" ? r.push(new Yt(a, n.source, `layer "${n.id}" requires a raster source`)) : S !== "raster-dem" && m === "hillshade" || S !== "raster-dem" && m === "color-relief" ? r.push(new Yt(a, n.source, `layer "${n.id}" requires a raster-dem source`)) : S === "raster" && m !== "raster" ? r.push(new Yt(a, n.source, `layer "${n.id}" requires a vector source`)) : S !== "vector" || n["source-layer"] ? S === "raster-dem" && m !== "hillshade" && m !== "color-relief" ? r.push(new Yt(a, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : m !== "line" || !n.paint || !n.paint["line-gradient"] || S === "geojson" && b.lineMetrics || r.push(new Yt(a, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : r.push(new Yt(a, n, `layer "${n.id}" must specify a "source-layer"`)) : r.push(new Yt(a, n.source, `source "${n.source}" not found`))
            } else r.push(new Yt(a, n, 'missing required property "source"'));
          return r = r.concat(fo({
            key: a,
            value: n,
            valueSpec: f.layer,
            style: i.style,
            styleSpec: i.styleSpec,
            validateSpec: i.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => i.validateSpec({
                key: `${a}.type`,
                value: n.type,
                valueSpec: f.layer.type,
                style: i.style,
                styleSpec: i.styleSpec,
                validateSpec: i.validateSpec,
                object: n,
                objectKey: "type"
              }),
              filter: rl,
              layout: b => fo({
                layer: n,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": S => oh(je({
                    layerType: m
                  }, S))
                }
              }),
              paint: b => fo({
                layer: n,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": S => Qa(je({
                    layerType: m
                  }, S))
                }
              })
            }
          })), r
        }

        function Ms(i) {
          const r = i.value,
            n = i.key,
            a = Ln(r);
          return a !== "string" ? [new Yt(n, r, `string expected, ${a} found`)] : []
        }
        const sh = {
          promoteId: function({
            key: i,
            value: r
          }) {
            if (Ln(r) === "string") return Ms({
              key: i,
              value: r
            });
            {
              const n = [];
              for (const a in r) n.push(...Ms({
                key: `${i}.${a}`,
                value: r[a]
              }));
              return n
            }
          }
        };

        function sl(i) {
          const r = i.value,
            n = i.key,
            a = i.styleSpec,
            _ = i.style,
            f = i.validateSpec;
          if (!r.type) return [new Yt(n, r, '"type" is required')];
          const m = ci(r.type);
          let v;
          switch (m) {
            case "vector":
            case "raster":
              return v = fo({
                key: n,
                value: r,
                valueSpec: a[`source_${m.replace("-","_")}`],
                style: i.style,
                styleSpec: a,
                objectElementValidators: sh,
                validateSpec: f
              }), v;
            case "raster-dem":
              return v = (function(b) {
                var S;
                const M = (S = b.sourceName) !== null && S !== void 0 ? S : "",
                  j = b.value,
                  O = b.styleSpec,
                  N = O.source_raster_dem,
                  H = b.style;
                let J = [];
                const rt = Ln(j);
                if (j === void 0) return J;
                if (rt !== "object") return J.push(new Yt("source_raster_dem", j, `object expected, ${rt} found`)), J;
                const ht = ci(j.encoding) === "custom",
                  Ot = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  bt = b.value.encoding ? `"${b.value.encoding}"` : "Default";
                for (const Mt in j) !ht && Ot.includes(Mt) ? J.push(new Yt(Mt, j[Mt], `In "${M}": "${Mt}" is only valid when "encoding" is set to "custom". ${bt} encoding found`)) : N[Mt] ? J = J.concat(b.validateSpec({
                  key: Mt,
                  value: j[Mt],
                  valueSpec: N[Mt],
                  validateSpec: b.validateSpec,
                  style: H,
                  styleSpec: O
                })) : J.push(new Yt(Mt, j[Mt], `unknown property "${Mt}"`));
                return J
              })({
                sourceName: n,
                value: r,
                style: i.style,
                styleSpec: a,
                validateSpec: f
              }), v;
            case "geojson":
              if (v = fo({
                  key: n,
                  value: r,
                  valueSpec: a.source_geojson,
                  style: _,
                  styleSpec: a,
                  validateSpec: f,
                  objectElementValidators: sh
                }), r.cluster)
                for (const b in r.clusterProperties) {
                  const [S, M] = r.clusterProperties[b], j = typeof S == "string" ? [S, ["accumulated"],
                    ["get", b]
                  ] : S;
                  v.push(...Ta({
                    key: `${n}.${b}.map`,
                    value: M,
                    expressionContext: "cluster-map"
                  })), v.push(...Ta({
                    key: `${n}.${b}.reduce`,
                    value: j,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return v;
            case "video":
              return fo({
                key: n,
                value: r,
                valueSpec: a.source_video,
                style: _,
                validateSpec: f,
                styleSpec: a
              });
            case "image":
              return fo({
                key: n,
                value: r,
                valueSpec: a.source_image,
                style: _,
                validateSpec: f,
                styleSpec: a
              });
            case "canvas":
              return [new Yt(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Ja({
                key: `${n}.type`,
                value: r.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function al(i) {
          const r = i.value,
            n = i.styleSpec,
            a = n.light,
            _ = i.style;
          let f = [];
          const m = Ln(r);
          if (r === void 0) return f;
          if (m !== "object") return f = f.concat([new Yt("light", r, `object expected, ${m} found`)]), f;
          for (const v in r) {
            const b = v.match(/^(.*)-transition$/);
            f = f.concat(b && a[b[1]] && a[b[1]].transition ? i.validateSpec({
              key: v,
              value: r[v],
              valueSpec: n.transition,
              validateSpec: i.validateSpec,
              style: _,
              styleSpec: n
            }) : a[v] ? i.validateSpec({
              key: v,
              value: r[v],
              valueSpec: a[v],
              validateSpec: i.validateSpec,
              style: _,
              styleSpec: n
            }) : [new Yt(v, r[v], `unknown property "${v}"`)])
          }
          return f
        }

        function Sa(i) {
          const r = i.value,
            n = i.styleSpec,
            a = n.sky,
            _ = i.style,
            f = Ln(r);
          if (r === void 0) return [];
          if (f !== "object") return [new Yt("sky", r, `object expected, ${f} found`)];
          let m = [];
          for (const v in r) m = m.concat(a[v] ? i.validateSpec({
            key: v,
            value: r[v],
            valueSpec: a[v],
            style: _,
            styleSpec: n
          }) : [new Yt(v, r[v], `unknown property "${v}"`)]);
          return m
        }

        function ah(i) {
          const r = i.value,
            n = i.styleSpec,
            a = n.terrain,
            _ = i.style;
          let f = [];
          const m = Ln(r);
          if (r === void 0) return f;
          if (m !== "object") return f = f.concat([new Yt("terrain", r, `object expected, ${m} found`)]), f;
          for (const v in r) f = f.concat(a[v] ? i.validateSpec({
            key: v,
            value: r[v],
            valueSpec: a[v],
            validateSpec: i.validateSpec,
            style: _,
            styleSpec: n
          }) : [new Yt(v, r[v], `unknown property "${v}"`)]);
          return f
        }

        function uh(i) {
          let r = [];
          const n = i.value,
            a = i.key;
          if (Array.isArray(n)) {
            const _ = [],
              f = [];
            for (const m in n) n[m].id && _.includes(n[m].id) && r.push(new Yt(a, n, `all the sprites' ids must be unique, but ${n[m].id} is duplicated`)), _.push(n[m].id), n[m].url && f.includes(n[m].url) && r.push(new Yt(a, n, `all the sprites' URLs must be unique, but ${n[m].url} is duplicated`)), f.push(n[m].url), r = r.concat(fo({
              key: `${a}[${m}]`,
              value: n[m],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: i.validateSpec
            }));
            return r
          }
          return Ms({
            key: a,
            value: n
          })
        }

        function ch(i) {
          return r = i.value, r && r.constructor === Object ? [] : [new Yt(i.key, i.value, `object expected, ${Ln(i.value)} found`)];
          var r
        }
        const lh = {
          "*": () => [],
          array: ka,
          boolean: function(i) {
            const r = i.value,
              n = i.key,
              a = Ln(r);
            return a !== "boolean" ? [new Yt(n, r, `boolean expected, ${a} found`)] : []
          },
          number: Uu,
          color: el,
          constants: Vu,
          enum: Ja,
          filter: rl,
          function: ih,
          layer: ol,
          object: fo,
          source: sl,
          light: al,
          sky: Sa,
          terrain: ah,
          projection: function(i) {
            const r = i.value,
              n = i.styleSpec,
              a = n.projection,
              _ = i.style,
              f = Ln(r);
            if (r === void 0) return [];
            if (f !== "object") return [new Yt("projection", r, `object expected, ${f} found`)];
            let m = [];
            for (const v in r) m = m.concat(a[v] ? i.validateSpec({
              key: v,
              value: r[v],
              valueSpec: a[v],
              style: _,
              styleSpec: n
            }) : [new Yt(v, r[v], `unknown property "${v}"`)]);
            return m
          },
          projectionDefinition: function(i) {
            const r = i.key;
            let n = i.value;
            n = n instanceof String ? n.valueOf() : n;
            const a = Ln(n);
            return a !== "array" || (function(_) {
              return Array.isArray(_) && _.length === 3 && typeof _[0] == "string" && typeof _[1] == "string" && typeof _[2] == "number"
            })(n) || (function(_) {
              return !!["interpolate", "step", "literal"].includes(_[0])
            })(n) ? ["array", "string"].includes(a) ? [] : [new Yt(r, n, `projection expected, invalid type "${a}" found`)] : [new Yt(r, n, `projection expected, invalid array ${JSON.stringify(n)} found`)]
          },
          string: Ms,
          formatted: function(i) {
            return Ms(i).length === 0 ? [] : Ta(i)
          },
          resolvedImage: function(i) {
            return Ms(i).length === 0 ? [] : Ta(i)
          },
          padding: function(i) {
            const r = i.key,
              n = i.value;
            if (Ln(n) === "array") {
              if (n.length < 1 || n.length > 4) return [new Yt(r, n, `padding requires 1 to 4 values; ${n.length} values found`)];
              const a = {
                type: "number"
              };
              let _ = [];
              for (let f = 0; f < n.length; f++) _ = _.concat(i.validateSpec({
                key: `${r}[${f}]`,
                value: n[f],
                validateSpec: i.validateSpec,
                valueSpec: a
              }));
              return _
            }
            return Uu({
              key: r,
              value: n,
              valueSpec: {}
            })
          },
          numberArray: function(i) {
            const r = i.key,
              n = i.value;
            if (Ln(n) === "array") {
              const a = {
                type: "number"
              };
              if (n.length < 1) return [new Yt(r, n, "array length at least 1 expected, length 0 found")];
              let _ = [];
              for (let f = 0; f < n.length; f++) _ = _.concat(i.validateSpec({
                key: `${r}[${f}]`,
                value: n[f],
                validateSpec: i.validateSpec,
                valueSpec: a
              }));
              return _
            }
            return Uu({
              key: r,
              value: n,
              valueSpec: {}
            })
          },
          colorArray: function(i) {
            const r = i.key,
              n = i.value;
            if (Ln(n) === "array") {
              if (n.length < 1) return [new Yt(r, n, "array length at least 1 expected, length 0 found")];
              let a = [];
              for (let _ = 0; _ < n.length; _++) a = a.concat(el({
                key: `${r}[${_}]`,
                value: n[_]
              }));
              return a
            }
            return el({
              key: r,
              value: n
            })
          },
          variableAnchorOffsetCollection: function(i) {
            const r = i.key,
              n = i.value,
              a = Ln(n),
              _ = i.styleSpec;
            if (a !== "array" || n.length < 1 || n.length % 2 != 0) return [new Yt(r, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let f = [];
            for (let m = 0; m < n.length; m += 2) f = f.concat(Ja({
              key: `${r}[${m}]`,
              value: n[m],
              valueSpec: _.layout_symbol["text-anchor"]
            })), f = f.concat(ka({
              key: `${r}[${m+1}]`,
              value: n[m + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: _
            }));
            return f
          },
          sprite: uh,
          state: ch
        };

        function Zu(i) {
          const r = i.value,
            n = i.valueSpec,
            a = i.styleSpec;
          return i.validateSpec = Zu, n.expression && Lu(ci(r)) ? ih(i) : n.expression && Du(us(r)) ? Ta(i) : n.type && lh[n.type] ? lh[n.type](i) : fo(je({}, i, {
            valueSpec: n.type ? a[n.type] : n
          }))
        }

        function _h(i) {
          const r = i.value,
            n = i.key,
            a = Ms(i);
          return a.length || (r.indexOf("{fontstack}") === -1 && a.push(new Yt(n, r, '"glyphs" url must include a "{fontstack}" token')), r.indexOf("{range}") === -1 && a.push(new Yt(n, r, '"glyphs" url must include a "{range}" token'))), a
        }

        function no(i, r = W) {
          let n = [];
          return n = n.concat(Zu({
            key: "",
            value: i,
            valueSpec: r.$root,
            styleSpec: r,
            style: i,
            validateSpec: Zu,
            objectElementValidators: {
              glyphs: _h,
              "*": () => []
            }
          })), i.constants && (n = n.concat(Vu({
            key: "constants",
            value: i.constants
          }))), mo(n)
        }

        function ao(i) {
          return function(r) {
            return i(Object.assign({}, r, {
              validateSpec: Zu
            }))
          }
        }

        function mo(i) {
          return [].concat(i).sort(((r, n) => r.line - n.line))
        }

        function uo(i) {
          return function(...r) {
            return mo(i.apply(this, r))
          }
        }
        no.source = uo(ao(sl)), no.sprite = uo(ao(uh)), no.glyphs = uo(ao(_h)), no.light = uo(ao(al)), no.sky = uo(ao(Sa)), no.terrain = uo(ao(ah)), no.state = uo(ao(ch)), no.layer = uo(ao(ol)), no.filter = uo(ao(rl)), no.paintProperty = uo(ao(Qa)), no.layoutProperty = uo(ao(oh));
        const hh = W,
          Pa = no,
          $d = Pa.light,
          tu = Pa.sky,
          dh = Pa.paintProperty,
          ul = Pa.layoutProperty;

        function ph(i, r) {
          let n = !1;
          if (r && r.length)
            for (const a of r) i.fire(new mt(new Error(a.message))), n = !0;
          return n
        }
        class Ws {
          constructor(r, n, a) {
            const _ = this.cells = [];
            if (r instanceof ArrayBuffer) {
              this.arrayBuffer = r;
              const m = new Int32Array(this.arrayBuffer);
              r = m[0], this.d = (n = m[1]) + 2 * (a = m[2]);
              for (let b = 0; b < this.d * this.d; b++) {
                const S = m[3 + b],
                  M = m[3 + b + 1];
                _.push(S === M ? null : m.subarray(S, M))
              }
              const v = m[3 + _.length + 1];
              this.keys = m.subarray(m[3 + _.length], v), this.bboxes = m.subarray(v), this.insert = this._insertReadonly
            } else {
              this.d = n + 2 * a;
              for (let m = 0; m < this.d * this.d; m++) _.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = n, this.extent = r, this.padding = a, this.scale = n / r, this.uid = 0;
            const f = a / n * r;
            this.min = -f, this.max = r + f
          }
          insert(r, n, a, _, f) {
            this._forEachCell(n, a, _, f, this._insertCell, this.uid++, void 0, void 0), this.keys.push(r), this.bboxes.push(n), this.bboxes.push(a), this.bboxes.push(_), this.bboxes.push(f)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(r, n, a, _, f, m) {
            this.cells[f].push(m)
          }
          query(r, n, a, _, f) {
            const m = this.min,
              v = this.max;
            if (r <= m && n <= m && v <= a && v <= _ && !f) return Array.prototype.slice.call(this.keys);
            {
              const b = [];
              return this._forEachCell(r, n, a, _, this._queryCell, b, {}, f), b
            }
          }
          _queryCell(r, n, a, _, f, m, v, b) {
            const S = this.cells[f];
            if (S !== null) {
              const M = this.keys,
                j = this.bboxes;
              for (let O = 0; O < S.length; O++) {
                const N = S[O];
                if (v[N] === void 0) {
                  const H = 4 * N;
                  (b ? b(j[H + 0], j[H + 1], j[H + 2], j[H + 3]) : r <= j[H + 2] && n <= j[H + 3] && a >= j[H + 0] && _ >= j[H + 1]) ? (v[N] = !0, m.push(M[N])) : v[N] = !1
                }
              }
            }
          }
          _forEachCell(r, n, a, _, f, m, v, b) {
            const S = this._convertToCellCoord(r),
              M = this._convertToCellCoord(n),
              j = this._convertToCellCoord(a),
              O = this._convertToCellCoord(_);
            for (let N = S; N <= j; N++)
              for (let H = M; H <= O; H++) {
                const J = this.d * H + N;
                if ((!b || b(this._convertFromCellCoord(N), this._convertFromCellCoord(H), this._convertFromCellCoord(N + 1), this._convertFromCellCoord(H + 1))) && f.call(this, r, n, a, _, J, m, v, b)) return
              }
          }
          _convertFromCellCoord(r) {
            return (r - this.padding) / this.scale
          }
          _convertToCellCoord(r) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(r * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const r = this.cells,
              n = 3 + this.cells.length + 1 + 1;
            let a = 0;
            for (let m = 0; m < this.cells.length; m++) a += this.cells[m].length;
            const _ = new Int32Array(n + a + this.keys.length + this.bboxes.length);
            _[0] = this.extent, _[1] = this.n, _[2] = this.padding;
            let f = n;
            for (let m = 0; m < r.length; m++) {
              const v = r[m];
              _[3 + m] = f, _.set(v, f), f += v.length
            }
            return _[3 + r.length] = f, _.set(this.keys, f), f += this.keys.length, _[3 + r.length + 1] = f, _.set(this.bboxes, f), f += this.bboxes.length, _.buffer
          }
          static serialize(r, n) {
            const a = r.toArrayBuffer();
            return n && n.push(a), {
              buffer: a
            }
          }
          static deserialize(r) {
            return new Ws(r.buffer)
          }
        }
        const cs = {};

        function Sr(i, r, n = {}) {
          if (cs[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(r, "_classRegistryKey", {
            value: i,
            writeable: !1
          }), cs[i] = {
            klass: r,
            omit: n.omit || [],
            shallow: n.shallow || []
          }
        }
        Sr("Object", Object), Sr("Set", Set), Sr("TransferableGridIndex", Ws), Sr("Color", Ur), Sr("Error", Error), Sr("AJAXError", nt), Sr("ResolvedImage", ki), Sr("StylePropertyFunction", Ru), Sr("StyleExpression", Kc, {
          omit: ["_evaluator"]
        }), Sr("ZoomDependentExpression", Jc), Sr("ZoomConstantExpression", Xa), Sr("CompoundExpression", Ro, {
          omit: ["_evaluate"]
        });
        for (const i in ba) ba[i]._classRegistryKey || Sr(`Expression_${i}`, ba[i]);

        function fh(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
        }

        function cl(i) {
          return i.$name || i.constructor._classRegistryKey
        }

        function mh(i) {
          return !(function(r) {
            if (r === null || typeof r != "object") return !1;
            const n = cl(r);
            return !(!n || n === "Object")
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || fh(i) || de(i) || ArrayBuffer.isView(i) || i instanceof ImageData)
        }

        function ls(i, r) {
          if (mh(i)) return (fh(i) || de(i)) && r && r.push(i), ArrayBuffer.isView(i) && r && r.push(i.buffer), i instanceof ImageData && r && r.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const f = [];
            for (const m of i) f.push(ls(m, r));
            return f
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const n = cl(i);
          if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!cs[n]) throw new Error(`${n} is not registered.`);
          const {
            klass: a
          } = cs[n], _ = a.serialize ? a.serialize(i, r) : {};
          if (a.serialize) {
            if (r && _ === r[r.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const f in i) {
              if (!i.hasOwnProperty(f) || cs[n].omit.indexOf(f) >= 0) continue;
              const m = i[f];
              _[f] = cs[n].shallow.indexOf(f) >= 0 ? m : ls(m, r)
            }
            i instanceof Error && (_.message = i.message)
          }
          if (_.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (_.$name = n), _
        }

        function eu(i) {
          if (mh(i)) return i;
          if (Array.isArray(i)) return i.map(eu);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const r = cl(i) || "Object";
          if (!cs[r]) throw new Error(`can't deserialize unregistered class ${r}`);
          const {
            klass: n
          } = cs[r];
          if (!n) throw new Error(`can't deserialize unregistered class ${r}`);
          if (n.deserialize) return n.deserialize(i);
          const a = Object.create(n.prototype);
          for (const _ of Object.keys(i)) {
            if (_ === "$name") continue;
            const f = i[_];
            a[_] = cs[r].shallow.indexOf(_) >= 0 ? f : eu(f)
          }
          return a
        }
        class ll {
          constructor() {
            this.first = !0
          }
          update(r, n) {
            const a = Math.floor(r);
            return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = r, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = n), r !== this.lastZoom && (this.lastZoom = r, this.lastFloorZoom = a, !0))
          }
        }
        const zn = {
          "Latin-1 Supplement": i => i >= 128 && i <= 255,
          "Hangul Jamo": i => i >= 4352 && i <= 4607,
          Khmer: i => i >= 6016 && i <= 6143,
          "General Punctuation": i => i >= 8192 && i <= 8303,
          "Letterlike Symbols": i => i >= 8448 && i <= 8527,
          "Number Forms": i => i >= 8528 && i <= 8591,
          "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
          "Control Pictures": i => i >= 9216 && i <= 9279,
          "Optical Character Recognition": i => i >= 9280 && i <= 9311,
          "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
          "Geometric Shapes": i => i >= 9632 && i <= 9727,
          "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
          "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
          "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
          "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
          Hiragana: i => i >= 12352 && i <= 12447,
          Katakana: i => i >= 12448 && i <= 12543,
          Kanbun: i => i >= 12688 && i <= 12703,
          "CJK Strokes": i => i >= 12736 && i <= 12783,
          "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
          "CJK Compatibility": i => i >= 13056 && i <= 13311,
          "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
          "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
          "Hangul Syllables": i => i >= 44032 && i <= 55215,
          "Private Use Area": i => i >= 57344 && i <= 63743,
          "Vertical Forms": i => i >= 65040 && i <= 65055,
          "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
          "Small Form Variants": i => i >= 65104 && i <= 65135,
          "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
        };

        function _l(i) {
          for (const r of i)
            if (Gu(r.charCodeAt(0))) return !0;
          return !1
        }

        function hl(i) {
          for (const r of i)
            if (!yh(r.charCodeAt(0))) return !1;
          return !0
        }

        function Ma(i) {
          const r = i.map((n => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source
            } catch {
              return null
            }
          })).filter((n => n));
          return new RegExp(r.join("|"), "u")
        }
        const gh = Ma(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function yh(i) {
          return !gh.test(String.fromCodePoint(i))
        }
        const dl = Ma(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function Gu(i) {
          return !(i !== 746 && i !== 747 && (i < 4352 || !(zn["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || zn["CJK Compatibility"](i) || zn["CJK Strokes"](i) || !(!zn["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || zn["Enclosed CJK Letters and Months"](i) || zn["Ideographic Description Characters"](i) || zn.Kanbun(i) || zn.Katakana(i) && i !== 12540 || !(!zn["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!zn["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || zn["Vertical Forms"](i) || zn["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || dl.test(String.fromCodePoint(i)))))
        }

        function Hu(i) {
          return !(Gu(i) || (function(r) {
            return !!(zn["Latin-1 Supplement"](r) && (r === 167 || r === 169 || r === 174 || r === 177 || r === 188 || r === 189 || r === 190 || r === 215 || r === 247) || zn["General Punctuation"](r) && (r === 8214 || r === 8224 || r === 8225 || r === 8240 || r === 8241 || r === 8251 || r === 8252 || r === 8258 || r === 8263 || r === 8264 || r === 8265 || r === 8273) || zn["Letterlike Symbols"](r) || zn["Number Forms"](r) || zn["Miscellaneous Technical"](r) && (r >= 8960 && r <= 8967 || r >= 8972 && r <= 8991 || r >= 8996 && r <= 9e3 || r === 9003 || r >= 9085 && r <= 9114 || r >= 9150 && r <= 9165 || r === 9167 || r >= 9169 && r <= 9179 || r >= 9186 && r <= 9215) || zn["Control Pictures"](r) && r !== 9251 || zn["Optical Character Recognition"](r) || zn["Enclosed Alphanumerics"](r) || zn["Geometric Shapes"](r) || zn["Miscellaneous Symbols"](r) && !(r >= 9754 && r <= 9759) || zn["Miscellaneous Symbols and Arrows"](r) && (r >= 11026 && r <= 11055 || r >= 11088 && r <= 11097 || r >= 11192 && r <= 11243) || zn["CJK Symbols and Punctuation"](r) || zn.Katakana(r) || zn["Private Use Area"](r) || zn["CJK Compatibility Forms"](r) || zn["Small Form Variants"](r) || zn["Halfwidth and Fullwidth Forms"](r) || r === 8734 || r === 8756 || r === 8757 || r >= 9984 && r <= 10087 || r >= 10102 && r <= 10131 || r === 65532 || r === 65533)
          })(i))
        }
        const vh = Ma(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function bh(i) {
          return vh.test(String.fromCodePoint(i))
        }

        function xh(i, r) {
          return !(!r && bh(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || zn.Khmer(i))
        }

        function Xd(i) {
          for (const r of i)
            if (bh(r.charCodeAt(0))) return !0;
          return !1
        }
        const _s = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(i) {
            if (_s.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(i, r) {
            return c(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const n = i.pluginURL,
                a = new Promise((f => {
                  this.loadScriptResolve = f
                }));
              r(n);
              const _ = new Promise((f => setTimeout((() => f()), this.TIMEOUT)));
              if (yield Promise.race([a, _]), this.isParsed()) {
                const f = {
                  pluginStatus: "loaded",
                  pluginURL: n
                };
                return this.setState(f), f
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${n}`)
            }))
          }
        };
        class Kn {
          constructor(r, n) {
            this.isSupportedScript = wh, this.zoom = r, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new ll, this.transition = n.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ll, this.transition = {})
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const r = this.zoom,
              n = r - Math.floor(r),
              a = this.crossFadingFactor();
            return r > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: n + (1 - n) * a
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - a) * n
            }
          }
        }

        function wh(i) {
          return (function(r, n) {
            for (const a of r)
              if (!xh(a.charCodeAt(0), n)) return !1;
            return !0
          })(i, _s.getRTLTextPluginStatus() === "loaded")
        }
        class ru {
          constructor(r, n, a) {
            this.property = r, this.value = n, this.expression = (function(_, f, m) {
              if (Lu(_)) return new Ru(_, f);
              if (Du(_)) {
                const v = Q_(_, f, m);
                if (v.result === "error") throw new Error(v.value.map((b => `${b.key}: ${b.message}`)).join(", "));
                return v.value
              } {
                let v = _;
                return f.type === "color" && typeof _ == "string" ? v = Ur.parse(_) : f.type !== "padding" || typeof _ != "number" && !Array.isArray(_) ? f.type !== "numberArray" || typeof _ != "number" && !Array.isArray(_) ? f.type !== "colorArray" || typeof _ != "string" && !Array.isArray(_) ? f.type === "variableAnchorOffsetCollection" && Array.isArray(_) ? v = Wn.parse(_) : f.type === "projectionDefinition" && typeof _ == "string" && (v = yi.parse(_)) : v = bn.parse(_) : v = Vn.parse(_) : v = Bn.parse(_), {
                  globalStateRefs: new Set,
                  _globalState: null,
                  kind: "constant",
                  evaluate: () => v
                }
              }
            })(n === void 0 ? r.specification.default : n, r.specification, a)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(r, n, a) {
            return this.property.possiblyEvaluate(this, r, n, a)
          }
        }
        class pl {
          constructor(r, n) {
            this.property = r, this.value = new ru(r, void 0, n)
          }
          transitioned(r, n) {
            return new fl(this.property, this.value, n, se({}, r.transition, this.transition), r.now)
          }
          untransitioned() {
            return new fl(this.property, this.value, null, {}, 0)
          }
        }
        class kh {
          constructor(r, n) {
            this._properties = r, this._values = Object.create(r.defaultTransitionablePropertyValues), this._globalState = n
          }
          getValue(r) {
            return ve(this._values[r].value.value)
          }
          setValue(r, n) {
            Object.prototype.hasOwnProperty.call(this._values, r) || (this._values[r] = new pl(this._values[r].property, this._globalState)), this._values[r].value = new ru(this._values[r].property, n === null ? void 0 : ve(n), this._globalState)
          }
          getTransition(r) {
            return ve(this._values[r].transition)
          }
          setTransition(r, n) {
            Object.prototype.hasOwnProperty.call(this._values, r) || (this._values[r] = new pl(this._values[r].property, this._globalState)), this._values[r].transition = ve(n) || void 0
          }
          serialize() {
            const r = {};
            for (const n of Object.keys(this._values)) {
              const a = this.getValue(n);
              a !== void 0 && (r[n] = a);
              const _ = this.getTransition(n);
              _ !== void 0 && (r[`${n}-transition`] = _)
            }
            return r
          }
          transitioned(r, n) {
            const a = new ml(this._properties);
            for (const _ of Object.keys(this._values)) a._values[_] = this._values[_].transitioned(r, n._values[_]);
            return a
          }
          untransitioned() {
            const r = new ml(this._properties);
            for (const n of Object.keys(this._values)) r._values[n] = this._values[n].untransitioned();
            return r
          }
        }
        class fl {
          constructor(r, n, a, _, f) {
            this.property = r, this.value = n, this.begin = f + _.delay || 0, this.end = this.begin + _.duration || 0, r.specification.transition && (_.delay || _.duration) && (this.prior = a)
          }
          possiblyEvaluate(r, n, a) {
            const _ = r.now || 0,
              f = this.value.possiblyEvaluate(r, n, a),
              m = this.prior;
            if (m) {
              if (_ > this.end) return this.prior = null, f;
              if (this.value.isDataDriven()) return this.prior = null, f;
              if (_ < this.begin) return m.possiblyEvaluate(r, n, a);
              {
                const v = (_ - this.begin) / (this.end - this.begin);
                return this.property.interpolate(m.possiblyEvaluate(r, n, a), f, Ae(v))
              }
            }
            return f
          }
        }
        class ml {
          constructor(r) {
            this._properties = r, this._values = Object.create(r.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(r, n, a) {
            const _ = new $s(this._properties);
            for (const f of Object.keys(this._values)) _._values[f] = this._values[f].possiblyEvaluate(r, n, a);
            return _
          }
          hasTransition() {
            for (const r of Object.keys(this._values))
              if (this._values[r].prior) return !0;
            return !1
          }
        }
        class Th {
          constructor(r, n) {
            this._properties = r, this._values = Object.create(r.defaultPropertyValues), this._globalState = n
          }
          hasValue(r) {
            return this._values[r].value !== void 0
          }
          getValue(r) {
            return ve(this._values[r].value)
          }
          setValue(r, n) {
            this._values[r] = new ru(this._values[r].property, n === null ? void 0 : ve(n), this._globalState)
          }
          serialize() {
            const r = {};
            for (const n of Object.keys(this._values)) {
              const a = this.getValue(n);
              a !== void 0 && (r[n] = a)
            }
            return r
          }
          possiblyEvaluate(r, n, a) {
            const _ = new $s(this._properties);
            for (const f of Object.keys(this._values)) _._values[f] = this._values[f].possiblyEvaluate(r, n, a);
            return _
          }
        }
        class Vo {
          constructor(r, n, a) {
            this.property = r, this.value = n, this.parameters = a
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(r) {
            return this.value.kind === "constant" ? this.value.value : r
          }
          evaluate(r, n, a, _) {
            return this.property.evaluate(this.value, this.parameters, r, n, a, _)
          }
        }
        class $s {
          constructor(r) {
            this._properties = r, this._values = Object.create(r.defaultPossiblyEvaluatedValues)
          }
          get(r) {
            return this._values[r]
          }
        }
        class Xr {
          constructor(r) {
            this.specification = r
          }
          possiblyEvaluate(r, n) {
            if (r.isDataDriven()) throw new Error("Value should not be data driven");
            return r.expression.evaluate(n)
          }
          interpolate(r, n, a) {
            const _ = Do[this.specification.type];
            return _ ? _(r, n, a) : r
          }
        }
        class nn {
          constructor(r, n) {
            this.specification = r, this.overrides = n
          }
          possiblyEvaluate(r, n, a, _) {
            return new Vo(this, r.expression.kind === "constant" || r.expression.kind === "camera" ? {
              kind: "constant",
              value: r.expression.evaluate(n, null, {}, a, _)
            } : r.expression, n)
          }
          interpolate(r, n, a) {
            if (r.value.kind !== "constant" || n.value.kind !== "constant") return r;
            if (r.value.value === void 0 || n.value.value === void 0) return new Vo(this, {
              kind: "constant",
              value: void 0
            }, r.parameters);
            const _ = Do[this.specification.type];
            if (_) {
              const f = _(r.value.value, n.value.value, a);
              return new Vo(this, {
                kind: "constant",
                value: f
              }, r.parameters)
            }
            return r
          }
          evaluate(r, n, a, _, f, m) {
            return r.kind === "constant" ? r.value : r.evaluate(n, a, _, f, m)
          }
        }
        class nu extends nn {
          possiblyEvaluate(r, n, a, _) {
            if (r.value === void 0) return new Vo(this, {
              kind: "constant",
              value: void 0
            }, n);
            if (r.expression.kind === "constant") {
              const f = r.expression.evaluate(n, null, {}, a, _),
                m = r.property.specification.type === "resolvedImage" && typeof f != "string" ? f.name : f,
                v = this._calculate(m, m, m, n);
              return new Vo(this, {
                kind: "constant",
                value: v
              }, n)
            }
            if (r.expression.kind === "camera") {
              const f = this._calculate(r.expression.evaluate({
                zoom: n.zoom - 1
              }), r.expression.evaluate({
                zoom: n.zoom
              }), r.expression.evaluate({
                zoom: n.zoom + 1
              }), n);
              return new Vo(this, {
                kind: "constant",
                value: f
              }, n)
            }
            return new Vo(this, r.expression, n)
          }
          evaluate(r, n, a, _, f, m) {
            if (r.kind === "source") {
              const v = r.evaluate(n, a, _, f, m);
              return this._calculate(v, v, v, n)
            }
            return r.kind === "composite" ? this._calculate(r.evaluate({
              zoom: Math.floor(n.zoom) - 1
            }, a, _), r.evaluate({
              zoom: Math.floor(n.zoom)
            }, a, _), r.evaluate({
              zoom: Math.floor(n.zoom) + 1
            }, a, _), n) : r.value
          }
          _calculate(r, n, a, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? {
              from: r,
              to: n
            } : {
              from: a,
              to: n
            }
          }
          interpolate(r) {
            return r
          }
        }
        class Sh {
          constructor(r) {
            this.specification = r
          }
          possiblyEvaluate(r, n, a, _) {
            if (r.value !== void 0) {
              if (r.expression.kind === "constant") {
                const f = r.expression.evaluate(n, null, {}, a, _);
                return this._calculate(f, f, f, n)
              }
              return this._calculate(r.expression.evaluate(new Kn(Math.floor(n.zoom - 1), n)), r.expression.evaluate(new Kn(Math.floor(n.zoom), n)), r.expression.evaluate(new Kn(Math.floor(n.zoom + 1), n)), n)
            }
          }
          _calculate(r, n, a, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? {
              from: r,
              to: n
            } : {
              from: a,
              to: n
            }
          }
          interpolate(r) {
            return r
          }
        }
        class iu {
          constructor(r) {
            this.specification = r
          }
          possiblyEvaluate(r, n, a, _) {
            return !!r.expression.evaluate(n, null, {}, a, _)
          }
          interpolate() {
            return !1
          }
        }
        class io {
          constructor(r) {
            this.properties = r, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in r) {
              const a = r[n];
              a.specification.overridable && this.overridableProperties.push(n);
              const _ = this.defaultPropertyValues[n] = new ru(a, void 0, void 0),
                f = this.defaultTransitionablePropertyValues[n] = new pl(a, void 0);
              this.defaultTransitioningPropertyValues[n] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = _.possiblyEvaluate({})
            }
          }
        }
        Sr("DataDrivenProperty", nn), Sr("DataConstantProperty", Xr), Sr("CrossFadedDataDrivenProperty", nu), Sr("CrossFadedProperty", Sh), Sr("ColorRampProperty", iu);
        const gl = "-transition";
        class Uo extends et {
          constructor(r, n, a) {
            if (super(), this.id = r.id, this.type = r.type, this._globalState = a, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, r.type !== "custom" && (this.metadata = r.metadata, this.minzoom = r.minzoom, this.maxzoom = r.maxzoom, r.type !== "background" && (this.source = r.source, this.sourceLayer = r["source-layer"], this.filter = r.filter, this._featureFilter = Ya(r.filter, a)), n.layout && (this._unevaluatedLayout = new Th(n.layout, a)), n.paint)) {
              this._transitionablePaint = new kh(n.paint, a);
              for (const _ in r.paint) this.setPaintProperty(_, r.paint[_], {
                validate: !1
              });
              for (const _ in r.layout) this.setLayoutProperty(_, r.layout[_], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new $s(n.paint)
            }
          }
          setFilter(r) {
            this.filter = r, this._featureFilter = Ya(r, this._globalState)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(r) {
            return r === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(r)
          }
          getLayoutAffectingGlobalStateRefs() {
            const r = new Set;
            if (this._unevaluatedLayout)
              for (const n in this._unevaluatedLayout._values) {
                const a = this._unevaluatedLayout._values[n];
                for (const _ of a.getGlobalStateRefs()) r.add(_)
              }
            for (const n of this._featureFilter.getGlobalStateRefs()) r.add(n);
            return r
          }
          getPaintAffectingGlobalStateRefs() {
            var r;
            const n = new globalThis.Map;
            if (this._transitionablePaint)
              for (const a in this._transitionablePaint._values) {
                const _ = this._transitionablePaint._values[a].value;
                for (const f of _.getGlobalStateRefs()) {
                  const m = (r = n.get(f)) !== null && r !== void 0 ? r : [];
                  m.push({
                    name: a,
                    value: _.value
                  }), n.set(f, m)
                }
              }
            return n
          }
          setLayoutProperty(r, n, a = {}) {
            n != null && this._validate(ul, `layers.${this.id}.layout.${r}`, r, n, a) || (r !== "visibility" ? this._unevaluatedLayout.setValue(r, n) : this.visibility = n)
          }
          getPaintProperty(r) {
            return r.endsWith(gl) ? this._transitionablePaint.getTransition(r.slice(0, -11)) : this._transitionablePaint.getValue(r)
          }
          setPaintProperty(r, n, a = {}) {
            if (n != null && this._validate(dh, `layers.${this.id}.paint.${r}`, r, n, a)) return !1;
            if (r.endsWith(gl)) return this._transitionablePaint.setTransition(r.slice(0, -11), n || void 0), !1;
            {
              const _ = this._transitionablePaint._values[r],
                f = _.property.specification["property-type"] === "cross-faded-data-driven",
                m = _.value.isDataDriven(),
                v = _.value;
              this._transitionablePaint.setValue(r, n), this._handleSpecialPaintPropertyUpdate(r);
              const b = this._transitionablePaint._values[r].value;
              return b.isDataDriven() || m || f || this._handleOverridablePaintPropertyUpdate(r, v, b)
            }
          }
          _handleSpecialPaintPropertyUpdate(r) {}
          _handleOverridablePaintPropertyUpdate(r, n, a) {
            return !1
          }
          isHidden(r, n = !1) {
            return !!(this.minzoom && r < (n ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && r >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(r) {
            this._transitioningPaint = this._transitionablePaint.transitioned(r, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(r, n) {
            r.getCrossfadeParameters && (this._crossfadeParameters = r.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(r, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(r, void 0, n)
          }
          serialize() {
            const r = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (r.layout = r.layout || {}, r.layout.visibility = this.visibility), Ke(r, ((n, a) => !(n === void 0 || a === "layout" && !Object.keys(n).length || a === "paint" && !Object.keys(n).length)))
          }
          _validate(r, n, a, _, f = {}) {
            return (!f || f.validate !== !1) && ph(this, r.call(Pa, {
              key: n,
              layerType: this.type,
              objectKey: a,
              value: _,
              styleSpec: W,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const r in this.paint._values) {
              const n = this.paint.get(r);
              if (n instanceof Vo && wa(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0
            }
            return !1
          }
        }
        let Ph;
        var Yd = {
          get paint() {
            return Ph = Ph || new io({
              "raster-opacity": new Xr(W.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new Xr(W.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new Xr(W.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new Xr(W.paint_raster["raster-brightness-max"]),
              "raster-saturation": new Xr(W.paint_raster["raster-saturation"]),
              "raster-contrast": new Xr(W.paint_raster["raster-contrast"]),
              "raster-resampling": new Xr(W.paint_raster["raster-resampling"]),
              "raster-fade-duration": new Xr(W.paint_raster["raster-fade-duration"])
            })
          }
        };
        class Kd extends Uo {
          constructor(r, n) {
            super(r, Yd, n)
          }
        }
        const Jd = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class es {
          constructor(r, n) {
            this._structArray = r, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class li {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(r, n) {
            return r._trim(), n && (r.isTransferred = !0, n.push(r.arrayBuffer)), {
              length: r.length,
              arrayBuffer: r.arrayBuffer
            }
          }
          static deserialize(r) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = r.arrayBuffer, n.length = r.length, n.capacity = r.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(r) {
            this.reserve(r), this.length = r
          }
          reserve(r) {
            if (r > this.capacity) {
              this.capacity = Math.max(r, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function bi(i, r = 1) {
          let n = 0,
            a = 0;
          return {
            members: i.map((_ => {
              const f = Jd[_.type].BYTES_PER_ELEMENT,
                m = n = Mh(n, Math.max(r, f)),
                v = _.components || 1;
              return a = Math.max(a, f), n += f * v, {
                name: _.name,
                type: _.type,
                components: v,
                offset: m
              }
            })),
            size: Mh(n, Math.max(a, r)),
            alignment: r
          }
        }

        function Mh(i, r) {
          return Math.ceil(i / r) * r
        }
        class Ca extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, r, n)
          }
          emplace(r, n, a) {
            const _ = 2 * r;
            return this.int16[_ + 0] = n, this.int16[_ + 1] = a, r
          }
        }
        Ca.prototype.bytesPerElement = 4, Sr("StructArrayLayout2i4", Ca);
        class Wu extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, r, n, a)
          }
          emplace(r, n, a, _) {
            const f = 3 * r;
            return this.int16[f + 0] = n, this.int16[f + 1] = a, this.int16[f + 2] = _, r
          }
        }
        Wu.prototype.bytesPerElement = 6, Sr("StructArrayLayout3i6", Wu);
        class yl extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, r, n, a, _)
          }
          emplace(r, n, a, _, f) {
            const m = 4 * r;
            return this.int16[m + 0] = n, this.int16[m + 1] = a, this.int16[m + 2] = _, this.int16[m + 3] = f, r
          }
        }
        yl.prototype.bytesPerElement = 8, Sr("StructArrayLayout4i8", yl);
        class hs extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, r, n, a, _, f, m)
          }
          emplace(r, n, a, _, f, m, v) {
            const b = 6 * r;
            return this.int16[b + 0] = n, this.int16[b + 1] = a, this.int16[b + 2] = _, this.int16[b + 3] = f, this.int16[b + 4] = m, this.int16[b + 5] = v, r
          }
        }
        hs.prototype.bytesPerElement = 12, Sr("StructArrayLayout2i4i12", hs);
        class $u extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, r, n, a, _, f, m)
          }
          emplace(r, n, a, _, f, m, v) {
            const b = 4 * r,
              S = 8 * r;
            return this.int16[b + 0] = n, this.int16[b + 1] = a, this.uint8[S + 4] = _, this.uint8[S + 5] = f, this.uint8[S + 6] = m, this.uint8[S + 7] = v, r
          }
        }
        $u.prototype.bytesPerElement = 8, Sr("StructArrayLayout2i4ub8", $u);
        class Xs extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(r, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, r, n)
          }
          emplace(r, n, a) {
            const _ = 2 * r;
            return this.float32[_ + 0] = n, this.float32[_ + 1] = a, r
          }
        }
        Xs.prototype.bytesPerElement = 8, Sr("StructArrayLayout2f8", Xs);
        class Xu extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m, v, b, S, M) {
            const j = this.length;
            return this.resize(j + 1), this.emplace(j, r, n, a, _, f, m, v, b, S, M)
          }
          emplace(r, n, a, _, f, m, v, b, S, M, j) {
            const O = 10 * r;
            return this.uint16[O + 0] = n, this.uint16[O + 1] = a, this.uint16[O + 2] = _, this.uint16[O + 3] = f, this.uint16[O + 4] = m, this.uint16[O + 5] = v, this.uint16[O + 6] = b, this.uint16[O + 7] = S, this.uint16[O + 8] = M, this.uint16[O + 9] = j, r
          }
        }
        Xu.prototype.bytesPerElement = 20, Sr("StructArrayLayout10ui20", Xu);
        class ou extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m, v, b) {
            const S = this.length;
            return this.resize(S + 1), this.emplace(S, r, n, a, _, f, m, v, b)
          }
          emplace(r, n, a, _, f, m, v, b, S) {
            const M = 8 * r;
            return this.uint16[M + 0] = n, this.uint16[M + 1] = a, this.uint16[M + 2] = _, this.uint16[M + 3] = f, this.uint16[M + 4] = m, this.uint16[M + 5] = v, this.uint16[M + 6] = b, this.uint16[M + 7] = S, r
          }
        }
        ou.prototype.bytesPerElement = 16, Sr("StructArrayLayout8ui16", ou);
        class vl extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m, v, b, S, M, j, O) {
            const N = this.length;
            return this.resize(N + 1), this.emplace(N, r, n, a, _, f, m, v, b, S, M, j, O)
          }
          emplace(r, n, a, _, f, m, v, b, S, M, j, O, N) {
            const H = 12 * r;
            return this.int16[H + 0] = n, this.int16[H + 1] = a, this.int16[H + 2] = _, this.int16[H + 3] = f, this.uint16[H + 4] = m, this.uint16[H + 5] = v, this.uint16[H + 6] = b, this.uint16[H + 7] = S, this.int16[H + 8] = M, this.int16[H + 9] = j, this.int16[H + 10] = O, this.int16[H + 11] = N, r
          }
        }
        vl.prototype.bytesPerElement = 24, Sr("StructArrayLayout4i4ui4i24", vl);
        class Ia extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, r, n, a)
          }
          emplace(r, n, a, _) {
            const f = 3 * r;
            return this.float32[f + 0] = n, this.float32[f + 1] = a, this.float32[f + 2] = _, r
          }
        }
        Ia.prototype.bytesPerElement = 12, Sr("StructArrayLayout3f12", Ia);
        class Ys extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, r)
          }
          emplace(r, n) {
            return this.uint32[1 * r + 0] = n, r
          }
        }
        Ys.prototype.bytesPerElement = 4, Sr("StructArrayLayout1ul4", Ys);
        class bl extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m, v, b, S) {
            const M = this.length;
            return this.resize(M + 1), this.emplace(M, r, n, a, _, f, m, v, b, S)
          }
          emplace(r, n, a, _, f, m, v, b, S, M) {
            const j = 10 * r,
              O = 5 * r;
            return this.int16[j + 0] = n, this.int16[j + 1] = a, this.int16[j + 2] = _, this.int16[j + 3] = f, this.int16[j + 4] = m, this.int16[j + 5] = v, this.uint32[O + 3] = b, this.uint16[j + 8] = S, this.uint16[j + 9] = M, r
          }
        }
        bl.prototype.bytesPerElement = 20, Sr("StructArrayLayout6i1ul2ui20", bl);
        class Yu extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, r, n, a, _, f, m)
          }
          emplace(r, n, a, _, f, m, v) {
            const b = 6 * r;
            return this.int16[b + 0] = n, this.int16[b + 1] = a, this.int16[b + 2] = _, this.int16[b + 3] = f, this.int16[b + 4] = m, this.int16[b + 5] = v, r
          }
        }
        Yu.prototype.bytesPerElement = 12, Sr("StructArrayLayout2i2i2i12", Yu);
        class Ks extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, r, n, a, _, f)
          }
          emplace(r, n, a, _, f, m) {
            const v = 4 * r,
              b = 8 * r;
            return this.float32[v + 0] = n, this.float32[v + 1] = a, this.float32[v + 2] = _, this.int16[b + 6] = f, this.int16[b + 7] = m, r
          }
        }
        Ks.prototype.bytesPerElement = 16, Sr("StructArrayLayout2f1f2i16", Ks);
        class xl extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, r, n, a, _, f, m)
          }
          emplace(r, n, a, _, f, m, v) {
            const b = 16 * r,
              S = 4 * r,
              M = 8 * r;
            return this.uint8[b + 0] = n, this.uint8[b + 1] = a, this.float32[S + 1] = _, this.float32[S + 2] = f, this.int16[M + 6] = m, this.int16[M + 7] = v, r
          }
        }
        xl.prototype.bytesPerElement = 16, Sr("StructArrayLayout2ub2f2i16", xl);
        class Ku extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, r, n, a)
          }
          emplace(r, n, a, _) {
            const f = 3 * r;
            return this.uint16[f + 0] = n, this.uint16[f + 1] = a, this.uint16[f + 2] = _, r
          }
        }
        Ku.prototype.bytesPerElement = 6, Sr("StructArrayLayout3ui6", Ku);
        class Ju extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m, v, b, S, M, j, O, N, H, J, rt, ht) {
            const Ot = this.length;
            return this.resize(Ot + 1), this.emplace(Ot, r, n, a, _, f, m, v, b, S, M, j, O, N, H, J, rt, ht)
          }
          emplace(r, n, a, _, f, m, v, b, S, M, j, O, N, H, J, rt, ht, Ot) {
            const bt = 24 * r,
              Mt = 12 * r,
              te = 48 * r;
            return this.int16[bt + 0] = n, this.int16[bt + 1] = a, this.uint16[bt + 2] = _, this.uint16[bt + 3] = f, this.uint32[Mt + 2] = m, this.uint32[Mt + 3] = v, this.uint32[Mt + 4] = b, this.uint16[bt + 10] = S, this.uint16[bt + 11] = M, this.uint16[bt + 12] = j, this.float32[Mt + 7] = O, this.float32[Mt + 8] = N, this.uint8[te + 36] = H, this.uint8[te + 37] = J, this.uint8[te + 38] = rt, this.uint32[Mt + 10] = ht, this.int16[bt + 22] = Ot, r
          }
        }
        Ju.prototype.bytesPerElement = 48, Sr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ju);
        class wl extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _, f, m, v, b, S, M, j, O, N, H, J, rt, ht, Ot, bt, Mt, te, le, Re, br, ar, yr, Yr, fr) {
            const vr = this.length;
            return this.resize(vr + 1), this.emplace(vr, r, n, a, _, f, m, v, b, S, M, j, O, N, H, J, rt, ht, Ot, bt, Mt, te, le, Re, br, ar, yr, Yr, fr)
          }
          emplace(r, n, a, _, f, m, v, b, S, M, j, O, N, H, J, rt, ht, Ot, bt, Mt, te, le, Re, br, ar, yr, Yr, fr, vr) {
            const ke = 32 * r,
              an = 16 * r;
            return this.int16[ke + 0] = n, this.int16[ke + 1] = a, this.int16[ke + 2] = _, this.int16[ke + 3] = f, this.int16[ke + 4] = m, this.int16[ke + 5] = v, this.int16[ke + 6] = b, this.int16[ke + 7] = S, this.uint16[ke + 8] = M, this.uint16[ke + 9] = j, this.uint16[ke + 10] = O, this.uint16[ke + 11] = N, this.uint16[ke + 12] = H, this.uint16[ke + 13] = J, this.uint16[ke + 14] = rt, this.uint16[ke + 15] = ht, this.uint16[ke + 16] = Ot, this.uint16[ke + 17] = bt, this.uint16[ke + 18] = Mt, this.uint16[ke + 19] = te, this.uint16[ke + 20] = le, this.uint16[ke + 21] = Re, this.uint16[ke + 22] = br, this.uint32[an + 12] = ar, this.float32[an + 13] = yr, this.float32[an + 14] = Yr, this.uint16[ke + 30] = fr, this.uint16[ke + 31] = vr, r
          }
        }
        wl.prototype.bytesPerElement = 64, Sr("StructArrayLayout8i15ui1ul2f2ui64", wl);
        class d extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, r)
          }
          emplace(r, n) {
            return this.float32[1 * r + 0] = n, r
          }
        }
        d.prototype.bytesPerElement = 4, Sr("StructArrayLayout1f4", d);
        class e extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, r, n, a)
          }
          emplace(r, n, a, _) {
            const f = 3 * r;
            return this.uint16[6 * r + 0] = n, this.float32[f + 1] = a, this.float32[f + 2] = _, r
          }
        }
        e.prototype.bytesPerElement = 12, Sr("StructArrayLayout1ui2f12", e);
        class o extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, r, n, a)
          }
          emplace(r, n, a, _) {
            const f = 4 * r;
            return this.uint32[2 * r + 0] = n, this.uint16[f + 2] = a, this.uint16[f + 3] = _, r
          }
        }
        o.prototype.bytesPerElement = 8, Sr("StructArrayLayout1ul2ui8", o);
        class u extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, r, n)
          }
          emplace(r, n, a) {
            const _ = 2 * r;
            return this.uint16[_ + 0] = n, this.uint16[_ + 1] = a, r
          }
        }
        u.prototype.bytesPerElement = 4, Sr("StructArrayLayout2ui4", u);
        class h extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, r)
          }
          emplace(r, n) {
            return this.uint16[1 * r + 0] = n, r
          }
        }
        h.prototype.bytesPerElement = 2, Sr("StructArrayLayout1ui2", h);
        class p extends li {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(r, n, a, _) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, r, n, a, _)
          }
          emplace(r, n, a, _, f) {
            const m = 4 * r;
            return this.float32[m + 0] = n, this.float32[m + 1] = a, this.float32[m + 2] = _, this.float32[m + 3] = f, r
          }
        }
        p.prototype.bytesPerElement = 16, Sr("StructArrayLayout4f16", p);
        class g extends es {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new R(this.anchorPointX, this.anchorPointY)
          }
        }
        g.prototype.size = 20;
        class x extends bl {
          get(r) {
            return new g(this, r)
          }
        }
        Sr("CollisionBoxArray", x);
        class T extends es {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(r) {
            this._structArray.uint8[this._pos1 + 37] = r
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(r) {
            this._structArray.uint8[this._pos1 + 38] = r
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(r) {
            this._structArray.uint32[this._pos4 + 10] = r
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        T.prototype.size = 48;
        class I extends Ju {
          get(r) {
            return new T(this, r)
          }
        }
        Sr("PlacedSymbolArray", I);
        class A extends es {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(r) {
            this._structArray.uint32[this._pos4 + 12] = r
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        A.prototype.size = 64;
        class F extends wl {
          get(r) {
            return new A(this, r)
          }
        }
        Sr("SymbolInstanceArray", F);
        class L extends d {
          getoffsetX(r) {
            return this.float32[1 * r + 0]
          }
        }
        Sr("GlyphOffsetArray", L);
        class V extends Wu {
          getx(r) {
            return this.int16[3 * r + 0]
          }
          gety(r) {
            return this.int16[3 * r + 1]
          }
          gettileUnitDistanceFromAnchor(r) {
            return this.int16[3 * r + 2]
          }
        }
        Sr("SymbolLineVertexArray", V);
        class K extends es {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        K.prototype.size = 12;
        class it extends e {
          get(r) {
            return new K(this, r)
          }
        }
        Sr("TextAnchorOffsetArray", it);
        class ot extends es {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        ot.prototype.size = 8;
        class st extends o {
          get(r) {
            return new ot(this, r)
          }
        }
        Sr("FeatureIndexArray", st);
        class pt extends Ca {}
        class wt extends Ca {}
        class dt extends Ca {}
        class kt extends hs {}
        class It extends $u {}
        class gt extends Xs {}
        class Rt extends Xu {}
        class oe extends ou {}
        class Qt extends vl {}
        class re extends Ia {}
        class ue extends Ys {}
        class Je extends Yu {}
        class tr extends xl {}
        class Pe extends Ku {}
        class Fr extends u {}
        const gn = bi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Hn
          } = gn;
        class Tn {
          constructor(r = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = r
          }
          prepareSegment(r, n, a, _) {
            const f = this.segments[this.segments.length - 1];
            return r > Tn.MAX_VERTEX_ARRAY_LENGTH && nr(`Max vertices per segment is ${Tn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${r}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Tn.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !f || f.vertexLength + r > Tn.MAX_VERTEX_ARRAY_LENGTH || f.sortKey !== _ ? this.createNewSegment(n, a, _) : f
          }
          createNewSegment(r, n, a) {
            const _ = {
              vertexOffset: r.length,
              primitiveOffset: n.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return a !== void 0 && (_.sortKey = a), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(_), _
          }
          getOrCreateLatestSegment(r, n, a) {
            return this.prepareSegment(0, r, n, a)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const r of this.segments)
              for (const n in r.vaos) r.vaos[n].destroy()
          }
          static simpleSegment(r, n, a, _) {
            return new Tn([{
              vertexOffset: r,
              primitiveOffset: n,
              vertexLength: a,
              primitiveLength: _,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function Jn(i, r) {
          return 256 * (i = Ye(Math.floor(i), 0, 255)) + Ye(Math.floor(r), 0, 255)
        }
        Tn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Sr("SegmentVector", Tn);
        const _i = bi([{
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
          }]),
          ei = bi([{
            name: "a_dasharray_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_dasharray_to",
            components: 4,
            type: "Uint16"
          }]);
        var Ii, oi, Oi, si = {
            exports: {}
          },
          Si = {
            exports: {}
          },
          co = {
            exports: {}
          },
          Js = (function() {
            if (Oi) return si.exports;
            Oi = 1;
            var i = (Ii || (Ii = 1, Si.exports = function(n, a) {
                var _, f, m, v, b, S, M, j;
                for (f = n.length - (_ = 3 & n.length), m = a, b = 3432918353, S = 461845907, j = 0; j < f;) M = 255 & n.charCodeAt(j) | (255 & n.charCodeAt(++j)) << 8 | (255 & n.charCodeAt(++j)) << 16 | (255 & n.charCodeAt(++j)) << 24, ++j, m = 27492 + (65535 & (v = 5 * (65535 & (m = (m ^= M = (65535 & (M = (M = (65535 & M) * b + (((M >>> 16) * b & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * S + (((M >>> 16) * S & 65535) << 16) & 4294967295) << 13 | m >>> 19)) + ((5 * (m >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
                switch (M = 0, _) {
                  case 3:
                    M ^= (255 & n.charCodeAt(j + 2)) << 16;
                  case 2:
                    M ^= (255 & n.charCodeAt(j + 1)) << 8;
                  case 1:
                    m ^= M = (65535 & (M = (M = (65535 & (M ^= 255 & n.charCodeAt(j))) * b + (((M >>> 16) * b & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * S + (((M >>> 16) * S & 65535) << 16) & 4294967295
                }
                return m ^= n.length, m = 2246822507 * (65535 & (m ^= m >>> 16)) + ((2246822507 * (m >>> 16) & 65535) << 16) & 4294967295, m = 3266489909 * (65535 & (m ^= m >>> 13)) + ((3266489909 * (m >>> 16) & 65535) << 16) & 4294967295, (m ^= m >>> 16) >>> 0
              }), Si.exports),
              r = (oi || (oi = 1, co.exports = function(n, a) {
                for (var _, f = n.length, m = a ^ f, v = 0; f >= 4;) _ = 1540483477 * (65535 & (_ = 255 & n.charCodeAt(v) | (255 & n.charCodeAt(++v)) << 8 | (255 & n.charCodeAt(++v)) << 16 | (255 & n.charCodeAt(++v)) << 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16), m = 1540483477 * (65535 & m) + ((1540483477 * (m >>> 16) & 65535) << 16) ^ (_ = 1540483477 * (65535 & (_ ^= _ >>> 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16)), f -= 4, ++v;
                switch (f) {
                  case 3:
                    m ^= (255 & n.charCodeAt(v + 2)) << 16;
                  case 2:
                    m ^= (255 & n.charCodeAt(v + 1)) << 8;
                  case 1:
                    m = 1540483477 * (65535 & (m ^= 255 & n.charCodeAt(v))) + ((1540483477 * (m >>> 16) & 65535) << 16)
                }
                return m = 1540483477 * (65535 & (m ^= m >>> 13)) + ((1540483477 * (m >>> 16) & 65535) << 16), (m ^= m >>> 15) >>> 0
              }), co.exports);
            return si.exports = i, si.exports.murmur3 = i, si.exports.murmur2 = r, si.exports
          })(),
          ds = X(Js);
        class rs {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(r, n, a, _) {
            this.ids.push(Qs(r)), this.positions.push(n, a, _)
          }
          getPositions(r) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = Qs(r);
            let a = 0,
              _ = this.ids.length - 1;
            for (; a < _;) {
              const m = a + _ >> 1;
              this.ids[m] >= n ? _ = m : a = m + 1
            }
            const f = [];
            for (; this.ids[a] === n;) f.push({
              index: this.positions[3 * a],
              start: this.positions[3 * a + 1],
              end: this.positions[3 * a + 2]
            }), a++;
            return f
          }
          static serialize(r, n) {
            const a = new Float64Array(r.ids),
              _ = new Uint32Array(r.positions);
            return za(a, _, 0, a.length - 1), n && n.push(a.buffer, _.buffer), {
              ids: a,
              positions: _
            }
          }
          static deserialize(r) {
            const n = new rs;
            return n.ids = r.ids, n.positions = r.positions, n.indexed = !0, n
          }
        }

        function Qs(i) {
          const r = +i;
          return !isNaN(r) && r <= Number.MAX_SAFE_INTEGER ? r : ds(String(i))
        }

        function za(i, r, n, a) {
          for (; n < a;) {
            const _ = i[n + a >> 1];
            let f = n - 1,
              m = a + 1;
            for (;;) {
              do f++; while (i[f] < _);
              do m--; while (i[m] > _);
              if (f >= m) break;
              ta(i, f, m), ta(r, 3 * f, 3 * m), ta(r, 3 * f + 1, 3 * m + 1), ta(r, 3 * f + 2, 3 * m + 2)
            }
            m - n < a - m ? (za(i, r, n, m), n = m + 1) : (za(i, r, m + 1, a), a = m)
          }
        }

        function ta(i, r, n) {
          const a = i[r];
          i[r] = i[n], i[n] = a
        }
        Sr("FeaturePositionMap", rs);
        class go {
          constructor(r, n) {
            this.gl = r.gl, this.location = n
          }
        }
        class lo extends go {
          constructor(r, n) {
            super(r, n), this.current = 0
          }
          set(r) {
            this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r))
          }
        }
        class ps extends go {
          constructor(r, n) {
            super(r, n), this.current = [0, 0, 0, 0]
          }
          set(r) {
            r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3]))
          }
        }
        class Cs extends go {
          constructor(r, n) {
            super(r, n), this.current = Ur.transparent
          }
          set(r) {
            r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a))
          }
        }
        const su = new Float32Array(16);

        function Pi(i) {
          return [Jn(255 * i.r, 255 * i.g), Jn(255 * i.b, 255 * i.a)]
        }
        class xi {
          constructor(r, n, a) {
            this.value = r, this.uniformNames = n.map((_ => `u_${_}`)), this.type = a
          }
          setUniform(r, n, a) {
            r.set(a.constantOr(this.value))
          }
          getBinding(r, n, a) {
            return this.type === "color" ? new Cs(r, n) : new lo(r, n)
          }
        }
        class qi {
          constructor(r, n) {
            this.uniformNames = n.map((a => `u_${a}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(r, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = r.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = r.tlbr
          }
          setConstantDashPositions(r, n) {
            this.dashTo = [0, r.y, r.height, r.width], this.dashFrom = [0, n.y, n.height, n.width]
          }
          setUniform(r, n, a, _) {
            let f = null;
            _ === "u_pattern_to" ? f = this.patternTo : _ === "u_pattern_from" ? f = this.patternFrom : _ === "u_dasharray_to" ? f = this.dashTo : _ === "u_dasharray_from" ? f = this.dashFrom : _ === "u_pixel_ratio_to" ? f = this.pixelRatioTo : _ === "u_pixel_ratio_from" && (f = this.pixelRatioFrom), f !== null && r.set(f)
          }
          getBinding(r, n, a) {
            return a.substr(0, 9) === "u_pattern" || a.substr(0, 12) === "u_dasharray_" ? new ps(r, n) : new lo(r, n)
          }
        }
        class ni {
          constructor(r, n, a, _) {
            this.expression = r, this.type = a, this.maxValue = 0, this.paintVertexAttributes = n.map((f => ({
              name: `a_${f}`,
              type: "Float32",
              components: a === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new _
          }
          populatePaintArray(r, n, a) {
            const _ = this.paintVertexArray.length,
              f = this.expression.evaluate(new Kn(0, a), n, {}, a.canonical, [], a.formattedSection);
            this.paintVertexArray.resize(r), this._setPaintValue(_, r, f)
          }
          updatePaintArray(r, n, a, _, f) {
            const m = this.expression.evaluate(new Kn(0, f), a, _);
            this._setPaintValue(r, n, m)
          }
          _setPaintValue(r, n, a) {
            if (this.type === "color") {
              const _ = Pi(a);
              for (let f = r; f < n; f++) this.paintVertexArray.emplace(f, _[0], _[1])
            } else {
              for (let _ = r; _ < n; _++) this.paintVertexArray.emplace(_, a);
              this.maxValue = Math.max(this.maxValue, Math.abs(a))
            }
          }
          upload(r) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Zo {
          constructor(r, n, a, _, f, m) {
            this.expression = r, this.uniformNames = n.map((v => `u_${v}_t`)), this.type = a, this.useIntegerZoom = _, this.zoom = f, this.maxValue = 0, this.paintVertexAttributes = n.map((v => ({
              name: `a_${v}`,
              type: "Float32",
              components: a === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new m
          }
          populatePaintArray(r, n, a) {
            const _ = this.expression.evaluate(new Kn(this.zoom, a), n, {}, a.canonical, [], a.formattedSection),
              f = this.expression.evaluate(new Kn(this.zoom + 1, a), n, {}, a.canonical, [], a.formattedSection),
              m = this.paintVertexArray.length;
            this.paintVertexArray.resize(r), this._setPaintValue(m, r, _, f)
          }
          updatePaintArray(r, n, a, _, f) {
            const m = this.expression.evaluate(new Kn(this.zoom, f), a, _),
              v = this.expression.evaluate(new Kn(this.zoom + 1, f), a, _);
            this._setPaintValue(r, n, m, v)
          }
          _setPaintValue(r, n, a, _) {
            if (this.type === "color") {
              const f = Pi(a),
                m = Pi(_);
              for (let v = r; v < n; v++) this.paintVertexArray.emplace(v, f[0], f[1], m[0], m[1])
            } else {
              for (let f = r; f < n; f++) this.paintVertexArray.emplace(f, a, _);
              this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(_))
            }
          }
          upload(r) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(r, n) {
            const a = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom,
              _ = Ye(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
            r.set(_)
          }
          getBinding(r, n, a) {
            return new lo(r, n)
          }
        }
        class Is {
          constructor(r, n, a, _, f, m) {
            this.expression = r, this.type = n, this.useIntegerZoom = a, this.zoom = _, this.layerId = m, this.zoomInPaintVertexArray = new f, this.zoomOutPaintVertexArray = new f
          }
          populatePaintArray(r, n, a) {
            const _ = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(r), this.zoomOutPaintVertexArray.resize(r), this._setPaintValues(_, r, this.getPositionIds(n), a)
          }
          updatePaintArray(r, n, a, _, f) {
            this._setPaintValues(r, n, this.getPositionIds(a), f)
          }
          _setPaintValues(r, n, a, _) {
            const f = this.getPositions(_);
            if (!f || !a) return;
            const m = f[a.min],
              v = f[a.mid],
              b = f[a.max];
            if (m && v && b)
              for (let S = r; S < n; S++) this.emplace(this.zoomInPaintVertexArray, S, v, m), this.emplace(this.zoomOutPaintVertexArray, S, v, b)
          }
          upload(r) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const n = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = r.createVertexBuffer(this.zoomInPaintVertexArray, n, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = r.createVertexBuffer(this.zoomOutPaintVertexArray, n, this.expression.isStateDependent)
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Ch extends Is {
          getPositions(r) {
            return r.imagePositions
          }
          getPositionIds(r) {
            return r.patterns && r.patterns[this.layerId]
          }
          getVertexAttributes() {
            return _i.members
          }
          emplace(r, n, a, _) {
            r.emplace(n, a.tlbr[0], a.tlbr[1], a.tlbr[2], a.tlbr[3], _.tlbr[0], _.tlbr[1], _.tlbr[2], _.tlbr[3], a.pixelRatio, _.pixelRatio)
          }
        }
        class Ih extends Is {
          getPositions(r) {
            return r.dashPositions
          }
          getPositionIds(r) {
            return r.dashes && r.dashes[this.layerId]
          }
          getVertexAttributes() {
            return ei.members
          }
          emplace(r, n, a, _) {
            r.emplace(n, 0, a.y, a.height, a.width, 0, _.y, _.height, _.width)
          }
        }
        class zh {
          constructor(r, n, a) {
            this.binders = {}, this._buffers = [];
            const _ = [];
            for (const f in r.paint._values) {
              if (!a(f)) continue;
              const m = r.paint.get(f);
              if (!(m instanceof Vo && wa(m.property.specification))) continue;
              const v = ra(f, r.type),
                b = m.value,
                S = m.property.specification.type,
                M = m.property.useIntegerZoom,
                j = m.property.specification["property-type"],
                O = j === "cross-faded" || j === "cross-faded-data-driven";
              if (b.kind === "constant") this.binders[f] = O ? new qi(b.value, v) : new xi(b.value, v, S), _.push(`/u_${f}`);
              else if (b.kind === "source" || O) {
                const N = kl(f, S, "source");
                this.binders[f] = O ? f === "line-dasharray" ? new Ih(b, S, M, n, N, r.id) : new Ch(b, S, M, n, N, r.id) : new ni(b, v, S, N), _.push(`/a_${f}`)
              } else {
                const N = kl(f, S, "composite");
                this.binders[f] = new Zo(b, v, S, M, n, N), _.push(`/z_${f}`)
              }
            }
            this.cacheKey = _.sort().join("")
          }
          getMaxValue(r) {
            const n = this.binders[r];
            return n instanceof ni || n instanceof Zo ? n.maxValue : 0
          }
          populatePaintArrays(r, n, a) {
            for (const _ in this.binders) {
              const f = this.binders[_];
              (f instanceof ni || f instanceof Zo || f instanceof Is) && f.populatePaintArray(r, n, a)
            }
          }
          setConstantPatternPositions(r, n) {
            for (const a in this.binders) {
              const _ = this.binders[a];
              _ instanceof qi && _.setConstantPatternPositions(r, n)
            }
          }
          setConstantDashPositions(r, n) {
            for (const a in this.binders) {
              const _ = this.binders[a];
              _ instanceof qi && _.setConstantDashPositions(r, n)
            }
          }
          updatePaintArrays(r, n, a, _, f) {
            let m = !1;
            for (const v in r) {
              const b = n.getPositions(v);
              for (const S of b) {
                const M = a.feature(S.index);
                for (const j in this.binders) {
                  const O = this.binders[j];
                  if ((O instanceof ni || O instanceof Zo || O instanceof Is) && O.expression.isStateDependent === !0) {
                    const N = _.paint.get(j);
                    O.expression = N.value, O.updatePaintArray(S.start, S.end, M, r[v], f), m = !0
                  }
                }
              }
            }
            return m
          }
          defines() {
            const r = [];
            for (const n in this.binders) {
              const a = this.binders[n];
              (a instanceof xi || a instanceof qi) && r.push(...a.uniformNames.map((_ => `#define HAS_UNIFORM_${_}`)))
            }
            return r
          }
          getBinderAttributes() {
            const r = [];
            for (const n in this.binders) {
              const a = this.binders[n];
              if (a instanceof ni || a instanceof Zo)
                for (let _ = 0; _ < a.paintVertexAttributes.length; _++) r.push(a.paintVertexAttributes[_].name);
              else if (a instanceof Is) {
                const _ = a.getVertexAttributes();
                for (const f of _) r.push(f.name)
              }
            }
            return r
          }
          getBinderUniforms() {
            const r = [];
            for (const n in this.binders) {
              const a = this.binders[n];
              if (a instanceof xi || a instanceof qi || a instanceof Zo)
                for (const _ of a.uniformNames) r.push(_)
            }
            return r
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(r, n) {
            const a = [];
            for (const _ in this.binders) {
              const f = this.binders[_];
              if (f instanceof xi || f instanceof qi || f instanceof Zo) {
                for (const m of f.uniformNames)
                  if (n[m]) {
                    const v = f.getBinding(r, n[m], m);
                    a.push({
                      name: m,
                      property: _,
                      binding: v
                    })
                  }
              }
            }
            return a
          }
          setUniforms(r, n, a, _) {
            for (const {
                name: f,
                property: m,
                binding: v
              }
              of n) this.binders[m].setUniform(v, _, a.get(m), f)
          }
          updatePaintBuffers(r) {
            this._buffers = [];
            for (const n in this.binders) {
              const a = this.binders[n];
              if (r && a instanceof Is) {
                const _ = r.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
                _ && this._buffers.push(_)
              } else(a instanceof ni || a instanceof Zo) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
            }
          }
          upload(r) {
            for (const n in this.binders) {
              const a = this.binders[n];
              (a instanceof ni || a instanceof Zo || a instanceof Is) && a.upload(r)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const r in this.binders) {
              const n = this.binders[r];
              (n instanceof ni || n instanceof Zo || n instanceof Is) && n.destroy()
            }
          }
        }
        class ea {
          constructor(r, n, a = () => !0) {
            this.programConfigurations = {};
            for (const _ of r) this.programConfigurations[_.id] = new zh(_, n, a);
            this.needsUpload = !1, this._featureMap = new rs, this._bufferOffset = 0
          }
          populatePaintArrays(r, n, a, _) {
            for (const f in this.programConfigurations) this.programConfigurations[f].populatePaintArrays(r, n, _);
            n.id !== void 0 && this._featureMap.add(n.id, a, this._bufferOffset, r), this._bufferOffset = r, this.needsUpload = !0
          }
          updatePaintArrays(r, n, a, _) {
            for (const f of a) this.needsUpload = this.programConfigurations[f.id].updatePaintArrays(r, this._featureMap, n, f, _) || this.needsUpload
          }
          get(r) {
            return this.programConfigurations[r]
          }
          upload(r) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(r);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const r in this.programConfigurations) this.programConfigurations[r].destroy()
          }
        }

        function ra(i, r) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-dasharray": ["dasharray_to", "dasharray_from"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [i] || [i.replace(`${r}-`, "").replace(/-/g, "_")]
        }

        function kl(i, r, n) {
          const a = {
              color: {
                source: Xs,
                composite: p
              },
              number: {
                source: d,
                composite: Xs
              }
            },
            _ = (function(f) {
              return {
                "line-pattern": {
                  source: Rt,
                  composite: Rt
                },
                "fill-pattern": {
                  source: Rt,
                  composite: Rt
                },
                "fill-extrusion-pattern": {
                  source: Rt,
                  composite: Rt
                },
                "line-dasharray": {
                  source: oe,
                  composite: oe
                }
              } [f]
            })(i);
          return _ && _[n] || a[r][n]
        }
        Sr("ConstantBinder", xi), Sr("CrossFadedConstantBinder", qi), Sr("SourceExpressionBinder", ni), Sr("CrossFadedPatternBinder", Ch), Sr("CrossFadedDasharrayBinder", Ih), Sr("CompositeExpressionBinder", Zo), Sr("ProgramConfiguration", zh, {
          omit: ["_buffers"]
        }), Sr("ProgramConfigurationSet", ea);
        const Qu = Math.pow(2, 14) - 1,
          Tl = -Qu - 1;

        function fs(i) {
          const r = ne / i.extent,
            n = i.loadGeometry();
          for (let a = 0; a < n.length; a++) {
            const _ = n[a];
            for (let f = 0; f < _.length; f++) {
              const m = _[f],
                v = Math.round(m.x * r),
                b = Math.round(m.y * r);
              m.x = Ye(v, Tl, Qu), m.y = Ye(b, Tl, Qu), (v < m.x || v > m.x + 1 || b < m.y || b > m.y + 1) && nr("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return n
        }

        function zs(i, r) {
          return {
            type: i.type,
            id: i.id,
            properties: i.properties,
            geometry: r ? fs(i) : []
          }
        }
        const tc = -32768;

        function m0(i, r, n, a, _) {
          i.emplaceBack(tc + 8 * r + a, tc + 8 * n + _)
        }
        class Qd {
          constructor(r) {
            this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map((n => n.id)), this.index = r.index, this.hasDependencies = !1, this.layoutVertexArray = new wt, this.indexArray = new Pe, this.segments = new Tn, this.programConfigurations = new ea(r.layers, r.zoom), this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(r, n, a) {
            const _ = this.layers[0],
              f = [];
            let m = null,
              v = !1,
              b = _.type === "heatmap";
            if (_.type === "circle") {
              const M = _;
              m = M.layout.get("circle-sort-key"), v = !m.isConstant(), b = b || M.paint.get("circle-pitch-alignment") === "map"
            }
            const S = b ? n.subdivisionGranularity.circle : 1;
            for (const {
                feature: M,
                id: j,
                index: O,
                sourceLayerIndex: N
              }
              of r) {
              const H = this.layers[0]._featureFilter.needGeometry,
                J = zs(M, H);
              if (!this.layers[0]._featureFilter.filter(new Kn(this.zoom), J, a)) continue;
              const rt = v ? m.evaluate(J, {}, a) : void 0,
                ht = {
                  id: j,
                  properties: M.properties,
                  type: M.type,
                  sourceLayerIndex: N,
                  index: O,
                  geometry: H ? J.geometry : fs(M),
                  patterns: {},
                  sortKey: rt
                };
              f.push(ht)
            }
            v && f.sort(((M, j) => M.sortKey - j.sortKey));
            for (const M of f) {
              const {
                geometry: j,
                index: O,
                sourceLayerIndex: N
              } = M, H = r[O].feature;
              this.addFeature(M, j, O, a, S), n.featureIndex.insert(H, j, O, N, this.index)
            }
          }
          update(r, n, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, n, this.stateDependentLayers, {
              imagePositions: a
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(r) {
            this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, Hn), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(r, n, a, _, f = 1) {
            let m;
            switch (f) {
              case 1:
                m = [0, 7];
                break;
              case 3:
                m = [0, 2, 5, 7];
                break;
              case 5:
                m = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                m = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${f}; valid values are 1, 3, 5, 7.`)
            }
            const v = m.length;
            for (const b of n)
              for (const S of b) {
                const M = S.x,
                  j = S.y;
                if (M < 0 || M >= ne || j < 0 || j >= ne) continue;
                const O = this.segments.prepareSegment(v * v, this.layoutVertexArray, this.indexArray, r.sortKey),
                  N = O.vertexLength;
                for (let H = 0; H < v; H++)
                  for (let J = 0; J < v; J++) m0(this.layoutVertexArray, M, j, m[J], m[H]);
                for (let H = 0; H < v - 1; H++)
                  for (let J = 0; J < v - 1; J++) {
                    const rt = N + H * v + J,
                      ht = N + (H + 1) * v + J;
                    this.indexArray.emplaceBack(rt, ht + 1, rt + 1), this.indexArray.emplaceBack(rt, ht, ht + 1)
                  }
                O.vertexLength += v * v, O.primitiveLength += (v - 1) * (v - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, a, {
              imagePositions: {},
              canonical: _
            })
          }
        }

        function km(i, r) {
          for (let n = 0; n < i.length; n++)
            if (ec(r, i[n])) return !0;
          for (let n = 0; n < r.length; n++)
            if (ec(i, r[n])) return !0;
          return !!tp(i, r)
        }

        function Ah(i, r, n) {
          return !!ec(i, r) || !!ep(r, i, n)
        }

        function Tm(i, r) {
          if (i.length === 1) return Pm(r, i[0]);
          for (let n = 0; n < r.length; n++) {
            const a = r[n];
            for (let _ = 0; _ < a.length; _++)
              if (ec(i, a[_])) return !0
          }
          for (let n = 0; n < i.length; n++)
            if (Pm(r, i[n])) return !0;
          for (let n = 0; n < r.length; n++)
            if (tp(i, r[n])) return !0;
          return !1
        }

        function g0(i, r, n) {
          if (i.length > 1) {
            if (tp(i, r)) return !0;
            for (let a = 0; a < r.length; a++)
              if (ep(r[a], i, n)) return !0
          }
          for (let a = 0; a < i.length; a++)
            if (ep(i[a], r, n)) return !0;
          return !1
        }

        function tp(i, r) {
          if (i.length === 0 || r.length === 0) return !1;
          for (let n = 0; n < i.length - 1; n++) {
            const a = i[n],
              _ = i[n + 1];
            for (let f = 0; f < r.length - 1; f++)
              if (y0(a, _, r[f], r[f + 1])) return !0
          }
          return !1
        }

        function y0(i, r, n, a) {
          return gr(i, n, a) !== gr(r, n, a) && gr(i, r, n) !== gr(i, r, a)
        }

        function ep(i, r, n) {
          const a = n * n;
          if (r.length === 1) return i.distSqr(r[0]) < a;
          for (let _ = 1; _ < r.length; _++)
            if (Sm(i, r[_ - 1], r[_]) < a) return !0;
          return !1
        }

        function Sm(i, r, n) {
          const a = r.distSqr(n);
          if (a === 0) return i.distSqr(r);
          const _ = ((i.x - r.x) * (n.x - r.x) + (i.y - r.y) * (n.y - r.y)) / a;
          return i.distSqr(_ < 0 ? r : _ > 1 ? n : n.sub(r)._mult(_)._add(r))
        }

        function Pm(i, r) {
          let n, a, _, f = !1;
          for (let m = 0; m < i.length; m++) {
            n = i[m];
            for (let v = 0, b = n.length - 1; v < n.length; b = v++) a = n[v], _ = n[b], a.y > r.y != _.y > r.y && r.x < (_.x - a.x) * (r.y - a.y) / (_.y - a.y) + a.x && (f = !f)
          }
          return f
        }

        function ec(i, r) {
          let n = !1;
          for (let a = 0, _ = i.length - 1; a < i.length; _ = a++) {
            const f = i[a],
              m = i[_];
            f.y > r.y != m.y > r.y && r.x < (m.x - f.x) * (r.y - f.y) / (m.y - f.y) + f.x && (n = !n)
          }
          return n
        }

        function v0(i, r, n) {
          const a = n[0],
            _ = n[2];
          if (i.x < a.x && r.x < a.x || i.x > _.x && r.x > _.x || i.y < a.y && r.y < a.y || i.y > _.y && r.y > _.y) return !1;
          const f = gr(i, r, n[0]);
          return f !== gr(i, r, n[1]) || f !== gr(i, r, n[2]) || f !== gr(i, r, n[3])
        }

        function rc(i, r, n) {
          const a = r.paint.get(i).value;
          return a.kind === "constant" ? a.value : n.programConfigurations.get(r.id).getMaxValue(i)
        }

        function Eh(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1])
        }

        function jh(i, r, n, a, _) {
          if (!r[0] && !r[1]) return i;
          const f = R.convert(r)._mult(_);
          n === "viewport" && f._rotate(-a);
          const m = [];
          for (let v = 0; v < i.length; v++) m.push(i[v].sub(f));
          return m
        }

        function b0({
          queryGeometry: i,
          size: r
        }, n) {
          return Ah(i, n, r)
        }

        function x0({
          queryGeometry: i,
          size: r,
          transform: n,
          unwrappedTileID: a,
          getElevation: _
        }, f) {
          return Ah(i, f, r * (n.projectTileCoordinates(f.x, f.y, a, _).signedDistanceFromCamera / n.cameraToCenterDistance))
        }

        function w0({
          queryGeometry: i,
          size: r,
          transform: n,
          unwrappedTileID: a,
          getElevation: _
        }, f) {
          const m = n.projectTileCoordinates(f.x, f.y, a, _).signedDistanceFromCamera,
            v = r * (n.cameraToCenterDistance / m);
          return Ah(i, rp(f, n, a, _), v)
        }

        function k0({
          queryGeometry: i,
          size: r,
          transform: n,
          unwrappedTileID: a,
          getElevation: _
        }, f) {
          return Ah(i, rp(f, n, a, _), r)
        }

        function Mm({
          queryGeometry: i,
          size: r,
          transform: n,
          unwrappedTileID: a,
          getElevation: _,
          pitchAlignment: f = "map",
          pitchScale: m = "map"
        }, v) {
          const b = f === "map" ? m === "map" ? b0 : x0 : m === "map" ? w0 : k0,
            S = {
              queryGeometry: i,
              size: r,
              transform: n,
              unwrappedTileID: a,
              getElevation: _
            };
          for (const M of v)
            for (const j of M)
              if (b(S, j)) return !0;
          return !1
        }

        function rp(i, r, n, a) {
          const _ = r.projectTileCoordinates(i.x, i.y, n, a).point;
          return new R((.5 * _.x + .5) * r.width, (.5 * -_.y + .5) * r.height)
        }
        let Cm, Im;
        Sr("CircleBucket", Qd, {
          omit: ["layers"]
        });
        var T0 = {
          get paint() {
            return Im = Im || new io({
              "circle-radius": new nn(W.paint_circle["circle-radius"]),
              "circle-color": new nn(W.paint_circle["circle-color"]),
              "circle-blur": new nn(W.paint_circle["circle-blur"]),
              "circle-opacity": new nn(W.paint_circle["circle-opacity"]),
              "circle-translate": new Xr(W.paint_circle["circle-translate"]),
              "circle-translate-anchor": new Xr(W.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new Xr(W.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new Xr(W.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new nn(W.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new nn(W.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new nn(W.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return Cm = Cm || new io({
              "circle-sort-key": new nn(W.layout_circle["circle-sort-key"])
            })
          }
        };
        class S0 extends Uo {
          constructor(r, n) {
            super(r, T0, n)
          }
          createBucket(r) {
            return new Qd(r)
          }
          queryRadius(r) {
            const n = r;
            return rc("circle-radius", this, n) + rc("circle-stroke-width", this, n) + Eh(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: r,
            feature: n,
            featureState: a,
            geometry: _,
            transform: f,
            pixelsToTileUnits: m,
            unwrappedTileID: v,
            getElevation: b
          }) {
            const S = jh(r, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -f.bearingInRadians, m),
              M = this.paint.get("circle-radius").evaluate(n, a) + this.paint.get("circle-stroke-width").evaluate(n, a),
              j = this.paint.get("circle-pitch-scale"),
              O = this.paint.get("circle-pitch-alignment");
            let N, H;
            return O === "map" ? (N = S, H = M * m) : (N = (function(J, rt, ht, Ot) {
              return J.map((bt => rp(bt, rt, ht, Ot)))
            })(S, f, v, b), H = M), Mm({
              queryGeometry: N,
              size: H,
              transform: f,
              unwrappedTileID: v,
              getElevation: b,
              pitchAlignment: O,
              pitchScale: j
            }, _)
          }
        }
        class zm extends Qd {}
        let Am;
        Sr("HeatmapBucket", zm, {
          omit: ["layers"]
        });
        var P0 = {
          get paint() {
            return Am = Am || new io({
              "heatmap-radius": new nn(W.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new nn(W.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new Xr(W.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new iu(W.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new Xr(W.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function np(i, {
          width: r,
          height: n
        }, a, _) {
          if (_) {
            if (_ instanceof Uint8ClampedArray) _ = new Uint8Array(_.buffer);
            else if (_.length !== r * n * a) throw new RangeError(`mismatched image size. expected: ${_.length} but got: ${r*n*a}`)
          } else _ = new Uint8Array(r * n * a);
          return i.width = r, i.height = n, i.data = _, i
        }

        function Em(i, {
          width: r,
          height: n
        }, a) {
          if (r === i.width && n === i.height) return;
          const _ = np({}, {
            width: r,
            height: n
          }, a);
          ip(i, _, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(i.width, r),
            height: Math.min(i.height, n)
          }, a), i.width = r, i.height = n, i.data = _.data
        }

        function ip(i, r, n, a, _, f) {
          if (_.width === 0 || _.height === 0) return r;
          if (_.width > i.width || _.height > i.height || n.x > i.width - _.width || n.y > i.height - _.height) throw new RangeError("out of range source coordinates for image copy");
          if (_.width > r.width || _.height > r.height || a.x > r.width - _.width || a.y > r.height - _.height) throw new RangeError("out of range destination coordinates for image copy");
          const m = i.data,
            v = r.data;
          if (m === v) throw new Error("srcData equals dstData, so image is already copied");
          for (let b = 0; b < _.height; b++) {
            const S = ((n.y + b) * i.width + n.x) * f,
              M = ((a.y + b) * r.width + a.x) * f;
            for (let j = 0; j < _.width * f; j++) v[M + j] = m[S + j]
          }
          return r
        }
        class Sl {
          constructor(r, n) {
            np(this, r, 1, n)
          }
          resize(r) {
            Em(this, r, 1)
          }
          clone() {
            return new Sl({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(r, n, a, _, f) {
            ip(r, n, a, _, f, 1)
          }
        }
        class To {
          constructor(r, n) {
            np(this, r, 4, n)
          }
          resize(r) {
            Em(this, r, 4)
          }
          replace(r, n) {
            n ? this.data.set(r) : this.data = r instanceof Uint8ClampedArray ? new Uint8Array(r.buffer) : r
          }
          clone() {
            return new To({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(r, n, a, _, f) {
            ip(r, n, a, _, f, 4)
          }
          setPixel(r, n, a) {
            const _ = 4 * (r * this.width + n);
            this.data[_ + 0] = Math.round(255 * a.r / a.a), this.data[_ + 1] = Math.round(255 * a.g / a.a), this.data[_ + 2] = Math.round(255 * a.b / a.a), this.data[_ + 3] = Math.round(255 * a.a)
          }
        }

        function jm(i) {
          const r = {},
            n = i.resolution || 256,
            a = i.clips ? i.clips.length : 1,
            _ = i.image || new To({
              width: n,
              height: a
            });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const f = (m, v, b) => {
            r[i.evaluationKey] = b;
            const S = i.expression.evaluate(r);
            _.setPixel(m / 4 / n, v / 4, S)
          };
          if (i.clips)
            for (let m = 0, v = 0; m < a; ++m, v += 4 * n)
              for (let b = 0, S = 0; b < n; b++, S += 4) {
                const M = b / (n - 1),
                  {
                    start: j,
                    end: O
                  } = i.clips[m];
                f(v, S, j * (1 - M) + O * M)
              } else
                for (let m = 0, v = 0; m < n; m++, v += 4) f(0, v, m / (n - 1));
          return _
        }
        Sr("AlphaImage", Sl), Sr("RGBAImage", To);
        const op = "big-fb";
        class M0 extends Uo {
          createBucket(r) {
            return new zm(r)
          }
          constructor(r, n) {
            super(r, P0, n), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(r) {
            r === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = jm({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(op) && this.heatmapFbos.delete(op)
          }
          queryRadius(r) {
            return rc("heatmap-radius", this, r)
          }
          queryIntersectsFeature({
            queryGeometry: r,
            feature: n,
            featureState: a,
            geometry: _,
            transform: f,
            pixelsToTileUnits: m,
            unwrappedTileID: v,
            getElevation: b
          }) {
            return Mm({
              queryGeometry: r,
              size: this.paint.get("heatmap-radius").evaluate(n, a) * m,
              transform: f,
              unwrappedTileID: v,
              getElevation: b
            }, _)
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let Lm;
        var C0 = {
          get paint() {
            return Lm = Lm || new io({
              "hillshade-illumination-direction": new Xr(W.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new Xr(W.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new Xr(W.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new Xr(W.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new Xr(W.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new Xr(W.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new Xr(W.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new Xr(W.paint_hillshade["hillshade-method"])
            })
          }
        };
        class I0 extends Uo {
          constructor(r, n) {
            super(r, C0, n), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let r = this.paint.get("hillshade-illumination-direction").values,
              n = this.paint.get("hillshade-illumination-altitude").values,
              a = this.paint.get("hillshade-highlight-color").values,
              _ = this.paint.get("hillshade-shadow-color").values;
            const f = Math.max(r.length, n.length, a.length, _.length);
            r = r.concat(Array(f - r.length).fill(r.at(-1))), n = n.concat(Array(f - n.length).fill(n.at(-1))), a = a.concat(Array(f - a.length).fill(a.at(-1))), _ = _.concat(Array(f - _.length).fill(_.at(-1)));
            const m = n.map(Or);
            return {
              directionRadians: r.map(Or),
              altitudeRadians: m,
              shadowColor: _,
              highlightColor: a
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let Dm;
        var z0 = {
          get paint() {
            return Dm = Dm || new io({
              "color-relief-opacity": new Xr(W["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new iu(W["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class sp {
          constructor(r, n, a, _) {
            this.context = r, this.format = a, this.texture = r.gl.createTexture(), this.update(n, _)
          }
          update(r, n, a) {
            const {
              width: _,
              height: f
            } = r, m = !(this.size && this.size[0] === _ && this.size[1] === f || a), {
              context: v
            } = this, {
              gl: b
            } = v;
            if (this.useMipmap = !!(n && n.useMipmap), b.bindTexture(b.TEXTURE_2D, this.texture), v.pixelStoreUnpackFlipY.set(!1), v.pixelStoreUnpack.set(1), v.pixelStoreUnpackPremultiplyAlpha.set(this.format === b.RGBA && (!n || n.premultiply !== !1)), m) this.size = [_, f], r instanceof HTMLImageElement || r instanceof HTMLCanvasElement || r instanceof HTMLVideoElement || r instanceof ImageData || de(r) ? b.texImage2D(b.TEXTURE_2D, 0, this.format, this.format, b.UNSIGNED_BYTE, r) : b.texImage2D(b.TEXTURE_2D, 0, this.format, _, f, 0, this.format, b.UNSIGNED_BYTE, r.data);
            else {
              const {
                x: S,
                y: M
              } = a || {
                x: 0,
                y: 0
              };
              r instanceof HTMLImageElement || r instanceof HTMLCanvasElement || r instanceof HTMLVideoElement || r instanceof ImageData || de(r) ? b.texSubImage2D(b.TEXTURE_2D, 0, S, M, b.RGBA, b.UNSIGNED_BYTE, r) : b.texSubImage2D(b.TEXTURE_2D, 0, S, M, _, f, b.RGBA, b.UNSIGNED_BYTE, r.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && b.generateMipmap(b.TEXTURE_2D), v.pixelStoreUnpackFlipY.setDefault(), v.pixelStoreUnpack.setDefault(), v.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(r, n, a) {
            const {
              context: _
            } = this, {
              gl: f
            } = _;
            f.bindTexture(f.TEXTURE_2D, this.texture), a !== f.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = f.LINEAR), r !== this.filter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, r), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, a || r), this.filter = r), n !== this.wrap && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, n), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, n), this.wrap = n)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: r
            } = this.context;
            r.deleteTexture(this.texture), this.texture = null
          }
        }
        class Rm {
          constructor(r, n, a, _ = 1, f = 1, m = 1, v = 0) {
            if (this.uid = r, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void nr(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const b = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), a) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = _, this.greenFactor = f, this.blueFactor = m, this.baseShift = v;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let S = 0; S < b; S++) this.data[this._idx(-1, S)] = this.data[this._idx(0, S)], this.data[this._idx(b, S)] = this.data[this._idx(b - 1, S)], this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)], this.data[this._idx(S, b)] = this.data[this._idx(S, b - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(b, -1)] = this.data[this._idx(b - 1, 0)], this.data[this._idx(-1, b)] = this.data[this._idx(0, b - 1)], this.data[this._idx(b, b)] = this.data[this._idx(b - 1, b - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let S = 0; S < b; S++)
              for (let M = 0; M < b; M++) {
                const j = this.get(S, M);
                j > this.max && (this.max = j), j < this.min && (this.min = j)
              }
          }
          get(r, n) {
            const a = new Uint8Array(this.data.buffer),
              _ = 4 * this._idx(r, n);
            return this.unpack(a[_], a[_ + 1], a[_ + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(r, n) {
            if (r < -1 || r >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (r + 1)
          }
          unpack(r, n, a) {
            return r * this.redFactor + n * this.greenFactor + a * this.blueFactor - this.baseShift
          }
          pack(r) {
            return Bm(r, this.getUnpackVector())
          }
          getPixels() {
            return new To({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(r, n, a) {
            if (this.dim !== r.dim) throw new Error("dem dimension mismatch");
            let _ = n * this.dim,
              f = n * this.dim + this.dim,
              m = a * this.dim,
              v = a * this.dim + this.dim;
            switch (n) {
              case -1:
                _ = f - 1;
                break;
              case 1:
                f = _ + 1
            }
            switch (a) {
              case -1:
                m = v - 1;
                break;
              case 1:
                v = m + 1
            }
            const b = -n * this.dim,
              S = -a * this.dim;
            for (let M = m; M < v; M++)
              for (let j = _; j < f; j++) this.data[this._idx(j, M)] = r.data[this._idx(j + b, M + S)]
          }
        }

        function Bm(i, r) {
          const n = r[0],
            a = r[1],
            _ = r[2],
            f = r[3],
            m = Math.min(n, a, _),
            v = Math.round((i + f) / m);
          return {
            r: Math.floor(v * m / n) % 256,
            g: Math.floor(v * m / a) % 256,
            b: Math.floor(v * m / _) % 256
          }
        }
        Sr("DEMData", Rm);
        class A0 extends Uo {
          constructor(r, n) {
            super(r, z0, n)
          }
          _createColorRamp(r) {
            const n = {
                elevationStops: [],
                colorStops: []
              },
              a = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (a instanceof Xa && a._styleExpression.expression instanceof Un) {
              this.colorRampExpression = a;
              const m = a._styleExpression.expression;
              n.elevationStops = m.labels, n.colorStops = [];
              for (const v of n.elevationStops) n.colorStops.push(m.evaluate({
                globals: {
                  elevation: v
                }
              }))
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [Ur.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= r) return n;
            const _ = {
                elevationStops: [],
                colorStops: []
              },
              f = (n.elevationStops.length - 1) / (r - 1);
            for (let m = 0; m < n.elevationStops.length - .5; m += f) _.elevationStops.push(n.elevationStops[Math.round(m)]), _.colorStops.push(n.colorStops[Math.round(m)]);
            return nr(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${r}, provided: ${n.elevationStops.length}`), _
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(r, n, a) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const _ = this._createColorRamp(n),
              f = new To({
                width: _.colorStops.length,
                height: 1
              }),
              m = new To({
                width: _.colorStops.length,
                height: 1
              });
            for (let v = 0; v < _.elevationStops.length; v++) {
              const b = Bm(_.elevationStops[v], a);
              m.setPixel(0, v, new Ur(b.r / 255, b.g / 255, b.b / 255, 1)), f.setPixel(0, v, _.colorStops[v])
            }
            return this.colorRampTextures = {
              elevationTexture: new sp(r, m, r.gl.RGBA),
              colorTexture: new sp(r, f, r.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const E0 = bi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: j0
          } = E0;

        function Lh(i, r, n) {
          const a = n.patternDependencies;
          let _ = !1;
          for (const f of r) {
            const m = f.paint.get(`${i}-pattern`);
            m.isConstant() || (_ = !0);
            const v = m.constantOr(null);
            v && (_ = !0, a[v.to] = !0, a[v.from] = !0)
          }
          return _
        }

        function ap(i, r, n, a, _) {
          const {
            zoom: f
          } = a, m = _.patternDependencies;
          for (const v of r) {
            const b = v.paint.get(`${i}-pattern`).value;
            if (b.kind !== "constant") {
              let S = b.evaluate({
                  zoom: f - 1
                }, n, {}, _.availableImages),
                M = b.evaluate({
                  zoom: f
                }, n, {}, _.availableImages),
                j = b.evaluate({
                  zoom: f + 1
                }, n, {}, _.availableImages);
              S = S && S.name ? S.name : S, M = M && M.name ? M.name : M, j = j && j.name ? j.name : j, m[S] = !0, m[M] = !0, m[j] = !0, n.patterns[v.id] = {
                min: S,
                mid: M,
                max: j
              }
            }
          }
          return n
        }

        function Fm(i, r, n, a, _) {
          let f;
          if (_ === (function(m, v, b, S) {
              let M = 0;
              for (let j = v, O = b - S; j < b; j += S) M += (m[O] - m[j]) * (m[j + 1] + m[O + 1]), O = j;
              return M
            })(i, r, n, a) > 0)
            for (let m = r; m < n; m += a) f = Vm(m / a | 0, i[m], i[m + 1], f);
          else
            for (let m = n - a; m >= r; m -= a) f = Vm(m / a | 0, i[m], i[m + 1], f);
          return f && nc(f, f.next) && (Il(f), f = f.next), f
        }

        function au(i, r) {
          if (!i) return i;
          r || (r = i);
          let n, a = i;
          do
            if (n = !1, a.steiner || !nc(a, a.next) && Mi(a.prev, a, a.next) !== 0) a = a.next;
            else {
              if (Il(a), a = r = a.prev, a === a.next) break;
              n = !0
            } while (n || a !== r);
          return r
        }

        function Pl(i, r, n, a, _, f, m) {
          if (!i) return;
          !m && f && (function(b, S, M, j) {
            let O = b;
            do O.z === 0 && (O.z = up(O.x, O.y, S, M, j)), O.prevZ = O.prev, O.nextZ = O.next, O = O.next; while (O !== b);
            O.prevZ.nextZ = null, O.prevZ = null, (function(N) {
              let H, J = 1;
              do {
                let rt, ht = N;
                N = null;
                let Ot = null;
                for (H = 0; ht;) {
                  H++;
                  let bt = ht,
                    Mt = 0;
                  for (let le = 0; le < J && (Mt++, bt = bt.nextZ, bt); le++);
                  let te = J;
                  for (; Mt > 0 || te > 0 && bt;) Mt !== 0 && (te === 0 || !bt || ht.z <= bt.z) ? (rt = ht, ht = ht.nextZ, Mt--) : (rt = bt, bt = bt.nextZ, te--), Ot ? Ot.nextZ = rt : N = rt, rt.prevZ = Ot, Ot = rt;
                  ht = bt
                }
                Ot.nextZ = null, J *= 2
              } while (H > 1)
            })(O)
          })(i, a, _, f);
          let v = i;
          for (; i.prev !== i.next;) {
            const b = i.prev,
              S = i.next;
            if (f ? D0(i, a, _, f) : L0(i)) r.push(b.i, i.i, S.i), Il(i), i = S.next, v = S.next;
            else if ((i = S) === v) {
              m ? m === 1 ? Pl(i = R0(au(i), r), r, n, a, _, f, 2) : m === 2 && B0(i, r, n, a, _, f) : Pl(au(i), r, n, a, _, f, 1);
              break
            }
          }
        }

        function L0(i) {
          const r = i.prev,
            n = i,
            a = i.next;
          if (Mi(r, n, a) >= 0) return !1;
          const _ = r.x,
            f = n.x,
            m = a.x,
            v = r.y,
            b = n.y,
            S = a.y,
            M = Math.min(_, f, m),
            j = Math.min(v, b, S),
            O = Math.max(_, f, m),
            N = Math.max(v, b, S);
          let H = a.next;
          for (; H !== r;) {
            if (H.x >= M && H.x <= O && H.y >= j && H.y <= N && Ml(_, v, f, b, m, S, H.x, H.y) && Mi(H.prev, H, H.next) >= 0) return !1;
            H = H.next
          }
          return !0
        }

        function D0(i, r, n, a) {
          const _ = i.prev,
            f = i,
            m = i.next;
          if (Mi(_, f, m) >= 0) return !1;
          const v = _.x,
            b = f.x,
            S = m.x,
            M = _.y,
            j = f.y,
            O = m.y,
            N = Math.min(v, b, S),
            H = Math.min(M, j, O),
            J = Math.max(v, b, S),
            rt = Math.max(M, j, O),
            ht = up(N, H, r, n, a),
            Ot = up(J, rt, r, n, a);
          let bt = i.prevZ,
            Mt = i.nextZ;
          for (; bt && bt.z >= ht && Mt && Mt.z <= Ot;) {
            if (bt.x >= N && bt.x <= J && bt.y >= H && bt.y <= rt && bt !== _ && bt !== m && Ml(v, M, b, j, S, O, bt.x, bt.y) && Mi(bt.prev, bt, bt.next) >= 0 || (bt = bt.prevZ, Mt.x >= N && Mt.x <= J && Mt.y >= H && Mt.y <= rt && Mt !== _ && Mt !== m && Ml(v, M, b, j, S, O, Mt.x, Mt.y) && Mi(Mt.prev, Mt, Mt.next) >= 0)) return !1;
            Mt = Mt.nextZ
          }
          for (; bt && bt.z >= ht;) {
            if (bt.x >= N && bt.x <= J && bt.y >= H && bt.y <= rt && bt !== _ && bt !== m && Ml(v, M, b, j, S, O, bt.x, bt.y) && Mi(bt.prev, bt, bt.next) >= 0) return !1;
            bt = bt.prevZ
          }
          for (; Mt && Mt.z <= Ot;) {
            if (Mt.x >= N && Mt.x <= J && Mt.y >= H && Mt.y <= rt && Mt !== _ && Mt !== m && Ml(v, M, b, j, S, O, Mt.x, Mt.y) && Mi(Mt.prev, Mt, Mt.next) >= 0) return !1;
            Mt = Mt.nextZ
          }
          return !0
        }

        function R0(i, r) {
          let n = i;
          do {
            const a = n.prev,
              _ = n.next.next;
            !nc(a, _) && qm(a, n, n.next, _) && Cl(a, _) && Cl(_, a) && (r.push(a.i, n.i, _.i), Il(n), Il(n.next), n = i = _), n = n.next
          } while (n !== i);
          return au(n)
        }

        function B0(i, r, n, a, _, f) {
          let m = i;
          do {
            let v = m.next.next;
            for (; v !== m.prev;) {
              if (m.i !== v.i && V0(m, v)) {
                let b = Nm(m, v);
                return m = au(m, m.next), b = au(b, b.next), Pl(m, r, n, a, _, f, 0), void Pl(b, r, n, a, _, f, 0)
              }
              v = v.next
            }
            m = m.next
          } while (m !== i)
        }

        function F0(i, r) {
          let n = i.x - r.x;
          return n === 0 && (n = i.y - r.y, n === 0) && (n = (i.next.y - i.y) / (i.next.x - i.x) - (r.next.y - r.y) / (r.next.x - r.x)), n
        }

        function O0(i, r) {
          const n = (function(_, f) {
            let m = f;
            const v = _.x,
              b = _.y;
            let S, M = -1 / 0;
            if (nc(_, m)) return m;
            do {
              if (nc(_, m.next)) return m.next;
              if (b <= m.y && b >= m.next.y && m.next.y !== m.y) {
                const J = m.x + (b - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
                if (J <= v && J > M && (M = J, S = m.x < m.next.x ? m : m.next, J === v)) return S
              }
              m = m.next
            } while (m !== f);
            if (!S) return null;
            const j = S,
              O = S.x,
              N = S.y;
            let H = 1 / 0;
            m = S;
            do {
              if (v >= m.x && m.x >= O && v !== m.x && Om(b < N ? v : M, b, O, N, b < N ? M : v, b, m.x, m.y)) {
                const J = Math.abs(b - m.y) / (v - m.x);
                Cl(m, _) && (J < H || J === H && (m.x > S.x || m.x === S.x && q0(S, m))) && (S = m, H = J)
              }
              m = m.next
            } while (m !== j);
            return S
          })(i, r);
          if (!n) return r;
          const a = Nm(n, i);
          return au(a, a.next), au(n, n.next)
        }

        function q0(i, r) {
          return Mi(i.prev, i, r.prev) < 0 && Mi(r.next, i, i.next) < 0
        }

        function up(i, r, n, a, _) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * _ | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = (r - a) * _ | 0) | r << 8)) | r << 4)) | r << 2)) | r << 1)) << 1
        }

        function N0(i) {
          let r = i,
            n = i;
          do(r.x < n.x || r.x === n.x && r.y < n.y) && (n = r), r = r.next; while (r !== i);
          return n
        }

        function Om(i, r, n, a, _, f, m, v) {
          return (_ - m) * (r - v) >= (i - m) * (f - v) && (i - m) * (a - v) >= (n - m) * (r - v) && (n - m) * (f - v) >= (_ - m) * (a - v)
        }

        function Ml(i, r, n, a, _, f, m, v) {
          return !(i === m && r === v) && Om(i, r, n, a, _, f, m, v)
        }

        function V0(i, r) {
          return i.next.i !== r.i && i.prev.i !== r.i && !(function(n, a) {
            let _ = n;
            do {
              if (_.i !== n.i && _.next.i !== n.i && _.i !== a.i && _.next.i !== a.i && qm(_, _.next, n, a)) return !0;
              _ = _.next
            } while (_ !== n);
            return !1
          })(i, r) && (Cl(i, r) && Cl(r, i) && (function(n, a) {
            let _ = n,
              f = !1;
            const m = (n.x + a.x) / 2,
              v = (n.y + a.y) / 2;
            do _.y > v != _.next.y > v && _.next.y !== _.y && m < (_.next.x - _.x) * (v - _.y) / (_.next.y - _.y) + _.x && (f = !f), _ = _.next; while (_ !== n);
            return f
          })(i, r) && (Mi(i.prev, i, r.prev) || Mi(i, r.prev, r)) || nc(i, r) && Mi(i.prev, i, i.next) > 0 && Mi(r.prev, r, r.next) > 0)
        }

        function Mi(i, r, n) {
          return (r.y - i.y) * (n.x - r.x) - (r.x - i.x) * (n.y - r.y)
        }

        function nc(i, r) {
          return i.x === r.x && i.y === r.y
        }

        function qm(i, r, n, a) {
          const _ = Rh(Mi(i, r, n)),
            f = Rh(Mi(i, r, a)),
            m = Rh(Mi(n, a, i)),
            v = Rh(Mi(n, a, r));
          return _ !== f && m !== v || !(_ !== 0 || !Dh(i, n, r)) || !(f !== 0 || !Dh(i, a, r)) || !(m !== 0 || !Dh(n, i, a)) || !(v !== 0 || !Dh(n, r, a))
        }

        function Dh(i, r, n) {
          return r.x <= Math.max(i.x, n.x) && r.x >= Math.min(i.x, n.x) && r.y <= Math.max(i.y, n.y) && r.y >= Math.min(i.y, n.y)
        }

        function Rh(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0
        }

        function Cl(i, r) {
          return Mi(i.prev, i, i.next) < 0 ? Mi(i, r, i.next) >= 0 && Mi(i, i.prev, r) >= 0 : Mi(i, r, i.prev) < 0 || Mi(i, i.next, r) < 0
        }

        function Nm(i, r) {
          const n = cp(i.i, i.x, i.y),
            a = cp(r.i, r.x, r.y),
            _ = i.next,
            f = r.prev;
          return i.next = r, r.prev = i, n.next = _, _.prev = n, a.next = n, n.prev = a, f.next = a, a.prev = f, a
        }

        function Vm(i, r, n, a) {
          const _ = cp(i, r, n);
          return a ? (_.next = a.next, _.prev = a, a.next.prev = _, a.next = _) : (_.prev = _, _.next = _), _
        }

        function Il(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
        }

        function cp(i, r, n) {
          return {
            i,
            x: r,
            y: n,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class ic {
          constructor(r, n) {
            if (n > r) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = r, this._minGranularity = n
          }
          getGranularityForZoomLevel(r) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << r)), this._minGranularity, 1)
          }
        }
        class Bh {
          constructor(r) {
            this.fill = r.fill, this.line = r.line, this.tile = r.tile, this.stencil = r.stencil, this.circle = r.circle
          }
        }
        Bh.noSubdivision = new Bh({
          fill: new ic(0, 0),
          line: new ic(0, 0),
          tile: new ic(0, 0),
          stencil: new ic(0, 0),
          circle: 1
        }), Sr("SubdivisionGranularityExpression", ic), Sr("SubdivisionGranularitySetting", Bh);
        const oc = -32768,
          zl = 32767;
        class U0 {
          constructor(r, n) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = r, this._granularityCellSize = ne / r, this._canonical = n
          }
          _getKey(r, n) {
            return (r += 32768) << 16 | n + 32768
          }
          _vertexToIndex(r, n) {
            if (r < -32768 || n < -32768 || r > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const a = 0 | Math.round(r),
              _ = 0 | Math.round(n),
              f = this._getKey(a, _);
            if (this._vertexDictionary.has(f)) return this._vertexDictionary.get(f);
            const m = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(f, m), this._vertexBuffer.push(a, _), m
          }
          _subdivideTrianglesScanline(r) {
            if (this._granularity < 2) return (function(_, f) {
              const m = [];
              for (let v = 0; v < f.length; v += 3) {
                const b = f[v],
                  S = f[v + 1],
                  M = f[v + 2],
                  j = _[2 * b],
                  O = _[2 * b + 1];
                (_[2 * S] - j) * (_[2 * M + 1] - O) - (_[2 * S + 1] - O) * (_[2 * M] - j) > 0 ? (m.push(b), m.push(M), m.push(S)) : (m.push(b), m.push(S), m.push(M))
              }
              return m
            })(this._vertexBuffer, r);
            const n = [],
              a = r.length;
            for (let _ = 0; _ < a; _ += 3) {
              const f = [r[_ + 0], r[_ + 1], r[_ + 2]],
                m = [this._vertexBuffer[2 * r[_ + 0] + 0], this._vertexBuffer[2 * r[_ + 0] + 1], this._vertexBuffer[2 * r[_ + 1] + 0], this._vertexBuffer[2 * r[_ + 1] + 1], this._vertexBuffer[2 * r[_ + 2] + 0], this._vertexBuffer[2 * r[_ + 2] + 1]];
              let v = 1 / 0,
                b = 1 / 0,
                S = -1 / 0,
                M = -1 / 0;
              for (let J = 0; J < 3; J++) {
                const rt = m[2 * J],
                  ht = m[2 * J + 1];
                v = Math.min(v, rt), S = Math.max(S, rt), b = Math.min(b, ht), M = Math.max(M, ht)
              }
              if (v === S || b === M) continue;
              const j = Math.floor(v / this._granularityCellSize),
                O = Math.ceil(S / this._granularityCellSize),
                N = Math.floor(b / this._granularityCellSize),
                H = Math.ceil(M / this._granularityCellSize);
              if (j !== O || N !== H)
                for (let J = N; J < H; J++) {
                  const rt = this._scanlineGenerateVertexRingForCellRow(J, m, f);
                  Z0(this._vertexBuffer, rt, n)
                } else n.push(...f)
            }
            return n
          }
          _scanlineGenerateVertexRingForCellRow(r, n, a) {
            const _ = r * this._granularityCellSize,
              f = _ + this._granularityCellSize,
              m = [];
            for (let v = 0; v < 3; v++) {
              const b = n[2 * v],
                S = n[2 * v + 1],
                M = n[2 * (v + 1) % 6],
                j = n[(2 * (v + 1) + 1) % 6],
                O = n[2 * (v + 2) % 6],
                N = n[(2 * (v + 2) + 1) % 6],
                H = M - b,
                J = j - S,
                rt = H === 0,
                ht = J === 0,
                Ot = (_ - S) / J,
                bt = (f - S) / J,
                Mt = Math.min(Ot, bt),
                te = Math.max(Ot, bt);
              if (!ht && (Mt >= 1 || te <= 0) || ht && (S < _ || S > f)) {
                j >= _ && j <= f && m.push(a[(v + 1) % 3]);
                continue
              }!ht && Mt > 0 && m.push(this._vertexToIndex(b + H * Mt, S + J * Mt));
              const le = b + H * Math.max(Mt, 0),
                Re = b + H * Math.min(te, 1);
              rt || this._generateIntraEdgeVertices(m, b, S, M, j, le, Re), !ht && te < 1 && m.push(this._vertexToIndex(b + H * te, S + J * te)), (ht || j >= _ && j <= f) && m.push(a[(v + 1) % 3]), !ht && (j <= _ || j >= f) && this._generateInterEdgeVertices(m, b, S, M, j, O, N, Re, _, f)
            }
            return m
          }
          _generateIntraEdgeVertices(r, n, a, _, f, m, v) {
            const b = _ - n,
              S = f - a,
              M = S === 0,
              j = M ? Math.min(n, _) : Math.min(m, v),
              O = M ? Math.max(n, _) : Math.max(m, v),
              N = Math.floor(j / this._granularityCellSize) + 1,
              H = Math.ceil(O / this._granularityCellSize) - 1;
            if (M ? n < _ : m < v)
              for (let J = N; J <= H; J++) {
                const rt = J * this._granularityCellSize;
                r.push(this._vertexToIndex(rt, a + S * (rt - n) / b))
              } else
                for (let J = H; J >= N; J--) {
                  const rt = J * this._granularityCellSize;
                  r.push(this._vertexToIndex(rt, a + S * (rt - n) / b))
                }
          }
          _generateInterEdgeVertices(r, n, a, _, f, m, v, b, S, M) {
            const j = f - a,
              O = m - _,
              N = v - f,
              H = (S - f) / N,
              J = (M - f) / N,
              rt = Math.min(H, J),
              ht = Math.max(H, J),
              Ot = _ + O * rt;
            let bt = Math.floor(Math.min(Ot, b) / this._granularityCellSize) + 1,
              Mt = Math.ceil(Math.max(Ot, b) / this._granularityCellSize) - 1,
              te = b < Ot;
            const le = N === 0;
            if (le && (v === S || v === M)) return;
            if (le || rt >= 1 || ht <= 0) {
              const br = a - v,
                ar = m + (n - m) * Math.min((S - v) / br, (M - v) / br);
              bt = Math.floor(Math.min(ar, b) / this._granularityCellSize) + 1, Mt = Math.ceil(Math.max(ar, b) / this._granularityCellSize) - 1, te = b < ar
            }
            const Re = j > 0 ? M : S;
            if (te)
              for (let br = bt; br <= Mt; br++) r.push(this._vertexToIndex(br * this._granularityCellSize, Re));
            else
              for (let br = Mt; br >= bt; br--) r.push(this._vertexToIndex(br * this._granularityCellSize, Re))
          }
          _generateOutline(r) {
            const n = [];
            for (const a of r) {
              const _ = uu(a, this._granularity, !0),
                f = this._pointArrayToIndices(_),
                m = [];
              for (let v = 1; v < f.length; v++) m.push(f[v - 1]), m.push(f[v]);
              n.push(m)
            }
            return n
          }
          _handlePoles(r) {
            let n = !1,
              a = !1;
            this._canonical && (this._canonical.y === 0 && (n = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)), (n || a) && this._fillPoles(r, n, a)
          }
          _ensureNoPoleVertices() {
            const r = this._vertexBuffer;
            for (let n = 0; n < r.length; n += 2) {
              const a = r[n + 1];
              a === oc && (r[n + 1] = -32767), a === zl && (r[n + 1] = 32766)
            }
          }
          _generatePoleQuad(r, n, a, _, f, m) {
            _ > f != (m === oc) ? (r.push(n), r.push(a), r.push(this._vertexToIndex(_, m)), r.push(a), r.push(this._vertexToIndex(f, m)), r.push(this._vertexToIndex(_, m))) : (r.push(a), r.push(n), r.push(this._vertexToIndex(_, m)), r.push(this._vertexToIndex(f, m)), r.push(a), r.push(this._vertexToIndex(_, m)))
          }
          _fillPoles(r, n, a) {
            const _ = this._vertexBuffer,
              f = ne,
              m = r.length;
            for (let v = 2; v < m; v += 3) {
              const b = r[v - 2],
                S = r[v - 1],
                M = r[v],
                j = _[2 * b],
                O = _[2 * b + 1],
                N = _[2 * S],
                H = _[2 * S + 1],
                J = _[2 * M],
                rt = _[2 * M + 1];
              n && (O === 0 && H === 0 && this._generatePoleQuad(r, b, S, j, N, oc), H === 0 && rt === 0 && this._generatePoleQuad(r, S, M, N, J, oc), rt === 0 && O === 0 && this._generatePoleQuad(r, M, b, J, j, oc)), a && (O === f && H === f && this._generatePoleQuad(r, b, S, j, N, zl), H === f && rt === f && this._generatePoleQuad(r, S, M, N, J, zl), rt === f && O === f && this._generatePoleQuad(r, M, b, J, j, zl))
            }
          }
          _initializeVertices(r) {
            for (let n = 0; n < r.length; n += 2) this._vertexToIndex(r[n], r[n + 1])
          }
          subdividePolygonInternal(r, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: a,
              holeIndices: _
            } = (function(v) {
              const b = [],
                S = [];
              for (const M of v)
                if (M.length !== 0) {
                  M !== v[0] && b.push(S.length / 2);
                  for (let j = 0; j < M.length; j++) S.push(M[j].x), S.push(M[j].y)
                } return {
                flattened: S,
                holeIndices: b
              }
            })(r);
            let f;
            this._initializeVertices(a);
            try {
              const v = (function(S, M, j = 2) {
                  const O = M && M.length,
                    N = O ? M[0] * j : S.length;
                  let H = Fm(S, 0, N, j, !0);
                  const J = [];
                  if (!H || H.next === H.prev) return J;
                  let rt, ht, Ot;
                  if (O && (H = (function(bt, Mt, te, le) {
                      const Re = [];
                      for (let br = 0, ar = Mt.length; br < ar; br++) {
                        const yr = Fm(bt, Mt[br] * le, br < ar - 1 ? Mt[br + 1] * le : bt.length, le, !1);
                        yr === yr.next && (yr.steiner = !0), Re.push(N0(yr))
                      }
                      Re.sort(F0);
                      for (let br = 0; br < Re.length; br++) te = O0(Re[br], te);
                      return te
                    })(S, M, H, j)), S.length > 80 * j) {
                    rt = S[0], ht = S[1];
                    let bt = rt,
                      Mt = ht;
                    for (let te = j; te < N; te += j) {
                      const le = S[te],
                        Re = S[te + 1];
                      le < rt && (rt = le), Re < ht && (ht = Re), le > bt && (bt = le), Re > Mt && (Mt = Re)
                    }
                    Ot = Math.max(bt - rt, Mt - ht), Ot = Ot !== 0 ? 32767 / Ot : 0
                  }
                  return Pl(H, J, j, rt, ht, Ot, 0), J
                })(a, _),
                b = this._convertIndices(a, v);
              f = this._subdivideTrianglesScanline(b)
            } catch (v) {
              console.error(v)
            }
            let m = [];
            return n && (m = this._generateOutline(r)), this._ensureNoPoleVertices(), this._handlePoles(f), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: f,
              indicesLineList: m
            }
          }
          _convertIndices(r, n) {
            const a = [];
            for (let _ = 0; _ < n.length; _++) a.push(this._vertexToIndex(r[2 * n[_]], r[2 * n[_] + 1]));
            return a
          }
          _pointArrayToIndices(r) {
            const n = [];
            for (let a = 0; a < r.length; a++) {
              const _ = r[a];
              n.push(this._vertexToIndex(_.x, _.y))
            }
            return n
          }
        }

        function Um(i, r, n, a = !0) {
          return new U0(n, r).subdividePolygonInternal(i, a)
        }

        function uu(i, r, n = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const a = i[0],
            _ = i[i.length - 1],
            f = n && (a.x !== _.x || a.y !== _.y);
          if (r < 2) return f ? [...i, i[0]] : [...i];
          const m = Math.floor(ne / r),
            v = [];
          v.push(new R(i[0].x, i[0].y));
          const b = i.length,
            S = f ? b : b - 1;
          for (let M = 0; M < S; M++) {
            const j = i[M],
              O = M < b - 1 ? i[M + 1] : i[0],
              N = j.x,
              H = j.y,
              J = O.x,
              rt = O.y,
              ht = N !== J,
              Ot = H !== rt;
            if (!ht && !Ot) continue;
            const bt = J - N,
              Mt = rt - H,
              te = Math.abs(bt),
              le = Math.abs(Mt);
            let Re = N,
              br = H;
            for (;;) {
              const yr = bt > 0 ? (Math.floor(Re / m) + 1) * m : (Math.ceil(Re / m) - 1) * m,
                Yr = Mt > 0 ? (Math.floor(br / m) + 1) * m : (Math.ceil(br / m) - 1) * m,
                fr = Math.abs(Re - yr),
                vr = Math.abs(br - Yr),
                ke = Math.abs(Re - J),
                an = Math.abs(br - rt),
                hn = ht ? fr / te : Number.POSITIVE_INFINITY,
                Qr = Ot ? vr / le : Number.POSITIVE_INFINITY;
              if ((ke <= fr || !ht) && (an <= vr || !Ot)) break;
              if (hn < Qr && ht || !Ot) {
                Re = yr, br += Mt * hn;
                const Wr = new R(Re, Math.round(br));
                v[v.length - 1].x === Wr.x && v[v.length - 1].y === Wr.y || v.push(Wr)
              } else {
                Re += bt * Qr, br = Yr;
                const Wr = new R(Math.round(Re), br);
                v[v.length - 1].x === Wr.x && v[v.length - 1].y === Wr.y || v.push(Wr)
              }
            }
            const ar = new R(J, rt);
            v[v.length - 1].x === ar.x && v[v.length - 1].y === ar.y || v.push(ar)
          }
          return v
        }

        function Z0(i, r, n) {
          if (r.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let a = 0,
            _ = i[2 * r[0]];
          for (let b = 1; b < r.length; b++) {
            const S = i[2 * r[b]];
            S < _ && (_ = S, a = b)
          }
          const f = r.length;
          let m = a,
            v = (m + 1) % f;
          for (;;) {
            const b = m - 1 >= 0 ? m - 1 : f - 1,
              S = (v + 1) % f,
              M = i[2 * r[b]],
              j = i[2 * r[S]],
              O = i[2 * r[m]],
              N = i[2 * r[m] + 1],
              H = i[2 * r[v] + 1];
            let J = !1;
            if (M < j) J = !0;
            else if (M > j) J = !1;
            else {
              const rt = H - N,
                ht = -(i[2 * r[v]] - O),
                Ot = N < H ? 1 : -1;
              ((M - O) * rt + (i[2 * r[b] + 1] - N) * ht) * Ot > ((j - O) * rt + (i[2 * r[S] + 1] - N) * ht) * Ot && (J = !0)
            }
            if (J) {
              const rt = r[b],
                ht = r[m],
                Ot = r[v];
              rt !== ht && rt !== Ot && ht !== Ot && n.push(Ot, ht, rt), m--, m < 0 && (m = f - 1)
            } else {
              const rt = r[S],
                ht = r[m],
                Ot = r[v];
              rt !== ht && rt !== Ot && ht !== Ot && n.push(Ot, ht, rt), v++, v >= f && (v = 0)
            }
            if (b === S) break
          }
        }

        function Zm(i, r, n, a, _, f, m, v, b) {
          const S = _.length / 2,
            M = m && v && b;
          if (S < Tn.MAX_VERTEX_ARRAY_LENGTH) {
            const j = r.prepareSegment(S, n, a),
              O = j.vertexLength;
            for (let J = 0; J < f.length; J += 3) a.emplaceBack(O + f[J], O + f[J + 1], O + f[J + 2]);
            let N, H;
            j.vertexLength += S, j.primitiveLength += f.length / 3, M && (H = m.prepareSegment(S, n, v), N = H.vertexLength, H.vertexLength += S);
            for (let J = 0; J < _.length; J += 2) i(_[J], _[J + 1]);
            if (M)
              for (let J = 0; J < b.length; J++) {
                const rt = b[J];
                for (let ht = 1; ht < rt.length; ht += 2) v.emplaceBack(N + rt[ht - 1], N + rt[ht]);
                H.primitiveLength += rt.length / 2
              }
          } else(function(j, O, N, H, J, rt) {
            const ht = [];
            for (let le = 0; le < H.length / 2; le++) ht.push(-1);
            const Ot = {
              count: 0
            };
            let bt = 0,
              Mt = j.getOrCreateLatestSegment(O, N),
              te = Mt.vertexLength;
            for (let le = 2; le < J.length; le += 3) {
              const Re = J[le - 2],
                br = J[le - 1],
                ar = J[le];
              let yr = ht[Re] < bt,
                Yr = ht[br] < bt,
                fr = ht[ar] < bt;
              Mt.vertexLength + ((yr ? 1 : 0) + (Yr ? 1 : 0) + (fr ? 1 : 0)) > Tn.MAX_VERTEX_ARRAY_LENGTH && (Mt = j.createNewSegment(O, N), bt = Ot.count, yr = !0, Yr = !0, fr = !0, te = 0);
              const vr = Al(ht, H, rt, Ot, Re, yr, Mt),
                ke = Al(ht, H, rt, Ot, br, Yr, Mt),
                an = Al(ht, H, rt, Ot, ar, fr, Mt);
              N.emplaceBack(te + vr - bt, te + ke - bt, te + an - bt), Mt.primitiveLength++
            }
          })(r, n, a, _, f, i), M && (function(j, O, N, H, J, rt) {
            const ht = [];
            for (let le = 0; le < H.length / 2; le++) ht.push(-1);
            const Ot = {
              count: 0
            };
            let bt = 0,
              Mt = j.getOrCreateLatestSegment(O, N),
              te = Mt.vertexLength;
            for (let le = 0; le < J.length; le++) {
              const Re = J[le];
              for (let br = 1; br < J[le].length; br += 2) {
                const ar = Re[br - 1],
                  yr = Re[br];
                let Yr = ht[ar] < bt,
                  fr = ht[yr] < bt;
                Mt.vertexLength + ((Yr ? 1 : 0) + (fr ? 1 : 0)) > Tn.MAX_VERTEX_ARRAY_LENGTH && (Mt = j.createNewSegment(O, N), bt = Ot.count, Yr = !0, fr = !0, te = 0);
                const vr = Al(ht, H, rt, Ot, ar, Yr, Mt),
                  ke = Al(ht, H, rt, Ot, yr, fr, Mt);
                N.emplaceBack(te + vr - bt, te + ke - bt), Mt.primitiveLength++
              }
            }
          })(m, n, v, _, b, i), r.forceNewSegmentOnNextPrepare(), m == null || m.forceNewSegmentOnNextPrepare()
        }

        function Al(i, r, n, a, _, f, m) {
          if (f) {
            const v = a.count;
            return n(r[2 * _], r[2 * _ + 1]), i[_] = a.count, a.count++, m.vertexLength++, v
          }
          return i[_]
        }
        class lp {
          constructor(r) {
            this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map((n => n.id)), this.index = r.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new dt, this.indexArray = new Pe, this.indexArray2 = new Fr, this.programConfigurations = new ea(r.layers, r.zoom), this.segments = new Tn, this.segments2 = new Tn, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(r, n, a) {
            this.hasDependencies = Lh("fill", this.layers, n);
            const _ = this.layers[0].layout.get("fill-sort-key"),
              f = !_.isConstant(),
              m = [];
            for (const {
                feature: v,
                id: b,
                index: S,
                sourceLayerIndex: M
              }
              of r) {
              const j = this.layers[0]._featureFilter.needGeometry,
                O = zs(v, j);
              if (!this.layers[0]._featureFilter.filter(new Kn(this.zoom), O, a)) continue;
              const N = f ? _.evaluate(O, {}, a, n.availableImages) : void 0,
                H = {
                  id: b,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: M,
                  index: S,
                  geometry: j ? O.geometry : fs(v),
                  patterns: {},
                  sortKey: N
                };
              m.push(H)
            }
            f && m.sort(((v, b) => v.sortKey - b.sortKey));
            for (const v of m) {
              const {
                geometry: b,
                index: S,
                sourceLayerIndex: M
              } = v;
              if (this.hasDependencies) {
                const j = ap("fill", this.layers, v, {
                  zoom: this.zoom
                }, n);
                this.patternFeatures.push(j)
              } else this.addFeature(v, b, S, a, {}, n.subdivisionGranularity);
              n.featureIndex.insert(r[S].feature, b, S, M, this.index)
            }
          }
          update(r, n, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, n, this.stateDependentLayers, {
              imagePositions: a
            })
          }
          addFeatures(r, n, a) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, n, a, r.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(r) {
            this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, j0), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.indexBuffer2 = r.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(r), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(r, n, a, _, f, m) {
            for (const v of Su(n, 500)) {
              const b = Um(v, _, m.fill.getGranularityForZoomLevel(_.z)),
                S = this.layoutVertexArray;
              Zm(((M, j) => {
                S.emplaceBack(M, j)
              }), this.segments, this.layoutVertexArray, this.indexArray, b.verticesFlattened, b.indicesTriangles, this.segments2, this.indexArray2, b.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, a, {
              imagePositions: f,
              canonical: _
            })
          }
        }
        let Gm, Hm;
        Sr("FillBucket", lp, {
          omit: ["layers", "patternFeatures"]
        });
        var G0 = {
          get paint() {
            return Hm = Hm || new io({
              "fill-antialias": new Xr(W.paint_fill["fill-antialias"]),
              "fill-opacity": new nn(W.paint_fill["fill-opacity"]),
              "fill-color": new nn(W.paint_fill["fill-color"]),
              "fill-outline-color": new nn(W.paint_fill["fill-outline-color"]),
              "fill-translate": new Xr(W.paint_fill["fill-translate"]),
              "fill-translate-anchor": new Xr(W.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new nu(W.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return Gm = Gm || new io({
              "fill-sort-key": new nn(W.layout_fill["fill-sort-key"])
            })
          }
        };
        class H0 extends Uo {
          constructor(r, n) {
            super(r, G0, n)
          }
          recalculate(r, n) {
            super.recalculate(r, n);
            const a = this.paint._values["fill-outline-color"];
            a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(r) {
            return new lp(r)
          }
          queryRadius() {
            return Eh(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: r,
            geometry: n,
            transform: a,
            pixelsToTileUnits: _
          }) {
            return Tm(jh(r, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, _), n)
          }
          isTileClipped() {
            return !0
          }
        }
        const W0 = bi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          $0 = bi([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: X0
          } = W0;
        class sc {
          constructor(r, n, a, _, f) {
            this.properties = {}, this.extent = a, this.type = 0, this.id = void 0, this._pbf = r, this._geometry = -1, this._keys = _, this._values = f, r.readFields(Y0, this, n)
          }
          loadGeometry() {
            const r = this._pbf;
            r.pos = this._geometry;
            const n = r.readVarint() + r.pos,
              a = [];
            let _, f = 1,
              m = 0,
              v = 0,
              b = 0;
            for (; r.pos < n;) {
              if (m <= 0) {
                const S = r.readVarint();
                f = 7 & S, m = S >> 3
              }
              if (m--, f === 1 || f === 2) v += r.readSVarint(), b += r.readSVarint(), f === 1 && (_ && a.push(_), _ = []), _ && _.push(new R(v, b));
              else {
                if (f !== 7) throw new Error(`unknown command ${f}`);
                _ && _.push(_[0].clone())
              }
            }
            return _ && a.push(_), a
          }
          bbox() {
            const r = this._pbf;
            r.pos = this._geometry;
            const n = r.readVarint() + r.pos;
            let a = 1,
              _ = 0,
              f = 0,
              m = 0,
              v = 1 / 0,
              b = -1 / 0,
              S = 1 / 0,
              M = -1 / 0;
            for (; r.pos < n;) {
              if (_ <= 0) {
                const j = r.readVarint();
                a = 7 & j, _ = j >> 3
              }
              if (_--, a === 1 || a === 2) f += r.readSVarint(), m += r.readSVarint(), f < v && (v = f), f > b && (b = f), m < S && (S = m), m > M && (M = m);
              else if (a !== 7) throw new Error(`unknown command ${a}`)
            }
            return [v, S, b, M]
          }
          toGeoJSON(r, n, a) {
            const _ = this.extent * Math.pow(2, a),
              f = this.extent * r,
              m = this.extent * n,
              v = this.loadGeometry();

            function b(O) {
              return [360 * (O.x + f) / _ - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (O.y + m) / _) * Math.PI)) - 90]
            }

            function S(O) {
              return O.map(b)
            }
            let M;
            if (this.type === 1) {
              const O = [];
              for (const H of v) O.push(H[0]);
              const N = S(O);
              M = O.length === 1 ? {
                type: "Point",
                coordinates: N[0]
              } : {
                type: "MultiPoint",
                coordinates: N
              }
            } else if (this.type === 2) {
              const O = v.map(S);
              M = O.length === 1 ? {
                type: "LineString",
                coordinates: O[0]
              } : {
                type: "MultiLineString",
                coordinates: O
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const O = (function(H) {
                    const J = H.length;
                    if (J <= 1) return [H];
                    const rt = [];
                    let ht, Ot;
                    for (let bt = 0; bt < J; bt++) {
                      const Mt = K0(H[bt]);
                      Mt !== 0 && (Ot === void 0 && (Ot = Mt < 0), Ot === Mt < 0 ? (ht && rt.push(ht), ht = [H[bt]]) : ht && ht.push(H[bt]))
                    }
                    return ht && rt.push(ht), rt
                  })(v),
                  N = [];
                for (const H of O) N.push(H.map(S));
                M = N.length === 1 ? {
                  type: "Polygon",
                  coordinates: N[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: N
                }
              }
            }
            const j = {
              type: "Feature",
              geometry: M,
              properties: this.properties
            };
            return this.id != null && (j.id = this.id), j
          }
        }

        function Y0(i, r, n) {
          i === 1 ? r.id = n.readVarint() : i === 2 ? (function(a, _) {
            const f = a.readVarint() + a.pos;
            for (; a.pos < f;) {
              const m = _._keys[a.readVarint()],
                v = _._values[a.readVarint()];
              _.properties[m] = v
            }
          })(n, r) : i === 3 ? r.type = n.readVarint() : i === 4 && (r._geometry = n.pos)
        }

        function K0(i) {
          let r = 0;
          for (let n, a, _ = 0, f = i.length, m = f - 1; _ < f; m = _++) n = i[_], a = i[m], r += (a.x - n.x) * (n.y + a.y);
          return r
        }
        sc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Wm {
          constructor(r, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = r, this._keys = [], this._values = [], this._features = [], r.readFields(J0, this, n), this.length = this._features.length
          }
          feature(r) {
            if (r < 0 || r >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[r];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new sc(this._pbf, n, this.extent, this._keys, this._values)
          }
        }

        function J0(i, r, n) {
          i === 15 ? r.version = n.readVarint() : i === 1 ? r.name = n.readString() : i === 5 ? r.extent = n.readVarint() : i === 2 ? r._features.push(n.pos) : i === 3 ? r._keys.push(n.readString()) : i === 4 && r._values.push((function(a) {
            let _ = null;
            const f = a.readVarint() + a.pos;
            for (; a.pos < f;) {
              const m = a.readVarint() >> 3;
              _ = m === 1 ? a.readString() : m === 2 ? a.readFloat() : m === 3 ? a.readDouble() : m === 4 ? a.readVarint64() : m === 5 ? a.readVarint() : m === 6 ? a.readSVarint() : m === 7 ? a.readBoolean() : null
            }
            if (_ == null) throw new Error("unknown feature value");
            return _
          })(n))
        }
        class $m {
          constructor(r, n) {
            this.layers = r.readFields(Q0, {}, n)
          }
        }

        function Q0(i, r, n) {
          if (i === 3) {
            const a = new Wm(n, n.readVarint() + n.pos);
            a.length && (r[a.name] = a)
          }
        }
        const _p = Math.pow(2, 13);

        function El(i, r, n, a, _, f, m, v) {
          i.emplaceBack(r, n, 2 * Math.floor(a * _p) + m, _ * _p * 2, f * _p * 2, Math.round(v))
        }
        class hp {
          constructor(r) {
            this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map((n => n.id)), this.index = r.index, this.hasDependencies = !1, this.layoutVertexArray = new kt, this.centroidVertexArray = new pt, this.indexArray = new Pe, this.programConfigurations = new ea(r.layers, r.zoom), this.segments = new Tn, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(r, n, a) {
            this.features = [], this.hasDependencies = Lh("fill-extrusion", this.layers, n);
            for (const {
                feature: _,
                id: f,
                index: m,
                sourceLayerIndex: v
              }
              of r) {
              const b = this.layers[0]._featureFilter.needGeometry,
                S = zs(_, b);
              if (!this.layers[0]._featureFilter.filter(new Kn(this.zoom), S, a)) continue;
              const M = {
                id: f,
                sourceLayerIndex: v,
                index: m,
                geometry: b ? S.geometry : fs(_),
                properties: _.properties,
                type: _.type,
                patterns: {}
              };
              this.hasDependencies ? this.features.push(ap("fill-extrusion", this.layers, M, {
                zoom: this.zoom
              }, n)) : this.addFeature(M, M.geometry, m, a, {}, n.subdivisionGranularity), n.featureIndex.insert(_, M.geometry, m, v, this.index, !0)
            }
          }
          addFeatures(r, n, a) {
            for (const _ of this.features) {
              const {
                geometry: f
              } = _;
              this.addFeature(_, f, _.index, n, a, r.subdivisionGranularity)
            }
          }
          update(r, n, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, n, this.stateDependentLayers, {
              imagePositions: a
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(r) {
            this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, X0), this.centroidVertexBuffer = r.createVertexBuffer(this.centroidVertexArray, $0.members, !0), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(r, n, a, _, f, m) {
            for (const v of Su(n, 500)) {
              const b = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                S = this.layoutVertexArray.length;
              this.processPolygon(b, _, r, v, m);
              const M = this.layoutVertexArray.length - S,
                j = Math.floor(b.x / b.sampleCount),
                O = Math.floor(b.y / b.sampleCount);
              for (let N = 0; N < M; N++) this.centroidVertexArray.emplaceBack(j, O)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, a, {
              imagePositions: f,
              canonical: _
            })
          }
          processPolygon(r, n, a, _, f) {
            if (_.length < 1 || Xm(_[0])) return;
            for (const j of _) j.length !== 0 && tb(r, j);
            const m = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              v = f.fill.getGranularityForZoomLevel(n.z),
              b = sc.types[a.type] === "Polygon";
            for (const j of _) {
              if (j.length === 0 || Xm(j)) continue;
              const O = uu(j, v, b);
              this._generateSideFaces(O, m)
            }
            if (!b) return;
            const S = Um(_, n, v, !1),
              M = this.layoutVertexArray;
            Zm(((j, O) => {
              El(M, j, O, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles)
          }
          _generateSideFaces(r, n) {
            let a = 0;
            for (let _ = 1; _ < r.length; _++) {
              const f = r[_],
                m = r[_ - 1];
              if (eb(f, m)) continue;
              n.segment.vertexLength + 4 > Tn.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const v = f.sub(m)._perp()._unit(),
                b = m.dist(f);
              a + b > 32768 && (a = 0), El(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 0, a), El(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 1, a), a += b, El(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 0, a), El(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 1, a);
              const S = n.segment.vertexLength;
              this.indexArray.emplaceBack(S, S + 2, S + 1), this.indexArray.emplaceBack(S + 1, S + 2, S + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2
            }
          }
        }

        function tb(i, r) {
          for (let n = 0; n < r.length; n++) {
            const a = r[n];
            n === r.length - 1 && r[0].x === a.x && r[0].y === a.y || (i.x += a.x, i.y += a.y, i.sampleCount++)
          }
        }

        function eb(i, r) {
          return i.x === r.x && (i.x < 0 || i.x > ne) || i.y === r.y && (i.y < 0 || i.y > ne)
        }

        function Xm(i) {
          return i.every((r => r.x < 0)) || i.every((r => r.x > ne)) || i.every((r => r.y < 0)) || i.every((r => r.y > ne))
        }
        let Ym;
        Sr("FillExtrusionBucket", hp, {
          omit: ["layers", "features"]
        });
        var rb = {
          get paint() {
            return Ym = Ym || new io({
              "fill-extrusion-opacity": new Xr(W["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new nn(W["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new Xr(W["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new Xr(W["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new nu(W["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new nn(W["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new nn(W["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new Xr(W["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class nb extends Uo {
          constructor(r, n) {
            super(r, rb, n)
          }
          createBucket(r) {
            return new hp(r)
          }
          queryRadius() {
            return Eh(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: r,
            feature: n,
            featureState: a,
            geometry: _,
            transform: f,
            pixelsToTileUnits: m,
            pixelPosMatrix: v
          }) {
            const b = jh(r, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -f.bearingInRadians, m),
              S = this.paint.get("fill-extrusion-height").evaluate(n, a),
              M = this.paint.get("fill-extrusion-base").evaluate(n, a),
              j = (function(N, H) {
                const J = [];
                for (const rt of N) {
                  const ht = [rt.x, rt.y, 0, 1];
                  Xt(ht, ht, H), J.push(new R(ht[0] / ht[3], ht[1] / ht[3]))
                }
                return J
              })(b, v),
              O = (function(N, H, J, rt) {
                const ht = [],
                  Ot = [],
                  bt = rt[8] * H,
                  Mt = rt[9] * H,
                  te = rt[10] * H,
                  le = rt[11] * H,
                  Re = rt[8] * J,
                  br = rt[9] * J,
                  ar = rt[10] * J,
                  yr = rt[11] * J;
                for (const Yr of N) {
                  const fr = [],
                    vr = [];
                  for (const ke of Yr) {
                    const an = ke.x,
                      hn = ke.y,
                      Qr = rt[0] * an + rt[4] * hn + rt[12],
                      Wr = rt[1] * an + rt[5] * hn + rt[13],
                      Dn = rt[2] * an + rt[6] * hn + rt[14],
                      fi = rt[3] * an + rt[7] * hn + rt[15],
                      Li = Dn + te,
                      so = fi + le,
                      Ho = Qr + Re,
                      So = Wr + br,
                      Xi = Dn + ar,
                      hi = fi + yr,
                      Vi = new R((Qr + bt) / so, (Wr + Mt) / so);
                    Vi.z = Li / so, fr.push(Vi);
                    const Yi = new R(Ho / hi, So / hi);
                    Yi.z = Xi / hi, vr.push(Yi)
                  }
                  ht.push(fr), Ot.push(vr)
                }
                return [ht, Ot]
              })(_, M, S, v);
            return (function(N, H, J) {
              let rt = 1 / 0;
              Tm(J, H) && (rt = Km(J, H[0]));
              for (let ht = 0; ht < H.length; ht++) {
                const Ot = H[ht],
                  bt = N[ht];
                for (let Mt = 0; Mt < Ot.length - 1; Mt++) {
                  const te = Ot[Mt],
                    le = [te, Ot[Mt + 1], bt[Mt + 1], bt[Mt], te];
                  km(J, le) && (rt = Math.min(rt, Km(J, le)))
                }
              }
              return rt !== 1 / 0 && rt
            })(O[0], O[1], j)
          }
        }

        function jl(i, r) {
          return i.x * r.x + i.y * r.y
        }

        function Km(i, r) {
          if (i.length === 1) {
            let n = 0;
            const a = r[n++];
            let _;
            for (; !_ || a.equals(_);)
              if (_ = r[n++], !_) return 1 / 0;
            for (; n < r.length; n++) {
              const f = r[n],
                m = i[0],
                v = _.sub(a),
                b = f.sub(a),
                S = m.sub(a),
                M = jl(v, v),
                j = jl(v, b),
                O = jl(b, b),
                N = jl(S, v),
                H = jl(S, b),
                J = M * O - j * j,
                rt = (O * N - j * H) / J,
                ht = (M * H - j * N) / J,
                Ot = a.z * (1 - rt - ht) + _.z * rt + f.z * ht;
              if (isFinite(Ot)) return Ot
            }
            return 1 / 0
          } {
            let n = 1 / 0;
            for (const a of r) n = Math.min(n, a.z);
            return n
          }
        }
        const ib = bi([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: ob
          } = ib,
          sb = bi([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: ab
          } = sb,
          ub = Math.cos(Math.PI / 180 * 37.5),
          Jm = Math.pow(2, 14) / .5;
        class dp {
          constructor(r) {
            this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map((n => n.id)), this.index = r.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n => {
              this.gradients[n.id] = {}
            })), this.layoutVertexArray = new It, this.layoutVertexArray2 = new gt, this.indexArray = new Pe, this.programConfigurations = new ea(r.layers, r.zoom), this.segments = new Tn, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n => n.isStateDependent())).map((n => n.id))
          }
          populate(r, n, a) {
            this.hasDependencies = Lh("line", this.layers, n) || this.hasLineDasharray(this.layers);
            const _ = this.layers[0].layout.get("line-sort-key"),
              f = !_.isConstant(),
              m = [];
            for (const {
                feature: v,
                id: b,
                index: S,
                sourceLayerIndex: M
              }
              of r) {
              const j = this.layers[0]._featureFilter.needGeometry,
                O = zs(v, j);
              if (!this.layers[0]._featureFilter.filter(new Kn(this.zoom), O, a)) continue;
              const N = f ? _.evaluate(O, {}, a) : void 0,
                H = {
                  id: b,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: M,
                  index: S,
                  geometry: j ? O.geometry : fs(v),
                  patterns: {},
                  dashes: {},
                  sortKey: N
                };
              m.push(H)
            }
            f && m.sort(((v, b) => v.sortKey - b.sortKey));
            for (const v of m) {
              const {
                geometry: b,
                index: S,
                sourceLayerIndex: M
              } = v;
              this.hasDependencies ? (Lh("line", this.layers, n) ? ap("line", this.layers, v, {
                zoom: this.zoom
              }, n) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, v, this.zoom, n), this.patternFeatures.push(v)) : this.addFeature(v, b, S, a, {}, {}, n.subdivisionGranularity), n.featureIndex.insert(r[S].feature, b, S, M, this.index)
            }
          }
          update(r, n, a, _) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, n, this.stateDependentLayers, {
              imagePositions: a,
              dashPositions: _
            })
          }
          addFeatures(r, n, a, _) {
            for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, n, a, _, r.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(r) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = r.createVertexBuffer(this.layoutVertexArray2, ab)), this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, ob), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(r) {
            if (r.properties && Object.prototype.hasOwnProperty.call(r.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(r.properties, "mapbox_clip_end")) return {
              start: +r.properties.mapbox_clip_start,
              end: +r.properties.mapbox_clip_end
            }
          }
          addFeature(r, n, a, _, f, m, v) {
            const b = this.layers[0].layout,
              S = b.get("line-join").evaluate(r, {}),
              M = b.get("line-cap"),
              j = b.get("line-miter-limit"),
              O = b.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(r);
            for (const N of n) this.addLine(N, r, S, M, j, O, _, v);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, a, {
              imagePositions: f,
              dashPositions: m,
              canonical: _
            })
          }
          addLine(r, n, a, _, f, m, v, b) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, r = uu(r, v ? b.line.getGranularityForZoomLevel(v.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let bt = 0; bt < r.length - 1; bt++) this.totalDistance += r[bt].dist(r[bt + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const S = sc.types[n.type] === "Polygon";
            let M = r.length;
            for (; M >= 2 && r[M - 1].equals(r[M - 2]);) M--;
            let j = 0;
            for (; j < M - 1 && r[j].equals(r[j + 1]);) j++;
            if (M < (S ? 3 : 2)) return;
            a === "bevel" && (f = 1.05);
            const O = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              N = this.segments.prepareSegment(10 * M, this.layoutVertexArray, this.indexArray);
            let H, J, rt, ht, Ot;
            this.e1 = this.e2 = -1, S && (H = r[M - 2], Ot = r[j].sub(H)._unit()._perp());
            for (let bt = j; bt < M; bt++) {
              if (rt = bt === M - 1 ? S ? r[j + 1] : void 0 : r[bt + 1], rt && r[bt].equals(rt)) continue;
              Ot && (ht = Ot), H && (J = H), H = r[bt], Ot = rt ? rt.sub(H)._unit()._perp() : ht, ht = ht || Ot;
              let Mt = ht.add(Ot);
              Mt.x === 0 && Mt.y === 0 || Mt._unit();
              const te = ht.x * Ot.x + ht.y * Ot.y,
                le = Mt.x * Ot.x + Mt.y * Ot.y,
                Re = le !== 0 ? 1 / le : 1 / 0,
                br = 2 * Math.sqrt(2 - 2 * le),
                ar = le < ub && J && rt,
                yr = ht.x * Ot.y - ht.y * Ot.x > 0;
              if (ar && bt > j) {
                const vr = H.dist(J);
                if (vr > 2 * O) {
                  const ke = H.sub(H.sub(J)._mult(O / vr)._round());
                  this.updateDistance(J, ke), this.addCurrentVertex(ke, ht, 0, 0, N), J = ke
                }
              }
              const Yr = J && rt;
              let fr = Yr ? a : S ? "butt" : _;
              if (Yr && fr === "round" && (Re < m ? fr = "miter" : Re <= 2 && (fr = "fakeround")), fr === "miter" && Re > f && (fr = "bevel"), fr === "bevel" && (Re > 2 && (fr = "flipbevel"), Re < f && (fr = "miter")), J && this.updateDistance(J, H), fr === "miter") Mt._mult(Re), this.addCurrentVertex(H, Mt, 0, 0, N);
              else if (fr === "flipbevel") {
                if (Re > 100) Mt = Ot.mult(-1);
                else {
                  const vr = Re * ht.add(Ot).mag() / ht.sub(Ot).mag();
                  Mt._perp()._mult(vr * (yr ? -1 : 1))
                }
                this.addCurrentVertex(H, Mt, 0, 0, N), this.addCurrentVertex(H, Mt.mult(-1), 0, 0, N)
              } else if (fr === "bevel" || fr === "fakeround") {
                const vr = -Math.sqrt(Re * Re - 1),
                  ke = yr ? vr : 0,
                  an = yr ? 0 : vr;
                if (J && this.addCurrentVertex(H, ht, ke, an, N), fr === "fakeround") {
                  const hn = Math.round(180 * br / Math.PI / 20);
                  for (let Qr = 1; Qr < hn; Qr++) {
                    let Wr = Qr / hn;
                    if (Wr !== .5) {
                      const fi = Wr - .5;
                      Wr += Wr * fi * (Wr - 1) * ((1.0904 + te * (te * (3.55645 - 1.43519 * te) - 3.2452)) * fi * fi + (.848013 + te * (.215638 * te - 1.06021)))
                    }
                    const Dn = Ot.sub(ht)._mult(Wr)._add(ht)._unit()._mult(yr ? -1 : 1);
                    this.addHalfVertex(H, Dn.x, Dn.y, !1, yr, 0, N)
                  }
                }
                rt && this.addCurrentVertex(H, Ot, -ke, -an, N)
              } else if (fr === "butt") this.addCurrentVertex(H, Mt, 0, 0, N);
              else if (fr === "square") {
                const vr = J ? 1 : -1;
                this.addCurrentVertex(H, Mt, vr, vr, N)
              } else fr === "round" && (J && (this.addCurrentVertex(H, ht, 0, 0, N), this.addCurrentVertex(H, ht, 1, 1, N, !0)), rt && (this.addCurrentVertex(H, Ot, -1, -1, N, !0), this.addCurrentVertex(H, Ot, 0, 0, N)));
              if (ar && bt < M - 1) {
                const vr = H.dist(rt);
                if (vr > 2 * O) {
                  const ke = H.add(rt.sub(H)._mult(O / vr)._round());
                  this.updateDistance(H, ke), this.addCurrentVertex(ke, Ot, 0, 0, N), H = ke
                }
              }
            }
          }
          addCurrentVertex(r, n, a, _, f, m = !1) {
            const v = n.y * _ - n.x,
              b = -n.y - n.x * _;
            this.addHalfVertex(r, n.x + n.y * a, n.y - n.x * a, m, !1, a, f), this.addHalfVertex(r, v, b, m, !0, -_, f), this.distance > Jm / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(r, n, a, _, f, m))
          }
          addHalfVertex({
            x: r,
            y: n
          }, a, _, f, m, v, b) {
            const S = .5 * (this.lineClips ? this.scaledDistance * (Jm - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((r << 1) + (f ? 1 : 0), (n << 1) + (m ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * _) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const M = b.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, M, this.e2), b.primitiveLength++), m ? this.e2 = M : this.e1 = M
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(r, n) {
            this.distance += r.dist(n), this.updateScaledDistance()
          }
          hasLineDasharray(r) {
            for (const n of r) {
              const a = n.paint.get("line-dasharray");
              if (a && !a.isConstant()) return !0
            }
            return !1
          }
          addLineDashDependencies(r, n, a, _) {
            for (const f of r) {
              const m = f.paint.get("line-dasharray");
              if (!m || m.value.kind === "constant") continue;
              const v = f.layout.get("line-cap") === "round",
                b = {
                  dasharray: m.value.evaluate({
                    zoom: a - 1
                  }, n, {}),
                  round: v
                },
                S = {
                  dasharray: m.value.evaluate({
                    zoom: a
                  }, n, {}),
                  round: v
                },
                M = {
                  dasharray: m.value.evaluate({
                    zoom: a + 1
                  }, n, {}),
                  round: v
                },
                j = `${b.dasharray.join(",")},${b.round}`,
                O = `${S.dasharray.join(",")},${S.round}`,
                N = `${M.dasharray.join(",")},${M.round}`;
              _.dashDependencies[j] = b, _.dashDependencies[O] = S, _.dashDependencies[N] = M, n.dashes[f.id] = {
                min: j,
                mid: O,
                max: N
              }
            }
          }
        }
        let Qm, tg;
        Sr("LineBucket", dp, {
          omit: ["layers", "patternFeatures"]
        });
        var eg = {
          get paint() {
            return tg = tg || new io({
              "line-opacity": new nn(W.paint_line["line-opacity"]),
              "line-color": new nn(W.paint_line["line-color"]),
              "line-translate": new Xr(W.paint_line["line-translate"]),
              "line-translate-anchor": new Xr(W.paint_line["line-translate-anchor"]),
              "line-width": new nn(W.paint_line["line-width"]),
              "line-gap-width": new nn(W.paint_line["line-gap-width"]),
              "line-offset": new nn(W.paint_line["line-offset"]),
              "line-blur": new nn(W.paint_line["line-blur"]),
              "line-dasharray": new nu(W.paint_line["line-dasharray"]),
              "line-pattern": new nu(W.paint_line["line-pattern"]),
              "line-gradient": new iu(W.paint_line["line-gradient"])
            })
          },
          get layout() {
            return Qm = Qm || new io({
              "line-cap": new Xr(W.layout_line["line-cap"]),
              "line-join": new nn(W.layout_line["line-join"]),
              "line-miter-limit": new Xr(W.layout_line["line-miter-limit"]),
              "line-round-limit": new Xr(W.layout_line["line-round-limit"]),
              "line-sort-key": new nn(W.layout_line["line-sort-key"])
            })
          }
        };
        class cb extends nn {
          possiblyEvaluate(r, n) {
            return n = new Kn(Math.floor(n.zoom), {
              now: n.now,
              fadeDuration: n.fadeDuration,
              zoomHistory: n.zoomHistory,
              transition: n.transition
            }), super.possiblyEvaluate(r, n)
          }
          evaluate(r, n, a, _) {
            return n = se({}, n, {
              zoom: Math.floor(n.zoom)
            }), super.evaluate(r, n, a, _)
          }
        }
        let Fh;
        class lb extends Uo {
          constructor(r, n) {
            super(r, eg, n), this.gradientVersion = 0, Fh || (Fh = new cb(eg.paint.properties["line-width"].specification), Fh.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(r) {
            if (r === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(a) {
                return a._styleExpression !== void 0
              })(n) && n._styleExpression.expression instanceof Ti, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(r, n) {
            super.recalculate(r, n), this.paint._values["line-floorwidth"] = Fh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, r)
          }
          createBucket(r) {
            return new dp(r)
          }
          queryRadius(r) {
            const n = r,
              a = rg(rc("line-width", this, n), rc("line-gap-width", this, n)),
              _ = rc("line-offset", this, n);
            return a / 2 + Math.abs(_) + Eh(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: r,
            feature: n,
            featureState: a,
            geometry: _,
            transform: f,
            pixelsToTileUnits: m
          }) {
            const v = jh(r, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -f.bearingInRadians, m),
              b = m / 2 * rg(this.paint.get("line-width").evaluate(n, a), this.paint.get("line-gap-width").evaluate(n, a)),
              S = this.paint.get("line-offset").evaluate(n, a);
            return S && (_ = (function(M, j) {
              const O = [];
              for (let N = 0; N < M.length; N++) {
                const H = M[N],
                  J = [];
                for (let rt = 0; rt < H.length; rt++) {
                  const ht = H[rt - 1],
                    Ot = H[rt],
                    bt = H[rt + 1],
                    Mt = rt === 0 ? new R(0, 0) : Ot.sub(ht)._unit()._perp(),
                    te = rt === H.length - 1 ? new R(0, 0) : bt.sub(Ot)._unit()._perp(),
                    le = Mt._add(te)._unit(),
                    Re = le.x * te.x + le.y * te.y;
                  Re !== 0 && le._mult(1 / Re), J.push(le._mult(j)._add(Ot))
                }
                O.push(J)
              }
              return O
            })(_, S * m)), (function(M, j, O) {
              for (let N = 0; N < j.length; N++) {
                const H = j[N];
                if (M.length >= 3) {
                  for (let J = 0; J < H.length; J++)
                    if (ec(M, H[J])) return !0
                }
                if (g0(M, H, O)) return !0
              }
              return !1
            })(v, _, b)
          }
          isTileClipped() {
            return !0
          }
        }

        function rg(i, r) {
          return r > 0 ? r + 2 * i : i
        }
        const _b = bi([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          hb = bi([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        bi([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const db = bi([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        bi([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const ng = bi([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          pb = bi([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function fb(i, r, n) {
          return i.sections.forEach((a => {
            a.text = (function(_, f, m) {
              const v = f.layout.get("text-transform").evaluate(m, {});
              return v === "uppercase" ? _ = _.toLocaleUpperCase() : v === "lowercase" && (_ = _.toLocaleLowerCase()), _s.applyArabicShaping && (_ = _s.applyArabicShaping(_)), _
            })(a.text, r, n)
          })), i
        }
        bi([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), bi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), bi([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), bi([{
          type: "Float32",
          name: "offsetX"
        }]), bi([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), bi([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const Ll = {
          "!": "ï¸•",
          "#": "ï¼ƒ",
          $: "ï¼„",
          "%": "ï¼…",
          "&": "ï¼†",
          "(": "ï¸µ",
          ")": "ï¸¶",
          "*": "ï¼Š",
          "+": "ï¼‹",
          ",": "ï¸",
          "-": "ï¸²",
          ".": "ãƒ»",
          "/": "ï¼",
          ":": "ï¸“",
          ";": "ï¸”",
          "<": "ï¸¿",
          "=": "ï¼",
          ">": "ï¹€",
          "?": "ï¸–",
          "@": "ï¼ ",
          "[": "ï¹‡",
          "\\": "ï¼¼",
          "]": "ï¹ˆ",
          "^": "ï¼¾",
          _: "ï¸³",
          "`": "ï½€",
          "{": "ï¸·",
          "|": "â€•",
          "}": "ï¸¸",
          "~": "ï½",
          "Â¢": "ï¿ ",
          "Â£": "ï¿¡",
          "Â¥": "ï¿¥",
          "Â¦": "ï¿¤",
          "Â¬": "ï¿¢",
          "Â¯": "ï¿£",
          "â€“": "ï¸²",
          "â€”": "ï¸±",
          "â€˜": "ï¹ƒ",
          "â€™": "ï¹„",
          "â€œ": "ï¹",
          "â€": "ï¹‚",
          "â€¦": "ï¸™",
          "â€§": "ãƒ»",
          "â‚©": "ï¿¦",
          "ã€": "ï¸‘",
          "ã€‚": "ï¸’",
          "ã€ˆ": "ï¸¿",
          "ã€‰": "ï¹€",
          "ã€Š": "ï¸½",
          "ã€‹": "ï¸¾",
          "ã€Œ": "ï¹",
          "ã€": "ï¹‚",
          "ã€": "ï¹ƒ",
          "ã€": "ï¹„",
          "ã€": "ï¸»",
          "ã€‘": "ï¸¼",
          "ã€”": "ï¸¹",
          "ã€•": "ï¸º",
          "ã€–": "ï¸—",
          "ã€—": "ï¸˜",
          "ï¼": "ï¸•",
          "ï¼ˆ": "ï¸µ",
          "ï¼‰": "ï¸¶",
          "ï¼Œ": "ï¸",
          "ï¼": "ï¸²",
          "ï¼": "ãƒ»",
          "ï¼š": "ï¸“",
          "ï¼›": "ï¸”",
          "ï¼œ": "ï¸¿",
          "ï¼": "ï¹€",
          "ï¼Ÿ": "ï¸–",
          "ï¼»": "ï¹‡",
          "ï¼½": "ï¹ˆ",
          "ï¼¿": "ï¸³",
          "ï½›": "ï¸·",
          "ï½œ": "â€•",
          "ï½": "ï¸¸",
          "ï½Ÿ": "ï¸µ",
          "ï½ ": "ï¸¶",
          "ï½¡": "ï¸’",
          "ï½¢": "ï¹",
          "ï½£": "ï¹‚"
        };
        var Ni = 24;
        const pp = 4294967296,
          ig = 1 / pp,
          og = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class fp {
          constructor(r = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(r) ? r : new Uint8Array(r), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(r, n, a = this.length) {
            for (; this.pos < a;) {
              const _ = this.readVarint(),
                f = _ >> 3,
                m = this.pos;
              this.type = 7 & _, r(f, n, this), this.pos === m && this.skip(_)
            }
            return n
          }
          readMessage(r, n) {
            return this.readFields(r, n, this.readVarint() + this.pos)
          }
          readFixed32() {
            const r = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, r
          }
          readSFixed32() {
            const r = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, r
          }
          readFixed64() {
            const r = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * pp;
            return this.pos += 8, r
          }
          readSFixed64() {
            const r = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * pp;
            return this.pos += 8, r
          }
          readFloat() {
            const r = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, r
          }
          readDouble() {
            const r = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, r
          }
          readVarint(r) {
            const n = this.buf;
            let a, _;
            return _ = n[this.pos++], a = 127 & _, _ < 128 ? a : (_ = n[this.pos++], a |= (127 & _) << 7, _ < 128 ? a : (_ = n[this.pos++], a |= (127 & _) << 14, _ < 128 ? a : (_ = n[this.pos++], a |= (127 & _) << 21, _ < 128 ? a : (_ = n[this.pos], a |= (15 & _) << 28, (function(f, m, v) {
              const b = v.buf;
              let S, M;
              if (M = b[v.pos++], S = (112 & M) >> 4, M < 128 || (M = b[v.pos++], S |= (127 & M) << 3, M < 128) || (M = b[v.pos++], S |= (127 & M) << 10, M < 128) || (M = b[v.pos++], S |= (127 & M) << 17, M < 128) || (M = b[v.pos++], S |= (127 & M) << 24, M < 128) || (M = b[v.pos++], S |= (1 & M) << 31, M < 128)) return ac(f, S, m);
              throw new Error("Expected varint not more than 10 bytes")
            })(a, r, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const r = this.readVarint();
            return r % 2 == 1 ? (r + 1) / -2 : r / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const r = this.readVarint() + this.pos,
              n = this.pos;
            return this.pos = r, r - n >= 12 && og ? og.decode(this.buf.subarray(n, r)) : (function(a, _, f) {
              let m = "",
                v = _;
              for (; v < f;) {
                const b = a[v];
                let S, M, j, O = null,
                  N = b > 239 ? 4 : b > 223 ? 3 : b > 191 ? 2 : 1;
                if (v + N > f) break;
                N === 1 ? b < 128 && (O = b) : N === 2 ? (S = a[v + 1], (192 & S) == 128 && (O = (31 & b) << 6 | 63 & S, O <= 127 && (O = null))) : N === 3 ? (S = a[v + 1], M = a[v + 2], (192 & S) == 128 && (192 & M) == 128 && (O = (15 & b) << 12 | (63 & S) << 6 | 63 & M, (O <= 2047 || O >= 55296 && O <= 57343) && (O = null))) : N === 4 && (S = a[v + 1], M = a[v + 2], j = a[v + 3], (192 & S) == 128 && (192 & M) == 128 && (192 & j) == 128 && (O = (15 & b) << 18 | (63 & S) << 12 | (63 & M) << 6 | 63 & j, (O <= 65535 || O >= 1114112) && (O = null))), O === null ? (O = 65533, N = 1) : O > 65535 && (O -= 65536, m += String.fromCharCode(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), m += String.fromCharCode(O), v += N
              }
              return m
            })(this.buf, n, r)
          }
          readBytes() {
            const r = this.readVarint() + this.pos,
              n = this.buf.subarray(this.pos, r);
            return this.pos = r, n
          }
          readPackedVarint(r = [], n) {
            const a = this.readPackedEnd();
            for (; this.pos < a;) r.push(this.readVarint(n));
            return r
          }
          readPackedSVarint(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readSVarint());
            return r
          }
          readPackedBoolean(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readBoolean());
            return r
          }
          readPackedFloat(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readFloat());
            return r
          }
          readPackedDouble(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readDouble());
            return r
          }
          readPackedFixed32(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readFixed32());
            return r
          }
          readPackedSFixed32(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readSFixed32());
            return r
          }
          readPackedFixed64(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readFixed64());
            return r
          }
          readPackedSFixed64(r = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) r.push(this.readSFixed64());
            return r
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(r) {
            const n = 7 & r;
            if (n === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8
            }
          }
          writeTag(r, n) {
            this.writeVarint(r << 3 | n)
          }
          realloc(r) {
            let n = this.length || 16;
            for (; n < this.pos + r;) n *= 2;
            if (n !== this.length) {
              const a = new Uint8Array(n);
              a.set(this.buf), this.buf = a, this.dataView = new DataView(a.buffer), this.length = n
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(r) {
            this.realloc(4), this.dataView.setInt32(this.pos, r, !0), this.pos += 4
          }
          writeSFixed32(r) {
            this.realloc(4), this.dataView.setInt32(this.pos, r, !0), this.pos += 4
          }
          writeFixed64(r) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & r, !0), this.dataView.setInt32(this.pos + 4, Math.floor(r * ig), !0), this.pos += 8
          }
          writeSFixed64(r) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & r, !0), this.dataView.setInt32(this.pos + 4, Math.floor(r * ig), !0), this.pos += 8
          }
          writeVarint(r) {
            (r = +r || 0) > 268435455 || r < 0 ? (function(n, a) {
              let _, f;
              if (n >= 0 ? (_ = n % 4294967296 | 0, f = n / 4294967296 | 0) : (_ = ~(-n % 4294967296), f = ~(-n / 4294967296), 4294967295 ^ _ ? _ = _ + 1 | 0 : (_ = 0, f = f + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              a.realloc(10), (function(m, v, b) {
                b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, b.buf[b.pos] = 127 & (m >>>= 7)
              })(_, 0, a), (function(m, v) {
                const b = (7 & m) << 4;
                v.buf[v.pos++] |= b | ((m >>>= 3) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m)))))
              })(f, a)
            })(r, this) : (this.realloc(4), this.buf[this.pos++] = 127 & r | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = r >>> 7 & 127))))
          }
          writeSVarint(r) {
            this.writeVarint(r < 0 ? 2 * -r - 1 : 2 * r)
          }
          writeBoolean(r) {
            this.writeVarint(+r)
          }
          writeString(r) {
            r = String(r), this.realloc(4 * r.length), this.pos++;
            const n = this.pos;
            this.pos = (function(_, f, m) {
              for (let v, b, S = 0; S < f.length; S++) {
                if (v = f.charCodeAt(S), v > 55295 && v < 57344) {
                  if (!b) {
                    v > 56319 || S + 1 === f.length ? (_[m++] = 239, _[m++] = 191, _[m++] = 189) : b = v;
                    continue
                  }
                  if (v < 56320) {
                    _[m++] = 239, _[m++] = 191, _[m++] = 189, b = v;
                    continue
                  }
                  v = b - 55296 << 10 | v - 56320 | 65536, b = null
                } else b && (_[m++] = 239, _[m++] = 191, _[m++] = 189, b = null);
                v < 128 ? _[m++] = v : (v < 2048 ? _[m++] = v >> 6 | 192 : (v < 65536 ? _[m++] = v >> 12 | 224 : (_[m++] = v >> 18 | 240, _[m++] = v >> 12 & 63 | 128), _[m++] = v >> 6 & 63 | 128), _[m++] = 63 & v | 128)
              }
              return m
            })(this.buf, r, this.pos);
            const a = this.pos - n;
            a >= 128 && sg(n, a, this), this.pos = n - 1, this.writeVarint(a), this.pos += a
          }
          writeFloat(r) {
            this.realloc(4), this.dataView.setFloat32(this.pos, r, !0), this.pos += 4
          }
          writeDouble(r) {
            this.realloc(8), this.dataView.setFloat64(this.pos, r, !0), this.pos += 8
          }
          writeBytes(r) {
            const n = r.length;
            this.writeVarint(n), this.realloc(n);
            for (let a = 0; a < n; a++) this.buf[this.pos++] = r[a]
          }
          writeRawMessage(r, n) {
            this.pos++;
            const a = this.pos;
            r(n, this);
            const _ = this.pos - a;
            _ >= 128 && sg(a, _, this), this.pos = a - 1, this.writeVarint(_), this.pos += _
          }
          writeMessage(r, n, a) {
            this.writeTag(r, 2), this.writeRawMessage(n, a)
          }
          writePackedVarint(r, n) {
            n.length && this.writeMessage(r, mb, n)
          }
          writePackedSVarint(r, n) {
            n.length && this.writeMessage(r, gb, n)
          }
          writePackedBoolean(r, n) {
            n.length && this.writeMessage(r, bb, n)
          }
          writePackedFloat(r, n) {
            n.length && this.writeMessage(r, yb, n)
          }
          writePackedDouble(r, n) {
            n.length && this.writeMessage(r, vb, n)
          }
          writePackedFixed32(r, n) {
            n.length && this.writeMessage(r, xb, n)
          }
          writePackedSFixed32(r, n) {
            n.length && this.writeMessage(r, wb, n)
          }
          writePackedFixed64(r, n) {
            n.length && this.writeMessage(r, kb, n)
          }
          writePackedSFixed64(r, n) {
            n.length && this.writeMessage(r, Tb, n)
          }
          writeBytesField(r, n) {
            this.writeTag(r, 2), this.writeBytes(n)
          }
          writeFixed32Field(r, n) {
            this.writeTag(r, 5), this.writeFixed32(n)
          }
          writeSFixed32Field(r, n) {
            this.writeTag(r, 5), this.writeSFixed32(n)
          }
          writeFixed64Field(r, n) {
            this.writeTag(r, 1), this.writeFixed64(n)
          }
          writeSFixed64Field(r, n) {
            this.writeTag(r, 1), this.writeSFixed64(n)
          }
          writeVarintField(r, n) {
            this.writeTag(r, 0), this.writeVarint(n)
          }
          writeSVarintField(r, n) {
            this.writeTag(r, 0), this.writeSVarint(n)
          }
          writeStringField(r, n) {
            this.writeTag(r, 2), this.writeString(n)
          }
          writeFloatField(r, n) {
            this.writeTag(r, 5), this.writeFloat(n)
          }
          writeDoubleField(r, n) {
            this.writeTag(r, 1), this.writeDouble(n)
          }
          writeBooleanField(r, n) {
            this.writeVarintField(r, +n)
          }
        }

        function ac(i, r, n) {
          return n ? 4294967296 * r + (i >>> 0) : 4294967296 * (r >>> 0) + (i >>> 0)
        }

        function sg(i, r, n) {
          const a = r <= 16383 ? 1 : r <= 2097151 ? 2 : r <= 268435455 ? 3 : Math.floor(Math.log(r) / (7 * Math.LN2));
          n.realloc(a);
          for (let _ = n.pos - 1; _ >= i; _--) n.buf[_ + a] = n.buf[_]
        }

        function mb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeVarint(i[n])
        }

        function gb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeSVarint(i[n])
        }

        function yb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeFloat(i[n])
        }

        function vb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeDouble(i[n])
        }

        function bb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeBoolean(i[n])
        }

        function xb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeFixed32(i[n])
        }

        function wb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeSFixed32(i[n])
        }

        function kb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeFixed64(i[n])
        }

        function Tb(i, r) {
          for (let n = 0; n < i.length; n++) r.writeSFixed64(i[n])
        }

        function Sb(i, r, n) {
          i === 1 && n.readMessage(Pb, r)
        }

        function Pb(i, r, n) {
          if (i === 3) {
            const {
              id: a,
              bitmap: _,
              width: f,
              height: m,
              left: v,
              top: b,
              advance: S
            } = n.readMessage(Mb, {});
            r.push({
              id: a,
              bitmap: new Sl({
                width: f + 6,
                height: m + 6
              }, _),
              metrics: {
                width: f,
                height: m,
                left: v,
                top: b,
                advance: S
              }
            })
          }
        }

        function Mb(i, r, n) {
          i === 1 ? r.id = n.readVarint() : i === 2 ? r.bitmap = n.readBytes() : i === 3 ? r.width = n.readVarint() : i === 4 ? r.height = n.readVarint() : i === 5 ? r.left = n.readSVarint() : i === 6 ? r.top = n.readSVarint() : i === 7 && (r.advance = n.readVarint())
        }

        function ag(i) {
          let r = 0,
            n = 0;
          for (const m of i) r += m.w * m.h, n = Math.max(n, m.w);
          i.sort(((m, v) => v.h - m.h));
          const a = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(r / .95)), n),
            h: 1 / 0
          }];
          let _ = 0,
            f = 0;
          for (const m of i)
            for (let v = a.length - 1; v >= 0; v--) {
              const b = a[v];
              if (!(m.w > b.w || m.h > b.h)) {
                if (m.x = b.x, m.y = b.y, f = Math.max(f, m.y + m.h), _ = Math.max(_, m.x + m.w), m.w === b.w && m.h === b.h) {
                  const S = a.pop();
                  S && v < a.length && (a[v] = S)
                } else m.h === b.h ? (b.x += m.w, b.w -= m.w) : m.w === b.w ? (b.y += m.h, b.h -= m.h) : (a.push({
                  x: b.x + m.w,
                  y: b.y,
                  w: b.w - m.w,
                  h: m.h
                }), b.y += m.h, b.h -= m.h);
                break
              }
            }
          return {
            w: _,
            h: f,
            fill: r / (_ * f) || 0
          }
        }
        class mp {
          constructor(r, {
            pixelRatio: n,
            version: a,
            stretchX: _,
            stretchY: f,
            content: m,
            textFitWidth: v,
            textFitHeight: b
          }) {
            this.paddedRect = r, this.pixelRatio = n, this.stretchX = _, this.stretchY = f, this.content = m, this.version = a, this.textFitWidth = v, this.textFitHeight = b
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class ug {
          constructor(r, n) {
            const a = {},
              _ = {};
            this.haveRenderCallbacks = [];
            const f = [];
            this.addImages(r, a, f), this.addImages(n, _, f);
            const {
              w: m,
              h: v
            } = ag(f), b = new To({
              width: m || 1,
              height: v || 1
            });
            for (const S in r) {
              const M = r[S],
                j = a[S].paddedRect;
              To.copy(M.data, b, {
                x: 0,
                y: 0
              }, {
                x: j.x + 1,
                y: j.y + 1
              }, M.data)
            }
            for (const S in n) {
              const M = n[S],
                j = _[S].paddedRect,
                O = j.x + 1,
                N = j.y + 1,
                H = M.data.width,
                J = M.data.height;
              To.copy(M.data, b, {
                x: 0,
                y: 0
              }, {
                x: O,
                y: N
              }, M.data), To.copy(M.data, b, {
                x: 0,
                y: J - 1
              }, {
                x: O,
                y: N - 1
              }, {
                width: H,
                height: 1
              }), To.copy(M.data, b, {
                x: 0,
                y: 0
              }, {
                x: O,
                y: N + J
              }, {
                width: H,
                height: 1
              }), To.copy(M.data, b, {
                x: H - 1,
                y: 0
              }, {
                x: O - 1,
                y: N
              }, {
                width: 1,
                height: J
              }), To.copy(M.data, b, {
                x: 0,
                y: 0
              }, {
                x: O + H,
                y: N
              }, {
                width: 1,
                height: J
              })
            }
            this.image = b, this.iconPositions = a, this.patternPositions = _
          }
          addImages(r, n, a) {
            for (const _ in r) {
              const f = r[_],
                m = {
                  x: 0,
                  y: 0,
                  w: f.data.width + 2,
                  h: f.data.height + 2
                };
              a.push(m), n[_] = new mp(m, f), f.hasRenderCallback && this.haveRenderCallbacks.push(_)
            }
          }
          patchUpdatedImages(r, n) {
            r.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const a in r.updatedImages) this.patchUpdatedImage(this.iconPositions[a], r.getImage(a), n), this.patchUpdatedImage(this.patternPositions[a], r.getImage(a), n)
          }
          patchUpdatedImage(r, n, a) {
            if (!r || !n || r.version === n.version) return;
            r.version = n.version;
            const [_, f] = r.tl;
            a.update(n.data, void 0, {
              x: _,
              y: f
            })
          }
        }
        var Aa;
        Sr("ImagePosition", mp), Sr("ImageAtlas", ug), k.as = void 0, (Aa = k.as || (k.as = {}))[Aa.none = 0] = "none", Aa[Aa.horizontal = 1] = "horizontal", Aa[Aa.vertical = 2] = "vertical", Aa[Aa.horizontalOnly = 3] = "horizontalOnly";
        class Dl {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(r, n, a) {
            const _ = new Dl;
            return _.scale = r || 1, _.fontStack = n, _.verticalAlign = a || "bottom", _
          }
          static forImage(r, n) {
            const a = new Dl;
            return a.imageName = r, a.verticalAlign = n || "bottom", a
          }
        }
        class uc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(r, n) {
            const a = new uc;
            for (let _ = 0; _ < r.sections.length; _++) {
              const f = r.sections[_];
              f.image ? a.addImageSection(f) : a.addTextSection(f, n)
            }
            return a
          }
          length() {
            return this.text.length
          }
          getSection(r) {
            return this.sections[this.sectionIndex[r]]
          }
          getSectionIndex(r) {
            return this.sectionIndex[r]
          }
          getCharCode(r) {
            return this.text.charCodeAt(r)
          }
          verticalizePunctuation() {
            this.text = (function(r) {
              let n = "";
              for (let a = 0; a < r.length; a++) {
                const _ = r.charCodeAt(a + 1) || null,
                  f = r.charCodeAt(a - 1) || null;
                n += _ && Hu(_) && !Ll[r[a + 1]] || f && Hu(f) && !Ll[r[a - 1]] || !Ll[r[a]] ? r[a] : Ll[r[a]]
              }
              return n
            })(this.text)
          }
          trim() {
            let r = 0;
            for (let a = 0; a < this.text.length && qh[this.text.charCodeAt(a)]; a++) r++;
            let n = this.text.length;
            for (let a = this.text.length - 1; a >= 0 && a >= r && qh[this.text.charCodeAt(a)]; a--) n--;
            this.text = this.text.substring(r, n), this.sectionIndex = this.sectionIndex.slice(r, n)
          }
          substring(r, n) {
            const a = new uc;
            return a.text = this.text.substring(r, n), a.sectionIndex = this.sectionIndex.slice(r, n), a.sections = this.sections, a
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((r, n) => Math.max(r, this.sections[n].scale)), 0)
          }
          getMaxImageSize(r) {
            let n = 0,
              a = 0;
            for (let _ = 0; _ < this.length(); _++) {
              const f = this.getSection(_);
              if (f.imageName) {
                const m = r[f.imageName];
                if (!m) continue;
                const v = m.displaySize;
                n = Math.max(n, v[0]), a = Math.max(a, v[1])
              }
            }
            return {
              maxImageWidth: n,
              maxImageHeight: a
            }
          }
          addTextSection(r, n) {
            this.text += r.text, this.sections.push(Dl.forText(r.scale, r.fontStack || n, r.verticalAlign));
            const a = this.sections.length - 1;
            for (let _ = 0; _ < r.text.length; ++_) this.sectionIndex.push(a)
          }
          addImageSection(r) {
            const n = r.image ? r.image.name : "";
            if (n.length === 0) return void nr("Can't add FormattedSection with an empty image.");
            const a = this.getNextImageSectionCharCode();
            a ? (this.text += String.fromCharCode(a), this.sections.push(Dl.forImage(n, r.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : nr("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function Oh(i, r, n, a, _, f, m, v, b, S, M, j, O, N, H) {
          const J = uc.fromFeature(i, _);
          let rt;
          j === k.as.vertical && J.verticalizePunctuation();
          const {
            processBidirectionalText: ht,
            processStyledBidirectionalText: Ot
          } = _s;
          if (ht && J.sections.length === 1) {
            rt = [];
            const te = ht(J.toString(), gp(J, S, f, r, a, N));
            for (const le of te) {
              const Re = new uc;
              Re.text = le, Re.sections = J.sections;
              for (let br = 0; br < le.length; br++) Re.sectionIndex.push(0);
              rt.push(Re)
            }
          } else if (Ot) {
            rt = [];
            const te = Ot(J.text, J.sectionIndex, gp(J, S, f, r, a, N));
            for (const le of te) {
              const Re = new uc;
              Re.text = le[0], Re.sectionIndex = le[1], Re.sections = J.sections, rt.push(Re)
            }
          } else rt = (function(te, le) {
            const Re = [],
              br = te.text;
            let ar = 0;
            for (const yr of le) Re.push(te.substring(ar, yr)), ar = yr;
            return ar < br.length && Re.push(te.substring(ar, br.length)), Re
          })(J, gp(J, S, f, r, a, N));
          const bt = [],
            Mt = {
              positionedLines: bt,
              text: J.toString(),
              top: M[1],
              bottom: M[1],
              left: M[0],
              right: M[0],
              writingMode: j,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(te, le, Re, br, ar, yr, Yr, fr, vr, ke, an, hn) {
            let Qr = 0,
              Wr = 0,
              Dn = 0,
              fi = 0;
            const Li = fr === "right" ? 1 : fr === "left" ? 0 : .5,
              so = Ni / hn;
            let Ho = 0;
            for (const hi of ar) {
              hi.trim();
              const Vi = hi.getMaxScale(),
                Yi = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              te.positionedLines[Ho] = Yi;
              const Ki = Yi.positionedGlyphs;
              let yo = 0;
              if (!hi.length()) {
                Wr += yr, ++Ho;
                continue
              }
              const Wo = Ab(br, hi, so);
              for (let Po = 0; Po < hi.length(); Po++) {
                const Di = hi.getSection(Po),
                  Zi = hi.getSectionIndex(Po),
                  Gi = hi.getCharCode(Po),
                  zi = Eb(vr, an, Gi);
                let ii;
                if (Di.imageName) {
                  if (te.iconsInText = !0, Di.scale = Di.scale * so, ii = Lb(Di, zi, Vi, Wo, br), !ii) continue;
                  yo = Math.max(yo, ii.imageOffset)
                } else if (ii = jb(Di, Gi, zi, Wo, le, Re), !ii) continue;
                const {
                  rect: ms,
                  metrics: hc,
                  baselineOffset: gs
                } = ii;
                Ki.push({
                  glyph: Gi,
                  imageName: Di.imageName,
                  x: Qr,
                  y: Wr + gs + -17,
                  vertical: zi,
                  scale: Di.scale,
                  fontStack: Di.fontStack,
                  sectionIndex: Zi,
                  metrics: hc,
                  rect: ms
                }), zi ? (te.verticalizable = !0, Qr += (Di.imageName ? hc.advance : Ni) * Di.scale + ke) : Qr += hc.advance * Di.scale + ke
              }
              Ki.length !== 0 && (Dn = Math.max(Qr - ke, Dn), Db(Ki, 0, Ki.length - 1, Li)), Qr = 0, Yi.lineOffset = Math.max(yo, (Vi - 1) * Ni);
              const Ui = yr * Vi + yo;
              Wr += Ui, fi = Math.max(Ui, fi), ++Ho
            }
            const {
              horizontalAlign: So,
              verticalAlign: Xi
            } = yp(Yr);
            (function(hi, Vi, Yi, Ki, yo, Wo, Ui, Po, Di) {
              const Zi = (Vi - Yi) * yo;
              let Gi = 0;
              Gi = Wo !== Ui ? -Po * Ki - -17 : -Ki * Di * Ui + .5 * Ui;
              for (const zi of hi)
                for (const ii of zi.positionedGlyphs) ii.x += Zi, ii.y += Gi
            })(te.positionedLines, Li, So, Xi, Dn, fi, yr, Wr, ar.length), te.top += -Xi * Wr, te.bottom = te.top + Wr, te.left += -So * Dn, te.right = te.left + Dn
          })(Mt, r, n, a, rt, m, v, b, j, S, O, H), !(function(te) {
            for (const le of te)
              if (le.positionedGlyphs.length !== 0) return !1;
            return !0
          })(bt) && Mt
        }
        const qh = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          Cb = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          Ib = {
            40: !0
          };

        function cg(i, r, n, a, _, f) {
          if (r.imageName) {
            const m = a[r.imageName];
            return m ? m.displaySize[0] * r.scale * Ni / f + _ : 0
          } {
            const m = n[r.fontStack],
              v = m && m[i];
            return v ? v.metrics.advance * r.scale + _ : 0
          }
        }

        function lg(i, r, n, a) {
          const _ = Math.pow(i - r, 2);
          return a ? i < r ? _ / 2 : 2 * _ : _ + Math.abs(n) * n
        }

        function zb(i, r, n) {
          let a = 0;
          return i === 10 && (a -= 1e4), n && (a += 150), i !== 40 && i !== 65288 || (a += 50), r !== 41 && r !== 65289 || (a += 50), a
        }

        function _g(i, r, n, a, _, f) {
          let m = null,
            v = lg(r, n, _, f);
          for (const b of a) {
            const S = lg(r - b.x, n, _, f) + b.badness;
            S <= v && (m = b, v = S)
          }
          return {
            index: i,
            x: r,
            priorBreak: m,
            badness: v
          }
        }

        function hg(i) {
          return i ? hg(i.priorBreak).concat(i.index) : []
        }

        function gp(i, r, n, a, _, f) {
          if (!i) return [];
          const m = [],
            v = (function(j, O, N, H, J, rt) {
              let ht = 0;
              for (let Ot = 0; Ot < j.length(); Ot++) {
                const bt = j.getSection(Ot);
                ht += cg(j.getCharCode(Ot), bt, H, J, O, rt)
              }
              return ht / Math.max(1, Math.ceil(ht / N))
            })(i, r, n, a, _, f),
            b = i.text.indexOf("â€‹") >= 0;
          let S = 0;
          for (let j = 0; j < i.length(); j++) {
            const O = i.getSection(j),
              N = i.getCharCode(j);
            if (qh[N] || (S += cg(N, O, a, _, r, f)), j < i.length() - 1) {
              const H = !((M = N) < 11904) && (!!zn["CJK Compatibility Forms"](M) || !!zn["CJK Compatibility"](M) || !!zn["CJK Strokes"](M) || !!zn["CJK Symbols and Punctuation"](M) || !!zn["Enclosed CJK Letters and Months"](M) || !!zn["Halfwidth and Fullwidth Forms"](M) || !!zn["Ideographic Description Characters"](M) || !!zn["Vertical Forms"](M) || dl.test(String.fromCodePoint(M)));
              (Cb[N] || H || O.imageName || j !== i.length() - 2 && Ib[i.getCharCode(j + 1)]) && m.push(_g(j + 1, S, v, m, zb(N, i.getCharCode(j + 1), H && b), !1))
            }
          }
          var M;
          return hg(_g(i.length(), S, v, m, 0, !0))
        }

        function yp(i) {
          let r = .5,
            n = .5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              r = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              r = 0
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0
          }
          return {
            horizontalAlign: r,
            verticalAlign: n
          }
        }

        function Ab(i, r, n) {
          const a = r.getMaxScale() * Ni,
            {
              maxImageWidth: _,
              maxImageHeight: f
            } = r.getMaxImageSize(i),
            m = Math.max(a, f * n);
          return {
            verticalLineContentWidth: Math.max(a, _ * n),
            horizontalLineContentHeight: m
          }
        }

        function dg(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function Eb(i, r, n) {
          return !(i === k.as.horizontal || !r && !Gu(n) || r && (qh[n] || (a = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(a)))));
          var a
        }

        function jb(i, r, n, a, _, f) {
          const m = f[i.fontStack],
            v = (function(S, M, j, O) {
              if (S && S.rect) return S;
              const N = M[j.fontStack],
                H = N && N[O];
              return H ? {
                rect: null,
                metrics: H.metrics
              } : null
            })(m && m[r], _, i, r);
          if (v === null) return null;
          let b;
          if (n) b = a.verticalLineContentWidth - i.scale * Ni;
          else {
            const S = dg(i.verticalAlign);
            b = (a.horizontalLineContentHeight - i.scale * Ni) * S
          }
          return {
            rect: v.rect,
            metrics: v.metrics,
            baselineOffset: b
          }
        }

        function Lb(i, r, n, a, _) {
          const f = _[i.imageName];
          if (!f) return null;
          const m = f.paddedRect,
            v = f.displaySize,
            b = {
              width: v[0],
              height: v[1],
              left: 1,
              top: -3,
              advance: r ? v[1] : v[0]
            };
          let S;
          if (r) S = a.verticalLineContentWidth - v[1] * i.scale;
          else {
            const M = dg(i.verticalAlign);
            S = (a.horizontalLineContentHeight - v[1] * i.scale) * M
          }
          return {
            rect: m,
            metrics: b,
            baselineOffset: S,
            imageOffset: (r ? v[0] : v[1]) * i.scale - Ni * n
          }
        }

        function Db(i, r, n, a) {
          if (a === 0) return;
          const _ = i[n],
            f = (i[n].x + _.metrics.advance * _.scale) * a;
          for (let m = r; m <= n; m++) i[m].x -= f
        }

        function Rb(i, r, n) {
          const {
            horizontalAlign: a,
            verticalAlign: _
          } = yp(n), f = r[0] - i.displaySize[0] * a, m = r[1] - i.displaySize[1] * _;
          return {
            image: i,
            top: m,
            bottom: m + i.displaySize[1],
            left: f,
            right: f + i.displaySize[0]
          }
        }

        function pg(i) {
          var r, n;
          let a = i.left,
            _ = i.top,
            f = i.right - a,
            m = i.bottom - _;
          const v = (r = i.image.textFitWidth) !== null && r !== void 0 ? r : "stretchOrShrink",
            b = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink",
            S = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (b === "proportional") {
            if (v === "stretchOnly" && f / m < S || v === "proportional") {
              const M = Math.ceil(m * S);
              a *= M / f, f = M
            }
          } else if (v === "proportional" && b === "stretchOnly" && S !== 0 && f / m > S) {
            const M = Math.ceil(f / S);
            _ *= M / m, m = M
          }
          return {
            x1: a,
            y1: _,
            x2: a + f,
            y2: _ + m
          }
        }

        function fg(i, r, n, a, _, f) {
          const m = i.image;
          let v;
          if (m.content) {
            const rt = m.content,
              ht = m.pixelRatio || 1;
            v = [rt[0] / ht, rt[1] / ht, m.displaySize[0] - rt[2] / ht, m.displaySize[1] - rt[3] / ht]
          }
          const b = r.left * f,
            S = r.right * f;
          let M, j, O, N;
          n === "width" || n === "both" ? (N = _[0] + b - a[3], j = _[0] + S + a[1]) : (N = _[0] + (b + S - m.displaySize[0]) / 2, j = N + m.displaySize[0]);
          const H = r.top * f,
            J = r.bottom * f;
          return n === "height" || n === "both" ? (M = _[1] + H - a[0], O = _[1] + J + a[2]) : (M = _[1] + (H + J - m.displaySize[1]) / 2, O = M + m.displaySize[1]), {
            image: m,
            top: M,
            right: j,
            bottom: O,
            left: N,
            collisionPadding: v
          }
        }
        const na = 128,
          Ea = 32640;

        function mg(i, r) {
          const {
            expression: n
          } = r;
          if (n.kind === "constant") return {
            kind: "constant",
            layoutSize: n.evaluate(new Kn(i + 1))
          };
          if (n.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: a,
              interpolationType: _
            } = n;
            let f = 0;
            for (; f < a.length && a[f] <= i;) f++;
            f = Math.max(0, f - 1);
            let m = f;
            for (; m < a.length && a[m] < i + 1;) m++;
            m = Math.min(a.length - 1, m);
            const v = a[f],
              b = a[m];
            return n.kind === "composite" ? {
              kind: "composite",
              minZoom: v,
              maxZoom: b,
              interpolationType: _
            } : {
              kind: "camera",
              minZoom: v,
              maxZoom: b,
              minSize: n.evaluate(new Kn(v)),
              maxSize: n.evaluate(new Kn(b)),
              interpolationType: _
            }
          }
        }

        function vp(i, r, n) {
          let a = "never";
          const _ = i.get(r);
          return _ ? a = _ : i.get(n) && (a = "always"), a
        }
        const Bb = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function Nh(i, r, n, a, _, f, m, v, b, S, M, j, O) {
          const N = v ? Math.min(Ea, Math.round(v[0])) : 0,
            H = v ? Math.min(Ea, Math.round(v[1])) : 0;
          i.emplaceBack(r, n, Math.round(32 * a), Math.round(32 * _), f, m, (N << 1) + (b ? 1 : 0), H, 16 * S, 16 * M, 256 * j, 256 * O)
        }

        function bp(i, r, n) {
          i.emplaceBack(r.x, r.y, n), i.emplaceBack(r.x, r.y, n), i.emplaceBack(r.x, r.y, n), i.emplaceBack(r.x, r.y, n)
        }

        function Fb(i) {
          for (const r of i.sections)
            if (Xd(r.text)) return !0;
          return !1
        }
        class xp {
          constructor(r) {
            this.layoutVertexArray = new Qt, this.indexArray = new Pe, this.programConfigurations = r, this.segments = new Tn, this.dynamicLayoutVertexArray = new re, this.opacityVertexArray = new ue, this.hasVisibleVertices = !1, this.placedSymbolArray = new I
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(r, n, a, _) {
            this.isEmpty() || (a && (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, _b.members), this.indexBuffer = r.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = r.createVertexBuffer(this.dynamicLayoutVertexArray, hb.members, !0), this.opacityVertexBuffer = r.createVertexBuffer(this.opacityVertexArray, Bb, !0), this.opacityVertexBuffer.itemSize = 1), (a || _) && this.programConfigurations.upload(r))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Sr("SymbolBuffers", xp);
        class wp {
          constructor(r, n, a) {
            this.layoutVertexArray = new r, this.layoutAttributes = n, this.indexArray = new a, this.segments = new Tn, this.collisionVertexArray = new tr
          }
          upload(r) {
            this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = r.createVertexBuffer(this.collisionVertexArray, db.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Sr("CollisionBuffers", wp);
        class cc {
          constructor(r) {
            this.collisionBoxArray = r.collisionBoxArray, this.zoom = r.zoom, this.overscaling = or(globalThis) ? Math.min(r.overscaling, 128) : r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map((m => m.id)), this.index = r.index, this.pixelRatio = r.pixelRatio, this.sourceLayerIndex = r.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = mg(this.zoom, n["text-size"]), this.iconSizeData = mg(this.zoom, n["icon-size"]);
            const a = this.layers[0].layout,
              _ = a.get("symbol-sort-key"),
              f = a.get("symbol-z-order");
            this.canOverlap = vp(a, "text-overlap", "text-allow-overlap") !== "never" || vp(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = f !== "viewport-y" && !_.isConstant(), this.sortFeaturesByY = (f === "viewport-y" || f === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((m => k.as[m]))), this.stateDependentLayerIds = this.layers.filter((m => m.isStateDependent())).map((m => m.id)), this.sourceID = r.sourceID
          }
          createArrays() {
            this.text = new xp(new ea(this.layers, this.zoom, (r => /^text/.test(r)))), this.icon = new xp(new ea(this.layers, this.zoom, (r => /^icon/.test(r)))), this.glyphOffsetArray = new L, this.lineVertexArray = new V, this.symbolInstances = new F, this.textAnchorOffsets = new it
          }
          calculateGlyphDependencies(r, n, a, _, f) {
            for (let m = 0; m < r.length; m++)
              if (n[r.charCodeAt(m)] = !0, (a || _) && f) {
                const v = Ll[r.charAt(m)];
                v && (n[v.charCodeAt(0)] = !0)
              }
          }
          populate(r, n, a) {
            const _ = this.layers[0],
              f = _.layout,
              m = f.get("text-font"),
              v = f.get("text-field"),
              b = f.get("icon-image"),
              S = (v.value.kind !== "constant" || v.value.value instanceof sn && !v.value.value.isEmpty() || v.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0),
              M = b.value.kind !== "constant" || !!b.value.value || Object.keys(b.parameters).length > 0,
              j = f.get("symbol-sort-key");
            if (this.features = [], !S && !M) return;
            const O = n.iconDependencies,
              N = n.glyphDependencies,
              H = n.availableImages,
              J = new Kn(this.zoom);
            for (const {
                feature: rt,
                id: ht,
                index: Ot,
                sourceLayerIndex: bt
              }
              of r) {
              const Mt = _._featureFilter.needGeometry,
                te = zs(rt, Mt);
              if (!_._featureFilter.filter(J, te, a)) continue;
              let le, Re;
              if (Mt || (te.geometry = fs(rt)), S) {
                const ar = _.getValueAndResolveTokens("text-field", te, a, H),
                  yr = sn.factory(ar),
                  Yr = this.hasRTLText = this.hasRTLText || Fb(yr);
                (!Yr || _s.getRTLTextPluginStatus() === "unavailable" || Yr && _s.isParsed()) && (le = fb(yr, _, te))
              }
              if (M) {
                const ar = _.getValueAndResolveTokens("icon-image", te, a, H);
                Re = ar instanceof ki ? ar : ki.fromString(ar)
              }
              if (!le && !Re) continue;
              const br = this.sortFeaturesByKey ? j.evaluate(te, {}, a) : void 0;
              if (this.features.push({
                  id: ht,
                  text: le,
                  icon: Re,
                  index: Ot,
                  sourceLayerIndex: bt,
                  geometry: te.geometry,
                  properties: rt.properties,
                  type: sc.types[rt.type],
                  sortKey: br
                }), Re && (O[Re.name] = !0), le) {
                const ar = m.evaluate(te, {}, a).join(","),
                  yr = f.get("text-rotation-alignment") !== "viewport" && f.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(k.as.vertical) >= 0;
                for (const Yr of le.sections)
                  if (Yr.image) O[Yr.image.name] = !0;
                  else {
                    const fr = _l(le.toString()),
                      vr = Yr.fontStack || ar,
                      ke = N[vr] = N[vr] || {};
                    this.calculateGlyphDependencies(Yr.text, ke, yr, this.allowVerticalPlacement, fr)
                  }
              }
            }
            f.get("symbol-placement") === "line" && (this.features = (function(rt) {
              const ht = {},
                Ot = {},
                bt = [];
              let Mt = 0;

              function te(ar) {
                bt.push(rt[ar]), Mt++
              }

              function le(ar, yr, Yr) {
                const fr = Ot[ar];
                return delete Ot[ar], Ot[yr] = fr, bt[fr].geometry[0].pop(), bt[fr].geometry[0] = bt[fr].geometry[0].concat(Yr[0]), fr
              }

              function Re(ar, yr, Yr) {
                const fr = ht[yr];
                return delete ht[yr], ht[ar] = fr, bt[fr].geometry[0].shift(), bt[fr].geometry[0] = Yr[0].concat(bt[fr].geometry[0]), fr
              }

              function br(ar, yr, Yr) {
                const fr = Yr ? yr[0][yr[0].length - 1] : yr[0][0];
                return `${ar}:${fr.x}:${fr.y}`
              }
              for (let ar = 0; ar < rt.length; ar++) {
                const yr = rt[ar],
                  Yr = yr.geometry,
                  fr = yr.text ? yr.text.toString() : null;
                if (!fr) {
                  te(ar);
                  continue
                }
                const vr = br(fr, Yr),
                  ke = br(fr, Yr, !0);
                if (vr in Ot && ke in ht && Ot[vr] !== ht[ke]) {
                  const an = Re(vr, ke, Yr),
                    hn = le(vr, ke, bt[an].geometry);
                  delete ht[vr], delete Ot[ke], Ot[br(fr, bt[hn].geometry, !0)] = hn, bt[an].geometry = null
                } else vr in Ot ? le(vr, ke, Yr) : ke in ht ? Re(vr, ke, Yr) : (te(ar), ht[vr] = Mt - 1, Ot[ke] = Mt - 1)
              }
              return bt.filter((ar => ar.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((rt, ht) => rt.sortKey - ht.sortKey))
          }
          update(r, n, a) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(r, n, this.layers, {
              imagePositions: a
            }), this.icon.programConfigurations.updatePaintArrays(r, n, this.layers, {
              imagePositions: a
            }))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(r) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(r), this.iconCollisionBox.upload(r)), this.text.upload(r, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(r, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(r, n) {
            const a = this.lineVertexArray.length;
            if (r.segment !== void 0) {
              let _ = r.dist(n[r.segment + 1]),
                f = r.dist(n[r.segment]);
              const m = {};
              for (let v = r.segment + 1; v < n.length; v++) m[v] = {
                x: n[v].x,
                y: n[v].y,
                tileUnitDistanceFromAnchor: _
              }, v < n.length - 1 && (_ += n[v + 1].dist(n[v]));
              for (let v = r.segment || 0; v >= 0; v--) m[v] = {
                x: n[v].x,
                y: n[v].y,
                tileUnitDistanceFromAnchor: f
              }, v > 0 && (f += n[v - 1].dist(n[v]));
              for (let v = 0; v < n.length; v++) {
                const b = m[v];
                this.lineVertexArray.emplaceBack(b.x, b.y, b.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: a,
              lineLength: this.lineVertexArray.length - a
            }
          }
          addSymbols(r, n, a, _, f, m, v, b, S, M, j, O) {
            const N = r.indexArray,
              H = r.layoutVertexArray,
              J = r.segments.prepareSegment(4 * n.length, H, N, this.canOverlap ? m.sortKey : void 0),
              rt = this.glyphOffsetArray.length,
              ht = J.vertexLength,
              Ot = this.allowVerticalPlacement && v === k.as.vertical ? Math.PI / 2 : 0,
              bt = m.text && m.text.sections;
            for (let Mt = 0; Mt < n.length; Mt++) {
              const {
                tl: te,
                tr: le,
                bl: Re,
                br,
                tex: ar,
                pixelOffsetTL: yr,
                pixelOffsetBR: Yr,
                minFontScaleX: fr,
                minFontScaleY: vr,
                glyphOffset: ke,
                isSDF: an,
                sectionIndex: hn
              } = n[Mt], Qr = J.vertexLength, Wr = ke[1];
              Nh(H, b.x, b.y, te.x, Wr + te.y, ar.x, ar.y, a, an, yr.x, yr.y, fr, vr), Nh(H, b.x, b.y, le.x, Wr + le.y, ar.x + ar.w, ar.y, a, an, Yr.x, yr.y, fr, vr), Nh(H, b.x, b.y, Re.x, Wr + Re.y, ar.x, ar.y + ar.h, a, an, yr.x, Yr.y, fr, vr), Nh(H, b.x, b.y, br.x, Wr + br.y, ar.x + ar.w, ar.y + ar.h, a, an, Yr.x, Yr.y, fr, vr), bp(r.dynamicLayoutVertexArray, b, Ot), N.emplaceBack(Qr, Qr + 2, Qr + 1), N.emplaceBack(Qr + 1, Qr + 2, Qr + 3), J.vertexLength += 4, J.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ke[0]), Mt !== n.length - 1 && hn === n[Mt + 1].sectionIndex || r.programConfigurations.populatePaintArrays(H.length, m, m.index, {
                imagePositions: {},
                canonical: O,
                formattedSection: bt && bt[hn]
              })
            }
            r.placedSymbolArray.emplaceBack(b.x, b.y, rt, this.glyphOffsetArray.length - rt, ht, S, M, b.segment, a ? a[0] : 0, a ? a[1] : 0, _[0], _[1], v, 0, !1, 0, j)
          }
          _addCollisionDebugVertex(r, n, a, _, f, m) {
            return n.emplaceBack(0, 0), r.emplaceBack(a.x, a.y, _, f, Math.round(m.x), Math.round(m.y))
          }
          addCollisionDebugVertices(r, n, a, _, f, m, v) {
            const b = f.segments.prepareSegment(4, f.layoutVertexArray, f.indexArray),
              S = b.vertexLength,
              M = f.layoutVertexArray,
              j = f.collisionVertexArray,
              O = v.anchorX,
              N = v.anchorY;
            this._addCollisionDebugVertex(M, j, m, O, N, new R(r, n)), this._addCollisionDebugVertex(M, j, m, O, N, new R(a, n)), this._addCollisionDebugVertex(M, j, m, O, N, new R(a, _)), this._addCollisionDebugVertex(M, j, m, O, N, new R(r, _)), b.vertexLength += 4;
            const H = f.indexArray;
            H.emplaceBack(S, S + 1), H.emplaceBack(S + 1, S + 2), H.emplaceBack(S + 2, S + 3), H.emplaceBack(S + 3, S), b.primitiveLength += 4
          }
          addDebugCollisionBoxes(r, n, a, _) {
            for (let f = r; f < n; f++) {
              const m = this.collisionBoxArray.get(f);
              this.addCollisionDebugVertices(m.x1, m.y1, m.x2, m.y2, _ ? this.textCollisionBox : this.iconCollisionBox, m.anchorPoint, a)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new wp(Je, ng.members, Fr), this.iconCollisionBox = new wp(Je, ng.members, Fr);
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const n = this.symbolInstances.get(r);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(r, n, a, _, f, m, v, b, S) {
            const M = {};
            for (let j = n; j < a; j++) {
              const O = r.get(j);
              M.textBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, M.textFeatureIndex = O.featureIndex;
              break
            }
            for (let j = _; j < f; j++) {
              const O = r.get(j);
              M.verticalTextBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, M.verticalTextFeatureIndex = O.featureIndex;
              break
            }
            for (let j = m; j < v; j++) {
              const O = r.get(j);
              M.iconBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, M.iconFeatureIndex = O.featureIndex;
              break
            }
            for (let j = b; j < S; j++) {
              const O = r.get(j);
              M.verticalIconBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, M.verticalIconFeatureIndex = O.featureIndex;
              break
            }
            return M
          }
          deserializeCollisionBoxes(r) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const a = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(r, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(r, n) {
            const a = r.placedSymbolArray.get(n),
              _ = a.vertexStartIndex + 4 * a.numGlyphs;
            for (let f = a.vertexStartIndex; f < _; f += 4) r.indexArray.emplaceBack(f, f + 2, f + 1), r.indexArray.emplaceBack(f + 1, f + 2, f + 3)
          }
          getSortedSymbolIndexes(r) {
            if (this.sortedAngle === r && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(r),
              a = Math.cos(r),
              _ = [],
              f = [],
              m = [];
            for (let v = 0; v < this.symbolInstances.length; ++v) {
              m.push(v);
              const b = this.symbolInstances.get(v);
              _.push(0 | Math.round(n * b.anchorX + a * b.anchorY)), f.push(b.featureIndex)
            }
            return m.sort(((v, b) => _[v] - _[b] || f[b] - f[v])), m
          }
          addToSortKeyRanges(r, n) {
            const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            a && a.sortKey === n ? a.symbolInstanceEnd = r + 1 : this.sortKeyRanges.push({
              sortKey: n,
              symbolInstanceStart: r,
              symbolInstanceEnd: r + 1
            })
          }
          sortFeatures(r) {
            if (this.sortFeaturesByY && this.sortedAngle !== r && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(r), this.sortedAngle = r, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const a = this.symbolInstances.get(n);
                this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(((_, f, m) => {
                  _ >= 0 && m.indexOf(_) === f && this.addIndicesForPlacedSymbol(this.text, _)
                })), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let gg, yg;
        Sr("SymbolBucket", cc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), cc.MAX_GLYPHS = 65535, cc.addDynamicAttributes = bp;
        var kp = {
          get paint() {
            return yg = yg || new io({
              "icon-opacity": new nn(W.paint_symbol["icon-opacity"]),
              "icon-color": new nn(W.paint_symbol["icon-color"]),
              "icon-halo-color": new nn(W.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new nn(W.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new nn(W.paint_symbol["icon-halo-blur"]),
              "icon-translate": new Xr(W.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new Xr(W.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new nn(W.paint_symbol["text-opacity"]),
              "text-color": new nn(W.paint_symbol["text-color"], {
                runtimeType: fe,
                getOverride: i => i.textColor,
                hasOverride: i => !!i.textColor
              }),
              "text-halo-color": new nn(W.paint_symbol["text-halo-color"]),
              "text-halo-width": new nn(W.paint_symbol["text-halo-width"]),
              "text-halo-blur": new nn(W.paint_symbol["text-halo-blur"]),
              "text-translate": new Xr(W.paint_symbol["text-translate"]),
              "text-translate-anchor": new Xr(W.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return gg = gg || new io({
              "symbol-placement": new Xr(W.layout_symbol["symbol-placement"]),
              "symbol-spacing": new Xr(W.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new Xr(W.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new nn(W.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new Xr(W.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new Xr(W.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new Xr(W.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new Xr(W.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new Xr(W.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new Xr(W.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new nn(W.layout_symbol["icon-size"]),
              "icon-text-fit": new Xr(W.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new Xr(W.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new nn(W.layout_symbol["icon-image"]),
              "icon-rotate": new nn(W.layout_symbol["icon-rotate"]),
              "icon-padding": new nn(W.layout_symbol["icon-padding"]),
              "icon-keep-upright": new Xr(W.layout_symbol["icon-keep-upright"]),
              "icon-offset": new nn(W.layout_symbol["icon-offset"]),
              "icon-anchor": new nn(W.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new Xr(W.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new Xr(W.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new Xr(W.layout_symbol["text-rotation-alignment"]),
              "text-field": new nn(W.layout_symbol["text-field"]),
              "text-font": new nn(W.layout_symbol["text-font"]),
              "text-size": new nn(W.layout_symbol["text-size"]),
              "text-max-width": new nn(W.layout_symbol["text-max-width"]),
              "text-line-height": new Xr(W.layout_symbol["text-line-height"]),
              "text-letter-spacing": new nn(W.layout_symbol["text-letter-spacing"]),
              "text-justify": new nn(W.layout_symbol["text-justify"]),
              "text-radial-offset": new nn(W.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new Xr(W.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new nn(W.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new nn(W.layout_symbol["text-anchor"]),
              "text-max-angle": new Xr(W.layout_symbol["text-max-angle"]),
              "text-writing-mode": new Xr(W.layout_symbol["text-writing-mode"]),
              "text-rotate": new nn(W.layout_symbol["text-rotate"]),
              "text-padding": new Xr(W.layout_symbol["text-padding"]),
              "text-keep-upright": new Xr(W.layout_symbol["text-keep-upright"]),
              "text-transform": new nn(W.layout_symbol["text-transform"]),
              "text-offset": new nn(W.layout_symbol["text-offset"]),
              "text-allow-overlap": new Xr(W.layout_symbol["text-allow-overlap"]),
              "text-overlap": new Xr(W.layout_symbol["text-overlap"]),
              "text-ignore-placement": new Xr(W.layout_symbol["text-ignore-placement"]),
              "text-optional": new Xr(W.layout_symbol["text-optional"])
            })
          }
        };
        class vg {
          constructor(r) {
            if (r.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = r.property.overrides ? r.property.overrides.runtimeType : Ar, this.defaultValue = r
          }
          evaluate(r) {
            if (r.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(r.formattedSection)) return n.getOverride(r.formattedSection)
            }
            return r.feature && r.featureState ? this.defaultValue.evaluate(r.feature, r.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(r) {
            this.defaultValue.isConstant() || r(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Sr("FormatSectionOverride", vg, {
          omit: ["defaultValue"]
        });
        class Vh extends Uo {
          constructor(r, n) {
            super(r, kp, n)
          }
          recalculate(r, n) {
            if (super.recalculate(r, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const a = this.layout.get("text-writing-mode");
              if (a) {
                const _ = [];
                for (const f of a) _.indexOf(f) < 0 && _.push(f);
                this.layout._values["text-writing-mode"] = _
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(r, n, a, _) {
            const f = this.layout.get(r).evaluate(n, {}, a, _),
              m = this._unevaluatedLayout._values[r];
            return m.isDataDriven() || Du(m.value) || !f ? f : (function(v, b) {
              return b.replace(/{([^{}]+)}/g, ((S, M) => v && M in v ? String(v[M]) : ""))
            })(n.properties, f)
          }
          createBucket(r) {
            return new cc(r)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const r of kp.paint.overridableProperties) {
              if (!Vh.hasPaintOverride(this.layout, r)) continue;
              const n = this.paint.get(r),
                a = new vg(n),
                _ = new Kc(a, n.property.specification);
              let f = null;
              f = n.value.kind === "constant" || n.value.kind === "source" ? new Xa("source", _) : new Jc("composite", _, n.value.zoomStops), this.paint._values[r] = new Vo(n.property, f, n.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(r, n, a) {
            return !(!this.layout || n.isDataDriven() || a.isDataDriven()) && Vh.hasPaintOverride(this.layout, r)
          }
          static hasPaintOverride(r, n) {
            const a = r.get("text-field"),
              _ = kp.paint.properties[n];
            let f = !1;
            const m = v => {
              for (const b of v)
                if (_.overrides && _.overrides.hasOverride(b)) return void(f = !0)
            };
            if (a.value.kind === "constant" && a.value.value instanceof sn) m(a.value.value.sections);
            else if (a.value.kind === "source" || a.value.kind === "composite") {
              const v = S => {
                  f || (S instanceof pi && Yn(S.value) === lr ? m(S.value.sections) : S instanceof Tu ? m(S.sections) : S.eachChild(v))
                },
                b = a.value;
              b._styleExpression && v(b._styleExpression.expression)
            }
            return f
          }
        }
        let bg;
        var Ob = {
          get paint() {
            return bg = bg || new io({
              "background-color": new Xr(W.paint_background["background-color"]),
              "background-pattern": new Sh(W.paint_background["background-pattern"]),
              "background-opacity": new Xr(W.paint_background["background-opacity"])
            })
          }
        };
        class qb extends Uo {
          constructor(r, n) {
            super(r, Ob, n)
          }
        }
        class Nb extends Uo {
          constructor(r, n) {
            super(r, {}, n), this.onAdd = a => {
              this.implementation.onAdd && this.implementation.onAdd(a, a.painter.context.gl)
            }, this.onRemove = a => {
              this.implementation.onRemove && this.implementation.onRemove(a, a.painter.context.gl)
            }, this.implementation = r
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class Vb {
          constructor(r) {
            this._methodToThrottle = r, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const Ub = {
            once: !0
          },
          Tp = 63710088e-1;
        class ja {
          constructor(r, n) {
            if (isNaN(r) || isNaN(n)) throw new Error(`Invalid LngLat object: (${r}, ${n})`);
            if (this.lng = +r, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new ja(mr(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(r) {
            const n = Math.PI / 180,
              a = this.lat * n,
              _ = r.lat * n,
              f = Math.sin(a) * Math.sin(_) + Math.cos(a) * Math.cos(_) * Math.cos((r.lng - this.lng) * n);
            return Tp * Math.acos(Math.min(f, 1))
          }
          static convert(r) {
            if (r instanceof ja) return r;
            if (Array.isArray(r) && (r.length === 2 || r.length === 3)) return new ja(Number(r[0]), Number(r[1]));
            if (!Array.isArray(r) && typeof r == "object" && r !== null) return new ja(Number("lng" in r ? r.lng : r.lon), Number(r.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const xg = 2 * Math.PI * Tp;

        function wg(i) {
          return xg * Math.cos(i * Math.PI / 180)
        }

        function kg(i) {
          return (180 + i) / 360
        }

        function Tg(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
        }

        function Sg(i, r) {
          return i / wg(r)
        }

        function Pg(i) {
          return 360 * i - 180
        }

        function Uh(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
        }

        function Mg(i, r) {
          return i * wg(Uh(r))
        }
        class Rl {
          constructor(r, n, a = 0) {
            this.x = +r, this.y = +n, this.z = +a
          }
          static fromLngLat(r, n = 0) {
            const a = ja.convert(r);
            return new Rl(kg(a.lng), Tg(a.lat), Sg(n, a.lat))
          }
          toLngLat() {
            return new ja(Pg(this.x), Uh(this.y))
          }
          toAltitude() {
            return Mg(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / xg * (r = Uh(this.y), 1 / Math.cos(r * Math.PI / 180));
            var r
          }
        }

        function Cg(i, r, n) {
          var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [i * a - 2 * Math.PI * 6378137 / 2, r * a - 2 * Math.PI * 6378137 / 2]
        }
        class Sp {
          constructor(r, n, a) {
            if (!(function(_, f, m) {
                return !(_ < 0 || _ > 25 || m < 0 || m >= Math.pow(2, _) || f < 0 || f >= Math.pow(2, _))
              })(r, n, a)) throw new Error(`x=${n}, y=${a}, z=${r} outside of bounds. 0<=x<${Math.pow(2,r)}, 0<=y<${Math.pow(2,r)} 0<=z<=25 `);
            this.z = r, this.x = n, this.y = a, this.key = lc(0, r, r, n, a)
          }
          equals(r) {
            return this.z === r.z && this.x === r.x && this.y === r.y
          }
          url(r, n, a) {
            const _ = (m = this.y, v = this.z, b = Cg(256 * (f = this.x), 256 * (m = Math.pow(2, v) - m - 1), v), S = Cg(256 * (f + 1), 256 * (m + 1), v), b[0] + "," + b[1] + "," + S[0] + "," + S[1]);
            var f, m, v, b, S;
            const M = (function(j, O, N) {
              let H, J = "";
              for (let rt = j; rt > 0; rt--) H = 1 << rt - 1, J += (O & H ? 1 : 0) + (N & H ? 2 : 0);
              return J
            })(this.z, this.x, this.y);
            return r[(this.x + this.y) % r.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, M).replace(/{bbox-epsg-3857}/g, _)
          }
          isChildOf(r) {
            const n = this.z - r.z;
            return n > 0 && r.x === this.x >> n && r.y === this.y >> n
          }
          getTilePoint(r) {
            const n = Math.pow(2, this.z);
            return new R((r.x * n - this.x) * ne, (r.y * n - this.y) * ne)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class Ig {
          constructor(r, n) {
            this.wrap = r, this.canonical = n, this.key = lc(r, n.z, n.z, n.x, n.y)
          }
        }
        class Go {
          constructor(r, n, a, _, f) {
            if (this.terrainRttPosMatrix32f = null, r < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${r}; z = ${a}`);
            this.overscaledZ = r, this.wrap = n, this.canonical = new Sp(a, +_, +f), this.key = lc(n, r, a, _, f)
          }
          clone() {
            return new Go(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(r) {
            return this.overscaledZ === r.overscaledZ && this.wrap === r.wrap && this.canonical.equals(r.canonical)
          }
          scaledTo(r) {
            if (r > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${r}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - r;
            return r > this.canonical.z ? new Go(r, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Go(r, this.wrap, r, this.canonical.x >> n, this.canonical.y >> n)
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z
          }
          calculateScaledKey(r, n) {
            if (r > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${r}; overscaledZ = ${this.overscaledZ}`);
            const a = this.canonical.z - r;
            return r > this.canonical.z ? lc(this.wrap * +n, r, this.canonical.z, this.canonical.x, this.canonical.y) : lc(this.wrap * +n, r, r, this.canonical.x >> a, this.canonical.y >> a)
          }
          isChildOf(r) {
            if (r.wrap !== this.wrap || this.overscaledZ - r.overscaledZ <= 0) return !1;
            if (r.overscaledZ === 0) return this.overscaledZ > 0;
            const n = this.canonical.z - r.canonical.z;
            return !(n < 0) && r.canonical.x === this.canonical.x >> n && r.canonical.y === this.canonical.y >> n
          }
          children(r) {
            if (this.overscaledZ >= r) return [new Go(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1,
              a = 2 * this.canonical.x,
              _ = 2 * this.canonical.y;
            return [new Go(n, this.wrap, n, a, _), new Go(n, this.wrap, n, a + 1, _), new Go(n, this.wrap, n, a, _ + 1), new Go(n, this.wrap, n, a + 1, _ + 1)]
          }
          isLessThan(r) {
            return this.wrap < r.wrap || !(this.wrap > r.wrap) && (this.overscaledZ < r.overscaledZ || !(this.overscaledZ > r.overscaledZ) && (this.canonical.x < r.canonical.x || !(this.canonical.x > r.canonical.x) && this.canonical.y < r.canonical.y))
          }
          wrapped() {
            return new Go(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(r) {
            return new Go(this.overscaledZ, r, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new Ig(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(r) {
            return this.canonical.getTilePoint(new Rl(r.x - this.wrap, r.y))
          }
        }

        function lc(i, r, n, a, _) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const f = 1 << n;
          return (f * f * i + f * _ + a).toString(36) + n.toString(36) + r.toString(36)
        }

        function Bl(i, r) {
          return r ? i.properties[r] : i.id
        }
        Sr("CanonicalTileID", Sp), Sr("OverscaledTileID", Go, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class cu {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(r) {
            return this.minX = Math.min(this.minX, r.x), this.minY = Math.min(this.minY, r.y), this.maxX = Math.max(this.maxX, r.x), this.maxY = Math.max(this.maxY, r.y), this
          }
          expandBy(r) {
            return this.minX -= r, this.minY -= r, this.maxX += r, this.maxY += r, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(r) {
            return this.expandBy(-r)
          }
          map(r) {
            const n = new cu;
            return n.extend(r(new R(this.minX, this.minY))), n.extend(r(new R(this.maxX, this.minY))), n.extend(r(new R(this.minX, this.maxY))), n.extend(r(new R(this.maxX, this.maxY))), n
          }
          static fromPoints(r) {
            const n = new cu;
            for (const a of r) n.extend(a);
            return n
          }
          contains(r) {
            return r.x >= this.minX && r.x <= this.maxX && r.y >= this.minY && r.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(r) {
            return !this.empty() && !r.empty() && r.minX >= this.minX && r.maxX <= this.maxX && r.minY >= this.minY && r.maxY <= this.maxY
          }
          intersects(r) {
            return !this.empty() && !r.empty() && r.minX <= this.maxX && r.maxX >= this.minX && r.minY <= this.maxY && r.maxY >= this.minY
          }
        }
        class zg {
          constructor(r) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < r.length; n++) {
              const a = r[n];
              this._stringToNumber[a] = n, this._numberToString[n] = a
            }
          }
          encode(r) {
            return this._stringToNumber[r]
          }
          decode(r) {
            if (r >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${r} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[r]
          }
        }
        class Ag {
          constructor(r, n, a, _, f) {
            this.type = "Feature", this._vectorTileFeature = r, r._z = n, r._x = a, r._y = _, this.properties = r.properties, this.id = f
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(r) {
            this._geometry = r
          }
          toJSON() {
            const r = {
              geometry: this.geometry
            };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (r[n] = this[n]);
            return r
          }
        }
        class Eg {
          constructor(r, n) {
            this.tileID = r, this.x = r.canonical.x, this.y = r.canonical.y, this.z = r.canonical.z, this.grid = new Ws(ne, 16, 0), this.grid3D = new Ws(ne, 16, 0), this.featureIndexArray = new st, this.promoteId = n
          }
          insert(r, n, a, _, f, m) {
            const v = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(a, _, f);
            const b = m ? this.grid3D : this.grid;
            for (let S = 0; S < n.length; S++) {
              const M = n[S],
                j = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let O = 0; O < M.length; O++) {
                const N = M[O];
                j[0] = Math.min(j[0], N.x), j[1] = Math.min(j[1], N.y), j[2] = Math.max(j[2], N.x), j[3] = Math.max(j[3], N.y)
              }
              j[0] < ne && j[1] < ne && j[2] >= 0 && j[3] >= 0 && b.insert(v, j[0], j[1], j[2], j[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new $m(new fp(this.rawTileData)).layers, this.sourceLayerCoder = new zg(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(r, n, a, _) {
            this.loadVTLayers();
            const f = r.params,
              m = ne / r.tileSize / r.scale,
              v = Ya(f.filter, f.globalState),
              b = r.queryGeometry,
              S = r.queryPadding * m,
              M = cu.fromPoints(b),
              j = this.grid.query(M.minX - S, M.minY - S, M.maxX + S, M.maxY + S),
              O = cu.fromPoints(r.cameraQueryGeometry).expandBy(S),
              N = this.grid3D.query(O.minX, O.minY, O.maxX, O.maxY, ((rt, ht, Ot, bt) => (function(Mt, te, le, Re, br) {
                for (const yr of Mt)
                  if (te <= yr.x && le <= yr.y && Re >= yr.x && br >= yr.y) return !0;
                const ar = [new R(te, le), new R(te, br), new R(Re, br), new R(Re, le)];
                if (Mt.length > 2) {
                  for (const yr of ar)
                    if (ec(Mt, yr)) return !0
                }
                for (let yr = 0; yr < Mt.length - 1; yr++)
                  if (v0(Mt[yr], Mt[yr + 1], ar)) return !0;
                return !1
              })(r.cameraQueryGeometry, rt - S, ht - S, Ot + S, bt + S)));
            for (const rt of N) j.push(rt);
            j.sort(Zb);
            const H = {};
            let J;
            for (let rt = 0; rt < j.length; rt++) {
              const ht = j[rt];
              if (ht === J) continue;
              J = ht;
              const Ot = this.featureIndexArray.get(ht);
              let bt = null;
              this.loadMatchingFeature(H, Ot.bucketIndex, Ot.sourceLayerIndex, Ot.featureIndex, v, f.layers, f.availableImages, n, a, _, ((Mt, te, le) => (bt || (bt = fs(Mt)), te.queryIntersectsFeature({
                queryGeometry: b,
                feature: Mt,
                featureState: le,
                geometry: bt,
                zoom: this.z,
                transform: r.transform,
                pixelsToTileUnits: m,
                pixelPosMatrix: r.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: r.getElevation
              }))))
            }
            return H
          }
          loadMatchingFeature(r, n, a, _, f, m, v, b, S, M, j) {
            const O = this.bucketLayerIDs[n];
            if (m && !O.some((rt => m.has(rt)))) return;
            const N = this.sourceLayerCoder.decode(a),
              H = this.vtLayers[N].feature(_);
            if (f.needGeometry) {
              const rt = zs(H, !0);
              if (!f.filter(new Kn(this.tileID.overscaledZ), rt, this.tileID.canonical)) return
            } else if (!f.filter(new Kn(this.tileID.overscaledZ), H)) return;
            const J = this.getId(H, N);
            for (let rt = 0; rt < O.length; rt++) {
              const ht = O[rt];
              if (m && !m.has(ht)) continue;
              const Ot = b[ht];
              if (!Ot) continue;
              let bt = {};
              J && M && (bt = M.getState(Ot.sourceLayer || "_geojsonTileLayer", J));
              const Mt = se({}, S[ht]);
              Mt.paint = jg(Mt.paint, Ot.paint, H, bt, v), Mt.layout = jg(Mt.layout, Ot.layout, H, bt, v);
              const te = !j || j(H, Ot, bt);
              if (!te) continue;
              const le = new Ag(H, this.z, this.x, this.y, J);
              le.layer = Mt;
              let Re = r[ht];
              Re === void 0 && (Re = r[ht] = []), Re.push({
                featureIndex: _,
                feature: le,
                intersectionZ: te
              })
            }
          }
          lookupSymbolFeatures(r, n, a, _, f, m, v, b) {
            const S = {};
            this.loadVTLayers();
            const M = Ya(f.filterSpec, f.globalState);
            for (const j of r) this.loadMatchingFeature(S, a, _, j, M, m, v, b, n);
            return S
          }
          hasLayer(r) {
            for (const n of this.bucketLayerIDs)
              for (const a of n)
                if (r === a) return !0;
            return !1
          }
          getId(r, n) {
            var a;
            let _ = r.id;
            return this.promoteId && (_ = r.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof _ == "boolean" && (_ = Number(_)), _ === void 0 && (!((a = r.properties) === null || a === void 0) && a.cluster) && this.promoteId && (_ = Number(r.properties.cluster_id))), _
          }
        }

        function jg(i, r, n, a, _) {
          return ur(i, ((f, m) => {
            const v = r instanceof $s ? r.get(m) : null;
            return v && v.evaluate ? v.evaluate(n, a, _) : v
          }))
        }

        function Zb(i, r) {
          return r - i
        }

        function Lg(i, r, n, a, _) {
          const f = [];
          for (let m = 0; m < i.length; m++) {
            const v = i[m];
            let b;
            for (let S = 0; S < v.length - 1; S++) {
              let M = v[S],
                j = v[S + 1];
              M.x < r && j.x < r || (M.x < r ? M = new R(r, M.y + (r - M.x) / (j.x - M.x) * (j.y - M.y))._round() : j.x < r && (j = new R(r, M.y + (r - M.x) / (j.x - M.x) * (j.y - M.y))._round()), M.y < n && j.y < n || (M.y < n ? M = new R(M.x + (n - M.y) / (j.y - M.y) * (j.x - M.x), n)._round() : j.y < n && (j = new R(M.x + (n - M.y) / (j.y - M.y) * (j.x - M.x), n)._round()), M.x >= a && j.x >= a || (M.x >= a ? M = new R(a, M.y + (a - M.x) / (j.x - M.x) * (j.y - M.y))._round() : j.x >= a && (j = new R(a, M.y + (a - M.x) / (j.x - M.x) * (j.y - M.y))._round()), M.y >= _ && j.y >= _ || (M.y >= _ ? M = new R(M.x + (_ - M.y) / (j.y - M.y) * (j.x - M.x), _)._round() : j.y >= _ && (j = new R(M.x + (_ - M.y) / (j.y - M.y) * (j.x - M.x), _)._round()), b && M.equals(b[b.length - 1]) || (b = [M], f.push(b)), b.push(j)))))
            }
          }
          return f
        }
        Sr("FeatureIndex", Eg, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class La extends R {
          constructor(r, n, a, _) {
            super(r, n), this.angle = a, _ !== void 0 && (this.segment = _)
          }
          clone() {
            return new La(this.x, this.y, this.angle, this.segment)
          }
        }

        function Dg(i, r, n, a, _) {
          if (r.segment === void 0 || n === 0) return !0;
          let f = r,
            m = r.segment + 1,
            v = 0;
          for (; v > -n / 2;) {
            if (m--, m < 0) return !1;
            v -= i[m].dist(f), f = i[m]
          }
          v += i[m].dist(i[m + 1]), m++;
          const b = [];
          let S = 0;
          for (; v < n / 2;) {
            const M = i[m],
              j = i[m + 1];
            if (!j) return !1;
            let O = i[m - 1].angleTo(M) - M.angleTo(j);
            for (O = Math.abs((O + 3 * Math.PI) % (2 * Math.PI) - Math.PI), b.push({
                distance: v,
                angleDelta: O
              }), S += O; v - b[0].distance > a;) S -= b.shift().angleDelta;
            if (S > _) return !1;
            m++, v += M.dist(j)
          }
          return !0
        }

        function Rg(i) {
          let r = 0;
          for (let n = 0; n < i.length - 1; n++) r += i[n].dist(i[n + 1]);
          return r
        }

        function Bg(i, r, n) {
          return i ? .6 * r * n : 0
        }

        function Fg(i, r) {
          return Math.max(i ? i.right - i.left : 0, r ? r.right - r.left : 0)
        }

        function Gb(i, r, n, a, _, f) {
          const m = Bg(n, _, f),
            v = Fg(n, a) * f;
          let b = 0;
          const S = Rg(i) / 2;
          for (let M = 0; M < i.length - 1; M++) {
            const j = i[M],
              O = i[M + 1],
              N = j.dist(O);
            if (b + N > S) {
              const H = (S - b) / N,
                J = Do.number(j.x, O.x, H),
                rt = Do.number(j.y, O.y, H),
                ht = new La(J, rt, O.angleTo(j), M);
              return ht._round(), !m || Dg(i, ht, v, m, r) ? ht : void 0
            }
            b += N
          }
        }

        function Hb(i, r, n, a, _, f, m, v, b) {
          const S = Bg(a, f, m),
            M = Fg(a, _),
            j = M * m,
            O = i[0].x === 0 || i[0].x === b || i[0].y === 0 || i[0].y === b;
          return r - j < r / 4 && (r = j + r / 4), Og(i, O ? r / 2 * v % r : (M / 2 + 2 * f) * m * v % r, r, S, n, j, O, !1, b)
        }

        function Og(i, r, n, a, _, f, m, v, b) {
          const S = f / 2,
            M = Rg(i);
          let j = 0,
            O = r - n,
            N = [];
          for (let H = 0; H < i.length - 1; H++) {
            const J = i[H],
              rt = i[H + 1],
              ht = J.dist(rt),
              Ot = rt.angleTo(J);
            for (; O + n < j + ht;) {
              O += n;
              const bt = (O - j) / ht,
                Mt = Do.number(J.x, rt.x, bt),
                te = Do.number(J.y, rt.y, bt);
              if (Mt >= 0 && Mt < b && te >= 0 && te < b && O - S >= 0 && O + S <= M) {
                const le = new La(Mt, te, Ot, H);
                le._round(), a && !Dg(i, le, f, a, _) || N.push(le)
              }
            }
            j += ht
          }
          return v || N.length || m || (N = Og(i, j / 2, n, a, _, f, m, !0, b)), N
        }

        function qg(i, r, n, a) {
          const _ = [],
            f = i.image,
            m = f.pixelRatio,
            v = f.paddedRect.w - 2,
            b = f.paddedRect.h - 2;
          let S = {
            x1: i.left,
            y1: i.top,
            x2: i.right,
            y2: i.bottom
          };
          const M = f.stretchX || [
              [0, v]
            ],
            j = f.stretchY || [
              [0, b]
            ],
            O = (ke, an) => ke + an[1] - an[0],
            N = M.reduce(O, 0),
            H = j.reduce(O, 0),
            J = v - N,
            rt = b - H;
          let ht = 0,
            Ot = N,
            bt = 0,
            Mt = H,
            te = 0,
            le = J,
            Re = 0,
            br = rt;
          if (f.content && a) {
            const ke = f.content,
              an = ke[2] - ke[0],
              hn = ke[3] - ke[1];
            (f.textFitWidth || f.textFitHeight) && (S = pg(i)), ht = Zh(M, 0, ke[0]), bt = Zh(j, 0, ke[1]), Ot = Zh(M, ke[0], ke[2]), Mt = Zh(j, ke[1], ke[3]), te = ke[0] - ht, Re = ke[1] - bt, le = an - Ot, br = hn - Mt
          }
          const ar = S.x1,
            yr = S.y1,
            Yr = S.x2 - ar,
            fr = S.y2 - yr,
            vr = (ke, an, hn, Qr) => {
              const Wr = Gh(ke.stretch - ht, Ot, Yr, ar),
                Dn = Hh(ke.fixed - te, le, ke.stretch, N),
                fi = Gh(an.stretch - bt, Mt, fr, yr),
                Li = Hh(an.fixed - Re, br, an.stretch, H),
                so = Gh(hn.stretch - ht, Ot, Yr, ar),
                Ho = Hh(hn.fixed - te, le, hn.stretch, N),
                So = Gh(Qr.stretch - bt, Mt, fr, yr),
                Xi = Hh(Qr.fixed - Re, br, Qr.stretch, H),
                hi = new R(Wr, fi),
                Vi = new R(so, fi),
                Yi = new R(so, So),
                Ki = new R(Wr, So),
                yo = new R(Dn / m, Li / m),
                Wo = new R(Ho / m, Xi / m),
                Ui = r * Math.PI / 180;
              if (Ui) {
                const Zi = Math.sin(Ui),
                  Gi = Math.cos(Ui),
                  zi = [Gi, -Zi, Zi, Gi];
                hi._matMult(zi), Vi._matMult(zi), Ki._matMult(zi), Yi._matMult(zi)
              }
              const Po = ke.stretch + ke.fixed,
                Di = an.stretch + an.fixed;
              return {
                tl: hi,
                tr: Vi,
                bl: Ki,
                br: Yi,
                tex: {
                  x: f.paddedRect.x + 1 + Po,
                  y: f.paddedRect.y + 1 + Di,
                  w: hn.stretch + hn.fixed - Po,
                  h: Qr.stretch + Qr.fixed - Di
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: yo,
                pixelOffsetBR: Wo,
                minFontScaleX: le / m / Yr,
                minFontScaleY: br / m / fr,
                isSDF: n
              }
            };
          if (a && (f.stretchX || f.stretchY)) {
            const ke = Ng(M, J, N),
              an = Ng(j, rt, H);
            for (let hn = 0; hn < ke.length - 1; hn++) {
              const Qr = ke[hn],
                Wr = ke[hn + 1];
              for (let Dn = 0; Dn < an.length - 1; Dn++) _.push(vr(Qr, an[Dn], Wr, an[Dn + 1]))
            }
          } else _.push(vr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: v + 1
          }, {
            fixed: 0,
            stretch: b + 1
          }));
          return _
        }

        function Zh(i, r, n) {
          let a = 0;
          for (const _ of i) a += Math.max(r, Math.min(n, _[1])) - Math.max(r, Math.min(n, _[0]));
          return a
        }

        function Ng(i, r, n) {
          const a = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [_, f] of i) {
            const m = a[a.length - 1];
            a.push({
              fixed: _ - m.stretch,
              stretch: m.stretch
            }), a.push({
              fixed: _ - m.stretch,
              stretch: m.stretch + (f - _)
            })
          }
          return a.push({
            fixed: r + 1,
            stretch: n
          }), a
        }

        function Gh(i, r, n, a) {
          return i / r * n + a
        }

        function Hh(i, r, n, a) {
          return i - r * n / a
        }
        Sr("Anchor", La);
        class Wh {
          constructor(r, n, a, _, f, m, v, b, S, M) {
            var j;
            if (this.boxStartIndex = r.length, S) {
              let O = m.top,
                N = m.bottom;
              const H = m.collisionPadding;
              H && (O -= H[1], N += H[3]);
              let J = N - O;
              J > 0 && (J = Math.max(10, J), this.circleDiameter = J)
            } else {
              const O = !((j = m.image) === null || j === void 0) && j.content && (m.image.textFitWidth || m.image.textFitHeight) ? pg(m) : {
                x1: m.left,
                y1: m.top,
                x2: m.right,
                y2: m.bottom
              };
              O.y1 = O.y1 * v - b[0], O.y2 = O.y2 * v + b[2], O.x1 = O.x1 * v - b[3], O.x2 = O.x2 * v + b[1];
              const N = m.collisionPadding;
              if (N && (O.x1 -= N[0] * v, O.y1 -= N[1] * v, O.x2 += N[2] * v, O.y2 += N[3] * v), M) {
                const H = new R(O.x1, O.y1),
                  J = new R(O.x2, O.y1),
                  rt = new R(O.x1, O.y2),
                  ht = new R(O.x2, O.y2),
                  Ot = M * Math.PI / 180;
                H._rotate(Ot), J._rotate(Ot), rt._rotate(Ot), ht._rotate(Ot), O.x1 = Math.min(H.x, J.x, rt.x, ht.x), O.x2 = Math.max(H.x, J.x, rt.x, ht.x), O.y1 = Math.min(H.y, J.y, rt.y, ht.y), O.y2 = Math.max(H.y, J.y, rt.y, ht.y)
              }
              r.emplaceBack(n.x, n.y, O.x1, O.y1, O.x2, O.y2, a, _, f)
            }
            this.boxEndIndex = r.length
          }
        }
        class Wb {
          constructor(r = [], n = (a, _) => a < _ ? -1 : a > _ ? 1 : 0) {
            if (this.data = r, this.length = this.data.length, this.compare = n, this.length > 0)
              for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a)
          }
          push(r) {
            this.data.push(r), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const r = this.data[0],
              n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), r
          }
          peek() {
            return this.data[0]
          }
          _up(r) {
            const {
              data: n,
              compare: a
            } = this, _ = n[r];
            for (; r > 0;) {
              const f = r - 1 >> 1,
                m = n[f];
              if (a(_, m) >= 0) break;
              n[r] = m, r = f
            }
            n[r] = _
          }
          _down(r) {
            const {
              data: n,
              compare: a
            } = this, _ = this.length >> 1, f = n[r];
            for (; r < _;) {
              let m = 1 + (r << 1);
              const v = m + 1;
              if (v < this.length && a(n[v], n[m]) < 0 && (m = v), a(n[m], f) >= 0) break;
              n[r] = n[m], r = m
            }
            n[r] = f
          }
        }

        function $b(i, r = 1, n = !1) {
          const a = cu.fromPoints(i[0]),
            _ = Math.min(a.width(), a.height());
          let f = _ / 2;
          const m = new Wb([], Xb),
            {
              minX: v,
              minY: b,
              maxX: S,
              maxY: M
            } = a;
          if (_ === 0) return new R(v, b);
          for (let N = v; N < S; N += _)
            for (let H = b; H < M; H += _) m.push(new _c(N + f, H + f, f, i));
          let j = (function(N) {
              let H = 0,
                J = 0,
                rt = 0;
              const ht = N[0];
              for (let Ot = 0, bt = ht.length, Mt = bt - 1; Ot < bt; Mt = Ot++) {
                const te = ht[Ot],
                  le = ht[Mt],
                  Re = te.x * le.y - le.x * te.y;
                J += (te.x + le.x) * Re, rt += (te.y + le.y) * Re, H += 3 * Re
              }
              return new _c(J / H, rt / H, 0, N)
            })(i),
            O = m.length;
          for (; m.length;) {
            const N = m.pop();
            (N.d > j.d || !j.d) && (j = N, n && console.log("found best %d after %d probes", Math.round(1e4 * N.d) / 1e4, O)), N.max - j.d <= r || (f = N.h / 2, m.push(new _c(N.p.x - f, N.p.y - f, f, i)), m.push(new _c(N.p.x + f, N.p.y - f, f, i)), m.push(new _c(N.p.x - f, N.p.y + f, f, i)), m.push(new _c(N.p.x + f, N.p.y + f, f, i)), O += 4)
          }
          return n && (console.log(`num probes: ${O}`), console.log(`best distance: ${j.d}`)), j.p
        }

        function Xb(i, r) {
          return r.max - i.max
        }

        function _c(i, r, n, a) {
          this.p = new R(i, r), this.h = n, this.d = (function(_, f) {
            let m = !1,
              v = 1 / 0;
            for (let b = 0; b < f.length; b++) {
              const S = f[b];
              for (let M = 0, j = S.length, O = j - 1; M < j; O = M++) {
                const N = S[M],
                  H = S[O];
                N.y > _.y != H.y > _.y && _.x < (H.x - N.x) * (_.y - N.y) / (H.y - N.y) + N.x && (m = !m), v = Math.min(v, Sm(_, N, H))
              }
            }
            return (m ? 1 : -1) * Math.sqrt(v)
          })(this.p, a), this.max = this.d + this.h * Math.SQRT2
        }
        var oo;
        k.aI = void 0, (oo = k.aI || (k.aI = {}))[oo.center = 1] = "center", oo[oo.left = 2] = "left", oo[oo.right = 3] = "right", oo[oo.top = 4] = "top", oo[oo.bottom = 5] = "bottom", oo[oo["top-left"] = 6] = "top-left", oo[oo["top-right"] = 7] = "top-right", oo[oo["bottom-left"] = 8] = "bottom-left", oo[oo["bottom-right"] = 9] = "bottom-right";
        const Pp = Number.POSITIVE_INFINITY;

        function Vg(i, r) {
          return r[1] !== Pp ? (function(n, a, _) {
            let f = 0,
              m = 0;
            switch (a = Math.abs(a), _ = Math.abs(_), n) {
              case "top-right":
              case "top-left":
              case "top":
                m = _ - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                m = 7 - _
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                f = -a;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                f = a
            }
            return [f, m]
          })(i, r[0], r[1]) : (function(n, a) {
            let _ = 0,
              f = 0;
            a < 0 && (a = 0);
            const m = a / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                f = m - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                f = 7 - m;
                break;
              case "bottom":
                f = 7 - a;
                break;
              case "top":
                f = a - 7
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                _ = -m;
                break;
              case "top-left":
              case "bottom-left":
                _ = m;
                break;
              case "left":
                _ = a;
                break;
              case "right":
                _ = -a
            }
            return [_, f]
          })(i, r[0])
        }

        function Ug(i, r, n) {
          var a;
          const _ = i.layout,
            f = (a = _.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(r, {}, n);
          if (f) {
            const v = f.values,
              b = [];
            for (let S = 0; S < v.length; S += 2) {
              const M = b[S] = v[S],
                j = v[S + 1].map((O => O * Ni));
              M.startsWith("top") ? j[1] -= 7 : M.startsWith("bottom") && (j[1] += 7), b[S + 1] = j
            }
            return new Wn(b)
          }
          const m = _.get("text-variable-anchor");
          if (m) {
            let v;
            v = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [_.get("text-radial-offset").evaluate(r, {}, n) * Ni, Pp] : _.get("text-offset").evaluate(r, {}, n).map((S => S * Ni));
            const b = [];
            for (const S of m) b.push(S, Vg(S, v));
            return new Wn(b)
          }
          return null
        }

        function Mp(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function Yb(i, r, n, a, _, f, m, v, b, S, M, j) {
          let O = f.textMaxSize.evaluate(r, {});
          O === void 0 && (O = m);
          const N = i.layers[0].layout,
            H = N.get("icon-offset").evaluate(r, {}, M),
            J = Gg(n.horizontal),
            rt = m / 24,
            ht = i.tilePixelRatio * rt,
            Ot = i.tilePixelRatio * O / 24,
            bt = i.tilePixelRatio * v,
            Mt = i.tilePixelRatio * N.get("symbol-spacing"),
            te = N.get("text-padding") * i.tilePixelRatio,
            le = (function(hn, Qr, Wr, Dn = 1) {
              const fi = hn.get("icon-padding").evaluate(Qr, {}, Wr),
                Li = fi && fi.values;
              return [Li[0] * Dn, Li[1] * Dn, Li[2] * Dn, Li[3] * Dn]
            })(N, r, M, i.tilePixelRatio),
            Re = N.get("text-max-angle") / 180 * Math.PI,
            br = N.get("text-rotation-alignment") !== "viewport" && N.get("symbol-placement") !== "point",
            ar = N.get("icon-rotation-alignment") === "map" && N.get("symbol-placement") !== "point",
            yr = N.get("symbol-placement"),
            Yr = Mt / 2,
            fr = N.get("icon-text-fit");
          let vr;
          a && fr !== "none" && (i.allowVerticalPlacement && n.vertical && (vr = fg(a, n.vertical, fr, N.get("icon-text-fit-padding"), H, rt)), J && (a = fg(a, J, fr, N.get("icon-text-fit-padding"), H, rt)));
          const ke = M ? j.line.getGranularityForZoomLevel(M.z) : 1,
            an = (hn, Qr) => {
              Qr.x < 0 || Qr.x >= ne || Qr.y < 0 || Qr.y >= ne || (function(Wr, Dn, fi, Li, so, Ho, So, Xi, hi, Vi, Yi, Ki, yo, Wo, Ui, Po, Di, Zi, Gi, zi, ii, ms, hc, gs, Qb) {
                const dc = Wr.addToLineVertexArray(Dn, fi);
                let lu, pc, fc, mc, Xg = 0,
                  Yg = 0,
                  Kg = 0,
                  Jg = 0,
                  Dp = -1,
                  Rp = -1;
                const ia = {};
                let Qg = ds("");
                if (Wr.allowVerticalPlacement && Li.vertical) {
                  const _o = Xi.layout.get("text-rotate").evaluate(ii, {}, gs) + 90;
                  fc = new Wh(hi, Dn, Vi, Yi, Ki, Li.vertical, yo, Wo, Ui, _o), So && (mc = new Wh(hi, Dn, Vi, Yi, Ki, So, Di, Zi, Ui, _o))
                }
                if (so) {
                  const _o = Xi.layout.get("icon-rotate").evaluate(ii, {}),
                    $o = Xi.layout.get("icon-text-fit") !== "none",
                    _u = qg(so, _o, hc, $o),
                    vs = So ? qg(So, _o, hc, $o) : void 0;
                  pc = new Wh(hi, Dn, Vi, Yi, Ki, so, Di, Zi, !1, _o), Xg = 4 * _u.length;
                  const hu = Wr.iconSizeData;
                  let As = null;
                  hu.kind === "source" ? (As = [na * Xi.layout.get("icon-size").evaluate(ii, {})], As[0] > Ea && nr(`${Wr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : hu.kind === "composite" && (As = [na * ms.compositeIconSizes[0].evaluate(ii, {}, gs), na * ms.compositeIconSizes[1].evaluate(ii, {}, gs)], (As[0] > Ea || As[1] > Ea) && nr(`${Wr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Wr.addSymbols(Wr.icon, _u, As, zi, Gi, ii, k.as.none, Dn, dc.lineStartIndex, dc.lineLength, -1, gs), Dp = Wr.icon.placedSymbolArray.length - 1, vs && (Yg = 4 * vs.length, Wr.addSymbols(Wr.icon, vs, As, zi, Gi, ii, k.as.vertical, Dn, dc.lineStartIndex, dc.lineLength, -1, gs), Rp = Wr.icon.placedSymbolArray.length - 1)
                }
                const ty = Object.keys(Li.horizontal);
                for (const _o of ty) {
                  const $o = Li.horizontal[_o];
                  if (!lu) {
                    Qg = ds($o.text);
                    const vs = Xi.layout.get("text-rotate").evaluate(ii, {}, gs);
                    lu = new Wh(hi, Dn, Vi, Yi, Ki, $o, yo, Wo, Ui, vs)
                  }
                  const _u = $o.positionedLines.length === 1;
                  if (Kg += Zg(Wr, Dn, $o, Ho, Xi, Ui, ii, Po, dc, Li.vertical ? k.as.horizontal : k.as.horizontalOnly, _u ? ty : [_o], ia, Dp, ms, gs), _u) break
                }
                Li.vertical && (Jg += Zg(Wr, Dn, Li.vertical, Ho, Xi, Ui, ii, Po, dc, k.as.vertical, ["vertical"], ia, Rp, ms, gs));
                const tx = lu ? lu.boxStartIndex : Wr.collisionBoxArray.length,
                  ex = lu ? lu.boxEndIndex : Wr.collisionBoxArray.length,
                  rx = fc ? fc.boxStartIndex : Wr.collisionBoxArray.length,
                  nx = fc ? fc.boxEndIndex : Wr.collisionBoxArray.length,
                  ix = pc ? pc.boxStartIndex : Wr.collisionBoxArray.length,
                  ox = pc ? pc.boxEndIndex : Wr.collisionBoxArray.length,
                  sx = mc ? mc.boxStartIndex : Wr.collisionBoxArray.length,
                  ax = mc ? mc.boxEndIndex : Wr.collisionBoxArray.length;
                let ys = -1;
                const Xh = (_o, $o) => _o && _o.circleDiameter ? Math.max(_o.circleDiameter, $o) : $o;
                ys = Xh(lu, ys), ys = Xh(fc, ys), ys = Xh(pc, ys), ys = Xh(mc, ys);
                const ey = ys > -1 ? 1 : 0;
                ey && (ys *= Qb / Ni), Wr.glyphOffsetArray.length >= cc.MAX_GLYPHS && nr("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ii.sortKey !== void 0 && Wr.addToSortKeyRanges(Wr.symbolInstances.length, ii.sortKey);
                const ux = Ug(Xi, ii, gs),
                  [cx, lx] = (function(_o, $o) {
                    const _u = _o.length,
                      vs = $o == null ? void 0 : $o.values;
                    if ((vs == null ? void 0 : vs.length) > 0)
                      for (let hu = 0; hu < vs.length; hu += 2) {
                        const As = vs[hu + 1];
                        _o.emplaceBack(k.aI[vs[hu]], As[0], As[1])
                      }
                    return [_u, _o.length]
                  })(Wr.textAnchorOffsets, ux);
                Wr.symbolInstances.emplaceBack(Dn.x, Dn.y, ia.right >= 0 ? ia.right : -1, ia.center >= 0 ? ia.center : -1, ia.left >= 0 ? ia.left : -1, ia.vertical || -1, Dp, Rp, Qg, tx, ex, rx, nx, ix, ox, sx, ax, Vi, Kg, Jg, Xg, Yg, ey, 0, yo, ys, cx, lx)
              })(i, Qr, hn, n, a, _, vr, i.layers[0], i.collisionBoxArray, r.index, r.sourceLayerIndex, i.index, ht, [te, te, te, te], br, b, bt, le, ar, H, r, f, S, M, m)
            };
          if (yr === "line")
            for (const hn of Lg(r.geometry, 0, 0, ne, ne)) {
              const Qr = uu(hn, ke),
                Wr = Hb(Qr, Mt, Re, n.vertical || J, a, 24, Ot, i.overscaling, ne);
              for (const Dn of Wr) J && Kb(i, J.text, Yr, Dn) || an(Qr, Dn)
            } else if (yr === "line-center") {
              for (const hn of r.geometry)
                if (hn.length > 1) {
                  const Qr = uu(hn, ke),
                    Wr = Gb(Qr, Re, n.vertical || J, a, 24, Ot);
                  Wr && an(Qr, Wr)
                }
            } else if (r.type === "Polygon")
            for (const hn of Su(r.geometry, 0)) {
              const Qr = $b(hn, 16);
              an(uu(hn[0], ke, !0), new La(Qr.x, Qr.y, 0))
            } else if (r.type === "LineString")
              for (const hn of r.geometry) {
                const Qr = uu(hn, ke);
                an(Qr, new La(Qr[0].x, Qr[0].y, 0))
              } else if (r.type === "Point")
                for (const hn of r.geometry)
                  for (const Qr of hn) an([Qr], new La(Qr.x, Qr.y, 0))
        }

        function Zg(i, r, n, a, _, f, m, v, b, S, M, j, O, N, H) {
          const J = (function(Ot, bt, Mt, te, le, Re, br, ar) {
              const yr = te.layout.get("text-rotate").evaluate(Re, {}) * Math.PI / 180,
                Yr = [];
              for (const fr of bt.positionedLines)
                for (const vr of fr.positionedGlyphs) {
                  if (!vr.rect) continue;
                  const ke = vr.rect || {};
                  let an = 4,
                    hn = !0,
                    Qr = 1,
                    Wr = 0;
                  const Dn = (le || ar) && vr.vertical,
                    fi = vr.metrics.advance * vr.scale / 2;
                  if (ar && bt.verticalizable && (Wr = fr.lineOffset / 2 - (vr.imageName ? -(Ni - vr.metrics.width * vr.scale) / 2 : (vr.scale - 1) * Ni)), vr.imageName) {
                    const Zi = br[vr.imageName];
                    hn = Zi.sdf, Qr = Zi.pixelRatio, an = 1 / Qr
                  }
                  const Li = le ? [vr.x + fi, vr.y] : [0, 0];
                  let so = le ? [0, 0] : [vr.x + fi + Mt[0], vr.y + Mt[1] - Wr],
                    Ho = [0, 0];
                  Dn && (Ho = so, so = [0, 0]);
                  const So = vr.metrics.isDoubleResolution ? 2 : 1,
                    Xi = (vr.metrics.left - an) * vr.scale - fi + so[0],
                    hi = (-vr.metrics.top - an) * vr.scale + so[1],
                    Vi = Xi + ke.w / So * vr.scale / Qr,
                    Yi = hi + ke.h / So * vr.scale / Qr,
                    Ki = new R(Xi, hi),
                    yo = new R(Vi, hi),
                    Wo = new R(Xi, Yi),
                    Ui = new R(Vi, Yi);
                  if (Dn) {
                    const Zi = new R(-fi, fi - -17),
                      Gi = -Math.PI / 2,
                      zi = 12 - fi,
                      ii = new R(22 - zi, -(vr.imageName ? zi : 0)),
                      ms = new R(...Ho);
                    Ki._rotateAround(Gi, Zi)._add(ii)._add(ms), yo._rotateAround(Gi, Zi)._add(ii)._add(ms), Wo._rotateAround(Gi, Zi)._add(ii)._add(ms), Ui._rotateAround(Gi, Zi)._add(ii)._add(ms)
                  }
                  if (yr) {
                    const Zi = Math.sin(yr),
                      Gi = Math.cos(yr),
                      zi = [Gi, -Zi, Zi, Gi];
                    Ki._matMult(zi), yo._matMult(zi), Wo._matMult(zi), Ui._matMult(zi)
                  }
                  const Po = new R(0, 0),
                    Di = new R(0, 0);
                  Yr.push({
                    tl: Ki,
                    tr: yo,
                    bl: Wo,
                    br: Ui,
                    tex: ke,
                    writingMode: bt.writingMode,
                    glyphOffset: Li,
                    sectionIndex: vr.sectionIndex,
                    isSDF: hn,
                    pixelOffsetTL: Po,
                    pixelOffsetBR: Di,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return Yr
            })(0, n, v, _, f, m, a, i.allowVerticalPlacement),
            rt = i.textSizeData;
          let ht = null;
          rt.kind === "source" ? (ht = [na * _.layout.get("text-size").evaluate(m, {})], ht[0] > Ea && nr(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : rt.kind === "composite" && (ht = [na * N.compositeTextSizes[0].evaluate(m, {}, H), na * N.compositeTextSizes[1].evaluate(m, {}, H)], (ht[0] > Ea || ht[1] > Ea) && nr(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, J, ht, v, f, m, S, r, b.lineStartIndex, b.lineLength, O, H);
          for (const Ot of M) j[Ot] = i.text.placedSymbolArray.length - 1;
          return 4 * J.length
        }

        function Gg(i) {
          for (const r in i) return i[r];
          return null
        }

        function Kb(i, r, n, a) {
          const _ = i.compareText;
          if (r in _) {
            const f = _[r];
            for (let m = f.length - 1; m >= 0; m--)
              if (a.dist(f[m]) < n) return !0
          } else _[r] = [];
          return _[r].push(a), !1
        }
        const Hg = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Cp {
          static from(r) {
            if (!(r instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, a] = new Uint8Array(r, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const _ = a >> 4;
            if (_ !== 1) throw new Error(`Got v${_} data when expected v1.`);
            const f = Hg[15 & a];
            if (!f) throw new Error("Unrecognized array type.");
            const [m] = new Uint16Array(r, 2, 1), [v] = new Uint32Array(r, 4, 1);
            return new Cp(v, m, f, r)
          }
          constructor(r, n = 64, a = Float64Array, _) {
            if (isNaN(r) || r < 0) throw new Error(`Unpexpected numItems value: ${r}.`);
            this.numItems = +r, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = a, this.IndexArrayType = r < 65536 ? Uint16Array : Uint32Array;
            const f = Hg.indexOf(this.ArrayType),
              m = 2 * r * this.ArrayType.BYTES_PER_ELEMENT,
              v = r * this.IndexArrayType.BYTES_PER_ELEMENT,
              b = (8 - v % 8) % 8;
            if (f < 0) throw new Error(`Unexpected typed array class: ${a}.`);
            _ && _ instanceof ArrayBuffer ? (this.data = _, this.ids = new this.IndexArrayType(this.data, 8, r), this.coords = new this.ArrayType(this.data, 8 + v + b, 2 * r), this._pos = 2 * r, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + v + b), this.ids = new this.IndexArrayType(this.data, 8, r), this.coords = new this.ArrayType(this.data, 8 + v + b, 2 * r), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + f]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = r)
          }
          add(r, n) {
            const a = this._pos >> 1;
            return this.ids[a] = a, this.coords[this._pos++] = r, this.coords[this._pos++] = n, a
          }
          finish() {
            const r = this._pos >> 1;
            if (r !== this.numItems) throw new Error(`Added ${r} items when expected ${this.numItems}.`);
            return Ip(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(r, n, a, _) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: f,
              coords: m,
              nodeSize: v
            } = this, b = [0, f.length - 1, 0], S = [];
            for (; b.length;) {
              const M = b.pop() || 0,
                j = b.pop() || 0,
                O = b.pop() || 0;
              if (j - O <= v) {
                for (let rt = O; rt <= j; rt++) {
                  const ht = m[2 * rt],
                    Ot = m[2 * rt + 1];
                  ht >= r && ht <= a && Ot >= n && Ot <= _ && S.push(f[rt])
                }
                continue
              }
              const N = O + j >> 1,
                H = m[2 * N],
                J = m[2 * N + 1];
              H >= r && H <= a && J >= n && J <= _ && S.push(f[N]), (M === 0 ? r <= H : n <= J) && (b.push(O), b.push(N - 1), b.push(1 - M)), (M === 0 ? a >= H : _ >= J) && (b.push(N + 1), b.push(j), b.push(1 - M))
            }
            return S
          }
          within(r, n, a) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: _,
              coords: f,
              nodeSize: m
            } = this, v = [0, _.length - 1, 0], b = [], S = a * a;
            for (; v.length;) {
              const M = v.pop() || 0,
                j = v.pop() || 0,
                O = v.pop() || 0;
              if (j - O <= m) {
                for (let rt = O; rt <= j; rt++) $g(f[2 * rt], f[2 * rt + 1], r, n) <= S && b.push(_[rt]);
                continue
              }
              const N = O + j >> 1,
                H = f[2 * N],
                J = f[2 * N + 1];
              $g(H, J, r, n) <= S && b.push(_[N]), (M === 0 ? r - a <= H : n - a <= J) && (v.push(O), v.push(N - 1), v.push(1 - M)), (M === 0 ? r + a >= H : n + a >= J) && (v.push(N + 1), v.push(j), v.push(1 - M))
            }
            return b
          }
        }

        function Ip(i, r, n, a, _, f) {
          if (_ - a <= n) return;
          const m = a + _ >> 1;
          Wg(i, r, m, a, _, f), Ip(i, r, n, a, m - 1, 1 - f), Ip(i, r, n, m + 1, _, 1 - f)
        }

        function Wg(i, r, n, a, _, f) {
          for (; _ > a;) {
            if (_ - a > 600) {
              const S = _ - a + 1,
                M = n - a + 1,
                j = Math.log(S),
                O = .5 * Math.exp(2 * j / 3),
                N = .5 * Math.sqrt(j * O * (S - O) / S) * (M - S / 2 < 0 ? -1 : 1);
              Wg(i, r, n, Math.max(a, Math.floor(n - M * O / S + N)), Math.min(_, Math.floor(n + (S - M) * O / S + N)), f)
            }
            const m = r[2 * n + f];
            let v = a,
              b = _;
            for (Fl(i, r, a, n), r[2 * _ + f] > m && Fl(i, r, a, _); v < b;) {
              for (Fl(i, r, v, b), v++, b--; r[2 * v + f] < m;) v++;
              for (; r[2 * b + f] > m;) b--
            }
            r[2 * a + f] === m ? Fl(i, r, a, b) : (b++, Fl(i, r, b, _)), b <= n && (a = b + 1), n <= b && (_ = b - 1)
          }
        }

        function Fl(i, r, n, a) {
          zp(i, n, a), zp(r, 2 * n, 2 * a), zp(r, 2 * n + 1, 2 * a + 1)
        }

        function zp(i, r, n) {
          const a = i[r];
          i[r] = i[n], i[n] = a
        }

        function $g(i, r, n, a) {
          const _ = i - n,
            f = r - a;
          return _ * _ + f * f
        }
        var Ap;
        k.cA = void 0, (Ap = k.cA || (k.cA = {})).create = "create", Ap.load = "load", Ap.fullLoad = "fullLoad";
        let $h = null,
          Ol = [];
        const Ep = 1e3 / 60,
          jp = "loadTime",
          Lp = "fullLoadTime",
          Jb = {
            mark(i) {
              performance.mark(i)
            },
            frame(i) {
              const r = i;
              $h != null && Ol.push(r - $h), $h = r
            },
            clearMetrics() {
              $h = null, Ol = [], performance.clearMeasures(jp), performance.clearMeasures(Lp);
              for (const i in k.cA) performance.clearMarks(k.cA[i])
            },
            getPerformanceMetrics() {
              performance.measure(jp, k.cA.create, k.cA.load), performance.measure(Lp, k.cA.create, k.cA.fullLoad);
              const i = performance.getEntriesByName(jp)[0].duration,
                r = performance.getEntriesByName(Lp)[0].duration,
                n = Ol.length,
                a = 1 / (Ol.reduce(((f, m) => f + m), 0) / n / 1e3),
                _ = Ol.filter((f => f > Ep)).reduce(((f, m) => f + (m - Ep) / Ep), 0);
              return {
                loadTime: i,
                fullLoadTime: r,
                fps: a,
                percentDroppedFrames: _ / (n + _) * 100,
                totalFrames: n
              }
            }
          };
        k.$ = er, k.A = St, k.B = Pa, k.C = function([i, r, n]) {
          return r += 90, r *= Math.PI / 180, n *= Math.PI / 180, {
            x: i * Math.cos(r) * Math.sin(n),
            y: i * Math.sin(r) * Math.sin(n),
            z: i * Math.cos(n)
          }
        }, k.D = Xr, k.E = et, k.F = Do, k.G = Kn, k.H = tu, k.I = mp, k.J = or, k.K = class {
          constructor(i, r) {
            this.target = i, this.mapId = r, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Vb((() => this.process())), this.subscription = Pr(this.target, "message", (n => this.receive(n)), !1), this.globalScope = ir(self) ? i : window
          }
          registerMessageHandler(i, r) {
            this.messageHandlers[i] = r
          }
          sendAsync(i, r) {
            return new Promise(((n, a) => {
              const _ = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                f = r ? Pr(r.signal, "abort", (() => {
                  f == null || f.unsubscribe(), delete this.resolveRejects[_];
                  const b = {
                    id: _,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: i.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(b)
                }), Ub) : null;
              this.resolveRejects[_] = {
                resolve: b => {
                  f == null || f.unsubscribe(), n(b)
                },
                reject: b => {
                  f == null || f.unsubscribe(), a(b)
                }
              };
              const m = [],
                v = Object.assign(Object.assign({}, i), {
                  id: _,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: ls(i.data, m)
                });
              this.target.postMessage(v, {
                transfer: m
              })
            }))
          }
          receive(i) {
            const r = i.data,
              n = r.id;
            if (!(r.origin !== "file://" && location.origin !== "file://" && r.origin !== "resource://android" && location.origin !== "resource://android" && r.origin !== location.origin || r.targetMapId && this.mapId !== r.targetMapId)) {
              if (r.type === "<cancel>") {
                delete this.tasks[n];
                const a = this.abortControllers[n];
                return delete this.abortControllers[n], void(a && a.abort())
              }
              if (ir(self) || r.mustQueue) return this.tasks[n] = r, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, r)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(),
              r = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), r && this.processTask(i, r)
          }
          processTask(i, r) {
            return c(this, void 0, void 0, (function*() {
              if (r.type === "<response>") {
                const _ = this.resolveRejects[i];
                return delete this.resolveRejects[i], _ ? void(r.error ? _.reject(eu(r.error)) : _.resolve(eu(r.data))) : void 0
              }
              if (!this.messageHandlers[r.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${r.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = eu(r.data),
                a = new AbortController;
              this.abortControllers[i] = a;
              try {
                const _ = yield this.messageHandlers[r.type](r.sourceMapId, n, a);
                this.completeTask(i, null, _)
              } catch (_) {
                this.completeTask(i, _)
              }
            }))
          }
          completeTask(i, r, n) {
            const a = [];
            delete this.abortControllers[i];
            const _ = {
              id: i,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: r ? ls(r) : null,
              data: ls(n, a)
            };
            this.target.postMessage(_, {
              transfer: a
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, k.L = Q, k.M = function() {
          var i = new St(16);
          return St != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i
        }, k.N = function(i, r, n) {
          var a, _, f, m, v, b, S, M, j, O, N, H, J = n[0],
            rt = n[1],
            ht = n[2];
          return r === i ? (i[12] = r[0] * J + r[4] * rt + r[8] * ht + r[12], i[13] = r[1] * J + r[5] * rt + r[9] * ht + r[13], i[14] = r[2] * J + r[6] * rt + r[10] * ht + r[14], i[15] = r[3] * J + r[7] * rt + r[11] * ht + r[15]) : (_ = r[1], f = r[2], m = r[3], v = r[4], b = r[5], S = r[6], M = r[7], j = r[8], O = r[9], N = r[10], H = r[11], i[0] = a = r[0], i[1] = _, i[2] = f, i[3] = m, i[4] = v, i[5] = b, i[6] = S, i[7] = M, i[8] = j, i[9] = O, i[10] = N, i[11] = H, i[12] = a * J + v * rt + j * ht + r[12], i[13] = _ * J + b * rt + O * ht + r[13], i[14] = f * J + S * rt + N * ht + r[14], i[15] = m * J + M * rt + H * ht + r[15]), i
        }, k.O = function(i, r, n) {
          var a = n[0],
            _ = n[1],
            f = n[2];
          return i[0] = r[0] * a, i[1] = r[1] * a, i[2] = r[2] * a, i[3] = r[3] * a, i[4] = r[4] * _, i[5] = r[5] * _, i[6] = r[6] * _, i[7] = r[7] * _, i[8] = r[8] * f, i[9] = r[9] * f, i[10] = r[10] * f, i[11] = r[11] * f, i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], i
        }, k.P = R, k.Q = function(i, r, n) {
          var a = r[0],
            _ = r[1],
            f = r[2],
            m = r[3],
            v = r[4],
            b = r[5],
            S = r[6],
            M = r[7],
            j = r[8],
            O = r[9],
            N = r[10],
            H = r[11],
            J = r[12],
            rt = r[13],
            ht = r[14],
            Ot = r[15],
            bt = n[0],
            Mt = n[1],
            te = n[2],
            le = n[3];
          return i[0] = bt * a + Mt * v + te * j + le * J, i[1] = bt * _ + Mt * b + te * O + le * rt, i[2] = bt * f + Mt * S + te * N + le * ht, i[3] = bt * m + Mt * M + te * H + le * Ot, i[4] = (bt = n[4]) * a + (Mt = n[5]) * v + (te = n[6]) * j + (le = n[7]) * J, i[5] = bt * _ + Mt * b + te * O + le * rt, i[6] = bt * f + Mt * S + te * N + le * ht, i[7] = bt * m + Mt * M + te * H + le * Ot, i[8] = (bt = n[8]) * a + (Mt = n[9]) * v + (te = n[10]) * j + (le = n[11]) * J, i[9] = bt * _ + Mt * b + te * O + le * rt, i[10] = bt * f + Mt * S + te * N + le * ht, i[11] = bt * m + Mt * M + te * H + le * Ot, i[12] = (bt = n[12]) * a + (Mt = n[13]) * v + (te = n[14]) * j + (le = n[15]) * J, i[13] = bt * _ + Mt * b + te * O + le * rt, i[14] = bt * f + Mt * S + te * N + le * ht, i[15] = bt * m + Mt * M + te * H + le * Ot, i
        }, k.R = To, k.S = function(i, r) {
          const n = {};
          for (let a = 0; a < r.length; a++) {
            const _ = r[a];
            _ in i && (n[_] = i[_])
          }
          return n
        }, k.T = sp, k.U = ja, k.V = mr, k.W = Tg, k.X = kg, k.Y = yt, k.Z = Lt, k._ = c, k.a = q, k.a$ = function(i, r, n) {
          return i[0] = r[0] * n[0], i[1] = r[1] * n[1], i[2] = r[2] * n[2], i[3] = r[3] * n[3], i
        }, k.a0 = Go, k.a1 = Pg, k.a2 = Uh, k.a3 = ne, k.a4 = function(i, r) {
          var n, a, _, f, m;
          if (!i) return r ?? {};
          if (!r) return i;
          let v = Object.assign({}, i);
          if (r.removeAll && (v = {
              removeAll: !0
            }), r.remove) {
            const b = new Set(r.remove);
            v.add && (v.add = v.add.filter((M => !b.has(M.id)))), v.update && (v.update = v.update.filter((M => !b.has(M.id))));
            const S = new Set(((n = i.add) !== null && n !== void 0 ? n : []).map((M => M.id)));
            r.remove = r.remove.filter((M => !S.has(M)))
          }
          if (r.remove) {
            const b = new Set(v.remove ? v.remove.concat(r.remove) : r.remove);
            v.remove = Array.from(b.values())
          }
          if (r.add) {
            const b = v.add ? v.add.concat(r.add) : r.add,
              S = new Map(b.map((M => [M.id, M])));
            v.add = Array.from(S.values())
          }
          if (r.update) {
            const b = new Map((a = v.update) === null || a === void 0 ? void 0 : a.map((S => [S.id, S])));
            for (const S of r.update) {
              const M = (_ = b.get(S.id)) !== null && _ !== void 0 ? _ : {
                id: S.id
              };
              S.newGeometry && (M.newGeometry = S.newGeometry), S.addOrUpdateProperties && (M.addOrUpdateProperties = ((f = M.addOrUpdateProperties) !== null && f !== void 0 ? f : []).concat(S.addOrUpdateProperties)), S.removeProperties && (M.removeProperties = ((m = M.removeProperties) !== null && m !== void 0 ? m : []).concat(S.removeProperties)), S.removeAllProperties && (M.removeAllProperties = !0), b.set(S.id, M)
            }
            v.update = Array.from(b.values())
          }
          return v.remove && v.add && (v.remove = v.remove.filter((b => v.add.findIndex((S => S.id === b)) === -1))), v
        }, k.a5 = Rl, k.a6 = cu, k.a7 = 25, k.a8 = Sp, k.a9 = i => {
          const r = window.document.createElement("video");
          return r.muted = !0, new Promise((n => {
            r.onloadstart = () => {
              n(r)
            };
            for (const a of i) {
              const _ = window.document.createElement("source");
              Ft(a) || (r.crossOrigin = "Anonymous"), _.src = a, r.appendChild(_)
            }
          }))
        }, k.aA = Xt, k.aB = function(i, r, n, a) {
          const _ = r.y - i.y,
            f = r.x - i.x,
            m = a.y - n.y,
            v = a.x - n.x,
            b = m * f - v * _;
          if (b === 0) return null;
          const S = (v * (i.y - n.y) - m * (i.x - n.x)) / b;
          return new R(i.x + S * f, i.y + S * _)
        }, k.aC = Lg, k.aD = km, k.aE = function(i) {
          let r = 1 / 0,
            n = 1 / 0,
            a = -1 / 0,
            _ = -1 / 0;
          for (const f of i) r = Math.min(r, f.x), n = Math.min(n, f.y), a = Math.max(a, f.x), _ = Math.max(_, f.y);
          return [r, n, a, _]
        }, k.aF = Ni, k.aG = Xe, k.aH = function(i, r, n, a, _ = !1) {
          if (!n[0] && !n[1]) return [0, 0];
          const f = _ ? a === "map" ? -i.bearingInRadians : 0 : a === "viewport" ? i.bearingInRadians : 0;
          if (f) {
            const m = Math.sin(f),
              v = Math.cos(f);
            n = [n[0] * v - n[1] * m, n[0] * m + n[1] * v]
          }
          return [_ ? n[0] : Xe(r, n[0], i.zoom), _ ? n[1] : Xe(r, n[1], i.zoom)]
        }, k.aJ = vp, k.aK = Mp, k.aL = yp, k.aM = Cp, k.aN = bi, k.aO = Bh, k.aP = pt, k.aQ = Tn, k.aR = Pe, k.aS = jr, k.aT = Mg, k.aU = jt, k.aV = Wt, k.aW = function(i) {
          var r = new St(3);
          return r[0] = i[0], r[1] = i[1], r[2] = i[2], r
        }, k.aX = function(i, r, n) {
          return i[0] = r[0] - n[0], i[1] = r[1] - n[1], i[2] = r[2] - n[2], i
        }, k.aY = function(i, r) {
          var n = r[0],
            a = r[1],
            _ = r[2],
            f = n * n + a * a + _ * _;
          return f > 0 && (f = 1 / Math.sqrt(f)), i[0] = r[0] * f, i[1] = r[1] * f, i[2] = r[2] * f, i
        }, k.aZ = Ht, k.a_ = function(i, r) {
          return i[0] * r[0] + i[1] * r[1] + i[2] * r[2]
        }, k.aa = Yt, k.ab = function() {
          return ce++
        }, k.ac = x, k.ad = cc, k.ae = Ya, k.af = zs, k.ag = Ag, k.ah = function(i) {
          const r = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, a, _, f) => {
              const m = _ || f;
              return r[a] = !m || m.toLowerCase(), ""
            })), r["max-age"]) {
            const n = parseInt(r["max-age"], 10);
            isNaN(n) ? delete r["max-age"] : r["max-age"] = n
          }
          return r
        }, k.ai = Ye, k.aj = 85.051129, k.ak = Or, k.al = function(i) {
          return Math.pow(2, i)
        }, k.am = Vt, k.an = Sg, k.ao = function(i) {
          return Math.log(i) / Math.LN2
        }, k.ap = function(i) {
          var r = i[0],
            n = i[1];
          return r * r + n * n
        }, k.aq = function(i) {
          if (!i.length) return new Set;
          const r = Math.max(...i.map((b => b.canonical.z)));
          let n = 1 / 0,
            a = -1 / 0,
            _ = 1 / 0,
            f = -1 / 0;
          const m = [];
          for (const b of i) {
            const {
              x: S,
              y: M,
              z: j
            } = b.canonical, O = Math.pow(2, r - j), N = S * O, H = M * O;
            m.push({
              id: b,
              x: N,
              y: H
            }), N < n && (n = N), N > a && (a = N), H < _ && (_ = H), H > f && (f = H)
          }
          const v = new Set;
          for (const b of m) b.x !== n && b.x !== a && b.y !== _ && b.y !== f || v.add(b.id);
          return v
        }, k.ar = function(i, r) {
          let n = 0,
            a = 0;
          if (i.kind === "constant") a = i.layoutSize;
          else if (i.kind !== "source") {
            const {
              interpolationType: _,
              minZoom: f,
              maxZoom: m
            } = i, v = _ ? Ye(Un.interpolationFactor(_, r, f, m), 0, 1) : 0;
            i.kind === "camera" ? a = Do.number(i.minSize, i.maxSize, v) : n = v
          }
          return {
            uSizeT: n,
            uSize: a
          }
        }, k.at = function(i, {
          uSize: r,
          uSizeT: n
        }, {
          lowerSize: a,
          upperSize: _
        }) {
          return i.kind === "source" ? a / na : i.kind === "composite" ? Do.number(a / na, _ / na, n) : r
        }, k.au = function(i, r) {
          var n = r[0],
            a = r[1],
            _ = r[2],
            f = r[3],
            m = r[4],
            v = r[5],
            b = r[6],
            S = r[7],
            M = r[8],
            j = r[9],
            O = r[10],
            N = r[11],
            H = r[12],
            J = r[13],
            rt = r[14],
            ht = r[15],
            Ot = n * v - a * m,
            bt = n * b - _ * m,
            Mt = n * S - f * m,
            te = a * b - _ * v,
            le = a * S - f * v,
            Re = _ * S - f * b,
            br = M * J - j * H,
            ar = M * rt - O * H,
            yr = M * ht - N * H,
            Yr = j * rt - O * J,
            fr = j * ht - N * J,
            vr = O * ht - N * rt,
            ke = Ot * vr - bt * fr + Mt * Yr + te * yr - le * ar + Re * br;
          return ke ? (i[0] = (v * vr - b * fr + S * Yr) * (ke = 1 / ke), i[1] = (_ * fr - a * vr - f * Yr) * ke, i[2] = (J * Re - rt * le + ht * te) * ke, i[3] = (O * le - j * Re - N * te) * ke, i[4] = (b * yr - m * vr - S * ar) * ke, i[5] = (n * vr - _ * yr + f * ar) * ke, i[6] = (rt * Mt - H * Re - ht * bt) * ke, i[7] = (M * Re - O * Mt + N * bt) * ke, i[8] = (m * fr - v * yr + S * br) * ke, i[9] = (a * yr - n * fr - f * br) * ke, i[10] = (H * le - J * Mt + ht * Ot) * ke, i[11] = (j * Mt - M * le - N * Ot) * ke, i[12] = (v * ar - m * Yr - b * br) * ke, i[13] = (n * Yr - a * ar + _ * br) * ke, i[14] = (J * bt - H * te - rt * Ot) * ke, i[15] = (M * te - j * bt + O * Ot) * ke, i) : null
        }, k.av = Ve, k.aw = function(i) {
          var r = i[0],
            n = i[1];
          return Math.sqrt(r * r + n * n)
        }, k.ax = function(i) {
          return i[0] = 0, i[1] = 0, i
        }, k.ay = function(i, r, n) {
          return i[0] = r[0] * n, i[1] = r[1] * n, i
        }, k.az = bp, k.b = de, k.b$ = function(i, r, n) {
          var a = r[0],
            _ = r[1],
            f = r[2];
          return i[0] = a * n[0] + _ * n[3] + f * n[6], i[1] = a * n[1] + _ * n[4] + f * n[7], i[2] = a * n[2] + _ * n[5] + f * n[8], i
        }, k.b0 = Et, k.b1 = function(i, r, n) {
          const a = r[0] * n[0] + r[1] * n[1] + r[2] * n[2];
          return a === 0 ? null : (-(i[0] * n[0] + i[1] * n[1] + i[2] * n[2]) - n[3]) / a
        }, k.b2 = Ut, k.b3 = function(i, r, n) {
          return i[0] = r[0] * n, i[1] = r[1] * n, i[2] = r[2] * n, i[3] = r[3] * n, i
        }, k.b4 = function(i, r) {
          return i[0] * r[0] + i[1] * r[1] + i[2] * r[2] + i[3]
        }, k.b5 = Ig, k.b6 = lc, k.b7 = function(i, r, n, a, _) {
          var f = 1 / Math.tan(r / 2);
          if (i[0] = f / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = f, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, _ != null && _ !== 1 / 0) {
            var m = 1 / (a - _);
            i[10] = (_ + a) * m, i[14] = 2 * _ * a * m
          } else i[10] = -1, i[14] = -2 * a;
          return i
        }, k.b8 = function(i) {
          var r = new St(16);
          return r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], r[4] = i[4], r[5] = i[5], r[6] = i[6], r[7] = i[7], r[8] = i[8], r[9] = i[9], r[10] = i[10], r[11] = i[11], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15], r
        }, k.b9 = function(i, r, n) {
          var a = Math.sin(n),
            _ = Math.cos(n),
            f = r[0],
            m = r[1],
            v = r[2],
            b = r[3],
            S = r[4],
            M = r[5],
            j = r[6],
            O = r[7];
          return r !== i && (i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15]), i[0] = f * _ + S * a, i[1] = m * _ + M * a, i[2] = v * _ + j * a, i[3] = b * _ + O * a, i[4] = S * _ - f * a, i[5] = M * _ - m * a, i[6] = j * _ - v * a, i[7] = O * _ - b * a, i
        }, k.bA = function(i, r, n, a) {
          var _ = [],
            f = [];
          return _[0] = r[0] - n[0], _[1] = r[1] - n[1], _[2] = r[2] - n[2], f[0] = _[0], f[1] = _[1] * Math.cos(a) - _[2] * Math.sin(a), f[2] = _[1] * Math.sin(a) + _[2] * Math.cos(a), i[0] = f[0] + n[0], i[1] = f[1] + n[1], i[2] = f[2] + n[2], i
        }, k.bB = function(i, r, n, a) {
          var _ = [],
            f = [];
          return _[0] = r[0] - n[0], _[1] = r[1] - n[1], _[2] = r[2] - n[2], f[0] = _[2] * Math.sin(a) + _[0] * Math.cos(a), f[1] = _[1], f[2] = _[2] * Math.cos(a) - _[0] * Math.sin(a), i[0] = f[0] + n[0], i[1] = f[1] + n[1], i[2] = f[2] + n[2], i
        }, k.bC = function(i, r, n) {
          var a = Math.sin(n),
            _ = Math.cos(n),
            f = r[0],
            m = r[1],
            v = r[2],
            b = r[3],
            S = r[8],
            M = r[9],
            j = r[10],
            O = r[11];
          return r !== i && (i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15]), i[0] = f * _ - S * a, i[1] = m * _ - M * a, i[2] = v * _ - j * a, i[3] = b * _ - O * a, i[8] = f * a + S * _, i[9] = m * a + M * _, i[10] = v * a + j * _, i[11] = b * a + O * _, i
        }, k.bD = function(i, r) {
          const n = pe(i, 360),
            a = pe(r, 360),
            _ = a - n,
            f = a > n ? _ - 360 : _ + 360;
          return Math.abs(_) < Math.abs(f) ? _ : f
        }, k.bE = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i
        }, k.bF = function(i, r, n, a) {
          const _ = Math.sqrt(i * i + r * r),
            f = Math.sqrt(n * n + a * a);
          i /= _, r /= _, n /= f, a /= f;
          const m = Math.acos(i * n + r * a);
          return -r * n + i * a > 0 ? m : -m
        }, k.bG = function(i, r) {
          const n = pe(i, 2 * Math.PI),
            a = pe(r, 2 * Math.PI);
          return Math.min(Math.abs(n - a), Math.abs(n - a + 2 * Math.PI), Math.abs(n - a - 2 * Math.PI))
        }, k.bH = function() {
          const i = {},
            r = W.$version;
          for (const n in W.$root) {
            const a = W.$root[n];
            if (a.required) {
              let _ = null;
              _ = n === "version" ? r : a.type === "array" ? [] : {}, _ != null && (i[n] = _)
            }
          }
          return i
        }, k.bI = ll, k.bJ = _t, k.bK = function i(r, n) {
          if (Array.isArray(r)) {
            if (!Array.isArray(n) || r.length !== n.length) return !1;
            for (let a = 0; a < r.length; a++)
              if (!i(r[a], n[a])) return !1;
            return !0
          }
          if (typeof r == "object" && r !== null && n !== null) {
            if (typeof n != "object" || Object.keys(r).length !== Object.keys(n).length) return !1;
            for (const a in r)
              if (!i(r[a], n[a])) return !1;
            return !0
          }
          return r === n
        }, k.bL = function(i) {
          i = i.slice();
          const r = Object.create(null);
          for (let n = 0; n < i.length; n++) r[i[n].id] = i[n];
          for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = $t(i[n], r[i[n].ref]));
          return i
        }, k.bM = function(i, r) {
          if (i.type === "custom") return new Nb(i, r);
          switch (i.type) {
            case "background":
              return new qb(i, r);
            case "circle":
              return new S0(i, r);
            case "color-relief":
              return new A0(i, r);
            case "fill":
              return new H0(i, r);
            case "fill-extrusion":
              return new nb(i, r);
            case "heatmap":
              return new M0(i, r);
            case "hillshade":
              return new I0(i, r);
            case "line":
              return new lb(i, r);
            case "raster":
              return new Kd(i, r);
            case "symbol":
              return new Vh(i, r)
          }
        }, k.bN = i => i.type === "raster", k.bO = ve, k.bP = function(i, r) {
          if (!i) return [{
            command: "setStyle",
            args: [r]
          }];
          let n = [];
          try {
            if (!Pt(i.version, r.version)) return [{
              command: "setStyle",
              args: [r]
            }];
            Pt(i.center, r.center) || n.push({
              command: "setCenter",
              args: [r.center]
            }), Pt(i.state, r.state) || n.push({
              command: "setGlobalState",
              args: [r.state]
            }), Pt(i.centerAltitude, r.centerAltitude) || n.push({
              command: "setCenterAltitude",
              args: [r.centerAltitude]
            }), Pt(i.zoom, r.zoom) || n.push({
              command: "setZoom",
              args: [r.zoom]
            }), Pt(i.bearing, r.bearing) || n.push({
              command: "setBearing",
              args: [r.bearing]
            }), Pt(i.pitch, r.pitch) || n.push({
              command: "setPitch",
              args: [r.pitch]
            }), Pt(i.roll, r.roll) || n.push({
              command: "setRoll",
              args: [r.roll]
            }), Pt(i.sprite, r.sprite) || n.push({
              command: "setSprite",
              args: [r.sprite]
            }), Pt(i.glyphs, r.glyphs) || n.push({
              command: "setGlyphs",
              args: [r.glyphs]
            }), Pt(i.transition, r.transition) || n.push({
              command: "setTransition",
              args: [r.transition]
            }), Pt(i.light, r.light) || n.push({
              command: "setLight",
              args: [r.light]
            }), Pt(i.terrain, r.terrain) || n.push({
              command: "setTerrain",
              args: [r.terrain]
            }), Pt(i.sky, r.sky) || n.push({
              command: "setSky",
              args: [r.sky]
            }), Pt(i.projection, r.projection) || n.push({
              command: "setProjection",
              args: [r.projection]
            });
            const a = {},
              _ = [];
            (function(m, v, b, S) {
              let M;
              for (M in v = v || {}, m = m || {}) Object.prototype.hasOwnProperty.call(m, M) && (Object.prototype.hasOwnProperty.call(v, M) || ye(M, b, S));
              for (M in v) Object.prototype.hasOwnProperty.call(v, M) && (Object.prototype.hasOwnProperty.call(m, M) ? Pt(m[M], v[M]) || (m[M].type === "geojson" && v[M].type === "geojson" && we(m, v, M) ? Gt(b, {
                command: "setGeoJSONSourceData",
                args: [M, v[M].data]
              }) : Te(M, v, b, S)) : ae(M, v, b))
            })(i.sources, r.sources, _, a);
            const f = [];
            i.layers && i.layers.forEach((m => {
              "source" in m && a[m.source] ? n.push({
                command: "removeLayer",
                args: [m.id]
              }) : f.push(m)
            })), n = n.concat(_), (function(m, v, b) {
              v = v || [];
              const S = (m = m || []).map(Ee),
                M = v.map(Ee),
                j = m.reduce(Qe, {}),
                O = v.reduce(Qe, {}),
                N = S.slice(),
                H = Object.create(null);
              let J, rt, ht, Ot, bt;
              for (let Mt = 0, te = 0; Mt < S.length; Mt++) J = S[Mt], Object.prototype.hasOwnProperty.call(O, J) ? te++ : (Gt(b, {
                command: "removeLayer",
                args: [J]
              }), N.splice(N.indexOf(J, te), 1));
              for (let Mt = 0, te = 0; Mt < M.length; Mt++) J = M[M.length - 1 - Mt], N[N.length - 1 - Mt] !== J && (Object.prototype.hasOwnProperty.call(j, J) ? (Gt(b, {
                command: "removeLayer",
                args: [J]
              }), N.splice(N.lastIndexOf(J, N.length - te), 1)) : te++, Ot = N[N.length - Mt], Gt(b, {
                command: "addLayer",
                args: [O[J], Ot]
              }), N.splice(N.length - Mt, 0, J), H[J] = !0);
              for (let Mt = 0; Mt < M.length; Mt++)
                if (J = M[Mt], rt = j[J], ht = O[J], !H[J] && !Pt(rt, ht))
                  if (Pt(rt.source, ht.source) && Pt(rt["source-layer"], ht["source-layer"]) && Pt(rt.type, ht.type)) {
                    for (bt in be(rt.layout, ht.layout, b, J, null, "setLayoutProperty"), be(rt.paint, ht.paint, b, J, null, "setPaintProperty"), Pt(rt.filter, ht.filter) || Gt(b, {
                        command: "setFilter",
                        args: [J, ht.filter]
                      }), Pt(rt.minzoom, ht.minzoom) && Pt(rt.maxzoom, ht.maxzoom) || Gt(b, {
                        command: "setLayerZoomRange",
                        args: [J, ht.minzoom, ht.maxzoom]
                      }), rt) Object.prototype.hasOwnProperty.call(rt, bt) && bt !== "layout" && bt !== "paint" && bt !== "filter" && bt !== "metadata" && bt !== "minzoom" && bt !== "maxzoom" && (bt.indexOf("paint.") === 0 ? be(rt[bt], ht[bt], b, J, bt.slice(6), "setPaintProperty") : Pt(rt[bt], ht[bt]) || Gt(b, {
                      command: "setLayerProperty",
                      args: [J, bt, ht[bt]]
                    }));
                    for (bt in ht) Object.prototype.hasOwnProperty.call(ht, bt) && !Object.prototype.hasOwnProperty.call(rt, bt) && bt !== "layout" && bt !== "paint" && bt !== "filter" && bt !== "metadata" && bt !== "minzoom" && bt !== "maxzoom" && (bt.indexOf("paint.") === 0 ? be(rt[bt], ht[bt], b, J, bt.slice(6), "setPaintProperty") : Pt(rt[bt], ht[bt]) || Gt(b, {
                      command: "setLayerProperty",
                      args: [J, bt, ht[bt]]
                    }))
                  } else Gt(b, {
                    command: "removeLayer",
                    args: [J]
                  }), Ot = N[N.lastIndexOf(J) + 1], Gt(b, {
                    command: "addLayer",
                    args: [ht, Ot]
                  })
            })(f, r.layers, n)
          } catch (a) {
            console.warn("Unable to compute style diff:", a), n = [{
              command: "setStyle",
              args: [r]
            }]
          }
          return n
        }, k.bQ = function(i) {
          const r = [],
            n = i.id;
          return n === void 0 && r.push({
            message: `layers.${n}: missing required property "id"`
          }), i.render === void 0 && r.push({
            message: `layers.${n}: missing required method "render"`
          }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && r.push({
            message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"`
          }), r
        }, k.bR = ur, k.bS = Ke, k.bT = class extends go {
          constructor(i, r) {
            super(i, r), this.current = 0
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i))
          }
        }, k.bU = Cs, k.bV = class extends go {
          constructor(i, r) {
            super(i, r), this.current = su
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let r = 1; r < 16; r++)
              if (i[r] !== this.current[r]) {
                this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
                break
              }
          }
        }, k.bW = ps, k.bX = class extends go {
          constructor(i, r) {
            super(i, r), this.current = [0, 0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]))
          }
        }, k.bY = class extends go {
          constructor(i, r) {
            super(i, r), this.current = [0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]))
          }
        }, k.bZ = qt, k.b_ = function(i, r) {
          var n = Math.sin(r),
            a = Math.cos(r);
          return i[0] = a, i[1] = n, i[2] = 0, i[3] = -n, i[4] = a, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i
        }, k.ba = function(i, r, n) {
          var a = Math.sin(n),
            _ = Math.cos(n),
            f = r[4],
            m = r[5],
            v = r[6],
            b = r[7],
            S = r[8],
            M = r[9],
            j = r[10],
            O = r[11];
          return r !== i && (i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15]), i[4] = f * _ + S * a, i[5] = m * _ + M * a, i[6] = v * _ + j * a, i[7] = b * _ + O * a, i[8] = S * _ - f * a, i[9] = M * _ - m * a, i[10] = j * _ - v * a, i[11] = O * _ - b * a, i
        }, k.bb = function() {
          const i = new Float32Array(16);
          return Vt(i), i
        }, k.bc = function() {
          const i = new Float64Array(16);
          return Vt(i), i
        }, k.bd = function() {
          return new Float64Array(16)
        }, k.be = function(i, r, n) {
          const a = new Float64Array(4);
          return Ce(a, i, r - 90, n), a
        }, k.bf = function(i, r, n, a) {
          var _, f, m, v, b, S = r[0],
            M = r[1],
            j = r[2],
            O = r[3],
            N = n[0],
            H = n[1],
            J = n[2],
            rt = n[3];
          return (f = S * N + M * H + j * J + O * rt) < 0 && (f = -f, N = -N, H = -H, J = -J, rt = -rt), 1 - f > Dt ? (_ = Math.acos(f), m = Math.sin(_), v = Math.sin((1 - a) * _) / m, b = Math.sin(a * _) / m) : (v = 1 - a, b = a), i[0] = v * S + b * N, i[1] = v * M + b * H, i[2] = v * j + b * J, i[3] = v * O + b * rt, i
        }, k.bg = function(i) {
          const r = new Float64Array(9);
          var n, a, _, f, m, v, b, S, M, j, O, N, H, J, rt, ht, Ot, bt;
          j = (_ = (a = i)[0]) * (b = _ + _), O = (f = a[1]) * b, H = (m = a[2]) * b, J = m * (S = f + f), ht = (v = a[3]) * b, Ot = v * S, bt = v * (M = m + m), (n = r)[0] = 1 - (N = f * S) - (rt = m * M), n[3] = O - bt, n[6] = H + Ot, n[1] = O + bt, n[4] = 1 - j - rt, n[7] = J - ht, n[2] = H - Ot, n[5] = J + ht, n[8] = 1 - j - N;
          const Mt = jr(-Math.asin(Ye(r[2], -1, 1)));
          let te, le;
          return Math.hypot(r[5], r[8]) < .001 ? (te = 0, le = -jr(Math.atan2(r[3], r[4]))) : (te = jr(r[5] === 0 && r[8] === 0 ? 0 : Math.atan2(r[5], r[8])), le = jr(r[1] === 0 && r[0] === 0 ? 0 : Math.atan2(r[1], r[0]))), {
            roll: te,
            pitch: Mt + 90,
            bearing: le
          }
        }, k.bh = function(i, r) {
          return i.roll == r.roll && i.pitch == r.pitch && i.bearing == r.bearing
        }, k.bi = Ur, k.bj = lo, k.bk = oc, k.bl = zl, k.bm = ic, k.bn = Ue, k.bo = Ae, k.bp = yi, k.bq = function(i, r, n, a, _) {
          return Ue(a, _, Ye((i - r) / (n - r), 0, 1))
        }, k.br = pe, k.bs = function() {
          return new Float64Array(3)
        }, k.bt = function(i, r, n, a) {
          return i[0] = r[0] + n[0] * a, i[1] = r[1] + n[1] * a, i[2] = r[2] + n[2] * a, i
        }, k.bu = Ce, k.bv = function(i, r, n) {
          var a = n[0],
            _ = n[1],
            f = n[2],
            m = n[3],
            v = r[0],
            b = r[1],
            S = r[2],
            M = _ * S - f * b,
            j = f * v - a * S,
            O = a * b - _ * v;
          return i[0] = v + m * (M += M) + _ * (O += O) - f * (j += j), i[1] = b + m * j + f * M - a * O, i[2] = S + m * O + a * j - _ * M, i
        }, k.bw = function(i, r, n) {
          const a = (_ = [i[0], i[1], i[2], r[0], r[1], r[2], n[0], n[1], n[2]])[0] * ((M = _[8]) * (m = _[4]) - (v = _[5]) * (S = _[7])) + _[1] * (-M * (f = _[3]) + v * (b = _[6])) + _[2] * (S * f - m * b);
          var _, f, m, v, b, S, M;
          if (a === 0) return null;
          const j = Ht([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]),
            O = Ht([], [n[0], n[1], n[2]], [i[0], i[1], i[2]]),
            N = Ht([], [i[0], i[1], i[2]], [r[0], r[1], r[2]]),
            H = jt([], j, -i[3]);
          return Wt(H, H, jt([], O, -r[3])), Wt(H, H, jt([], N, -n[3])), jt(H, H, 1 / a), H
        }, k.bx = Tp, k.by = function() {
          return new Float64Array(4)
        }, k.bz = function(i, r, n, a) {
          var _ = [],
            f = [];
          return _[0] = r[0] - n[0], _[1] = r[1] - n[1], _[2] = r[2] - n[2], f[0] = _[0] * Math.cos(a) - _[1] * Math.sin(a), f[1] = _[0] * Math.sin(a) + _[1] * Math.cos(a), f[2] = _[2], i[0] = f[0] + n[0], i[1] = f[1] + n[1], i[2] = f[2] + n[2], i
        }, k.c = ct, k.c0 = function(i, r, n, a, _, f, m) {
          var v = 1 / (r - n),
            b = 1 / (a - _),
            S = 1 / (f - m);
          return i[0] = -2 * v, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * b, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * S, i[11] = 0, i[12] = (r + n) * v, i[13] = (_ + a) * b, i[14] = (m + f) * S, i[15] = 1, i
        }, k.c1 = class extends go {
          constructor(i, r) {
            super(i, r), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const r = new Float32Array(4 * i.length);
              for (let n = 0; n < i.length; n++) r[4 * n] = i[n].r, r[4 * n + 1] = i[n].g, r[4 * n + 2] = i[n].b, r[4 * n + 3] = i[n].a;
              this.gl.uniform4fv(this.location, r)
            }
          }
        }, k.c2 = class extends go {
          constructor(i, r) {
            super(i, r), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const r = new Float32Array(i);
              this.gl.uniform1fv(this.location, r)
            }
          }
        }, k.c3 = class extends Ks {}, k.c4 = pb, k.c5 = class extends Ku {}, k.c6 = op, k.c7 = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
        }, k.c8 = jm, k.c9 = function(i, r, n) {
          var a = r[0],
            _ = r[1],
            f = r[2],
            m = n[3] * a + n[7] * _ + n[11] * f + n[15];
          return i[0] = (n[0] * a + n[4] * _ + n[8] * f + n[12]) / (m = m || 1), i[1] = (n[1] * a + n[5] * _ + n[9] * f + n[13]) / m, i[2] = (n[2] * a + n[6] * _ + n[10] * f + n[14]) / m, i
        }, k.cB = function(i) {
          return i.message === dr
        }, k.cC = nt, k.cD = function(i, r) {
          q.REGISTERED_PROTOCOLS[i] = r
        }, k.cE = function(i) {
          delete q.REGISTERED_PROTOCOLS[i]
        }, k.cF = function(i, r) {
          const n = {};
          for (let _ = 0; _ < i.length; _++) {
            const f = r && r[i[_].id] || nh(i[_]);
            r && (r[i[_].id] = f);
            let m = n[f];
            m || (m = n[f] = []), m.push(i[_])
          }
          const a = [];
          for (const _ in n) a.push(n[_]);
          return a
        }, k.cG = Sr, k.cH = zg, k.cI = Eg, k.cJ = ug, k.cK = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = ne / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const r = i.bucket.layers[0],
            n = r.layout,
            a = r._unevaluatedLayout._values,
            _ = {
              layoutIconSize: a["icon-size"].possiblyEvaluate(new Kn(i.bucket.zoom + 1), i.canonical),
              layoutTextSize: a["text-size"].possiblyEvaluate(new Kn(i.bucket.zoom + 1), i.canonical),
              textMaxSize: a["text-size"].possiblyEvaluate(new Kn(18))
            };
          if (i.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: M
            } = i.bucket.textSizeData;
            _.compositeTextSizes = [a["text-size"].possiblyEvaluate(new Kn(S), i.canonical), a["text-size"].possiblyEvaluate(new Kn(M), i.canonical)]
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: M
            } = i.bucket.iconSizeData;
            _.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new Kn(S), i.canonical), a["icon-size"].possiblyEvaluate(new Kn(M), i.canonical)]
          }
          const f = n.get("text-line-height") * Ni,
            m = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point",
            v = n.get("text-keep-upright"),
            b = n.get("text-size");
          for (const S of i.bucket.features) {
            const M = n.get("text-font").evaluate(S, {}, i.canonical).join(","),
              j = b.evaluate(S, {}, i.canonical),
              O = _.layoutTextSize.evaluate(S, {}, i.canonical),
              N = _.layoutIconSize.evaluate(S, {}, i.canonical),
              H = {
                horizontal: {},
                vertical: void 0
              },
              J = S.text;
            let rt, ht = [0, 0];
            if (J) {
              const Mt = J.toString(),
                te = n.get("text-letter-spacing").evaluate(S, {}, i.canonical) * Ni,
                le = hl(Mt) ? te : 0,
                Re = n.get("text-anchor").evaluate(S, {}, i.canonical),
                br = Ug(r, S, i.canonical);
              if (!br) {
                const fr = n.get("text-radial-offset").evaluate(S, {}, i.canonical);
                ht = fr ? Vg(Re, [fr * Ni, Pp]) : n.get("text-offset").evaluate(S, {}, i.canonical).map((vr => vr * Ni))
              }
              let ar = m ? "center" : n.get("text-justify").evaluate(S, {}, i.canonical);
              const yr = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(S, {}, i.canonical) * Ni : 1 / 0,
                Yr = () => {
                  i.bucket.allowVerticalPlacement && _l(Mt) && (H.vertical = Oh(J, i.glyphMap, i.glyphPositions, i.imagePositions, M, yr, f, Re, "left", le, ht, k.as.vertical, !0, O, j))
                };
              if (!m && br) {
                const fr = new Set;
                if (ar === "auto")
                  for (let ke = 0; ke < br.values.length; ke += 2) fr.add(Mp(br.values[ke]));
                else fr.add(ar);
                let vr = !1;
                for (const ke of fr)
                  if (!H.horizontal[ke])
                    if (vr) H.horizontal[ke] = H.horizontal[0];
                    else {
                      const an = Oh(J, i.glyphMap, i.glyphPositions, i.imagePositions, M, yr, f, "center", ke, le, ht, k.as.horizontal, !1, O, j);
                      an && (H.horizontal[ke] = an, vr = an.positionedLines.length === 1)
                    } Yr()
              } else {
                ar === "auto" && (ar = Mp(Re));
                const fr = Oh(J, i.glyphMap, i.glyphPositions, i.imagePositions, M, yr, f, Re, ar, le, ht, k.as.horizontal, !1, O, j);
                fr && (H.horizontal[ar] = fr), Yr(), _l(Mt) && m && v && (H.vertical = Oh(J, i.glyphMap, i.glyphPositions, i.imagePositions, M, yr, f, Re, ar, le, ht, k.as.vertical, !1, O, j))
              }
            }
            let Ot = !1;
            if (S.icon && S.icon.name) {
              const Mt = i.imageMap[S.icon.name];
              Mt && (rt = Rb(i.imagePositions[S.icon.name], n.get("icon-offset").evaluate(S, {}, i.canonical), n.get("icon-anchor").evaluate(S, {}, i.canonical)), Ot = !!Mt.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Ot : i.bucket.sdfIcons !== Ot && nr("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Mt.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
            }
            const bt = Gg(H.horizontal) || H.vertical;
            i.bucket.iconsInText = !!bt && bt.iconsInText, (bt || rt) && Yb(i.bucket, S, H, rt, i.imageMap, _, O, N, ht, Ot, i.canonical, i.subdivisionGranularity)
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
        }, k.cL = lp, k.cM = hp, k.cN = dp, k.cO = $m, k.cP = fp, k.cQ = class {
          constructor(i) {
            this._marks = {
              start: [i.url, "start"].join("#"),
              end: [i.url, "end"].join("#"),
              measure: i.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i
          }
        }, k.cR = function(i, r, n, a, _) {
          return c(this, void 0, void 0, (function*() {
            if (Lt()) try {
              return yield er(i, r, n, a, _)
            } catch {}
            return (function(f, m, v, b, S) {
              const M = f.width,
                j = f.height;
              hr && Mr || (hr = new OffscreenCanvas(M, j), Mr = hr.getContext("2d", {
                willReadFrequently: !0
              })), hr.width = M, hr.height = j, Mr.drawImage(f, 0, 0, M, j);
              const O = Mr.getImageData(m, v, b, S);
              return Mr.clearRect(0, 0, M, j), O.data
            })(i, r, n, a, _)
          }))
        }, k.cS = Rm, k.cT = X, k.cU = Wm, k.cV = sc, k.cW = Gs, k.cX = function(i, r) {
          const n = new Map;
          if (i != null)
            if (i.type === "Feature") n.set(Bl(i, r), i);
            else
              for (const a of i.features) n.set(Bl(a, r), a);
          return n
        }, k.cY = function(i, r) {
          if (i == null) return !0;
          if (i.type === "Feature") return Bl(i, r) != null;
          if (i.type === "FeatureCollection") {
            const n = new Set;
            for (const a of i.features) {
              const _ = Bl(a, r);
              if (_ == null || n.has(_)) return !1;
              n.add(_)
            }
            return !0
          }
          return !1
        }, k.cZ = function(i, r, n) {
          var a, _, f, m;
          if (r.removeAll && i.clear(), r.remove)
            for (const v of r.remove) i.delete(v);
          if (r.add)
            for (const v of r.add) {
              const b = Bl(v, n);
              b != null && i.set(b, v)
            }
          if (r.update)
            for (const v of r.update) {
              let b = i.get(v.id);
              if (b == null) continue;
              const S = !v.removeAllProperties && (((a = v.removeProperties) === null || a === void 0 ? void 0 : a.length) > 0 || ((_ = v.addOrUpdateProperties) === null || _ === void 0 ? void 0 : _.length) > 0);
              if ((v.newGeometry || v.removeAllProperties || S) && (b = Object.assign({}, b), i.set(v.id, b), S && (b.properties = Object.assign({}, b.properties))), v.newGeometry && (b.geometry = v.newGeometry), v.removeAllProperties) b.properties = {};
              else if (((f = v.removeProperties) === null || f === void 0 ? void 0 : f.length) > 0)
                for (const M of v.removeProperties) Object.prototype.hasOwnProperty.call(b.properties, M) && delete b.properties[M];
              if (((m = v.addOrUpdateProperties) === null || m === void 0 ? void 0 : m.length) > 0)
                for (const {
                    key: M,
                    value: j
                  }
                  of v.addOrUpdateProperties) b.properties[M] = j
            }
        }, k.c_ = _s, k.ca = class extends yl {}, k.cb = class extends h {}, k.cc = function(i, r) {
          return i[0] === r[0] && i[1] === r[1] && i[2] === r[2] && i[3] === r[3] && i[4] === r[4] && i[5] === r[5] && i[6] === r[6] && i[7] === r[7] && i[8] === r[8] && i[9] === r[9] && i[10] === r[10] && i[11] === r[11] && i[12] === r[12] && i[13] === r[13] && i[14] === r[14] && i[15] === r[15]
        }, k.cd = function(i, r) {
          var n = i[0],
            a = i[1],
            _ = i[2],
            f = i[3],
            m = i[4],
            v = i[5],
            b = i[6],
            S = i[7],
            M = i[8],
            j = i[9],
            O = i[10],
            N = i[11],
            H = i[12],
            J = i[13],
            rt = i[14],
            ht = i[15],
            Ot = r[0],
            bt = r[1],
            Mt = r[2],
            te = r[3],
            le = r[4],
            Re = r[5],
            br = r[6],
            ar = r[7],
            yr = r[8],
            Yr = r[9],
            fr = r[10],
            vr = r[11],
            ke = r[12],
            an = r[13],
            hn = r[14],
            Qr = r[15];
          return Math.abs(n - Ot) <= Dt * Math.max(1, Math.abs(n), Math.abs(Ot)) && Math.abs(a - bt) <= Dt * Math.max(1, Math.abs(a), Math.abs(bt)) && Math.abs(_ - Mt) <= Dt * Math.max(1, Math.abs(_), Math.abs(Mt)) && Math.abs(f - te) <= Dt * Math.max(1, Math.abs(f), Math.abs(te)) && Math.abs(m - le) <= Dt * Math.max(1, Math.abs(m), Math.abs(le)) && Math.abs(v - Re) <= Dt * Math.max(1, Math.abs(v), Math.abs(Re)) && Math.abs(b - br) <= Dt * Math.max(1, Math.abs(b), Math.abs(br)) && Math.abs(S - ar) <= Dt * Math.max(1, Math.abs(S), Math.abs(ar)) && Math.abs(M - yr) <= Dt * Math.max(1, Math.abs(M), Math.abs(yr)) && Math.abs(j - Yr) <= Dt * Math.max(1, Math.abs(j), Math.abs(Yr)) && Math.abs(O - fr) <= Dt * Math.max(1, Math.abs(O), Math.abs(fr)) && Math.abs(N - vr) <= Dt * Math.max(1, Math.abs(N), Math.abs(vr)) && Math.abs(H - ke) <= Dt * Math.max(1, Math.abs(H), Math.abs(ke)) && Math.abs(J - an) <= Dt * Math.max(1, Math.abs(J), Math.abs(an)) && Math.abs(rt - hn) <= Dt * Math.max(1, Math.abs(rt), Math.abs(hn)) && Math.abs(ht - Qr) <= Dt * Math.max(1, Math.abs(ht), Math.abs(Qr))
        }, k.ce = function(i, r) {
          return i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], i
        }, k.cf = i => i.type === "symbol", k.cg = i => i.type === "circle", k.ch = i => i.type === "heatmap", k.ci = i => i.type === "line", k.cj = i => i.type === "fill", k.ck = i => i.type === "fill-extrusion", k.cl = i => i.type === "hillshade", k.cm = i => i.type === "color-relief", k.cn = i => i.type === "background", k.co = i => i.type === "custom", k.cp = He, k.cq = function(i, r, n) {
          const a = Ie(r.x - n.x, r.y - n.y),
            _ = Ie(i.x - n.x, i.y - n.y);
          var f, m;
          return jr(Math.atan2(a[0] * _[1] - a[1] * _[0], (f = a)[0] * (m = _)[0] + f[1] * m[1]))
        }, k.cr = Tr, k.cs = function(i, r) {
          return _n[r] && (i instanceof MouseEvent || i instanceof WheelEvent)
        }, k.ct = function(i, r) {
          return Lr[r] && "touches" in i
        }, k.cu = function(i) {
          return Lr[i] || _n[i]
        }, k.cv = function(i, r, n) {
          var a = r[0],
            _ = r[1];
          return i[0] = n[0] * a + n[4] * _ + n[12], i[1] = n[1] * a + n[5] * _ + n[13], i
        }, k.cw = function(i, r) {
          const {
            x: n,
            y: a
          } = Rl.fromLngLat(r);
          return !(i < 0 || i > 25 || a < 0 || a >= 1 || n < 0 || n >= 1)
        }, k.cx = function(i, r) {
          return i[0] = r[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = r[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = r[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }, k.cy = class extends Wu {}, k.cz = Jb, k.d = Ft, k.e = se, k.f = i => c(void 0, void 0, void 0, (function*() {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const r = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(r)
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), k.g = U, k.h = i => new Promise(((r, n) => {
          const a = new Image;
          a.onload = () => {
            r(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame((() => {
              a.src = zr
            }))
          }, a.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const _ = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          a.src = i.byteLength ? URL.createObjectURL(_) : zr
        })), k.i = ir, k.j = (i, r) => Tt(se(i, {
          type: "json"
        }), r), k.k = mt, k.l = ie, k.m = Tt, k.n = (i, r) => Tt(se(i, {
          type: "arrayBuffer"
        }), r), k.o = function(i) {
          return new fp(i).readFields(Sb, [])
        }, k.p = ag, k.q = Sl, k.r = io, k.s = Pr, k.t = W, k.u = zn, k.v = hh, k.w = nr, k.x = kh, k.y = $d, k.z = ph
      })), z("worker", ["./shared"], (function(k) {
        class c {
          constructor(q, U) {
            this.keyCache = {}, q && this.replace(q, U)
          }
          replace(q, U) {
            this._layerConfigs = {}, this._layers = {}, this.update(q, [], U)
          }
          update(q, U, Q) {
            for (const _t of q) {
              this._layerConfigs[_t.id] = _t;
              const Tt = this._layers[_t.id] = k.bM(_t, Q);
              Tt._featureFilter = k.ae(Tt.filter, Q), this.keyCache[_t.id] && delete this.keyCache[_t.id]
            }
            for (const _t of U) delete this.keyCache[_t], delete this._layerConfigs[_t], delete this._layers[_t];
            this.familiesBySource = {};
            const nt = k.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const _t of nt) {
              const Tt = _t.map((et => this._layers[et.id])),
                Ft = Tt[0];
              if (Ft.visibility === "none") continue;
              const zt = Ft.source || "";
              let Nt = this.familiesBySource[zt];
              Nt || (Nt = this.familiesBySource[zt] = {});
              const ie = Ft.sourceLayer || "_geojsonTileLayer";
              let mt = Nt[ie];
              mt || (mt = Nt[ie] = []), mt.push(Tt)
            }
          }
        }
        class R {
          constructor(q) {
            const U = {},
              Q = [];
            for (const Ft in q) {
              const zt = q[Ft],
                Nt = U[Ft] = {};
              for (const ie in zt) {
                const mt = zt[+ie];
                if (!mt || mt.bitmap.width === 0 || mt.bitmap.height === 0) continue;
                const et = {
                  x: 0,
                  y: 0,
                  w: mt.bitmap.width + 2,
                  h: mt.bitmap.height + 2
                };
                Q.push(et), Nt[ie] = {
                  rect: et,
                  metrics: mt.metrics
                }
              }
            }
            const {
              w: nt,
              h: _t
            } = k.p(Q), Tt = new k.q({
              width: nt || 1,
              height: _t || 1
            });
            for (const Ft in q) {
              const zt = q[Ft];
              for (const Nt in zt) {
                const ie = zt[+Nt];
                if (!ie || ie.bitmap.width === 0 || ie.bitmap.height === 0) continue;
                const mt = U[Ft][Nt].rect;
                k.q.copy(ie.bitmap, Tt, {
                  x: 0,
                  y: 0
                }, {
                  x: mt.x + 1,
                  y: mt.y + 1
                }, ie.bitmap)
              }
            }
            this.image = Tt, this.positions = U
          }
        }
        k.cG("GlyphAtlas", R);
        class X {
          constructor(q) {
            this.tileID = new k.a0(q.tileID.overscaledZ, q.tileID.wrap, q.tileID.canonical.z, q.tileID.canonical.x, q.tileID.canonical.y), this.uid = q.uid, this.zoom = q.zoom, this.pixelRatio = q.pixelRatio, this.tileSize = q.tileSize, this.source = q.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = q.showCollisionBoxes, this.collectResourceTiming = !!q.collectResourceTiming, this.returnDependencies = !!q.returnDependencies, this.promoteId = q.promoteId, this.inFlightDependencies = []
          }
          parse(q, U, Q, nt, _t) {
            return k._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = q, this.collisionBoxArray = new k.ac;
              const Tt = new k.cH(Object.keys(q.layers).sort()),
                Ft = new k.cI(this.tileID, this.promoteId);
              Ft.bucketLayerIDs = [];
              const zt = {},
                Nt = {
                  featureIndex: Ft,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: Q,
                  subdivisionGranularity: _t
                },
                ie = U.familiesBySource[this.source];
              for (const Yt in ie) {
                const je = q.layers[Yt];
                if (!je) continue;
                je.version === 1 && k.w(`Vector tile source "${this.source}" layer "${Yt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Fe = Tt.encode(Yt),
                  Nr = [];
                for (let Ar = 0; Ar < je.length; Ar++) {
                  const Kt = je.feature(Ar),
                    Oe = Ft.getId(Kt, Yt);
                  Nr.push({
                    feature: Kt,
                    id: Oe,
                    index: Ar,
                    sourceLayerIndex: Fe
                  })
                }
                for (const Ar of ie[Yt]) {
                  const Kt = Ar[0];
                  Kt.source !== this.source && k.w(`layer.source = ${Kt.source} does not equal this.source = ${this.source}`), Kt.isHidden(this.zoom, !0) || ($(Ar, this.zoom, Q), (zt[Kt.id] = Kt.createBucket({
                    index: Ft.bucketLayerIDs.length,
                    layers: Ar,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: Fe,
                    sourceID: this.source
                  })).populate(Nr, Nt, this.tileID.canonical), Ft.bucketLayerIDs.push(Ar.map((Oe => Oe.id))))
                }
              }
              const mt = k.bR(Nt.glyphDependencies, (Yt => Object.keys(Yt).map(Number)));
              this.inFlightDependencies.forEach((Yt => Yt == null ? void 0 : Yt.abort())), this.inFlightDependencies = [];
              let et = Promise.resolve({});
              if (Object.keys(mt).length) {
                const Yt = new AbortController;
                this.inFlightDependencies.push(Yt), et = nt.sendAsync({
                  type: "GG",
                  data: {
                    stacks: mt,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, Yt)
              }
              const W = Object.keys(Nt.iconDependencies);
              let vt = Promise.resolve({});
              if (W.length) {
                const Yt = new AbortController;
                this.inFlightDependencies.push(Yt), vt = nt.sendAsync({
                  type: "GI",
                  data: {
                    icons: W,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, Yt)
              }
              const $t = Object.keys(Nt.patternDependencies);
              let Pt = Promise.resolve({});
              if ($t.length) {
                const Yt = new AbortController;
                this.inFlightDependencies.push(Yt), Pt = nt.sendAsync({
                  type: "GI",
                  data: {
                    icons: $t,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, Yt)
              }
              const Gt = Nt.dashDependencies;
              let ae = Promise.resolve({});
              if (Object.keys(Gt).length) {
                const Yt = new AbortController;
                this.inFlightDependencies.push(Yt), ae = nt.sendAsync({
                  type: "GDA",
                  data: {
                    dashes: Gt
                  }
                }, Yt)
              }
              const [ye, Te, we, be] = yield Promise.all([et, vt, Pt, ae]), Ee = new R(ye), Qe = new k.cJ(Te, we);
              for (const Yt in zt) {
                const je = zt[Yt];
                je instanceof k.ad ? ($(je.layers, this.zoom, Q), k.cK({
                  bucket: je,
                  glyphMap: ye,
                  glyphPositions: Ee.positions,
                  imageMap: Te,
                  imagePositions: Qe.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Nt.subdivisionGranularity
                })) : je.hasDependencies && (je instanceof k.cL || je instanceof k.cM || je instanceof k.cN) && ($(je.layers, this.zoom, Q), je.addFeatures(Nt, this.tileID.canonical, Qe.patternPositions, be))
              }
              return this.status = "done", {
                buckets: Object.values(zt).filter((Yt => !Yt.isEmpty())),
                featureIndex: Ft,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: Ee.image,
                imageAtlas: Qe,
                dashPositions: be,
                glyphMap: this.returnDependencies ? ye : null,
                iconMap: this.returnDependencies ? Te : null,
                glyphPositions: this.returnDependencies ? Ee.positions : null
              }
            }))
          }
        }

        function $(ct, q, U) {
          const Q = new k.G(q);
          for (const nt of ct) nt.recalculate(Q, U)
        }
        class tt {
          constructor(q, U, Q) {
            this.actor = q, this.layerIndex = U, this.availableImages = Q, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(q, U) {
            return k._(this, void 0, void 0, (function*() {
              const Q = yield k.n(q.request, U);
              try {
                return {
                  vectorTile: new k.cO(new k.cP(Q.data)),
                  rawData: Q.data,
                  cacheControl: Q.cacheControl,
                  expires: Q.expires
                }
              } catch (nt) {
                const _t = new Uint8Array(Q.data);
                let Tt = `Unable to parse the tile at ${q.request.url}, `;
                throw Tt += _t[0] === 31 && _t[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${nt.message}`, new Error(Tt)
              }
            }))
          }
          loadTile(q) {
            return k._(this, void 0, void 0, (function*() {
              const U = q.uid,
                Q = !!(q && q.request && q.request.collectResourceTiming) && new k.cQ(q.request),
                nt = new X(q);
              this.loading[U] = nt;
              const _t = new AbortController;
              nt.abort = _t;
              try {
                const Tt = yield this.loadVectorTile(q, _t);
                if (delete this.loading[U], !Tt) return null;
                const Ft = Tt.rawData,
                  zt = {};
                Tt.expires && (zt.expires = Tt.expires), Tt.cacheControl && (zt.cacheControl = Tt.cacheControl);
                const Nt = {};
                if (Q) {
                  const mt = Q.finish();
                  mt && (Nt.resourceTiming = JSON.parse(JSON.stringify(mt)))
                }
                nt.vectorTile = Tt.vectorTile;
                const ie = nt.parse(Tt.vectorTile, this.layerIndex, this.availableImages, this.actor, q.subdivisionGranularity);
                this.loaded[U] = nt, this.fetching[U] = {
                  rawTileData: Ft,
                  cacheControl: zt,
                  resourceTiming: Nt
                };
                try {
                  const mt = yield ie;
                  return k.e({
                    rawTileData: Ft.slice(0)
                  }, mt, zt, Nt)
                } finally {
                  delete this.fetching[U]
                }
              } catch (Tt) {
                throw delete this.loading[U], nt.status = "done", this.loaded[U] = nt, Tt
              }
            }))
          }
          reloadTile(q) {
            return k._(this, void 0, void 0, (function*() {
              const U = q.uid;
              if (!this.loaded || !this.loaded[U]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const Q = this.loaded[U];
              if (Q.showCollisionBoxes = q.showCollisionBoxes, Q.status === "parsing") {
                const nt = yield Q.parse(Q.vectorTile, this.layerIndex, this.availableImages, this.actor, q.subdivisionGranularity);
                let _t;
                if (this.fetching[U]) {
                  const {
                    rawTileData: Tt,
                    cacheControl: Ft,
                    resourceTiming: zt
                  } = this.fetching[U];
                  delete this.fetching[U], _t = k.e({
                    rawTileData: Tt.slice(0)
                  }, nt, Ft, zt)
                } else _t = nt;
                return _t
              }
              if (Q.status === "done" && Q.vectorTile) return Q.parse(Q.vectorTile, this.layerIndex, this.availableImages, this.actor, q.subdivisionGranularity)
            }))
          }
          abortTile(q) {
            return k._(this, void 0, void 0, (function*() {
              const U = this.loading,
                Q = q.uid;
              U && U[Q] && U[Q].abort && (U[Q].abort.abort(), delete U[Q])
            }))
          }
          removeTile(q) {
            return k._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[q.uid] && delete this.loaded[q.uid]
            }))
          }
        }
        class ut {
          constructor() {
            this.loaded = {}
          }
          loadTile(q) {
            return k._(this, void 0, void 0, (function*() {
              const {
                uid: U,
                encoding: Q,
                rawImageData: nt,
                redFactor: _t,
                greenFactor: Tt,
                blueFactor: Ft,
                baseShift: zt
              } = q, Nt = nt.width + 2, ie = nt.height + 2, mt = k.b(nt) ? new k.R({
                width: Nt,
                height: ie
              }, yield k.cR(nt, -1, -1, Nt, ie)) : nt, et = new k.cS(U, mt, Q, _t, Tt, Ft, zt);
              return this.loaded = this.loaded || {}, this.loaded[U] = et, et
            }))
          }
          removeTile(q) {
            const U = this.loaded,
              Q = q.uid;
            U && U[Q] && delete U[Q]
          }
        }
        var xt, lt, G = (function() {
            if (lt) return xt;

            function ct(U, Q) {
              if (U.length !== 0) {
                q(U[0], Q);
                for (var nt = 1; nt < U.length; nt++) q(U[nt], !Q)
              }
            }

            function q(U, Q) {
              for (var nt = 0, _t = 0, Tt = 0, Ft = U.length, zt = Ft - 1; Tt < Ft; zt = Tt++) {
                var Nt = (U[Tt][0] - U[zt][0]) * (U[zt][1] + U[Tt][1]),
                  ie = nt + Nt;
                _t += Math.abs(nt) >= Math.abs(Nt) ? nt - ie + Nt : Nt - ie + nt, nt = ie
              }
              nt + _t >= 0 != !!Q && U.reverse()
            }
            return lt = 1, xt = function U(Q, nt) {
              var _t, Tt = Q && Q.type;
              if (Tt === "FeatureCollection")
                for (_t = 0; _t < Q.features.length; _t++) U(Q.features[_t], nt);
              else if (Tt === "GeometryCollection")
                for (_t = 0; _t < Q.geometries.length; _t++) U(Q.geometries[_t], nt);
              else if (Tt === "Feature") U(Q.geometry, nt);
              else if (Tt === "Polygon") ct(Q.coordinates, nt);
              else if (Tt === "MultiPolygon")
                for (_t = 0; _t < Q.coordinates.length; _t++) ct(Q.coordinates[_t], nt);
              return Q
            }
          })(),
          yt = k.cT(G);
        class Lt extends k.cV {
          constructor(q, U) {
            super(new k.cP, 0, U, [], []), this.feature = q, this.type = q.type, this.properties = q.tags ? q.tags : {}, "id" in q && (typeof q.id == "string" ? this.id = parseInt(q.id, 10) : typeof q.id != "number" || isNaN(q.id) || (this.id = q.id))
          }
          loadGeometry() {
            const q = [],
              U = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const Q of U) {
              const nt = [];
              for (const _t of Q) nt.push(new k.P(_t[0], _t[1]));
              q.push(nt)
            }
            return q
          }
        }
        class Dt extends k.cU {
          constructor(q, U) {
            super(new k.cP), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = U ? U.version : 1, this.extent = U ? U.extent : 4096, this.length = q.length, this.features = q
          }
          feature(q) {
            return new Lt(this.features[q], this.extent)
          }
        }

        function St(ct, q) {
          q.writeVarintField(15, ct.version || 1), q.writeStringField(1, ct.name || ""), q.writeVarintField(5, ct.extent || 4096);
          const U = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let _t = 0; _t < ct.length; _t++) U.feature = ct.feature(_t), q.writeMessage(2, qt, U);
          const Q = U.keys;
          for (const _t of Q) q.writeStringField(3, _t);
          const nt = U.values;
          for (const _t of nt) q.writeMessage(4, Wt, _t)
        }

        function qt(ct, q) {
          if (!ct.feature) return;
          const U = ct.feature;
          U.id !== void 0 && q.writeVarintField(1, U.id), q.writeMessage(2, Vt, ct), q.writeVarintField(3, U.type), q.writeMessage(4, Ct, U)
        }

        function Vt(ct, q) {
          var U;
          for (const Q in (U = ct.feature) == null ? void 0 : U.properties) {
            let nt = ct.feature.properties[Q],
              _t = ct.keycache[Q];
            if (nt === null) continue;
            _t === void 0 && (ct.keys.push(Q), _t = ct.keys.length - 1, ct.keycache[Q] = _t), q.writeVarint(_t), typeof nt != "string" && typeof nt != "boolean" && typeof nt != "number" && (nt = JSON.stringify(nt));
            const Tt = typeof nt + ":" + nt;
            let Ft = ct.valuecache[Tt];
            Ft === void 0 && (ct.values.push(nt), Ft = ct.values.length - 1, ct.valuecache[Tt] = Ft), q.writeVarint(Ft)
          }
        }

        function Zt(ct, q) {
          return (q << 3) + (7 & ct)
        }

        function Et(ct) {
          return ct << 1 ^ ct >> 31
        }

        function Ct(ct, q) {
          const U = ct.loadGeometry(),
            Q = ct.type;
          let nt = 0,
            _t = 0;
          for (const Tt of U) {
            let Ft = 1;
            Q === 1 && (Ft = Tt.length), q.writeVarint(Zt(1, Ft));
            const zt = Q === 3 ? Tt.length - 1 : Tt.length;
            for (let Nt = 0; Nt < zt; Nt++) {
              Nt === 1 && Q !== 1 && q.writeVarint(Zt(2, zt - 1));
              const ie = Tt[Nt].x - nt,
                mt = Tt[Nt].y - _t;
              q.writeVarint(Et(ie)), q.writeVarint(Et(mt)), nt += ie, _t += mt
            }
            ct.type === 3 && q.writeVarint(Zt(7, 1))
          }
        }

        function Wt(ct, q) {
          const U = typeof ct;
          U === "string" ? q.writeStringField(1, ct) : U === "boolean" ? q.writeBooleanField(7, ct) : U === "number" && (ct % 1 != 0 ? q.writeDoubleField(3, ct) : ct < 0 ? q.writeSVarintField(6, ct) : q.writeVarintField(5, ct))
        }
        const jt = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: ct => ct
          },
          Ht = Math.fround || (_e = new Float32Array(1), ct => (_e[0] = +ct, _e[0]));
        var _e;
        class Ut {
          constructor(q) {
            this.options = Object.assign(Object.create(jt), q), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(q) {
            const {
              log: U,
              minZoom: Q,
              maxZoom: nt
            } = this.options;
            U && console.time("total time");
            const _t = `prepare ${q.length} points`;
            U && console.time(_t), this.points = q;
            const Tt = [];
            for (let zt = 0; zt < q.length; zt++) {
              const Nt = q[zt];
              if (!Nt.geometry) continue;
              const [ie, mt] = Nt.geometry.coordinates, et = Ht(Ce(ie)), W = Ht(Ve(mt));
              Tt.push(et, W, 1 / 0, zt, -1, 1), this.options.reduce && Tt.push(0)
            }
            let Ft = this.trees[nt + 1] = this._createTree(Tt);
            U && console.timeEnd(_t);
            for (let zt = nt; zt >= Q; zt--) {
              const Nt = +Date.now();
              Ft = this.trees[zt] = this._createTree(this._cluster(Ft, zt)), U && console.log("z%d: %d clusters in %dms", zt, Ft.numItems, +Date.now() - Nt)
            }
            return U && console.timeEnd("total time"), this
          }
          getClusters(q, U) {
            let Q = ((q[0] + 180) % 360 + 360) % 360 - 180;
            const nt = Math.max(-90, Math.min(90, q[1]));
            let _t = q[2] === 180 ? 180 : ((q[2] + 180) % 360 + 360) % 360 - 180;
            const Tt = Math.max(-90, Math.min(90, q[3]));
            if (q[2] - q[0] >= 360) Q = -180, _t = 180;
            else if (Q > _t) {
              const mt = this.getClusters([Q, nt, 180, Tt], U),
                et = this.getClusters([-180, nt, _t, Tt], U);
              return mt.concat(et)
            }
            const Ft = this.trees[this._limitZoom(U)],
              zt = Ft.range(Ce(Q), Ve(Tt), Ce(_t), Ve(nt)),
              Nt = Ft.data,
              ie = [];
            for (const mt of zt) {
              const et = this.stride * mt;
              ie.push(Nt[et + 5] > 1 ? Xt(Nt, et, this.clusterProps) : this.points[Nt[et + 3]])
            }
            return ie
          }
          getChildren(q) {
            const U = this._getOriginId(q),
              Q = this._getOriginZoom(q),
              nt = "No cluster with the specified id.",
              _t = this.trees[Q];
            if (!_t) throw new Error(nt);
            const Tt = _t.data;
            if (U * this.stride >= Tt.length) throw new Error(nt);
            const Ft = this.options.radius / (this.options.extent * Math.pow(2, Q - 1)),
              zt = _t.within(Tt[U * this.stride], Tt[U * this.stride + 1], Ft),
              Nt = [];
            for (const ie of zt) {
              const mt = ie * this.stride;
              Tt[mt + 4] === q && Nt.push(Tt[mt + 5] > 1 ? Xt(Tt, mt, this.clusterProps) : this.points[Tt[mt + 3]])
            }
            if (Nt.length === 0) throw new Error(nt);
            return Nt
          }
          getLeaves(q, U, Q) {
            const nt = [];
            return this._appendLeaves(nt, q, U = U || 10, Q = Q || 0, 0), nt
          }
          getTile(q, U, Q) {
            const nt = this.trees[this._limitZoom(q)],
              _t = Math.pow(2, q),
              {
                extent: Tt,
                radius: Ft
              } = this.options,
              zt = Ft / Tt,
              Nt = (Q - zt) / _t,
              ie = (Q + 1 + zt) / _t,
              mt = {
                features: []
              };
            return this._addTileFeatures(nt.range((U - zt) / _t, Nt, (U + 1 + zt) / _t, ie), nt.data, U, Q, _t, mt), U === 0 && this._addTileFeatures(nt.range(1 - zt / _t, Nt, 1, ie), nt.data, _t, Q, _t, mt), U === _t - 1 && this._addTileFeatures(nt.range(0, Nt, zt / _t, ie), nt.data, -1, Q, _t, mt), mt.features.length ? mt : null
          }
          getClusterExpansionZoom(q) {
            let U = this._getOriginZoom(q) - 1;
            for (; U <= this.options.maxZoom;) {
              const Q = this.getChildren(q);
              if (U++, Q.length !== 1) break;
              q = Q[0].properties.cluster_id
            }
            return U
          }
          _appendLeaves(q, U, Q, nt, _t) {
            const Tt = this.getChildren(U);
            for (const Ft of Tt) {
              const zt = Ft.properties;
              if (zt && zt.cluster ? _t + zt.point_count <= nt ? _t += zt.point_count : _t = this._appendLeaves(q, zt.cluster_id, Q, nt, _t) : _t < nt ? _t++ : q.push(Ft), q.length === Q) break
            }
            return _t
          }
          _createTree(q) {
            const U = new k.aM(q.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let Q = 0; Q < q.length; Q += this.stride) U.add(q[Q], q[Q + 1]);
            return U.finish(), U.data = q, U
          }
          _addTileFeatures(q, U, Q, nt, _t, Tt) {
            for (const Ft of q) {
              const zt = Ft * this.stride,
                Nt = U[zt + 5] > 1;
              let ie, mt, et;
              if (Nt) ie = me(U, zt, this.clusterProps), mt = U[zt], et = U[zt + 1];
              else {
                const $t = this.points[U[zt + 3]];
                ie = $t.properties;
                const [Pt, Gt] = $t.geometry.coordinates;
                mt = Ce(Pt), et = Ve(Gt)
              }
              const W = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (mt * _t - Q)), Math.round(this.options.extent * (et * _t - nt))]
                ],
                tags: ie
              };
              let vt;
              vt = Nt || this.options.generateId ? U[zt + 3] : this.points[U[zt + 3]].id, vt !== void 0 && (W.id = vt), Tt.features.push(W)
            }
          }
          _limitZoom(q) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+q), this.options.maxZoom + 1))
          }
          _cluster(q, U) {
            const {
              radius: Q,
              extent: nt,
              reduce: _t,
              minPoints: Tt
            } = this.options, Ft = Q / (nt * Math.pow(2, U)), zt = q.data, Nt = [], ie = this.stride;
            for (let mt = 0; mt < zt.length; mt += ie) {
              if (zt[mt + 2] <= U) continue;
              zt[mt + 2] = U;
              const et = zt[mt],
                W = zt[mt + 1],
                vt = q.within(zt[mt], zt[mt + 1], Ft),
                $t = zt[mt + 5];
              let Pt = $t;
              for (const Gt of vt) {
                const ae = Gt * ie;
                zt[ae + 2] > U && (Pt += zt[ae + 5])
              }
              if (Pt > $t && Pt >= Tt) {
                let Gt, ae = et * $t,
                  ye = W * $t,
                  Te = -1;
                const we = (mt / ie << 5) + (U + 1) + this.points.length;
                for (const be of vt) {
                  const Ee = be * ie;
                  if (zt[Ee + 2] <= U) continue;
                  zt[Ee + 2] = U;
                  const Qe = zt[Ee + 5];
                  ae += zt[Ee] * Qe, ye += zt[Ee + 1] * Qe, zt[Ee + 4] = we, _t && (Gt || (Gt = this._map(zt, mt, !0), Te = this.clusterProps.length, this.clusterProps.push(Gt)), _t(Gt, this._map(zt, Ee)))
                }
                zt[mt + 4] = we, Nt.push(ae / Pt, ye / Pt, 1 / 0, we, -1, Pt), _t && Nt.push(Te)
              } else {
                for (let Gt = 0; Gt < ie; Gt++) Nt.push(zt[mt + Gt]);
                if (Pt > 1)
                  for (const Gt of vt) {
                    const ae = Gt * ie;
                    if (!(zt[ae + 2] <= U)) {
                      zt[ae + 2] = U;
                      for (let ye = 0; ye < ie; ye++) Nt.push(zt[ae + ye])
                    }
                  }
              }
            }
            return Nt
          }
          _getOriginId(q) {
            return q - this.points.length >> 5
          }
          _getOriginZoom(q) {
            return (q - this.points.length) % 32
          }
          _map(q, U, Q) {
            if (q[U + 5] > 1) {
              const Tt = this.clusterProps[q[U + 6]];
              return Q ? Object.assign({}, Tt) : Tt
            }
            const nt = this.points[q[U + 3]].properties,
              _t = this.options.map(nt);
            return Q && _t === nt ? Object.assign({}, _t) : _t
          }
        }

        function Xt(ct, q, U) {
          return {
            type: "Feature",
            id: ct[q + 3],
            properties: me(ct, q, U),
            geometry: {
              type: "Point",
              coordinates: [(Q = ct[q], 360 * (Q - .5)), Ie(ct[q + 1])]
            }
          };
          var Q
        }

        function me(ct, q, U) {
          const Q = ct[q + 5],
            nt = Q >= 1e4 ? `${Math.round(Q/1e3)}k` : Q >= 1e3 ? Math.round(Q / 100) / 10 + "k" : Q,
            _t = ct[q + 6],
            Tt = _t === -1 ? {} : Object.assign({}, U[_t]);
          return Object.assign(Tt, {
            cluster: !0,
            cluster_id: ct[q + 3],
            point_count: Q,
            point_count_abbreviated: nt
          })
        }

        function Ce(ct) {
          return ct / 360 + .5
        }

        function Ve(ct) {
          const q = Math.sin(ct * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + q) / (1 - q)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function Ie(ct) {
          const q = (180 - 360 * ct) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(q)) / Math.PI - 90
        }

        function ne(ct, q, U, Q) {
          let nt = Q;
          const _t = q + (U - q >> 1);
          let Tt, Ft = U - q;
          const zt = ct[q],
            Nt = ct[q + 1],
            ie = ct[U],
            mt = ct[U + 1];
          for (let et = q + 3; et < U; et += 3) {
            const W = Xe(ct[et], ct[et + 1], zt, Nt, ie, mt);
            if (W > nt) Tt = et, nt = W;
            else if (W === nt) {
              const vt = Math.abs(et - _t);
              vt < Ft && (Tt = et, Ft = vt)
            }
          }
          nt > Q && (Tt - q > 3 && ne(ct, q, Tt, Q), ct[Tt + 2] = nt, U - Tt > 3 && ne(ct, Tt, U, Q))
        }

        function Xe(ct, q, U, Q, nt, _t) {
          let Tt = nt - U,
            Ft = _t - Q;
          if (Tt !== 0 || Ft !== 0) {
            const zt = ((ct - U) * Tt + (q - Q) * Ft) / (Tt * Tt + Ft * Ft);
            zt > 1 ? (U = nt, Q = _t) : zt > 0 && (U += Tt * zt, Q += Ft * zt)
          }
          return Tt = ct - U, Ft = q - Q, Tt * Tt + Ft * Ft
        }

        function pe(ct, q, U, Q) {
          const nt = {
            id: ct ?? null,
            type: q,
            geometry: U,
            tags: Q,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (q === "Point" || q === "MultiPoint" || q === "LineString") Ue(nt, U);
          else if (q === "Polygon") Ue(nt, U[0]);
          else if (q === "MultiLineString")
            for (const _t of U) Ue(nt, _t);
          else if (q === "MultiPolygon")
            for (const _t of U) Ue(nt, _t[0]);
          return nt
        }

        function Ue(ct, q) {
          for (let U = 0; U < q.length; U += 3) ct.minX = Math.min(ct.minX, q[U]), ct.minY = Math.min(ct.minY, q[U + 1]), ct.maxX = Math.max(ct.maxX, q[U]), ct.maxY = Math.max(ct.maxY, q[U + 1])
        }

        function Ae(ct, q, U, Q) {
          if (!q.geometry) return;
          const nt = q.geometry.coordinates;
          if (nt && nt.length === 0) return;
          const _t = q.geometry.type,
            Tt = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2);
          let Ft = [],
            zt = q.id;
          if (U.promoteId ? zt = q.properties[U.promoteId] : U.generateId && (zt = Q || 0), _t === "Point") He(nt, Ft);
          else if (_t === "MultiPoint")
            for (const Nt of nt) He(Nt, Ft);
          else if (_t === "LineString") Tr(nt, Ft, Tt, !1);
          else if (_t === "MultiLineString") {
            if (U.lineMetrics) {
              for (const Nt of nt) Ft = [], Tr(Nt, Ft, Tt, !1), ct.push(pe(zt, "LineString", Ft, q.properties));
              return
            }
            Ye(nt, Ft, Tt, !1)
          } else if (_t === "Polygon") Ye(nt, Ft, Tt, !0);
          else {
            if (_t !== "MultiPolygon") {
              if (_t === "GeometryCollection") {
                for (const Nt of q.geometry.geometries) Ae(ct, {
                  id: zt,
                  geometry: Nt,
                  properties: q.properties
                }, U, Q);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Nt of nt) {
              const ie = [];
              Ye(Nt, ie, Tt, !0), Ft.push(ie)
            }
          }
          ct.push(pe(zt, _t, Ft, q.properties))
        }

        function He(ct, q) {
          q.push(mr(ct[0]), se(ct[1]), 0)
        }

        function Tr(ct, q, U, Q) {
          let nt, _t, Tt = 0;
          for (let zt = 0; zt < ct.length; zt++) {
            const Nt = mr(ct[zt][0]),
              ie = se(ct[zt][1]);
            q.push(Nt, ie, 0), zt > 0 && (Tt += Q ? (nt * ie - Nt * _t) / 2 : Math.sqrt(Math.pow(Nt - nt, 2) + Math.pow(ie - _t, 2))), nt = Nt, _t = ie
          }
          const Ft = q.length - 3;
          q[2] = 1, ne(q, 0, Ft, U), q[Ft + 2] = 1, q.size = Math.abs(Tt), q.start = 0, q.end = q.size
        }

        function Ye(ct, q, U, Q) {
          for (let nt = 0; nt < ct.length; nt++) {
            const _t = [];
            Tr(ct[nt], _t, U, Q), q.push(_t)
          }
        }

        function mr(ct) {
          return ct / 360 + .5
        }

        function se(ct) {
          const q = Math.sin(ct * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + q) / (1 - q)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function ce(ct, q, U, Q, nt, _t, Tt, Ft) {
          if (Q /= q, _t >= (U /= q) && Tt < Q) return ct;
          if (Tt < U || _t >= Q) return null;
          const zt = [];
          for (const Nt of ct) {
            const ie = Nt.geometry;
            let mt = Nt.type;
            const et = nt === 0 ? Nt.minX : Nt.minY,
              W = nt === 0 ? Nt.maxX : Nt.maxY;
            if (et >= U && W < Q) {
              zt.push(Nt);
              continue
            }
            if (W < U || et >= Q) continue;
            let vt = [];
            if (mt === "Point" || mt === "MultiPoint") ur(ie, vt, U, Q, nt);
            else if (mt === "LineString") Ke(ie, vt, U, Q, nt, !1, Ft.lineMetrics);
            else if (mt === "MultiLineString") _r(ie, vt, U, Q, nt, !1);
            else if (mt === "Polygon") _r(ie, vt, U, Q, nt, !0);
            else if (mt === "MultiPolygon")
              for (const $t of ie) {
                const Pt = [];
                _r($t, Pt, U, Q, nt, !0), Pt.length && vt.push(Pt)
              }
            if (vt.length) {
              if (Ft.lineMetrics && mt === "LineString") {
                for (const $t of vt) zt.push(pe(Nt.id, mt, $t, Nt.tags));
                continue
              }
              mt !== "LineString" && mt !== "MultiLineString" || (vt.length === 1 ? (mt = "LineString", vt = vt[0]) : mt = "MultiLineString"), mt !== "Point" && mt !== "MultiPoint" || (mt = vt.length === 3 ? "Point" : "MultiPoint"), zt.push(pe(Nt.id, mt, vt, Nt.tags))
            }
          }
          return zt.length ? zt : null
        }

        function ur(ct, q, U, Q, nt) {
          for (let _t = 0; _t < ct.length; _t += 3) {
            const Tt = ct[_t + nt];
            Tt >= U && Tt <= Q && nr(q, ct[_t], ct[_t + 1], ct[_t + 2])
          }
        }

        function Ke(ct, q, U, Q, nt, _t, Tt) {
          let Ft = ve(ct);
          const zt = nt === 0 ? gr : ir;
          let Nt, ie, mt = ct.start;
          for (let Pt = 0; Pt < ct.length - 3; Pt += 3) {
            const Gt = ct[Pt],
              ae = ct[Pt + 1],
              ye = ct[Pt + 2],
              Te = ct[Pt + 3],
              we = ct[Pt + 4],
              be = nt === 0 ? Gt : ae,
              Ee = nt === 0 ? Te : we;
            let Qe = !1;
            Tt && (Nt = Math.sqrt(Math.pow(Gt - Te, 2) + Math.pow(ae - we, 2))), be < U ? Ee > U && (ie = zt(Ft, Gt, ae, Te, we, U), Tt && (Ft.start = mt + Nt * ie)) : be > Q ? Ee < Q && (ie = zt(Ft, Gt, ae, Te, we, Q), Tt && (Ft.start = mt + Nt * ie)) : nr(Ft, Gt, ae, ye), Ee < U && be >= U && (ie = zt(Ft, Gt, ae, Te, we, U), Qe = !0), Ee > Q && be <= Q && (ie = zt(Ft, Gt, ae, Te, we, Q), Qe = !0), !_t && Qe && (Tt && (Ft.end = mt + Nt * ie), q.push(Ft), Ft = ve(ct)), Tt && (mt += Nt)
          }
          let et = ct.length - 3;
          const W = ct[et],
            vt = ct[et + 1],
            $t = nt === 0 ? W : vt;
          $t >= U && $t <= Q && nr(Ft, W, vt, ct[et + 2]), et = Ft.length - 3, _t && et >= 3 && (Ft[et] !== Ft[0] || Ft[et + 1] !== Ft[1]) && nr(Ft, Ft[0], Ft[1], Ft[2]), Ft.length && q.push(Ft)
        }

        function ve(ct) {
          const q = [];
          return q.size = ct.size, q.start = ct.start, q.end = ct.end, q
        }

        function _r(ct, q, U, Q, nt, _t) {
          for (const Tt of ct) Ke(Tt, q, U, Q, nt, _t, !1)
        }

        function nr(ct, q, U, Q) {
          ct.push(q, U, Q)
        }

        function gr(ct, q, U, Q, nt, _t) {
          const Tt = (_t - q) / (Q - q);
          return nr(ct, _t, U + (nt - U) * Tt, 1), Tt
        }

        function ir(ct, q, U, Q, nt, _t) {
          const Tt = (_t - U) / (nt - U);
          return nr(ct, q + (Q - q) * Tt, _t, 1), Tt
        }

        function Ze(ct, q) {
          const U = [];
          for (let Q = 0; Q < ct.length; Q++) {
            const nt = ct[Q],
              _t = nt.type;
            let Tt;
            if (_t === "Point" || _t === "MultiPoint" || _t === "LineString") Tt = or(nt.geometry, q);
            else if (_t === "MultiLineString" || _t === "Polygon") {
              Tt = [];
              for (const Ft of nt.geometry) Tt.push(or(Ft, q))
            } else if (_t === "MultiPolygon") {
              Tt = [];
              for (const Ft of nt.geometry) {
                const zt = [];
                for (const Nt of Ft) zt.push(or(Nt, q));
                Tt.push(zt)
              }
            }
            U.push(pe(nt.id, _t, Tt, nt.tags))
          }
          return U
        }

        function or(ct, q) {
          const U = [];
          U.size = ct.size, ct.start !== void 0 && (U.start = ct.start, U.end = ct.end);
          for (let Q = 0; Q < ct.length; Q += 3) U.push(ct[Q] + q, ct[Q + 1], ct[Q + 2]);
          return U
        }

        function de(ct, q) {
          if (ct.transformed) return ct;
          const U = 1 << ct.z,
            Q = ct.x,
            nt = ct.y;
          for (const _t of ct.features) {
            const Tt = _t.geometry,
              Ft = _t.type;
            if (_t.geometry = [], Ft === 1)
              for (let zt = 0; zt < Tt.length; zt += 2) _t.geometry.push(zr(Tt[zt], Tt[zt + 1], q, U, Q, nt));
            else
              for (let zt = 0; zt < Tt.length; zt++) {
                const Nt = [];
                for (let ie = 0; ie < Tt[zt].length; ie += 2) Nt.push(zr(Tt[zt][ie], Tt[zt][ie + 1], q, U, Q, nt));
                _t.geometry.push(Nt)
              }
          }
          return ct.transformed = !0, ct
        }

        function zr(ct, q, U, Q, nt, _t) {
          return [Math.round(U * (ct * Q - nt)), Math.round(U * (q * Q - _t))]
        }

        function er(ct, q, U, Q, nt) {
          const _t = q === nt.maxZoom ? 0 : nt.tolerance / ((1 << q) * nt.extent),
            Tt = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: ct.length,
              source: null,
              x: U,
              y: Q,
              z: q,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const Ft of ct) hr(Tt, Ft, _t, nt);
          return Tt
        }

        function hr(ct, q, U, Q) {
          const nt = q.geometry,
            _t = q.type,
            Tt = [];
          if (ct.minX = Math.min(ct.minX, q.minX), ct.minY = Math.min(ct.minY, q.minY), ct.maxX = Math.max(ct.maxX, q.maxX), ct.maxY = Math.max(ct.maxY, q.maxY), _t === "Point" || _t === "MultiPoint")
            for (let Ft = 0; Ft < nt.length; Ft += 3) Tt.push(nt[Ft], nt[Ft + 1]), ct.numPoints++, ct.numSimplified++;
          else if (_t === "LineString") Mr(Tt, nt, ct, U, !1, !1);
          else if (_t === "MultiLineString" || _t === "Polygon")
            for (let Ft = 0; Ft < nt.length; Ft++) Mr(Tt, nt[Ft], ct, U, _t === "Polygon", Ft === 0);
          else if (_t === "MultiPolygon")
            for (let Ft = 0; Ft < nt.length; Ft++) {
              const zt = nt[Ft];
              for (let Nt = 0; Nt < zt.length; Nt++) Mr(Tt, zt[Nt], ct, U, !0, Nt === 0)
            }
          if (Tt.length) {
            let Ft = q.tags || null;
            if (_t === "LineString" && Q.lineMetrics) {
              Ft = {};
              for (const Nt in q.tags) Ft[Nt] = q.tags[Nt];
              Ft.mapbox_clip_start = nt.start / nt.size, Ft.mapbox_clip_end = nt.end / nt.size
            }
            const zt = {
              geometry: Tt,
              type: _t === "Polygon" || _t === "MultiPolygon" ? 3 : _t === "LineString" || _t === "MultiLineString" ? 2 : 1,
              tags: Ft
            };
            q.id !== null && (zt.id = q.id), ct.features.push(zt)
          }
        }

        function Mr(ct, q, U, Q, nt, _t) {
          const Tt = Q * Q;
          if (Q > 0 && q.size < (nt ? Tt : Q)) return void(U.numPoints += q.length / 3);
          const Ft = [];
          for (let zt = 0; zt < q.length; zt += 3)(Q === 0 || q[zt + 2] > Tt) && (U.numSimplified++, Ft.push(q[zt], q[zt + 1])), U.numPoints++;
          nt && (function(zt, Nt) {
            let ie = 0;
            for (let mt = 0, et = zt.length, W = et - 2; mt < et; W = mt, mt += 2) ie += (zt[mt] - zt[W]) * (zt[mt + 1] + zt[W + 1]);
            if (ie > 0 === Nt)
              for (let mt = 0, et = zt.length; mt < et / 2; mt += 2) {
                const W = zt[mt],
                  vt = zt[mt + 1];
                zt[mt] = zt[et - 2 - mt], zt[mt + 1] = zt[et - 1 - mt], zt[et - 2 - mt] = W, zt[et - 1 - mt] = vt
              }
          })(Ft, _t), ct.push(Ft)
        }
        const Pr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Or {
          constructor(q, U) {
            const Q = (U = this.options = (function(_t, Tt) {
              for (const Ft in Tt) _t[Ft] = Tt[Ft];
              return _t
            })(Object.create(Pr), U)).debug;
            if (Q && console.time("preprocess data"), U.maxZoom < 0 || U.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (U.promoteId && U.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let nt = (function(_t, Tt) {
              const Ft = [];
              if (_t.type === "FeatureCollection")
                for (let zt = 0; zt < _t.features.length; zt++) Ae(Ft, _t.features[zt], Tt, zt);
              else Ae(Ft, _t.type === "Feature" ? _t : {
                geometry: _t
              }, Tt);
              return Ft
            })(q, U);
            this.tiles = {}, this.tileCoords = [], Q && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", U.indexMaxZoom, U.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), nt = (function(_t, Tt) {
              const Ft = Tt.buffer / Tt.extent;
              let zt = _t;
              const Nt = ce(_t, 1, -1 - Ft, Ft, 0, -1, 2, Tt),
                ie = ce(_t, 1, 1 - Ft, 2 + Ft, 0, -1, 2, Tt);
              return (Nt || ie) && (zt = ce(_t, 1, -Ft, 1 + Ft, 0, -1, 2, Tt) || [], Nt && (zt = Ze(Nt, 1).concat(zt)), ie && (zt = zt.concat(Ze(ie, -1)))), zt
            })(nt, U), nt.length && this.splitTile(nt, 0, 0, 0), Q && (nt.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(q, U, Q, nt, _t, Tt, Ft) {
            const zt = [q, U, Q, nt],
              Nt = this.options,
              ie = Nt.debug;
            for (; zt.length;) {
              nt = zt.pop(), Q = zt.pop(), U = zt.pop(), q = zt.pop();
              const mt = 1 << U,
                et = jr(U, Q, nt);
              let W = this.tiles[et];
              if (!W && (ie > 1 && console.time("creation"), W = this.tiles[et] = er(q, U, Q, nt, Nt), this.tileCoords.push({
                  z: U,
                  x: Q,
                  y: nt
                }), ie)) {
                ie > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", U, Q, nt, W.numFeatures, W.numPoints, W.numSimplified), console.timeEnd("creation"));
                const Qe = `z${U}`;
                this.stats[Qe] = (this.stats[Qe] || 0) + 1, this.total++
              }
              if (W.source = q, _t == null) {
                if (U === Nt.indexMaxZoom || W.numPoints <= Nt.indexMaxPoints) continue
              } else {
                if (U === Nt.maxZoom || U === _t) continue;
                if (_t != null) {
                  const Qe = _t - U;
                  if (Q !== Tt >> Qe || nt !== Ft >> Qe) continue
                }
              }
              if (W.source = null, q.length === 0) continue;
              ie > 1 && console.time("clipping");
              const vt = .5 * Nt.buffer / Nt.extent,
                $t = .5 - vt,
                Pt = .5 + vt,
                Gt = 1 + vt;
              let ae = null,
                ye = null,
                Te = null,
                we = null,
                be = ce(q, mt, Q - vt, Q + Pt, 0, W.minX, W.maxX, Nt),
                Ee = ce(q, mt, Q + $t, Q + Gt, 0, W.minX, W.maxX, Nt);
              q = null, be && (ae = ce(be, mt, nt - vt, nt + Pt, 1, W.minY, W.maxY, Nt), ye = ce(be, mt, nt + $t, nt + Gt, 1, W.minY, W.maxY, Nt), be = null), Ee && (Te = ce(Ee, mt, nt - vt, nt + Pt, 1, W.minY, W.maxY, Nt), we = ce(Ee, mt, nt + $t, nt + Gt, 1, W.minY, W.maxY, Nt), Ee = null), ie > 1 && console.timeEnd("clipping"), zt.push(ae || [], U + 1, 2 * Q, 2 * nt), zt.push(ye || [], U + 1, 2 * Q, 2 * nt + 1), zt.push(Te || [], U + 1, 2 * Q + 1, 2 * nt), zt.push(we || [], U + 1, 2 * Q + 1, 2 * nt + 1)
            }
          }
          getTile(q, U, Q) {
            q = +q, U = +U, Q = +Q;
            const nt = this.options,
              {
                extent: _t,
                debug: Tt
              } = nt;
            if (q < 0 || q > 24) return null;
            const Ft = 1 << q,
              zt = jr(q, U = U + Ft & Ft - 1, Q);
            if (this.tiles[zt]) return de(this.tiles[zt], _t);
            Tt > 1 && console.log("drilling down to z%d-%d-%d", q, U, Q);
            let Nt, ie = q,
              mt = U,
              et = Q;
            for (; !Nt && ie > 0;) ie--, mt >>= 1, et >>= 1, Nt = this.tiles[jr(ie, mt, et)];
            return Nt && Nt.source ? (Tt > 1 && (console.log("found parent tile z%d-%d-%d", ie, mt, et), console.time("drilling down")), this.splitTile(Nt.source, ie, mt, et, q, U, Q), Tt > 1 && console.timeEnd("drilling down"), this.tiles[zt] ? de(this.tiles[zt], _t) : null) : null
          }
        }

        function jr(ct, q, U) {
          return 32 * ((1 << ct) * U + q) + ct
        }
        class Lr extends tt {
          constructor(q, U, Q, nt = _n) {
            super(q, U, Q), this._dataUpdateable = new Map, this._createGeoJSONIndex = nt
          }
          loadVectorTile(q, U) {
            return k._(this, void 0, void 0, (function*() {
              const Q = q.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const nt = this._geoJSONIndex.getTile(Q.z, Q.x, Q.y);
              if (!nt) return null;
              const _t = new Dt(nt.features, {
                version: 2,
                extent: k.a3
              });
              let Tt = (function(Ft) {
                const zt = new k.cP;
                return (function(Nt, ie) {
                  for (const mt in Nt.layers) ie.writeMessage(3, St, Nt.layers[mt])
                })(Ft, zt), zt.finish()
              })(_t);
              return Tt.byteOffset === 0 && Tt.byteLength === Tt.buffer.byteLength || (Tt = new Uint8Array(Tt)), {
                vectorTile: _t,
                rawData: Tt.buffer
              }
            }))
          }
          loadData(q) {
            return k._(this, void 0, void 0, (function*() {
              var U;
              (U = this._pendingRequest) === null || U === void 0 || U.abort();
              const Q = !!(q && q.request && q.request.collectResourceTiming) && new k.cQ(q.request);
              this._pendingRequest = new AbortController;
              try {
                (!this._pendingData || q.request || q.data || q.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(q, this._pendingRequest));
                const nt = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(nt, q), this.loaded = {};
                const _t = {
                  data: nt
                };
                if (Q) {
                  const Tt = Q.finish();
                  Tt && (_t.resourceTiming = {}, _t.resourceTiming[q.source] = JSON.parse(JSON.stringify(Tt)))
                }
                return _t
              } catch (nt) {
                if (delete this._pendingRequest, k.cB(nt)) return {
                  abandoned: !0
                };
                throw nt
              }
            }))
          }
          getData() {
            return k._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(q) {
            const U = this.loaded;
            return U && U[q.uid] ? super.reloadTile(q) : this.loadTile(q)
          }
          loadAndProcessGeoJSON(q, U) {
            return k._(this, void 0, void 0, (function*() {
              let Q = yield this.loadGeoJSON(q, U);
              if (delete this._pendingRequest, typeof Q != "object") throw new Error(`Input data given to '${q.source}' is not a valid GeoJSON object.`);
              if (yt(Q, !0), q.filter) {
                const nt = k.cW(q.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (nt.result === "error") throw new Error(nt.value.map((Tt => `${Tt.key}: ${Tt.message}`)).join(", "));
                Q = {
                  type: "FeatureCollection",
                  features: Q.features.filter((Tt => nt.value.evaluate({
                    zoom: 0
                  }, Tt)))
                }
              }
              return Q
            }))
          }
          loadGeoJSON(q, U) {
            return k._(this, void 0, void 0, (function*() {
              const {
                promoteId: Q
              } = q;
              if (q.request) {
                const nt = yield k.j(q.request, U);
                return this._dataUpdateable = k.cY(nt.data, Q) ? k.cX(nt.data, Q) : void 0, nt.data
              }
              if (typeof q.data == "string") try {
                const nt = JSON.parse(q.data);
                return this._dataUpdateable = k.cY(nt, Q) ? k.cX(nt, Q) : void 0, nt
              } catch {
                throw new Error(`Input data given to '${q.source}' is not a valid GeoJSON object.`)
              }
              if (!q.dataDiff) throw new Error(`Input data given to '${q.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${q.source}`);
              return k.cZ(this._dataUpdateable, q.dataDiff, Q), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(q) {
            return k._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(q) {
            return this._geoJSONIndex.getClusterExpansionZoom(q.clusterId)
          }
          getClusterChildren(q) {
            return this._geoJSONIndex.getChildren(q.clusterId)
          }
          getClusterLeaves(q) {
            return this._geoJSONIndex.getLeaves(q.clusterId, q.limit, q.offset)
          }
        }

        function _n(ct, q) {
          return q.cluster ? new Ut((function({
            superclusterOptions: U,
            clusterProperties: Q
          }) {
            if (!Q || !U) return U;
            const nt = {},
              _t = {},
              Tt = {
                accumulated: null,
                zoom: 0
              },
              Ft = {
                properties: null
              },
              zt = Object.keys(Q);
            for (const Nt of zt) {
              const [ie, mt] = Q[Nt], et = k.cW(mt), W = k.cW(typeof ie == "string" ? [ie, ["accumulated"],
                ["get", Nt]
              ] : ie);
              nt[Nt] = et.value, _t[Nt] = W.value
            }
            return U.map = Nt => {
              Ft.properties = Nt;
              const ie = {};
              for (const mt of zt) ie[mt] = nt[mt].evaluate(Tt, Ft);
              return ie
            }, U.reduce = (Nt, ie) => {
              Ft.properties = ie;
              for (const mt of zt) Tt.accumulated = Nt[mt], Nt[mt] = _t[mt].evaluate(Tt, Ft)
            }, U
          })(q)).load(ct.features) : (function(U, Q) {
            return new Or(U, Q)
          })(ct, q.geojsonVtOptions)
        }
        class dr {
          constructor(q) {
            this.self = q, this.actor = new k.K(q), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (U, Q) => {
              if (this.externalWorkerSourceTypes[U]) throw new Error(`Worker source with name "${U}" already registered.`);
              this.externalWorkerSourceTypes[U] = Q
            }, this.self.addProtocol = k.cD, this.self.removeProtocol = k.cE, this.self.registerRTLTextPlugin = U => {
              k.c_.setMethods(U)
            }, this.actor.registerMessageHandler("LDT", ((U, Q) => this._getDEMWorkerSource(U, Q.source).loadTile(Q))), this.actor.registerMessageHandler("RDT", ((U, Q) => k._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(U, Q.source).removeTile(Q)
            })))), this.actor.registerMessageHandler("GCEZ", ((U, Q) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Q.type, Q.source).getClusterExpansionZoom(Q)
            })))), this.actor.registerMessageHandler("GCC", ((U, Q) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Q.type, Q.source).getClusterChildren(Q)
            })))), this.actor.registerMessageHandler("GCL", ((U, Q) => k._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, Q.type, Q.source).getClusterLeaves(Q)
            })))), this.actor.registerMessageHandler("LD", ((U, Q) => this._getWorkerSource(U, Q.type, Q.source).loadData(Q))), this.actor.registerMessageHandler("GD", ((U, Q) => this._getWorkerSource(U, Q.type, Q.source).getData())), this.actor.registerMessageHandler("LT", ((U, Q) => this._getWorkerSource(U, Q.type, Q.source).loadTile(Q))), this.actor.registerMessageHandler("RT", ((U, Q) => this._getWorkerSource(U, Q.type, Q.source).reloadTile(Q))), this.actor.registerMessageHandler("AT", ((U, Q) => this._getWorkerSource(U, Q.type, Q.source).abortTile(Q))), this.actor.registerMessageHandler("RMT", ((U, Q) => this._getWorkerSource(U, Q.type, Q.source).removeTile(Q))), this.actor.registerMessageHandler("RS", ((U, Q) => k._(this, void 0, void 0, (function*() {
              if (!this.workerSources[U] || !this.workerSources[U][Q.type] || !this.workerSources[U][Q.type][Q.source]) return;
              const nt = this.workerSources[U][Q.type][Q.source];
              delete this.workerSources[U][Q.type][Q.source], nt.removeSource !== void 0 && nt.removeSource(Q)
            })))), this.actor.registerMessageHandler("RM", (U => k._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[U], delete this.availableImages[U], delete this.workerSources[U], delete this.demWorkerSources[U], this.globalStates.delete(U)
            })))), this.actor.registerMessageHandler("SR", ((U, Q) => k._(this, void 0, void 0, (function*() {
              this.referrer = Q
            })))), this.actor.registerMessageHandler("SRPS", ((U, Q) => this._syncRTLPluginState(U, Q))), this.actor.registerMessageHandler("IS", ((U, Q) => k._(this, void 0, void 0, (function*() {
              this.self.importScripts(Q)
            })))), this.actor.registerMessageHandler("SI", ((U, Q) => this._setImages(U, Q))), this.actor.registerMessageHandler("UL", ((U, Q) => k._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).update(Q.layers, Q.removedIds, this._getGlobalState(U))
            })))), this.actor.registerMessageHandler("UGS", ((U, Q) => k._(this, void 0, void 0, (function*() {
              const nt = this._getGlobalState(U);
              for (const _t in Q) nt[_t] = Q[_t]
            })))), this.actor.registerMessageHandler("SL", ((U, Q) => k._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).replace(Q, this._getGlobalState(U))
            }))))
          }
          _getGlobalState(q) {
            let U = this.globalStates.get(q);
            return U || (U = {}, this.globalStates.set(q, U)), U
          }
          _setImages(q, U) {
            return k._(this, void 0, void 0, (function*() {
              this.availableImages[q] = U;
              for (const Q in this.workerSources[q]) {
                const nt = this.workerSources[q][Q];
                for (const _t in nt) nt[_t].availableImages = U
              }
            }))
          }
          _syncRTLPluginState(q, U) {
            return k._(this, void 0, void 0, (function*() {
              return yield k.c_.syncState(U, this.self.importScripts)
            }))
          }
          _getAvailableImages(q) {
            let U = this.availableImages[q];
            return U || (U = []), U
          }
          _getLayerIndex(q) {
            let U = this.layerIndexes[q];
            return U || (U = this.layerIndexes[q] = new c), U
          }
          _getWorkerSource(q, U, Q) {
            if (this.workerSources[q] || (this.workerSources[q] = {}), this.workerSources[q][U] || (this.workerSources[q][U] = {}), !this.workerSources[q][U][Q]) {
              const nt = {
                sendAsync: (_t, Tt) => (_t.targetMapId = q, this.actor.sendAsync(_t, Tt))
              };
              switch (U) {
                case "vector":
                  this.workerSources[q][U][Q] = new tt(nt, this._getLayerIndex(q), this._getAvailableImages(q));
                  break;
                case "geojson":
                  this.workerSources[q][U][Q] = new Lr(nt, this._getLayerIndex(q), this._getAvailableImages(q));
                  break;
                default:
                  this.workerSources[q][U][Q] = new this.externalWorkerSourceTypes[U](nt, this._getLayerIndex(q), this._getAvailableImages(q))
              }
            }
            return this.workerSources[q][U][Q]
          }
          _getDEMWorkerSource(q, U) {
            return this.demWorkerSources[q] || (this.demWorkerSources[q] = {}), this.demWorkerSources[q][U] || (this.demWorkerSources[q][U] = new ut), this.demWorkerSources[q][U]
          }
        }
        return k.i(self) && (self.worker = new dr(self)), dr
      })), z("index", ["exports", "./shared"], (function(k, c) {
        var R = "5.11.0";

        function X() {
          var d = new c.A(4);
          return c.A != Float32Array && (d[1] = 0, d[2] = 0), d[0] = 1, d[3] = 1, d
        }
        let $, tt;
        const ut = {
            frame(d, e, o) {
              const u = requestAnimationFrame((p => {
                  h(), e(p)
                })),
                {
                  unsubscribe: h
                } = c.s(d.signal, "abort", (() => {
                  h(), cancelAnimationFrame(u), o(c.c())
                }), !1)
            },
            frameAsync(d) {
              return new Promise(((e, o) => {
                this.frame(d, e, o)
              }))
            },
            getImageData(d, e = 0) {
              return this.getImageCanvasContext(d).getImageData(-e, -e, d.width + 2 * e, d.height + 2 * e)
            },
            getImageCanvasContext(d) {
              const e = window.document.createElement("canvas"),
                o = e.getContext("2d", {
                  willReadFrequently: !0
                });
              if (!o) throw new Error("failed to create canvas 2d context");
              return e.width = d.width, e.height = d.height, o.drawImage(d, 0, 0, d.width, d.height), o
            },
            resolveURL: d => ($ || ($ = document.createElement("a")), $.href = d, $.href),
            hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && (tt == null && (tt = matchMedia("(prefers-reduced-motion: reduce)")), tt.matches)
            }
          },
          xt = new class {
            constructor() {
              this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null
            }
            getCurrentTime() {
              return this._frozenAt !== null ? this._frozenAt : this._realTime()
            }
            setNow(d) {
              this._frozenAt = d
            }
            restoreNow() {
              this._frozenAt = null
            }
            isFrozen() {
              return this._frozenAt !== null
            }
          };

        function lt() {
          return xt.getCurrentTime()
        }
        class G {
          static testProp(e) {
            if (!G.docStyle) return e[0];
            for (let o = 0; o < e.length; o++)
              if (e[o] in G.docStyle) return e[o];
            return e[0]
          }
          static create(e, o, u) {
            const h = window.document.createElement(e);
            return o !== void 0 && (h.className = o), u && u.appendChild(h), h
          }
          static createNS(e, o) {
            return window.document.createElementNS(e, o)
          }
          static disableDrag() {
            G.docStyle && G.selectProp && (G.userSelect = G.docStyle[G.selectProp], G.docStyle[G.selectProp] = "none")
          }
          static enableDrag() {
            G.docStyle && G.selectProp && (G.docStyle[G.selectProp] = G.userSelect)
          }
          static setTransform(e, o) {
            e.style[G.transformProp] = o
          }
          static addEventListener(e, o, u, h = {}) {
            e.addEventListener(o, u, "passive" in h ? h : h.capture)
          }
          static removeEventListener(e, o, u, h = {}) {
            e.removeEventListener(o, u, "passive" in h ? h : h.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", G.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", G.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", G.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const o = e.getBoundingClientRect();
            return {
              x: o.width / e.offsetWidth || 1,
              y: o.height / e.offsetHeight || 1,
              boundingClientRect: o
            }
          }
          static getPoint(e, o, u) {
            const h = o.boundingClientRect;
            return new c.P((u.clientX - h.left) / o.x - e.clientLeft, (u.clientY - h.top) / o.y - e.clientTop)
          }
          static mousePos(e, o) {
            const u = G.getScale(e);
            return G.getPoint(e, u, o)
          }
          static touchPos(e, o) {
            const u = [],
              h = G.getScale(e);
            for (let p = 0; p < o.length; p++) u.push(G.getPoint(e, h, o[p]));
            return u
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const o = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              u = o.querySelectorAll("script");
            for (const h of u) h.remove();
            return G.clean(o), o.innerHTML
          }
          static isPossiblyDangerous(e, o) {
            const u = o.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !u.includes("javascript:") && !u.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const o = e.children;
            for (const u of o) G.removeAttributes(u), G.clean(u)
          }
          static removeAttributes(e) {
            for (const {
                name: o,
                value: u
              }
              of e.attributes) G.isPossiblyDangerous(o, u) && e.removeAttribute(o)
          }
        }
        G.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, G.selectProp = G.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), G.transformProp = G.testProp(["transform", "WebkitTransform"]);
        const yt = {
          supported: !1,
          testSupport: function(d) {
            !St && Dt && (qt ? Vt(d) : Lt = d)
          }
        };
        let Lt, Dt, St = !1,
          qt = !1;

        function Vt(d) {
          const e = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, e);
          try {
            if (d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, d.RGBA, d.UNSIGNED_BYTE, Dt), d.isContextLost()) return;
            yt.supported = !0
          } catch {}
          d.deleteTexture(e), St = !0
        }
        var Zt;
        typeof document < "u" && (Dt = document.createElement("img"), Dt.onload = () => {
          Lt && Vt(Lt), Lt = null, qt = !0
        }, Dt.onerror = () => {
          St = !0, Lt = null
        }, Dt.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(d) {
          let e, o, u, h;
          d.resetRequestQueue = () => {
            e = [], o = 0, u = 0, h = {}
          }, d.addThrottleControl = T => {
            const I = u++;
            return h[I] = T, I
          }, d.removeThrottleControl = T => {
            delete h[T], g()
          }, d.getImage = (T, I, A = !0) => new Promise(((F, L) => {
            yt.supported && (T.headers || (T.headers = {}), T.headers.accept = "image/webp,*/*"), c.e(T, {
              type: "image"
            }), e.push({
              abortController: I,
              requestParameters: T,
              supportImageRefresh: A,
              state: "queued",
              onError: V => {
                L(V)
              },
              onSuccess: V => {
                F(V)
              }
            }), g()
          }));
          const p = T => c._(this, void 0, void 0, (function*() {
              T.state = "running";
              const {
                requestParameters: I,
                supportImageRefresh: A,
                onError: F,
                onSuccess: L,
                abortController: V
              } = T, K = A === !1 && !c.i(self) && !c.g(I.url) && (!I.headers || Object.keys(I.headers).reduce(((st, pt) => st && pt === "accept"), !0));
              o++;
              const it = K ? x(I, V) : c.m(I, V);
              try {
                const st = yield it;
                delete T.abortController, T.state = "completed", st.data instanceof HTMLImageElement || c.b(st.data) ? L(st) : st.data && L({
                  data: yield(ot = st.data, typeof createImageBitmap == "function" ? c.f(ot) : c.h(ot)),
                  cacheControl: st.cacheControl,
                  expires: st.expires
                })
              } catch (st) {
                delete T.abortController, F(st)
              } finally {
                o--, g()
              }
              var ot
            })),
            g = () => {
              const T = (() => {
                for (const I of Object.keys(h))
                  if (h[I]()) return !0;
                return !1
              })() ? c.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let I = o; I < T && e.length > 0; I++) {
                const A = e.shift();
                A.abortController.signal.aborted ? I-- : p(A)
              }
            },
            x = (T, I) => new Promise(((A, F) => {
              const L = new Image,
                V = T.url,
                K = T.credentials;
              K && K === "include" ? L.crossOrigin = "use-credentials" : (K && K === "same-origin" || !c.d(V)) && (L.crossOrigin = "anonymous"), I.signal.addEventListener("abort", (() => {
                L.src = "", F(c.c())
              })), L.fetchPriority = "high", L.onload = () => {
                L.onerror = L.onload = null, A({
                  data: L
                })
              }, L.onerror = () => {
                L.onerror = L.onload = null, I.signal.aborted || F(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, L.src = V
            }))
        })(Zt || (Zt = {})), Zt.resetRequestQueue();
        class Et {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, o) {
            return this._transformRequestFn && this._transformRequestFn(e, o) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function Ct(d) {
          const e = [];
          if (typeof d == "string") e.push({
            id: "default",
            url: d
          });
          else if (d && d.length > 0) {
            const o = [];
            for (const {
                id: u,
                url: h
              }
              of d) {
              const p = `${u}${h}`;
              o.indexOf(p) === -1 && (o.push(p), e.push({
                id: u,
                url: h
              }))
            }
          }
          return e
        }

        function Wt(d, e, o) {
          try {
            const u = new URL(d);
            return u.pathname += `${e}${o}`, u.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${d}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function jt(d) {
          const {
            userImage: e
          } = d;
          return !!(e && e.render && e.render()) && (d.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class Ht extends c.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: o,
                  promiseResolve: u
                }
                of this.requestors) u(this._getImagesForIds(o));
              this.requestors = []
            }
          }
          getImage(e) {
            const o = this.images[e];
            if (o && !o.data && o.spriteData) {
              const u = o.spriteData;
              o.data = new c.R({
                width: u.width,
                height: u.height
              }, u.context.getImageData(u.x, u.y, u.width, u.height).data), o.spriteData = null
            }
            return o
          }
          addImage(e, o) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, o) && (this.images[e] = o)
          }
          _validate(e, o) {
            let u = !0;
            const h = o.data || o.spriteData;
            return this._validateStretch(o.stretchX, h && h.width) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchX" value`))), u = !1), this._validateStretch(o.stretchY, h && h.height) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchY" value`))), u = !1), this._validateContent(o.content, o) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "content" value`))), u = !1), u
          }
          _validateStretch(e, o) {
            if (!e) return !0;
            let u = 0;
            for (const h of e) {
              if (h[0] < u || h[1] < h[0] || o < h[1]) return !1;
              u = h[1]
            }
            return !0
          }
          _validateContent(e, o) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const u = o.spriteData,
              h = u && u.width || o.data.width,
              p = u && u.height || o.data.height;
            return !(e[0] < 0 || h < e[0] || e[1] < 0 || p < e[1] || e[2] < 0 || h < e[2] || e[3] < 0 || p < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, o, u = !0) {
            const h = this.getImage(e);
            if (u && (h.data.width !== o.data.width || h.data.height !== o.data.height)) throw new Error(`size mismatch between old image (${h.data.width}x${h.data.height}) and new image (${o.data.width}x${o.data.height}).`);
            o.version = h.version + 1, this.images[e] = o, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const o = this.images[e];
            delete this.images[e], delete this.patterns[e], o.userImage && o.userImage.onRemove && o.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((o, u) => {
              let h = !0;
              if (!this.isLoaded())
                for (const p of e) this.images[p] || (h = !1);
              this.isLoaded() || h ? o(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: o
              })
            }))
          }
          _getImagesForIds(e) {
            const o = {};
            for (const u of e) {
              let h = this.getImage(u);
              h || (this.fire(new c.l("styleimagemissing", {
                id: u
              })), h = this.getImage(u)), h ? o[u] = {
                data: h.data.clone(),
                pixelRatio: h.pixelRatio,
                sdf: h.sdf,
                version: h.version,
                stretchX: h.stretchX,
                stretchY: h.stretchY,
                content: h.content,
                textFitWidth: h.textFitWidth,
                textFitHeight: h.textFitHeight,
                hasRenderCallback: !!(h.userImage && h.userImage.render)
              } : c.w(`Image "${u}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return o
          }
          getPixelSize() {
            const {
              width: e,
              height: o
            } = this.atlasImage;
            return {
              width: e,
              height: o
            }
          }
          getPattern(e) {
            const o = this.patterns[e],
              u = this.getImage(e);
            if (!u) return null;
            if (o && o.position.version === u.version) return o.position;
            if (o) o.position.version = u.version;
            else {
              const h = {
                  w: u.data.width + 2,
                  h: u.data.height + 2,
                  x: 0,
                  y: 0
                },
                p = new c.I(h, u);
              this.patterns[e] = {
                bin: h,
                position: p
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const o = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new c.T(e, this.atlasImage, o.RGBA), this.atlasTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const p in this.patterns) e.push(this.patterns[p].bin);
            const {
              w: o,
              h: u
            } = c.p(e), h = this.atlasImage;
            h.resize({
              width: o || 1,
              height: u || 1
            });
            for (const p in this.patterns) {
              const {
                bin: g
              } = this.patterns[p], x = g.x + 1, T = g.y + 1, I = this.getImage(p).data, A = I.width, F = I.height;
              c.R.copy(I, h, {
                x: 0,
                y: 0
              }, {
                x,
                y: T
              }, {
                width: A,
                height: F
              }), c.R.copy(I, h, {
                x: 0,
                y: F - 1
              }, {
                x,
                y: T - 1
              }, {
                width: A,
                height: 1
              }), c.R.copy(I, h, {
                x: 0,
                y: 0
              }, {
                x,
                y: T + F
              }, {
                width: A,
                height: 1
              }), c.R.copy(I, h, {
                x: A - 1,
                y: 0
              }, {
                x: x - 1,
                y: T
              }, {
                width: 1,
                height: F
              }), c.R.copy(I, h, {
                x: 0,
                y: 0
              }, {
                x: x + A,
                y: T
              }, {
                width: 1,
                height: F
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const o of e) {
              if (this.callbackDispatchedThisFrame[o]) continue;
              this.callbackDispatchedThisFrame[o] = !0;
              const u = this.getImage(o);
              u || c.w(`Image with ID: "${o}" was not found`), jt(u) && this.updateImage(o, u)
            }
          }
        }
        const _e = 1e20;

        function Ut(d, e, o, u, h, p, g, x, T) {
          for (let I = e; I < e + u; I++) Xt(d, o * p + I, p, h, g, x, T);
          for (let I = o; I < o + h; I++) Xt(d, I * p + e, 1, u, g, x, T)
        }

        function Xt(d, e, o, u, h, p, g) {
          p[0] = 0, g[0] = -_e, g[1] = _e, h[0] = d[e];
          for (let x = 1, T = 0, I = 0; x < u; x++) {
            h[x] = d[e + x * o];
            const A = x * x;
            do {
              const F = p[T];
              I = (h[x] - h[F] + A - F * F) / (x - F) / 2
            } while (I <= g[T] && --T > -1);
            T++, p[T] = x, g[T] = I, g[T + 1] = _e
          }
          for (let x = 0, T = 0; x < u; x++) {
            for (; g[T + 1] < x;) T++;
            const I = p[T],
              A = x - I;
            d[e + x * o] = h[I] + A * A
          }
        }
        const me = c.v.layout_symbol["text-font"].default.join(",");
        class Ce {
          constructor(e, o, u) {
            this.requestManager = e, this.localIdeographFontFamily = o, this.entries = {}, this.lang = u
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return c._(this, void 0, void 0, (function*() {
              const o = [];
              for (const p in e)
                for (const g of e[p]) o.push(this._getAndCacheGlyphsPromise(p, g));
              const u = yield Promise.all(o), h = {};
              for (const {
                  stack: p,
                  id: g,
                  glyph: x
                }
                of u) h[p] || (h[p] = {}), h[p][g] = x && {
                id: x.id,
                bitmap: x.bitmap.clone(),
                metrics: x.metrics
              };
              return h
            }))
          }
          _getAndCacheGlyphsPromise(e, o) {
            return c._(this, void 0, void 0, (function*() {
              let u = this.entries[e];
              u || (u = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let h = u.glyphs[o];
              return h !== void 0 ? {
                stack: e,
                id: o,
                glyph: h
              } : !this.url || this._charUsesLocalIdeographFontFamily(o) ? (h = u.glyphs[o] = this._drawGlyph(u, e, o), {
                stack: e,
                id: o,
                glyph: h
              }) : yield this._downloadAndCacheRangePromise(e, o)
            }))
          }
          _downloadAndCacheRangePromise(e, o) {
            return c._(this, void 0, void 0, (function*() {
              const u = Math.floor(o / 256);
              if (256 * u > 65535) throw new Error("glyphs > 65535 not supported");
              const h = this.entries[e];
              if (h.ranges[u]) return {
                stack: e,
                id: o,
                glyph: null
              };
              if (!h.requests[u]) {
                const p = Ce.loadGlyphRange(e, u, this.url, this.requestManager);
                h.requests[u] = p
              }
              try {
                const p = yield h.requests[u];
                for (const g in p) h.glyphs[+g] = p[+g];
                return h.ranges[u] = !0, {
                  stack: e,
                  id: o,
                  glyph: p[o] || null
                }
              } catch (p) {
                const g = h.glyphs[o] = this._drawGlyph(h, e, o);
                return this._warnOnMissingGlyphRange(g, u, o, p), {
                  stack: e,
                  id: o,
                  glyph: g
                }
              }
            }))
          }
          _warnOnMissingGlyphRange(e, o, u, h) {
            const p = 256 * o,
              g = p + 255,
              x = u.toString(16).padStart(4, "0").toUpperCase();
            c.w(`Unable to load glyph range ${o}, ${p}-${g}. Rendering codepoint U+${x} locally instead. ${h}`)
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || c.u["CJK Unified Ideographs"](e) || c.u["Hangul Syllables"](e) || c.u.Hiragana(e) || c.u.Katakana(e) || c.u["CJK Symbols and Punctuation"](e) || c.u["Halfwidth and Fullwidth Forms"](e))
          }
          _drawGlyph(e, o, u) {
            const h = o === me && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(u),
              p = h ? "ideographTinySDF" : "tinySDF";
            e[p] || (e[p] = this._createTinySDF(h ? this.localIdeographFontFamily : o));
            const g = e[p].draw(String.fromCharCode(u));
            return {
              id: u,
              bitmap: new c.q({
                width: g.width || 60,
                height: g.height || 60
              }, g.data),
              metrics: {
                width: g.glyphWidth / 2 || 24,
                height: g.glyphHeight / 2 || 24,
                left: g.glyphLeft / 2 + .5 || 0,
                top: g.glyphTop / 2 - 27.5 || -8,
                advance: g.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
          _createTinySDF(e) {
            const o = e ? e.split(",") : [];
            o.push("sans-serif");
            const u = o.map((h => /[-\w]+/.test(h) ? h : `'${CSS.escape(h)}'`)).join(",");
            return new Ce.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: .25,
              fontFamily: u,
              fontWeight: this._fontWeight(o[0]),
              fontStyle: this._fontStyle(o[0]),
              lang: this.lang
            })
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal"
          }
          _fontWeight(e) {
            const o = {
              thin: 100,
              hairline: 100,
              "extra light": 200,
              "ultra light": 200,
              light: 300,
              normal: 400,
              regular: 400,
              medium: 500,
              semibold: 600,
              demibold: 600,
              bold: 700,
              "extra bold": 800,
              "ultra bold": 800,
              black: 900,
              heavy: 900,
              "extra black": 950,
              "ultra black": 950
            };
            let u;
            for (const [h, p] of Object.entries(o)) new RegExp(`\\b${h}\\b`, "i").test(e) && (u = `${p}`);
            return u
          }
        }
        Ce.loadGlyphRange = function(d, e, o, u) {
          return c._(this, void 0, void 0, (function*() {
            const h = 256 * e,
              p = h + 255,
              g = u.transformRequest(o.replace("{fontstack}", d).replace("{range}", `${h}-${p}`), "Glyphs"),
              x = yield c.n(g, new AbortController);
            if (!x || !x.data) throw new Error(`Could not load glyph range. range: ${e}, ${h}-${p}`);
            const T = {};
            for (const I of c.o(x.data)) T[I.id] = I;
            return T
          }))
        }, Ce.TinySDF = class {
          constructor({
            fontSize: d = 24,
            buffer: e = 3,
            radius: o = 8,
            cutoff: u = .25,
            fontFamily: h = "sans-serif",
            fontWeight: p = "normal",
            fontStyle: g = "normal",
            lang: x = null
          } = {}) {
            this.buffer = e, this.cutoff = u, this.radius = o, this.lang = x;
            const T = this.size = d + 4 * e,
              I = this._createCanvas(T),
              A = this.ctx = I.getContext("2d", {
                willReadFrequently: !0
              });
            A.font = `${g} ${p} ${d}px ${h}`, A.textBaseline = "alphabetic", A.textAlign = "left", A.fillStyle = "black", this.gridOuter = new Float64Array(T * T), this.gridInner = new Float64Array(T * T), this.f = new Float64Array(T), this.z = new Float64Array(T + 1), this.v = new Uint16Array(T)
          }
          _createCanvas(d) {
            const e = document.createElement("canvas");
            return e.width = e.height = d, e
          }
          draw(d) {
            const {
              width: e,
              actualBoundingBoxAscent: o,
              actualBoundingBoxDescent: u,
              actualBoundingBoxLeft: h,
              actualBoundingBoxRight: p
            } = this.ctx.measureText(d), g = Math.ceil(o), x = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(p - h))), T = Math.min(this.size - this.buffer, g + Math.ceil(u)), I = x + 2 * this.buffer, A = T + 2 * this.buffer, F = Math.max(I * A, 0), L = new Uint8ClampedArray(F), V = {
              data: L,
              width: I,
              height: A,
              glyphWidth: x,
              glyphHeight: T,
              glyphTop: g,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (x === 0 || T === 0) return V;
            const {
              ctx: K,
              buffer: it,
              gridInner: ot,
              gridOuter: st
            } = this;
            this.lang && (K.lang = this.lang), K.clearRect(it, it, x, T), K.fillText(d, it, it + g);
            const pt = K.getImageData(it, it, x, T);
            st.fill(_e, 0, F), ot.fill(0, 0, F);
            for (let wt = 0; wt < T; wt++)
              for (let dt = 0; dt < x; dt++) {
                const kt = pt.data[4 * (wt * x + dt) + 3] / 255;
                if (kt === 0) continue;
                const It = (wt + it) * I + dt + it;
                if (kt === 1) st[It] = 0, ot[It] = _e;
                else {
                  const gt = .5 - kt;
                  st[It] = gt > 0 ? gt * gt : 0, ot[It] = gt < 0 ? gt * gt : 0
                }
              }
            Ut(st, 0, 0, I, A, I, this.f, this.v, this.z), Ut(ot, it, it, x, T, I, this.f, this.v, this.z);
            for (let wt = 0; wt < F; wt++) {
              const dt = Math.sqrt(st[wt]) - Math.sqrt(ot[wt]);
              L[wt] = Math.round(255 - 255 * (dt / this.radius + this.cutoff))
            }
            return V
          }
        };
        class Ve {
          constructor() {
            this.specification = c.t.light.position
          }
          possiblyEvaluate(e, o) {
            return c.C(e.expression.evaluate(o))
          }
          interpolate(e, o, u) {
            return {
              x: c.F.number(e.x, o.x, u),
              y: c.F.number(e.y, o.y, u),
              z: c.F.number(e.z, o.z, u)
            }
          }
        }
        let Ie;
        class ne extends c.E {
          constructor(e) {
            super(), Ie = Ie || new c.r({
              anchor: new c.D(c.t.light.anchor),
              position: new Ve,
              color: new c.D(c.t.light.color),
              intensity: new c.D(c.t.light.intensity)
            }), this._transitionable = new c.x(Ie, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, o = {}) {
            if (!this._validate(c.y, e, o))
              for (const u in e) {
                const h = e[u];
                u.endsWith("-transition") ? this._transitionable.setTransition(u.slice(0, -11), h) : this._transitionable.setValue(u, h)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, o, u) {
            return (!u || u.validate !== !1) && c.z(this, e.call(c.B, {
              value: o,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: c.t
            }))
          }
        }
        const Xe = new c.r({
          "sky-color": new c.D(c.t.sky["sky-color"]),
          "horizon-color": new c.D(c.t.sky["horizon-color"]),
          "fog-color": new c.D(c.t.sky["fog-color"]),
          "fog-ground-blend": new c.D(c.t.sky["fog-ground-blend"]),
          "horizon-fog-blend": new c.D(c.t.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new c.D(c.t.sky["sky-horizon-blend"]),
          "atmosphere-blend": new c.D(c.t.sky["atmosphere-blend"])
        });
        class pe extends c.E {
          constructor(e) {
            super(), this._transitionable = new c.x(Xe, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.G(0))
          }
          setSky(e, o = {}) {
            if (!this._validate(c.H, e, o)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const u in e) {
                const h = e[u];
                u.endsWith("-transition") ? this._transitionable.setTransition(u.slice(0, -11), h) : this._transitionable.setValue(u, h)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, o, u = {}) {
            return (u == null ? void 0 : u.validate) !== !1 && c.z(this, e.call(c.B, c.e({
              value: o,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: c.t
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class Ue {
          constructor(e, o) {
            this.width = e, this.height = o, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, o) {
            const u = e.join(",") + String(o);
            return this.dashEntry[u] || (this.dashEntry[u] = this.addDash(e, o)), this.dashEntry[u]
          }
          getDashRanges(e, o, u) {
            const h = [];
            let p = e.length % 2 == 1 ? -e[e.length - 1] * u : 0,
              g = e[0] * u,
              x = !0;
            h.push({
              left: p,
              right: g,
              isDash: x,
              zeroLength: e[0] === 0
            });
            let T = e[0];
            for (let I = 1; I < e.length; I++) {
              x = !x;
              const A = e[I];
              p = T * u, T += A, g = T * u, h.push({
                left: p,
                right: g,
                isDash: x,
                zeroLength: A === 0
              })
            }
            return h
          }
          addRoundDash(e, o, u) {
            const h = o / 2;
            for (let p = -u; p <= u; p++) {
              const g = this.width * (this.nextRow + u + p);
              let x = 0,
                T = e[x];
              for (let I = 0; I < this.width; I++) {
                I / T.right > 1 && (T = e[++x]);
                const A = Math.abs(I - T.left),
                  F = Math.abs(I - T.right),
                  L = Math.min(A, F);
                let V;
                const K = p / u * (h + 1);
                if (T.isDash) {
                  const it = h - Math.abs(K);
                  V = Math.sqrt(L * L + it * it)
                } else V = h - Math.sqrt(L * L + K * K);
                this.data[g + I] = Math.max(0, Math.min(255, V + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let x = e.length - 1; x >= 0; --x) {
              const T = e[x],
                I = e[x + 1];
              T.zeroLength ? e.splice(x, 1) : I && I.isDash === T.isDash && (I.left = T.left, e.splice(x, 1))
            }
            const o = e[0],
              u = e[e.length - 1];
            o.isDash === u.isDash && (o.left = u.left - this.width, u.right = o.right + this.width);
            const h = this.width * this.nextRow;
            let p = 0,
              g = e[p];
            for (let x = 0; x < this.width; x++) {
              x / g.right > 1 && (g = e[++p]);
              const T = Math.abs(x - g.left),
                I = Math.abs(x - g.right),
                A = Math.min(T, I);
              this.data[h + x] = Math.max(0, Math.min(255, (g.isDash ? A : -A) + 128))
            }
          }
          addDash(e, o) {
            const u = o ? 7 : 0,
              h = 2 * u + 1;
            if (this.nextRow + h > this.height) return c.w("LineAtlas out of space"), null;
            let p = 0;
            for (let x = 0; x < e.length; x++) p += e[x];
            if (p !== 0) {
              const x = this.width / p,
                T = this.getDashRanges(e, this.width, x);
              o ? this.addRoundDash(T, x, u) : this.addRegularDash(T)
            }
            const g = {
              y: this.nextRow + u,
              height: 2 * u,
              width: p
            };
            return this.nextRow += h, this.dirty = !0, g
          }
          bind(e) {
            const o = e.gl;
            this.texture ? (o.bindTexture(o.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, this.width, this.height, o.ALPHA, o.UNSIGNED_BYTE, this.data))) : (this.texture = o.createTexture(), o.bindTexture(o.TEXTURE_2D, this.texture), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.REPEAT), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.REPEAT), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), o.texImage2D(o.TEXTURE_2D, 0, o.ALPHA, this.width, this.height, 0, o.ALPHA, o.UNSIGNED_BYTE, this.data))
          }
        }
        const Ae = "maplibre_preloaded_worker_pool";
        class He {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < He.workerCount;) this.workers.push(new Worker(c.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((o => {
              o.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[Ae]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const Tr = Math.floor(ut.hardwareConcurrency / 2);
        let Ye, mr;

        function se() {
          return Ye || (Ye = new He), Ye
        }
        He.workerCount = c.J(globalThis) ? Math.max(Math.min(Tr, 3), 1) : 1;
        class ce {
          constructor(e, o) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = o;
            const u = this.workerPool.acquire(o);
            for (let h = 0; h < u.length; h++) {
              const p = new c.K(u[h], o);
              p.name = `Worker ${h}`, this.actors.push(p)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, o) {
            const u = [];
            for (const h of this.actors) u.push(h.sendAsync({
              type: e,
              data: o
            }));
            return Promise.all(u)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((o => {
              o.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, o) {
            for (const u of this.actors) u.registerMessageHandler(e, o)
          }
        }

        function ur() {
          return mr || (mr = new ce(se(), c.L), mr.registerMessageHandler("GR", ((d, e, o) => c.m(e, o)))), mr
        }

        function Ke(d, e) {
          const o = c.M();
          return c.N(o, o, [1, 1, 0]), c.O(o, o, [.5 * d.width, .5 * d.height, 1]), d.calculatePosMatrix ? c.Q(o, o, d.calculatePosMatrix(e.toUnwrapped())) : o
        }

        function ve(d, e, o, u, h, p, g) {
          var x;
          const T = (function(L, V, K) {
              if (L)
                for (const it of L) {
                  const ot = V[it];
                  if (ot && ot.source === K && ot.type === "fill-extrusion") return !0
                } else
                  for (const it in V) {
                    const ot = V[it];
                    if (ot.source === K && ot.type === "fill-extrusion") return !0
                  }
              return !1
            })((x = h == null ? void 0 : h.layers) !== null && x !== void 0 ? x : null, e, d.id),
            I = p.maxPitchScaleFactor(),
            A = d.tilesIn(u, I, T);
          A.sort(_r);
          const F = [];
          for (const L of A) F.push({
            wrappedTileID: L.tileID.wrapped().key,
            queryResults: L.tile.queryRenderedFeatures(e, o, d.getState(), L.queryGeometry, L.cameraQueryGeometry, L.scale, h, p, I, Ke(p, L.tileID), g ? (V, K) => g(L.tileID, V, K) : void 0)
          });
          return (function(L, V) {
            for (const K in L)
              for (const it of L[K]) nr(it, V);
            return L
          })((function(L) {
            const V = {},
              K = {};
            for (const it of L) {
              const ot = it.queryResults,
                st = it.wrappedTileID,
                pt = K[st] = K[st] || {};
              for (const wt in ot) {
                const dt = ot[wt],
                  kt = pt[wt] = pt[wt] || {},
                  It = V[wt] = V[wt] || [];
                for (const gt of dt) kt[gt.featureIndex] || (kt[gt.featureIndex] = !0, It.push(gt))
              }
            }
            return V
          })(F), d)
        }

        function _r(d, e) {
          const o = d.tileID,
            u = e.tileID;
          return o.overscaledZ - u.overscaledZ || o.canonical.y - u.canonical.y || o.wrap - u.wrap || o.canonical.x - u.canonical.x
        }

        function nr(d, e) {
          const o = d.feature,
            u = e.getFeatureState(o.layer["source-layer"], o.id);
          o.source = o.layer.source, o.layer["source-layer"] && (o.sourceLayer = o.layer["source-layer"]), o.state = u
        }

        function gr(d, e, o) {
          return c._(this, void 0, void 0, (function*() {
            let u = d;
            if (d.url ? u = (yield c.j(e.transformRequest(d.url, "Source"), o)).data : yield ut.frameAsync(o), !u) return null;
            const h = c.S(c.e(u, d), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in u && u.vector_layers && (h.vectorLayerIds = u.vector_layers.map((p => p.id))), h
          }))
        }
        class ir {
          constructor(e, o) {
            e && (o ? this.setSouthWest(e).setNorthEast(o) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof c.U ? new c.U(e.lng, e.lat) : c.U.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof c.U ? new c.U(e.lng, e.lat) : c.U.convert(e), this
          }
          extend(e) {
            const o = this._sw,
              u = this._ne;
            let h, p;
            if (e instanceof c.U) h = e, p = e;
            else {
              if (!(e instanceof ir)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(ir.convert(e)) : this.extend(c.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(c.U.convert(e)) : this;
              if (h = e._sw, p = e._ne, !h || !p) return this
            }
            return o || u ? (o.lng = Math.min(h.lng, o.lng), o.lat = Math.min(h.lat, o.lat), u.lng = Math.max(p.lng, u.lng), u.lat = Math.max(p.lat, u.lat)) : (this._sw = new c.U(h.lng, h.lat), this._ne = new c.U(p.lng, p.lat)), this
          }
          getCenter() {
            return new c.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new c.U(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new c.U(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: o,
              lat: u
            } = c.U.convert(e);
            let h = this._sw.lng <= o && o <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (h = this._sw.lng >= o && o >= this._ne.lng), this._sw.lat <= u && u <= this._ne.lat && h
          }
          intersects(e) {
            if ((e = ir.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const o = c.V(this.getWest(), -180, 180),
              u = c.V(this.getEast(), -180, 180),
              h = c.V(e.getWest(), -180, 180),
              p = c.V(e.getEast(), -180, 180),
              g = o > u,
              x = h > p;
            return !(!g || !x) || (g ? p >= o || h <= u : x ? u >= h || o <= p : !(h > u || p < o))
          }
          static convert(e) {
            return e instanceof ir ? e : e && new ir(e)
          }
          static fromLngLat(e, o = 0) {
            const u = 360 * o / 40075017,
              h = u / Math.cos(Math.PI / 180 * e.lat);
            return new ir(new c.U(e.lng - h, e.lat - u), new c.U(e.lng + h, e.lat + u))
          }
          adjustAntiMeridian() {
            const e = new c.U(this._sw.lng, this._sw.lat),
              o = new c.U(this._ne.lng, this._ne.lat);
            return new ir(e, e.lng > o.lng ? new c.U(o.lng + 360, o.lat) : o)
          }
        }
        class Ze {
          constructor(e, o, u) {
            this.bounds = ir.convert(this.validateBounds(e)), this.minzoom = o || 0, this.maxzoom = u || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const o = Math.pow(2, e.z),
              u = Math.floor(c.X(this.bounds.getWest()) * o),
              h = Math.floor(c.W(this.bounds.getNorth()) * o),
              p = Math.ceil(c.X(this.bounds.getEast()) * o),
              g = Math.ceil(c.W(this.bounds.getSouth()) * o);
            return e.x >= u && e.x < p && e.y >= h && e.y < g
          }
        }
        class or extends c.E {
          constructor(e, o, u, h) {
            if (super(), this.id = e, this.dispatcher = u, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.S(o, ["url", "scheme", "tileSize", "promoteId"])), this._options = c.e({
                type: "vector"
              }, o), this._collectResourceTiming = o.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(h)
          }
          load() {
            return c._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new c.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield gr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (c.e(this, e), e.bounds && (this.tileBounds = new Ze(e.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new c.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new c.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return c.e({}, this._options)
          }
          loadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              const o = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                u = {
                  request: this.map._requestManager.transformRequest(o, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                };
              u.request.collectResourceTiming = this._collectResourceTiming;
              let h = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((p, g) => {
                  e.reloadPromise = {
                    resolve: p,
                    reject: g
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), h = "LT";
              e.abortController = new AbortController;
              try {
                const p = yield e.actor.sendAsync({
                  type: h,
                  data: u
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, p)
              } catch (p) {
                if (delete e.abortController, e.aborted) return;
                if (p && p.status !== 404) throw p;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, o) {
            if (o && o.resourceTiming && (e.resourceTiming = o.resourceTiming), o && this.map._refreshExpiredTiles && e.setExpiryData(o), e.loadVectorData(o, this.map.painter), e.reloadPromise) {
              const u = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(u.resolve).catch(u.reject)
            }
          }
          abortTile(e) {
            return c._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class de extends c.E {
          constructor(e, o, u, h) {
            super(), this.id = e, this.dispatcher = u, this.setEventedParent(h), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({
              type: "raster"
            }, o), c.e(this, c.S(o, ["url", "scheme", "tileSize"]))
          }
          load() {
            return c._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new c.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const o = yield gr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, o && (c.e(this, o), o.bounds && (this.tileBounds = new Ze(o.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new c.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (o) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new c.k(o))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return c.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              const o = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const u = yield Zt.getImage(this.map._requestManager.transformRequest(o, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (u && u.data) {
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                    cacheControl: u.cacheControl,
                    expires: u.expires
                  });
                  const h = this.map.painter.context,
                    p = h.gl,
                    g = u.data;
                  e.texture = this.map.painter.getTileTexture(g.width), e.texture ? e.texture.update(g, {
                    useMipmap: !0
                  }) : (e.texture = new c.T(h, g, p.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u
              }
            }))
          }
          abortTile(e) {
            return c._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class zr extends de {
          constructor(e, o, u, h) {
            super(e, o, u, h), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({
              type: "raster-dem"
            }, o), this.encoding = o.encoding || "mapbox", this.redFactor = o.redFactor, this.greenFactor = o.greenFactor, this.blueFactor = o.blueFactor, this.baseShift = o.baseShift
          }
          loadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              const o = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                u = this.map._requestManager.transformRequest(o, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const h = yield Zt.getImage(u, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (h && h.data) {
                  const p = h.data;
                  this.map._refreshExpiredTiles && (h.cacheControl || h.expires) && e.setExpiryData({
                    cacheControl: h.cacheControl,
                    expires: h.expires
                  });
                  const g = c.b(p) && c.Y() ? p : yield this.readImageNow(p), x = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: g,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const T = yield e.actor.sendAsync({
                      type: "LDT",
                      data: x
                    });
                    e.dem = T, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (h) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (h) throw e.state = "errored", h
              }
            }))
          }
          readImageNow(e) {
            return c._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && c.Z()) {
                const o = e.width + 2,
                  u = e.height + 2;
                try {
                  return new c.R({
                    width: o,
                    height: u
                  }, yield c.$(e, -1, -1, o, u))
                } catch {}
              }
              return ut.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const o = e.canonical,
              u = Math.pow(2, o.z),
              h = (o.x - 1 + u) % u,
              p = o.x === 0 ? e.wrap - 1 : e.wrap,
              g = (o.x + 1 + u) % u,
              x = o.x + 1 === u ? e.wrap + 1 : e.wrap,
              T = {};
            return T[new c.a0(e.overscaledZ, p, o.z, h, o.y).key] = {
              backfilled: !1
            }, T[new c.a0(e.overscaledZ, x, o.z, g, o.y).key] = {
              backfilled: !1
            }, o.y > 0 && (T[new c.a0(e.overscaledZ, p, o.z, h, o.y - 1).key] = {
              backfilled: !1
            }, T[new c.a0(e.overscaledZ, e.wrap, o.z, o.x, o.y - 1).key] = {
              backfilled: !1
            }, T[new c.a0(e.overscaledZ, x, o.z, g, o.y - 1).key] = {
              backfilled: !1
            }), o.y + 1 < u && (T[new c.a0(e.overscaledZ, p, o.z, h, o.y + 1).key] = {
              backfilled: !1
            }, T[new c.a0(e.overscaledZ, e.wrap, o.z, o.x, o.y + 1).key] = {
              backfilled: !1
            }, T[new c.a0(e.overscaledZ, x, o.z, g, o.y + 1).key] = {
              backfilled: !1
            }), T
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }

        function er(d) {
          return d.type === "GeometryCollection" ? d.geometries.map((e => e.coordinates)).flat(1 / 0) : d.coordinates.flat(1 / 0)
        }

        function hr(d) {
          const e = new ir;
          let o;
          switch (d.type) {
            case "FeatureCollection":
              o = d.features.map((u => er(u.geometry))).flat(1 / 0);
              break;
            case "Feature":
              o = er(d.geometry);
              break;
            default:
              o = er(d)
          }
          if (o.length == 0) return e;
          for (let u = 0; u < o.length - 1; u += 2) e.extend([o[u], o[u + 1]]);
          return e
        }
        class Mr extends c.E {
          constructor(e, o, u, h) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: o.data
            }, this.actor = u.getActor(), this.setEventedParent(h), this._data = o.data, this._options = c.e({}, o), this._collectResourceTiming = o.collectResourceTiming, o.maxzoom !== void 0 && (this.maxzoom = o.maxzoom), o.type && (this.type = o.type), o.attribution && (this.attribution = o.attribution), this.promoteId = o.promoteId, o.clusterMaxZoom !== void 0 && this.maxzoom <= o.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${o.clusterMaxZoom}".`), this.workerOptions = c.e({
              source: this.id,
              cluster: o.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(o.buffer !== void 0 ? o.buffer : 128),
                tolerance: this._pixelsToTileUnits(o.tolerance !== void 0 ? o.tolerance : .375),
                extent: c.a3,
                maxZoom: this.maxzoom,
                lineMetrics: o.lineMetrics || !1,
                generateId: o.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(o.clusterMaxZoom),
                minPoints: Math.max(2, o.clusterMinPoints || 2),
                extent: c.a3,
                radius: this._pixelsToTileUnits(o.clusterRadius || 50),
                log: !1,
                generateId: o.generateId || !1
              },
              clusterProperties: o.clusterProperties,
              filter: o.filter
            }, o.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged
          }
          _pixelsToTileUnits(e) {
            return e * (c.a3 / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const o = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || c.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${o}"`), o
          }
          load() {
            return c._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = c.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return c._(this, void 0, void 0, (function*() {
              const e = c.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getBounds() {
            return c._(this, void 0, void 0, (function*() {
              return hr(yield this.getData())
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, o, u) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: o,
                offset: u
              }
            })
          }
          _updateWorkerData() {
            return c._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void c.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const {
                data: e,
                diff: o
              } = this._pendingWorkerUpdate, u = c.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (u.request = this.map._requestManager.transformRequest(ut.resolveURL(e), "Source"), u.request.collectResourceTiming = this._collectResourceTiming) : u.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : o && (u.dataDiff = o, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new c.l("dataloading", {
                dataType: "source"
              }));
              try {
                const h = yield this.actor.sendAsync({
                  type: "LD",
                  data: u
                });
                if (this._isUpdatingWorker = !1, this._removed || h.abandoned) return void this.fire(new c.l("dataabort", {
                  dataType: "source"
                }));
                this._data = h.data;
                let p = null;
                h.resourceTiming && h.resourceTiming[this.id] && (p = h.resourceTiming[this.id].slice(0));
                const g = {
                  dataType: "source"
                };
                this._collectResourceTiming && p && p.length > 0 && c.e(g, {
                  resourceTiming: p
                }), this.fire(new c.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "metadata"
                }))), this.fire(new c.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "content",
                  shouldReloadTileOptions: this._getShouldReloadTileOptions(o)
                })))
              } catch (h) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new c.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new c.k(h))
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData()
              }
            }))
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const {
              add: o = [],
              update: u = [],
              remove: h = []
            } = e || {}, p = new Set([...u.map((g => g.id)), ...h]);
            return {
              nextBounds: [...u.map((g => g.newGeometry)), ...o.map((g => g.geometry))].map((g => hr(g))),
              prevIds: p
            }
          }
          shouldReloadTile(e, {
            nextBounds: o,
            prevIds: u
          }) {
            const h = e.latestFeatureIndex.loadVTLayers();
            for (let T = 0; T < e.latestFeatureIndex.featureIndexArray.length; T++) {
              const I = e.latestFeatureIndex.featureIndexArray.get(T),
                A = h._geojsonTileLayer.feature(I.featureIndex);
              if (u.has(A.id)) return !0
            }
            const {
              buffer: p,
              extent: g
            } = this.workerOptions.geojsonVtOptions, x = (function({
              x: T,
              y: I,
              z: A
            }, F = 0) {
              const L = c.a1((T - F) / Math.pow(2, A)),
                V = c.a2((I + 1 + F) / Math.pow(2, A)),
                K = c.a1((T + 1 + F) / Math.pow(2, A)),
                it = c.a2((I - F) / Math.pow(2, A));
              return new ir([L, V], [K, it])
            })(e.tileID.canonical, p / g);
            for (const T of o)
              if (x.intersects(T)) return !0;
            return !1
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
          }
          loadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              const o = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const u = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
              };
              e.abortController = new AbortController;
              const h = yield this.actor.sendAsync({
                type: o,
                data: u
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(h, this.map.painter, o === "RT")
            }))
          }
          abortTile(e) {
            return c._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return c.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class Pr extends c.E {
          constructor(e, o, u, h) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = u, this.coordinates = o.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(h), this.options = o
          }
          load(e) {
            return c._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new c.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const o = yield Zt.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, o && o.data && (this.image = o.data, e && (this.coordinates = e), this._finishLoading())
              } catch (o) {
                this._request = null, this._loaded = !0, this.fire(new c.k(o))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new c.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const o = e.map(c.a5.fromLngLat);
            var u;
            return this.tileID = (function(h) {
              const p = c.a6.fromPoints(h),
                g = p.width(),
                x = p.height(),
                T = Math.max(g, x),
                I = Math.max(0, Math.floor(-Math.log(T) / Math.LN2)),
                A = Math.pow(2, I);
              return new c.a8(I, Math.floor((p.minX + p.maxX) / 2 * A), Math.floor((p.minY + p.maxY) / 2 * A))
            })(o), this.terrainTileRanges = this._getOverlappingTileRanges(o), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = o.map((h => this.tileID.getTilePoint(h)._round())), this.flippedWindingOrder = ((u = this.tileCoords)[1].x - u[0].x) * (u[2].y - u[0].y) - (u[1].y - u[0].y) * (u[2].x - u[0].x) < 0, this.fire(new c.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              o = e.gl;
            this.texture || (this.texture = new c.T(e, this.image, o.RGBA), this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE));
            let u = !1;
            for (const h in this.tiles) {
              const p = this.tiles[h];
              p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, u = !0)
            }
            u && this.fire(new c.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return c._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: o,
              minY: u,
              maxX: h,
              maxY: p
            } = c.a6.fromPoints(e), g = {};
            for (let x = 0; x <= c.a7; x++) {
              const T = Math.pow(2, x),
                I = Math.floor(o * T),
                A = Math.floor(u * T),
                F = Math.floor(h * T),
                L = Math.floor(p * T);
              g[x] = {
                minTileX: I,
                minTileY: A,
                maxTileX: F,
                maxTileY: L
              }
            }
            return g
          }
        }
        class Or extends Pr {
          constructor(e, o, u, h) {
            super(e, o, u, h), this.roundZoom = !0, this.type = "video", this.options = o
          }
          load() {
            return c._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const o of e.urls) this.urls.push(this.map._requestManager.transformRequest(o, "Source").url);
              try {
                const o = yield c.a9(this.urls);
                if (this._loaded = !0, !o) return;
                this.video = o, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (o) {
                this.fire(new c.k(o))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const o = this.video.seekable;
              e < o.start(0) || e > o.end(0) ? this.fire(new c.k(new c.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${o.start(0)} and ${o.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              o = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE), o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, o.RGBA, o.UNSIGNED_BYTE, this.video)) : (this.texture = new c.T(e, this.video, o.RGBA), this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE));
            let u = !1;
            for (const h in this.tiles) {
              const p = this.tiles[h];
              p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, u = !0)
            }
            u && this.fire(new c.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class jr extends Pr {
          constructor(e, o, u, h) {
            super(e, o, u, h), o.coordinates ? Array.isArray(o.coordinates) && o.coordinates.length === 4 && !o.coordinates.some((p => !Array.isArray(p) || p.length !== 2 || p.some((g => typeof g != "number")))) || this.fire(new c.k(new c.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.k(new c.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), o.animate && typeof o.animate != "boolean" && this.fire(new c.k(new c.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), o.canvas ? typeof o.canvas == "string" || o.canvas instanceof HTMLCanvasElement || this.fire(new c.k(new c.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.k(new c.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = o, this.animate = o.animate === void 0 || o.animate
          }
          load() {
            return c._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const o = this.map.painter.context,
              u = o.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new c.T(o, this.canvas, u.RGBA, {
              premultiply: !0
            });
            let h = !1;
            for (const p in this.tiles) {
              const g = this.tiles[p];
              g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, h = !0)
            }
            h && this.fire(new c.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const Lr = {},
          _n = d => {
            switch (d) {
              case "geojson":
                return Mr;
              case "image":
                return Pr;
              case "raster":
                return de;
              case "raster-dem":
                return zr;
              case "vector":
                return or;
              case "video":
                return Or;
              case "canvas":
                return jr
            }
            return Lr[d]
          },
          dr = "RTLPluginLoaded";
        class ct extends c.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = ur()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((o => {
              throw this.status = "error", o
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return c._(this, arguments, void 0, (function*(o, u = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = ut.resolveURL(o), !this.url) throw new Error(`requested url ${o} is invalid`);
              if (this.status === "unavailable") {
                if (!u) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return c._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new c.l(dr))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let q = null;

        function U() {
          return q || (q = new ct), q
        }
        var Q, nt;
        (function(d) {
          d[d.Base = 0] = "Base", d[d.Parent = 1] = "Parent"
        })(Q || (Q = {})), (function(d) {
          d[d.Departing = 0] = "Departing", d[d.Incoming = 1] = "Incoming"
        })(nt || (nt = {}));
        class _t {
          constructor(e, o) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = c.ab(), this.uses = 0, this.tileSize = o, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade())
          }
          setCrossFadeLogic({
            fadingRole: e,
            fadingDirection: o,
            fadingParentID: u,
            fadeEndTime: h
          }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = o, this.fadingParentID = u, this.fadeEndTime = h
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = lt(), this.fadeEndTime = 0, this.fadeOpacity = 1
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, o, u) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(h, p) {
                const g = {};
                if (!p) return g;
                for (const x of h) {
                  const T = x.layerIds.map((I => p.getLayer(I))).filter(Boolean);
                  if (T.length !== 0) {
                    x.layers = T, x.stateDependentLayerIds && (x.stateDependentLayers = x.stateDependentLayerIds.map((I => T.filter((A => A.id === I))[0])));
                    for (const I of T) g[I.id] = x
                  }
                }
                return g
              })(e.buckets, o == null ? void 0 : o.style), this.hasSymbolBuckets = !1;
              for (const h in this.buckets) {
                const p = this.buckets[h];
                if (p instanceof c.ad) {
                  if (this.hasSymbolBuckets = !0, !u) break;
                  p.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const h in this.buckets) {
                  const p = this.buckets[h];
                  if (p instanceof c.ad && p.hasRTLText) {
                    this.hasRTLText = !0, U().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const h in this.buckets) {
                const p = this.buckets[h];
                this.queryPadding = Math.max(this.queryPadding, o.style.getLayer(h).queryRadius(p))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions
            } else this.collisionBoxArray = new c.ac
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const u in this.buckets) {
              const h = this.buckets[u];
              h.uploadPending() && h.upload(e)
            }
            const o = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new c.T(e, this.imageAtlas.image, o.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new c.T(e, this.glyphAtlasImage, o.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, o, u, h, p, g, x, T, I, A, F) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: h,
              cameraQueryGeometry: p,
              scale: g,
              tileSize: this.tileSize,
              pixelPosMatrix: A,
              transform: T,
              params: x,
              queryPadding: this.queryPadding * I,
              getElevation: F
            }, e, o, u) : {}
          }
          querySourceFeatures(e, o) {
            const u = this.latestFeatureIndex;
            if (!u || !u.rawTileData) return;
            const h = u.loadVTLayers(),
              p = o && o.sourceLayer ? o.sourceLayer : "",
              g = h._geojsonTileLayer || h[p];
            if (!g) return;
            const x = c.ae(o == null ? void 0 : o.filter, o == null ? void 0 : o.globalState),
              {
                z: T,
                x: I,
                y: A
              } = this.tileID.canonical,
              F = {
                z: T,
                x: I,
                y: A
              };
            for (let L = 0; L < g.length; L++) {
              const V = g.feature(L);
              if (x.needGeometry) {
                const ot = c.af(V, !0);
                if (!x.filter(new c.G(this.tileID.overscaledZ), ot, this.tileID.canonical)) continue
              } else if (!x.filter(new c.G(this.tileID.overscaledZ), V)) continue;
              const K = u.getId(V, p),
                it = new c.ag(V, T, I, A, K);
              it.tile = F, e.push(it)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const o = this.expirationTime;
            if (e.cacheControl) {
              const u = c.ah(e.cacheControl);
              u["max-age"] && (this.expirationTime = Date.now() + 1e3 * u["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const u = Date.now();
              let h = !1;
              if (this.expirationTime > u) h = !1;
              else if (o)
                if (this.expirationTime < o) h = !0;
                else {
                  const p = this.expirationTime - o;
                  p ? this.expirationTime = u + Math.max(p, 3e4) : h = !0
                }
              else h = !0;
              h ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, o) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const u = this.latestFeatureIndex.loadVTLayers();
            for (const h in this.buckets) {
              if (!o.style.hasLayer(h)) continue;
              const p = this.buckets[h],
                g = p.layers[0].sourceLayer || "_geojsonTileLayer",
                x = u[g],
                T = e[g];
              if (!x || !T || Object.keys(T).length === 0) continue;
              p.update(T, x, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const I = o && o.style && o.style.getLayer(h);
              I && (this.queryPadding = Math.max(this.queryPadding, I.queryRadius(p)))
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < lt()
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = lt() + e
          }
          setDependencies(e, o) {
            const u = {};
            for (const h of o) u[h] = !0;
            this.dependencies[e] = u
          }
          hasDependency(e, o) {
            for (const u of e) {
              const h = this.dependencies[u];
              if (h) {
                for (const p of o)
                  if (h[p]) return !0
              }
            }
            return !1
          }
        }
        class Tt {
          constructor(e, o) {
            this.max = e, this.onRemove = o, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const o of this.data[e]) o.timeout && clearTimeout(o.timeout), this.onRemove(o.value);
            return this.data = {}, this.order = [], this
          }
          add(e, o, u) {
            const h = e.wrapped().key;
            this.data[h] === void 0 && (this.data[h] = []);
            const p = {
              value: o,
              timeout: void 0
            };
            if (u !== void 0 && (p.timeout = setTimeout((() => {
                this.remove(e, p)
              }), u)), this.data[h].push(p), this.order.push(h), this.order.length > this.max) {
              const g = this._getAndRemoveByKey(this.order[0]);
              g && this.onRemove(g)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const o = this.data[e].shift();
            return o.timeout && clearTimeout(o.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), o.value
          }
          getByKey(e) {
            const o = this.data[e];
            return o ? o[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, o) {
            if (!this.has(e)) return this;
            const u = e.wrapped().key,
              h = o === void 0 ? 0 : this.data[u].indexOf(o),
              p = this.data[u][h];
            return this.data[u].splice(h, 1), p.timeout && clearTimeout(p.timeout), this.data[u].length === 0 && delete this.data[u], this.onRemove(p.value), this.order.splice(this.order.indexOf(u), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const o = this._getAndRemoveByKey(this.order[0]);
              o && this.onRemove(o)
            }
            return this
          }
          filter(e) {
            const o = [];
            for (const u in this.data)
              for (const h of this.data[u]) e(h.value) || o.push(h);
            for (const u of o) this.remove(u.value.tileID, u)
          }
        }
        class Ft {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, o, u) {
            const h = String(o);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][h] = this.stateChanges[e][h] || {}, c.e(this.stateChanges[e][h], u), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const p in this.state[e]) p !== h && (this.deletedStates[e][p] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][h] === null) {
              this.deletedStates[e][h] = {};
              for (const p in this.state[e][h]) u[p] || (this.deletedStates[e][h][p] = null)
            } else
              for (const p in u) this.deletedStates[e] && this.deletedStates[e][h] && this.deletedStates[e][h][p] === null && delete this.deletedStates[e][h][p]
          }
          removeFeatureState(e, o, u) {
            if (this.deletedStates[e] === null) return;
            const h = String(o);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, u && o !== void 0) this.deletedStates[e][h] !== null && (this.deletedStates[e][h] = this.deletedStates[e][h] || {}, this.deletedStates[e][h][u] = null);
            else if (o !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][h])
                for (u in this.deletedStates[e][h] = {}, this.stateChanges[e][h]) this.deletedStates[e][h][u] = null;
              else this.deletedStates[e][h] = null;
            else this.deletedStates[e] = null
          }
          getState(e, o) {
            const u = String(o),
              h = c.e({}, (this.state[e] || {})[u], (this.stateChanges[e] || {})[u]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const p = this.deletedStates[e][o];
              if (p === null) return {};
              for (const g in p) delete h[g]
            }
            return h
          }
          initializeTileState(e, o) {
            e.setFeatureState(this.state, o)
          }
          coalesceChanges(e, o) {
            const u = {};
            for (const h in this.stateChanges) {
              this.state[h] = this.state[h] || {};
              const p = {};
              for (const g in this.stateChanges[h]) this.state[h][g] || (this.state[h][g] = {}), c.e(this.state[h][g], this.stateChanges[h][g]), p[g] = this.state[h][g];
              u[h] = p
            }
            for (const h in this.deletedStates) {
              this.state[h] = this.state[h] || {};
              const p = {};
              if (this.deletedStates[h] === null)
                for (const g in this.state[h]) p[g] = {}, this.state[h][g] = {};
              else
                for (const g in this.deletedStates[h]) {
                  if (this.deletedStates[h][g] === null) this.state[h][g] = {};
                  else
                    for (const x of Object.keys(this.deletedStates[h][g])) delete this.state[h][g][x];
                  p[g] = this.state[h][g]
                }
              u[h] = u[h] || {}, c.e(u[h], p)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(u).length !== 0)
              for (const h in e) e[h].setFeatureState(u, o)
          }
        }
        const zt = 89.25;

        function Nt(d, e) {
          const o = c.ai(e.lat, -c.aj, c.aj);
          return new c.P(c.X(e.lng) * d, c.W(o) * d)
        }

        function ie(d, e) {
          return new c.a5(e.x / d, e.y / d).toLngLat()
        }

        function mt(d) {
          return d.cameraToCenterDistance * Math.min(.85 * Math.tan(c.ak(90 - d.pitch)), Math.tan(c.ak(zt - d.pitch)))
        }

        function et(d, e) {
          const o = d.canonical,
            u = e / c.al(o.z),
            h = o.x + Math.pow(2, o.z) * d.wrap,
            p = c.am(new Float64Array(16));
          return c.N(p, p, [h * u, o.y * u, 0]), c.O(p, p, [u / c.a3, u / c.a3, 1]), p
        }

        function W(d, e, o, u, h) {
          const p = c.a5.fromLngLat(d, e),
            g = h * c.an(1, d.lat),
            x = g * Math.cos(c.ak(o)),
            T = Math.sqrt(g * g - x * x),
            I = T * Math.sin(c.ak(-u)),
            A = T * Math.cos(c.ak(-u));
          return new c.a5(p.x + I, p.y + A, p.z + x)
        }

        function vt(d, e, o) {
          const u = e.intersectsFrustum(d);
          if (!o || u === 0) return u;
          const h = e.intersectsPlane(o);
          return h === 0 ? 0 : u === 2 && h === 2 ? 2 : 1
        }

        function $t(d, e, o) {
          let u = 0;
          const h = (o - e) / 10;
          for (let p = 0; p < 10; p++) u += h * Math.pow(Math.cos(e + (p + .5) / 10 * (o - e)), d);
          return u
        }

        function Pt(d, e) {
          return function(o, u, h, p, g) {
            const x = 2 * ((d - 1) / c.ao(Math.cos(c.ak(zt - g)) / Math.cos(c.ak(zt))) - 1),
              T = Math.acos(h / p),
              I = 2 * $t(x - 1, 0, c.ak(g / 2)),
              A = Math.min(c.ak(zt), T + c.ak(g / 2)),
              F = $t(x - 1, Math.min(A, T - c.ak(g / 2)), A),
              L = Math.atan(u / h),
              V = Math.hypot(u, h);
            let K = o;
            return K += c.ao(p / V / Math.max(.5, Math.cos(c.ak(g / 2)))), K += x * c.ao(Math.cos(L)) / 2, K -= c.ao(Math.max(1, F / I / e)) / 2, K
          }
        }
        const Gt = Pt(9.314, 3);

        function ae(d, e) {
          const o = (e.roundZoom ? Math.round : Math.floor)(d.zoom + c.ao(d.tileSize / e.tileSize));
          return Math.max(0, o)
        }

        function ye(d, e) {
          const o = d.getCameraFrustum(),
            u = d.getClippingPlane(),
            h = d.screenPointToMercatorCoordinate(d.getCameraPoint()),
            p = c.a5.fromLngLat(d.center, d.elevation);
          h.z = p.z + Math.cos(d.pitchInRadians) * d.cameraToCenterDistance / d.worldSize;
          const g = d.getCoveringTilesDetailsProvider(),
            x = g.allowVariableZoom(d, e),
            T = ae(d, e),
            I = e.minzoom || 0,
            A = e.maxzoom !== void 0 ? e.maxzoom : d.maxZoom,
            F = Math.min(Math.max(0, T), A),
            L = Math.pow(2, F),
            V = [L * h.x, L * h.y, 0],
            K = [L * p.x, L * p.y, 0],
            it = Math.hypot(p.x - h.x, p.y - h.y),
            ot = Math.abs(p.z - h.z),
            st = Math.hypot(it, ot),
            pt = kt => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: kt,
              fullyVisible: !1
            }),
            wt = [],
            dt = [];
          if (d.renderWorldCopies && g.allowWorldCopies())
            for (let kt = 1; kt <= 3; kt++) wt.push(pt(-kt)), wt.push(pt(kt));
          for (wt.push(pt(0)); wt.length > 0;) {
            const kt = wt.pop(),
              It = kt.x,
              gt = kt.y;
            let Rt = kt.fullyVisible;
            const oe = {
                x: It,
                y: gt,
                z: kt.zoom
              },
              Qt = g.getTileBoundingVolume(oe, kt.wrap, d.elevation, e);
            if (!Rt) {
              const tr = vt(o, Qt, u);
              if (tr === 0) continue;
              Rt = tr === 2
            }
            const re = g.distanceToTile2d(h.x, h.y, oe, Qt);
            let ue = T;
            x && (ue = (e.calculateTileZoom || Gt)(d.zoom + c.ao(d.tileSize / e.tileSize), re, ot, st, d.fov)), ue = (e.roundZoom ? Math.round : Math.floor)(ue), ue = Math.max(0, ue);
            const Je = Math.min(ue, A);
            if (kt.wrap = g.getWrap(p, oe, kt.wrap), kt.zoom >= Je) {
              if (kt.zoom < I) continue;
              const tr = F - kt.zoom,
                Pe = V[0] - .5 - (It << tr),
                Fr = V[1] - .5 - (gt << tr),
                gn = e.reparseOverscaled ? Math.max(kt.zoom, ue) : kt.zoom;
              dt.push({
                tileID: new c.a0(kt.zoom === A ? gn : kt.zoom, kt.wrap, kt.zoom, It, gt),
                distanceSq: c.ap([K[0] - .5 - It, K[1] - .5 - gt]),
                tileDistanceToCamera: Math.sqrt(Pe * Pe + Fr * Fr)
              })
            } else
              for (let tr = 0; tr < 4; tr++) wt.push({
                zoom: kt.zoom + 1,
                x: (It << 1) + tr % 2,
                y: (gt << 1) + (tr >> 1),
                wrap: kt.wrap,
                fullyVisible: Rt
              })
          }
          return dt.sort(((kt, It) => kt.distanceSq - It.distanceSq)).map((kt => kt.tileID))
        }
        const Te = c.a6.fromPoints([new c.P(0, 0), new c.P(c.a3, c.a3)]);
        class we extends c.E {
          constructor(e, o, u) {
            super(), this.id = e, this.dispatcher = u, this.on("data", (h => this._dataHandler(h))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((h, p, g, x) => {
              const T = new(_n(p.type))(h, p, g, x);
              if (T.id !== h) throw new Error(`Expected Source id to be ${h} instead of ${T.id}`);
              return T
            })(e, o, u, this), this._tiles = {}, this._cache = new Tt(0, (h => this._unloadTile(h))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Ft, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const o = this._tiles[e];
              if (o.state !== "loaded" && o.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          getState() {
            return this._state
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, o, u) {
            return c._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, o, u)
              } catch (h) {
                e.state = "errored", h.status !== 404 ? this._source.fire(new c.k(h, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new c.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const o in this._tiles) {
              const u = this._tiles[o];
              u.upload(e), u.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(be).map((e => e.key))
          }
          getRenderableIds(e) {
            const o = [];
            for (const u in this._tiles) this._isIdRenderable(u, e) && o.push(this._tiles[u]);
            return e ? o.sort(((u, h) => {
              const p = u.tileID,
                g = h.tileID,
                x = new c.P(p.canonical.x, p.canonical.y)._rotate(-this.transform.bearingInRadians),
                T = new c.P(g.canonical.x, g.canonical.y)._rotate(-this.transform.bearingInRadians);
              return p.overscaledZ - g.overscaledZ || T.y - x.y || T.x - x.x
            })).map((u => u.tileID.key)) : o.map((u => u.tileID)).sort(be).map((u => u.key))
          }
          hasRenderableParent(e) {
            const o = e.overscaledZ - 1;
            if (o >= this._source.minzoom) {
              const u = this.getLoadedTile(e.scaledTo(o));
              if (u) return this._isIdRenderable(u.tileID.key)
            }
            return !1
          }
          _isIdRenderable(e, o = !1) {
            var u;
            return (u = this._tiles[e]) === null || u === void 0 ? void 0 : u.isRenderable(o)
          }
          reload(e, o = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const u in this._tiles) o && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[u], o) || (e ? this._reloadTile(u, "expired") : this._tiles[u].state !== "errored" && this._reloadTile(u, "reloading"))
            }
          }
          _reloadTile(e, o) {
            return c._(this, void 0, void 0, (function*() {
              const u = this._tiles[e];
              u && (u.state !== "loading" && (u.state = o), yield this._loadTile(u, e, o))
            }))
          }
          _tileLoaded(e, o, u) {
            e.timeAdded = lt(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), u === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(o, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new c.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const o = this.getRenderableIds();
            for (let h = 0; h < o.length; h++) {
              const p = o[h];
              if (e.neighboringTiles && e.neighboringTiles[p]) {
                const g = this.getTileByID(p);
                u(e, g), u(g, e)
              }
            }

            function u(h, p) {
              h.needsHillshadePrepare = !0, h.needsTerrainPrepare = !0;
              let g = p.tileID.canonical.x - h.tileID.canonical.x;
              const x = p.tileID.canonical.y - h.tileID.canonical.y,
                T = Math.pow(2, h.tileID.canonical.z),
                I = p.tileID.key;
              g === 0 && x === 0 || Math.abs(x) > 1 || (Math.abs(g) > 1 && (Math.abs(g + T) === 1 ? g += T : Math.abs(g - T) === 1 && (g -= T)), p.dem && h.dem && (h.dem.backfillBorder(p.dem, g, x), h.neighboringTiles && h.neighboringTiles[I] && (h.neighboringTiles[I].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, o) {
            const u = Object.values(e),
              h = this._getLoadedDescendents(u),
              p = {};
            for (const g of u) {
              const x = h[g.key];
              if (!(x != null && x.length)) {
                p[g.key] = g;
                continue
              }
              const T = g.overscaledZ + we.maxUnderzooming,
                I = x.filter((L => L.tileID.overscaledZ <= T));
              if (!I.length) {
                p[g.key] = g;
                continue
              }
              const A = Math.min(...I.map((L => L.tileID.overscaledZ))),
                F = I.filter((L => L.tileID.overscaledZ === A)).map((L => L.tileID));
              for (const L of F) o[L.key] = L;
              this._areDescendentsComplete(F, A, g.overscaledZ) || (p[g.key] = g)
            }
            return p
          }
          _getLoadedDescendents(e) {
            var o;
            const u = {};
            for (const h in this._tiles) {
              const p = this._tiles[h];
              if (p.hasData())
                for (const g of e) p.tileID.isChildOf(g) && (u[o = g.key] || (u[o] = [])).push(p)
            }
            return u
          }
          _areDescendentsComplete(e, o, u) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === o : Math.pow(4, o - u) === e.length
          }
          getLoadedTile(e) {
            const o = this._tiles[e.key];
            return o != null && o.hasData() ? o : null
          }
          updateCacheSize(e) {
            const o = Math.ceil(e.width / this._source.tileSize) + 1,
              u = Math.ceil(e.height / this._source.tileSize) + 1,
              h = Math.floor(o * u * (this._maxTileCacheZoomLevels === null ? c.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              p = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, h) : h;
            this._cache.setMaxSize(p)
          }
          handleWrapJump(e) {
            const o = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, o) {
              const u = {};
              for (const h in this._tiles) {
                const p = this._tiles[h];
                p.tileID = p.tileID.unwrapTo(p.tileID.wrap + o), u[p.tileID.key] = p
              }
              this._tiles = u, this._resetTileReloadTimers()
            }
          }
          update(e, o) {
            if (!this._sourceLoaded || this._paused) return;
            let u;
            this.transform = e, this.terrain = o, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? u = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((T => new c.a0(T.canonical.z, T.wrap, T.canonical.z, T.canonical.x, T.canonical.y))) : (u = ye(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: o,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (u = u.filter((T => this._source.hasTile(T))))) : u = [], this.usedForTerrain && (u = this._addTerrainIdealTiles(u));
            const h = u.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, h && this.fire(new c.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const p = ae(e, this._source),
              g = this._updateRetainedTiles(u, p),
              x = Ee(this._source.type);
            x && this._rasterFadeDuration > 0 && !o && this._updateFadingTiles(u, g), x ? this._cleanUpRasterTiles(g) : this._cleanUpVectorTiles(g)
          }
          _cleanUpRasterTiles(e) {
            for (const o in this._tiles) e[o] || this._removeTile(o)
          }
          _cleanUpVectorTiles(e) {
            for (const o in this._tiles) {
              const u = this._tiles[o];
              e[o] ? u.clearSymbolFadeHold() : u.hasSymbolBuckets ? u.holdingForSymbolFade() ? u.symbolFadeFinished() && this._removeTile(o) : u.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(o)
            }
          }
          _addTerrainIdealTiles(e) {
            const o = [];
            for (const u of e)
              if (u.canonical.z > this._source.minzoom) {
                const h = u.scaledTo(u.canonical.z - 1);
                o.push(h);
                const p = u.scaledTo(Math.max(this._source.minzoom, Math.min(u.canonical.z, 5)));
                o.push(p)
              } return e.concat(o)
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, o) {
            var u;
            const h = {},
              p = {},
              g = Math.max(o - we.maxOverzooming, this._source.minzoom);
            let x = {};
            for (const T of e) {
              const I = this._addTile(T);
              h[T.key] = T, I.hasData() || (x[T.key] = T)
            }
            x = this._retainLoadedChildren(x, h);
            for (const T in x) {
              const I = x[T];
              let A = this._tiles[T],
                F = A == null ? void 0 : A.wasRequested();
              for (let L = I.overscaledZ - 1; L >= g; --L) {
                const V = I.scaledTo(L);
                if (p[V.key]) break;
                if (p[V.key] = !0, A = this.getTile(V), !A && F && (A = this._addTile(V)), A) {
                  const K = A.hasData();
                  if ((K || !(!((u = this.map) === null || u === void 0) && u.cancelPendingTileRequestsWhileZooming) || F) && (h[V.key] = V), F = A.wasRequested(), K) break
                }
              }
            }
            return h
          }
          _updateFadingTiles(e, o) {
            const u = lt(),
              h = c.aq(e);
            for (const p of e) {
              const g = this._tiles[p.key];
              g.fadingDirection !== nt.Departing && g.fadeOpacity !== 0 || g.resetFadeLogic(), this._updateFadingAncestor(g, o, u) || this._updateFadingDescendents(g, o, u) || this._updateFadingEdge(g, h, u) || g.resetFadeLogic()
            }
          }
          _updateFadingAncestor(e, o, u) {
            if (!e.hasData()) return !1;
            const {
              tileID: h,
              fadingRole: p,
              fadingDirection: g,
              fadingParentID: x
            } = e;
            if (p === Q.Base && g === nt.Incoming && x) return o[x.key] = x, !0;
            const T = Math.max(h.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let I = h.overscaledZ - 1; I >= T; I--) {
              const A = h.scaledTo(I),
                F = this.getLoadedTile(A);
              if (F) return e.setCrossFadeLogic({
                fadingRole: Q.Base,
                fadingDirection: nt.Incoming,
                fadingParentID: F.tileID,
                fadeEndTime: u + this._rasterFadeDuration
              }), F.setCrossFadeLogic({
                fadingRole: Q.Parent,
                fadingDirection: nt.Departing,
                fadeEndTime: u + this._rasterFadeDuration
              }), o[A.key] = A, !0
            }
            return !1
          }
          _updateFadingDescendents(e, o, u) {
            if (!e.hasData()) return !1;
            const h = e.tileID.children(this._source.maxzoom);
            let p = this._updateFadingChildren(e, h, o, u);
            if (p) return !0;
            for (const g of h) {
              const x = g.children(this._source.maxzoom);
              this._updateFadingChildren(e, x, o, u) && (p = !0)
            }
            return p
          }
          _updateFadingChildren(e, o, u, h) {
            if (o[0].overscaledZ >= this._source.maxzoom) return !1;
            let p = !1;
            for (const g of o) {
              const x = this.getLoadedTile(g);
              if (!x) continue;
              const {
                fadingRole: T,
                fadingDirection: I,
                fadingParentID: A
              } = x;
              T === Q.Base && I === nt.Departing && A || (x.setCrossFadeLogic({
                fadingRole: Q.Base,
                fadingDirection: nt.Departing,
                fadingParentID: e.tileID,
                fadeEndTime: h + this._rasterFadeDuration
              }), e.setCrossFadeLogic({
                fadingRole: Q.Parent,
                fadingDirection: nt.Incoming,
                fadeEndTime: h + this._rasterFadeDuration
              })), u[g.key] = g, p = !0
            }
            return p
          }
          _updateFadingEdge(e, o, u) {
            const h = e.tileID;
            return !!e.selfFading || !e.hasData() && !!o.has(h) && (e.setSelfFadeLogic(u + this._rasterFadeDuration), !0)
          }
          _addTile(e) {
            let o = this._tiles[e.key];
            if (o) return o;
            o = this._cache.getAndRemove(e), o && (o.resetFadeLogic(), this._setTileReloadTimer(e.key, o), o.tileID = e, this._state.initializeTileState(o, this.map ? this.map.painter : null));
            const u = o;
            return o || (o = new _t(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(o, e.key, o.state)), o.uses++, this._tiles[e.key] = o, u || this._source.fire(new c.l("dataloading", {
              tile: o,
              coord: o.tileID,
              dataType: "source"
            })), o
          }
          _setTileReloadTimer(e, o) {
            this._clearTileReloadTimer(e);
            const u = o.getExpiryTimeout();
            u && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), u))
          }
          _clearTileReloadTimer(e) {
            const o = this._timers[e];
            o && (clearTimeout(o), delete this._timers[e])
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e])
          }
          refreshTiles(e) {
            for (const o in this._tiles)(this._isIdRenderable(o) || this._tiles[o].state == "errored") && e.some((u => u.equals(this._tiles[o].tileID.canonical))) && this._reloadTile(o, "expired")
          }
          _removeTile(e) {
            const o = this._tiles[e];
            o && (o.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), o.uses > 0 || (o.hasData() && o.state !== "reloading" ? this._cache.add(o.tileID, o, o.getExpiryTimeout()) : (o.aborted = !0, this._abortTile(o), this._unloadTile(o))))
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, o, u) {
            const h = [],
              p = this.transform;
            if (!p) return h;
            const g = p.getCoveringTilesDetailsProvider().allowWorldCopies(),
              x = u ? p.getCameraQueryGeometry(e) : e,
              T = V => p.screenPointToMercatorCoordinate(V, this.terrain),
              I = this.transformBbox(e, T, !g),
              A = this.transformBbox(x, T, !g),
              F = this.getIds(),
              L = c.a6.fromPoints(A);
            for (let V = 0; V < F.length; V++) {
              const K = this._tiles[F[V]];
              if (K.holdingForSymbolFade()) continue;
              const it = g ? [K.tileID] : [K.tileID.unwrapTo(-1), K.tileID.unwrapTo(0)],
                ot = Math.pow(2, p.zoom - K.tileID.overscaledZ),
                st = o * K.queryPadding * c.a3 / K.tileSize / ot;
              for (const pt of it) {
                const wt = L.map((dt => pt.getTilePoint(new c.a5(dt.x, dt.y))));
                if (wt.expandBy(st), wt.intersects(Te)) {
                  const dt = I.map((It => pt.getTilePoint(It))),
                    kt = A.map((It => pt.getTilePoint(It)));
                  h.push({
                    tile: K,
                    tileID: g ? pt : pt.unwrapTo(0),
                    queryGeometry: dt,
                    cameraQueryGeometry: kt,
                    scale: ot
                  })
                }
              }
            }
            return h
          }
          transformBbox(e, o, u) {
            let h = e.map(o);
            if (u) {
              const p = c.a6.fromPoints(e);
              p.shrinkBy(.001 * Math.min(p.width(), p.height()));
              const g = p.map(o);
              c.a6.fromPoints(h).covers(g) || (h = h.map((x => x.x > .5 ? new c.a5(x.x - 1, x.y, x.z) : x)))
            }
            return h
          }
          getVisibleCoordinates(e) {
            const o = this.getRenderableIds(e).map((u => this._tiles[u].tileID));
            return this.transform && this.transform.populateCache(o), o
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (Ee(this._source.type) && this._rasterFadeDuration > 0) {
              const e = lt();
              for (const o in this._tiles)
                if (this._tiles[o].fadeEndTime >= e) return !0
            }
            return !1
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e
          }
          setFeatureState(e, o, u) {
            this._state.updateState(e = e || "_geojsonTileLayer", o, u)
          }
          removeFeatureState(e, o, u) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", o, u)
          }
          getFeatureState(e, o) {
            return this._state.getState(e = e || "_geojsonTileLayer", o)
          }
          setDependencies(e, o, u) {
            const h = this._tiles[e];
            h && h.setDependencies(o, u)
          }
          reloadTilesForDependencies(e, o) {
            for (const u in this._tiles) this._tiles[u].hasDependency(e, o) && this._reloadTile(u, "reloading");
            this._cache.filter((u => !u.hasDependency(e, o)))
          }
        }

        function be(d, e) {
          const o = Math.abs(2 * d.wrap) - +(d.wrap < 0),
            u = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return d.overscaledZ - e.overscaledZ || u - o || e.canonical.y - d.canonical.y || e.canonical.x - d.canonical.x
        }

        function Ee(d) {
          return d === "raster" || d === "image" || d === "video"
        }
        we.maxOverzooming = 10, we.maxUnderzooming = 3;
        class Qe {
          constructor(e, o) {
            this.reset(e, o)
          }
          reset(e, o) {
            this.points = e || [], this._distances = [0];
            for (let u = 1; u < this.points.length; u++) this._distances[u] = this._distances[u - 1] + this.points[u].dist(this.points[u - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(o || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = c.ai(e, 0, 1);
            let o = 1,
              u = this._distances[o];
            const h = e * this.paddedLength + this.padding;
            for (; u < h && o < this._distances.length;) u = this._distances[++o];
            const p = o - 1,
              g = this._distances[p],
              x = u - g,
              T = x > 0 ? (h - g) / x : 0;
            return this.points[p].mult(1 - T).add(this.points[o].mult(T))
          }
        }

        function Yt(d, e) {
          let o = !0;
          return d === "always" || d !== "never" && e !== "never" || (o = !1), o
        }
        class je {
          constructor(e, o, u) {
            const h = this.boxCells = [],
              p = this.circleCells = [];
            this.xCellCount = Math.ceil(e / u), this.yCellCount = Math.ceil(o / u);
            for (let g = 0; g < this.xCellCount * this.yCellCount; g++) h.push([]), p.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = o, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / o, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, o, u, h, p) {
            this._forEachCell(o, u, h, p, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(h), this.bboxes.push(p)
          }
          insertCircle(e, o, u, h) {
            this._forEachCell(o - h, u - h, o + h, u + h, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(o), this.circles.push(u), this.circles.push(h)
          }
          _insertBoxCell(e, o, u, h, p, g) {
            this.boxCells[p].push(g)
          }
          _insertCircleCell(e, o, u, h, p, g) {
            this.circleCells[p].push(g)
          }
          _query(e, o, u, h, p, g, x) {
            if (u < 0 || e > this.width || h < 0 || o > this.height) return [];
            const T = [];
            if (e <= 0 && o <= 0 && this.width <= u && this.height <= h) {
              if (p) return [{
                key: null,
                x1: e,
                y1: o,
                x2: u,
                y2: h
              }];
              for (let I = 0; I < this.boxKeys.length; I++) T.push({
                key: this.boxKeys[I],
                x1: this.bboxes[4 * I],
                y1: this.bboxes[4 * I + 1],
                x2: this.bboxes[4 * I + 2],
                y2: this.bboxes[4 * I + 3]
              });
              for (let I = 0; I < this.circleKeys.length; I++) {
                const A = this.circles[3 * I],
                  F = this.circles[3 * I + 1],
                  L = this.circles[3 * I + 2];
                T.push({
                  key: this.circleKeys[I],
                  x1: A - L,
                  y1: F - L,
                  x2: A + L,
                  y2: F + L
                })
              }
            } else this._forEachCell(e, o, u, h, this._queryCell, T, {
              hitTest: p,
              overlapMode: g,
              seenUids: {
                box: {},
                circle: {}
              }
            }, x);
            return T
          }
          query(e, o, u, h) {
            return this._query(e, o, u, h, !1, null)
          }
          hitTest(e, o, u, h, p, g) {
            return this._query(e, o, u, h, !0, p, g).length > 0
          }
          hitTestCircle(e, o, u, h, p) {
            const g = e - u,
              x = e + u,
              T = o - u,
              I = o + u;
            if (x < 0 || g > this.width || I < 0 || T > this.height) return !1;
            const A = [];
            return this._forEachCell(g, T, x, I, this._queryCellCircle, A, {
              hitTest: !0,
              overlapMode: h,
              circle: {
                x: e,
                y: o,
                radius: u
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, p), A.length > 0
          }
          _queryCell(e, o, u, h, p, g, x, T) {
            const {
              seenUids: I,
              hitTest: A,
              overlapMode: F
            } = x, L = this.boxCells[p];
            if (L !== null) {
              const K = this.bboxes;
              for (const it of L)
                if (!I.box[it]) {
                  I.box[it] = !0;
                  const ot = 4 * it,
                    st = this.boxKeys[it];
                  if (e <= K[ot + 2] && o <= K[ot + 3] && u >= K[ot + 0] && h >= K[ot + 1] && (!T || T(st)) && (!A || !Yt(F, st.overlapMode)) && (g.push({
                      key: st,
                      x1: K[ot],
                      y1: K[ot + 1],
                      x2: K[ot + 2],
                      y2: K[ot + 3]
                    }), A)) return !0
                }
            }
            const V = this.circleCells[p];
            if (V !== null) {
              const K = this.circles;
              for (const it of V)
                if (!I.circle[it]) {
                  I.circle[it] = !0;
                  const ot = 3 * it,
                    st = this.circleKeys[it];
                  if (this._circleAndRectCollide(K[ot], K[ot + 1], K[ot + 2], e, o, u, h) && (!T || T(st)) && (!A || !Yt(F, st.overlapMode))) {
                    const pt = K[ot],
                      wt = K[ot + 1],
                      dt = K[ot + 2];
                    if (g.push({
                        key: st,
                        x1: pt - dt,
                        y1: wt - dt,
                        x2: pt + dt,
                        y2: wt + dt
                      }), A) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, o, u, h, p, g, x, T) {
            const {
              circle: I,
              seenUids: A,
              overlapMode: F
            } = x, L = this.boxCells[p];
            if (L !== null) {
              const K = this.bboxes;
              for (const it of L)
                if (!A.box[it]) {
                  A.box[it] = !0;
                  const ot = 4 * it,
                    st = this.boxKeys[it];
                  if (this._circleAndRectCollide(I.x, I.y, I.radius, K[ot + 0], K[ot + 1], K[ot + 2], K[ot + 3]) && (!T || T(st)) && !Yt(F, st.overlapMode)) return g.push(!0), !0
                }
            }
            const V = this.circleCells[p];
            if (V !== null) {
              const K = this.circles;
              for (const it of V)
                if (!A.circle[it]) {
                  A.circle[it] = !0;
                  const ot = 3 * it,
                    st = this.circleKeys[it];
                  if (this._circlesCollide(K[ot], K[ot + 1], K[ot + 2], I.x, I.y, I.radius) && (!T || T(st)) && !Yt(F, st.overlapMode)) return g.push(!0), !0
                }
            }
          }
          _forEachCell(e, o, u, h, p, g, x, T) {
            const I = this._convertToXCellCoord(e),
              A = this._convertToYCellCoord(o),
              F = this._convertToXCellCoord(u),
              L = this._convertToYCellCoord(h);
            for (let V = I; V <= F; V++)
              for (let K = A; K <= L; K++)
                if (p.call(this, e, o, u, h, this.xCellCount * K + V, g, x, T)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, o, u, h, p, g) {
            const x = h - e,
              T = p - o,
              I = u + g;
            return I * I > x * x + T * T
          }
          _circleAndRectCollide(e, o, u, h, p, g, x) {
            const T = (g - h) / 2,
              I = Math.abs(e - (h + T));
            if (I > T + u) return !1;
            const A = (x - p) / 2,
              F = Math.abs(o - (p + A));
            if (F > A + u) return !1;
            if (I <= T || F <= A) return !0;
            const L = I - T,
              V = F - A;
            return L * L + V * V <= u * u
          }
        }

        function Fe(d, e, o) {
          const u = c.M();
          if (!d) {
            const {
              vecSouth: F,
              vecEast: L
            } = Ar(e), V = X();
            V[0] = L[0], V[1] = L[1], V[2] = F[0], V[3] = F[1], h = V, (A = (g = (p = V)[0]) * (I = p[3]) - (T = p[2]) * (x = p[1])) && (h[0] = I * (A = 1 / A), h[1] = -x * A, h[2] = -T * A, h[3] = g * A), u[0] = V[0], u[1] = V[1], u[4] = V[2], u[5] = V[3]
          }
          var h, p, g, x, T, I, A;
          return c.O(u, u, [1 / o, 1 / o, 1]), u
        }

        function Nr(d, e, o, u) {
          if (d) {
            const h = c.M();
            if (!e) {
              const {
                vecSouth: p,
                vecEast: g
              } = Ar(o);
              h[0] = g[0], h[1] = g[1], h[4] = p[0], h[5] = p[1]
            }
            return c.O(h, h, [u, u, 1]), h
          }
          return o.pixelsToClipSpaceMatrix
        }

        function Ar(d) {
          const e = Math.cos(d.rollInRadians),
            o = Math.sin(d.rollInRadians),
            u = Math.cos(d.pitchInRadians),
            h = Math.cos(d.bearingInRadians),
            p = Math.sin(d.bearingInRadians),
            g = c.av();
          g[0] = -h * u * o - p * e, g[1] = -p * u * o + h * e;
          const x = c.aw(g);
          x < 1e-9 ? c.ax(g) : c.ay(g, g, 1 / x);
          const T = c.av();
          T[0] = h * u * e - p * o, T[1] = p * u * e + h * o;
          const I = c.aw(T);
          return I < 1e-9 ? c.ax(T) : c.ay(T, T, 1 / I), {
            vecEast: T,
            vecSouth: g
          }
        }

        function Kt(d, e, o, u) {
          let h;
          u ? (h = [d, e, u(d, e), 1], c.aA(h, h, o)) : (h = [d, e, 0, 1], ln(h, h, o));
          const p = h[3];
          return {
            point: new c.P(h[0] / p, h[1] / p),
            signedDistanceFromCamera: p,
            isOccluded: !1
          }
        }

        function Oe(d, e) {
          return .5 + d / e * .5
        }

        function Be(d, e) {
          return d.x >= -e[0] && d.x <= e[0] && d.y >= -e[1] && d.y <= e[1]
        }

        function fe(d, e, o, u, h, p, g, x, T, I, A, F, L) {
          const V = o ? d.textSizeData : d.iconSizeData,
            K = c.ar(V, e.transform.zoom),
            it = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            ot = o ? d.text.dynamicLayoutVertexArray : d.icon.dynamicLayoutVertexArray;
          ot.clear();
          const st = d.lineVertexArray,
            pt = o ? d.text.placedSymbolArray : d.icon.placedSymbolArray,
            wt = e.transform.width / e.transform.height;
          let dt = !1;
          for (let kt = 0; kt < pt.length; kt++) {
            const It = pt.get(kt);
            if (It.hidden || It.writingMode === c.as.vertical && !dt) {
              on(It.numGlyphs, ot);
              continue
            }
            dt = !1;
            const gt = new c.P(It.anchorX, It.anchorY),
              Rt = {
                getElevation: L,
                pitchedLabelPlaneMatrix: u,
                lineVertexArray: st,
                pitchWithMap: p,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: gt,
                unwrappedTileID: T,
                width: I,
                height: A,
                translation: F
              },
              oe = rr(It.anchorX, It.anchorY, Rt);
            if (!Be(oe.point, it)) {
              on(It.numGlyphs, ot);
              continue
            }
            const Qt = Oe(e.transform.cameraToCenterDistance, oe.signedDistanceFromCamera),
              re = c.at(V, K, It),
              ue = p ? re * e.transform.getPitchedTextCorrection(It.anchorX, It.anchorY, T) / Qt : re * Qt,
              Je = Ge({
                projectionContext: Rt,
                pitchedLabelPlaneMatrixInverse: h,
                symbol: It,
                fontSize: ue,
                flip: !1,
                keepUpright: g,
                glyphOffsetArray: d.glyphOffsetArray,
                dynamicLayoutVertexArray: ot,
                aspectRatio: wt,
                rotateToLine: x
              });
            dt = Je.useVertical, (Je.notEnoughRoom || dt || Je.needsFlipping && Ge({
              projectionContext: Rt,
              pitchedLabelPlaneMatrixInverse: h,
              symbol: It,
              fontSize: ue,
              flip: !0,
              keepUpright: g,
              glyphOffsetArray: d.glyphOffsetArray,
              dynamicLayoutVertexArray: ot,
              aspectRatio: wt,
              rotateToLine: x
            }).notEnoughRoom) && on(It.numGlyphs, ot)
          }
          o ? d.text.dynamicLayoutVertexBuffer.updateData(ot) : d.icon.dynamicLayoutVertexBuffer.updateData(ot)
        }

        function Me(d, e, o, u, h, p, g, x) {
          const T = p.glyphStartIndex + p.numGlyphs,
            I = p.lineStartIndex,
            A = p.lineStartIndex + p.lineLength,
            F = e.getoffsetX(p.glyphStartIndex),
            L = e.getoffsetX(T - 1),
            V = De(d * F, o, u, h, p.segment, I, A, x, g);
          if (!V) return null;
          const K = De(d * L, o, u, h, p.segment, I, A, x, g);
          return K ? x.projectionCache.anyProjectionOccluded ? null : {
            first: V,
            last: K
          } : null
        }

        function cr(d, e, o, u) {
          return d === c.as.horizontal && Math.abs(o.y - e.y) > Math.abs(o.x - e.x) * u ? {
            useVertical: !0
          } : (d === c.as.vertical ? e.y < o.y : e.x > o.x) ? {
            needsFlipping: !0
          } : null
        }

        function Ge(d) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: o,
            symbol: u,
            fontSize: h,
            flip: p,
            keepUpright: g,
            glyphOffsetArray: x,
            dynamicLayoutVertexArray: T,
            aspectRatio: I,
            rotateToLine: A
          } = d, F = h / 24, L = u.lineOffsetX * F, V = u.lineOffsetY * F;
          let K;
          if (u.numGlyphs > 1) {
            const it = u.glyphStartIndex + u.numGlyphs,
              ot = u.lineStartIndex,
              st = u.lineStartIndex + u.lineLength,
              pt = Me(F, x, L, V, p, u, A, e);
            if (!pt) return {
              notEnoughRoom: !0
            };
            const wt = Se(pt.first.point.x, pt.first.point.y, e, o),
              dt = Se(pt.last.point.x, pt.last.point.y, e, o);
            if (g && !p) {
              const kt = cr(u.writingMode, wt, dt, I);
              if (kt) return kt
            }
            K = [pt.first];
            for (let kt = u.glyphStartIndex + 1; kt < it - 1; kt++) {
              const It = De(F * x.getoffsetX(kt), L, V, p, u.segment, ot, st, e, A);
              if (!It) return {
                notEnoughRoom: !0
              };
              K.push(It)
            }
            K.push(pt.last)
          } else {
            if (g && !p) {
              const ot = Jt(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                st = u.lineStartIndex + u.segment + 1,
                pt = new c.P(e.lineVertexArray.getx(st), e.lineVertexArray.gety(st)),
                wt = Jt(pt.x, pt.y, e),
                dt = wt.signedDistanceFromCamera > 0 ? wt.point : qr(e.tileAnchorPoint, pt, ot, 1, e),
                kt = Se(ot.x, ot.y, e, o),
                It = Se(dt.x, dt.y, e, o),
                gt = cr(u.writingMode, kt, It, I);
              if (gt) return gt
            }
            const it = De(F * x.getoffsetX(u.glyphStartIndex), L, V, p, u.segment, u.lineStartIndex, u.lineStartIndex + u.lineLength, e, A);
            if (!it || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            K = [it]
          }
          for (const it of K) c.az(T, it.point, it.angle);
          return {}
        }

        function qr(d, e, o, u, h) {
          const p = d.add(d.sub(e)._unit()),
            g = Jt(p.x, p.y, h).point,
            x = o.sub(g);
          return o.add(x._mult(u / x.mag()))
        }

        function lr(d, e, o) {
          const u = e.projectionCache;
          if (u.projections[d]) return u.projections[d];
          const h = new c.P(e.lineVertexArray.getx(d), e.lineVertexArray.gety(d)),
            p = Jt(h.x, h.y, e);
          if (p.signedDistanceFromCamera > 0) return u.projections[d] = p.point, u.anyProjectionOccluded = u.anyProjectionOccluded || p.isOccluded, p.point;
          const g = d - o.direction;
          return qr(o.distanceFromAnchor === 0 ? e.tileAnchorPoint : new c.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), h, o.previousVertex, o.absOffsetX - o.distanceFromAnchor + 1, e)
        }

        function Jt(d, e, o) {
          const u = d + o.translation[0],
            h = e + o.translation[1];
          let p;
          return o.pitchWithMap ? (p = Kt(u, h, o.pitchedLabelPlaneMatrix, o.getElevation), p.isOccluded = !1) : (p = o.transform.projectTileCoordinates(u, h, o.unwrappedTileID, o.getElevation), p.point.x = (.5 * p.point.x + .5) * o.width, p.point.y = (.5 * -p.point.y + .5) * o.height), p
        }

        function Se(d, e, o, u) {
          if (o.pitchWithMap) {
            const h = [d, e, 0, 1];
            return c.aA(h, h, u), o.transform.projectTileCoordinates(h[0] / h[3], h[1] / h[3], o.unwrappedTileID, o.getElevation).point
          }
          return {
            x: d / o.width * 2 - 1,
            y: 1 - e / o.height * 2
          }
        }

        function rr(d, e, o) {
          return o.transform.projectTileCoordinates(d, e, o.unwrappedTileID, o.getElevation)
        }

        function Le(d, e, o) {
          return d._unit()._perp()._mult(e * o)
        }

        function sr(d, e, o, u, h, p, g, x, T) {
          if (x.projectionCache.offsets[d]) return x.projectionCache.offsets[d];
          const I = o.add(e);
          if (d + T.direction < u || d + T.direction >= h) return x.projectionCache.offsets[d] = I, I;
          const A = lr(d + T.direction, x, T),
            F = Le(A.sub(o), g, T.direction),
            L = o.add(F),
            V = A.add(F);
          return x.projectionCache.offsets[d] = c.aB(p, I, L, V) || I, x.projectionCache.offsets[d]
        }

        function De(d, e, o, u, h, p, g, x, T) {
          const I = u ? d - e : d + e;
          let A = I > 0 ? 1 : -1,
            F = 0;
          u && (A *= -1, F = Math.PI), A < 0 && (F += Math.PI);
          let L, V = A > 0 ? p + h : p + h + 1;
          x.projectionCache.cachedAnchorPoint ? L = x.projectionCache.cachedAnchorPoint : (L = Jt(x.tileAnchorPoint.x, x.tileAnchorPoint.y, x).point, x.projectionCache.cachedAnchorPoint = L);
          let K, it, ot = L,
            st = L,
            pt = 0,
            wt = 0;
          const dt = Math.abs(I),
            kt = [];
          let It;
          for (; pt + wt <= dt;) {
            if (V += A, V < p || V >= g) return null;
            pt += wt, st = ot, it = K;
            const oe = {
              absOffsetX: dt,
              direction: A,
              distanceFromAnchor: pt,
              previousVertex: st
            };
            if (ot = lr(V, x, oe), o === 0) kt.push(st), It = ot.sub(st);
            else {
              let Qt;
              const re = ot.sub(st);
              Qt = re.mag() === 0 ? Le(lr(V + A, x, oe).sub(ot), o, A) : Le(re, o, A), it || (it = st.add(Qt)), K = sr(V, Qt, ot, p, g, it, o, x, oe), kt.push(it), It = K.sub(it)
            }
            wt = It.mag()
          }
          const gt = It._mult((dt - pt) / wt)._add(it || st),
            Rt = F + Math.atan2(ot.y - st.y, ot.x - st.x);
          return kt.push(gt), {
            point: gt,
            angle: T ? Rt : 0,
            path: kt
          }
        }
        const Cr = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function on(d, e) {
          for (let o = 0; o < d; o++) {
            const u = e.length;
            e.resize(u + 4), e.float32.set(Cr, 3 * u)
          }
        }

        function ln(d, e, o) {
          const u = e[0],
            h = e[1];
          return d[0] = o[0] * u + o[4] * h + o[12], d[1] = o[1] * u + o[5] * h + o[13], d[3] = o[3] * u + o[7] * h + o[15], d
        }
        const Br = 100;
        class Dr {
          constructor(e, o = new je(e.width + 200, e.height + 200, 25), u = new je(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = o, this.ignoredGrid = u, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Br, this.screenBottomBoundary = e.height + Br, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, o, u, h, p, g, x, T, I, A, F, L) {
            const V = this.projectAndGetPerspectiveRatio(e.anchorPointX + T[0], e.anchorPointY + T[1], p, A, L),
              K = u * V.perspectiveRatio;
            let it;
            if (g || x) it = this._projectCollisionBox(e, K, h, p, g, x, T, V, A, F, L);
            else {
              const It = V.x + (F ? F.x * K : 0),
                gt = V.y + (F ? F.y * K : 0);
              it = {
                allPointsOccluded: !1,
                box: [It + e.x1 * K, gt + e.y1 * K, It + e.x2 * K, gt + e.y2 * K]
              }
            }
            const [ot, st, pt, wt] = it.box, dt = g ? it.allPointsOccluded : V.isOccluded;
            let kt = dt;
            return kt || (kt = V.perspectiveRatio < this.perspectiveRatioCutoff), kt || (kt = !this.isInsideGrid(ot, st, pt, wt)), kt || o !== "always" && this.grid.hitTest(ot, st, pt, wt, o, I) ? {
              box: [ot, st, pt, wt],
              placeable: !1,
              offscreen: !1,
              occluded: dt
            } : {
              box: [ot, st, pt, wt],
              placeable: !0,
              offscreen: this.isOffscreen(ot, st, pt, wt),
              occluded: dt
            }
          }
          placeCollisionCircles(e, o, u, h, p, g, x, T, I, A, F, L, V, K) {
            const it = [],
              ot = new c.P(o.anchorX, o.anchorY),
              st = this.getPerspectiveRatio(ot.x, ot.y, g, K),
              pt = (I ? p * this.transform.getPitchedTextCorrection(o.anchorX, o.anchorY, g) / st : p * st) / c.aF,
              wt = {
                getElevation: K,
                pitchedLabelPlaneMatrix: x,
                lineVertexArray: u,
                pitchWithMap: I,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: ot,
                unwrappedTileID: g,
                width: this.transform.width,
                height: this.transform.height,
                translation: V
              },
              dt = Me(pt, h, o.lineOffsetX * pt, o.lineOffsetY * pt, !1, o, !1, wt);
            let kt = !1,
              It = !1,
              gt = !0;
            if (dt) {
              const Rt = .5 * F * st + L,
                oe = new c.P(-100, -100),
                Qt = new c.P(this.screenRightBoundary, this.screenBottomBoundary),
                re = new Qe,
                ue = dt.first,
                Je = dt.last;
              let tr = [];
              for (let gn = ue.path.length - 1; gn >= 1; gn--) tr.push(ue.path[gn]);
              for (let gn = 1; gn < Je.path.length; gn++) tr.push(Je.path[gn]);
              const Pe = 2.5 * Rt;
              if (I) {
                const gn = this.projectPathToScreenSpace(tr, wt);
                tr = gn.some((Hn => Hn.signedDistanceFromCamera <= 0)) ? [] : gn.map((Hn => Hn.point))
              }
              let Fr = [];
              if (tr.length > 0) {
                const gn = tr[0].clone(),
                  Hn = tr[0].clone();
                for (let Tn = 1; Tn < tr.length; Tn++) gn.x = Math.min(gn.x, tr[Tn].x), gn.y = Math.min(gn.y, tr[Tn].y), Hn.x = Math.max(Hn.x, tr[Tn].x), Hn.y = Math.max(Hn.y, tr[Tn].y);
                Fr = gn.x >= oe.x && Hn.x <= Qt.x && gn.y >= oe.y && Hn.y <= Qt.y ? [tr] : Hn.x < oe.x || gn.x > Qt.x || Hn.y < oe.y || gn.y > Qt.y ? [] : c.aC([tr], oe.x, oe.y, Qt.x, Qt.y)
              }
              for (const gn of Fr) {
                re.reset(gn, .25 * Rt);
                let Hn = 0;
                Hn = re.length <= .5 * Rt ? 1 : Math.ceil(re.paddedLength / Pe) + 1;
                for (let Tn = 0; Tn < Hn; Tn++) {
                  const Jn = Tn / Math.max(Hn - 1, 1),
                    _i = re.lerp(Jn),
                    ei = _i.x + Br,
                    Ii = _i.y + Br;
                  it.push(ei, Ii, Rt, 0);
                  const oi = ei - Rt,
                    Oi = Ii - Rt,
                    si = ei + Rt,
                    Si = Ii + Rt;
                  if (gt = gt && this.isOffscreen(oi, Oi, si, Si), It = It || this.isInsideGrid(oi, Oi, si, Si), e !== "always" && this.grid.hitTestCircle(ei, Ii, Rt, e, A) && (kt = !0, !T)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: kt
                  }
                }
              }
            }
            return {
              circles: !T && kt || !It || st < this.perspectiveRatioCutoff ? [] : it,
              offscreen: gt,
              collisionDetected: kt
            }
          }
          projectPathToScreenSpace(e, o) {
            const u = (function(h, p) {
              const g = c.M();
              return c.au(g, p.pitchedLabelPlaneMatrix), h.map((x => {
                const T = Kt(x.x, x.y, g, p.getElevation),
                  I = p.transform.projectTileCoordinates(T.point.x, T.point.y, p.unwrappedTileID, p.getElevation);
                return I.point.x = (.5 * I.point.x + .5) * p.width, I.point.y = (.5 * -I.point.y + .5) * p.height, I
              }))
            })(e, o);
            return (function(h) {
              let p = 0,
                g = 0,
                x = 0,
                T = 0;
              for (let I = 0; I < h.length; I++) h[I].isOccluded ? (x = I + 1, T = 0) : (T++, T > g && (g = T, p = x));
              return h.slice(p, p + g)
            })(u)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const o = [],
              u = new c.a6;
            for (const F of e) {
              const L = new c.P(F.x + Br, F.y + Br);
              u.extend(L), o.push(L)
            }
            const {
              minX: h,
              minY: p,
              maxX: g,
              maxY: x
            } = u, T = this.grid.query(h, p, g, x).concat(this.ignoredGrid.query(h, p, g, x)), I = {}, A = {};
            for (const F of T) {
              const L = F.key;
              if (I[L.bucketInstanceId] === void 0 && (I[L.bucketInstanceId] = {}), I[L.bucketInstanceId][L.featureIndex]) continue;
              const V = [new c.P(F.x1, F.y1), new c.P(F.x2, F.y1), new c.P(F.x2, F.y2), new c.P(F.x1, F.y2)];
              c.aD(o, V) && (I[L.bucketInstanceId][L.featureIndex] = !0, A[L.bucketInstanceId] === void 0 && (A[L.bucketInstanceId] = []), A[L.bucketInstanceId].push(L.featureIndex))
            }
            return A
          }
          insertCollisionBox(e, o, u, h, p, g) {
            (u ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: h,
              featureIndex: p,
              collisionGroupID: g,
              overlapMode: o
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, o, u, h, p, g) {
            const x = u ? this.ignoredGrid : this.grid,
              T = {
                bucketInstanceId: h,
                featureIndex: p,
                collisionGroupID: g,
                overlapMode: o
              };
            for (let I = 0; I < e.length; I += 4) x.insertCircle(T, e[I], e[I + 1], e[I + 2])
          }
          projectAndGetPerspectiveRatio(e, o, u, h, p) {
            if (p) {
              let g;
              h ? (g = [e, o, h(e, o), 1], c.aA(g, g, p)) : (g = [e, o, 0, 1], ln(g, g, p));
              const x = g[3];
              return {
                x: (g[0] / x + 1) / 2 * this.transform.width + Br,
                y: (-g[1] / x + 1) / 2 * this.transform.height + Br,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / x * .5,
                isOccluded: !1,
                signedDistanceFromCamera: x
              }
            } {
              const g = this.transform.projectTileCoordinates(e, o, u, h);
              return {
                x: (g.point.x + 1) / 2 * this.transform.width + Br,
                y: (1 - g.point.y) / 2 * this.transform.height + Br,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * .5,
                isOccluded: g.isOccluded,
                signedDistanceFromCamera: g.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, o, u, h) {
            const p = this.transform.projectTileCoordinates(e, o, u, h);
            return .5 + this.transform.cameraToCenterDistance / p.signedDistanceFromCamera * .5
          }
          isOffscreen(e, o, u, h) {
            return u < Br || e >= this.screenRightBoundary || h < Br || o > this.screenBottomBoundary
          }
          isInsideGrid(e, o, u, h) {
            return u >= 0 && e < this.gridRightBoundary && h >= 0 && o < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = c.am([]);
            return c.N(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, o, u, h, p, g, x, T, I, A, F) {
            let L = 1,
              V = 0,
              K = 0,
              it = 1;
            const ot = e.anchorPointX + x[0],
              st = e.anchorPointY + x[1];
            if (g && !p) {
              const tr = this.projectAndGetPerspectiveRatio(ot + 1, st, h, I, F),
                Pe = tr.x - T.x,
                Fr = Math.atan((tr.y - T.y) / Pe) + (Pe < 0 ? Math.PI : 0),
                gn = Math.sin(Fr),
                Hn = Math.cos(Fr);
              L = Hn, V = gn, K = -gn, it = Hn
            } else if (!g && p) {
              const tr = Ar(this.transform);
              L = tr.vecEast[0], V = tr.vecEast[1], K = tr.vecSouth[0], it = tr.vecSouth[1]
            }
            let pt = T.x,
              wt = T.y,
              dt = o;
            p && (pt = ot, wt = st, dt = Math.pow(2, -(this.transform.zoom - u.overscaledZ)), dt *= this.transform.getPitchedTextCorrection(ot, st, h), A || (dt *= c.ai(.5 + T.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), A && (pt += L * A.x * dt + K * A.y * dt, wt += V * A.x * dt + it * A.y * dt);
            const kt = e.x1 * dt,
              It = e.x2 * dt,
              gt = (kt + It) / 2,
              Rt = e.y1 * dt,
              oe = e.y2 * dt,
              Qt = (Rt + oe) / 2,
              re = [{
                offsetX: kt,
                offsetY: Rt
              }, {
                offsetX: gt,
                offsetY: Rt
              }, {
                offsetX: It,
                offsetY: Rt
              }, {
                offsetX: It,
                offsetY: Qt
              }, {
                offsetX: It,
                offsetY: oe
              }, {
                offsetX: gt,
                offsetY: oe
              }, {
                offsetX: kt,
                offsetY: oe
              }, {
                offsetX: kt,
                offsetY: Qt
              }];
            let ue = [];
            for (const {
                offsetX: tr,
                offsetY: Pe
              }
              of re) ue.push(new c.P(pt + L * tr + K * Pe, wt + V * tr + it * Pe));
            let Je = !1;
            if (p) {
              const tr = ue.map((Pe => this.projectAndGetPerspectiveRatio(Pe.x, Pe.y, h, I, F)));
              Je = tr.some((Pe => !Pe.isOccluded)), ue = tr.map((Pe => new c.P(Pe.x, Pe.y)))
            } else Je = !0;
            return {
              box: c.aE(ue),
              allPointsOccluded: !Je
            }
          }
        }
        class un {
          constructor(e, o, u, h) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? o : -o))) : h && u ? 1 : 0, this.placed = u
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class Fn {
          constructor(e, o, u, h, p) {
            this.text = new un(e ? e.text : null, o, u, p), this.icon = new un(e ? e.icon : null, o, h, p)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class Rn {
          constructor(e, o, u) {
            this.text = e, this.icon = o, this.skipFade = u
          }
        }
        class Kr {
          constructor(e, o, u, h, p) {
            this.bucketInstanceId = e, this.featureIndex = o, this.sourceLayerIndex = u, this.bucketIndex = h, this.tileID = p
          }
        }
        class Hr {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const o = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: o,
                predicate: u => u.collisionGroupID === o
              }
            }
            return this.collisionGroups[e]
          }
        }

        function An(d, e, o, u, h) {
          const {
            horizontalAlign: p,
            verticalAlign: g
          } = c.aL(d);
          return new c.P(-(p - .5) * e + u[0] * h, -(g - .5) * o + u[1] * h)
        }
        class Hi {
          constructor(e, o, u, h, p) {
            this.transform = e.clone(), this.terrain = o, this.collisionIndex = new Dr(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = u, this.retainedQueryData = {}, this.collisionGroups = new Hr(h), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = p, p && (p.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const o = this.terrain;
            return o ? (u, h) => o.getElevation(e, u, h) : null
          }
          getBucketParts(e, o, u, h) {
            const p = u.getBucket(o),
              g = u.latestFeatureIndex;
            if (!p || !g || o.id !== p.layerIds[0]) return;
            const x = u.collisionBoxArray,
              T = p.layers[0].layout,
              I = p.layers[0].paint,
              A = Math.pow(2, this.transform.zoom - u.tileID.overscaledZ),
              F = u.tileSize / c.a3,
              L = u.tileID.toUnwrapped(),
              V = T.get("text-rotation-alignment") === "map",
              K = c.aG(u, 1, this.transform.zoom),
              it = c.aH(this.collisionIndex.transform, u, I.get("text-translate"), I.get("text-translate-anchor")),
              ot = c.aH(this.collisionIndex.transform, u, I.get("icon-translate"), I.get("icon-translate-anchor")),
              st = Fe(V, this.transform, K);
            this.retainedQueryData[p.bucketInstanceId] = new Kr(p.bucketInstanceId, g, p.sourceLayerIndex, p.index, u.tileID);
            const pt = {
              bucket: p,
              layout: T,
              translationText: it,
              translationIcon: ot,
              unwrappedTileID: L,
              pitchedLabelPlaneMatrix: st,
              scale: A,
              textPixelRatio: F,
              holdingForFade: u.holdingForSymbolFade(),
              collisionBoxArray: x,
              partiallyEvaluatedTextSize: c.ar(p.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(p.sourceID)
            };
            if (h)
              for (const wt of p.sortKeyRanges) {
                const {
                  sortKey: dt,
                  symbolInstanceStart: kt,
                  symbolInstanceEnd: It
                } = wt;
                e.push({
                  sortKey: dt,
                  symbolInstanceStart: kt,
                  symbolInstanceEnd: It,
                  parameters: pt
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: p.symbolInstances.length,
                parameters: pt
              })
          }
          attemptAnchorPlacement(e, o, u, h, p, g, x, T, I, A, F, L, V, K, it, ot, st, pt, wt, dt) {
            const kt = c.aI[e.textAnchor],
              It = [e.textOffset0, e.textOffset1],
              gt = An(kt, u, h, It, p),
              Rt = this.collisionIndex.placeCollisionBox(o, L, T, I, A, x, g, ot, F.predicate, wt, gt, dt);
            if ((!pt || this.collisionIndex.placeCollisionBox(pt, L, T, I, A, x, g, st, F.predicate, wt, gt, dt).placeable) && Rt.placeable) {
              let oe;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[V.crossTileID] && this.prevPlacement.placements[V.crossTileID] && this.prevPlacement.placements[V.crossTileID].text && (oe = this.prevPlacement.variableOffsets[V.crossTileID].anchor), V.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[V.crossTileID] = {
                textOffset: It,
                width: u,
                height: h,
                anchor: kt,
                textBoxScale: p,
                prevAnchor: oe
              }, this.markUsedJustification(K, kt, V, it), K.allowVerticalPlacement && (this.markUsedOrientation(K, it, V), this.placedOrientations[V.crossTileID] = it), {
                shift: gt,
                placedGlyphBoxes: Rt
              }
            }
          }
          placeLayerBucketPart(e, o, u) {
            const {
              bucket: h,
              layout: p,
              translationText: g,
              translationIcon: x,
              unwrappedTileID: T,
              pitchedLabelPlaneMatrix: I,
              textPixelRatio: A,
              holdingForFade: F,
              collisionBoxArray: L,
              partiallyEvaluatedTextSize: V,
              collisionGroup: K
            } = e.parameters, it = p.get("text-optional"), ot = p.get("icon-optional"), st = c.aJ(p, "text-overlap", "text-allow-overlap"), pt = st === "always", wt = c.aJ(p, "icon-overlap", "icon-allow-overlap"), dt = wt === "always", kt = p.get("text-rotation-alignment") === "map", It = p.get("text-pitch-alignment") === "map", gt = p.get("icon-text-fit") !== "none", Rt = p.get("symbol-z-order") === "viewport-y", oe = pt && (dt || !h.hasIconData() || ot), Qt = dt && (pt || !h.hasTextData() || it);
            !h.collisionArrays && L && h.deserializeCollisionBoxes(L);
            const re = this.retainedQueryData[h.bucketInstanceId].tileID,
              ue = this._getTerrainElevationFunc(re),
              Je = this.transform.getFastPathSimpleProjectionMatrix(re),
              tr = (Pe, Fr, gn) => {
                var Hn, Tn;
                if (o[Pe.crossTileID]) return;
                if (F) return void(this.placements[Pe.crossTileID] = new Rn(!1, !1, !1));
                let Jn = !1,
                  _i = !1,
                  ei = !0,
                  Ii = null,
                  oi = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Oi = {
                    placeable: !1
                  },
                  si = null,
                  Si = null,
                  co = null,
                  Js = 0,
                  ds = 0,
                  rs = 0;
                Fr.textFeatureIndex ? Js = Fr.textFeatureIndex : Pe.useRuntimeCollisionCircles && (Js = Pe.featureIndex), Fr.verticalTextFeatureIndex && (ds = Fr.verticalTextFeatureIndex);
                const Qs = Fr.textBox;
                if (Qs) {
                  const lo = Pi => {
                      let xi = c.as.horizontal;
                      if (h.allowVerticalPlacement && !Pi && this.prevPlacement) {
                        const qi = this.prevPlacement.placedOrientations[Pe.crossTileID];
                        qi && (this.placedOrientations[Pe.crossTileID] = qi, xi = qi, this.markUsedOrientation(h, xi, Pe))
                      }
                      return xi
                    },
                    ps = (Pi, xi) => {
                      if (h.allowVerticalPlacement && Pe.numVerticalGlyphVertices > 0 && Fr.verticalTextBox) {
                        for (const qi of h.writingModes)
                          if (qi === c.as.vertical ? (oi = xi(), Oi = oi) : oi = Pi(), oi && oi.placeable) break
                      } else oi = Pi()
                    },
                    Cs = Pe.textAnchorOffsetStartIndex,
                    su = Pe.textAnchorOffsetEndIndex;
                  if (su === Cs) {
                    const Pi = (xi, qi) => {
                      const ni = this.collisionIndex.placeCollisionBox(xi, st, A, re, T, It, kt, g, K.predicate, ue, void 0, Je);
                      return ni && ni.placeable && (this.markUsedOrientation(h, qi, Pe), this.placedOrientations[Pe.crossTileID] = qi), ni
                    };
                    ps((() => Pi(Qs, c.as.horizontal)), (() => {
                      const xi = Fr.verticalTextBox;
                      return h.allowVerticalPlacement && Pe.numVerticalGlyphVertices > 0 && xi ? Pi(xi, c.as.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), lo(oi && oi.placeable)
                  } else {
                    let Pi = c.aI[(Tn = (Hn = this.prevPlacement) === null || Hn === void 0 ? void 0 : Hn.variableOffsets[Pe.crossTileID]) === null || Tn === void 0 ? void 0 : Tn.anchor];
                    const xi = (ni, Zo, Is) => {
                      const Ch = ni.x2 - ni.x1,
                        Ih = ni.y2 - ni.y1,
                        zh = Pe.textBoxScale,
                        ea = gt && wt === "never" ? Zo : null;
                      let ra = null,
                        kl = st === "never" ? 1 : 2,
                        Qu = "never";
                      Pi && kl++;
                      for (let Tl = 0; Tl < kl; Tl++) {
                        for (let fs = Cs; fs < su; fs++) {
                          const zs = h.textAnchorOffsets.get(fs);
                          if (Pi && zs.textAnchor !== Pi) continue;
                          const tc = this.attemptAnchorPlacement(zs, ni, Ch, Ih, zh, kt, It, A, re, T, K, Qu, Pe, h, Is, g, x, ea, ue);
                          if (tc && (ra = tc.placedGlyphBoxes, ra && ra.placeable)) return Jn = !0, Ii = tc.shift, ra
                        }
                        Pi ? Pi = null : Qu = st
                      }
                      return u && !ra && (ra = {
                        box: this.collisionIndex.placeCollisionBox(Qs, "always", A, re, T, It, kt, g, K.predicate, ue, void 0, Je).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), ra
                    };
                    ps((() => xi(Qs, Fr.iconBox, c.as.horizontal)), (() => {
                      const ni = Fr.verticalTextBox;
                      return h.allowVerticalPlacement && (!oi || !oi.placeable) && Pe.numVerticalGlyphVertices > 0 && ni ? xi(ni, Fr.verticalIconBox, c.as.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), oi && (Jn = oi.placeable, ei = oi.offscreen);
                    const qi = lo(oi && oi.placeable);
                    if (!Jn && this.prevPlacement) {
                      const ni = this.prevPlacement.variableOffsets[Pe.crossTileID];
                      ni && (this.variableOffsets[Pe.crossTileID] = ni, this.markUsedJustification(h, ni.anchor, Pe, qi))
                    }
                  }
                }
                if (si = oi, Jn = si && si.placeable, ei = si && si.offscreen, Pe.useRuntimeCollisionCircles && Pe.centerJustifiedTextSymbolIndex >= 0) {
                  const lo = h.text.placedSymbolArray.get(Pe.centerJustifiedTextSymbolIndex),
                    ps = c.at(h.textSizeData, V, lo),
                    Cs = p.get("text-padding");
                  Si = this.collisionIndex.placeCollisionCircles(st, lo, h.lineVertexArray, h.glyphOffsetArray, ps, T, I, u, It, K.predicate, Pe.collisionCircleDiameter, Cs, g, ue), Si.circles.length && Si.collisionDetected && !u && c.w("Collisions detected, but collision boxes are not shown"), Jn = pt || Si.circles.length > 0 && !Si.collisionDetected, ei = ei && Si.offscreen
                }
                if (Fr.iconFeatureIndex && (rs = Fr.iconFeatureIndex), Fr.iconBox) {
                  const lo = ps => this.collisionIndex.placeCollisionBox(ps, wt, A, re, T, It, kt, x, K.predicate, ue, gt && Ii ? Ii : void 0, Je);
                  Oi && Oi.placeable && Fr.verticalIconBox ? (co = lo(Fr.verticalIconBox), _i = co.placeable) : (co = lo(Fr.iconBox), _i = co.placeable), ei = ei && co.offscreen
                }
                const za = it || Pe.numHorizontalGlyphVertices === 0 && Pe.numVerticalGlyphVertices === 0,
                  ta = ot || Pe.numIconVertices === 0;
                za || ta ? ta ? za || (_i = _i && Jn) : Jn = _i && Jn : _i = Jn = _i && Jn;
                const go = _i && co.placeable;
                if (Jn && si.placeable && this.collisionIndex.insertCollisionBox(si.box, st, p.get("text-ignore-placement"), h.bucketInstanceId, Oi && Oi.placeable && ds ? ds : Js, K.ID), go && this.collisionIndex.insertCollisionBox(co.box, wt, p.get("icon-ignore-placement"), h.bucketInstanceId, rs, K.ID), Si && Jn && this.collisionIndex.insertCollisionCircles(Si.circles, st, p.get("text-ignore-placement"), h.bucketInstanceId, Js, K.ID), u && this.storeCollisionData(h.bucketInstanceId, gn, Fr, si, co, Si), Pe.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (h.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[Pe.crossTileID] = new Rn((Jn || oe) && !(si != null && si.occluded), (_i || Qt) && !(co != null && co.occluded), ei || h.justReloaded), o[Pe.crossTileID] = !0
              };
            if (Rt) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Pe = h.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Fr = Pe.length - 1; Fr >= 0; --Fr) {
                const gn = Pe[Fr];
                tr(h.symbolInstances.get(gn), h.collisionArrays[gn], gn)
              }
            } else
              for (let Pe = e.symbolInstanceStart; Pe < e.symbolInstanceEnd; Pe++) tr(h.symbolInstances.get(Pe), h.collisionArrays[Pe], Pe);
            h.justReloaded = !1
          }
          storeCollisionData(e, o, u, h, p, g) {
            if (u.textBox || u.iconBox) {
              let x, T;
              this.collisionBoxArrays.has(e) ? x = this.collisionBoxArrays.get(e) : (x = new Map, this.collisionBoxArrays.set(e, x)), x.has(o) ? T = x.get(o) : (T = {
                text: null,
                icon: null
              }, x.set(o, T)), u.textBox && (T.text = h.box), u.iconBox && (T.icon = p.box)
            }
            if (g) {
              let x = this.collisionCircleArrays[e];
              x === void 0 && (x = this.collisionCircleArrays[e] = []);
              for (let T = 0; T < g.circles.length; T += 4) x.push(g.circles[T + 0] - Br), x.push(g.circles[T + 1] - Br), x.push(g.circles[T + 2]), x.push(g.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, o, u, h) {
            let p;
            p = h === c.as.vertical ? u.verticalPlacedTextSymbolIndex : {
              left: u.leftJustifiedTextSymbolIndex,
              center: u.centerJustifiedTextSymbolIndex,
              right: u.rightJustifiedTextSymbolIndex
            } [c.aK(o)];
            const g = [u.leftJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.rightJustifiedTextSymbolIndex, u.verticalPlacedTextSymbolIndex];
            for (const x of g) x >= 0 && (e.text.placedSymbolArray.get(x).crossTileID = p >= 0 && x !== p ? 0 : u.crossTileID)
          }
          markUsedOrientation(e, o, u) {
            const h = o === c.as.horizontal || o === c.as.horizontalOnly ? o : 0,
              p = o === c.as.vertical ? o : 0,
              g = [u.leftJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.rightJustifiedTextSymbolIndex];
            for (const x of g) e.text.placedSymbolArray.get(x).placedOrientation = h;
            u.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(u.verticalPlacedTextSymbolIndex).placedOrientation = p)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const o = this.prevPlacement;
            let u = !1;
            this.prevZoomAdjustment = o ? o.zoomAdjustment(this.transform.zoom) : 0;
            const h = o ? o.symbolFadeChange(e) : 1,
              p = o ? o.opacities : {},
              g = o ? o.variableOffsets : {},
              x = o ? o.placedOrientations : {};
            for (const T in this.placements) {
              const I = this.placements[T],
                A = p[T];
              A ? (this.opacities[T] = new Fn(A, h, I.text, I.icon), u = u || I.text !== A.text.placed || I.icon !== A.icon.placed) : (this.opacities[T] = new Fn(null, h, I.text, I.icon, I.skipFade), u = u || I.text || I.icon)
            }
            for (const T in p) {
              const I = p[T];
              if (!this.opacities[T]) {
                const A = new Fn(I, h, !1, !1);
                A.isHidden() || (this.opacities[T] = A, u = u || I.text.placed || I.icon.placed)
              }
            }
            for (const T in g) this.variableOffsets[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.variableOffsets[T] = g[T]);
            for (const T in x) this.placedOrientations[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.placedOrientations[T] = x[T]);
            if (o && o.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            u ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = o ? o.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, o) {
            const u = {};
            for (const h of o) {
              const p = h.getBucket(e);
              p && h.latestFeatureIndex && e.id === p.layerIds[0] && this.updateBucketOpacities(p, h.tileID, u, h.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, o, u, h) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const p = e.layers[0],
              g = p.layout,
              x = new Fn(null, 0, !1, !1, !0),
              T = g.get("text-allow-overlap"),
              I = g.get("icon-allow-overlap"),
              A = p._unevaluatedLayout.hasValue("text-variable-anchor") || p._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              F = g.get("text-rotation-alignment") === "map",
              L = g.get("text-pitch-alignment") === "map",
              V = g.get("icon-text-fit") !== "none",
              K = new Fn(null, 0, T && (I || !e.hasIconData() || g.get("icon-optional")), I && (T || !e.hasTextData() || g.get("text-optional")), !0);
            !e.collisionArrays && h && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(h);
            const it = (st, pt, wt) => {
                for (let dt = 0; dt < pt / 4; dt++) st.opacityVertexArray.emplaceBack(wt);
                st.hasVisibleVertices = st.hasVisibleVertices || wt !== On
              },
              ot = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let st = 0; st < e.symbolInstances.length; st++) {
              const pt = e.symbolInstances.get(st),
                {
                  numHorizontalGlyphVertices: wt,
                  numVerticalGlyphVertices: dt,
                  crossTileID: kt
                } = pt;
              let It = this.opacities[kt];
              u[kt] ? It = x : It || (It = K, this.opacities[kt] = It), u[kt] = !0;
              const gt = pt.numIconVertices > 0,
                Rt = this.placedOrientations[pt.crossTileID],
                oe = Rt === c.as.vertical,
                Qt = Rt === c.as.horizontal || Rt === c.as.horizontalOnly;
              if (wt > 0 || dt > 0) {
                const ue = $n(It.text);
                it(e.text, wt, oe ? On : ue), it(e.text, dt, Qt ? On : ue);
                const Je = It.text.isHidden();
                [pt.rightJustifiedTextSymbolIndex, pt.centerJustifiedTextSymbolIndex, pt.leftJustifiedTextSymbolIndex].forEach((Fr => {
                  Fr >= 0 && (e.text.placedSymbolArray.get(Fr).hidden = Je || oe ? 1 : 0)
                })), pt.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(pt.verticalPlacedTextSymbolIndex).hidden = Je || Qt ? 1 : 0);
                const tr = this.variableOffsets[pt.crossTileID];
                tr && this.markUsedJustification(e, tr.anchor, pt, Rt);
                const Pe = this.placedOrientations[pt.crossTileID];
                Pe && (this.markUsedJustification(e, "left", pt, Pe), this.markUsedOrientation(e, Pe, pt))
              }
              if (gt) {
                const ue = $n(It.icon),
                  Je = !(V && pt.verticalPlacedIconSymbolIndex && oe);
                pt.placedIconSymbolIndex >= 0 && (it(e.icon, pt.numIconVertices, Je ? ue : On), e.icon.placedSymbolArray.get(pt.placedIconSymbolIndex).hidden = It.icon.isHidden()), pt.verticalPlacedIconSymbolIndex >= 0 && (it(e.icon, pt.numVerticalIconVertices, Je ? On : ue), e.icon.placedSymbolArray.get(pt.verticalPlacedIconSymbolIndex).hidden = It.icon.isHidden())
              }
              const re = ot && ot.has(st) ? ot.get(st) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const ue = e.collisionArrays[st];
                if (ue) {
                  let Je = new c.P(0, 0);
                  if (ue.textBox || ue.verticalTextBox) {
                    let tr = !0;
                    if (A) {
                      const Pe = this.variableOffsets[kt];
                      Pe ? (Je = An(Pe.anchor, Pe.width, Pe.height, Pe.textOffset, Pe.textBoxScale), F && Je._rotate(L ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : tr = !1
                    }
                    if (ue.textBox || ue.verticalTextBox) {
                      let Pe;
                      ue.textBox && (Pe = oe), ue.verticalTextBox && (Pe = Qt), Fi(e.textCollisionBox.collisionVertexArray, It.text.placed, !tr || Pe, re.text, Je.x, Je.y)
                    }
                  }
                  if (ue.iconBox || ue.verticalIconBox) {
                    const tr = !!(!Qt && ue.verticalIconBox);
                    let Pe;
                    ue.iconBox && (Pe = tr), ue.verticalIconBox && (Pe = !tr), Fi(e.iconCollisionBox.collisionVertexArray, It.icon.placed, Pe, re.icon, V ? Je.x : 0, V ? Je.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, o) {
            const u = this.zoomAtLastRecencyCheck === o ? 1 - this.zoomAdjustment(o) : 1;
            return this.zoomAtLastRecencyCheck = o, this.commitTime + this.fadeDuration * u > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function Fi(d, e, o, u, h, p) {
          u && u.length !== 0 || (u = [0, 0, 0, 0]);
          const g = u[0] - Br,
            x = u[1] - Br,
            T = u[2] - Br,
            I = u[3] - Br;
          d.emplaceBack(e ? 1 : 0, o ? 1 : 0, h || 0, p || 0, g, x), d.emplaceBack(e ? 1 : 0, o ? 1 : 0, h || 0, p || 0, T, x), d.emplaceBack(e ? 1 : 0, o ? 1 : 0, h || 0, p || 0, T, I), d.emplaceBack(e ? 1 : 0, o ? 1 : 0, h || 0, p || 0, g, I)
        }
        const Ci = Math.pow(2, 25),
          he = Math.pow(2, 24),
          qe = Math.pow(2, 17),
          Vr = Math.pow(2, 16),
          Pn = Math.pow(2, 9),
          Gn = Math.pow(2, 8),
          Xn = Math.pow(2, 1);

        function $n(d) {
          if (d.opacity === 0 && !d.placed) return 0;
          if (d.opacity === 1 && d.placed) return 4294967295;
          const e = d.placed ? 1 : 0,
            o = Math.floor(127 * d.opacity);
          return o * Ci + e * he + o * qe + e * Vr + o * Pn + e * Gn + o * Xn + e
        }
        const On = 0;
        class Ai {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, o, u, h, p) {
            const g = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (o.getBucketParts(g, h, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, p()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort(((x, T) => x.sortKey - T.sortKey))); this._currentPartIndex < g.length;)
              if (o.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, u), this._currentPartIndex++, p()) return !0;
            return !1
          }
        }
        class Rr {
          constructor(e, o, u, h, p, g, x, T) {
            this.placement = new Hi(e, o, g, x, T), this._currentPlacementIndex = u.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = p, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, o, u) {
            const h = lt(),
              p = () => !this._forceFullPlacement && lt() - h > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const g = o[e[this._currentPlacementIndex]],
                x = this.placement.collisionIndex.transform.zoom;
              if (g.type === "symbol" && (!g.minzoom || g.minzoom <= x) && (!g.maxzoom || g.maxzoom > x)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ai(g)), this._inProgressLayer.continuePlacement(u[g.source], this.placement, this._showCollisionBoxes, g, p)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const wr = 512 / c.a3 / 2;
        class xn {
          constructor(e, o, u) {
            this.tileID = e, this.bucketInstanceId = u, this._symbolsByKey = {};
            const h = new Map;
            for (let p = 0; p < o.length; p++) {
              const g = o.get(p),
                x = g.key,
                T = h.get(x);
              T ? T.push(g) : h.set(x, [g])
            }
            for (const [p, g] of h) {
              const x = {
                positions: g.map((T => ({
                  x: Math.floor(T.anchorX * wr),
                  y: Math.floor(T.anchorY * wr)
                }))),
                crossTileIDs: g.map((T => T.crossTileID))
              };
              if (x.positions.length > 128) {
                const T = new c.aM(x.positions.length, 16, Uint16Array);
                for (const {
                    x: I,
                    y: A
                  }
                  of x.positions) T.add(I, A);
                T.finish(), delete x.positions, x.index = T
              }
              this._symbolsByKey[p] = x
            }
          }
          getScaledCoordinates(e, o) {
            const {
              x: u,
              y: h,
              z: p
            } = this.tileID.canonical, {
              x: g,
              y: x,
              z: T
            } = o.canonical, I = wr / Math.pow(2, T - p), A = (x * c.a3 + e.anchorY) * I, F = h * c.a3 * wr;
            return {
              x: Math.floor((g * c.a3 + e.anchorX) * I - u * c.a3 * wr),
              y: Math.floor(A - F)
            }
          }
          findMatches(e, o, u) {
            const h = this.tileID.canonical.z < o.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - o.canonical.z);
            for (let p = 0; p < e.length; p++) {
              const g = e.get(p);
              if (g.crossTileID) continue;
              const x = this._symbolsByKey[g.key];
              if (!x) continue;
              const T = this.getScaledCoordinates(g, o);
              if (x.index) {
                const I = x.index.range(T.x - h, T.y - h, T.x + h, T.y + h).sort();
                for (const A of I) {
                  const F = x.crossTileIDs[A];
                  if (!u[F]) {
                    u[F] = !0, g.crossTileID = F;
                    break
                  }
                }
              } else if (x.positions)
                for (let I = 0; I < x.positions.length; I++) {
                  const A = x.positions[I],
                    F = x.crossTileIDs[I];
                  if (Math.abs(A.x - T.x) <= h && Math.abs(A.y - T.y) <= h && !u[F]) {
                    u[F] = !0, g.crossTileID = F;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class qn {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class wn {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const o = Math.round((e - this.lng) / 360);
            if (o !== 0)
              for (const u in this.indexes) {
                const h = this.indexes[u],
                  p = {};
                for (const g in h) {
                  const x = h[g];
                  x.tileID = x.tileID.unwrapTo(x.tileID.wrap + o), p[x.tileID.key] = x
                }
                this.indexes[u] = p
              }
            this.lng = e
          }
          addBucket(e, o, u) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === o.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let p = 0; p < o.symbolInstances.length; p++) o.symbolInstances.get(p).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const h = this.usedCrossTileIDs[e.overscaledZ];
            for (const p in this.indexes) {
              const g = this.indexes[p];
              if (Number(p) > e.overscaledZ)
                for (const x in g) {
                  const T = g[x];
                  T.tileID.isChildOf(e) && T.findMatches(o.symbolInstances, e, h)
                } else {
                  const x = g[e.scaledTo(Number(p)).key];
                  x && x.findMatches(o.symbolInstances, e, h)
                }
            }
            for (let p = 0; p < o.symbolInstances.length; p++) {
              const g = o.symbolInstances.get(p);
              g.crossTileID || (g.crossTileID = u.generate(), h[g.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new xn(e, o.symbolInstances, o.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, o) {
            for (const u of o.getCrossTileIDsLists())
              for (const h of u) delete this.usedCrossTileIDs[e][h]
          }
          removeStaleBuckets(e) {
            let o = !1;
            for (const u in this.indexes) {
              const h = this.indexes[u];
              for (const p in h) e[h[p].bucketInstanceId] || (this.removeBucketCrossTileIDs(u, h[p]), delete h[p], o = !0)
            }
            return o
          }
        }
        class xr {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new qn, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, o, u) {
            let h = this.layerIndexes[e.id];
            h === void 0 && (h = this.layerIndexes[e.id] = new wn);
            let p = !1;
            const g = {};
            h.handleWrapJump(u);
            for (const x of o) {
              const T = x.getBucket(e);
              T && e.id === T.layerIds[0] && (T.bucketInstanceId || (T.bucketInstanceId = ++this.maxBucketInstanceId), h.addBucket(x.tileID, T, this.crossTileIDs) && (p = !0), g[T.bucketInstanceId] = !0)
            }
            return h.removeStaleBuckets(g) && (p = !0), p
          }
          pruneUnusedLayers(e) {
            const o = {};
            e.forEach((u => {
              o[u] = !0
            }));
            for (const u in this.layerIndexes) o[u] || delete this.layerIndexes[u]
          }
        }
        var vn = "void main() {fragColor=vec4(1.0);}";
        const Ur = {
          prelude: Jr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: Jr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: Jr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: Jr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: Jr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: Jr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: Jr(vn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: Jr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: Jr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: Jr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: Jr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: Jr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: Jr(vn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: Jr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: Jr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: Jr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: Jr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: Jr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: Jr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: Jr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: Jr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: Jr(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          lineGradientSDF: Jr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          raster: Jr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: Jr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: Jr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: Jr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: Jr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: Jr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: Jr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: Jr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: Jr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: Jr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function Jr(d, e) {
          const o = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            u = e.match(/in ([\w]+) ([\w]+)/g),
            h = d.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            p = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            g = p ? p.concat(h) : h,
            x = {};
          return {
            fragmentSource: d = d.replace(o, ((T, I, A, F, L) => (x[L] = !0, I === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
in ${A} ${F} ${L};
#else
uniform ${A} ${F} u_${L};
#endif
` : `
#ifdef HAS_UNIFORM_u_${L}
    ${A} ${F} ${L} = u_${L};
#endif
`))),
            vertexSource: e = e.replace(o, ((T, I, A, F, L) => {
              const V = F === "float" ? "vec2" : "vec4",
                K = L.match(/color/) ? "color" : V;
              return x[L] ? I === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
uniform lowp float u_${L}_t;
in ${A} ${V} a_${L};
out ${A} ${F} ${L};
#else
uniform ${A} ${F} u_${L};
#endif
` : K === "vec4" ? `
#ifndef HAS_UNIFORM_u_${L}
    ${L} = a_${L};
#else
    ${A} ${F} ${L} = u_${L};
#endif
` : `
#ifndef HAS_UNIFORM_u_${L}
    ${L} = unpack_mix_${K}(a_${L}, u_${L}_t);
#else
    ${A} ${F} ${L} = u_${L};
#endif
` : I === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
uniform lowp float u_${L}_t;
in ${A} ${V} a_${L};
#else
uniform ${A} ${F} u_${L};
#endif
` : K === "vec4" ? `
#ifndef HAS_UNIFORM_u_${L}
    ${A} ${F} ${L} = a_${L};
#else
    ${A} ${F} ${L} = u_${L};
#endif
` : `
#ifndef HAS_UNIFORM_u_${L}
    ${A} ${F} ${L} = unpack_mix_${K}(a_${L}, u_${L}_t);
#else
    ${A} ${F} ${L} = u_${L};
#endif
`
            })),
            staticAttributes: u,
            staticUniforms: g
          }
        }
        class Cn {
          constructor(e, o, u) {
            this.vertexBuffer = e, this.indexBuffer = o, this.segments = u
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var kn = c.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const sn = "#define PROJECTION_MERCATOR",
          Bn = "mercator";
        class Vn {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return Bn
          }
          get shaderDefine() {
            return sn
          }
          get shaderPreludeCode() {
            return Ur.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return Ur.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return c.aO.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, o, u, h, p) {
            if (this._cachedMesh) return this._cachedMesh;
            const g = new c.aP;
            g.emplaceBack(0, 0), g.emplaceBack(c.a3, 0), g.emplaceBack(0, c.a3), g.emplaceBack(c.a3, c.a3);
            const x = e.createVertexBuffer(g, kn.members),
              T = c.aQ.simpleSegment(0, 0, 4, 2),
              I = new c.aR;
            I.emplaceBack(1, 0, 2), I.emplaceBack(1, 2, 3);
            const A = e.createIndexBuffer(I);
            return this._cachedMesh = new Cn(x, A, T), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class bn {
          constructor(e = 0, o = 0, u = 0, h = 0) {
            if (isNaN(e) || e < 0 || isNaN(o) || o < 0 || isNaN(u) || u < 0 || isNaN(h) || h < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = o, this.left = u, this.right = h
          }
          interpolate(e, o, u) {
            return o.top != null && e.top != null && (this.top = c.F.number(e.top, o.top, u)), o.bottom != null && e.bottom != null && (this.bottom = c.F.number(e.bottom, o.bottom, u)), o.left != null && e.left != null && (this.left = c.F.number(e.left, o.left, u)), o.right != null && e.right != null && (this.right = c.F.number(e.right, o.right, u)), this
          }
          getCenter(e, o) {
            const u = c.ai((this.left + e - this.right) / 2, 0, e),
              h = c.ai((this.top + o - this.bottom) / 2, 0, o);
            return new c.P(u, h)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new bn(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function In(d, e) {
          if (!d.renderWorldCopies || d.lngRange) return;
          const o = e.lng - d.center.lng;
          e.lng += o > 180 ? -360 : o < -180 ? 360 : 0
        }

        function Ei(d) {
          return Math.max(0, Math.floor(d))
        }
        class Wn {
          constructor(e, o) {
            var u;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (o == null ? void 0 : o.renderWorldCopies) === void 0 || !!(o != null && o.renderWorldCopies), this._minZoom = (o == null ? void 0 : o.minZoom) || 0, this._maxZoom = (o == null ? void 0 : o.maxZoom) || 22, this._minPitch = (o == null ? void 0 : o.minPitch) == null ? 0 : o == null ? void 0 : o.minPitch, this._maxPitch = (o == null ? void 0 : o.maxPitch) == null ? 60 : o == null ? void 0 : o.maxPitch, this._constrain = (u = o == null ? void 0 : o.constrain) !== null && u !== void 0 ? u : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new c.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ei(this._zoom), this._scale = c.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new bn, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, o, u) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Ei(this._zoom), this._scale = c.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new bn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !u && e.autoCalculateNearFarZ, o && this.constrainInternal(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get constrain() {
            return this._constrain
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices()
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new c.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const o = c.V(e, -180, 180) * Math.PI / 180;
            var u, h, p, g, x, T, I, A, F;
            this._bearingInRadians !== o && (this._unmodified = !1, this._bearingInRadians = o, this._calcMatrices(), this._rotationMatrix = X(), u = this._rotationMatrix, p = -this._bearingInRadians, g = (h = this._rotationMatrix)[0], x = h[1], T = h[2], I = h[3], A = Math.sin(p), F = Math.cos(p), u[0] = g * F + T * A, u[1] = x * F + I * A, u[2] = g * -A + T * F, u[3] = x * -A + I * F)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const o = c.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== o && (this._unmodified = !1, this._pitchInRadians = o, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const o = e / 180 * Math.PI;
            this._rollInRadians !== o && (this._unmodified = !1, this._rollInRadians = o, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return c.aS(this._fovInRadians)
          }
          setFov(e) {
            e = c.ai(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = c.ak(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const o = this.constrain(this._center, e).zoom;
            this._zoom !== o && (this._unmodified = !1, this._zoom = o, this._tileZoom = Math.max(0, Math.floor(o)), this._scale = c.al(o), this.constrainInternal(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, o) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = o, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, o, u) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, o, u), this.constrainInternal(), this._calcMatrices()
          }
          resize(e, o, u = !0) {
            this._width = e, this._height = o, u && this.constrainInternal(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new ir([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-c.aj, c.aj])
          }
          getCameraQueryGeometry(e, o) {
            if (o.length === 1) return [o[0], e];
            {
              const {
                minX: u,
                minY: h,
                maxX: p,
                maxY: g
              } = c.a6.fromPoints(o).extend(e);
              return [new c.P(u, h), new c.P(p, h), new c.P(p, g), new c.P(u, g), new c.P(u, h)]
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: o,
                zoom: u
              } = this.constrain(this.center, this.zoom);
            this.setCenter(o), this.setZoom(u), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = c.am(new Float64Array(16));
              c.O(e, e, [this._width / 2, -this._height / 2, 1]), c.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = c.am(new Float64Array(16)), c.O(e, e, [1, -1, 1]), c.N(e, e, [-1, -1, 0]), c.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, o, u, h) {
            const p = u !== void 0 ? u : this.bearing,
              g = h = h !== void 0 ? h : this.pitch,
              x = c.a5.fromLngLat(e, o),
              T = -Math.cos(c.ak(g)),
              I = Math.sin(c.ak(g)),
              A = I * Math.sin(c.ak(p)),
              F = -I * Math.cos(c.ak(p));
            let L = this.elevation;
            const V = o - L;
            let K;
            T * V >= 0 || Math.abs(T) < .1 ? (K = 1e4, L = o + K * T) : K = -V / T;
            let it, ot, st = c.aT(1, x.y),
              pt = 0;
            do {
              if (pt += 1, pt > 10) break;
              ot = K / st, it = new c.a5(x.x + A * ot, x.y + F * ot), st = 1 / it.meterInMercatorCoordinateUnits()
            } while (Math.abs(K - ot * st) > 1e-12);
            return {
              center: it.toLngLat(),
              elevation: L,
              zoom: c.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / ot / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const o = c.an(1, this.center.lat) * this.worldSize,
              u = this.cameraToCenterDistance / o,
              h = c.a5.fromLngLat(this.center, this.elevation),
              p = W(this.center, this.elevation, this.pitch, this.bearing, u);
            this._elevation = e;
            const g = this.calculateCenterFromCameraLngLatAlt(p.toLngLat(), c.aT(p.z, h.y), this.bearing, this.pitch);
            this._elevation = g.elevation, this._center = g.center, this.setZoom(g.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new c.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = c.an(1, this.center.lat) * this.worldSize;
            return W(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const o = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / o, e.canonical.y / o, 1 / o / c.a3, 1 / o / c.a3]
          }
        }
        class ki {
          constructor(e, o) {
            this.min = e, this.max = o, this.center = c.aU([], c.aV([], this.min, this.max), .5)
          }
          quadrant(e) {
            const o = [e % 2 == 0, e < 2],
              u = c.aW(this.min),
              h = c.aW(this.max);
            for (let p = 0; p < o.length; p++) u[p] = o[p] ? this.min[p] : this.center[p], h[p] = o[p] ? this.center[p] : this.max[p];
            return h[2] = this.max[2], new ki(u, h)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let o = !0;
            for (let u = 0; u < e.planes.length; u++) {
              const h = this.intersectsPlane(e.planes[u]);
              if (h === 0) return 0;
              h === 1 && (o = !1)
            }
            return o ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let o = e[3],
              u = e[3];
            for (let h = 0; h < 3; h++) e[h] > 0 ? (o += e[h] * this.min[h], u += e[h] * this.max[h]) : (u += e[h] * this.min[h], o += e[h] * this.max[h]);
            return o >= 0 ? 2 : u < 0 ? 0 : 1
          }
        }
        class yi {
          distanceToTile2d(e, o, u, h) {
            const p = h.distanceX([e, o]),
              g = h.distanceY([e, o]);
            return Math.hypot(p, g)
          }
          getWrap(e, o, u) {
            return u
          }
          getTileBoundingVolume(e, o, u, h) {
            var p, g;
            let x = 0,
              T = 0;
            if (h != null && h.terrain) {
              const A = new c.a0(e.z, o, e.z, e.x, e.y),
                F = h.terrain.getMinMaxElevation(A);
              x = (p = F.minElevation) !== null && p !== void 0 ? p : Math.min(0, u), T = (g = F.maxElevation) !== null && g !== void 0 ? g : Math.max(0, u)
            }
            const I = 1 << e.z;
            return new ki([o + e.x / I, e.y / I, x], [o + (e.x + 1) / I, (e.y + 1) / I, T])
          }
          allowVariableZoom(e, o) {
            const u = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              h = c.ai(78.5 - u / 2, 0, 60);
            return !!o.terrain || e.pitch > h
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class Wi {
          constructor(e, o, u) {
            this.points = e, this.planes = o, this.aabb = u
          }
          static fromInvProjectionMatrix(e, o = 1, u = 0, h, p) {
            const g = p ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              x = Math.pow(2, u),
              T = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((L => (function(V, K, it, ot) {
                const st = c.aA([], V, K),
                  pt = 1 / st[3] / it * ot;
                return c.a$(st, st, [pt, pt, 1 / st[3], pt])
              })(L, e, o, x)));
            h && (function(L, V, K, it) {
              const ot = it ? 4 : 0,
                st = it ? 0 : 4;
              let pt = 0;
              const wt = [],
                dt = [];
              for (let gt = 0; gt < 4; gt++) {
                const Rt = c.aX([], L[gt + st], L[gt + ot]),
                  oe = c.b0(Rt);
                c.aU(Rt, Rt, 1 / oe), wt.push(oe), dt.push(Rt)
              }
              for (let gt = 0; gt < 4; gt++) {
                const Rt = c.b1(L[gt + ot], dt[gt], K);
                pt = Rt !== null && Rt >= 0 ? Math.max(pt, Rt) : Math.max(pt, wt[gt])
              }
              const kt = (function(gt, Rt) {
                  const oe = c.aX([], gt[Rt[0]], gt[Rt[1]]),
                    Qt = c.aX([], gt[Rt[2]], gt[Rt[1]]),
                    re = [0, 0, 0, 0];
                  return c.aY(re, c.aZ([], oe, Qt)), re[3] = -c.a_(re, gt[Rt[0]]), re
                })(L, V),
                It = (function(gt, Rt) {
                  const oe = c.b2(gt),
                    Qt = c.b3([], gt, 1 / oe),
                    re = c.aX([], Rt, c.aU([], Qt, c.a_(Rt, Qt))),
                    ue = c.b2(re);
                  if (ue > 0) {
                    const Je = Math.sqrt(1 - Qt[3] * Qt[3]),
                      tr = c.aU([], Qt, -Qt[3]),
                      Pe = c.aV([], tr, c.aU([], re, Je / ue));
                    return c.b4(Rt, Pe)
                  }
                  return null
                })(K, kt);
              if (It !== null) {
                const gt = It / c.a_(dt[0], kt);
                pt = Math.min(pt, gt)
              }
              for (let gt = 0; gt < 4; gt++) {
                const Rt = Math.min(pt, wt[gt]);
                L[gt + st] = [L[gt + ot][0] + dt[gt][0] * Rt, L[gt + ot][1] + dt[gt][1] * Rt, L[gt + ot][2] + dt[gt][2] * Rt, 1]
              }
            })(T, g[0], h, p);
            const I = g.map((L => {
                const V = c.aX([], T[L[0]], T[L[1]]),
                  K = c.aX([], T[L[2]], T[L[1]]),
                  it = c.aY([], c.aZ([], V, K)),
                  ot = -c.a_(it, T[L[1]]);
                return it.concat(ot)
              })),
              A = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              F = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const L of T)
              for (let V = 0; V < 3; V++) A[V] = Math.min(A[V], L[V]), F[V] = Math.max(F[V], L[V]);
            return new Wi(T, I, new ki(A, F))
          }
        }
        class $i {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, o, u) {
            return this._helper.interpolatePadding(e, o, u)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, o, u = !0) {
            this._helper.resize(e, o, u)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, o) {
            this._helper.overrideNearFarZ(e, o)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, o) {}
          constructor(e) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (o, u) => {
              u = c.ai(+u, this.minZoom, this.maxZoom);
              const h = {
                center: new c.U(o.lng, o.lat),
                zoom: u
              };
              let p = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && p === null) {
                const dt = 179.9999999999;
                p = [-dt, dt]
              }
              const g = this.tileSize * c.al(h.zoom);
              let x = 0,
                T = g,
                I = 0,
                A = g,
                F = 0,
                L = 0;
              const {
                x: V,
                y: K
              } = this.size;
              if (this._helper._latRange) {
                const dt = this._helper._latRange;
                x = c.W(dt[1]) * g, T = c.W(dt[0]) * g, T - x < K && (F = K / (T - x))
              }
              p && (I = c.V(c.X(p[0]) * g, 0, g), A = c.V(c.X(p[1]) * g, 0, g), A < I && (A += g), A - I < V && (L = V / (A - I)));
              const {
                x: it,
                y: ot
              } = Nt(g, o);
              let st, pt;
              const wt = Math.max(L || 0, F || 0);
              if (wt) {
                const dt = new c.P(L ? (A + I) / 2 : it, F ? (T + x) / 2 : ot);
                return h.center = ie(g, dt).wrap(), h.zoom += c.ao(wt), h
              }
              if (this._helper._latRange) {
                const dt = K / 2;
                ot - dt < x && (pt = x + dt), ot + dt > T && (pt = T - dt)
              }
              if (p) {
                const dt = (I + A) / 2;
                let kt = it;
                this._helper._renderWorldCopies && (kt = c.V(it, dt - g / 2, dt + g / 2));
                const It = V / 2;
                kt - It < I && (st = I + It), kt + It > A && (st = A - It)
              }
              if (st !== void 0 || pt !== void 0) {
                const dt = new c.P(st ?? it, pt ?? ot);
                h.center = ie(g, dt).wrap()
              }
              return h
            }, this._helper = new Wn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (o, u) => this.defaultConstrain(o, u)
            }, e), this._coveringTilesDetailsProvider = new yi
          }
          clone() {
            const e = new $i;
            return e.apply(this), e
          }
          apply(e, o, u) {
            this._helper.apply(e, o, u)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const o = [new c.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const u = this.screenPointToMercatorCoordinate(new c.P(0, 0)),
                h = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, 0)),
                p = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, this._helper._height)),
                g = this.screenPointToMercatorCoordinate(new c.P(0, this._helper._height)),
                x = Math.floor(Math.min(u.x, h.x, p.x, g.x)),
                T = Math.floor(Math.max(u.x, h.x, p.x, g.x)),
                I = 1;
              for (let A = x - I; A <= T + I; A++) A !== 0 && o.push(new c.b5(A, e))
            }
            return o
          }
          getCameraFrustum() {
            return Wi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const o = this.screenPointToLocation(this.centerPoint, e),
              u = e ? e.getElevationForLngLatZoom(o, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(u)
          }
          setLocationAtPoint(e, o) {
            const u = c.an(this.elevation, this.center.lat),
              h = this.screenPointToMercatorCoordinateAtZ(o, u),
              p = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, u),
              g = c.a5.fromLngLat(e),
              x = new c.a5(g.x - (h.x - p.x), g.y - (h.y - p.y));
            this.setCenter(x == null ? void 0 : x.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, o) {
            return o ? this.coordinatePoint(c.a5.fromLngLat(e), o.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(c.a5.fromLngLat(e))
          }
          screenPointToLocation(e, o) {
            var u;
            return (u = this.screenPointToMercatorCoordinate(e, o)) === null || u === void 0 ? void 0 : u.toLngLat()
          }
          screenPointToMercatorCoordinate(e, o) {
            if (o) {
              const u = o.pointCoordinate(e);
              if (u != null) return u
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, o) {
            const u = o || 0,
              h = [e.x, e.y, 0, 1],
              p = [e.x, e.y, 1, 1];
            c.aA(h, h, this._pixelMatrixInverse), c.aA(p, p, this._pixelMatrixInverse);
            const g = h[3],
              x = p[3],
              T = h[1] / g,
              I = p[1] / x,
              A = h[2] / g,
              F = p[2] / x,
              L = A === F ? 0 : (u - A) / (F - A);
            return new c.a5(c.F.number(h[0] / g, p[0] / x, L) / this.worldSize, c.F.number(T, I, L) / this.worldSize, u)
          }
          coordinatePoint(e, o = 0, u = this._pixelMatrix) {
            const h = [e.x * this.worldSize, e.y * this.worldSize, o, 1];
            return c.aA(h, h, u), new c.P(h[0] / h[3], h[1] / h[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - mt(this));
            return new ir().extend(this.screenPointToLocation(new c.P(0, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new c.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, o) {
            return o ? o.pointCoordinate(e) != null : e.y > this.height / 2 - mt(this)
          }
          calculatePosMatrix(e, o = !1, u) {
            var h;
            const p = (h = e.key) !== null && h !== void 0 ? h : c.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              g = o ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (g.has(p)) {
              const I = g.get(p);
              return u ? I.f32 : I.f64
            }
            const x = et(e, this.worldSize);
            c.Q(x, o ? this._alignedProjMatrix : this._viewProjMatrix, x);
            const T = {
              f64: x,
              f32: new Float32Array(x)
            };
            return g.set(p, T), u ? T.f32 : T.f64
          }
          calculateFogMatrix(e) {
            const o = e.key,
              u = this._fogMatrixCacheF32;
            if (u.has(o)) return u.get(o);
            const h = et(e, this.worldSize);
            return c.Q(h, this._fogMatrix, h), u.set(o, new Float32Array(h)), u.get(o)
          }
          calculateCenterFromCameraLngLatAlt(e, o, u, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, o, u, h)
          }
          _calculateNearFarZIfNeeded(e, o, u) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const h = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              p = e - h * this._helper._pixelPerMeter / Math.cos(o),
              g = h < 0 ? p : e,
              x = Math.PI / 2 + this.pitchInRadians,
              T = c.ak(this.fov) * (Math.abs(Math.cos(c.ak(this.roll))) * this.height + Math.abs(Math.sin(c.ak(this.roll))) * this.width) / this.height * (.5 + u.y / this.height),
              I = Math.sin(T) * g / Math.sin(c.ai(Math.PI - x - T, .01, Math.PI - .01)),
              A = mt(this),
              F = Math.atan(A / this._helper.cameraToCenterDistance),
              L = c.ak(.75),
              V = F > L ? 2 * F * (.5 + u.y / (2 * A)) : L,
              K = Math.sin(V) * g / Math.sin(c.ai(Math.PI - x - V, .01, Math.PI - .01)),
              it = Math.min(I, K);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - o) * it + g), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              o = Nt(this.worldSize, this.center),
              u = o.x,
              h = o.y;
            this._helper._pixelPerMeter = c.an(1, this.center.lat) * this.worldSize;
            const p = c.ak(Math.min(this.pitch, zt)),
              g = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(p));
            let x;
            this._calculateNearFarZIfNeeded(g, p, e), x = new Float64Array(16), c.b7(x, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), c.au(this._invProjMatrix, x), x[8] = 2 * -e.x / this._helper._width, x[9] = 2 * e.y / this._helper._height, this._projectionMatrix = c.b8(x), c.O(x, x, [1, -1, 1]), c.N(x, x, [0, 0, -this._helper.cameraToCenterDistance]), c.b9(x, x, -this.rollInRadians), c.ba(x, x, this.pitchInRadians), c.b9(x, x, -this.bearingInRadians), c.N(x, x, [-u, -h, 0]), this._mercatorMatrix = c.O([], x, [this.worldSize, this.worldSize, this.worldSize]), c.O(x, x, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = c.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, x), c.N(x, x, [0, 0, -this.elevation]), this._viewProjMatrix = x, this._invViewProjMatrix = c.au([], x);
            const T = [0, 0, -1, 1];
            c.aA(T, T, this._invViewProjMatrix), this._cameraPosition = [T[0] / T[3], T[1] / T[3], T[2] / T[3]], this._fogMatrix = new Float64Array(16), c.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, g, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, c.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), c.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), c.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), c.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), c.N(this._fogMatrix, this._fogMatrix, [-u, -h, 0]), c.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), c.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = c.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, x);
            const I = this._helper._width % 2 / 2,
              A = this._helper._height % 2 / 2,
              F = Math.cos(this.bearingInRadians),
              L = Math.sin(-this.bearingInRadians),
              V = u - Math.round(u) + F * I + L * A,
              K = h - Math.round(h) + F * A + L * I,
              it = new Float64Array(x);
            if (c.N(it, it, [V > .5 ? V - 1 : V, K > .5 ? K - 1 : K, 0]), this._alignedProjMatrix = it, x = c.au(new Float64Array(16), this._pixelMatrix), !x) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = x, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new c.P(0, 0)),
              o = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return c.aA(o, o, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = c.an(1, this.center.lat) * this.worldSize;
            return W(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, o) {
            const u = c.a5.fromLngLat(e),
              h = [u.x * this.worldSize, u.y * this.worldSize, o, 1];
            return c.aA(h, h, this._viewProjMatrix), h[2] / h[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: o,
              aligned: u,
              applyTerrainMatrix: h
            } = e, p = this._helper.getMercatorTileCoordinates(o), g = o ? this.calculatePosMatrix(o, u, !0) : null;
            let x;
            return x = o && o.terrainRttPosMatrix32f && h ? o.terrainRttPosMatrix32f : g || c.bb(), {
              mainMatrix: x,
              tileMercatorCoords: p,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: x
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, o, u) {
            return 1
          }
          transformLightDirection(e) {
            return c.aW(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, o, u, h) {
            const p = this.calculatePosMatrix(u);
            let g;
            h ? (g = [e, o, h(e, o), 1], c.aA(g, g, p)) : (g = [e, o, 0, 1], ln(g, g, p));
            const x = g[3];
            return {
              point: new c.P(g[0] / x, g[1] / x),
              signedDistanceFromCamera: x,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const o of e) this.calculatePosMatrix(o)
          }
          getMatrixForModel(e, o) {
            const u = c.a5.fromLngLat(e, o),
              h = u.meterInMercatorCoordinateUnits(),
              p = c.bc();
            return c.N(p, p, [u.x, u.y, u.z]), c.b9(p, p, Math.PI), c.ba(p, p, Math.PI / 2), c.O(p, p, [-h, h, h]), p
          }
          getProjectionDataForCustomLayer(e = !0) {
            const o = new c.a0(0, 0, 0, 0, 0),
              u = this.getProjectionData({
                overscaledTileID: o,
                applyGlobeMatrix: e
              }),
              h = et(o, this.worldSize);
            c.Q(h, this._viewProjMatrix, h), u.tileMercatorCoords = [0, 0, 1, 1];
            const p = [c.a3, c.a3, this.worldSize / this._helper.pixelsPerMeter],
              g = c.bd();
            return c.O(g, h, p), u.fallbackMatrix = g, u.mainMatrix = g, u
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function Yn() {
          c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function ai(d) {
          if (d.useSlerp)
            if (d.k < 1) {
              const e = c.be(d.startEulerAngles.roll, d.startEulerAngles.pitch, d.startEulerAngles.bearing),
                o = c.be(d.endEulerAngles.roll, d.endEulerAngles.pitch, d.endEulerAngles.bearing),
                u = new Float64Array(4);
              c.bf(u, e, o, d.k);
              const h = c.bg(u);
              d.tr.setRoll(h.roll), d.tr.setPitch(h.pitch), d.tr.setBearing(h.bearing)
            } else d.tr.setRoll(d.endEulerAngles.roll), d.tr.setPitch(d.endEulerAngles.pitch), d.tr.setBearing(d.endEulerAngles.bearing);
          else d.tr.setRoll(c.F.number(d.startEulerAngles.roll, d.endEulerAngles.roll, d.k)), d.tr.setPitch(c.F.number(d.startEulerAngles.pitch, d.endEulerAngles.pitch, d.k)), d.tr.setBearing(c.F.number(d.startEulerAngles.bearing, d.endEulerAngles.bearing, d.k))
        }

        function pi(d, e, o, u, h) {
          const p = h.padding,
            g = Nt(h.worldSize, o.getNorthWest()),
            x = Nt(h.worldSize, o.getNorthEast()),
            T = Nt(h.worldSize, o.getSouthEast()),
            I = Nt(h.worldSize, o.getSouthWest()),
            A = c.ak(-u),
            F = g.rotate(A),
            L = x.rotate(A),
            V = T.rotate(A),
            K = I.rotate(A),
            it = new c.P(Math.max(F.x, L.x, K.x, V.x), Math.max(F.y, L.y, K.y, V.y)),
            ot = new c.P(Math.min(F.x, L.x, K.x, V.x), Math.min(F.y, L.y, K.y, V.y)),
            st = it.sub(ot),
            pt = (h.width - (p.left + p.right + e.left + e.right)) / st.x,
            wt = (h.height - (p.top + p.bottom + e.top + e.bottom)) / st.y;
          if (wt < 0 || pt < 0) return void Yn();
          const dt = Math.min(c.ao(h.scale * Math.min(pt, wt)), d.maxZoom),
            kt = c.P.convert(d.offset),
            It = new c.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(c.ak(u)),
            gt = kt.add(It).mult(h.scale / c.al(dt));
          return {
            center: ie(h.worldSize, g.add(T).div(2).sub(gt)),
            zoom: dt,
            bearing: u
          }
        }
        class ji {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, o) {
            const u = e.mag(),
              h = Math.abs(mt(o));
            return {
              easingOffset: e.mult(Math.min(.75 * h / u, 1)),
              easingCenter: o.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, o) {
            e.bearingDelta && o.setBearing(o.bearing + e.bearingDelta), e.pitchDelta && o.setPitch(o.pitch + e.pitchDelta), e.rollDelta && o.setRoll(o.roll + e.rollDelta), e.zoomDelta && o.setZoom(o.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, o, u) {
            e.around.distSqr(o.centerPoint) < .01 || o.setLocationAtPoint(u, e.around)
          }
          cameraForBoxAndBearing(e, o, u, h, p) {
            return pi(e, o, u, h, p)
          }
          handleJumpToCenterZoom(e, o) {
            e.zoom !== (o.zoom !== void 0 ? +o.zoom : e.zoom) && e.setZoom(+o.zoom), o.center !== void 0 && e.setCenter(c.U.convert(o.center))
          }
          handleEaseTo(e, o) {
            const u = e.zoom,
              h = e.padding,
              p = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              g = {
                roll: o.roll === void 0 ? e.roll : o.roll,
                pitch: o.pitch === void 0 ? e.pitch : o.pitch,
                bearing: o.bearing === void 0 ? e.bearing : o.bearing
              },
              x = o.zoom !== void 0,
              T = !e.isPaddingEqual(o.padding);
            let I = !1;
            const A = x ? +o.zoom : e.zoom;
            let F = e.centerPoint.add(o.offsetAsPoint);
            const L = e.screenPointToLocation(F),
              {
                center: V,
                zoom: K
              } = e.constrain(c.U.convert(o.center || L), A ?? u);
            In(e, V);
            const it = Nt(e.worldSize, L),
              ot = Nt(e.worldSize, V).sub(it),
              st = c.al(K - u);
            return I = K !== u, {
              easeFunc: pt => {
                if (I && e.setZoom(c.F.number(u, K, pt)), c.bh(p, g) || ai({
                    startEulerAngles: p,
                    endEulerAngles: g,
                    tr: e,
                    k: pt,
                    useSlerp: p.roll != g.roll
                  }), T && (e.interpolatePadding(h, o.padding, pt), F = e.centerPoint.add(o.offsetAsPoint)), o.around) e.setLocationAtPoint(o.around, o.aroundPoint);
                else {
                  const wt = c.al(e.zoom - u),
                    dt = K > u ? Math.min(2, st) : Math.max(.5, st),
                    kt = Math.pow(dt, 1 - pt),
                    It = ie(e.worldSize, it.add(ot.mult(pt * kt)).mult(wt));
                  e.setLocationAtPoint(e.renderWorldCopies ? It.wrap() : It, F)
                }
              },
              isZooming: I,
              elevationCenter: V
            }
          }
          handleFlyTo(e, o) {
            const u = o.zoom !== void 0,
              h = e.zoom,
              p = e.constrain(c.U.convert(o.center || o.locationAtOffset), u ? +o.zoom : h),
              g = p.center,
              x = p.zoom;
            In(e, g);
            const T = Nt(e.worldSize, o.locationAtOffset),
              I = Nt(e.worldSize, g).sub(T),
              A = I.mag(),
              F = c.al(x - h);
            let L;
            if (o.minZoom !== void 0) {
              const V = Math.min(+o.minZoom, h, x),
                K = e.constrain(g, V).zoom;
              L = c.al(K - h)
            }
            return {
              easeFunc: (V, K, it, ot) => {
                e.setZoom(V === 1 ? x : h + c.ao(K));
                const st = V === 1 ? g : ie(e.worldSize, T.add(I.mult(it)).mult(K));
                e.setLocationAtPoint(e.renderWorldCopies ? st.wrap() : st, ot)
              },
              scaleOfZoom: F,
              targetCenter: g,
              scaleOfMinZoom: L,
              pixelPathLength: A
            }
          }
        }
        class Sn {
          constructor(e, o, u) {
            this.blendFunction = e, this.blendColor = o, this.mask = u
          }
        }
        Sn.Replace = [1, 0], Sn.disabled = new Sn(Sn.Replace, c.bi.transparent, [!1, !1, !1, !1]), Sn.unblended = new Sn(Sn.Replace, c.bi.transparent, [!0, !0, !0, !0]), Sn.alphaBlended = new Sn([1, 771], c.bi.transparent, [!0, !0, !0, !0]);
        const jo = 2305;
        class pn {
          constructor(e, o, u) {
            this.enable = e, this.mode = o, this.frontFace = u
          }
        }
        pn.disabled = new pn(!1, 1029, jo), pn.backCCW = new pn(!0, 1029, jo), pn.frontCCW = new pn(!0, 1028, jo);
        class mn {
          constructor(e, o, u) {
            this.func = e, this.mask = o, this.range = u
          }
        }
        mn.ReadOnly = !1, mn.ReadWrite = !0, mn.disabled = new mn(519, mn.ReadOnly, [0, 1]);
        const Ko = 7680;
        class En {
          constructor(e, o, u, h, p, g) {
            this.test = e, this.ref = o, this.mask = u, this.fail = h, this.depthFail = p, this.pass = g
          }
        }
        En.disabled = new En({
          func: 519,
          mask: 0
        }, 0, 0, Ko, Ko, Ko);
        const wo = new WeakMap;

        function ro(d) {
          var e;
          if (wo.has(d)) return wo.get(d);
          {
            const o = (e = d.getParameter(d.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return wo.set(d, o), o
          }
        }
        class Oo {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const o = e.context,
              u = o.gl;
            this._texFormat = u.RGBA, this._texType = u.UNSIGNED_BYTE;
            const h = new c.aP;
            h.emplaceBack(-1, -1), h.emplaceBack(2, -1), h.emplaceBack(-1, 2);
            const p = new c.aR;
            p.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Cn(o.createVertexBuffer(h, kn.members), o.createIndexBuffer(p), c.aQ.simpleSegment(0, 0, h.length, p.length)), this._resultBuffer = new Uint8Array(4), o.activeTexture.set(u.TEXTURE1);
            const g = u.createTexture();
            u.bindTexture(u.TEXTURE_2D, g), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texImage2D(u.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = o.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(g), ro(u) && (this._pbo = u.createBuffer(), u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.bufferData(u.PIXEL_PACK_BUFFER, 4, u.STREAM_READ), u.bindBuffer(u.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, o) {
            const u = this._updateCount;
            return this._readbackQueue ? u >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : u >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, o), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              o = e.gl;
            e.activeTexture.set(o.TEXTURE1), o.bindTexture(o.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, o) {
            const u = this._cachedRenderContext.context,
              h = u.gl;
            if (this._bindFramebuffer(), u.viewport.set([0, 0, this._texWidth, this._texHeight]), u.clear({
                color: c.bi.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(u, h.TRIANGLES, mn.disabled, En.disabled, Sn.unblended, pn.disabled, ((p, g) => ({
                u_input: p,
                u_output_expected: g
              }))(e, o), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ro(h)) {
              h.bindBuffer(h.PIXEL_PACK_BUFFER, this._pbo), h.readBuffer(h.COLOR_ATTACHMENT0), h.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), h.bindBuffer(h.PIXEL_PACK_BUFFER, null);
              const p = h.fenceSync(h.SYNC_GPU_COMMANDS_COMPLETE, 0);
              h.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: p
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && ro(e)) {
              const o = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (o === e.WAIT_FAILED) return c.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (o === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Oo._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let o = 0;
            return o += e[0] / 256, o += e[1] / 65536, o += e[2] / 16777216, e[3] < 127 && (o = -o), o / 128
          }
        }
        const ko = c.a3 / 128;

        function Jo(d, e) {
          const o = d.granularity !== void 0 ? Math.max(d.granularity, 1) : 1,
            u = o + (d.generateBorders ? 2 : 0),
            h = o + (d.extendToNorthPole || d.generateBorders ? 1 : 0) + (d.extendToSouthPole || d.generateBorders ? 1 : 0),
            p = u + 1,
            g = h + 1,
            x = d.generateBorders ? -1 : 0,
            T = d.generateBorders || d.extendToNorthPole ? -1 : 0,
            I = o + (d.generateBorders ? 1 : 0),
            A = o + (d.generateBorders || d.extendToSouthPole ? 1 : 0),
            F = p * g,
            L = u * h * 6,
            V = p * g > 65536;
          if (V && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const K = V || e === "32bit",
            it = new Int16Array(2 * F);
          let ot = 0;
          for (let wt = T; wt <= A; wt++)
            for (let dt = x; dt <= I; dt++) {
              let kt = dt / o * c.a3;
              dt === -1 && (kt = -ko), dt === o + 1 && (kt = c.a3 + ko);
              let It = wt / o * c.a3;
              wt === -1 && (It = d.extendToNorthPole ? c.bk : -ko), wt === o + 1 && (It = d.extendToSouthPole ? c.bl : c.a3 + ko), it[ot++] = kt, it[ot++] = It
            }
          const st = K ? new Uint32Array(L) : new Uint16Array(L);
          let pt = 0;
          for (let wt = 0; wt < h; wt++)
            for (let dt = 0; dt < u; dt++) {
              const kt = dt + 1 + wt * p,
                It = dt + (wt + 1) * p,
                gt = dt + 1 + (wt + 1) * p;
              st[pt++] = dt + wt * p, st[pt++] = It, st[pt++] = kt, st[pt++] = kt, st[pt++] = It, st[pt++] = gt
            }
          return {
            vertices: it.buffer.slice(0),
            indices: st.buffer.slice(0),
            uses32bitIndices: K
          }
        }
        const Lo = new c.aO({
          fill: new c.bm(128, 2),
          line: new c.bm(512, 0),
          tile: new c.bm(128, 32),
          stencil: new c.bm(128, 1),
          circle: 3
        });
        class Qo {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return Ur.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return Ur.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return Lo
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Oo(e));
            const o = c.W(this._errorQueryLatitudeDegrees),
              u = 2 * Math.atan(Math.exp(Math.PI - o * Math.PI * 2)) - .5 * Math.PI,
              h = this._errorMeasurement.updateErrorLoop(o, u),
              p = lt();
            h !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = h, this._errorMeasurementLastChangeTime = p);
            const g = Math.min(Math.max((p - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = c.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, c.bo(g))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, o, u, h, p) {
            const g = (p === "stencil" ? Lo.stencil : Lo.tile).getGranularityForZoomLevel(o.z);
            return this._getMesh(e, {
              granularity: g,
              generateBorders: u,
              extendToNorthPole: o.y === 0 && h,
              extendToSouthPole: o.y === (1 << o.z) - 1 && h
            })
          }
          _getMesh(e, o) {
            const u = this._getMeshKey(o);
            if (u in this._tileMeshCache) return this._tileMeshCache[u];
            const h = (function(p, g) {
              const x = Jo(g, "16bit"),
                T = c.aP.deserialize({
                  arrayBuffer: x.vertices,
                  length: x.vertices.byteLength / 2 / 2
                }),
                I = c.aR.deserialize({
                  arrayBuffer: x.indices,
                  length: x.indices.byteLength / 2 / 3
                });
              return new Cn(p.createVertexBuffer(T, kn.members), p.createIndexBuffer(I), c.aQ.simpleSegment(0, 0, T.length, I.length))
            })(e, o);
            return this._tileMeshCache[u] = h, h
          }
          recalculate(e) {}
          hasTransition() {
            const e = lt();
            let o = !1;
            return o = o || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, o = o || this._errorMeasurement && this._errorMeasurement.awaitingQuery, o
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const Ts = new c.r({
          type: new c.D(c.t.projection.type)
        });
        class vi extends c.E {
          constructor(e) {
            super(), this._transitionable = new c.x(Ts, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.G(0)), this._mercatorProjection = new Vn, this._verticalPerspectiveProjection = new Qo
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof c.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, o, u, h, p) {
            return this.currentProjection.getMeshFromTileID(e, o, u, h, p)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function Ti(d) {
          const e = qo(d.worldSize, d.center.lat);
          return 2 * Math.PI * e
        }

        function po(d, e, o, u, h) {
          const p = 1 / (1 << h),
            g = e / c.a3 * p + u * p,
            x = c.br((d / c.a3 * p + o * p) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            T = 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI,
            I = Math.cos(T),
            A = new Float64Array(3);
          return A[0] = Math.sin(x) * I, A[1] = Math.sin(T), A[2] = Math.cos(x) * I, A
        }

        function ui(d) {
          return (function(e, o) {
            const u = Math.cos(o),
              h = new Float64Array(3);
            return h[0] = Math.sin(e) * u, h[1] = Math.sin(o), h[2] = Math.cos(e) * u, h
          })(d.lng * Math.PI / 180, d.lat * Math.PI / 180)
        }

        function qo(d, e) {
          return d / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function Bs(d) {
          const e = Math.asin(d[1]) / Math.PI * 180,
            o = Math.sqrt(d[0] * d[0] + d[2] * d[2]);
          if (o > 1e-6) {
            const u = d[0] / o,
              h = Math.acos(d[2] / o),
              p = (u > 0 ? h : -h) / Math.PI * 180;
            return new c.U(c.V(p, -180, 180), e)
          }
          return new c.U(0, e)
        }

        function ya(d) {
          return Math.cos(d * Math.PI / 180)
        }

        function Un(d, e) {
          const o = ya(d),
            u = ya(e);
          return c.ao(u / o)
        }

        function xu(d, e) {
          const o = d.rotate(e.bearingInRadians),
            u = e.zoom + Un(e.center.lat, 0),
            h = c.bn(1 / ya(e.center.lat), 1 / ya(Math.min(Math.abs(e.center.lat), 60)), c.bq(u, 7, 3, 0, 1)),
            p = 360 / Ti({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new c.U(e.center.lng - o.x * p * h, c.ai(e.center.lat + o.y * p, -c.aj, c.aj))
        }

        function Do(d) {
          const e = .5 * d,
            o = Math.sin(e),
            u = Math.cos(e);
          return Math.log(o + u) - Math.log(u - o)
        }

        function Na(d, e, o, u) {
          const h = d.lat + o * u;
          if (Math.abs(o) > 1) {
            const p = (Math.sign(d.lat + o) !== Math.sign(d.lat) ? -Math.abs(d.lat) : Math.abs(d.lat)) * Math.PI / 180,
              g = Math.abs(d.lat + o) * Math.PI / 180,
              x = Do(p + u * (g - p)),
              T = Do(p),
              I = Do(g);
            return new c.U(d.lng + e * ((x - T) / (I - T)), h)
          }
          return new c.U(d.lng + e * u, h)
        }
        class L_ {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, o, u, h) {
            const p = `${e.z}_${e.x}_${e.y}_${h!=null&&h.terrain?"t":""}`,
              g = this._cache.get(p);
            if (g) return g;
            const x = this._cachePrevious.get(p);
            if (x) return this._cache.set(p, x), x;
            const T = this._boundingVolumeFactory(e, o, u, h);
            return this._cache.set(p, T), this._hadAnyChanges = !0, T
          }
        }
        class Fs {
          constructor(e, o, u, h) {
            this.min = u, this.max = h, this.points = e, this.planes = o
          }
          static fromAabb(e, o) {
            const u = [];
            for (let h = 0; h < 8; h++) u.push([1 & ~h ? e[0] : o[0], (h >> 1 & 1) == 1 ? o[1] : e[1], (h >> 2 & 1) == 1 ? o[2] : e[2]]);
            return new Fs(u, [
              [-1, 0, 0, o[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, o[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, o[2]],
              [0, 0, 1, -e[2]]
            ], e, o)
          }
          static fromCenterSizeAngles(e, o, u) {
            const h = c.bu([], u[0], u[1], u[2]),
              p = c.bv([], [o[0], 0, 0], h),
              g = c.bv([], [0, o[1], 0], h),
              x = c.bv([], [0, 0, o[2]], h),
              T = [...e],
              I = [...e];
            for (let F = 0; F < 8; F++)
              for (let L = 0; L < 3; L++) {
                const V = e[L] + p[L] * (1 & ~F ? -1 : 1) + g[L] * ((F >> 1 & 1) == 1 ? 1 : -1) + x[L] * ((F >> 2 & 1) == 1 ? 1 : -1);
                T[L] = Math.min(T[L], V), I[L] = Math.max(I[L], V)
              }
            const A = [];
            for (let F = 0; F < 8; F++) {
              const L = [...e];
              c.aV(L, L, c.aU([], p, 1 & ~F ? -1 : 1)), c.aV(L, L, c.aU([], g, (F >> 1 & 1) == 1 ? 1 : -1)), c.aV(L, L, c.aU([], x, (F >> 2 & 1) == 1 ? 1 : -1)), A.push(L)
            }
            return new Fs(A, [
              [...p, -c.a_(p, A[0])],
              [...g, -c.a_(g, A[0])],
              [...x, -c.a_(x, A[0])],
              [-p[0], -p[1], -p[2], -c.a_(p, A[7])],
              [-g[0], -g[1], -g[2], -c.a_(g, A[7])],
              [-x[0], -x[1], -x[2], -c.a_(x, A[7])]
            ], T, I)
          }
          intersectsFrustum(e) {
            let o = !0;
            const u = this.points.length,
              h = this.planes.length,
              p = e.planes.length,
              g = e.points.length;
            for (let x = 0; x < p; x++) {
              const T = e.planes[x];
              let I = 0;
              for (let A = 0; A < u; A++) {
                const F = this.points[A];
                T[0] * F[0] + T[1] * F[1] + T[2] * F[2] + T[3] >= 0 && I++
              }
              if (I === 0) return 0;
              I < u && (o = !1)
            }
            if (o) return 2;
            for (let x = 0; x < h; x++) {
              const T = this.planes[x];
              let I = 0;
              for (let A = 0; A < g; A++) {
                const F = e.points[A];
                T[0] * F[0] + T[1] * F[1] + T[2] * F[2] + T[3] >= 0 && I++
              }
              if (I === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const o = this.points.length;
            let u = 0;
            for (let h = 0; h < o; h++) {
              const p = this.points[h];
              e[0] * p[0] + e[1] * p[1] + e[2] * p[2] + e[3] >= 0 && u++
            }
            return u === o ? 2 : u === 0 ? 0 : 1
          }
        }

        function ss(d, e, o) {
          const u = d - e;
          return u < 0 ? -u : Math.max(0, u - o)
        }

        function Lc(d, e, o, u, h) {
          const p = d - o;
          let g;
          return g = p < 0 ? Math.min(-p, 1 + p - h) : p > 1 ? Math.min(Math.max(p - h, 0), 1 - p) : 0, Math.max(g, ss(e, u, h))
        }
        class Ed {
          constructor() {
            this._boundingVolumeCache = new L_(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, o, u, h) {
            const p = 1 << u.z,
              g = 1 / p,
              x = u.x / p,
              T = u.y / p;
            let I = 2;
            return I = Math.min(I, Lc(e, o, x, T, g)), I = Math.min(I, Lc(e, o, x + .5, -T - g, g)), I = Math.min(I, Lc(e, o, x + .5, 2 - T - g, g)), I
          }
          getWrap(e, o, u) {
            const h = 1 << o.z,
              p = 1 / h,
              g = o.x / h,
              x = ss(e.x, g, p),
              T = ss(e.x, g - 1, p),
              I = ss(e.x, g + 1, p),
              A = Math.min(x, T, I);
            return A === I ? 1 : A === T ? -1 : 0
          }
          allowVariableZoom(e, o) {
            return ae(e, o) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, o, u, h) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, o, u, h)
          }
          _computeTileBoundingVolume(e, o, u, h) {
            var p, g;
            let x = 0,
              T = 0;
            if (h != null && h.terrain) {
              const I = new c.a0(e.z, o, e.z, e.x, e.y),
                A = h.terrain.getMinMaxElevation(I);
              x = (p = A.minElevation) !== null && p !== void 0 ? p : Math.min(0, u), T = (g = A.maxElevation) !== null && g !== void 0 ? g : Math.max(0, u)
            }
            if (x /= c.bx, T /= c.bx, x += 1, T += 1, e.z <= 0) return Fs.fromAabb([-T, -T, -T], [T, T, T]);
            if (e.z === 1) return Fs.fromAabb([e.x === 0 ? -T : 0, e.y === 0 ? 0 : -T, -T], [e.x === 0 ? 0 : T, e.y === 0 ? T : 0, T]);
            {
              const I = [po(0, 0, e.x, e.y, e.z), po(c.a3, 0, e.x, e.y, e.z), po(c.a3, c.a3, e.x, e.y, e.z), po(0, c.a3, e.x, e.y, e.z)],
                A = [];
              for (const re of I) A.push(c.aU([], re, T));
              if (T !== x)
                for (const re of I) A.push(c.aU([], re, x));
              e.y === 0 && A.push([0, 1, 0]), e.y === (1 << e.z) - 1 && A.push([0, -1, 0]);
              const F = [1, 1, 1],
                L = [-1, -1, -1];
              for (const re of A)
                for (let ue = 0; ue < 3; ue++) F[ue] = Math.min(F[ue], re[ue]), L[ue] = Math.max(L[ue], re[ue]);
              const V = po(c.a3 / 2, c.a3 / 2, e.x, e.y, e.z),
                K = c.aZ([], [0, 1, 0], V);
              c.aY(K, K);
              const it = c.aZ([], V, K);
              c.aY(it, it);
              const ot = c.aZ([], I[2], I[1]);
              c.aY(ot, ot);
              const st = c.aZ([], I[0], I[3]);
              c.aY(st, st), A.push(c.aU([], V, T)), e.y >= (1 << e.z) / 2 && A.push(c.aU([], po(c.a3 / 2, 0, e.x, e.y, e.z), T)), e.y < (1 << e.z) / 2 && A.push(c.aU([], po(c.a3 / 2, c.a3, e.x, e.y, e.z), T));
              const pt = D_(V, A),
                wt = D_(it, A),
                dt = [-V[0], -V[1], -V[2], pt.max],
                kt = [V[0], V[1], V[2], -pt.min],
                It = [-it[0], -it[1], -it[2], wt.max],
                gt = [it[0], it[1], it[2], -wt.min],
                Rt = [...ot, 0],
                oe = [...st, 0],
                Qt = [];
              return e.y === 0 ? Qt.push(c.bw(oe, Rt, dt), c.bw(oe, Rt, kt)) : Qt.push(c.bw(It, Rt, dt), c.bw(It, Rt, kt), c.bw(It, oe, dt), c.bw(It, oe, kt)), e.y === (1 << e.z) - 1 ? Qt.push(c.bw(oe, Rt, dt), c.bw(oe, Rt, kt)) : Qt.push(c.bw(gt, Rt, dt), c.bw(gt, Rt, kt), c.bw(gt, oe, dt), c.bw(gt, oe, kt)), new Fs(Qt, [dt, kt, It, gt, Rt, oe], F, L)
            }
          }
        }

        function D_(d, e) {
          let o = 1 / 0,
            u = -1 / 0;
          for (const h of e) {
            const p = c.a_(d, h);
            o = Math.min(o, p), u = Math.max(u, p)
          }
          return {
            min: o,
            max: u
          }
        }
        class wu {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, o, u) {
            return this._helper.interpolatePadding(e, o, u)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, o) {
            this._helper.resize(e, o)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, o) {
            this._helper.overrideNearFarZ(e, o)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor(e) {
            this._cachedClippingPlane = c.by(), this._projectionMatrix = c.bc(), this._globeViewProjMatrix32f = c.bb(), this._globeViewProjMatrixNoCorrection = c.bc(), this._globeViewProjMatrixNoCorrectionInverted = c.bc(), this._globeProjMatrixInverted = c.bc(), this._cameraPosition = c.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (o, u) => {
              const h = c.ai(o.lat, -c.aj, c.aj),
                p = c.ai(+u, this.minZoom + Un(0, h), this.maxZoom);
              return {
                center: new c.U(o.lng, h),
                zoom: p
              }
            }, this._helper = new Wn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (o, u) => this.defaultConstrain(o, u)
            }, e), this._coveringTilesDetailsProvider = new Ed
          }
          clone() {
            const e = new wu;
            return e.apply(this), e
          }
          apply(e, o) {
            this._globeLatitudeErrorCorrectionRadians = o || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = c.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: o,
              applyGlobeMatrix: u
            } = e, h = this._helper.getMercatorTileCoordinates(o);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: h,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: u ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const o = this.pitchInRadians,
              u = this.cameraToCenterDistance / e,
              h = Math.sin(o) * u,
              p = Math.cos(o) * u + 1,
              g = 1 / Math.sqrt(h * h + p * p) * 1;
            let x = -h,
              T = p;
            const I = Math.sqrt(x * x + T * T);
            x /= I, T /= I;
            const A = [0, x, T];
            c.bz(A, A, [0, 0, 0], -this.bearingInRadians), c.bA(A, A, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), c.bB(A, A, [0, 0, 0], this.center.lng * Math.PI / 180);
            const F = 1 / c.b0(A);
            return c.aU(A, A, F), [...A, -g * F]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(ui(e))
          }
          transformLightDirection(e) {
            const o = this._helper._center.lng * Math.PI / 180,
              u = this._helper._center.lat * Math.PI / 180,
              h = Math.cos(u),
              p = [Math.sin(o) * h, Math.sin(u), Math.cos(o) * h],
              g = [p[2], 0, -p[0]],
              x = [0, 0, 0];
            c.aZ(x, g, p), c.aY(g, g), c.aY(x, x);
            const T = [0, 0, 0];
            return c.aY(T, [g[0] * e[0] + x[0] * e[1] + p[0] * e[2], g[1] * e[0] + x[1] * e[1] + p[1] * e[2], g[2] * e[0] + x[2] * e[1] + p[2] * e[2]]), T
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, o, u) {
            const h = (function(x, T, I) {
                const A = 1 / (1 << I.z);
                return new c.a5(x / c.a3 * A + I.x * A, T / c.a3 * A + I.y * A)
              })(e, o, u.canonical),
              p = (g = h.y, [c.br(h.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI]);
            var g;
            return this.getCircleRadiusCorrection() / Math.cos(p[1])
          }
          projectTileCoordinates(e, o, u, h) {
            const p = u.canonical,
              g = po(e, o, p.x, p.y, p.z),
              x = 1 + (h ? h(e, o) : 0) / c.bx,
              T = [g[0] * x, g[1] * x, g[2] * x, 1];
            c.aA(T, T, this._globeViewProjMatrixNoCorrection);
            const I = this._cachedClippingPlane,
              A = I[0] * g[0] + I[1] * g[1] + I[2] * g[2] + I[3] < 0;
            return {
              point: new c.P(T[0] / T[3], T[1] / T[3]),
              signedDistanceFromCamera: T[3],
              isOccluded: A
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = qo(this.worldSize, this.center.lat),
              o = c.bd(),
              u = c.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), c.b7(o, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const h = this.centerOffset;
            o[8] = 2 * -h.x / this._helper._width, o[9] = 2 * h.y / this._helper._height, this._projectionMatrix = c.b8(o), this._globeProjMatrixInverted = c.bd(), c.au(this._globeProjMatrixInverted, o), c.N(o, o, [0, 0, -this.cameraToCenterDistance]), c.b9(o, o, this.rollInRadians), c.ba(o, o, -this.pitchInRadians), c.b9(o, o, this.bearingInRadians), c.N(o, o, [0, 0, -e]);
            const p = c.bs();
            p[0] = e, p[1] = e, p[2] = e, c.ba(u, o, this.center.lat * Math.PI / 180), c.bC(u, u, -this.center.lng * Math.PI / 180), c.O(u, u, p), this._globeViewProjMatrixNoCorrection = u, c.ba(o, o, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), c.bC(o, o, -this.center.lng * Math.PI / 180), c.O(o, o, p), this._globeViewProjMatrix32f = new Float32Array(o), this._globeViewProjMatrixNoCorrectionInverted = c.bd(), c.au(this._globeViewProjMatrixNoCorrectionInverted, u);
            const g = c.bs();
            this._cameraPosition = c.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, c.bz(this._cameraPosition, this._cameraPosition, g, -this.rollInRadians), c.bA(this._cameraPosition, this._cameraPosition, g, this.pitchInRadians), c.bz(this._cameraPosition, this._cameraPosition, g, -this.bearingInRadians), c.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), c.bA(this._cameraPosition, this._cameraPosition, g, -this.center.lat * Math.PI / 180), c.bB(this._cameraPosition, this._cameraPosition, g, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const x = c.b8(this._globeViewProjMatrixNoCorrectionInverted);
            c.O(x, x, [1, 1, -1]), this._cachedFrustum = Wi.fromInvProjectionMatrix(x, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            c.w("calculateFogMatrix is not supported on globe projection.");
            const o = c.bd();
            return c.am(o), o
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new c.b5(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && c.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, o) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const u = ui(e);
            c.aU(u, u, 1 + o / c.bx);
            const h = c.by();
            return c.aA(h, [u[0], u[1], u[2], 1], this._globeViewProjMatrixNoCorrection), h[2] / h[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              o = .5 * this.height,
              u = [new c.P(0, 0), new c.P(e, 0), new c.P(this.width, 0), new c.P(this.width, o), new c.P(this.width, this.height), new c.P(e, this.height), new c.P(0, this.height), new c.P(0, o)],
              h = [];
            for (const F of u) h.push(this.unprojectScreenPoint(F));
            let p = 0,
              g = 0,
              x = 0,
              T = 0;
            const I = this.center;
            for (const F of h) {
              const L = c.bD(I.lng, F.lng),
                V = c.bD(I.lat, F.lat);
              L < g && (g = L), L > p && (p = L), V < T && (T = V), V > x && (x = V)
            }
            const A = [I.lng + g, I.lat + T, I.lng + p, I.lat + x];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (A[3] = 90, A[0] = -180, A[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (A[1] = -90, A[0] = -180, A[2] = 180), new ir(A)
          }
          calculateCenterFromCameraLngLatAlt(e, o, u, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, o, u, h)
          }
          setLocationAtPoint(e, o) {
            const u = ui(this.unprojectScreenPoint(o)),
              h = ui(e),
              p = c.bs();
            c.bE(p);
            const g = c.bs();
            c.bB(g, u, p, -this.center.lng * Math.PI / 180), c.bA(g, g, p, this.center.lat * Math.PI / 180);
            const x = h[0] * h[0] + h[2] * h[2],
              T = g[0] * g[0];
            if (x < T) return;
            const I = Math.sqrt(x - T),
              A = -I,
              F = c.bF(h[0], h[2], g[0], I),
              L = c.bF(h[0], h[2], g[0], A),
              V = c.bs();
            c.bB(V, h, p, -F);
            const K = c.bF(V[1], V[2], g[1], g[2]),
              it = c.bs();
            c.bB(it, h, p, -L);
            const ot = c.bF(it[1], it[2], g[1], g[2]),
              st = .5 * Math.PI,
              pt = K >= -st && K <= st,
              wt = ot >= -st && ot <= st;
            let dt, kt;
            if (pt && wt) {
              const oe = this.center.lng * Math.PI / 180,
                Qt = this.center.lat * Math.PI / 180;
              c.bG(F, oe) + c.bG(K, Qt) < c.bG(L, oe) + c.bG(ot, Qt) ? (dt = F, kt = K) : (dt = L, kt = ot)
            } else if (pt) dt = F, kt = K;
            else {
              if (!wt) return;
              dt = L, kt = ot
            }
            const It = dt / Math.PI * 180,
              gt = kt / Math.PI * 180,
              Rt = this.center.lat;
            this.setCenter(new c.U(It, c.ai(gt, -90, 90))), this.setZoom(this.zoom + Un(Rt, this.center.lat))
          }
          locationToScreenPoint(e, o) {
            const u = ui(e);
            if (o) {
              const h = o.getElevationForLngLatZoom(e, this._helper._tileZoom);
              c.aU(u, u, 1 + h / c.bx)
            }
            return this._projectSurfacePointToScreen(u)
          }
          _projectSurfacePointToScreen(e) {
            const o = c.by();
            return c.aA(o, [...e, 1], this._globeViewProjMatrixNoCorrection), o[0] /= o[3], o[1] /= o[3], new c.P((.5 * o[0] + .5) * this.width, (.5 * -o[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, o) {
            if (o) {
              const u = o.pointCoordinate(e);
              if (u) return u
            }
            return c.a5.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, o) {
            var u;
            return (u = this.screenPointToMercatorCoordinate(e, o)) === null || u === void 0 ? void 0 : u.toLngLat()
          }
          isPointOnMapSurface(e, o) {
            const u = this._cameraPosition,
              h = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(u, h)
          }
          getRayDirectionFromPixel(e) {
            const o = c.by();
            o[0] = e.x / this.width * 2 - 1, o[1] = -1 * (e.y / this.height * 2 - 1), o[2] = 1, o[3] = 1, c.aA(o, o, this._globeViewProjMatrixNoCorrectionInverted), o[0] /= o[3], o[1] /= o[3], o[2] /= o[3];
            const u = c.bs();
            u[0] = o[0] - this._cameraPosition[0], u[1] = o[1] - this._cameraPosition[1], u[2] = o[2] - this._cameraPosition[2];
            const h = c.bs();
            return c.aY(h, u), h
          }
          isSurfacePointVisible(e) {
            const o = this._cachedClippingPlane;
            return o[0] * e[0] + o[1] * e[1] + o[2] * e[2] + o[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const o = c.by();
            return c.aA(o, [...e, 1], this._globeViewProjMatrixNoCorrection), o[0] /= o[3], o[1] /= o[3], o[2] /= o[3], o[0] > -1 && o[0] < 1 && o[1] > -1 && o[1] < 1 && o[2] > -1 && o[2] < 1
          }
          rayPlanetIntersection(e, o) {
            const u = c.a_(e, o),
              h = c.bs(),
              p = c.bs();
            c.aU(p, o, u), c.aX(h, e, p);
            const g = 1 - c.a_(h, h);
            if (g < 0) return null;
            const x = c.a_(e, e) - 1,
              T = -u + (u < 0 ? 1 : -1) * Math.sqrt(g),
              I = x / T,
              A = T;
            return {
              tMin: Math.min(I, A),
              tMax: Math.max(I, A)
            }
          }
          unprojectScreenPoint(e) {
            const o = this._cameraPosition,
              u = this.getRayDirectionFromPixel(e),
              h = this.rayPlanetIntersection(o, u);
            if (h) {
              const A = c.bs();
              c.aV(A, o, [u[0] * h.tMin, u[1] * h.tMin, u[2] * h.tMin]);
              const F = c.bs();
              return c.aY(F, A), Bs(F)
            }
            const p = this._cachedClippingPlane,
              g = p[0] * u[0] + p[1] * u[1] + p[2] * u[2],
              x = -c.b4(p, o) / g,
              T = c.bs();
            if (x > 0) c.aV(T, o, [u[0] * x, u[1] * x, u[2] * x]);
            else {
              const A = c.bs();
              c.aV(A, o, [2 * u[0], 2 * u[1], 2 * u[2]]);
              const F = c.b4(this._cachedClippingPlane, A);
              c.aX(T, A, [this._cachedClippingPlane[0] * F, this._cachedClippingPlane[1] * F, this._cachedClippingPlane[2] * F])
            }
            const I = (function(A) {
              const F = c.bs();
              return F[0] = A[0] * -A[3], F[1] = A[1] * -A[3], F[2] = A[2] * -A[3], {
                center: F,
                radius: Math.sqrt(1 - A[3] * A[3])
              }
            })(p);
            return Bs((function(A, F, L) {
              const V = c.bs();
              c.aX(V, L, A);
              const K = c.bs();
              return c.bt(K, A, V, F / c.b2(V)), K
            })(I.center, I.radius, T))
          }
          getMatrixForModel(e, o) {
            const u = c.U.convert(e),
              h = 1 / c.bx,
              p = c.bc();
            return c.bC(p, p, u.lng / 180 * Math.PI), c.ba(p, p, -u.lat / 180 * Math.PI), c.N(p, p, [0, 0, 1 + o / c.bx]), c.ba(p, p, .5 * Math.PI), c.O(p, p, [h, h, h]), p
          }
          getProjectionDataForCustomLayer(e = !0) {
            const o = this.getProjectionData({
              overscaledTileID: new c.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return o.tileMercatorCoords = [0, 0, 1, 1], o
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class ku {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, o, u) {
            return this._helper.interpolatePadding(e, o, u)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, o, u = !0) {
            this._helper.resize(e, o, u)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, o) {
            this._helper.overrideNearFarZ(e, o)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, o) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = o, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (o, u) => this.currentTransform.defaultConstrain(o, u), this._helper = new Wn({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (o, u) => this.defaultConstrain(o, u)
            }, e), this._globeness = 1, this._mercatorTransform = new $i, this._verticalPerspectiveTransform = new wu
          }
          clone() {
            const e = new ku;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const o = this._mercatorTransform.getProjectionData(e),
              u = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? u.mainMatrix : o.mainMatrix,
              clippingPlane: u.clippingPlane,
              tileMercatorCoords: u.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: o.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return c.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return c.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, o, u) {
            const h = this._mercatorTransform.getPitchedTextCorrection(e, o, u),
              p = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, o, u);
            return c.bn(h, p, this._globeness)
          }
          projectTileCoordinates(e, o, u, h) {
            return this.currentTransform.projectTileCoordinates(e, o, u, h)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, o) {
            return this.currentTransform.lngLatToCameraDepth(e, o)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          calculateCenterFromCameraLngLatAlt(e, o, u, h) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, o, u, h)
          }
          setLocationAtPoint(e, o) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, o), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, o), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, o) {
            return this.currentTransform.locationToScreenPoint(e, o)
          }
          screenPointToMercatorCoordinate(e, o) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, o)
          }
          screenPointToLocation(e, o) {
            return this.currentTransform.screenPointToLocation(e, o)
          }
          isPointOnMapSurface(e, o) {
            return this.currentTransform.isPointOnMapSurface(e, o)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, o) {
            return this.currentTransform.getMatrixForModel(e, o)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const o = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return o;
            const u = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return u.fallbackMatrix = o.mainMatrix, u
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class No {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, o) {
            const u = xu(e, o);
            return Math.abs(u.lng - o.center.lng) > 180 && (u.lng = o.center.lng + 179.5 * Math.sign(u.lng - o.center.lng)), {
              easingCenter: u,
              easingOffset: new c.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, o) {
            const u = e.around,
              h = o.screenPointToLocation(u);
            e.bearingDelta && o.setBearing(o.bearing + e.bearingDelta), e.pitchDelta && o.setPitch(o.pitch + e.pitchDelta), e.rollDelta && o.setRoll(o.roll + e.rollDelta);
            const p = o.zoom;
            e.zoomDelta && o.setZoom(o.zoom + e.zoomDelta);
            const g = o.zoom - p;
            if (g === 0) return;
            const x = c.bD(o.center.lng, h.lng),
              T = x / (Math.abs(x / 180) + 1),
              I = c.bD(o.center.lat, h.lat),
              A = o.getRayDirectionFromPixel(u),
              F = o.cameraPosition,
              L = -1 * c.a_(F, A),
              V = c.bs();
            c.aV(V, F, [A[0] * L, A[1] * L, A[2] * L]);
            const K = c.b0(V) - 1,
              it = Math.exp(.5 * -Math.max(K - .3, 0)),
              ot = qo(o.worldSize, o.center.lat) / Math.min(o.width, o.height),
              st = c.bq(ot, .9, .5, 1, .25),
              pt = (1 - c.al(-g)) * Math.min(it, st),
              wt = o.center.lat,
              dt = o.zoom,
              kt = new c.U(o.center.lng + T * pt, c.ai(o.center.lat + I * pt, -c.aj, c.aj));
            o.setLocationAtPoint(h, u);
            const It = o.center,
              gt = c.bq(Math.abs(x), 45, 85, 0, 1),
              Rt = c.bq(ot, .75, .35, 0, 1),
              oe = Math.pow(Math.max(gt, Rt), .25),
              Qt = c.bD(It.lng, kt.lng),
              re = c.bD(It.lat, kt.lat);
            o.setCenter(new c.U(It.lng + Qt * oe, It.lat + re * oe).wrap()), o.setZoom(dt + Un(wt, o.center.lat))
          }
          handleMapControlsPan(e, o, u) {
            if (!e.panDelta) return;
            const h = o.center.lat,
              p = o.zoom;
            o.setCenter(xu(e.panDelta, o).wrap()), o.setZoom(p + Un(h, o.center.lat))
          }
          cameraForBoxAndBearing(e, o, u, h, p) {
            const g = pi(e, o, u, h, p),
              x = o.left / p.width * 2 - 1,
              T = (p.width - o.right) / p.width * 2 - 1,
              I = o.top / p.height * -2 + 1,
              A = (p.height - o.bottom) / p.height * -2 + 1,
              F = c.bD(u.getWest(), u.getEast()) < 0,
              L = F ? u.getEast() : u.getWest(),
              V = F ? u.getWest() : u.getEast(),
              K = Math.max(u.getNorth(), u.getSouth()),
              it = Math.min(u.getNorth(), u.getSouth()),
              ot = L + .5 * c.bD(L, V),
              st = K + .5 * c.bD(K, it),
              pt = p.clone();
            pt.setCenter(g.center), pt.setBearing(g.bearing), pt.setPitch(0), pt.setRoll(0), pt.setZoom(g.zoom);
            const wt = pt.modelViewProjectionMatrix,
              dt = [ui(u.getNorthWest()), ui(u.getNorthEast()), ui(u.getSouthWest()), ui(u.getSouthEast()), ui(new c.U(V, st)), ui(new c.U(L, st)), ui(new c.U(ot, K)), ui(new c.U(ot, it))],
              kt = ui(g.center);
            let It = Number.POSITIVE_INFINITY;
            for (const gt of dt) x < 0 && (It = No.getLesserNonNegativeNonNull(It, No.solveVectorScale(gt, kt, wt, "x", x))), T > 0 && (It = No.getLesserNonNegativeNonNull(It, No.solveVectorScale(gt, kt, wt, "x", T))), I > 0 && (It = No.getLesserNonNegativeNonNull(It, No.solveVectorScale(gt, kt, wt, "y", I))), A < 0 && (It = No.getLesserNonNegativeNonNull(It, No.solveVectorScale(gt, kt, wt, "y", A)));
            if (Number.isFinite(It) && It !== 0) return g.zoom = pt.zoom + c.ao(It), g;
            Yn()
          }
          handleJumpToCenterZoom(e, o) {
            const u = e.center.lat,
              h = e.constrain(o.center ? c.U.convert(o.center) : e.center, e.zoom).center;
            e.setCenter(h.wrap());
            const p = o.zoom !== void 0 ? +o.zoom : e.zoom + Un(u, h.lat);
            e.zoom !== p && e.setZoom(p)
          }
          handleEaseTo(e, o) {
            const u = e.zoom,
              h = e.center,
              p = e.padding,
              g = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              x = {
                roll: o.roll === void 0 ? e.roll : o.roll,
                pitch: o.pitch === void 0 ? e.pitch : o.pitch,
                bearing: o.bearing === void 0 ? e.bearing : o.bearing
              },
              T = o.zoom !== void 0,
              I = !e.isPaddingEqual(o.padding);
            let A = !1;
            const F = o.center ? c.U.convert(o.center) : h,
              L = e.constrain(F, u).center;
            In(e, L);
            const V = e.clone();
            V.setCenter(L), V.setZoom(T ? +o.zoom : u + Un(h.lat, F.lat)), V.setBearing(o.bearing);
            const K = new c.P(c.ai(e.centerPoint.x + o.offsetAsPoint.x, 0, e.width), c.ai(e.centerPoint.y + o.offsetAsPoint.y, 0, e.height));
            V.setLocationAtPoint(L, K);
            const it = (o.offset && o.offsetAsPoint.mag()) > 0 ? V.center : L,
              ot = T ? +o.zoom : u + Un(h.lat, it.lat),
              st = u + Un(h.lat, 0),
              pt = ot + Un(it.lat, 0),
              wt = c.bD(h.lng, it.lng),
              dt = c.bD(h.lat, it.lat),
              kt = c.al(pt - st);
            return A = ot !== u, {
              easeFunc: It => {
                if (c.bh(g, x) || ai({
                    startEulerAngles: g,
                    endEulerAngles: x,
                    tr: e,
                    k: It,
                    useSlerp: g.roll != x.roll
                  }), I && e.interpolatePadding(p, o.padding, It), o.around) c.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(o.around, o.aroundPoint);
                else {
                  const gt = pt > st ? Math.min(2, kt) : Math.max(.5, kt),
                    Rt = Math.pow(gt, 1 - It),
                    oe = Na(h, wt, dt, It * Rt);
                  e.setCenter(oe.wrap())
                }
                if (A) {
                  const gt = c.F.number(st, pt, It) + Un(0, e.center.lat);
                  e.setZoom(gt)
                }
              },
              isZooming: A,
              elevationCenter: it
            }
          }
          handleFlyTo(e, o) {
            const u = o.zoom !== void 0,
              h = e.center,
              p = e.zoom,
              g = e.padding,
              x = !e.isPaddingEqual(o.padding),
              T = e.constrain(c.U.convert(o.center || o.locationAtOffset), p).center,
              I = u ? +o.zoom : e.zoom + Un(e.center.lat, T.lat),
              A = e.clone();
            A.setCenter(T), A.setZoom(I), A.setBearing(o.bearing);
            const F = new c.P(c.ai(e.centerPoint.x + o.offsetAsPoint.x, 0, e.width), c.ai(e.centerPoint.y + o.offsetAsPoint.y, 0, e.height));
            A.setLocationAtPoint(T, F);
            const L = A.center;
            In(e, L);
            const V = (function(dt, kt, It) {
                const gt = ui(kt),
                  Rt = ui(It),
                  oe = c.a_(gt, Rt),
                  Qt = Math.acos(oe),
                  re = Ti(dt);
                return Qt / (2 * Math.PI) * re
              })(e, h, L),
              K = p + Un(h.lat, 0),
              it = I + Un(L.lat, 0),
              ot = c.al(it - K);
            let st;
            if (typeof o.minZoom == "number") {
              const dt = +o.minZoom + Un(L.lat, 0),
                kt = Math.min(dt, K, it) + Un(0, L.lat),
                It = e.constrain(L, kt).zoom + Un(L.lat, 0);
              st = c.al(It - K)
            }
            const pt = c.bD(h.lng, L.lng),
              wt = c.bD(h.lat, L.lat);
            return {
              easeFunc: (dt, kt, It, gt) => {
                const Rt = Na(h, pt, wt, It);
                x && e.interpolatePadding(g, o.padding, dt);
                const oe = dt === 1 ? L : Rt;
                e.setCenter(oe.wrap());
                const Qt = K + c.ao(kt);
                e.setZoom(dt === 1 ? I : Qt + Un(0, oe.lat))
              },
              scaleOfZoom: ot,
              targetCenter: L,
              scaleOfMinZoom: st,
              pixelPathLength: V
            }
          }
          static solveVectorScale(e, o, u, h, p) {
            const g = h === "x" ? [u[0], u[4], u[8], u[12]] : [u[1], u[5], u[9], u[13]],
              x = [u[3], u[7], u[11], u[15]],
              T = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
              I = e[0] * x[0] + e[1] * x[1] + e[2] * x[2],
              A = o[0] * g[0] + o[1] * g[1] + o[2] * g[2],
              F = o[0] * x[0] + o[1] * x[1] + o[2] * x[2];
            return A + p * I === T + p * F || x[3] * (T - A) + g[3] * (F - I) + T * F == A * I ? null : (A + g[3] - p * F - p * x[3]) / (A - T - p * F + p * I)
          }
          static getLesserNonNegativeNonNull(e, o) {
            return o !== null && o >= 0 && o < e ? o : e
          }
        }
        class Va {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new ji, this._verticalPerspectiveCameraHelper = new No
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, o) {
            return this.currentHelper.handlePanInertia(e, o)
          }
          handleMapControlsRollPitchBearingZoom(e, o) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, o)
          }
          handleMapControlsPan(e, o, u) {
            this.currentHelper.handleMapControlsPan(e, o, u)
          }
          cameraForBoxAndBearing(e, o, u, h, p) {
            return this.currentHelper.cameraForBoxAndBearing(e, o, u, h, p)
          }
          handleJumpToCenterZoom(e, o) {
            this.currentHelper.handleJumpToCenterZoom(e, o)
          }
          handleEaseTo(e, o) {
            return this.currentHelper.handleEaseTo(e, o)
          }
          handleFlyTo(e, o) {
            return this.currentHelper.handleFlyTo(e, o)
          }
        }
        const va = (d, e) => c.z(d, e && e.filter((o => o.identifier !== "source.canvas"))),
          Tu = c.bH();
        class Ua extends c.E {
          constructor(e, o = {}) {
            var u, h;
            super(), this._rtlPluginLoaded = () => {
              for (const g in this.tileManagers) {
                const x = this.tileManagers[g].getSource().type;
                x !== "vector" && x !== "geojson" || this.tileManagers[g].reload()
              }
            }, this.map = e, this.dispatcher = new ce(se(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((g, x) => this.getGlyphs(g, x))), this.dispatcher.registerMessageHandler("GI", ((g, x) => this.getImages(g, x))), this.dispatcher.registerMessageHandler("GDA", ((g, x) => this.getDashes(g, x))), this.imageManager = new Ht, this.imageManager.setEventedParent(this);
            const p = ((u = e._container) === null || u === void 0 ? void 0 : u.lang) || typeof document < "u" && ((h = document.documentElement) === null || h === void 0 ? void 0 : h.lang) || void 0;
            this.glyphManager = new Ce(e._requestManager, o.localIdeographFontFamily, p), this.lineAtlas = new Ue(256, 512), this.crossTileSymbolIndex = new xr, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new c.bI, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", c.bJ()), U().on(dr, this._rtlPluginLoaded), this.on("data", (g => {
              if (g.dataType !== "source" || g.sourceDataType !== "metadata") return;
              const x = this.tileManagers[g.sourceId];
              if (!x) return;
              const T = x.getSource();
              if (T && T.vectorLayerIds)
                for (const I in this._layers) {
                  const A = this._layers[I];
                  A.source === T.id && this._validateLayer(A)
                }
            }))
          }
          setGlobalStateProperty(e, o) {
            var u, h, p;
            this._checkLoaded();
            const g = o === null ? (p = (h = (u = this.stylesheet.state) === null || u === void 0 ? void 0 : u[e]) === null || h === void 0 ? void 0 : h.default) !== null && p !== void 0 ? p : null : o;
            if (c.bK(g, this._globalState[e])) return this;
            this._globalState[e] = g, this._applyGlobalStateChanges([e])
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const o = [];
            for (const u in e) !c.bK(this._globalState[u], e[u].default) && (o.push(u), this._globalState[u] = e[u].default);
            this._applyGlobalStateChanges(o)
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const o = new Set,
              u = {};
            for (const h of e) {
              u[h] = this._globalState[h];
              for (const p in this._layers) {
                const g = this._layers[p],
                  x = g.getLayoutAffectingGlobalStateRefs(),
                  T = g.getPaintAffectingGlobalStateRefs();
                if (x.has(h) && o.add(g.source), T.has(h))
                  for (const {
                      name: I,
                      value: A
                    }
                    of T.get(h)) this._updatePaintProperty(g, I, A)
              }
            }
            this.dispatcher.broadcast("UGS", u);
            for (const h in this.tileManagers) o.has(h) && (this._reloadSource(h), this._changed = !0)
          }
          loadURL(e, o = {}, u) {
            this.fire(new c.l("dataloading", {
              dataType: "style"
            })), o.validate = typeof o.validate != "boolean" || o.validate;
            const h = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const p = this._loadStyleRequest;
            c.j(h, this._loadStyleRequest).then((g => {
              this._loadStyleRequest = null, this._load(g.data, o, u)
            })).catch((g => {
              this._loadStyleRequest = null, g && !p.signal.aborted && this.fire(new c.k(g))
            }))
          }
          loadJSON(e, o = {}, u) {
            this.fire(new c.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, ut.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, o.validate = o.validate !== !1, this._load(e, o, u)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new c.l("dataloading", {
              dataType: "style"
            })), this._load(Tu, {
              validate: !1
            })
          }
          _load(e, o, u) {
            var h, p;
            let g = o.transformStyle ? o.transformStyle(u, e) : e;
            if (!o.validate || !va(this, c.B(g))) {
              g = Object.assign({}, g), this._loaded = !0, this.stylesheet = g;
              for (const x in g.sources) this.addSource(x, g.sources[x], {
                validate: !1
              });
              g.sprite ? this._loadSprite(g.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(g.glyphs), this._createLayers(), this.light = new ne(this.stylesheet.light), this._setProjectionInternal(((h = this.stylesheet.projection) === null || h === void 0 ? void 0 : h.type) || "mercator"), this.sky = new pe(this.stylesheet.sky), this.map.setTerrain((p = this.stylesheet.terrain) !== null && p !== void 0 ? p : null), this.fire(new c.l("data", {
                dataType: "style"
              })), this.fire(new c.l("style.load"))
            }
          }
          _createLayers() {
            var e, o, u;
            const h = c.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", h), this._order = h.map((p => p.id)), this._layers = {}, this._serializedLayers = null;
            for (const p of h) {
              const g = c.bM(p, this._globalState);
              if (g.setEventedParent(this, {
                  layer: {
                    id: p.id
                  }
                }), this._layers[p.id] = g, c.bN(g) && this.tileManagers[g.source]) {
                const x = (u = (o = p.paint) === null || o === void 0 ? void 0 : o["raster-fade-duration"]) !== null && u !== void 0 ? u : g.paint.get("raster-fade-duration");
                this.tileManagers[g.source].setRasterFadeDuration(x)
              }
            }
          }
          _loadSprite(e, o = !1, u = void 0) {
            let h;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(p, g, x, T) {
              return c._(this, void 0, void 0, (function*() {
                const I = Ct(p),
                  A = x > 1 ? "@2x" : "",
                  F = {},
                  L = {};
                for (const {
                    id: V,
                    url: K
                  }
                  of I) {
                  const it = g.transformRequest(Wt(K, A, ".json"), "SpriteJSON");
                  F[V] = c.j(it, T);
                  const ot = g.transformRequest(Wt(K, A, ".png"), "SpriteImage");
                  L[V] = Zt.getImage(ot, T)
                }
                return yield Promise.all([...Object.values(F), ...Object.values(L)]), (function(V, K) {
                  return c._(this, void 0, void 0, (function*() {
                    const it = {};
                    for (const ot in V) {
                      it[ot] = {};
                      const st = ut.getImageCanvasContext((yield K[ot]).data),
                        pt = (yield V[ot]).data;
                      for (const wt in pt) {
                        const {
                          width: dt,
                          height: kt,
                          x: It,
                          y: gt,
                          sdf: Rt,
                          pixelRatio: oe,
                          stretchX: Qt,
                          stretchY: re,
                          content: ue,
                          textFitWidth: Je,
                          textFitHeight: tr
                        } = pt[wt];
                        it[ot][wt] = {
                          data: null,
                          pixelRatio: oe,
                          sdf: Rt,
                          stretchX: Qt,
                          stretchY: re,
                          content: ue,
                          textFitWidth: Je,
                          textFitHeight: tr,
                          spriteData: {
                            width: dt,
                            height: kt,
                            x: It,
                            y: gt,
                            context: st
                          }
                        }
                      }
                    }
                    return it
                  }))
                })(F, L)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((p => {
              if (this._spriteRequest = null, p)
                for (const g in p) {
                  this._spritesImagesIds[g] = [];
                  const x = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((T => !(T in p))) : [];
                  for (const T of x) this.imageManager.removeImage(T), this._changedImages[T] = !0;
                  for (const T in p[g]) {
                    const I = g === "default" ? T : `${g}:${T}`;
                    this._spritesImagesIds[g].push(I), I in this.imageManager.images ? this.imageManager.updateImage(I, p[g][T], !1) : this.imageManager.addImage(I, p[g][T]), o && (this._changedImages[I] = !0)
                  }
                }
            })).catch((p => {
              this._spriteRequest = null, h = p, this.fire(new c.k(h))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), o && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", {
                dataType: "style"
              })), u && u(h)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const o = this.tileManagers[e.source];
            if (!o) return;
            const u = e.sourceLayer;
            if (!u) return;
            const h = o.getSource();
            (h.type === "geojson" || h.vectorLayerIds && h.vectorLayerIds.indexOf(u) === -1) && this.fire(new c.k(new Error(`Source layer "${u}" does not exist on source "${h.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers)
              if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, o = !1) {
            const u = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(o ? c.bO(u) : u);
            const h = [];
            for (const p of e)
              if (u[p]) {
                const g = o ? c.bO(u[p]) : u[p];
                h.push(g)
              } return h
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const o = Object.keys(this._layers);
            for (const u of o) {
              const h = this._layers[u];
              h.type !== "custom" && (e[u] = h.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, o, u;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((o = this.sky) === null || o === void 0) && o.hasTransition() || !((u = this.projection) === null || u === void 0) && u.hasTransition()) return !0;
            for (const h in this.tileManagers)
              if (this.tileManagers[h].hasTransition()) return !0;
            for (const h in this._layers)
              if (this._layers[h].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const o = this._changed;
            if (o) {
              const h = Object.keys(this._updatedLayers),
                p = Object.keys(this._removedLayers);
              (h.length || p.length) && this._updateWorkerLayers(h, p);
              for (const g in this._updatedSources) {
                const x = this._updatedSources[g];
                if (x === "reload") this._reloadSource(g);
                else {
                  if (x !== "clear") throw new Error(`Invalid action ${x}`);
                  this._clearSource(g)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const u = {};
            for (const h in this.tileManagers) {
              const p = this.tileManagers[h];
              u[h] = p.used, p.used = !1
            }
            for (const h of this._order) {
              const p = this._layers[h];
              p.recalculate(e, this._availableImages), !p.isHidden(e.zoom) && p.source && (this.tileManagers[p.source].used = !0)
            }
            for (const h in u) {
              const p = this.tileManagers[h];
              !!u[h] != !!p.used && p.fire(new c.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: h
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, o && this.fire(new c.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const o in this.tileManagers) this.tileManagers[o].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, o) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: o
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, o = {}) {
            var u;
            this._checkLoaded();
            const h = this.serialize();
            if (e = o.transformStyle ? o.transformStyle(h, e) : e, ((u = o.validate) === null || u === void 0 || u) && va(this, c.B(e))) return !1;
            (e = c.bO(e)).layers = c.bL(e.layers);
            const p = c.bP(h, e),
              g = this._getOperationsToPerform(p);
            if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
            if (g.operations.length === 0) return !1;
            for (const x of g.operations) x();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const o = [],
              u = [];
            for (const h of e) switch (h.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                o.push((() => this.addLayer.apply(this, h.args)));
                break;
              case "removeLayer":
                o.push((() => this.removeLayer.apply(this, h.args)));
                break;
              case "setPaintProperty":
                o.push((() => this.setPaintProperty.apply(this, h.args)));
                break;
              case "setLayoutProperty":
                o.push((() => this.setLayoutProperty.apply(this, h.args)));
                break;
              case "setFilter":
                o.push((() => this.setFilter.apply(this, h.args)));
                break;
              case "addSource":
                o.push((() => this.addSource.apply(this, h.args)));
                break;
              case "removeSource":
                o.push((() => this.removeSource.apply(this, h.args)));
                break;
              case "setLayerZoomRange":
                o.push((() => this.setLayerZoomRange.apply(this, h.args)));
                break;
              case "setLight":
                o.push((() => this.setLight.apply(this, h.args)));
                break;
              case "setGeoJSONSourceData":
                o.push((() => this.setGeoJSONSourceData.apply(this, h.args)));
                break;
              case "setGlyphs":
                o.push((() => this.setGlyphs.apply(this, h.args)));
                break;
              case "setSprite":
                o.push((() => this.setSprite.apply(this, h.args)));
                break;
              case "setTerrain":
                o.push((() => this.map.setTerrain.apply(this, h.args)));
                break;
              case "setSky":
                o.push((() => this.setSky.apply(this, h.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, h.args);
                break;
              case "setGlobalState":
                o.push((() => this.setGlobalState.apply(this, h.args)));
                break;
              case "setTransition":
                o.push((() => {}));
                break;
              default:
                u.push(h.command)
            }
            return {
              operations: o,
              unimplemented: u
            }
          }
          addImage(e, o) {
            if (this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, o), this._afterImageUpdated(e)
          }
          updateImage(e, o) {
            this.imageManager.updateImage(e, o)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, o, u = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!o.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(o).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(o.type) >= 0 && this._validate(c.B.source, `sources.${e}`, o, null, u)) return;
            this.map && this.map._collectResourceTiming && (o.collectResourceTiming = !0);
            const h = this.tileManagers[e] = new we(e, o, this.dispatcher);
            h.style = this, h.setEventedParent(this, (() => ({
              isSourceLoaded: h.loaded(),
              source: h.serialize(),
              sourceId: e
            }))), h.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const u in this._layers)
              if (this._layers[u].source === e) return this.fire(new c.k(new Error(`Source "${e}" cannot be removed while layer "${u}" is using it.`)));
            const o = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], o.fire(new c.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), o.setEventedParent(null), o.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, o) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const u = this.tileManagers[e].getSource();
            if (u.type !== "geojson") throw new Error(`geojsonSource.type is ${u.type}, which is !== 'geojson`);
            u.setData(o), this._changed = !0
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource()
          }
          addLayer(e, o, u = {}) {
            this._checkLoaded();
            const h = e.id;
            if (this.getLayer(h)) return void this.fire(new c.k(new Error(`Layer "${h}" already exists on this map.`)));
            let p;
            if (e.type === "custom") {
              if (va(this, c.bQ(e))) return;
              p = c.bM(e, this._globalState)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(h, e.source), e = c.bO(e), e = c.e(e, {
                  source: h
                })), this._validate(c.B.layer, `layers.${h}`, e, {
                  arrayIndex: -1
                }, u)) return;
              p = c.bM(e, this._globalState), this._validateLayer(p), p.setEventedParent(this, {
                layer: {
                  id: h
                }
              })
            }
            const g = o ? this._order.indexOf(o) : this._order.length;
            if (o && g === -1) this.fire(new c.k(new Error(`Cannot add layer "${h}" before non-existing layer "${o}".`)));
            else {
              if (this._order.splice(g, 0, h), this._layerOrderChanged = !0, this._layers[h] = p, this._removedLayers[h] && p.source && p.type !== "custom") {
                const x = this._removedLayers[h];
                delete this._removedLayers[h], x.type !== p.type ? this._updatedSources[p.source] = "clear" : (this._updatedSources[p.source] = "reload", this.tileManagers[p.source].pause())
              }
              this._updateLayer(p), p.onAdd && p.onAdd(this.map)
            }
          }
          moveLayer(e, o) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new c.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === o) return;
            const u = this._order.indexOf(e);
            this._order.splice(u, 1);
            const h = o ? this._order.indexOf(o) : this._order.length;
            o && h === -1 ? this.fire(new c.k(new Error(`Cannot move layer "${e}" before non-existing layer "${o}".`))) : (this._order.splice(h, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const o = this._layers[e];
            if (!o) return void this.fire(new c.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            o.setEventedParent(null);
            const u = this._order.indexOf(e);
            this._order.splice(u, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = o, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], o.onRemove && o.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, o, u) {
            this._checkLoaded();
            const h = this.getLayer(e);
            h ? h.minzoom === o && h.maxzoom === u || (o != null && (h.minzoom = o), u != null && (h.maxzoom = u), this._updateLayer(h)) : this.fire(new c.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, o, u = {}) {
            this._checkLoaded();
            const h = this.getLayer(e);
            if (h) {
              if (!c.bK(h.filter, o)) return o == null ? (h.setFilter(void 0), void this._updateLayer(h)) : void(this._validate(c.B.filter, `layers.${h.id}.filter`, o, null, u) || (h.setFilter(c.bO(o)), this._updateLayer(h)))
            } else this.fire(new c.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return c.bO(this.getLayer(e).filter)
          }
          setLayoutProperty(e, o, u, h = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? c.bK(p.getLayoutProperty(o), u) || (p.setLayoutProperty(o, u, h), this._updateLayer(p)) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, o) {
            const u = this.getLayer(e);
            if (u) return u.getLayoutProperty(o);
            this.fire(new c.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, o, u, h = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? c.bK(p.getPaintProperty(o), u) || this._updatePaintProperty(p, o, u, h) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          _updatePaintProperty(e, o, u, h = {}) {
            e.setPaintProperty(o, u, h) && this._updateLayer(e), c.bN(e) && o === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(u), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null
          }
          getPaintProperty(e, o) {
            return this.getLayer(e).getPaintProperty(o)
          }
          setFeatureState(e, o) {
            this._checkLoaded();
            const u = e.source,
              h = e.sourceLayer,
              p = this.tileManagers[u];
            if (p === void 0) return void this.fire(new c.k(new Error(`The source '${u}' does not exist in the map's style.`)));
            const g = p.getSource().type;
            g === "geojson" && h ? this.fire(new c.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || h ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), p.setFeatureState(h, e.id, o)) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, o) {
            this._checkLoaded();
            const u = e.source,
              h = this.tileManagers[u];
            if (h === void 0) return void this.fire(new c.k(new Error(`The source '${u}' does not exist in the map's style.`)));
            const p = h.getSource().type,
              g = p === "vector" ? e.sourceLayer : void 0;
            p !== "vector" || g ? o && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new c.k(new Error("A feature id is required to remove its specific state property."))) : h.removeFeatureState(g, e.id, o) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const o = e.source,
              u = e.sourceLayer,
              h = this.tileManagers[o];
            if (h !== void 0) return h.getSource().type !== "vector" || u ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), h.getFeatureState(u, e.id)) : void this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new c.k(new Error(`The source '${o}' does not exist in the map's style.`)))
          }
          getTransition() {
            return c.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = c.bR(this.tileManagers, (p => p.serialize())),
              o = this._serializeByIds(this._order, !0),
              u = this.map.getTerrain() || void 0,
              h = this.stylesheet;
            return c.bS({
              version: h.version,
              name: h.name,
              metadata: h.metadata,
              light: h.light,
              sky: h.sky,
              center: h.center,
              zoom: h.zoom,
              bearing: h.bearing,
              pitch: h.pitch,
              sprite: h.sprite,
              glyphs: h.glyphs,
              transition: h.transition,
              projection: h.projection,
              sources: e,
              layers: o,
              terrain: u
            }, (p => p !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const o = g => this._layers[g].type === "fill-extrusion",
              u = {},
              h = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const x = this._order[g];
              if (o(x)) {
                u[x] = g;
                for (const T of e) {
                  const I = T[x];
                  if (I)
                    for (const A of I) h.push(A)
                }
              }
            }
            h.sort(((g, x) => x.intersectionZ - g.intersectionZ));
            const p = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const x = this._order[g];
              if (o(x))
                for (let T = h.length - 1; T >= 0; T--) {
                  const I = h[T].feature;
                  if (u[I.layer.id] < g) break;
                  p.push(I), h.pop()
                } else
                  for (const T of e) {
                    const I = T[x];
                    if (I)
                      for (const A of I) p.push(A.feature)
                  }
            }
            return p
          }
          queryRenderedFeatures(e, o, u) {
            o && o.filter && this._validate(c.B.filter, "queryRenderedFeatures.filter", o.filter, null, o);
            const h = {};
            if (o && o.layers) {
              if (!(Array.isArray(o.layers) || o.layers instanceof Set)) return this.fire(new c.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const I of o.layers) {
                const A = this._layers[I];
                if (!A) return this.fire(new c.k(new Error(`The layer '${I}' does not exist in the map's style and cannot be queried for features.`))), [];
                h[A.source] = !0
              }
            }
            const p = [];
            o.availableImages = this._availableImages;
            const g = this._serializedAllLayers(),
              x = o.layers instanceof Set ? o.layers : Array.isArray(o.layers) ? new Set(o.layers) : null,
              T = Object.assign(Object.assign({}, o), {
                layers: x,
                globalState: this._globalState
              });
            for (const I in this.tileManagers) o.layers && !h[I] || p.push(ve(this.tileManagers[I], this._layers, g, e, T, u, this.map.terrain ? (A, F, L) => this.map.terrain.getElevation(A, F, L) : void 0));
            return this.placement && p.push((function(I, A, F, L, V, K, it) {
              const ot = {},
                st = K.queryRenderedSymbols(L),
                pt = [];
              for (const wt of Object.keys(st).map(Number)) pt.push(it[wt]);
              pt.sort(_r);
              for (const wt of pt) {
                const dt = wt.featureIndex.lookupSymbolFeatures(st[wt.bucketInstanceId], A, wt.bucketIndex, wt.sourceLayerIndex, {
                  filterSpec: V.filter,
                  globalState: V.globalState
                }, V.layers, V.availableImages, I);
                for (const kt in dt) {
                  const It = ot[kt] = ot[kt] || [],
                    gt = dt[kt];
                  gt.sort(((Rt, oe) => {
                    const Qt = wt.featureSortOrder;
                    if (Qt) {
                      const re = Qt.indexOf(Rt.featureIndex);
                      return Qt.indexOf(oe.featureIndex) - re
                    }
                    return oe.featureIndex - Rt.featureIndex
                  }));
                  for (const Rt of gt) It.push(Rt)
                }
              }
              return (function(wt, dt, kt) {
                for (const It in wt)
                  for (const gt of wt[It]) nr(gt, kt[dt[It].source]);
                return wt
              })(ot, I, F)
            })(this._layers, g, this.tileManagers, e, T, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(p)
          }
          querySourceFeatures(e, o) {
            o != null && o.filter && this._validate(c.B.filter, "querySourceFeatures.filter", o.filter, null, o);
            const u = this.tileManagers[e];
            return u ? (function(h, p) {
              const g = h.getRenderableIds().map((I => h.getTileByID(I))),
                x = [],
                T = {};
              for (let I = 0; I < g.length; I++) {
                const A = g[I],
                  F = A.tileID.canonical.key;
                T[F] || (T[F] = !0, A.querySourceFeatures(x, p))
              }
              return x
            })(u, o ? Object.assign(Object.assign({}, o), {
              globalState: this._globalState
            }) : {
              globalState: this._globalState
            }) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, o = {}) {
            this._checkLoaded();
            const u = this.light.getLight();
            let h = !1;
            for (const g in e)
              if (!c.bK(e[g], u[g])) {
                h = !0;
                break
              } if (!h) return;
            const p = {
              now: lt(),
              transition: c.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, o), this.light.updateTransitions(p)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, o = {}) {
            this._checkLoaded();
            const u = this.getSky();
            let h = !1;
            if (!e && !u) return;
            if (e && !u) h = !0;
            else if (!e && u) h = !0;
            else
              for (const g in e)
                if (!c.bK(e[g], u[g])) {
                  h = !0;
                  break
                } if (!h) return;
            const p = {
              now: lt(),
              transition: c.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, o), this.sky.updateTransitions(p)
          }
          _setProjectionInternal(e) {
            const o = (function(u, h) {
              const p = {
                constrain: h
              };
              if (Array.isArray(u)) {
                const g = new vi({
                  type: u
                });
                return {
                  projection: g,
                  transform: new ku(p),
                  cameraHelper: new Va(g)
                }
              }
              switch (u) {
                case "mercator":
                  return {
                    projection: new Vn, transform: new $i(p), cameraHelper: new ji
                  };
                case "globe": {
                  const g = new vi({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: g,
                    transform: new ku(p),
                    cameraHelper: new Va(g)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new Qo, transform: new wu(p), cameraHelper: new No
                  };
                default:
                  return c.w(`Unknown projection name: ${u}. Falling back to mercator projection.`), {
                    projection: new Vn,
                    transform: new $i(p),
                    cameraHelper: new ji
                  }
              }
            })(e, this.map.transformConstrain);
            this.projection = o.projection, this.map.migrateProjection(o.transform, o.cameraHelper);
            for (const u in this.tileManagers) this.tileManagers[u].reload()
          }
          _validate(e, o, u, h, p = {}) {
            return (!p || p.validate !== !1) && va(this, e.call(c.B, c.e({
              key: o,
              style: this.serialize(),
              value: u,
              styleSpec: c.t
            }, h)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), U().off(dr, this._rtlPluginLoaded);
            for (const o in this._layers) this._layers[o].setEventedParent(null);
            for (const o in this.tileManagers) {
              const u = this.tileManagers[o];
              u.setEventedParent(null), u.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles()
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload()
          }
          _updateSources(e) {
            for (const o in this.tileManagers) this.tileManagers[o].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e)
          }
          _updatePlacement(e, o, u, h, p = !1) {
            let g = !1,
              x = !1;
            const T = {};
            for (const I of this._order) {
              const A = this._layers[I];
              if (A.type !== "symbol") continue;
              if (!T[A.source]) {
                const L = this.tileManagers[A.source];
                T[A.source] = L.getRenderableIds(!0).map((V => L.getTileByID(V))).sort(((V, K) => K.tileID.overscaledZ - V.tileID.overscaledZ || (V.tileID.isLessThan(K.tileID) ? -1 : 1)))
              }
              const F = this.crossTileSymbolIndex.addLayer(A, T[A.source], e.center.lng);
              g = g || F
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((p = p || this._layerOrderChanged || u === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(lt(), e.zoom)) && (this.pauseablePlacement = new Rr(e, this.map.terrain, this._order, p, o, u, h, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, T), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(lt()), x = !0), g && this.pauseablePlacement.placement.setStale()), x || g)
              for (const I of this._order) {
                const A = this._layers[I];
                A.type === "symbol" && this.placement.updateLayerOpacities(A, T[A.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(lt())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles()
          }
          getImages(e, o) {
            return c._(this, void 0, void 0, (function*() {
              const u = yield this.imageManager.getImages(o.icons);
              this._updateTilesForChangedImages();
              const h = this.tileManagers[o.source];
              return h && h.setDependencies(o.tileID.key, o.type, o.icons), u
            }))
          }
          getGlyphs(e, o) {
            return c._(this, void 0, void 0, (function*() {
              const u = yield this.glyphManager.getGlyphs(o.stacks), h = this.tileManagers[o.source];
              return h && h.setDependencies(o.tileID.key, o.type, [""]), u
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, o = {}) {
            this._checkLoaded(), e && this._validate(c.B.glyphs, "glyphs", e, null, o) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          getDashes(e, o) {
            return c._(this, void 0, void 0, (function*() {
              const u = {};
              for (const [h, p] of Object.entries(o.dashes)) u[h] = this.lineAtlas.getDash(p.dasharray, p.round);
              return u
            }))
          }
          addSprite(e, o, u = {}, h) {
            this._checkLoaded();
            const p = [{
                id: e,
                url: o
              }],
              g = [...Ct(this.stylesheet.sprite), ...p];
            this._validate(c.B.sprite, "sprite", g, null, u) || (this.stylesheet.sprite = g, this._loadSprite(p, !0, h))
          }
          removeSprite(e) {
            this._checkLoaded();
            const o = Ct(this.stylesheet.sprite);
            if (o.find((u => u.id === e))) {
              if (this._spritesImagesIds[e])
                for (const u of this._spritesImagesIds[e]) this.imageManager.removeImage(u), this._changedImages[u] = !0;
              o.splice(o.findIndex((u => u.id === e)), 1), this.stylesheet.sprite = o.length > 0 ? o : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", {
                dataType: "style"
              }))
            } else this.fire(new c.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return Ct(this.stylesheet.sprite)
          }
          setSprite(e, o = {}, u) {
            this._checkLoaded(), e && this._validate(c.B.sprite, "sprite", e, null, o) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, u) : (this._unloadSprite(), u && u(null)))
          }
        }
        var Dc = c.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class ts {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, o, u, h, p, g, x, T, I) {
            this.context = e;
            let A = this.boundPaintVertexBuffers.length !== h.length;
            for (let F = 0; !A && F < h.length; F++) this.boundPaintVertexBuffers[F] !== h[F] && (A = !0);
            !this.vao || this.boundProgram !== o || this.boundLayoutVertexBuffer !== u || A || this.boundIndexBuffer !== p || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== x || this.boundDynamicVertexBuffer2 !== T || this.boundDynamicVertexBuffer3 !== I ? this.freshBind(o, u, h, p, g, x, T, I) : (e.bindVertexArray.set(this.vao), x && x.bind(), p && p.dynamicDraw && p.bind(), T && T.bind(), I && I.bind())
          }
          freshBind(e, o, u, h, p, g, x, T) {
            const I = e.numAttributes,
              A = this.context,
              F = A.gl;
            this.vao && this.destroy(), this.vao = A.createVertexArray(), A.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = o, this.boundPaintVertexBuffers = u, this.boundIndexBuffer = h, this.boundVertexOffset = p, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = x, this.boundDynamicVertexBuffer3 = T, o.enableAttributes(F, e);
            for (const L of u) L.enableAttributes(F, e);
            g && g.enableAttributes(F, e), x && x.enableAttributes(F, e), T && T.enableAttributes(F, e), o.bind(), o.setVertexAttribPointers(F, e, p);
            for (const L of u) L.bind(), L.setVertexAttribPointers(F, e, p);
            g && (g.bind(), g.setVertexAttribPointers(F, e, p)), h && h.bind(), x && (x.bind(), x.setVertexAttribPointers(F, e, p)), T && (T.bind(), T.setVertexAttribPointers(F, e, p)), A.currentNumAttributes = I
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const jd = (d, e, o, u, h) => ({
            u_texture: 0,
            u_ele_delta: d,
            u_fog_matrix: e,
            u_fog_color: o ? o.properties.get("fog-color") : c.bi.white,
            u_fog_ground_blend: o ? o.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: h ? 0 : o ? o.calculateFogBlendOpacity(u) : 0,
            u_horizon_color: o ? o.properties.get("horizon-color") : c.bi.white,
            u_horizon_fog_blend: o ? o.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: h ? 1 : 0
          }),
          Rc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function Ss(d) {
          const e = [];
          for (let o = 0; o < d.length; o++) {
            if (d[o] === null) continue;
            const u = d[o].split(" ");
            e.push(u.pop())
          }
          return e
        }
        class Za {
          constructor(e, o, u, h, p, g, x, T, I = []) {
            const A = e.gl;
            this.program = A.createProgram();
            const F = Ss(o.staticAttributes),
              L = u ? u.getBinderAttributes() : [],
              V = F.concat(L),
              K = Ur.prelude.staticUniforms ? Ss(Ur.prelude.staticUniforms) : [],
              it = x.staticUniforms ? Ss(x.staticUniforms) : [],
              ot = o.staticUniforms ? Ss(o.staticUniforms) : [],
              st = u ? u.getBinderUniforms() : [],
              pt = K.concat(it).concat(ot).concat(st),
              wt = [];
            for (const Qt of pt) wt.indexOf(Qt) < 0 && wt.push(Qt);
            const dt = u ? u.defines() : [];
            ro(A) && dt.unshift("#version 300 es"), p && dt.push("#define OVERDRAW_INSPECTOR;"), g && dt.push("#define TERRAIN3D;"), T && dt.push(T), I && dt.push(...I);
            let kt = dt.concat(Ur.prelude.fragmentSource, x.fragmentSource, o.fragmentSource).join(`
`),
              It = dt.concat(Ur.prelude.vertexSource, x.vertexSource, o.vertexSource).join(`
`);
            ro(A) || (kt = (function(Qt) {
              return Qt.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(kt), It = (function(Qt) {
              return Qt.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(It));
            const gt = A.createShader(A.FRAGMENT_SHADER);
            if (A.isContextLost()) return void(this.failedToCreate = !0);
            if (A.shaderSource(gt, kt), A.compileShader(gt), !A.getShaderParameter(gt, A.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${A.getShaderInfoLog(gt)}`);
            A.attachShader(this.program, gt);
            const Rt = A.createShader(A.VERTEX_SHADER);
            if (A.isContextLost()) return void(this.failedToCreate = !0);
            if (A.shaderSource(Rt, It), A.compileShader(Rt), !A.getShaderParameter(Rt, A.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${A.getShaderInfoLog(Rt)}`);
            A.attachShader(this.program, Rt), this.attributes = {};
            const oe = {};
            this.numAttributes = V.length;
            for (let Qt = 0; Qt < this.numAttributes; Qt++) V[Qt] && (A.bindAttribLocation(this.program, Qt, V[Qt]), this.attributes[V[Qt]] = Qt);
            if (A.linkProgram(this.program), !A.getProgramParameter(this.program, A.LINK_STATUS)) throw new Error(`Program failed to link: ${A.getProgramInfoLog(this.program)}`);
            A.deleteShader(Rt), A.deleteShader(gt);
            for (let Qt = 0; Qt < wt.length; Qt++) {
              const re = wt[Qt];
              if (re && !oe[re]) {
                const ue = A.getUniformLocation(this.program, re);
                ue && (oe[re] = ue)
              }
            }
            this.fixedUniforms = h(e, oe), this.terrainUniforms = ((Qt, re) => ({
              u_depth: new c.bT(Qt, re.u_depth),
              u_terrain: new c.bT(Qt, re.u_terrain),
              u_terrain_dim: new c.bj(Qt, re.u_terrain_dim),
              u_terrain_matrix: new c.bV(Qt, re.u_terrain_matrix),
              u_terrain_unpack: new c.bW(Qt, re.u_terrain_unpack),
              u_terrain_exaggeration: new c.bj(Qt, re.u_terrain_exaggeration)
            }))(e, oe), this.projectionUniforms = ((Qt, re) => ({
              u_projection_matrix: new c.bV(Qt, re.u_projection_matrix),
              u_projection_tile_mercator_coords: new c.bW(Qt, re.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new c.bW(Qt, re.u_projection_clipping_plane),
              u_projection_transition: new c.bj(Qt, re.u_projection_transition),
              u_projection_fallback_matrix: new c.bV(Qt, re.u_projection_fallback_matrix)
            }))(e, oe), this.binderUniforms = u ? u.getUniforms(e, oe) : []
          }
          draw(e, o, u, h, p, g, x, T, I, A, F, L, V, K, it, ot, st, pt, wt) {
            const dt = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(u), e.setStencilMode(h), e.setColorMode(p), e.setCullFace(g), T) {
              e.activeTexture.set(dt.TEXTURE2), dt.bindTexture(dt.TEXTURE_2D, T.depthTexture), e.activeTexture.set(dt.TEXTURE3), dt.bindTexture(dt.TEXTURE_2D, T.texture);
              for (const It in this.terrainUniforms) this.terrainUniforms[It].set(T[It])
            }
            if (I)
              for (const It in I) this.projectionUniforms[Rc[It]].set(I[It]);
            if (x)
              for (const It in this.fixedUniforms) this.fixedUniforms[It].set(x[It]);
            ot && ot.setUniforms(e, this.binderUniforms, K, {
              zoom: it
            });
            let kt = 0;
            switch (o) {
              case dt.LINES:
                kt = 2;
                break;
              case dt.TRIANGLES:
                kt = 3;
                break;
              case dt.LINE_STRIP:
                kt = 1
            }
            for (const It of V.get()) {
              const gt = It.vaos || (It.vaos = {});
              (gt[A] || (gt[A] = new ts)).bind(e, this, F, ot ? ot.getPaintVertexBuffers() : [], L, It.vertexOffset, st, pt, wt), dt.drawElements(o, It.primitiveLength * kt, dt.UNSIGNED_SHORT, It.primitiveOffset * kt * 2)
            }
          }
        }

        function R_(d, e, o) {
          const u = 1 / c.aG(o, 1, e.transform.tileZoom),
            h = Math.pow(2, o.tileID.overscaledZ),
            p = o.tileSize * Math.pow(2, e.transform.tileZoom) / h,
            g = p * (o.tileID.canonical.x + o.tileID.wrap * h),
            x = p * o.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: o.imageAtlasTexture.size,
            u_scale: [u, d.fromScale, d.toScale],
            u_fade: d.t,
            u_pixel_coord_upper: [g >> 16, x >> 16],
            u_pixel_coord_lower: [65535 & g, 65535 & x]
          }
        }
        const Ga = (d, e, o, u) => {
            const h = d.style.light,
              p = h.properties.get("position"),
              g = [p.x, p.y, p.z],
              x = c.bZ();
            h.properties.get("anchor") === "viewport" && c.b_(x, d.transform.bearingInRadians), c.b$(g, g, x);
            const T = d.transform.transformLightDirection(g),
              I = h.properties.get("color");
            return {
              u_lightpos: g,
              u_lightpos_globe: T,
              u_lightintensity: h.properties.get("intensity"),
              u_lightcolor: [I.r, I.g, I.b],
              u_vertical_gradient: +e,
              u_opacity: o,
              u_fill_translate: u
            }
          },
          Ld = (d, e, o, u, h, p, g) => c.e(Ga(d, e, o, u), R_(p, d, g), {
            u_height_factor: -Math.pow(2, h.overscaledZ) / g.tileSize / 8
          }),
          Os = (d, e, o, u) => c.e(R_(e, d, o), {
            u_fill_translate: u
          }),
          Dd = (d, e) => ({
            u_world: d,
            u_fill_translate: e
          }),
          B_ = (d, e, o, u, h) => c.e(Os(d, e, o, h), {
            u_world: u
          }),
          Rd = (d, e, o, u, h) => {
            const p = d.transform;
            let g, x, T = 0;
            if (o.paint.get("circle-pitch-alignment") === "map") {
              const I = c.aG(e, 1, p.zoom);
              g = !0, x = [I, I], T = I / (c.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * h
            } else g = !1, x = p.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: p.cameraToCenterDistance,
              u_scale_with_map: +(o.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +g,
              u_device_pixel_ratio: d.pixelRatio,
              u_extrude_scale: x,
              u_globe_extrude_scale: T,
              u_translate: u
            }
          },
          F_ = d => ({
            u_pixel_extrude_scale: [1 / d.width, 1 / d.height]
          }),
          Bc = d => ({
            u_viewport_size: [d.width, d.height]
          }),
          Fc = (d, e = 1) => ({
            u_color: d,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Oc = (d, e, o, u) => {
            const h = c.aG(d, 1, e) / (c.a3 * Math.pow(2, d.tileID.overscaledZ)) * 2 * Math.PI * u;
            return {
              u_extrude_scale: c.aG(d, 1, e),
              u_intensity: o,
              u_globe_extrude_scale: h
            }
          },
          qc = (d, e, o, u) => {
            const h = c.M();
            c.c0(h, 0, d.width, d.height, 0, 0, 1);
            const p = d.context.gl;
            return {
              u_matrix: h,
              u_world: [p.drawingBufferWidth, p.drawingBufferHeight],
              u_image: o,
              u_color_ramp: u,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          O_ = (d, e, o) => {
            const u = o.paint.get("hillshade-accent-color");
            let h;
            switch (o.paint.get("hillshade-method")) {
              case "basic":
                h = 4;
                break;
              case "combined":
                h = 1;
                break;
              case "igor":
                h = 2;
                break;
              case "multidirectional":
                h = 3;
                break;
              default:
                h = 0
            }
            const p = o.getIlluminationProperties();
            for (let g = 0; g < p.directionRadians.length; g++) o.paint.get("hillshade-illumination-anchor") === "viewport" && (p.directionRadians[g] += d.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: q_(0, e.tileID),
              u_exaggeration: o.paint.get("hillshade-exaggeration"),
              u_altitudes: p.altitudeRadians,
              u_azimuths: p.directionRadians,
              u_accent: u,
              u_method: h,
              u_highlights: p.highlightColor,
              u_shadows: p.shadowColor
            }
          },
          qs = (d, e) => {
            const o = e.stride,
              u = c.M();
            return c.c0(u, 0, c.a3, -c.a3, 0, 0, 1), c.N(u, u, [0, -c.a3, 0]), {
              u_matrix: u,
              u_image: 1,
              u_dimension: [o, o],
              u_zoom: d.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function q_(d, e) {
          const o = Math.pow(2, e.canonical.z),
            u = e.canonical.y;
          return [new c.a5(0, u / o).toLngLat().lat, new c.a5(0, (u + 1) / o).toLngLat().lat]
        }
        const N_ = (d, e, o = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: o,
            u_opacity: d.paint.get("color-relief-opacity")
          }),
          Ps = (d, e, o, u) => {
            const h = d.transform;
            return {
              u_translation: Nc(d, e, o),
              u_ratio: u / c.aG(e, 1, h.zoom),
              u_device_pixel_ratio: d.pixelRatio,
              u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]]
            }
          },
          Bd = (d, e, o, u, h) => c.e(Ps(d, e, o, u), {
            u_image: 0,
            u_image_height: h
          }),
          Su = (d, e, o, u, h) => {
            const p = d.transform,
              g = Pu(e, p);
            return {
              u_translation: Nc(d, e, o),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: u / c.aG(e, 1, p.zoom),
              u_device_pixel_ratio: d.pixelRatio,
              u_image: 0,
              u_scale: [g, h.fromScale, h.toScale],
              u_fade: h.t,
              u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]]
            }
          },
          Fd = (d, e, o, u, h) => {
            const p = Pu(e, d.transform);
            return c.e(Ps(d, e, o, u), {
              u_tileratio: p,
              u_crossfade_from: h.fromScale,
              u_crossfade_to: h.toScale,
              u_image: 0,
              u_mix: h.t,
              u_lineatlas_width: d.lineAtlas.width,
              u_lineatlas_height: d.lineAtlas.height
            })
          },
          Od = (d, e, o, u, h, p) => {
            const g = Pu(e, d.transform);
            return c.e(Ps(d, e, o, u), {
              u_image: 0,
              u_image_height: p,
              u_tileratio: g,
              u_crossfade_from: h.fromScale,
              u_crossfade_to: h.toScale,
              u_image_dash: 1,
              u_mix: h.t,
              u_lineatlas_width: d.lineAtlas.width,
              u_lineatlas_height: d.lineAtlas.height
            })
          };

        function Pu(d, e) {
          return 1 / c.aG(d, 1, e.tileZoom)
        }

        function Nc(d, e, o) {
          return c.aH(d.transform, e, o.paint.get("line-translate"), o.paint.get("line-translate-anchor"))
        }
        const V_ = (d, e, o, u, h) => {
          return {
            u_tl_parent: d,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: o.mix,
            u_opacity: o.opacity * u.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: u.paint.get("raster-brightness-min"),
            u_brightness_high: u.paint.get("raster-brightness-max"),
            u_saturation_factor: (g = u.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g),
            u_contrast_factor: (p = u.paint.get("raster-contrast"), p > 0 ? 1 / (1 - p) : 1 + p),
            u_spin_weights: Vc(u.paint.get("raster-hue-rotate")),
            u_coords_top: [h[0].x, h[0].y, h[1].x, h[1].y],
            u_coords_bottom: [h[3].x, h[3].y, h[2].x, h[2].y]
          };
          var p, g
        };

        function Vc(d) {
          d *= Math.PI / 180;
          const e = Math.sin(d),
            o = Math.cos(d);
          return [(2 * o + 1) / 3, (-Math.sqrt(3) * e - o + 1) / 3, (Math.sqrt(3) * e - o + 1) / 3]
        }
        const Uc = (d, e, o, u, h, p, g, x, T, I, A, F, L) => {
            const V = g.transform;
            return {
              u_is_size_zoom_constant: +(d === "constant" || d === "source"),
              u_is_size_feature_constant: +(d === "constant" || d === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: V.cameraToCenterDistance,
              u_pitch: V.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +o,
              u_aspect_ratio: V.width / V.height,
              u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1,
              u_label_plane_matrix: x,
              u_coord_matrix: T,
              u_is_text: +A,
              u_pitch_with_map: +u,
              u_is_along_line: h,
              u_is_variable_anchor: p,
              u_texsize: F,
              u_texture: 0,
              u_translation: I,
              u_pitched_scale: L
            }
          },
          Ha = (d, e, o, u, h, p, g, x, T, I, A, F, L, V) => {
            const K = g.transform;
            return c.e(Uc(d, e, o, u, h, p, g, x, T, I, A, F, V), {
              u_gamma_scale: u ? Math.cos(K.pitch * Math.PI / 180) * K.cameraToCenterDistance : 1,
              u_device_pixel_ratio: g.pixelRatio,
              u_is_halo: 1
            })
          },
          as = (d, e, o, u, h, p, g, x, T, I, A, F, L) => c.e(Ha(d, e, o, u, h, p, g, x, T, I, !0, A, 0, L), {
            u_texsize_icon: F,
            u_texture_icon: 1
          }),
          Zc = (d, e) => ({
            u_opacity: d,
            u_color: e
          }),
          Gc = (d, e, o, u, h) => c.e((function(p, g, x, T) {
            const I = x.imageManager.getPattern(p.from.toString()),
              A = x.imageManager.getPattern(p.to.toString()),
              {
                width: F,
                height: L
              } = x.imageManager.getPixelSize(),
              V = Math.pow(2, T.tileID.overscaledZ),
              K = T.tileSize * Math.pow(2, x.transform.tileZoom) / V,
              it = K * (T.tileID.canonical.x + T.tileID.wrap * V),
              ot = K * T.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: I.tl,
              u_pattern_br_a: I.br,
              u_pattern_tl_b: A.tl,
              u_pattern_br_b: A.br,
              u_texsize: [F, L],
              u_mix: g.t,
              u_pattern_size_a: I.displaySize,
              u_pattern_size_b: A.displaySize,
              u_scale_a: g.fromScale,
              u_scale_b: g.toScale,
              u_tile_units_to_pixels: 1 / c.aG(T, 1, x.transform.tileZoom),
              u_pixel_coord_upper: [it >> 16, ot >> 16],
              u_pixel_coord_lower: [65535 & it, 65535 & ot]
            }
          })(o, h, e, u), {
            u_opacity: d
          }),
          Mu = (d, e) => {},
          U_ = {
            fillExtrusion: (d, e) => ({
              u_lightpos: new c.bX(d, e.u_lightpos),
              u_lightpos_globe: new c.bX(d, e.u_lightpos_globe),
              u_lightintensity: new c.bj(d, e.u_lightintensity),
              u_lightcolor: new c.bX(d, e.u_lightcolor),
              u_vertical_gradient: new c.bj(d, e.u_vertical_gradient),
              u_opacity: new c.bj(d, e.u_opacity),
              u_fill_translate: new c.bY(d, e.u_fill_translate)
            }),
            fillExtrusionPattern: (d, e) => ({
              u_lightpos: new c.bX(d, e.u_lightpos),
              u_lightpos_globe: new c.bX(d, e.u_lightpos_globe),
              u_lightintensity: new c.bj(d, e.u_lightintensity),
              u_lightcolor: new c.bX(d, e.u_lightcolor),
              u_vertical_gradient: new c.bj(d, e.u_vertical_gradient),
              u_height_factor: new c.bj(d, e.u_height_factor),
              u_opacity: new c.bj(d, e.u_opacity),
              u_fill_translate: new c.bY(d, e.u_fill_translate),
              u_image: new c.bT(d, e.u_image),
              u_texsize: new c.bY(d, e.u_texsize),
              u_pixel_coord_upper: new c.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new c.bY(d, e.u_pixel_coord_lower),
              u_scale: new c.bX(d, e.u_scale),
              u_fade: new c.bj(d, e.u_fade)
            }),
            fill: (d, e) => ({
              u_fill_translate: new c.bY(d, e.u_fill_translate)
            }),
            fillPattern: (d, e) => ({
              u_image: new c.bT(d, e.u_image),
              u_texsize: new c.bY(d, e.u_texsize),
              u_pixel_coord_upper: new c.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new c.bY(d, e.u_pixel_coord_lower),
              u_scale: new c.bX(d, e.u_scale),
              u_fade: new c.bj(d, e.u_fade),
              u_fill_translate: new c.bY(d, e.u_fill_translate)
            }),
            fillOutline: (d, e) => ({
              u_world: new c.bY(d, e.u_world),
              u_fill_translate: new c.bY(d, e.u_fill_translate)
            }),
            fillOutlinePattern: (d, e) => ({
              u_world: new c.bY(d, e.u_world),
              u_image: new c.bT(d, e.u_image),
              u_texsize: new c.bY(d, e.u_texsize),
              u_pixel_coord_upper: new c.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new c.bY(d, e.u_pixel_coord_lower),
              u_scale: new c.bX(d, e.u_scale),
              u_fade: new c.bj(d, e.u_fade),
              u_fill_translate: new c.bY(d, e.u_fill_translate)
            }),
            circle: (d, e) => ({
              u_camera_to_center_distance: new c.bj(d, e.u_camera_to_center_distance),
              u_scale_with_map: new c.bT(d, e.u_scale_with_map),
              u_pitch_with_map: new c.bT(d, e.u_pitch_with_map),
              u_extrude_scale: new c.bY(d, e.u_extrude_scale),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new c.bj(d, e.u_globe_extrude_scale),
              u_translate: new c.bY(d, e.u_translate)
            }),
            collisionBox: (d, e) => ({
              u_pixel_extrude_scale: new c.bY(d, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (d, e) => ({
              u_viewport_size: new c.bY(d, e.u_viewport_size)
            }),
            debug: (d, e) => ({
              u_color: new c.bU(d, e.u_color),
              u_overlay: new c.bT(d, e.u_overlay),
              u_overlay_scale: new c.bj(d, e.u_overlay_scale)
            }),
            depth: Mu,
            clippingMask: Mu,
            heatmap: (d, e) => ({
              u_extrude_scale: new c.bj(d, e.u_extrude_scale),
              u_intensity: new c.bj(d, e.u_intensity),
              u_globe_extrude_scale: new c.bj(d, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (d, e) => ({
              u_matrix: new c.bV(d, e.u_matrix),
              u_world: new c.bY(d, e.u_world),
              u_image: new c.bT(d, e.u_image),
              u_color_ramp: new c.bT(d, e.u_color_ramp),
              u_opacity: new c.bj(d, e.u_opacity)
            }),
            hillshade: (d, e) => ({
              u_image: new c.bT(d, e.u_image),
              u_latrange: new c.bY(d, e.u_latrange),
              u_exaggeration: new c.bj(d, e.u_exaggeration),
              u_altitudes: new c.c2(d, e.u_altitudes),
              u_azimuths: new c.c2(d, e.u_azimuths),
              u_accent: new c.bU(d, e.u_accent),
              u_method: new c.bT(d, e.u_method),
              u_shadows: new c.c1(d, e.u_shadows),
              u_highlights: new c.c1(d, e.u_highlights)
            }),
            hillshadePrepare: (d, e) => ({
              u_matrix: new c.bV(d, e.u_matrix),
              u_image: new c.bT(d, e.u_image),
              u_dimension: new c.bY(d, e.u_dimension),
              u_zoom: new c.bj(d, e.u_zoom),
              u_unpack: new c.bW(d, e.u_unpack)
            }),
            colorRelief: (d, e) => ({
              u_image: new c.bT(d, e.u_image),
              u_unpack: new c.bW(d, e.u_unpack),
              u_dimension: new c.bY(d, e.u_dimension),
              u_elevation_stops: new c.bT(d, e.u_elevation_stops),
              u_color_stops: new c.bT(d, e.u_color_stops),
              u_color_ramp_size: new c.bT(d, e.u_color_ramp_size),
              u_opacity: new c.bj(d, e.u_opacity)
            }),
            line: (d, e) => ({
              u_translation: new c.bY(d, e.u_translation),
              u_ratio: new c.bj(d, e.u_ratio),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new c.bY(d, e.u_units_to_pixels)
            }),
            lineGradient: (d, e) => ({
              u_translation: new c.bY(d, e.u_translation),
              u_ratio: new c.bj(d, e.u_ratio),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new c.bY(d, e.u_units_to_pixels),
              u_image: new c.bT(d, e.u_image),
              u_image_height: new c.bj(d, e.u_image_height)
            }),
            linePattern: (d, e) => ({
              u_translation: new c.bY(d, e.u_translation),
              u_texsize: new c.bY(d, e.u_texsize),
              u_ratio: new c.bj(d, e.u_ratio),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_image: new c.bT(d, e.u_image),
              u_units_to_pixels: new c.bY(d, e.u_units_to_pixels),
              u_scale: new c.bX(d, e.u_scale),
              u_fade: new c.bj(d, e.u_fade)
            }),
            lineSDF: (d, e) => ({
              u_translation: new c.bY(d, e.u_translation),
              u_ratio: new c.bj(d, e.u_ratio),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new c.bY(d, e.u_units_to_pixels),
              u_image: new c.bT(d, e.u_image),
              u_mix: new c.bj(d, e.u_mix),
              u_tileratio: new c.bj(d, e.u_tileratio),
              u_crossfade_from: new c.bj(d, e.u_crossfade_from),
              u_crossfade_to: new c.bj(d, e.u_crossfade_to),
              u_lineatlas_width: new c.bj(d, e.u_lineatlas_width),
              u_lineatlas_height: new c.bj(d, e.u_lineatlas_height)
            }),
            lineGradientSDF: (d, e) => ({
              u_translation: new c.bY(d, e.u_translation),
              u_ratio: new c.bj(d, e.u_ratio),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new c.bY(d, e.u_units_to_pixels),
              u_image: new c.bT(d, e.u_image),
              u_image_height: new c.bj(d, e.u_image_height),
              u_tileratio: new c.bj(d, e.u_tileratio),
              u_crossfade_from: new c.bj(d, e.u_crossfade_from),
              u_crossfade_to: new c.bj(d, e.u_crossfade_to),
              u_image_dash: new c.bT(d, e.u_image_dash),
              u_mix: new c.bj(d, e.u_mix),
              u_lineatlas_width: new c.bj(d, e.u_lineatlas_width),
              u_lineatlas_height: new c.bj(d, e.u_lineatlas_height)
            }),
            raster: (d, e) => ({
              u_tl_parent: new c.bY(d, e.u_tl_parent),
              u_scale_parent: new c.bj(d, e.u_scale_parent),
              u_buffer_scale: new c.bj(d, e.u_buffer_scale),
              u_fade_t: new c.bj(d, e.u_fade_t),
              u_opacity: new c.bj(d, e.u_opacity),
              u_image0: new c.bT(d, e.u_image0),
              u_image1: new c.bT(d, e.u_image1),
              u_brightness_low: new c.bj(d, e.u_brightness_low),
              u_brightness_high: new c.bj(d, e.u_brightness_high),
              u_saturation_factor: new c.bj(d, e.u_saturation_factor),
              u_contrast_factor: new c.bj(d, e.u_contrast_factor),
              u_spin_weights: new c.bX(d, e.u_spin_weights),
              u_coords_top: new c.bW(d, e.u_coords_top),
              u_coords_bottom: new c.bW(d, e.u_coords_bottom)
            }),
            symbolIcon: (d, e) => ({
              u_is_size_zoom_constant: new c.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new c.bT(d, e.u_is_size_feature_constant),
              u_size_t: new c.bj(d, e.u_size_t),
              u_size: new c.bj(d, e.u_size),
              u_camera_to_center_distance: new c.bj(d, e.u_camera_to_center_distance),
              u_pitch: new c.bj(d, e.u_pitch),
              u_rotate_symbol: new c.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new c.bj(d, e.u_aspect_ratio),
              u_fade_change: new c.bj(d, e.u_fade_change),
              u_label_plane_matrix: new c.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new c.bV(d, e.u_coord_matrix),
              u_is_text: new c.bT(d, e.u_is_text),
              u_pitch_with_map: new c.bT(d, e.u_pitch_with_map),
              u_is_along_line: new c.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new c.bT(d, e.u_is_variable_anchor),
              u_texsize: new c.bY(d, e.u_texsize),
              u_texture: new c.bT(d, e.u_texture),
              u_translation: new c.bY(d, e.u_translation),
              u_pitched_scale: new c.bj(d, e.u_pitched_scale)
            }),
            symbolSDF: (d, e) => ({
              u_is_size_zoom_constant: new c.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new c.bT(d, e.u_is_size_feature_constant),
              u_size_t: new c.bj(d, e.u_size_t),
              u_size: new c.bj(d, e.u_size),
              u_camera_to_center_distance: new c.bj(d, e.u_camera_to_center_distance),
              u_pitch: new c.bj(d, e.u_pitch),
              u_rotate_symbol: new c.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new c.bj(d, e.u_aspect_ratio),
              u_fade_change: new c.bj(d, e.u_fade_change),
              u_label_plane_matrix: new c.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new c.bV(d, e.u_coord_matrix),
              u_is_text: new c.bT(d, e.u_is_text),
              u_pitch_with_map: new c.bT(d, e.u_pitch_with_map),
              u_is_along_line: new c.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new c.bT(d, e.u_is_variable_anchor),
              u_texsize: new c.bY(d, e.u_texsize),
              u_texture: new c.bT(d, e.u_texture),
              u_gamma_scale: new c.bj(d, e.u_gamma_scale),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_is_halo: new c.bT(d, e.u_is_halo),
              u_translation: new c.bY(d, e.u_translation),
              u_pitched_scale: new c.bj(d, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (d, e) => ({
              u_is_size_zoom_constant: new c.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new c.bT(d, e.u_is_size_feature_constant),
              u_size_t: new c.bj(d, e.u_size_t),
              u_size: new c.bj(d, e.u_size),
              u_camera_to_center_distance: new c.bj(d, e.u_camera_to_center_distance),
              u_pitch: new c.bj(d, e.u_pitch),
              u_rotate_symbol: new c.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new c.bj(d, e.u_aspect_ratio),
              u_fade_change: new c.bj(d, e.u_fade_change),
              u_label_plane_matrix: new c.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new c.bV(d, e.u_coord_matrix),
              u_is_text: new c.bT(d, e.u_is_text),
              u_pitch_with_map: new c.bT(d, e.u_pitch_with_map),
              u_is_along_line: new c.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new c.bT(d, e.u_is_variable_anchor),
              u_texsize: new c.bY(d, e.u_texsize),
              u_texsize_icon: new c.bY(d, e.u_texsize_icon),
              u_texture: new c.bT(d, e.u_texture),
              u_texture_icon: new c.bT(d, e.u_texture_icon),
              u_gamma_scale: new c.bj(d, e.u_gamma_scale),
              u_device_pixel_ratio: new c.bj(d, e.u_device_pixel_ratio),
              u_is_halo: new c.bT(d, e.u_is_halo),
              u_translation: new c.bY(d, e.u_translation),
              u_pitched_scale: new c.bj(d, e.u_pitched_scale)
            }),
            background: (d, e) => ({
              u_opacity: new c.bj(d, e.u_opacity),
              u_color: new c.bU(d, e.u_color)
            }),
            backgroundPattern: (d, e) => ({
              u_opacity: new c.bj(d, e.u_opacity),
              u_image: new c.bT(d, e.u_image),
              u_pattern_tl_a: new c.bY(d, e.u_pattern_tl_a),
              u_pattern_br_a: new c.bY(d, e.u_pattern_br_a),
              u_pattern_tl_b: new c.bY(d, e.u_pattern_tl_b),
              u_pattern_br_b: new c.bY(d, e.u_pattern_br_b),
              u_texsize: new c.bY(d, e.u_texsize),
              u_mix: new c.bj(d, e.u_mix),
              u_pattern_size_a: new c.bY(d, e.u_pattern_size_a),
              u_pattern_size_b: new c.bY(d, e.u_pattern_size_b),
              u_scale_a: new c.bj(d, e.u_scale_a),
              u_scale_b: new c.bj(d, e.u_scale_b),
              u_pixel_coord_upper: new c.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new c.bY(d, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new c.bj(d, e.u_tile_units_to_pixels)
            }),
            terrain: (d, e) => ({
              u_texture: new c.bT(d, e.u_texture),
              u_ele_delta: new c.bj(d, e.u_ele_delta),
              u_fog_matrix: new c.bV(d, e.u_fog_matrix),
              u_fog_color: new c.bU(d, e.u_fog_color),
              u_fog_ground_blend: new c.bj(d, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new c.bj(d, e.u_fog_ground_blend_opacity),
              u_horizon_color: new c.bU(d, e.u_horizon_color),
              u_horizon_fog_blend: new c.bj(d, e.u_horizon_fog_blend),
              u_is_globe_mode: new c.bj(d, e.u_is_globe_mode)
            }),
            terrainDepth: (d, e) => ({
              u_ele_delta: new c.bj(d, e.u_ele_delta)
            }),
            terrainCoords: (d, e) => ({
              u_texture: new c.bT(d, e.u_texture),
              u_terrain_coords_id: new c.bj(d, e.u_terrain_coords_id),
              u_ele_delta: new c.bj(d, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (d, e) => ({
              u_input: new c.bj(d, e.u_input),
              u_output_expected: new c.bj(d, e.u_output_expected)
            }),
            atmosphere: (d, e) => ({
              u_sun_pos: new c.bX(d, e.u_sun_pos),
              u_atmosphere_blend: new c.bj(d, e.u_atmosphere_blend),
              u_globe_position: new c.bX(d, e.u_globe_position),
              u_globe_radius: new c.bj(d, e.u_globe_radius),
              u_inv_proj_matrix: new c.bV(d, e.u_inv_proj_matrix)
            }),
            sky: (d, e) => ({
              u_sky_color: new c.bU(d, e.u_sky_color),
              u_horizon_color: new c.bU(d, e.u_horizon_color),
              u_horizon: new c.bY(d, e.u_horizon),
              u_horizon_normal: new c.bY(d, e.u_horizon_normal),
              u_sky_horizon_blend: new c.bj(d, e.u_sky_horizon_blend),
              u_sky_blend: new c.bj(d, e.u_sky_blend)
            })
          };
        class Hc {
          constructor(e, o, u) {
            this.context = e;
            const h = e.gl;
            this.buffer = h.createBuffer(), this.dynamicDraw = !!u, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), h.bufferData(h.ELEMENT_ARRAY_BUFFER, o.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete o.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const o = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), o.bufferSubData(o.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const Ns = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Wc {
          constructor(e, o, u, h) {
            this.length = o.length, this.attributes = u, this.itemSize = o.bytesPerElement, this.dynamicDraw = h, this.context = e;
            const p = e.gl;
            this.buffer = p.createBuffer(), e.bindVertexBuffer.set(this.buffer), p.bufferData(p.ARRAY_BUFFER, o.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete o.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const o = this.context.gl;
            this.bind(), o.bufferSubData(o.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, o) {
            for (let u = 0; u < this.attributes.length; u++) {
              const h = o.attributes[this.attributes[u].name];
              h !== void 0 && e.enableVertexAttribArray(h)
            }
          }
          setVertexAttribPointers(e, o, u) {
            for (let h = 0; h < this.attributes.length; h++) {
              const p = this.attributes[h],
                g = o.attributes[p.name];
              g !== void 0 && e.vertexAttribPointer(g, p.components, e[Ns[p.type]], !1, this.itemSize, p.offset + this.itemSize * (u || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class Zn {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class qd extends Zn {
          getDefault() {
            return c.bi.transparent
          }
          set(e) {
            const o = this.current;
            (e.r !== o.r || e.g !== o.g || e.b !== o.b || e.a !== o.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Nd extends Zn {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class Vd extends Zn {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Z_ extends Zn {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const o = this.current;
            (e[0] !== o[0] || e[1] !== o[1] || e[2] !== o[2] || e[3] !== o[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Ud extends Zn {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class G_ extends Zn {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Cu extends Zn {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const o = this.current;
            (e.func !== o.func || e.ref !== o.ref || e.mask !== o.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Iu extends Zn {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const o = this.current;
            (e[0] !== o[0] || e[1] !== o[1] || e[2] !== o[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class zu extends Zn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            e ? o.enable(o.STENCIL_TEST) : o.disable(o.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class $c extends Zn {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const o = this.current;
            (e[0] !== o[0] || e[1] !== o[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Vs extends Zn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            e ? o.enable(o.DEPTH_TEST) : o.disable(o.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Wa extends Zn {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class ba extends Zn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            e ? o.enable(o.BLEND) : o.disable(o.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Ro extends Zn {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const o = this.current;
            (e[0] !== o[0] || e[1] !== o[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class H_ extends Zn {
          getDefault() {
            return c.bi.transparent
          }
          set(e) {
            const o = this.current;
            (e.r !== o.r || e.g !== o.g || e.b !== o.b || e.a !== o.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class W_ extends Zn {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class Xc extends Zn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            e ? o.enable(o.CULL_FACE) : o.disable(o.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class Us extends Zn {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Au extends Zn {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Eu extends Zn {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class $a extends Zn {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class ju extends Zn {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const o = this.current;
            (e[0] !== o[0] || e[1] !== o[1] || e[2] !== o[2] || e[3] !== o[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class $_ extends Zn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            o.bindFramebuffer(o.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class xa extends Zn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            o.bindRenderbuffer(o.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class wa extends Zn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            o.bindTexture(o.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class X_ extends Zn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            o.bindBuffer(o.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Yc extends Zn {
          getDefault() {
            return null
          }
          set(e) {
            const o = this.gl;
            o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ln extends Zn {
          getDefault() {
            return null
          }
          set(e) {
            var o;
            if (e === this.current && !this.dirty) return;
            const u = this.gl;
            ro(u) ? u.bindVertexArray(e) : (o = u.getExtension("OES_vertex_array_object")) === null || o === void 0 || o.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class Lu extends Zn {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            o.pixelStorei(o.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class Zd extends Zn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Y_ extends Zn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Zs extends Zn {
          constructor(e, o) {
            super(e), this.context = e, this.parent = o
          }
          getDefault() {
            return null
          }
        }
        class Gd extends Zs {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const o = this.gl;
            o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class Hd extends Zs {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const o = this.gl;
            o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT, o.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class K_ extends Zs {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const o = this.gl;
            o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const J_ = "Framebuffer is not complete";
        class Kc {
          constructor(e, o, u, h, p) {
            this.context = e, this.width = o, this.height = u;
            const g = e.gl,
              x = this.framebuffer = g.createFramebuffer();
            if (this.colorAttachment = new Gd(e, x), h) this.depthAttachment = p ? new K_(e, x) : new Hd(e, x);
            else if (p) throw new Error("Stencil cannot be set without depth");
            if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error(J_)
          }
          destroy() {
            const e = this.context.gl,
              o = this.colorAttachment.get();
            if (o && e.deleteTexture(o), this.depthAttachment) {
              const u = this.depthAttachment.get();
              u && e.deleteRenderbuffer(u)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class Du {
          constructor(e) {
            var o, u;
            if (this.gl = e, this.clearColor = new qd(this), this.clearDepth = new Nd(this), this.clearStencil = new Vd(this), this.colorMask = new Z_(this), this.depthMask = new Ud(this), this.stencilMask = new G_(this), this.stencilFunc = new Cu(this), this.stencilOp = new Iu(this), this.stencilTest = new zu(this), this.depthRange = new $c(this), this.depthTest = new Vs(this), this.depthFunc = new Wa(this), this.blend = new ba(this), this.blendFunc = new Ro(this), this.blendColor = new H_(this), this.blendEquation = new W_(this), this.cullFace = new Xc(this), this.cullFaceSide = new Us(this), this.frontFace = new Au(this), this.program = new Eu(this), this.activeTexture = new $a(this), this.viewport = new ju(this), this.bindFramebuffer = new $_(this), this.bindRenderbuffer = new xa(this), this.bindTexture = new wa(this), this.bindVertexBuffer = new X_(this), this.bindElementBuffer = new Yc(this), this.bindVertexArray = new Ln(this), this.pixelStoreUnpack = new Lu(this), this.pixelStoreUnpackPremultiplyAlpha = new Zd(this), this.pixelStoreUnpackFlipY = new Y_(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), ro(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const h = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (o = e.RGBA16F) !== null && o !== void 0 ? o : h == null ? void 0 : h.RGBA16F_EXT, this.RGB16F = (u = e.RGB16F) !== null && u !== void 0 ? u : h == null ? void 0 : h.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const h = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = h == null ? void 0 : h.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, o) {
            return new Hc(this, e, o)
          }
          createVertexBuffer(e, o, u) {
            return new Wc(this, e, o, u)
          }
          createRenderbuffer(e, o, u) {
            const h = this.gl,
              p = h.createRenderbuffer();
            return this.bindRenderbuffer.set(p), h.renderbufferStorage(h.RENDERBUFFER, e, o, u), this.bindRenderbuffer.set(null), p
          }
          createFramebuffer(e, o, u, h) {
            return new Kc(this, e, o, u, h)
          }
          clear({
            color: e,
            depth: o,
            stencil: u
          }) {
            const h = this.gl;
            let p = 0;
            e && (p |= h.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), o !== void 0 && (p |= h.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(o), this.depthMask.set(!0)), u !== void 0 && (p |= h.STENCIL_BUFFER_BIT, this.clearStencil.set(u), this.stencilMask.set(255)), h.clear(p)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            c.bK(e.blendFunction, Sn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return ro(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var o;
            return ro(this.gl) ? this.gl.deleteVertexArray(e) : (o = this.gl.getExtension("OES_vertex_array_object")) === null || o === void 0 ? void 0 : o.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let Gs;

        function Xa(d, e, o, u, h) {
          const p = d.context,
            g = d.transform,
            x = p.gl,
            T = d.useProgram("collisionBox"),
            I = [];
          let A = 0,
            F = 0;
          for (let st = 0; st < u.length; st++) {
            const pt = u[st],
              wt = e.getTile(pt).getBucket(o);
            if (!wt) continue;
            const dt = h ? wt.textCollisionBox : wt.iconCollisionBox,
              kt = wt.collisionCircleArray;
            kt.length > 0 && (I.push({
              circleArray: kt,
              circleOffset: F,
              coord: pt
            }), A += kt.length / 4, F = A), dt && T.draw(p, x.LINES, mn.disabled, En.disabled, d.colorModeForRenderPass(), pn.disabled, F_(d.transform), d.style.map.terrain && d.style.map.terrain.getTerrainData(pt), g.getProjectionData({
              overscaledTileID: pt,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), o.id, dt.layoutVertexBuffer, dt.indexBuffer, dt.segments, null, d.transform.zoom, null, null, dt.collisionVertexBuffer)
          }
          if (!h || !I.length) return;
          const L = d.useProgram("collisionCircle"),
            V = new c.c3;
          V.resize(4 * A), V._trim();
          let K = 0;
          for (const st of I)
            for (let pt = 0; pt < st.circleArray.length / 4; pt++) {
              const wt = 4 * pt,
                dt = st.circleArray[wt + 0],
                kt = st.circleArray[wt + 1],
                It = st.circleArray[wt + 2],
                gt = st.circleArray[wt + 3];
              V.emplace(K++, dt, kt, It, gt, 0), V.emplace(K++, dt, kt, It, gt, 1), V.emplace(K++, dt, kt, It, gt, 2), V.emplace(K++, dt, kt, It, gt, 3)
            }(!Gs || Gs.length < 2 * A) && (Gs = (function(st) {
              const pt = 2 * st,
                wt = new c.c5;
              wt.resize(pt), wt._trim();
              for (let dt = 0; dt < pt; dt++) {
                const kt = 6 * dt;
                wt.uint16[kt + 0] = 4 * dt + 0, wt.uint16[kt + 1] = 4 * dt + 1, wt.uint16[kt + 2] = 4 * dt + 2, wt.uint16[kt + 3] = 4 * dt + 2, wt.uint16[kt + 4] = 4 * dt + 3, wt.uint16[kt + 5] = 4 * dt + 0
              }
              return wt
            })(A));
          const it = p.createIndexBuffer(Gs, !0),
            ot = p.createVertexBuffer(V, c.c4.members, !0);
          for (const st of I) {
            const pt = Bc(d.transform);
            L.draw(p, x.TRIANGLES, mn.disabled, En.disabled, d.colorModeForRenderPass(), pn.disabled, pt, d.style.map.terrain && d.style.map.terrain.getTerrainData(st.coord), null, o.id, ot, it, c.aQ.simpleSegment(0, 2 * st.circleOffset, st.circleArray.length, st.circleArray.length / 2), null, d.transform.zoom, null, null, null)
          }
          ot.destroy(), it.destroy()
        }
        const Jc = c.am(new Float32Array(16));

        function Q_(d, e, o, u, h, p) {
          const {
            horizontalAlign: g,
            verticalAlign: x
          } = c.aL(d);
          return new c.P((-(g - .5) * e / h + u[0]) * p, (-(x - .5) * o / h + u[1]) * p)
        }

        function Ru(d, e, o, u, h, p) {
          const g = e.tileAnchorPoint.add(new c.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let x = u.mult(p);
            o || (x = x.rotate(-h));
            const T = g.add(x);
            return Kt(T.x, T.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (o) {
            const x = Jt(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(d),
              T = Math.atan(x.y / x.x) + (x.x < 0 ? Math.PI : 0);
            return d.add(u.rotate(T))
          }
          return d.add(u)
        }

        function Bu(d, e, o, u, h, p, g, x, T, I, A, F) {
          const L = d.text.placedSymbolArray,
            V = d.text.dynamicLayoutVertexArray,
            K = d.icon.dynamicLayoutVertexArray,
            it = {};
          V.clear();
          for (let ot = 0; ot < L.length; ot++) {
            const st = L.get(ot),
              pt = st.hidden || !st.crossTileID || d.allowVerticalPlacement && !st.placedOrientation ? null : u[st.crossTileID];
            if (pt) {
              const wt = new c.P(st.anchorX, st.anchorY),
                dt = {
                  getElevation: F,
                  width: h.width,
                  height: h.height,
                  pitchedLabelPlaneMatrix: p,
                  pitchWithMap: o,
                  transform: h,
                  tileAnchorPoint: wt,
                  translation: I,
                  unwrappedTileID: A
                },
                kt = o ? rr(wt.x, wt.y, dt) : Jt(wt.x, wt.y, dt),
                It = Oe(h.cameraToCenterDistance, kt.signedDistanceFromCamera);
              let gt = c.at(d.textSizeData, x, st) * It / c.aF;
              o && (gt *= d.tilePixelRatio / g);
              const {
                width: Rt,
                height: oe,
                anchor: Qt,
                textOffset: re,
                textBoxScale: ue
              } = pt, Je = Q_(Qt, Rt, oe, re, ue, gt), tr = h.getPitchedTextCorrection(wt.x + I[0], wt.y + I[1], A), Pe = Ru(kt.point, dt, e, Je, -h.bearingInRadians, tr), Fr = d.allowVerticalPlacement && st.placedOrientation === c.as.vertical ? Math.PI / 2 : 0;
              for (let gn = 0; gn < st.numGlyphs; gn++) c.az(V, Pe, Fr);
              T && st.associatedIconIndex >= 0 && (it[st.associatedIconIndex] = {
                shiftedAnchor: Pe,
                angle: Fr
              })
            } else on(st.numGlyphs, V)
          }
          if (T) {
            K.clear();
            const ot = d.icon.placedSymbolArray;
            for (let st = 0; st < ot.length; st++) {
              const pt = ot.get(st);
              if (pt.hidden) on(pt.numGlyphs, K);
              else {
                const wt = it[st];
                if (wt)
                  for (let dt = 0; dt < pt.numGlyphs; dt++) c.az(K, wt.shiftedAnchor, wt.angle);
                else on(pt.numGlyphs, K)
              }
            }
            d.icon.dynamicLayoutVertexBuffer.updateData(K)
          }
          d.text.dynamicLayoutVertexBuffer.updateData(V)
        }

        function Fu(d, e, o) {
          return o.iconsInText && e ? "symbolTextAndIcon" : d ? "symbolSDF" : "symbolIcon"
        }

        function Hs(d, e, o, u, h, p, g, x, T, I, A, F, L) {
          const V = d.context,
            K = V.gl,
            it = d.transform,
            ot = x === "map",
            st = T === "map",
            pt = x !== "viewport" && o.layout.get("symbol-placement") !== "point",
            wt = ot && !st && !pt,
            dt = !o.layout.get("symbol-sort-key").isConstant();
          let kt = !1;
          const It = d.getDepthModeForSublayer(0, mn.ReadOnly),
            gt = o._unevaluatedLayout.hasValue("text-variable-anchor") || o._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Rt = [],
            oe = it.getCircleRadiusCorrection();
          for (const Qt of u) {
            const re = e.getTile(Qt),
              ue = re.getBucket(o);
            if (!ue) continue;
            const Je = h ? ue.text : ue.icon;
            if (!Je || !Je.segments.get().length || !Je.hasVisibleVertices) continue;
            const tr = Je.programConfigurations.get(o.id),
              Pe = h || ue.sdfIcons,
              Fr = h ? ue.textSizeData : ue.iconSizeData,
              gn = st || it.pitch !== 0,
              Hn = d.useProgram(Fu(Pe, h, ue), tr),
              Tn = c.ar(Fr, it.zoom),
              Jn = d.style.map.terrain && d.style.map.terrain.getTerrainData(Qt);
            let _i, ei, Ii, oi, Oi = [0, 0],
              si = null;
            if (h) ei = re.glyphAtlasTexture, Ii = K.LINEAR, _i = re.glyphAtlasTexture.size, ue.iconsInText && (Oi = re.imageAtlasTexture.size, si = re.imageAtlasTexture, oi = gn || d.options.rotating || d.options.zooming || Fr.kind === "composite" || Fr.kind === "camera" ? K.LINEAR : K.NEAREST);
            else {
              const Pi = o.layout.get("icon-size").constantOr(0) !== 1 || ue.iconsNeedLinear;
              ei = re.imageAtlasTexture, Ii = Pe || d.options.rotating || d.options.zooming || Pi || gn ? K.LINEAR : K.NEAREST, _i = re.imageAtlasTexture.size
            }
            const Si = c.aG(re, 1, d.transform.zoom),
              co = Fe(ot, d.transform, Si),
              Js = c.M();
            c.au(Js, co);
            const ds = Nr(st, ot, d.transform, Si),
              rs = c.aH(it, re, p, g),
              Qs = it.getProjectionData({
                overscaledTileID: Qt,
                applyGlobeMatrix: !L,
                applyTerrainMatrix: !0
              }),
              za = gt && ue.hasTextData(),
              ta = o.layout.get("icon-text-fit") !== "none" && za && ue.hasIconData();
            if (pt) {
              const Pi = d.style.map.terrain ? (qi, ni) => d.style.map.terrain.getElevation(Qt, qi, ni) : null,
                xi = o.layout.get("text-rotation-alignment") === "map";
              fe(ue, d, h, co, Js, st, I, xi, Qt.toUnwrapped(), it.width, it.height, rs, Pi)
            }
            const go = h && gt || ta,
              lo = pt || go ? Jc : st ? co : d.transform.clipSpaceToPixelsMatrix,
              ps = Pe && o.paint.get(h ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Cs;
            Cs = Pe ? ue.iconsInText ? as(Fr.kind, Tn, wt, st, pt, go, d, lo, ds, rs, _i, Oi, oe) : Ha(Fr.kind, Tn, wt, st, pt, go, d, lo, ds, rs, h, _i, 0, oe) : Uc(Fr.kind, Tn, wt, st, pt, go, d, lo, ds, rs, h, _i, oe);
            const su = {
              program: Hn,
              buffers: Je,
              uniformValues: Cs,
              projectionData: Qs,
              atlasTexture: ei,
              atlasTextureIcon: si,
              atlasInterpolation: Ii,
              atlasInterpolationIcon: oi,
              isSDF: Pe,
              hasHalo: ps
            };
            if (dt && ue.canOverlap) {
              kt = !0;
              const Pi = Je.segments.get();
              for (const xi of Pi) Rt.push({
                segments: new c.aQ([xi]),
                sortKey: xi.sortKey,
                state: su,
                terrainData: Jn
              })
            } else Rt.push({
              segments: Je.segments,
              sortKey: 0,
              state: su,
              terrainData: Jn
            })
          }
          kt && Rt.sort(((Qt, re) => Qt.sortKey - re.sortKey));
          for (const Qt of Rt) {
            const re = Qt.state;
            if (V.activeTexture.set(K.TEXTURE0), re.atlasTexture.bind(re.atlasInterpolation, K.CLAMP_TO_EDGE), re.atlasTextureIcon && (V.activeTexture.set(K.TEXTURE1), re.atlasTextureIcon && re.atlasTextureIcon.bind(re.atlasInterpolationIcon, K.CLAMP_TO_EDGE)), re.isSDF) {
              const ue = re.uniformValues;
              re.hasHalo && (ue.u_is_halo = 1, Ou(re.buffers, Qt.segments, o, d, re.program, It, A, F, ue, re.projectionData, Qt.terrainData)), ue.u_is_halo = 0
            }
            Ou(re.buffers, Qt.segments, o, d, re.program, It, A, F, re.uniformValues, re.projectionData, Qt.terrainData)
          }
        }

        function Ou(d, e, o, u, h, p, g, x, T, I, A) {
          const F = u.context;
          h.draw(F, F.gl.TRIANGLES, p, g, x, pn.backCCW, T, A, I, o.id, d.layoutVertexBuffer, d.indexBuffer, e, o.paint, u.transform.zoom, d.programConfigurations.get(o.id), d.dynamicLayoutVertexBuffer, d.opacityVertexBuffer)
        }

        function Wd(d, e, o, u, h) {
          const p = d.context,
            g = p.gl,
            x = En.disabled,
            T = new Sn([g.ONE, g.ONE], c.bi.transparent, [!0, !0, !0, !0]),
            I = e.getBucket(o);
          if (!I) return;
          const A = u.key;
          let F = o.heatmapFbos.get(A);
          F || (F = th(p, e.tileSize, e.tileSize), o.heatmapFbos.set(A, F)), p.bindFramebuffer.set(F.framebuffer), p.viewport.set([0, 0, e.tileSize, e.tileSize]), p.clear({
            color: c.bi.transparent
          });
          const L = I.programConfigurations.get(o.id),
            V = d.useProgram("heatmap", L, !h),
            K = d.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            it = d.style.map.terrain.getTerrainData(u);
          V.draw(p, g.TRIANGLES, mn.disabled, x, T, pn.disabled, Oc(e, d.transform.zoom, o.paint.get("heatmap-intensity"), 1), it, K, o.id, I.layoutVertexBuffer, I.indexBuffer, I.segments, o.paint, d.transform.zoom, L)
        }

        function Ya(d, e, o, u, h) {
          const p = d.context,
            g = p.gl,
            x = d.transform;
          p.setColorMode(d.colorModeForRenderPass());
          const T = Qc(p, e),
            I = o.key,
            A = e.heatmapFbos.get(I);
          if (!A) return;
          p.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, A.colorAttachment.get()), p.activeTexture.set(g.TEXTURE1), T.bind(g.LINEAR, g.CLAMP_TO_EDGE);
          const F = x.getProjectionData({
            overscaledTileID: o,
            applyTerrainMatrix: h,
            applyGlobeMatrix: !u
          });
          d.useProgram("heatmapTexture").draw(p, g.TRIANGLES, mn.disabled, En.disabled, d.colorModeForRenderPass(), pn.disabled, qc(d, e, 0, 1), null, F, e.id, d.rasterBoundsBuffer, d.quadTriangleIndexBuffer, d.rasterBoundsSegments, e.paint, x.zoom), A.destroy(), e.heatmapFbos.delete(I)
        }

        function th(d, e, o) {
          var u, h;
          const p = d.gl,
            g = p.createTexture();
          p.bindTexture(p.TEXTURE_2D, g), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.LINEAR), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.LINEAR);
          const x = (u = d.HALF_FLOAT) !== null && u !== void 0 ? u : p.UNSIGNED_BYTE,
            T = (h = d.RGBA16F) !== null && h !== void 0 ? h : p.RGBA;
          p.texImage2D(p.TEXTURE_2D, 0, T, e, o, 0, p.RGBA, x, null);
          const I = d.createFramebuffer(e, o, !1, !1);
          return I.colorAttachment.set(g), I
        }

        function Qc(d, e) {
          return e.colorRampTexture || (e.colorRampTexture = new c.T(d, e.colorRamp, d.gl.RGBA)), e.colorRampTexture
        }

        function Ka(d, e, o, u, h, p, g, x) {
          let T = 256;
          if (h.stepInterpolant) {
            const I = e.getSource().maxzoom,
              A = g.canonical.z === I ? Math.ceil(1 << d.transform.maxZoom - g.canonical.z) : 1;
            T = c.ai(c.c7(p.maxLineLength / c.a3 * 1024 * A), 256, o.maxTextureSize)
          }
          return x.gradient = c.c8({
            expression: h.gradientExpression(),
            evaluationKey: "lineProgress",
            resolution: T,
            image: x.gradient || void 0,
            clips: p.lineClipsArray
          }), x.texture ? x.texture.update(x.gradient) : x.texture = new c.T(o, x.gradient, u.RGBA), x.version = h.gradientVersion, x.texture
        }

        function tl(d, e, o, u, h) {
          d.activeTexture.set(e.TEXTURE0), o.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), u.updatePaintBuffers(h)
        }

        function eh(d, e, o, u, h, p) {
          (h || d.lineAtlas.dirty) && (e.activeTexture.set(o.TEXTURE0), d.lineAtlas.bind(e)), u.updatePaintBuffers(p)
        }

        function rh(d, e, o, u, h, p, g) {
          const x = p.gradients[h.id];
          let T = x.texture;
          h.gradientVersion !== x.version && (T = Ka(d, e, o, u, h, p, g, x)), o.activeTexture.set(u.TEXTURE0), T.bind(h.stepInterpolant ? u.NEAREST : u.LINEAR, u.CLAMP_TO_EDGE)
        }

        function qu(d, e, o, u, h, p, g, x, T) {
          const I = p.gradients[h.id];
          let A = I.texture;
          h.gradientVersion !== I.version && (A = Ka(d, e, o, u, h, p, g, I)), o.activeTexture.set(u.TEXTURE0), A.bind(h.stepInterpolant ? u.NEAREST : u.LINEAR, u.CLAMP_TO_EDGE), o.activeTexture.set(u.TEXTURE1), d.lineAtlas.bind(o), x.updatePaintBuffers(T)
        }

        function Nu(d, e, o, u, h) {
          if (!o || !u || !u.imageAtlas) return;
          const p = u.imageAtlas.patternPositions;
          let g = p[o.to.toString()],
            x = p[o.from.toString()];
          if (!g && x && (g = x), !x && g && (x = g), !g || !x) {
            const T = h.getPaintProperty(e);
            g = p[T], x = p[T]
          }
          g && x && d.setConstantPatternPositions(g, x)
        }

        function nh(d, e, o, u, h, p, g, x) {
          const T = d.context.gl,
            I = "fill-pattern",
            A = o.paint.get(I),
            F = A && A.constantOr(1),
            L = o.getCrossfadeParameters();
          let V, K, it, ot, st;
          const pt = d.transform,
            wt = o.paint.get("fill-translate"),
            dt = o.paint.get("fill-translate-anchor");
          g ? (K = F && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", V = T.LINES) : (K = F ? "fillPattern" : "fill", V = T.TRIANGLES);
          const kt = A.constantOr(null);
          for (const It of u) {
            const gt = e.getTile(It);
            if (F && !gt.patternsLoaded()) continue;
            const Rt = gt.getBucket(o);
            if (!Rt) continue;
            const oe = Rt.programConfigurations.get(o.id),
              Qt = d.useProgram(K, oe),
              re = d.style.map.terrain && d.style.map.terrain.getTerrainData(It);
            F && (d.context.activeTexture.set(T.TEXTURE0), gt.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE), oe.updatePaintBuffers(L)), Nu(oe, I, kt, gt, o);
            const ue = pt.getProjectionData({
                overscaledTileID: It,
                applyGlobeMatrix: !x,
                applyTerrainMatrix: !0
              }),
              Je = c.aH(pt, gt, wt, dt);
            if (g) {
              ot = Rt.indexBuffer2, st = Rt.segments2;
              const Pe = [T.drawingBufferWidth, T.drawingBufferHeight];
              it = K === "fillOutlinePattern" && F ? B_(d, L, gt, Pe, Je) : Dd(Pe, Je)
            } else ot = Rt.indexBuffer, st = Rt.segments, it = F ? Os(d, L, gt, Je) : {
              u_fill_translate: Je
            };
            const tr = d.stencilModeForClipping(It);
            Qt.draw(d.context, V, h, tr, p, pn.backCCW, it, re, ue, o.id, Rt.layoutVertexBuffer, ot, st, o.paint, d.transform.zoom, oe)
          }
        }

        function Vu(d, e, o, u, h, p, g, x) {
          const T = d.context,
            I = T.gl,
            A = "fill-extrusion-pattern",
            F = o.paint.get(A),
            L = F.constantOr(1),
            V = o.getCrossfadeParameters(),
            K = o.paint.get("fill-extrusion-opacity"),
            it = F.constantOr(null),
            ot = d.transform;
          for (const st of u) {
            const pt = e.getTile(st),
              wt = pt.getBucket(o);
            if (!wt) continue;
            const dt = d.style.map.terrain && d.style.map.terrain.getTerrainData(st),
              kt = wt.programConfigurations.get(o.id),
              It = d.useProgram(L ? "fillExtrusionPattern" : "fillExtrusion", kt);
            L && (d.context.activeTexture.set(I.TEXTURE0), pt.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), kt.updatePaintBuffers(V));
            const gt = ot.getProjectionData({
              overscaledTileID: st,
              applyGlobeMatrix: !x,
              applyTerrainMatrix: !0
            });
            Nu(kt, A, it, pt, o);
            const Rt = c.aH(ot, pt, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")),
              oe = o.paint.get("fill-extrusion-vertical-gradient"),
              Qt = L ? Ld(d, oe, K, Rt, st, V, pt) : Ga(d, oe, K, Rt);
            It.draw(T, T.gl.TRIANGLES, h, p, g, pn.backCCW, Qt, dt, gt, o.id, wt.layoutVertexBuffer, wt.indexBuffer, wt.segments, o.paint, d.transform.zoom, kt, d.style.map.terrain && wt.centroidVertexBuffer)
          }
        }

        function ci(d, e, o, u, h, p, g, x, T) {
          var I;
          const A = d.style.projection,
            F = d.context,
            L = d.transform,
            V = F.gl,
            K = [`#define NUM_ILLUMINATION_SOURCES ${o.paint.get("hillshade-highlight-color").values.length}`],
            it = d.useProgram("hillshade", null, !1, K),
            ot = !d.options.moving;
          for (const st of u) {
            const pt = e.getTile(st),
              wt = pt.fbo;
            if (!wt) continue;
            const dt = A.getMeshFromTileID(F, st.canonical, x, !0, "raster"),
              kt = (I = d.style.map.terrain) === null || I === void 0 ? void 0 : I.getTerrainData(st);
            F.activeTexture.set(V.TEXTURE0), V.bindTexture(V.TEXTURE_2D, wt.colorAttachment.get());
            const It = L.getProjectionData({
              overscaledTileID: st,
              aligned: ot,
              applyGlobeMatrix: !T,
              applyTerrainMatrix: !0
            });
            it.draw(F, V.TRIANGLES, p, h[st.overscaledZ], g, pn.backCCW, O_(d, pt, o), kt, It, o.id, dt.vertexBuffer, dt.indexBuffer, dt.segments)
          }
        }

        function us(d, e, o, u, h, p, g, x, T) {
          var I;
          const A = d.style.projection,
            F = d.context,
            L = d.transform,
            V = F.gl,
            K = d.useProgram("colorRelief"),
            it = !d.options.moving;
          let ot = !0,
            st = 0;
          for (const pt of u) {
            const wt = e.getTile(pt),
              dt = wt.dem;
            if (ot) {
              const Qt = V.getParameter(V.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: re,
                  colorTexture: ue
                } = o.getColorRampTextures(F, Qt, dt.getUnpackVector());
              F.activeTexture.set(V.TEXTURE1), re.bind(V.NEAREST, V.CLAMP_TO_EDGE), F.activeTexture.set(V.TEXTURE4), ue.bind(V.LINEAR, V.CLAMP_TO_EDGE), ot = !1, st = re.size[0]
            }
            if (!dt || !dt.data) continue;
            const kt = dt.stride,
              It = dt.getPixels();
            if (F.activeTexture.set(V.TEXTURE0), F.pixelStoreUnpackPremultiplyAlpha.set(!1), wt.demTexture = wt.demTexture || d.getTileTexture(kt), wt.demTexture) {
              const Qt = wt.demTexture;
              Qt.update(It, {
                premultiply: !1
              }), Qt.bind(V.LINEAR, V.CLAMP_TO_EDGE)
            } else wt.demTexture = new c.T(F, It, V.RGBA, {
              premultiply: !1
            }), wt.demTexture.bind(V.LINEAR, V.CLAMP_TO_EDGE);
            const gt = A.getMeshFromTileID(F, pt.canonical, x, !0, "raster"),
              Rt = (I = d.style.map.terrain) === null || I === void 0 ? void 0 : I.getTerrainData(pt),
              oe = L.getProjectionData({
                overscaledTileID: pt,
                aligned: it,
                applyGlobeMatrix: !T,
                applyTerrainMatrix: !0
              });
            K.draw(F, V.TRIANGLES, p, h[pt.overscaledZ], g, pn.backCCW, N_(o, wt.dem, st), Rt, oe, o.id, gt.vertexBuffer, gt.indexBuffer, gt.segments)
          }
        }
        const fo = [new c.P(0, 0), new c.P(c.a3, 0), new c.P(c.a3, c.a3), new c.P(0, c.a3)];

        function ka(d, e, o, u, h, p, g, x, T = !1, I = !1) {
          const A = u[u.length - 1].overscaledZ,
            F = d.context,
            L = F.gl,
            V = d.useProgram("raster"),
            K = d.transform,
            it = d.style.projection,
            ot = d.colorModeForRenderPass(),
            st = !d.options.moving,
            pt = o.paint.get("raster-opacity"),
            wt = o.paint.get("raster-resampling"),
            dt = o.paint.get("raster-fade-duration"),
            kt = !!d.style.map.terrain;
          for (const It of u) {
            const gt = d.getDepthModeForSublayer(It.overscaledZ - A, pt === 1 ? mn.ReadWrite : mn.ReadOnly, L.LESS),
              Rt = e.getTile(It),
              oe = wt === "nearest" ? L.NEAREST : L.LINEAR;
            F.activeTexture.set(L.TEXTURE0), Rt.texture.bind(oe, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST), F.activeTexture.set(L.TEXTURE1);
            const {
              parentTile: Qt,
              parentScaleBy: re,
              parentTopLeft: ue,
              fadeValues: Je
            } = Uu(Rt, e, dt, kt);
            Rt.fadeOpacity = Je.tileOpacity, Qt ? (Qt.fadeOpacity = Je.parentTileOpacity, Qt.texture.bind(oe, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST)) : Rt.texture.bind(oe, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST), Rt.texture.useMipmap && F.extTextureFilterAnisotropic && d.transform.pitch > 20 && L.texParameterf(L.TEXTURE_2D, F.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, F.extTextureFilterAnisotropicMax);
            const tr = d.style.map.terrain && d.style.map.terrain.getTerrainData(It),
              Pe = K.getProjectionData({
                overscaledTileID: It,
                aligned: st,
                applyGlobeMatrix: !I,
                applyTerrainMatrix: !0
              }),
              Fr = V_(ue, re, Je.fadeMix, o, x),
              gn = it.getMeshFromTileID(F, It.canonical, p, g, "raster");
            V.draw(F, L.TRIANGLES, gt, h ? h[It.overscaledZ] : En.disabled, ot, T ? pn.frontCCW : pn.backCCW, Fr, tr, Pe, o.id, gn.vertexBuffer, gn.indexBuffer, gn.segments)
          }
        }

        function Uu(d, e, o, u) {
          const h = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: {
                opacity: 1,
                mix: 0
              }
            }
          };
          if (o === 0 || u) return h;
          if (d.fadingParentID) {
            const p = e.getLoadedTile(d.fadingParentID);
            if (!p) return h;
            const g = Math.pow(2, p.tileID.overscaledZ - d.tileID.overscaledZ),
              x = [d.tileID.canonical.x * g % 1, d.tileID.canonical.y * g % 1],
              T = (function(I, A, F) {
                const L = lt(),
                  V = (L - A.timeAdded) / F,
                  K = I.fadingDirection === nt.Incoming,
                  it = c.ai((L - I.timeAdded) / F, 0, 1),
                  ot = c.ai(1 - V, 0, 1),
                  st = K ? it : ot;
                return {
                  tileOpacity: st,
                  parentTileOpacity: K ? ot : it,
                  fadeMix: {
                    opacity: 1,
                    mix: 1 - st
                  }
                }
              })(d, p, o);
            return {
              parentTile: p,
              parentScaleBy: g,
              parentTopLeft: x,
              fadeValues: T
            }
          }
          if (d.selfFading) {
            const p = (function(g, x) {
              const T = (lt() - g.timeAdded) / x,
                I = c.ai(T, 0, 1);
              return {
                tileOpacity: I,
                fadeMix: {
                  opacity: I,
                  mix: 0
                }
              }
            })(d, o);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: p
            }
          }
          return h
        }
        const ih = new c.bi(1, 0, 0, 1),
          Ta = new c.bi(0, 1, 0, 1),
          el = new c.bi(0, 0, 1, 1),
          Ja = new c.bi(1, 0, 1, 1),
          rl = new c.bi(0, 1, 1, 1);

        function nl(d, e, o, u) {
          Qa(d, 0, e + o / 2, d.transform.width, o, u)
        }

        function il(d, e, o, u) {
          Qa(d, e - o / 2, 0, o, d.transform.height, u)
        }

        function Qa(d, e, o, u, h, p) {
          const g = d.context,
            x = g.gl;
          x.enable(x.SCISSOR_TEST), x.scissor(e * d.pixelRatio, o * d.pixelRatio, u * d.pixelRatio, h * d.pixelRatio), g.clear({
            color: p
          }), x.disable(x.SCISSOR_TEST)
        }

        function oh(d, e, o) {
          const u = d.context,
            h = u.gl,
            p = d.useProgram("debug"),
            g = mn.disabled,
            x = En.disabled,
            T = d.colorModeForRenderPass(),
            I = "$debug",
            A = d.style.map.terrain && d.style.map.terrain.getTerrainData(o);
          u.activeTexture.set(h.TEXTURE0);
          const F = e.getTileByID(o.key).latestRawTileData,
            L = Math.floor((F && F.byteLength || 0) / 1024),
            V = e.getTile(o).tileSize,
            K = 512 / Math.min(V, 512) * (o.overscaledZ / d.transform.zoom) * .5;
          let it = o.canonical.toString();
          o.overscaledZ !== o.canonical.z && (it += ` => ${o.overscaledZ}`), (function(st, pt) {
            st.initDebugOverlayCanvas();
            const wt = st.debugOverlayCanvas,
              dt = st.context.gl,
              kt = st.debugOverlayCanvas.getContext("2d");
            kt.clearRect(0, 0, wt.width, wt.height), kt.shadowColor = "white", kt.shadowBlur = 2, kt.lineWidth = 1.5, kt.strokeStyle = "white", kt.textBaseline = "top", kt.font = "bold 36px Open Sans, sans-serif", kt.fillText(pt, 5, 5), kt.strokeText(pt, 5, 5), st.debugOverlayTexture.update(wt), st.debugOverlayTexture.bind(dt.LINEAR, dt.CLAMP_TO_EDGE)
          })(d, `${it} ${L}kB`);
          const ot = d.transform.getProjectionData({
            overscaledTileID: o,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          p.draw(u, h.TRIANGLES, g, x, Sn.alphaBlended, pn.disabled, Fc(c.bi.transparent, K), null, ot, I, d.debugBuffer, d.quadTriangleIndexBuffer, d.debugSegments), p.draw(u, h.LINE_STRIP, g, x, T, pn.disabled, Fc(c.bi.red), A, ot, I, d.debugBuffer, d.tileBorderIndexBuffer, d.debugSegments)
        }

        function ol(d, e, o, u) {
          const {
            isRenderingGlobe: h
          } = u, p = d.context, g = p.gl, x = d.transform, T = d.colorModeForRenderPass(), I = d.getDepthModeFor3D(), A = d.useProgram("terrain");
          p.bindFramebuffer.set(null), p.viewport.set([0, 0, d.width, d.height]);
          for (const F of o) {
            const L = e.getTerrainMesh(F.tileID),
              V = d.renderToTexture.getTexture(F),
              K = e.getTerrainData(F.tileID);
            p.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, V.texture);
            const it = e.getMeshFrameDelta(x.zoom),
              ot = x.calculateFogMatrix(F.tileID.toUnwrapped()),
              st = jd(it, ot, d.style.sky, x.pitch, h),
              pt = x.getProjectionData({
                overscaledTileID: F.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            A.draw(p, g.TRIANGLES, I, En.disabled, T, pn.backCCW, st, K, pt, "terrain", L.vertexBuffer, L.indexBuffer, L.segments)
          }
        }

        function Ms(d, e) {
          if (!e.mesh) {
            const o = new c.aP;
            o.emplaceBack(-1, -1), o.emplaceBack(1, -1), o.emplaceBack(1, 1), o.emplaceBack(-1, 1);
            const u = new c.aR;
            u.emplaceBack(0, 1, 2), u.emplaceBack(0, 2, 3), e.mesh = new Cn(d.createVertexBuffer(o, kn.members), d.createIndexBuffer(u), c.aQ.simpleSegment(0, 0, o.length, u.length))
          }
          return e.mesh
        }
        class sh {
          constructor(e, o) {
            this.context = new Du(e), this.transform = o, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: c.am(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = we.maxUnderzooming + we.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new xr
          }
          resize(e, o, u) {
            if (this.width = Math.floor(e * u), this.height = Math.floor(o * u), this.pixelRatio = u, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const h of this.style._order) this.style._layers[h].resize()
          }
          setup() {
            const e = this.context,
              o = new c.aP;
            o.emplaceBack(0, 0), o.emplaceBack(c.a3, 0), o.emplaceBack(0, c.a3), o.emplaceBack(c.a3, c.a3), this.tileExtentBuffer = e.createVertexBuffer(o, kn.members), this.tileExtentSegments = c.aQ.simpleSegment(0, 0, 4, 2);
            const u = new c.aP;
            u.emplaceBack(0, 0), u.emplaceBack(c.a3, 0), u.emplaceBack(0, c.a3), u.emplaceBack(c.a3, c.a3), this.debugBuffer = e.createVertexBuffer(u, kn.members), this.debugSegments = c.aQ.simpleSegment(0, 0, 4, 5);
            const h = new c.ca;
            h.emplaceBack(0, 0, 0, 0), h.emplaceBack(c.a3, 0, c.a3, 0), h.emplaceBack(0, c.a3, 0, c.a3), h.emplaceBack(c.a3, c.a3, c.a3, c.a3), this.rasterBoundsBuffer = e.createVertexBuffer(h, Dc.members), this.rasterBoundsSegments = c.aQ.simpleSegment(0, 0, 4, 2);
            const p = new c.aP;
            p.emplaceBack(0, 0), p.emplaceBack(c.a3, 0), p.emplaceBack(0, c.a3), p.emplaceBack(c.a3, c.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(p, kn.members), this.rasterBoundsSegmentsPosOnly = c.aQ.simpleSegment(0, 0, 4, 5);
            const g = new c.aP;
            g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(g, kn.members), this.viewportSegments = c.aQ.simpleSegment(0, 0, 4, 2);
            const x = new c.cb;
            x.emplaceBack(0), x.emplaceBack(1), x.emplaceBack(3), x.emplaceBack(2), x.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(x);
            const T = new c.aR;
            T.emplaceBack(1, 0, 2), T.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(T);
            const I = this.context.gl;
            this.stencilClearMode = new En({
              func: I.ALWAYS,
              mask: 0
            }, 0, 255, I.ZERO, I.ZERO, I.ZERO), this.tileExtentMesh = new Cn(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              o = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const u = c.M();
            c.c0(u, 0, this.width, this.height, 0, 0, 1), c.O(u, u, [o.drawingBufferWidth, o.drawingBufferHeight, 0]);
            const h = {
              mainMatrix: u,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: u
            };
            this.useProgram("clippingMask", null, !0).draw(e, o.TRIANGLES, mn.disabled, this.stencilClearMode, Sn.disabled, pn.disabled, null, null, h, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, o, u) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !o || !o.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + o.length > 256 && this.clearStencil();
            const h = this.context;
            h.setColorMode(Sn.disabled), h.setDepthMode(mn.disabled);
            const p = {};
            for (const g of o) p[g.key] = this.nextStencilID++;
            this._renderTileMasks(p, o, u, !0), this._renderTileMasks(p, o, u, !1), this._tileClippingMaskIDs = p
          }
          _renderTileMasks(e, o, u, h) {
            const p = this.context,
              g = p.gl,
              x = this.style.projection,
              T = this.transform,
              I = this.useProgram("clippingMask");
            for (const A of o) {
              const F = e[A.key],
                L = this.style.map.terrain && this.style.map.terrain.getTerrainData(A),
                V = x.getMeshFromTileID(this.context, A.canonical, h, !0, "stencil"),
                K = T.getProjectionData({
                  overscaledTileID: A,
                  applyGlobeMatrix: !u,
                  applyTerrainMatrix: !0
                });
              I.draw(p, g.TRIANGLES, mn.disabled, new En({
                func: g.ALWAYS,
                mask: 0
              }, F, 255, g.KEEP, g.KEEP, g.REPLACE), Sn.disabled, u ? pn.disabled : pn.backCCW, null, L, K, "$clipping", V.vertexBuffer, V.indexBuffer, V.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              o = e.gl,
              u = this.style.projection,
              h = this.transform,
              p = this.useProgram("depth"),
              g = this.getDepthModeFor3D(),
              x = ye(h, {
                tileSize: h.tileSize
              });
            for (const T of x) {
              const I = this.style.map.terrain && this.style.map.terrain.getTerrainData(T),
                A = u.getMeshFromTileID(this.context, T.canonical, !0, !0, "raster"),
                F = h.getProjectionData({
                  overscaledTileID: T,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              p.draw(e, o.TRIANGLES, g, En.disabled, Sn.disabled, pn.backCCW, null, I, F, "$clipping", A.vertexBuffer, A.indexBuffer, A.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              o = this.context.gl;
            return new En({
              func: o.NOTEQUAL,
              mask: 255
            }, e, 255, o.KEEP, o.KEEP, o.REPLACE)
          }
          stencilModeForClipping(e) {
            const o = this.context.gl;
            return new En({
              func: o.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, o.KEEP, o.KEEP, o.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const o = this.context.gl,
              u = e.sort(((g, x) => x.overscaledZ - g.overscaledZ)),
              h = u[u.length - 1].overscaledZ,
              p = u[0].overscaledZ - h + 1;
            if (p > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + p > 256 && this.clearStencil();
              const g = {};
              for (let x = 0; x < p; x++) g[x + h] = new En({
                func: o.GEQUAL,
                mask: 255
              }, x + this.nextStencilID, 255, o.KEEP, o.KEEP, o.REPLACE);
              return this.nextStencilID += p, [g, u]
            }
            return [{
              [h]: En.disabled
            }, u]
          }
          stencilConfigForOverlapTwoPass(e) {
            const o = this.context.gl,
              u = e.sort(((g, x) => x.overscaledZ - g.overscaledZ)),
              h = u[u.length - 1].overscaledZ,
              p = u[0].overscaledZ - h + 1;
            if (this.clearStencil(), p > 1) {
              const g = {},
                x = {};
              for (let T = 0; T < p; T++) g[T + h] = new En({
                func: o.GREATER,
                mask: 255
              }, p + 1 + T, 255, o.KEEP, o.KEEP, o.REPLACE), x[T + h] = new En({
                func: o.GREATER,
                mask: 255
              }, 1 + T, 255, o.KEEP, o.KEEP, o.REPLACE);
              return this.nextStencilID = 2 * p + 1, [g, x, u]
            }
            return this.nextStencilID = 3, [{
              [h]: new En({
                func: o.GREATER,
                mask: 255
              }, 2, 255, o.KEEP, o.KEEP, o.REPLACE)
            }, {
              [h]: new En({
                func: o.GREATER,
                mask: 255
              }, 1, 255, o.KEEP, o.KEEP, o.REPLACE)
            }, u]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Sn([e.CONSTANT_COLOR, e.ONE], new c.bi(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Sn.unblended : Sn.alphaBlended
          }
          getDepthModeForSublayer(e, o, u) {
            if (!this.opaquePassEnabledForLayer()) return mn.disabled;
            const h = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new mn(u || this.context.gl.LEQUAL, o, [h, h])
          }
          getDepthModeFor3D() {
            return new mn(this.context.gl.LEQUAL, mn.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, o) {
            var u, h;
            this.style = e, this.options = o, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(lt()), this.imageManager.beginFrame();
            const p = this.style._order,
              g = this.style.tileManagers,
              x = {},
              T = {},
              I = {},
              A = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((u = e.projection) === null || u === void 0 ? void 0 : u.transitionState) > 0
              };
            for (const L in g) {
              const V = g[L];
              V.used && V.prepare(this.context), x[L] = V.getVisibleCoordinates(!1), T[L] = x[L].slice().reverse(), I[L] = V.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let L = 0; L < p.length; L++)
              if (this.style._layers[p[L]].is3D()) {
                this.opaquePassCutoff = L;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const L of p) {
              const V = this.style._layers[L];
              if (!V.hasOffscreenPass() || V.isHidden(this.transform.zoom)) continue;
              const K = T[V.source];
              (V.type === "custom" || K.length) && this.renderLayer(this, g[V.source], V, K, A)
            }
            if ((h = this.style.projection) === null || h === void 0 || h.updateGPUdependent({
                context: this.context,
                useProgram: L => this.useProgram(L)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: o.showOverdrawInspector ? c.bi.black : c.bi.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(L, V) {
                const K = L.context,
                  it = K.gl,
                  ot = ((It, gt, Rt) => {
                    const oe = Math.cos(gt.rollInRadians),
                      Qt = Math.sin(gt.rollInRadians),
                      re = mt(gt),
                      ue = gt.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: It.properties.get("sky-color"),
                      u_horizon_color: It.properties.get("horizon-color"),
                      u_horizon: [(gt.width / 2 - re * Qt) * Rt, (gt.height / 2 + re * oe) * Rt],
                      u_horizon_normal: [-Qt, oe],
                      u_sky_horizon_blend: It.properties.get("sky-horizon-blend") * gt.height / 2 * Rt,
                      u_sky_blend: ue
                    }
                  })(V, L.style.map.transform, L.pixelRatio),
                  st = new mn(it.LEQUAL, mn.ReadWrite, [0, 1]),
                  pt = En.disabled,
                  wt = L.colorModeForRenderPass(),
                  dt = L.useProgram("sky"),
                  kt = Ms(K, V);
                dt.draw(K, it.TRIANGLES, st, pt, wt, pn.disabled, ot, null, void 0, "sky", kt.vertexBuffer, kt.indexBuffer, kt.segments)
              })(this, this.style.sky), this._showOverdrawInspector = o.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = p.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const L = this.style._layers[p[this.currentLayer]],
                  V = g[L.source],
                  K = x[L.source];
                this._renderTileClippingMasks(L, K, !1), this.renderLayer(this, V, L, K, A)
              }
            this.renderPass = "translucent";
            let F = !1;
            for (this.currentLayer = 0; this.currentLayer < p.length; this.currentLayer++) {
              const L = this.style._layers[p[this.currentLayer]],
                V = g[L.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(L, A)) continue;
              this.opaquePassEnabledForLayer() || F || (F = !0, A.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const K = (L.type === "symbol" ? I : T)[L.source];
              this._renderTileClippingMasks(L, x[L.source], !!this.renderToTexture), this.renderLayer(this, V, L, K, A)
            }
            if (A.isRenderingGlobe && (function(L, V, K) {
                const it = L.context,
                  ot = it.gl,
                  st = L.useProgram("atmosphere"),
                  pt = new mn(ot.LEQUAL, mn.ReadOnly, [0, 1]),
                  wt = L.transform,
                  dt = (function(ue, Je) {
                    const tr = ue.properties.get("position"),
                      Pe = [-tr.x, -tr.y, -tr.z],
                      Fr = c.am(new Float64Array(16));
                    return ue.properties.get("anchor") === "map" && (c.b9(Fr, Fr, Je.rollInRadians), c.ba(Fr, Fr, -Je.pitchInRadians), c.b9(Fr, Fr, Je.bearingInRadians), c.ba(Fr, Fr, Je.center.lat * Math.PI / 180), c.bC(Fr, Fr, -Je.center.lng * Math.PI / 180)), c.c9(Pe, Pe, Fr), Pe
                  })(K, L.transform),
                  kt = wt.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  It = V.properties.get("atmosphere-blend") * kt.projectionTransition;
                if (It === 0) return;
                const gt = qo(wt.worldSize, wt.center.lat),
                  Rt = wt.inverseProjectionMatrix,
                  oe = new Float64Array(4);
                oe[3] = 1, c.aA(oe, oe, wt.modelViewProjectionMatrix), oe[0] /= oe[3], oe[1] /= oe[3], oe[2] /= oe[3], oe[3] = 1, c.aA(oe, oe, Rt), oe[0] /= oe[3], oe[1] /= oe[3], oe[2] /= oe[3], oe[3] = 1;
                const Qt = ((ue, Je, tr, Pe, Fr) => ({
                    u_sun_pos: ue,
                    u_atmosphere_blend: Je,
                    u_globe_position: tr,
                    u_globe_radius: Pe,
                    u_inv_proj_matrix: Fr
                  }))(dt, It, [oe[0], oe[1], oe[2]], gt, Rt),
                  re = Ms(it, V);
                st.draw(it, ot.TRIANGLES, pt, En.disabled, Sn.alphaBlended, pn.disabled, Qt, null, null, "atmosphere", re.vertexBuffer, re.indexBuffer, re.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const L = (function(V, K) {
                let it = null;
                const ot = Object.values(V._layers).flatMap((dt => dt.source && !dt.isHidden(K) ? [V.tileManagers[dt.source]] : [])),
                  st = ot.filter((dt => dt.getSource().type === "vector")),
                  pt = ot.filter((dt => dt.getSource().type !== "vector")),
                  wt = dt => {
                    (!it || it.getSource().maxzoom < dt.getSource().maxzoom) && (it = dt)
                  };
                return st.forEach((dt => wt(dt))), it || pt.forEach((dt => wt(dt))), it
              })(this.style, this.transform.zoom);
              L && (function(V, K, it) {
                for (let ot = 0; ot < it.length; ot++) oh(V, K, it[ot])
              })(this, L, L.getVisibleCoordinates())
            }
            this.options.showPadding && (function(L) {
              const V = L.transform.padding;
              nl(L, L.transform.height - (V.top || 0), 3, ih), nl(L, V.bottom || 0, 3, Ta), il(L, V.left || 0, 3, el), il(L, L.transform.width - (V.right || 0), 3, Ja);
              const K = L.transform.centerPoint;
              (function(it, ot, st, pt) {
                Qa(it, ot - 1, st - 10, 2, 20, pt), Qa(it, ot - 10, st - 1, 20, 2, pt)
              })(L, K.x, L.transform.height - K.y, rl)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const o = this.terrainFacilitator.matrix,
              u = this.transform.modelViewProjectionMatrix;
            let h = this.terrainFacilitator.dirty;
            h || (h = e ? !c.cc(o, u) : !c.cd(o, u)), h || (h = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), h && (c.ce(o, u), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(p, g) {
              const x = p.context,
                T = x.gl,
                I = p.transform,
                A = Sn.unblended,
                F = new mn(T.LEQUAL, mn.ReadWrite, [0, 1]),
                L = g.tileManager.getRenderableTiles(),
                V = p.useProgram("terrainDepth");
              x.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), x.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), x.clear({
                color: c.bi.transparent,
                depth: 1
              });
              for (const K of L) {
                const it = g.getTerrainMesh(K.tileID),
                  ot = g.getTerrainData(K.tileID),
                  st = I.getProjectionData({
                    overscaledTileID: K.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  pt = {
                    u_ele_delta: g.getMeshFrameDelta(I.zoom)
                  };
                V.draw(x, T.TRIANGLES, F, En.disabled, A, pn.backCCW, pt, ot, st, "terrain", it.vertexBuffer, it.indexBuffer, it.segments)
              }
              x.bindFramebuffer.set(null), x.viewport.set([0, 0, p.width, p.height])
            })(this, this.style.map.terrain), (function(p, g) {
              const x = p.context,
                T = x.gl,
                I = p.transform,
                A = Sn.unblended,
                F = new mn(T.LEQUAL, mn.ReadWrite, [0, 1]),
                L = g.getCoordsTexture(),
                V = g.tileManager.getRenderableTiles(),
                K = p.useProgram("terrainCoords");
              x.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), x.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), x.clear({
                color: c.bi.transparent,
                depth: 1
              }), g.coordsIndex = [];
              for (const it of V) {
                const ot = g.getTerrainMesh(it.tileID),
                  st = g.getTerrainData(it.tileID);
                x.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, L.texture);
                const pt = {
                    u_terrain_coords_id: (255 - g.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: g.getMeshFrameDelta(I.zoom)
                  },
                  wt = I.getProjectionData({
                    overscaledTileID: it.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                K.draw(x, T.TRIANGLES, F, En.disabled, A, pn.backCCW, pt, st, wt, "terrain", ot.vertexBuffer, ot.indexBuffer, ot.segments), g.coordsIndex.push(it.tileID.key)
              }
              x.bindFramebuffer.set(null), x.viewport.set([0, 0, p.width, p.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, o, u, h, p) {
            u.isHidden(this.transform.zoom) || (u.type === "background" || u.type === "custom" || (h || []).length) && (this.id = u.id, c.cf(u) ? (function(g, x, T, I, A, F) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: L
              } = F, V = En.disabled, K = g.colorModeForRenderPass();
              (T._unevaluatedLayout.hasValue("text-variable-anchor") || T._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(it, ot, st, pt, wt, dt, kt, It, gt) {
                const Rt = ot.transform,
                  oe = ot.style.map.terrain,
                  Qt = wt === "map",
                  re = dt === "map";
                for (const ue of it) {
                  const Je = pt.getTile(ue),
                    tr = Je.getBucket(st);
                  if (!tr || !tr.text || !tr.text.segments.get().length) continue;
                  const Pe = c.ar(tr.textSizeData, Rt.zoom),
                    Fr = c.aG(Je, 1, ot.transform.zoom),
                    gn = Fe(Qt, ot.transform, Fr),
                    Hn = st.layout.get("icon-text-fit") !== "none" && tr.hasIconData();
                  if (Pe) {
                    const Tn = Math.pow(2, Rt.zoom - Je.tileID.overscaledZ),
                      Jn = oe ? (_i, ei) => oe.getElevation(ue, _i, ei) : null;
                    Bu(tr, Qt, re, gt, Rt, gn, Tn, Pe, Hn, c.aH(Rt, Je, kt, It), ue.toUnwrapped(), Jn)
                  }
                }
              })(I, g, T, x, T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), A), T.paint.get("icon-opacity").constantOr(1) !== 0 && Hs(g, x, T, I, !1, T.paint.get("icon-translate"), T.paint.get("icon-translate-anchor"), T.layout.get("icon-rotation-alignment"), T.layout.get("icon-pitch-alignment"), T.layout.get("icon-keep-upright"), V, K, L), T.paint.get("text-opacity").constantOr(1) !== 0 && Hs(g, x, T, I, !0, T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.layout.get("text-keep-upright"), V, K, L), x.map.showCollisionBoxes && (Xa(g, x, T, I, !0), Xa(g, x, T, I, !1))
            })(e, o, u, h, this.style.placement.variableOffsets, p) : c.cg(u) ? (function(g, x, T, I, A) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = A, L = T.paint.get("circle-opacity"), V = T.paint.get("circle-stroke-width"), K = T.paint.get("circle-stroke-opacity"), it = !T.layout.get("circle-sort-key").isConstant();
              if (L.constantOr(1) === 0 && (V.constantOr(1) === 0 || K.constantOr(1) === 0)) return;
              const ot = g.context,
                st = ot.gl,
                pt = g.transform,
                wt = g.getDepthModeForSublayer(0, mn.ReadOnly),
                dt = En.disabled,
                kt = g.colorModeForRenderPass(),
                It = [],
                gt = pt.getCircleRadiusCorrection();
              for (let Rt = 0; Rt < I.length; Rt++) {
                const oe = I[Rt],
                  Qt = x.getTile(oe),
                  re = Qt.getBucket(T);
                if (!re) continue;
                const ue = T.paint.get("circle-translate"),
                  Je = T.paint.get("circle-translate-anchor"),
                  tr = c.aH(pt, Qt, ue, Je),
                  Pe = re.programConfigurations.get(T.id),
                  Fr = g.useProgram("circle", Pe),
                  gn = re.layoutVertexBuffer,
                  Hn = re.indexBuffer,
                  Tn = g.style.map.terrain && g.style.map.terrain.getTerrainData(oe),
                  Jn = {
                    programConfiguration: Pe,
                    program: Fr,
                    layoutVertexBuffer: gn,
                    indexBuffer: Hn,
                    uniformValues: Rd(g, Qt, T, tr, gt),
                    terrainData: Tn,
                    projectionData: pt.getProjectionData({
                      overscaledTileID: oe,
                      applyGlobeMatrix: !F,
                      applyTerrainMatrix: !0
                    })
                  };
                if (it) {
                  const _i = re.segments.get();
                  for (const ei of _i) It.push({
                    segments: new c.aQ([ei]),
                    sortKey: ei.sortKey,
                    state: Jn
                  })
                } else It.push({
                  segments: re.segments,
                  sortKey: 0,
                  state: Jn
                })
              }
              it && It.sort(((Rt, oe) => Rt.sortKey - oe.sortKey));
              for (const Rt of It) {
                const {
                  programConfiguration: oe,
                  program: Qt,
                  layoutVertexBuffer: re,
                  indexBuffer: ue,
                  uniformValues: Je,
                  terrainData: tr,
                  projectionData: Pe
                } = Rt.state;
                Qt.draw(ot, st.TRIANGLES, wt, dt, kt, pn.backCCW, Je, tr, Pe, T.id, re, ue, Rt.segments, T.paint, g.transform.zoom, oe)
              }
            })(e, o, u, h, p) : c.ch(u) ? (function(g, x, T, I, A) {
              if (T.paint.get("heatmap-opacity") === 0) return;
              const F = g.context,
                {
                  isRenderingToTexture: L,
                  isRenderingGlobe: V
                } = A;
              if (g.style.map.terrain) {
                for (const K of I) {
                  const it = x.getTile(K);
                  x.hasRenderableParent(K) || (g.renderPass === "offscreen" ? Wd(g, it, T, K, V) : g.renderPass === "translucent" && Ya(g, T, K, L, V))
                }
                F.viewport.set([0, 0, g.width, g.height])
              } else g.renderPass === "offscreen" ? (function(K, it, ot, st) {
                const pt = K.context,
                  wt = pt.gl,
                  dt = K.transform,
                  kt = En.disabled,
                  It = new Sn([wt.ONE, wt.ONE], c.bi.transparent, [!0, !0, !0, !0]);
                (function(gt, Rt, oe) {
                  const Qt = gt.gl;
                  gt.activeTexture.set(Qt.TEXTURE1), gt.viewport.set([0, 0, Rt.width / 4, Rt.height / 4]);
                  let re = oe.heatmapFbos.get(c.c6);
                  re ? (Qt.bindTexture(Qt.TEXTURE_2D, re.colorAttachment.get()), gt.bindFramebuffer.set(re.framebuffer)) : (re = th(gt, Rt.width / 4, Rt.height / 4), oe.heatmapFbos.set(c.c6, re))
                })(pt, K, ot), pt.clear({
                  color: c.bi.transparent
                });
                for (let gt = 0; gt < st.length; gt++) {
                  const Rt = st[gt];
                  if (it.hasRenderableParent(Rt)) continue;
                  const oe = it.getTile(Rt),
                    Qt = oe.getBucket(ot);
                  if (!Qt) continue;
                  const re = Qt.programConfigurations.get(ot.id),
                    ue = K.useProgram("heatmap", re),
                    Je = dt.getProjectionData({
                      overscaledTileID: Rt,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    tr = dt.getCircleRadiusCorrection();
                  ue.draw(pt, wt.TRIANGLES, mn.disabled, kt, It, pn.backCCW, Oc(oe, dt.zoom, ot.paint.get("heatmap-intensity"), tr), null, Je, ot.id, Qt.layoutVertexBuffer, Qt.indexBuffer, Qt.segments, ot.paint, dt.zoom, re)
                }
                pt.viewport.set([0, 0, K.width, K.height])
              })(g, x, T, I) : g.renderPass === "translucent" && (function(K, it) {
                const ot = K.context,
                  st = ot.gl;
                ot.setColorMode(K.colorModeForRenderPass());
                const pt = it.heatmapFbos.get(c.c6);
                pt && (ot.activeTexture.set(st.TEXTURE0), st.bindTexture(st.TEXTURE_2D, pt.colorAttachment.get()), ot.activeTexture.set(st.TEXTURE1), Qc(ot, it).bind(st.LINEAR, st.CLAMP_TO_EDGE), K.useProgram("heatmapTexture").draw(ot, st.TRIANGLES, mn.disabled, En.disabled, K.colorModeForRenderPass(), pn.disabled, qc(K, it, 0, 1), null, null, it.id, K.viewportBuffer, K.quadTriangleIndexBuffer, K.viewportSegments, it.paint, K.transform.zoom))
              })(g, T)
            })(e, o, u, h, p) : c.ci(u) ? (function(g, x, T, I, A) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = A, L = T.paint.get("line-opacity"), V = T.paint.get("line-width");
              if (L.constantOr(1) === 0 || V.constantOr(1) === 0) return;
              const K = g.getDepthModeForSublayer(0, mn.ReadOnly),
                it = g.colorModeForRenderPass(),
                ot = T.paint.get("line-dasharray"),
                st = ot.constantOr(1),
                pt = T.paint.get("line-pattern"),
                wt = pt.constantOr(1),
                dt = T.paint.get("line-gradient"),
                kt = T.getCrossfadeParameters();
              let It;
              It = wt ? "linePattern" : st && dt ? "lineGradientSDF" : st ? "lineSDF" : dt ? "lineGradient" : "line";
              const gt = g.context,
                Rt = gt.gl,
                oe = g.transform;
              let Qt = !0;
              for (const re of I) {
                const ue = x.getTile(re);
                if (wt && !ue.patternsLoaded()) continue;
                const Je = ue.getBucket(T);
                if (!Je) continue;
                const tr = Je.programConfigurations.get(T.id),
                  Pe = g.context.program.get(),
                  Fr = g.useProgram(It, tr),
                  gn = Qt || Fr.program !== Pe,
                  Hn = g.style.map.terrain && g.style.map.terrain.getTerrainData(re),
                  Tn = pt.constantOr(null),
                  Jn = ot && ot.constantOr(null);
                if (Tn && ue.imageAtlas) {
                  const Oi = ue.imageAtlas,
                    si = Oi.patternPositions[Tn.to.toString()],
                    Si = Oi.patternPositions[Tn.from.toString()];
                  si && Si && tr.setConstantPatternPositions(si, Si)
                } else if (Jn) {
                  const Oi = T.layout.get("line-cap") === "round",
                    si = g.lineAtlas.getDash(Jn.to, Oi),
                    Si = g.lineAtlas.getDash(Jn.from, Oi);
                  tr.setConstantDashPositions(si, Si)
                }
                const _i = oe.getProjectionData({
                    overscaledTileID: re,
                    applyGlobeMatrix: !F,
                    applyTerrainMatrix: !0
                  }),
                  ei = oe.getPixelScale();
                let Ii;
                wt ? (Ii = Su(g, ue, T, ei, kt), tl(gt, Rt, ue, tr, kt)) : st && dt ? (Ii = Od(g, ue, T, ei, kt, Je.lineClipsArray.length), qu(g, x, gt, Rt, T, Je, re, tr, kt)) : st ? (Ii = Fd(g, ue, T, ei, kt), eh(g, gt, Rt, tr, gn, kt)) : dt ? (Ii = Bd(g, ue, T, ei, Je.lineClipsArray.length), rh(g, x, gt, Rt, T, Je, re)) : Ii = Ps(g, ue, T, ei);
                const oi = g.stencilModeForClipping(re);
                Fr.draw(gt, Rt.TRIANGLES, K, oi, it, pn.disabled, Ii, Hn, _i, T.id, Je.layoutVertexBuffer, Je.indexBuffer, Je.segments, T.paint, g.transform.zoom, tr, Je.layoutVertexBuffer2), Qt = !1
              }
            })(e, o, u, h, p) : c.cj(u) ? (function(g, x, T, I, A) {
              const F = T.paint.get("fill-color"),
                L = T.paint.get("fill-opacity");
              if (L.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: V
              } = A, K = g.colorModeForRenderPass(), it = T.paint.get("fill-pattern"), ot = g.opaquePassEnabledForLayer() && !it.constantOr(1) && F.constantOr(c.bi.transparent).a === 1 && L.constantOr(0) === 1 ? "opaque" : "translucent";
              if (g.renderPass === ot) {
                const st = g.getDepthModeForSublayer(1, g.renderPass === "opaque" ? mn.ReadWrite : mn.ReadOnly);
                nh(g, x, T, I, st, K, !1, V)
              }
              if (g.renderPass === "translucent" && T.paint.get("fill-antialias")) {
                const st = g.getDepthModeForSublayer(T.getPaintProperty("fill-outline-color") ? 2 : 0, mn.ReadOnly);
                nh(g, x, T, I, st, K, !0, V)
              }
            })(e, o, u, h, p) : c.ck(u) ? (function(g, x, T, I, A) {
              const F = T.paint.get("fill-extrusion-opacity");
              if (F === 0) return;
              const {
                isRenderingToTexture: L
              } = A;
              if (g.renderPass === "translucent") {
                const V = new mn(g.context.gl.LEQUAL, mn.ReadWrite, g.depthRangeFor3D);
                if (F !== 1 || T.paint.get("fill-extrusion-pattern").constantOr(1)) Vu(g, x, T, I, V, En.disabled, Sn.disabled, L), Vu(g, x, T, I, V, g.stencilModeFor3D(), g.colorModeForRenderPass(), L);
                else {
                  const K = g.colorModeForRenderPass();
                  Vu(g, x, T, I, V, En.disabled, K, L)
                }
              }
            })(e, o, u, h, p) : c.cl(u) ? (function(g, x, T, I, A) {
              if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = A, L = g.context, V = g.style.projection.useSubdivision, K = g.getDepthModeForSublayer(0, mn.ReadOnly), it = g.colorModeForRenderPass();
              if (g.renderPass === "offscreen")(function(ot, st, pt, wt, dt, kt, It) {
                const gt = ot.context,
                  Rt = gt.gl;
                for (const oe of pt) {
                  const Qt = st.getTile(oe),
                    re = Qt.dem;
                  if (!re || !re.data || !Qt.needsHillshadePrepare) continue;
                  const ue = re.dim,
                    Je = re.stride,
                    tr = re.getPixels();
                  if (gt.activeTexture.set(Rt.TEXTURE1), gt.pixelStoreUnpackPremultiplyAlpha.set(!1), Qt.demTexture = Qt.demTexture || ot.getTileTexture(Je), Qt.demTexture) {
                    const Fr = Qt.demTexture;
                    Fr.update(tr, {
                      premultiply: !1
                    }), Fr.bind(Rt.NEAREST, Rt.CLAMP_TO_EDGE)
                  } else Qt.demTexture = new c.T(gt, tr, Rt.RGBA, {
                    premultiply: !1
                  }), Qt.demTexture.bind(Rt.NEAREST, Rt.CLAMP_TO_EDGE);
                  gt.activeTexture.set(Rt.TEXTURE0);
                  let Pe = Qt.fbo;
                  if (!Pe) {
                    const Fr = new c.T(gt, {
                      width: ue,
                      height: ue,
                      data: null
                    }, Rt.RGBA);
                    Fr.bind(Rt.LINEAR, Rt.CLAMP_TO_EDGE), Pe = Qt.fbo = gt.createFramebuffer(ue, ue, !0, !1), Pe.colorAttachment.set(Fr.texture)
                  }
                  gt.bindFramebuffer.set(Pe.framebuffer), gt.viewport.set([0, 0, ue, ue]), ot.useProgram("hillshadePrepare").draw(gt, Rt.TRIANGLES, dt, kt, It, pn.disabled, qs(Qt.tileID, re), null, null, wt.id, ot.rasterBoundsBuffer, ot.quadTriangleIndexBuffer, ot.rasterBoundsSegments), Qt.needsHillshadePrepare = !1
                }
              })(g, x, I, T, K, En.disabled, it), L.viewport.set([0, 0, g.width, g.height]);
              else if (g.renderPass === "translucent")
                if (V) {
                  const [ot, st, pt] = g.stencilConfigForOverlapTwoPass(I);
                  ci(g, x, T, pt, ot, K, it, !1, F), ci(g, x, T, pt, st, K, it, !0, F)
                } else {
                  const [ot, st] = g.getStencilConfigForOverlapAndUpdateStencilID(I);
                  ci(g, x, T, st, ot, K, it, !1, F)
                }
            })(e, o, u, h, p) : c.cm(u) ? (function(g, x, T, I, A) {
              if (g.renderPass !== "translucent" || !I.length) return;
              const {
                isRenderingToTexture: F
              } = A, L = g.style.projection.useSubdivision, V = g.getDepthModeForSublayer(0, mn.ReadOnly), K = g.colorModeForRenderPass();
              if (L) {
                const [it, ot, st] = g.stencilConfigForOverlapTwoPass(I);
                us(g, x, T, st, it, V, K, !1, F), us(g, x, T, st, ot, V, K, !0, F)
              } else {
                const [it, ot] = g.getStencilConfigForOverlapAndUpdateStencilID(I);
                us(g, x, T, ot, it, V, K, !1, F)
              }
            })(e, o, u, h, p) : c.bN(u) ? (function(g, x, T, I, A) {
              if (g.renderPass !== "translucent" || T.paint.get("raster-opacity") === 0 || !I.length) return;
              const {
                isRenderingToTexture: F
              } = A, L = x.getSource(), V = g.style.projection.useSubdivision;
              if (L instanceof Pr) ka(g, x, T, I, null, !1, !1, L.tileCoords, L.flippedWindingOrder, F);
              else if (V) {
                const [K, it, ot] = g.stencilConfigForOverlapTwoPass(I);
                ka(g, x, T, ot, K, !1, !0, fo, !1, F), ka(g, x, T, ot, it, !0, !0, fo, !1, F)
              } else {
                const [K, it] = g.getStencilConfigForOverlapAndUpdateStencilID(I);
                ka(g, x, T, it, K, !1, !0, fo, !1, F)
              }
            })(e, o, u, h, p) : c.cn(u) ? (function(g, x, T, I, A) {
              const F = T.paint.get("background-color"),
                L = T.paint.get("background-opacity");
              if (L === 0) return;
              const {
                isRenderingToTexture: V
              } = A, K = g.context, it = K.gl, ot = g.style.projection, st = g.transform, pt = st.tileSize, wt = T.paint.get("background-pattern");
              if (g.isPatternMissing(wt)) return;
              const dt = !wt && F.a === 1 && L === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass !== dt) return;
              const kt = En.disabled,
                It = g.getDepthModeForSublayer(0, dt === "opaque" ? mn.ReadWrite : mn.ReadOnly),
                gt = g.colorModeForRenderPass(),
                Rt = g.useProgram(wt ? "backgroundPattern" : "background"),
                oe = I || ye(st, {
                  tileSize: pt,
                  terrain: g.style.map.terrain
                });
              wt && (K.activeTexture.set(it.TEXTURE0), g.imageManager.bind(g.context));
              const Qt = T.getCrossfadeParameters();
              for (const re of oe) {
                const ue = st.getProjectionData({
                    overscaledTileID: re,
                    applyGlobeMatrix: !V,
                    applyTerrainMatrix: !0
                  }),
                  Je = wt ? Gc(L, g, wt, {
                    tileID: re,
                    tileSize: pt
                  }, Qt) : Zc(L, F),
                  tr = g.style.map.terrain && g.style.map.terrain.getTerrainData(re),
                  Pe = ot.getMeshFromTileID(K, re.canonical, !1, !0, "raster");
                Rt.draw(K, it.TRIANGLES, It, kt, gt, pn.backCCW, Je, tr, ue, T.id, Pe.vertexBuffer, Pe.indexBuffer, Pe.segments)
              }
            })(e, 0, u, h, p) : c.co(u) && (function(g, x, T, I) {
              const {
                isRenderingGlobe: A
              } = I, F = g.context, L = T.implementation, V = g.style.projection, K = g.transform, it = K.getProjectionDataForCustomLayer(A), ot = {
                farZ: K.farZ,
                nearZ: K.nearZ,
                fov: K.fov * Math.PI / 180,
                modelViewProjectionMatrix: K.modelViewProjectionMatrix,
                projectionMatrix: K.projectionMatrix,
                shaderData: {
                  variantName: V.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${V.shaderPreludeCode.vertexSource}`,
                  define: V.shaderDefine
                },
                defaultProjectionData: it
              }, st = L.renderingMode ? L.renderingMode : "2d";
              if (g.renderPass === "offscreen") {
                const pt = L.prerender;
                pt && (g.setCustomLayerDefaults(), F.setColorMode(g.colorModeForRenderPass()), pt.call(L, F.gl, ot), F.setDirty(), g.setBaseState())
              } else if (g.renderPass === "translucent") {
                g.setCustomLayerDefaults(), F.setColorMode(g.colorModeForRenderPass()), F.setStencilMode(En.disabled);
                const pt = st === "3d" ? g.getDepthModeFor3D() : g.getDepthModeForSublayer(0, mn.ReadOnly);
                F.setDepthMode(pt), L.render(F.gl, ot), F.setDirty(), g.setBaseState(), F.bindFramebuffer.set(null)
              }
            })(e, 0, u, p))
          }
          saveTileTexture(e) {
            const o = this._tileTextures[e.size[0]];
            o ? o.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const o = this._tileTextures[e];
            return o && o.length > 0 ? o.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const o = this.imageManager.getPattern(e.from.toString()),
              u = this.imageManager.getPattern(e.to.toString());
            return !o || !u
          }
          useProgram(e, o, u = !1, h = []) {
            this.cache = this.cache || {};
            const p = !!this.style.map.terrain,
              g = this.style.projection,
              x = u ? Ur.projectionMercator : g.shaderPreludeCode,
              T = u ? sn : g.shaderDefine,
              I = e + (o ? o.cacheKey : "") + `/${u?Bn:g.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (p ? "/terrain" : "") + (h ? `/${h.join("/")}` : "");
            return this.cache[I] || (this.cache[I] = new Za(this.context, Ur[e], o, U_[e], this._showOverdrawInspector, p, x, T, h)), this.cache[I]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new c.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: o
            } = this.context.gl;
            return this.width !== e || this.height !== o
          }
        }

        function sl(d, e) {
          let o, u = !1,
            h = null,
            p = null;
          const g = () => {
            h = null, u && (d.apply(p, o), h = setTimeout(g, e), u = !1)
          };
          return (...x) => (u = !0, p = this, o = x, h || g(), h)
        }
        class al {
          constructor(e) {
            this._getCurrentHash = () => {
              const o = window.location.hash.replace("#", "");
              if (this._hashName) {
                let u;
                return o.split("&").map((h => h.split("="))).forEach((h => {
                  h[0] === this._hashName && (u = h)
                })), (u && u[1] || "").split("/")
              }
              return o.split("/")
            }, this._onHashChange = () => {
              const o = this._getCurrentHash();
              if (!this._isValidHash(o)) return !1;
              const u = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(o[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+o[2], +o[1]],
                zoom: +o[0],
                bearing: u,
                pitch: +(o[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const o = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, o)
            }, this._removeHash = () => {
              const o = this._getCurrentHash();
              if (o.length === 0) return;
              const u = o.join("/");
              let h = u;
              h.split("&").length > 0 && (h = h.split("&")[0]), this._hashName && (h = `${this._hashName}=${u}`);
              let p = window.location.hash.replace(h, "");
              p.startsWith("#&") ? p = p.slice(0, 1) + p.slice(2) : p === "#" && (p = "");
              let g = window.location.href.replace(/(#.+)?$/, p);
              g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g)
            }, this._updateHash = sl(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const o = this._map.getCenter(),
              u = Math.round(100 * this._map.getZoom()) / 100,
              h = Math.ceil((u * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              p = Math.pow(10, h),
              g = Math.round(o.lng * p) / p,
              x = Math.round(o.lat * p) / p,
              T = this._map.getBearing(),
              I = this._map.getPitch();
            let A = "";
            if (A += e ? `/${g}/${x}/${u}` : `${u}/${x}/${g}`, (T || I) && (A += "/" + Math.round(10 * T) / 10), I && (A += `/${Math.round(I)}`), this._hashName) {
              const F = this._hashName;
              let L = !1;
              const V = window.location.hash.slice(1).split("&").map((K => {
                const it = K.split("=")[0];
                return it === F ? (L = !0, `${it}=${A}`) : K
              })).filter((K => K));
              return L || V.push(`${F}=${A}`), `#${V.join("&")}`
            }
            return `#${A}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new c.U(+e[2], +e[1])
            } catch {
              return !1
            }
            const o = +e[0],
              u = +(e[3] || 0),
              h = +(e[4] || 0);
            return o >= this._map.getMinZoom() && o <= this._map.getMaxZoom() && u >= -180 && u <= 180 && h >= this._map.getMinPitch() && h <= this._map.getMaxPitch()
          }
        }
        const Sa = {
            linearity: .3,
            easing: c.cp(0, 0, .3, 1)
          },
          ah = c.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, Sa),
          uh = c.e({
            deceleration: 20,
            maxSpeed: 1400
          }, Sa),
          ch = c.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Sa),
          lh = c.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, Sa),
          Zu = c.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Sa);
        class _h {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: lt(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              o = lt();
            for (; e.length > 0 && o - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const o = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new c.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: p
              }
              of this._inertiaBuffer) o.zoom += p.zoomDelta || 0, o.bearing += p.bearingDelta || 0, o.pitch += p.pitchDelta || 0, o.roll += p.rollDelta || 0, p.panDelta && o.pan._add(p.panDelta), p.around && (o.around = p.around), p.pinchAround && (o.pinchAround = p.pinchAround);
            const u = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              h = {};
            if (o.pan.mag()) {
              const p = ao(o.pan.mag(), u, c.e({}, ah, e || {})),
                g = o.pan.mult(p.amount / o.pan.mag()),
                x = this._map.cameraHelper.handlePanInertia(g, this._map.transform);
              h.center = x.easingCenter, h.offset = x.easingOffset, no(h, p)
            }
            if (o.zoom) {
              const p = ao(o.zoom, u, uh);
              h.zoom = this._map.transform.zoom + p.amount, no(h, p)
            }
            if (o.bearing) {
              const p = ao(o.bearing, u, ch);
              h.bearing = this._map.transform.bearing + c.ai(p.amount, -179, 179), no(h, p)
            }
            if (o.pitch) {
              const p = ao(o.pitch, u, lh);
              h.pitch = this._map.transform.pitch + p.amount, no(h, p)
            }
            if (o.roll) {
              const p = ao(o.roll, u, Zu);
              h.roll = this._map.transform.roll + c.ai(p.amount, -179, 179), no(h, p)
            }
            if (h.zoom || h.bearing) {
              const p = o.pinchAround === void 0 ? o.around : o.pinchAround;
              h.around = p ? this._map.unproject(p) : this._map.getCenter()
            }
            return this.clear(), c.e(h, {
              noMoveStart: !0
            })
          }
        }

        function no(d, e) {
          (!d.duration || d.duration < e.duration) && (d.duration = e.duration, d.easing = e.easing)
        }

        function ao(d, e, o) {
          const {
            maxSpeed: u,
            linearity: h,
            deceleration: p
          } = o, g = c.ai(d * h / (e / 1e3), -u, u), x = Math.abs(g) / (p * h);
          return {
            easing: o.easing,
            duration: 1e3 * x,
            amount: g * (x / 2)
          }
        }
        class mo extends c.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, o, u, h = {}) {
            u = u instanceof MouseEvent ? u : new MouseEvent(e, u);
            const p = G.mousePos(o.getCanvas(), u),
              g = o.unproject(p);
            super(e, c.e({
              point: p,
              lngLat: g,
              originalEvent: u
            }, h)), this._defaultPrevented = !1, this.target = o
          }
        }
        class uo extends c.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, o, u) {
            const h = e === "touchend" ? u.changedTouches : u.touches,
              p = G.touchPos(o.getCanvasContainer(), h),
              g = p.map((T => o.unproject(T))),
              x = p.reduce(((T, I, A, F) => T.add(I.div(F.length))), new c.P(0, 0));
            super(e, {
              points: p,
              point: x,
              lngLats: g,
              lngLat: o.unproject(x),
              originalEvent: u
            }), this._defaultPrevented = !1
          }
        }
        class hh extends c.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, o, u) {
            super(e, {
              originalEvent: u
            }), this._defaultPrevented = !1
          }
        }
        class Pa {
          constructor(e, o) {
            this._map = e, this._clickTolerance = o.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new hh(e.type, this._map, e))
          }
          mousedown(e, o) {
            return this._mousedownPos = o, this._firePreventable(new mo(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new mo(e.type, this._map, e))
          }
          click(e, o) {
            this._mousedownPos && this._mousedownPos.dist(o) >= this._clickTolerance || this._map.fire(new mo(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new mo(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new mo(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new mo(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new uo(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new uo(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new uo(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new uo(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class $d {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new mo(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new mo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new mo(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class tu {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(c.P.convert(e), this._map.terrain)
          }
        }
        class dh {
          constructor(e, o) {
            this._map = e, this._tr = new tu(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = o.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, o) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (G.disableDrag(), this._startPos = this._lastPos = o, this._active = !0)
          }
          mousemoveWindow(e, o) {
            if (!this._active) return;
            const u = o;
            if (this._lastPos.equals(u) || !this._box && u.dist(this._startPos) < this._clickTolerance) return;
            const h = this._startPos;
            this._lastPos = u, this._box || (this._box = G.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const p = Math.min(h.x, u.x),
              g = Math.max(h.x, u.x),
              x = Math.min(h.y, u.y),
              T = Math.max(h.y, u.y);
            G.setTransform(this._box, `translate(${p}px,${x}px)`), this._box.style.width = g - p + "px", this._box.style.height = T - x + "px"
          }
          mouseupWindow(e, o) {
            if (!this._active || e.button !== 0) return;
            const u = this._startPos,
              h = o;
            if (this.reset(), G.suppressClick(), u.x !== h.x || u.y !== h.y) return this._map.fire(new c.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: p => p.fitScreenCoordinates(u, h, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (G.remove(this._box), this._box = null), G.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, o) {
            return this._map.fire(new c.l(e, {
              originalEvent: o
            }))
          }
        }

        function ul(d, e) {
          if (d.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${d.length}, points ${e.length}`);
          const o = {};
          for (let u = 0; u < d.length; u++) o[d[u].identifier] = e[u];
          return o
        }
        class ph {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, o, u) {
            (this.centroid || u.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), u.length === this.numTouches && (this.centroid = (function(h) {
              const p = new c.P(0, 0);
              for (const g of h) p._add(g);
              return p.div(h.length)
            })(o), this.touches = ul(u, o)))
          }
          touchmove(e, o, u) {
            if (this.aborted || !this.centroid) return;
            const h = ul(u, o);
            for (const p in this.touches) {
              const g = h[p];
              (!g || g.dist(this.touches[p]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, o, u) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), u.length === 0) {
              const h = !this.aborted && this.centroid;
              if (this.reset(), h) return h
            }
          }
        }
        class Ws {
          constructor(e) {
            this.singleTap = new ph(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, o, u) {
            this.singleTap.touchstart(e, o, u)
          }
          touchmove(e, o, u) {
            this.singleTap.touchmove(e, o, u)
          }
          touchend(e, o, u) {
            const h = this.singleTap.touchend(e, o, u);
            if (h) {
              const p = e.timeStamp - this.lastTime < 500,
                g = !this.lastTap || this.lastTap.dist(h) < 30;
              if (p && g || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = h, this.count === this.numTaps) return this.reset(), h
            }
          }
        }
        class cs {
          constructor(e) {
            this._tr = new tu(e), this._zoomIn = new Ws({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Ws({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, o, u) {
            this._zoomIn.touchstart(e, o, u), this._zoomOut.touchstart(e, o, u)
          }
          touchmove(e, o, u) {
            this._zoomIn.touchmove(e, o, u), this._zoomOut.touchmove(e, o, u)
          }
          touchend(e, o, u) {
            const h = this._zoomIn.touchend(e, o, u),
              p = this._zoomOut.touchend(e, o, u),
              g = this._tr;
            return h ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: x => x.easeTo({
                duration: 300,
                zoom: g.zoom + 1,
                around: g.unproject(h)
              }, {
                originalEvent: e
              })
            }) : p ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: x => x.easeTo({
                duration: 300,
                zoom: g.zoom - 1,
                around: g.unproject(p)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Sr {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const o = this._moveFunction(...e);
            if (o.bearingDelta || o.pitchDelta || o.rollDelta || o.around || o.panDelta) return this._active = !0, o
          }
          dragStart(e, o) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(o) ? o[0] : o, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, o) {
            if (!this.isEnabled()) return;
            const u = this._lastPoint;
            if (!u) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const h = Array.isArray(o) ? o[0] : o;
            return !this._moved && h.dist(u) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = h, this._move(u, h))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && G.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const fh = 0,
          cl = 2,
          mh = {
            [fh]: 1,
            [cl]: 2
          };
        class ls {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const o = G.mouseButton(e);
            this._eventButton = o
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(o, u) {
              const h = mh[u];
              return o.buttons === void 0 || (o.buttons & h) !== h
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return G.mouseButton(e) === this._eventButton
          }
        }
        class eu {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class ll {
          constructor(e = new ls({
            checkCorrectEvent: () => !0
          }), o = new eu) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = o
          }
          _executeRelevantHandler(e, o, u) {
            return e instanceof MouseEvent ? o(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? u(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (o => this.mouseMoveStateManager.startMove(o)), (o => this.oneFingerTouchMoveStateManager.startMove(o)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (o => this.mouseMoveStateManager.endMove(o)), (o => this.oneFingerTouchMoveStateManager.endMove(o)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (o => this.mouseMoveStateManager.isValidStartEvent(o)), (o => this.oneFingerTouchMoveStateManager.isValidStartEvent(o)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (o => this.mouseMoveStateManager.isValidMoveEvent(o)), (o => this.oneFingerTouchMoveStateManager.isValidMoveEvent(o)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (o => this.mouseMoveStateManager.isValidEndEvent(o)), (o => this.oneFingerTouchMoveStateManager.isValidEndEvent(o)))
          }
        }
        const zn = d => {
          d.mousedown = d.dragStart, d.mousemoveWindow = d.dragMove, d.mouseup = d.dragEnd, d.contextmenu = e => {
            e.preventDefault()
          }
        };
        class _l {
          constructor(e, o) {
            this._clickTolerance = e.clickTolerance || 1, this._map = o, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new c.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, o, u) {
            return this._calculateTransform(e, o, u)
          }
          touchmove(e, o, u) {
            if (this._active) {
              if (!this._shouldBePrevented(u.length)) return e.preventDefault(), this._calculateTransform(e, o, u);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, o, u) {
            this._calculateTransform(e, o, u), this._active && this._shouldBePrevented(u.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, o, u) {
            u.length > 0 && (this._active = !0);
            const h = ul(u, o),
              p = new c.P(0, 0),
              g = new c.P(0, 0);
            let x = 0;
            for (const I in h) {
              const A = h[I],
                F = this._touches[I];
              F && (p._add(A), g._add(A.sub(F)), x++, h[I] = A)
            }
            if (this._touches = h, this._shouldBePrevented(x) || !g.mag()) return;
            const T = g.div(x);
            return this._sum._add(T), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: p.div(x),
              panDelta: T
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class hl {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, o, u) {
            this._firstTwoTouches || u.length < 2 || (this._firstTwoTouches = [u[0].identifier, u[1].identifier], this._start([o[0], o[1]]))
          }
          touchmove(e, o, u) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [h, p] = this._firstTwoTouches, g = Ma(u, o, h), x = Ma(u, o, p);
            if (!g || !x) return;
            const T = this._aroundCenter ? null : g.add(x).div(2);
            return this._move([g, x], T, e)
          }
          touchend(e, o, u) {
            if (!this._firstTwoTouches) return;
            const [h, p] = this._firstTwoTouches, g = Ma(u, o, h), x = Ma(u, o, p);
            g && x || (this._active && G.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Ma(d, e, o) {
          for (let u = 0; u < d.length; u++)
            if (d[u].identifier === o) return e[u]
        }

        function gh(d, e) {
          return Math.log(d / e) / Math.LN2
        }
        class yh extends hl {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, o) {
            const u = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(gh(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: gh(this._distance, u),
              pinchAround: o
            }
          }
        }

        function dl(d, e) {
          return 180 * d.angleWith(e) / Math.PI
        }
        class Gu extends hl {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, o, u) {
            const h = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: dl(this._vector, h),
              pinchAround: o
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const o = 25 / (Math.PI * this._minDiameter) * 360,
              u = dl(e, this._startVector);
            return Math.abs(u) < o
          }
        }

        function Hu(d) {
          return Math.abs(d.y) > Math.abs(d.x)
        }
        class vh extends hl {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, o, u) {
            super.touchstart(e, o, u), this._currentTouchCount = u.length
          }
          _start(e) {
            this._lastPoints = e, Hu(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, o, u) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const h = e[0].sub(this._lastPoints[0]),
              p = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(h, p, u.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (h.y + p.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, o, u) {
            if (this._valid !== void 0) return this._valid;
            const h = e.mag() >= 2,
              p = o.mag() >= 2;
            if (!h && !p) return;
            if (!h || !p) return this._firstMove === void 0 && (this._firstMove = u), u - this._firstMove < 100 && void 0;
            const g = e.y > 0 == o.y > 0;
            return Hu(e) && Hu(o) && g
          }
        }
        const bh = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class xh {
          constructor(e) {
            this._tr = new tu(e);
            const o = bh;
            this._panStep = o.panStep, this._bearingStep = o.bearingStep, this._pitchStep = o.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let o = 0,
              u = 0,
              h = 0,
              p = 0,
              g = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                o = 1;
                break;
              case 189:
              case 109:
              case 173:
                o = -1;
                break;
              case 37:
                e.shiftKey ? u = -1 : (e.preventDefault(), p = -1);
                break;
              case 39:
                e.shiftKey ? u = 1 : (e.preventDefault(), p = 1);
                break;
              case 38:
                e.shiftKey ? h = 1 : (e.preventDefault(), g = -1);
                break;
              case 40:
                e.shiftKey ? h = -1 : (e.preventDefault(), g = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (u = 0, h = 0), {
              cameraAnimation: x => {
                const T = this._tr;
                x.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: Xd,
                  zoom: o ? Math.round(T.zoom) + o * (e.shiftKey ? 2 : 1) : T.zoom,
                  bearing: T.bearing + u * this._bearingStep,
                  pitch: T.pitch + h * this._pitchStep,
                  offset: [-p * this._panStep, -g * this._panStep],
                  center: T.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function Xd(d) {
          return d * (2 - d)
        }
        const _s = 4.000244140625,
          Kn = 1 / 450;
        class wh {
          constructor(e, o) {
            this._onTimeout = u => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(u)
            }, this._map = e, this._tr = new tu(e), this._triggerRenderFrame = o, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Kn
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let o = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const u = lt(),
              h = u - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = u, o !== 0 && o % _s == 0 ? this._type = "wheel" : o !== 0 && Math.abs(o) < 4 ? this._type = "trackpad" : h > 400 ? (this._type = null, this._lastValue = o, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(h * o) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, o += this._lastValue)), e.shiftKey && o && (o /= 4), this._type && (this._lastWheelEvent = e, this._delta -= o, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const o = G.mousePos(this._map.getCanvas(), e),
              u = this._tr;
            this._aroundPoint = this._aroundCenter ? u.transform.locationToScreenPoint(c.U.convert(u.center)) : o, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const x = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += x), typeof this._targetZoom == "number" && (this._targetZoom += x)
            }
            if (this._delta !== 0) {
              const x = this._type === "wheel" && Math.abs(this._delta) > _s ? this._wheelZoomRate : this._defaultZoomRate;
              let T = 2 / (1 + Math.exp(-Math.abs(this._delta * x)));
              this._delta < 0 && T !== 0 && (T = 1 / T);
              const I = typeof this._targetZoom != "number" ? e.scale : c.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), c.ao(I * T)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const o = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              u = this._startZoom,
              h = this._easing;
            let p, g = !1;
            if (this._type === "wheel" && u && h) {
              const x = lt() - this._lastWheelEventTime,
                T = Math.min((x + 5) / 200, 1),
                I = h(T);
              p = c.F.number(u, o, I), T < 1 ? this._frameId || (this._frameId = !0) : g = !0
            } else p = o, g = !0;
            return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = p, {
              noInertia: !0,
              needsRenderFrame: !g,
              zoomDelta: p - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let o = c.cr;
            if (this._prevEase) {
              const u = this._prevEase,
                h = (lt() - u.start) / u.duration,
                p = u.easing(h + .01) - u.easing(h),
                g = .27 / Math.sqrt(p * p + 1e-4) * .01,
                x = Math.sqrt(.0729 - g * g);
              o = c.cp(g, x, .25, 1)
            }
            return this._prevEase = {
              start: lt(),
              duration: e,
              easing: o
            }, o
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class ru {
          constructor(e, o) {
            this._clickZoom = e, this._tapZoom = o
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class pl {
          constructor(e) {
            this._tr = new tu(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, o) {
            return e.preventDefault(), {
              cameraAnimation: u => {
                u.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(o)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class kh {
          constructor() {
            this._tap = new Ws({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, o, u) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const h = o[0],
                  p = e.timeStamp - this._tapTime < 500,
                  g = this._tapPoint.dist(h) < 30;
                p && g ? u.length > 0 && (this._swipePoint = h, this._swipeTouch = u[0].identifier) : this.reset()
              } else this._tap.touchstart(e, o, u)
          }
          touchmove(e, o, u) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (u[0].identifier !== this._swipeTouch) return;
                const h = o[0],
                  p = h.y - this._swipePoint.y;
                return this._swipePoint = h, e.preventDefault(), this._active = !0, {
                  zoomDelta: p / 128
                }
              }
            } else this._tap.touchmove(e, o, u)
          }
          touchend(e, o, u) {
            if (this._tapTime) this._swipePoint && u.length === 0 && this.reset();
            else {
              const h = this._tap.touchend(e, o, u);
              h && (this._tapTime = e.timeStamp, this._tapPoint = h)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class fl {
          constructor(e, o, u) {
            this._el = e, this._mousePan = o, this._touchPan = u
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class ml {
          constructor(e, o, u, h) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = o, this._mousePitch = u, this._mouseRoll = h
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Th {
          constructor(e, o, u, h) {
            this._el = e, this._touchZoom = o, this._touchRotate = u, this._tapDragZoom = h, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Vo {
          constructor(e, o) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = o, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = G.create("div", "maplibregl-cooperative-gesture-screen", e);
            let o = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (o = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const u = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              h = document.createElement("div");
            h.className = "maplibregl-desktop-message", h.textContent = o, this._container.appendChild(h);
            const p = document.createElement("div");
            p.className = "maplibregl-mobile-message", p.textContent = u, this._container.appendChild(p), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (G.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, o) {
            this._enabled && (this._map.fire(new c.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: o
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const $s = d => d.zoom || d.drag || d.roll || d.pitch || d.rotate;
        class Xr extends c.l {}

        function nn(d) {
          return d.panDelta && d.panDelta.mag() || d.zoomDelta || d.bearingDelta || d.pitchDelta || d.rollDelta
        }
        class nu {
          constructor(e, o) {
            this.handleWindowEvent = h => {
              this.handleEvent(h, `${h.type}Window`)
            }, this.handleEvent = (h, p) => {
              if (h.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const g = h.type === "renderFrame" ? void 0 : h,
                x = {
                  needsRenderFrame: !1
                },
                T = {},
                I = {};
              for (const {
                  handlerName: L,
                  handler: V,
                  allowed: K
                }
                of this._handlers) {
                if (!V.isEnabled()) continue;
                let it;
                if (this._blockedByActive(I, K, L)) V.reset();
                else if (V[p || h.type]) {
                  if (c.cs(h, p || h.type)) {
                    const ot = G.mousePos(this._map.getCanvas(), h);
                    it = V[p || h.type](h, ot)
                  } else if (c.ct(h, p || h.type)) {
                    const ot = this._getMapTouches(h.touches),
                      st = G.touchPos(this._map.getCanvas(), ot);
                    it = V[p || h.type](h, st, ot)
                  } else c.cu(p || h.type) || (it = V[p || h.type](h));
                  this.mergeHandlerResult(x, T, it, L, g), it && it.needsRenderFrame && this._triggerRenderFrame()
                }(it || V.isActive()) && (I[L] = V)
              }
              const A = {};
              for (const L in this._previousActiveHandlers) I[L] || (A[L] = g);
              this._previousActiveHandlers = I, (Object.keys(A).length || nn(x)) && (this._changes.push([x, T, A]), this._triggerRenderFrame()), (Object.keys(I).length || nn(x)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: F
              } = x;
              F && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], F(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new _h(e), this._bearingSnap = o.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(o);
            const u = this._el;
            this._listeners = [
              [u, "touchstart", {
                passive: !0
              }],
              [u, "touchmove", {
                passive: !1
              }],
              [u, "touchend", void 0],
              [u, "touchcancel", void 0],
              [u, "mousedown", void 0],
              [u, "mousemove", void 0],
              [u, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [u, "mouseover", void 0],
              [u, "mouseout", void 0],
              [u, "dblclick", void 0],
              [u, "click", void 0],
              [u, "keydown", {
                capture: !1
              }],
              [u, "keyup", void 0],
              [u, "wheel", {
                passive: !1
              }],
              [u, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [h, p, g] of this._listeners) G.addEventListener(h, p, h === document ? this.handleWindowEvent : this.handleEvent, g)
          }
          destroy() {
            for (const [e, o, u] of this._listeners) G.removeEventListener(e, o, e === document ? this.handleWindowEvent : this.handleEvent, u)
          }
          _addDefaultHandlers(e) {
            const o = this._map,
              u = o.getCanvasContainer();
            this._add("mapEvent", new Pa(o, e));
            const h = o.boxZoom = new dh(o, e);
            this._add("boxZoom", h), e.interactive && e.boxZoom && h.enable();
            const p = o.cooperativeGestures = new Vo(o, e.cooperativeGestures);
            this._add("cooperativeGestures", p), e.cooperativeGestures && p.enable();
            const g = new cs(o),
              x = new pl(o);
            o.doubleClickZoom = new ru(x, g), this._add("tapZoom", g), this._add("clickZoom", x), e.interactive && e.doubleClickZoom && o.doubleClickZoom.enable();
            const T = new kh;
            this._add("tapDragZoom", T);
            const I = o.touchPitch = new vh(o);
            this._add("touchPitch", I), e.interactive && e.touchPitch && o.touchPitch.enable(e.touchPitch);
            const A = () => o.project(o.getCenter()),
              F = (function({
                enable: dt,
                clickTolerance: kt,
                aroundCenter: It = !0,
                minPixelCenterThreshold: gt = 100,
                rotateDegreesPerPixelMoved: Rt = .8
              }, oe) {
                const Qt = new ls({
                  checkCorrectEvent: re => G.mouseButton(re) === 0 && re.ctrlKey || G.mouseButton(re) === 2 && !re.ctrlKey
                });
                return new Sr({
                  clickTolerance: kt,
                  move: (re, ue) => {
                    const Je = oe();
                    if (It && Math.abs(Je.y - re.y) > gt) return {
                      bearingDelta: c.cq(new c.P(re.x, ue.y), ue, Je)
                    };
                    let tr = (ue.x - re.x) * Rt;
                    return It && ue.y < Je.y && (tr = -tr), {
                      bearingDelta: tr
                    }
                  },
                  moveStateManager: Qt,
                  enable: dt,
                  assignEvents: zn
                })
              })(e, A),
              L = (function({
                enable: dt,
                clickTolerance: kt,
                pitchDegreesPerPixelMoved: It = -.5
              }) {
                const gt = new ls({
                  checkCorrectEvent: Rt => G.mouseButton(Rt) === 0 && Rt.ctrlKey || G.mouseButton(Rt) === 2
                });
                return new Sr({
                  clickTolerance: kt,
                  move: (Rt, oe) => ({
                    pitchDelta: (oe.y - Rt.y) * It
                  }),
                  moveStateManager: gt,
                  enable: dt,
                  assignEvents: zn
                })
              })(e),
              V = (function({
                enable: dt,
                clickTolerance: kt,
                rollDegreesPerPixelMoved: It = .3
              }, gt) {
                const Rt = new ls({
                  checkCorrectEvent: oe => G.mouseButton(oe) === 2 && oe.ctrlKey
                });
                return new Sr({
                  clickTolerance: kt,
                  move: (oe, Qt) => {
                    const re = gt();
                    let ue = (Qt.x - oe.x) * It;
                    return Qt.y < re.y && (ue = -ue), {
                      rollDelta: ue
                    }
                  },
                  moveStateManager: Rt,
                  enable: dt,
                  assignEvents: zn
                })
              })(e, A);
            o.dragRotate = new ml(e, F, L, V), this._add("mouseRotate", F, ["mousePitch"]), this._add("mousePitch", L, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", V, ["mousePitch"]), e.interactive && e.dragRotate && o.dragRotate.enable();
            const K = (function({
                enable: dt,
                clickTolerance: kt
              }) {
                const It = new ls({
                  checkCorrectEvent: gt => G.mouseButton(gt) === 0 && !gt.ctrlKey
                });
                return new Sr({
                  clickTolerance: kt,
                  move: (gt, Rt) => ({
                    around: Rt,
                    panDelta: Rt.sub(gt)
                  }),
                  activateOnStart: !0,
                  moveStateManager: It,
                  enable: dt,
                  assignEvents: zn
                })
              })(e),
              it = new _l(e, o);
            o.dragPan = new fl(u, K, it), this._add("mousePan", K), this._add("touchPan", it, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && o.dragPan.enable(e.dragPan);
            const ot = new Gu,
              st = new yh;
            o.touchZoomRotate = new Th(u, st, ot, T), this._add("touchRotate", ot, ["touchPan", "touchZoom"]), this._add("touchZoom", st, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && o.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new $d(o));
            const pt = o.scrollZoom = new wh(o, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", pt, ["mousePan"]), e.interactive && e.scrollZoom && o.scrollZoom.enable(e.scrollZoom);
            const wt = o.keyboard = new xh(o);
            this._add("keyboard", wt), e.interactive && e.keyboard && o.keyboard.enable()
          }
          _add(e, o, u) {
            this._handlers.push({
              handlerName: e,
              handler: o,
              allowed: u
            }), this._handlersById[e] = o
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: o
                }
                of this._handlers) o.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!$s(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, o, u) {
            for (const h in e)
              if (h !== u && (!o || o.indexOf(h) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const o = [];
            for (const u of e) this._el.contains(u.target) && o.push(u);
            return o
          }
          mergeHandlerResult(e, o, u, h, p) {
            if (!u) return;
            c.e(e, u);
            const g = {
              handlerName: h,
              originalEvent: u.originalEvent || p
            };
            u.zoomDelta !== void 0 && (o.zoom = g), u.panDelta !== void 0 && (o.drag = g), u.rollDelta !== void 0 && (o.roll = g), u.pitchDelta !== void 0 && (o.pitch = g), u.bearingDelta !== void 0 && (o.rotate = g)
          }
          _applyChanges() {
            const e = {},
              o = {},
              u = {};
            for (const [h, p, g] of this._changes) h.panDelta && (e.panDelta = (e.panDelta || new c.P(0, 0))._add(h.panDelta)), h.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + h.zoomDelta), h.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + h.bearingDelta), h.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + h.pitchDelta), h.rollDelta && (e.rollDelta = (e.rollDelta || 0) + h.rollDelta), h.around !== void 0 && (e.around = h.around), h.pinchAround !== void 0 && (e.pinchAround = h.pinchAround), h.noInertia && (e.noInertia = h.noInertia), c.e(o, p), c.e(u, g);
            this._updateMapTransform(e, o, u), this._changes = []
          }
          _updateMapTransform(e, o, u) {
            const h = this._map,
              p = h._getTransformForUpdate(),
              g = h.terrain;
            if (!(nn(e) || g && this._terrainMovement)) return this._fireEvents(o, u, !0);
            h._stop(!0);
            let {
              panDelta: x,
              zoomDelta: T,
              bearingDelta: I,
              pitchDelta: A,
              rollDelta: F,
              around: L,
              pinchAround: V
            } = e;
            V !== void 0 && (L = V), L = L || h.transform.centerPoint, g && !p.isPointOnMapSurface(L) && (L = p.centerPoint);
            const K = {
              panDelta: x,
              zoomDelta: T,
              rollDelta: F,
              pitchDelta: A,
              bearingDelta: I,
              around: L
            };
            this._map.cameraHelper.useGlobeControls && !p.isPointOnMapSurface(L) && (L = p.centerPoint);
            const it = L.distSqr(p.centerPoint) < .01 ? p.center : p.screenPointToLocation(x ? L.sub(x) : L);
            this._handleMapControls({
              terrain: g,
              tr: p,
              deltasForHelper: K,
              preZoomAroundLoc: it,
              combinedEventsInProgress: o,
              panDelta: x
            }), h._applyUpdatedTransform(p), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(o, u, !0)
          }
          _handleMapControls({
            terrain: e,
            tr: o,
            deltasForHelper: u,
            preZoomAroundLoc: h,
            combinedEventsInProgress: p,
            panDelta: g
          }) {
            const x = this._map.cameraHelper;
            if (x.handleMapControlsRollPitchBearingZoom(u, o), e) return x.useGlobeControls ? (this._terrainMovement || !p.drag && !p.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void x.handleMapControlsPan(u, o, h)) : this._terrainMovement || !p.drag && !p.zoom ? void(p.drag && this._terrainMovement && g ? o.setCenter(o.screenPointToLocation(o.centerPoint.sub(g))) : x.handleMapControlsPan(u, o, h)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void x.handleMapControlsPan(u, o, h));
            x.handleMapControlsPan(u, o, h)
          }
          _fireEvents(e, o, u) {
            const h = $s(this._eventsInProgress),
              p = $s(e),
              g = {};
            for (const F in e) {
              const {
                originalEvent: L
              } = e[F];
              this._eventsInProgress[F] || (g[`${F}start`] = L), this._eventsInProgress[F] = e[F]
            }!h && p && this._fireEvent("movestart", p.originalEvent);
            for (const F in g) this._fireEvent(F, g[F]);
            p && this._fireEvent("move", p.originalEvent);
            for (const F in e) {
              const {
                originalEvent: L
              } = e[F];
              this._fireEvent(F, L)
            }
            const x = {};
            let T;
            for (const F in this._eventsInProgress) {
              const {
                handlerName: L,
                originalEvent: V
              } = this._eventsInProgress[F];
              this._handlersById[L].isActive() || (delete this._eventsInProgress[F], T = o[L] || V, x[`${F}end`] = T)
            }
            for (const F in x) this._fireEvent(F, x[F]);
            const I = $s(this._eventsInProgress),
              A = (h || p) && !I;
            if (A && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const F = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && F.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(F)
            }
            if (u && A) {
              this._updatingCamera = !0;
              const F = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                L = V => V !== 0 && -this._bearingSnap < V && V < this._bearingSnap;
              !F || !F.essential && ut.prefersReducedMotion ? (this._map.fire(new c.l("moveend", {
                originalEvent: T
              })), L(this._map.getBearing()) && this._map.resetNorth()) : (L(F.bearing || this._map.getBearing()) && (F.bearing = 0), F.freezeElevation = !0, this._map.easeTo(F, {
                originalEvent: T
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, o) {
            this._map.fire(new c.l(e, o ? {
              originalEvent: o
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new Xr("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Sh extends c.E {
          constructor(e, o, u) {
            super(), this._renderFrameCallback = () => {
              const h = Math.min((lt() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(h)), h < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = u.bearingSnap, this.cameraHelper = o, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, o) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = o
          }
          getCenter() {
            return new c.U(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, o) {
            return this.jumpTo({
              center: e
            }, o)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, o) {
            return this.jumpTo({
              elevation: e
            }, o), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, o, u) {
            return e = c.P.convert(e).mult(-1), this.panTo(this.transform.center, c.e({
              offset: e
            }, o), u)
          }
          panTo(e, o, u) {
            return this.easeTo(c.e({
              center: e
            }, o), u)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, o) {
            return this.jumpTo({
              zoom: e
            }, o), this
          }
          zoomTo(e, o, u) {
            return this.easeTo(c.e({
              zoom: e
            }, o), u)
          }
          zoomIn(e, o) {
            return this.zoomTo(this.getZoom() + 1, e, o), this
          }
          zoomOut(e, o) {
            return this.zoomTo(this.getZoom() - 1, e, o), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, o) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new c.l("movestart", o)).fire(new c.l("move", o)).fire(new c.l("moveend", o))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, o) {
            return this.jumpTo({
              bearing: e
            }, o), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, o) {
            return this.jumpTo({
              padding: e
            }, o), this
          }
          rotateTo(e, o, u) {
            return this.easeTo(c.e({
              bearing: e
            }, o), u)
          }
          resetNorth(e, o) {
            return this.rotateTo(0, c.e({
              duration: 1e3
            }, e), o), this
          }
          resetNorthPitch(e, o) {
            return this.easeTo(c.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), o), this
          }
          snapToNorth(e, o) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, o) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, o) {
            return this.jumpTo({
              pitch: e
            }, o), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, o) {
            return this.jumpTo({
              roll: e
            }, o), this
          }
          cameraForBounds(e, o) {
            e = ir.convert(e).adjustAntiMeridian();
            const u = o && o.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), u, o)
          }
          _cameraForBoxAndBearing(e, o, u, h) {
            const p = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(h = c.e({
                padding: p,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, h)).padding == "number") {
              const I = h.padding;
              h.padding = {
                top: I,
                bottom: I,
                right: I,
                left: I
              }
            }
            const g = c.e(p, h.padding);
            h.padding = g;
            const x = this.transform,
              T = new ir(e, o);
            return this.cameraHelper.cameraForBoxAndBearing(h, g, T, u, x)
          }
          fitBounds(e, o, u) {
            return this._fitInternal(this.cameraForBounds(e, o), o, u)
          }
          fitScreenCoordinates(e, o, u, h, p) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(c.P.convert(e)), this.transform.screenPointToLocation(c.P.convert(o)), u, h), h, p)
          }
          _fitInternal(e, o, u) {
            return e ? (delete(o = c.e(e, o)).padding, o.linear ? this.easeTo(o, u) : this.flyTo(o, u)) : this
          }
          jumpTo(e, o) {
            this.stop();
            const u = this._getTransformForUpdate();
            let h = !1,
              p = !1,
              g = !1;
            const x = u.zoom;
            this.cameraHelper.handleJumpToCenterZoom(u, e);
            const T = u.zoom !== x;
            return "elevation" in e && u.elevation !== +e.elevation && u.setElevation(+e.elevation), "bearing" in e && u.bearing !== +e.bearing && (h = !0, u.setBearing(+e.bearing)), "pitch" in e && u.pitch !== +e.pitch && (p = !0, u.setPitch(+e.pitch)), "roll" in e && u.roll !== +e.roll && (g = !0, u.setRoll(+e.roll)), e.padding == null || u.isPaddingEqual(e.padding) || u.setPadding(e.padding), this._applyUpdatedTransform(u), this.fire(new c.l("movestart", o)).fire(new c.l("move", o)), T && this.fire(new c.l("zoomstart", o)).fire(new c.l("zoom", o)).fire(new c.l("zoomend", o)), h && this.fire(new c.l("rotatestart", o)).fire(new c.l("rotate", o)).fire(new c.l("rotateend", o)), p && this.fire(new c.l("pitchstart", o)).fire(new c.l("pitch", o)).fire(new c.l("pitchend", o)), g && this.fire(new c.l("rollstart", o)).fire(new c.l("roll", o)).fire(new c.l("rollend", o)), this.fire(new c.l("moveend", o))
          }
          calculateCameraOptionsFromTo(e, o, u, h = 0) {
            const p = c.a5.fromLngLat(e, o),
              g = c.a5.fromLngLat(u, h),
              x = g.x - p.x,
              T = g.y - p.y,
              I = g.z - p.z,
              A = Math.hypot(x, T, I);
            if (A === 0) throw new Error("Can't calculate camera options with same From and To");
            const F = Math.hypot(x, T),
              L = c.ao(this.transform.cameraToCenterDistance / A / this.transform.tileSize),
              V = 180 * Math.atan2(x, -T) / Math.PI;
            let K = 180 * Math.acos(F / A) / Math.PI;
            return K = I < 0 ? 90 - K : 90 + K, {
              center: g.toLngLat(),
              elevation: h,
              zoom: L,
              pitch: K,
              bearing: V
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, o, u, h, p) {
            const g = this.transform.calculateCenterFromCameraLngLatAlt(e, o, u, h);
            return {
              center: g.center,
              elevation: g.elevation,
              zoom: g.zoom,
              bearing: u,
              pitch: h,
              roll: p
            }
          }
          easeTo(e, o) {
            this._stop(!1, e.easeId), ((e = c.e({
              offset: [0, 0],
              duration: 500,
              easing: c.cr
            }, e)).animate === !1 || !e.essential && ut.prefersReducedMotion) && (e.duration = 0);
            const u = this._getTransformForUpdate(),
              h = this.getBearing(),
              p = u.pitch,
              g = u.roll,
              x = "bearing" in e ? this._normalizeBearing(e.bearing, h) : h,
              T = "pitch" in e ? +e.pitch : p,
              I = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              A = "padding" in e ? e.padding : u.padding,
              F = c.P.convert(e.offset);
            let L, V;
            e.around && (L = c.U.convert(e.around), V = u.locationToScreenPoint(L));
            const K = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              it = this.cameraHelper.handleEaseTo(u, {
                bearing: x,
                pitch: T,
                roll: I,
                padding: A,
                around: L,
                aroundPoint: V,
                offsetAsPoint: F,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || h !== x, this._pitching = this._pitching || T !== p, this._rolling = this._rolling || I !== g, this._padding = !u.isPaddingEqual(A), this._zooming = this._zooming || it.isZooming, this._easeId = e.easeId, this._prepareEase(o, e.noMoveStart, K), this.terrain && this._prepareElevation(it.elevationCenter), this._ease((ot => {
              it.easeFunc(ot), this.terrain && !e.freezeElevation && this._updateElevation(ot), this._applyUpdatedTransform(u), this._fireMoveEvents(o)
            }), (ot => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(o, ot)
            }), e), this
          }
          _prepareEase(e, o, u = {}) {
            this._moving = !0, o || u.moving || this.fire(new c.l("movestart", e)), this._zooming && !u.zooming && this.fire(new c.l("zoomstart", e)), this._rotating && !u.rotating && this.fire(new c.l("rotatestart", e)), this._pitching && !u.pitching && this.fire(new c.l("pitchstart", e)), this._rolling && !u.rolling && this.fire(new c.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const o = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && o !== this._elevationTarget) {
              const u = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (u - (o - (u * e + this._elevationStart)) / (1 - e)), this._elevationTarget = o
            }
            this.transform.setElevation(c.F.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const o = e.getCameraLngLat(),
              u = e.getCameraAltitude(),
              h = this.terrain ? this.terrain.getElevationForLngLatZoom(o, e.zoom) : 0;
            if (u < h) {
              const p = this.calculateCameraOptionsFromTo(o, h, e.center, e.elevation);
              return {
                pitch: p.pitch,
                zoom: p.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const o = [];
            if (o.push((h => this._elevateCameraIfInsideTerrain(h))), this.transformCameraUpdate && o.push((h => this.transformCameraUpdate(h))), !o.length) return;
            const u = e.clone();
            for (const h of o) {
              const p = u.clone(),
                {
                  center: g,
                  zoom: x,
                  roll: T,
                  pitch: I,
                  bearing: A,
                  elevation: F
                } = h(p);
              g && p.setCenter(g), F !== void 0 && p.setElevation(F), x !== void 0 && p.setZoom(x), T !== void 0 && p.setRoll(T), I !== void 0 && p.setPitch(I), A !== void 0 && p.setBearing(A), u.apply(p)
            }
            this.transform.apply(u)
          }
          _fireMoveEvents(e) {
            this.fire(new c.l("move", e)), this._zooming && this.fire(new c.l("zoom", e)), this._rotating && this.fire(new c.l("rotate", e)), this._pitching && this.fire(new c.l("pitch", e)), this._rolling && this.fire(new c.l("roll", e))
          }
          _afterEase(e, o) {
            if (this._easeId && o && this._easeId === o) return;
            delete this._easeId;
            const u = this._zooming,
              h = this._rotating,
              p = this._pitching,
              g = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, u && this.fire(new c.l("zoomend", e)), h && this.fire(new c.l("rotateend", e)), p && this.fire(new c.l("pitchend", e)), g && this.fire(new c.l("rollend", e)), this.fire(new c.l("moveend", e))
          }
          flyTo(e, o) {
            if (!e.essential && ut.prefersReducedMotion) {
              const ue = c.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(ue, o)
            }
            this.stop(), e = c.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: c.cr
            }, e);
            const u = this._getTransformForUpdate(),
              h = u.bearing,
              p = u.pitch,
              g = u.roll,
              x = u.padding,
              T = "bearing" in e ? this._normalizeBearing(e.bearing, h) : h,
              I = "pitch" in e ? +e.pitch : p,
              A = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              F = "padding" in e ? e.padding : u.padding,
              L = c.P.convert(e.offset);
            let V = u.centerPoint.add(L);
            const K = u.screenPointToLocation(V),
              it = this.cameraHelper.handleFlyTo(u, {
                bearing: T,
                pitch: I,
                roll: A,
                padding: F,
                locationAtOffset: K,
                offsetAsPoint: L,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let ot = e.curve;
            const st = Math.max(u.width, u.height),
              pt = st / it.scaleOfZoom,
              wt = it.pixelPathLength;
            typeof it.scaleOfMinZoom == "number" && (ot = Math.sqrt(st / it.scaleOfMinZoom / wt * 2));
            const dt = ot * ot;

            function kt(ue) {
              const Je = (pt * pt - st * st + (ue ? -1 : 1) * dt * dt * wt * wt) / (2 * (ue ? pt : st) * dt * wt);
              return Math.log(Math.sqrt(Je * Je + 1) - Je)
            }

            function It(ue) {
              return (Math.exp(ue) - Math.exp(-ue)) / 2
            }

            function gt(ue) {
              return (Math.exp(ue) + Math.exp(-ue)) / 2
            }
            const Rt = kt(!1);
            let oe = function(ue) {
                return gt(Rt) / gt(Rt + ot * ue)
              },
              Qt = function(ue) {
                return st * ((gt(Rt) * (It(Je = Rt + ot * ue) / gt(Je)) - It(Rt)) / dt) / wt;
                var Je
              },
              re = (kt(!0) - Rt) / ot;
            if (Math.abs(wt) < 2e-6 || !isFinite(re)) {
              if (Math.abs(st - pt) < 1e-6) return this.easeTo(e, o);
              const ue = pt < st ? -1 : 1;
              re = Math.abs(Math.log(pt / st)) / ot, Qt = () => 0, oe = Je => Math.exp(ue * ot * Je)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * re / ("screenSpeed" in e ? +e.screenSpeed / ot : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = h !== T, this._pitching = I !== p, this._rolling = A !== g, this._padding = !u.isPaddingEqual(F), this._prepareEase(o, !1), this.terrain && this._prepareElevation(it.targetCenter), this._ease((ue => {
              const Je = ue * re,
                tr = 1 / oe(Je),
                Pe = Qt(Je);
              this._rotating && u.setBearing(c.F.number(h, T, ue)), this._pitching && u.setPitch(c.F.number(p, I, ue)), this._rolling && u.setRoll(c.F.number(g, A, ue)), this._padding && (u.interpolatePadding(x, F, ue), V = u.centerPoint.add(L)), it.easeFunc(ue, tr, Pe, V), this.terrain && !e.freezeElevation && this._updateElevation(ue), this._applyUpdatedTransform(u), this._fireMoveEvents(o)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(o)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, o) {
            var u;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const h = this._onEaseEnd;
              delete this._onEaseEnd, h.call(this, o)
            }
            return e || (u = this.handlers) === null || u === void 0 || u.stop(!1), this
          }
          _ease(e, o, u) {
            u.animate === !1 || u.duration === 0 ? (e(1), o()) : (this._easeStart = lt(), this._easeOptions = u, this._onEaseFrame = e, this._onEaseEnd = o, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, o) {
            e = c.V(e, -180, 180);
            const u = Math.abs(e - o);
            return Math.abs(e - 360 - o) < u && (e -= 360), Math.abs(e + 360 - o) < u && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(c.U.convert(e), this.transform.tileZoom) : null
          }
        }
        const iu = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class io {
          constructor(e = iu) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = o => {
              !o || o.sourceDataType !== "metadata" && o.sourceDataType !== "visibility" && o.dataType !== "style" && o.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = G.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = G.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = G.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            G.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, o) {
            const u = this._map._getUIString(`AttributionControl.${o}`);
            e.title = u, e.setAttribute("aria-label", u)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((h => typeof h != "string" ? "" : h))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const h = this._map.style.stylesheet;
              this.styleOwner = h.owner, this.styleId = h.id
            }
            const o = this._map.style.tileManagers;
            for (const h in o) {
              const p = o[h];
              if (p.used || p.usedForTerrain) {
                const g = p.getSource();
                g.attribution && e.indexOf(g.attribution) < 0 && e.push(g.attribution)
              }
            }
            e = e.filter((h => String(h).trim())), e.sort(((h, p) => h.length - p.length)), e = e.filter(((h, p) => {
              for (let g = p + 1; g < e.length; g++)
                if (e[g].indexOf(h) >= 0) return !1;
              return !0
            }));
            const u = e.join(" | ");
            u !== this._attribHTML && (this._attribHTML = u, e.length ? (this._innerContainer.innerHTML = G.sanitize(u), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class gl {
          constructor(e = {}) {
            this._updateCompact = () => {
              const o = this._container.children;
              if (o.length) {
                const u = o[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && u.classList.add("maplibregl-compact") : u.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = G.create("div", "maplibregl-ctrl");
            const o = G.create("a", "maplibregl-ctrl-logo");
            return o.target = "_blank", o.rel = "noopener nofollow", o.href = "https://maplibre.org/", o.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), o.setAttribute("rel", "noopener nofollow"), this._container.appendChild(o), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            G.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Uo {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const o = ++this._id;
            return this._queue.push({
              callback: e,
              id: o,
              cancelled: !1
            }), o
          }
          remove(e) {
            const o = this._currentlyRunning,
              u = o ? this._queue.concat(o) : this._queue;
            for (const h of u)
              if (h.id === e) return void(h.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const o = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const u of o)
              if (!u.cancelled && (u.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Ph = c.aN([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class Yd extends c.E {
          constructor(e) {
            super(), this._lastTilesetChange = lt(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null
          }
          getSource() {
            return this.tileManager._source
          }
          update(e, o) {
            this.tileManager.update(e, o), this._renderableTilesKeys = [];
            const u = {};
            for (const h of ye(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: o,
                calculateTileZoom: this.tileManager._source.calculateTileZoom
              })) u[h.key] = !0, this._renderableTilesKeys.push(h.key), this._tiles[h.key] || (h.terrainRttPosMatrix32f = new Float64Array(16), c.c0(h.terrainRttPosMatrix32f, 0, c.a3, c.a3, 0, 0, 1), this._tiles[h.key] = new _t(h, this.tileSize), this._lastTilesetChange = lt());
            for (const h in this._tiles) u[h] || delete this._tiles[h]
          }
          freeRtt(e) {
            for (const o in this._tiles) {
              const u = this._tiles[o];
              (!e || u.tileID.equals(e) || u.tileID.isChildOf(e) || e.isChildOf(u.tileID)) && (u.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, o) {
            return o ? this._getTerrainCoordsForTileRanges(e, o) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const o = {};
            for (const u of this._renderableTilesKeys) {
              const h = this._tiles[u].tileID,
                p = e.clone(),
                g = c.bd();
              if (h.canonical.equals(e.canonical)) c.c0(g, 0, c.a3, c.a3, 0, 0, 1);
              else if (h.canonical.isChildOf(e.canonical)) {
                const x = h.canonical.z - e.canonical.z,
                  T = h.canonical.x - (h.canonical.x >> x << x),
                  I = h.canonical.y - (h.canonical.y >> x << x),
                  A = c.a3 >> x;
                c.c0(g, 0, A, A, 0, 0, 1), c.N(g, g, [-T * A, -I * A, 0])
              } else {
                if (!e.canonical.isChildOf(h.canonical)) continue;
                {
                  const x = e.canonical.z - h.canonical.z,
                    T = e.canonical.x - (e.canonical.x >> x << x),
                    I = e.canonical.y - (e.canonical.y >> x << x),
                    A = c.a3 >> x;
                  c.c0(g, 0, c.a3, c.a3, 0, 0, 1), c.N(g, g, [T * A, I * A, 0]), c.O(g, g, [1 / 2 ** x, 1 / 2 ** x, 0])
                }
              }
              p.terrainRttPosMatrix32f = new Float32Array(g), o[u] = p
            }
            return o
          }
          _getTerrainCoordsForTileRanges(e, o) {
            const u = {};
            for (const h of this._renderableTilesKeys) {
              const p = this._tiles[h].tileID;
              if (!this._isWithinTileRanges(p, o)) continue;
              const g = e.clone(),
                x = c.bd();
              if (p.canonical.z === e.canonical.z) {
                const T = e.canonical.x - p.canonical.x,
                  I = e.canonical.y - p.canonical.y;
                c.c0(x, 0, c.a3, c.a3, 0, 0, 1), c.N(x, x, [T * c.a3, I * c.a3, 0])
              } else if (p.canonical.z > e.canonical.z) {
                const T = p.canonical.z - e.canonical.z,
                  I = p.canonical.x - (p.canonical.x >> T << T),
                  A = p.canonical.y - (p.canonical.y >> T << T),
                  F = e.canonical.x - (p.canonical.x >> T),
                  L = e.canonical.y - (p.canonical.y >> T),
                  V = c.a3 >> T;
                c.c0(x, 0, V, V, 0, 0, 1), c.N(x, x, [-I * V + F * c.a3, -A * V + L * c.a3, 0])
              } else {
                const T = e.canonical.z - p.canonical.z,
                  I = e.canonical.x - (e.canonical.x >> T << T),
                  A = e.canonical.y - (e.canonical.y >> T << T),
                  F = (e.canonical.x >> T) - p.canonical.x,
                  L = (e.canonical.y >> T) - p.canonical.y,
                  V = c.a3 << T;
                c.c0(x, 0, V, V, 0, 0, 1), c.N(x, x, [I * c.a3 + F * V, A * c.a3 + L * V, 0])
              }
              g.terrainRttPosMatrix32f = new Float32Array(x), u[h] = g
            }
            return u
          }
          getSourceTile(e, o) {
            const u = this.tileManager._source;
            let h = e.overscaledZ - this.deltaZoom;
            if (h > u.maxzoom && (h = u.maxzoom), h < u.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(h).key);
            let p = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!p || !p.dem) && o)
              for (; h >= u.minzoom && (!p || !p.dem);) p = this.tileManager.getTileByID(e.scaledTo(h--).key);
            return p
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, o) {
            return o[e.canonical.z] && e.canonical.x >= o[e.canonical.z].minTileX && e.canonical.x <= o[e.canonical.z].maxTileX && e.canonical.y >= o[e.canonical.z].minTileY && e.canonical.y <= o[e.canonical.z].maxTileY
          }
        }
        class Kd {
          constructor(e, o, u) {
            this._meshCache = {}, this.painter = e, this.tileManager = new Yd(o), this.options = u, this.exaggeration = typeof u.exaggeration == "number" ? u.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, o, u, h = c.a3) {
            var p;
            if (!(o >= 0 && o < h && u >= 0 && u < h)) return 0;
            const g = this.getTerrainData(e),
              x = (p = g.tile) === null || p === void 0 ? void 0 : p.dem;
            if (!x) return 0;
            const T = c.cv([], [o / h * c.a3, u / h * c.a3], g.u_terrain_matrix),
              I = [T[0] * x.dim, T[1] * x.dim],
              A = Math.floor(I[0]),
              F = Math.floor(I[1]),
              L = I[0] - A,
              V = I[1] - F;
            return x.get(A, F) * (1 - L) * (1 - V) + x.get(A + 1, F) * L * (1 - V) + x.get(A, F + 1) * (1 - L) * V + x.get(A + 1, F + 1) * L * V
          }
          getElevationForLngLatZoom(e, o) {
            if (!c.cw(o, e.wrap())) return 0;
            const {
              tileID: u,
              mercatorX: h,
              mercatorY: p
            } = this._getOverscaledTileIDFromLngLatZoom(e, o);
            return this.getElevation(u, h % c.a3, p % c.a3, c.a3)
          }
          getElevation(e, o, u, h = c.a3) {
            return this.getDEMElevation(e, o, u, h) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const h = this.painter.context,
                p = new c.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new c.T(h, p, h.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new c.T(h, new c.R({
                width: 1,
                height: 1
              }), h.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.am([])
            }
            const o = this.tileManager.getSourceTile(e, !0);
            if (o && o.dem && (!o.demTexture || o.needsTerrainPrepare)) {
              const h = this.painter.context;
              o.demTexture = this.painter.getTileTexture(o.dem.stride), o.demTexture ? o.demTexture.update(o.dem.getPixels(), {
                premultiply: !1
              }) : o.demTexture = new c.T(h, o.dem.getPixels(), h.gl.RGBA, {
                premultiply: !1
              }), o.demTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), o.needsTerrainPrepare = !1
            }
            const u = o && o + o.tileID.key + e.key;
            if (u && !this._demMatrixCache[u]) {
              const h = this.tileManager.getSource().maxzoom;
              let p = e.canonical.z - o.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= h ? p = e.canonical.z - h : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const g = e.canonical.x - (e.canonical.x >> p << p),
                x = e.canonical.y - (e.canonical.y >> p << p),
                T = c.cx(new Float64Array(16), [1 / (c.a3 << p), 1 / (c.a3 << p), 0]);
              c.N(T, T, [g * c.a3, x * c.a3, 0]), this._demMatrixCache[e.key] = {
                matrix: T,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: o && o.dem && o.dem.dim || 1,
              u_terrain_matrix: u ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: o && o.dem && o.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (o && o.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: o
            }
          }
          getFramebuffer(e) {
            const o = this.painter,
              u = o.width / devicePixelRatio,
              h = o.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === u && this._fbo.height === h || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new c.T(o.context, {
              width: u,
              height: h,
              data: null
            }, o.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(o.context.gl.NEAREST, o.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new c.T(o.context, {
              width: u,
              height: h,
              data: null
            }, o.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(o.context.gl.NEAREST, o.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = o.context.createFramebuffer(u, h, !0, !1), this._fbo.depthAttachment.set(o.context.createRenderbuffer(o.context.gl.DEPTH_COMPONENT16, u, h))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const o = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let p = 0, g = 0; p < this._coordsTextureSize; p++)
              for (let x = 0; x < this._coordsTextureSize; x++, g += 4) o[g + 0] = 255 & x, o[g + 1] = 255 & p, o[g + 2] = x >> 8 << 4 | p >> 8, o[g + 3] = 0;
            const u = new c.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(o.buffer)),
              h = new c.T(e, u, e.gl.RGBA, {
                premultiply: !1
              });
            return h.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = h, h
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const o = new Uint8Array(4),
              u = this.painter.context,
              h = u.gl,
              p = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              g = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              x = Math.round(this.painter.height / devicePixelRatio);
            u.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), h.readPixels(p, x - g - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, o), u.bindFramebuffer.set(null);
            const T = o[0] + (o[2] >> 4 << 8),
              I = o[1] + ((15 & o[2]) << 8),
              A = this.coordsIndex[255 - o[3]],
              F = A && this.tileManager.getTileByID(A);
            if (!F) return null;
            const L = this._coordsTextureSize,
              V = (1 << F.tileID.canonical.z) * L;
            return new c.a5((F.tileID.canonical.x * L + T) / V + F.tileID.wrap, (F.tileID.canonical.y * L + I) / V, this.getElevation(F.tileID, T, I, L))
          }
          depthAtPoint(e) {
            const o = new Uint8Array(4),
              u = this.painter.context,
              h = u.gl;
            return u.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), h.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, o), u.bindFramebuffer.set(null), (o[0] / 16777216 + o[1] / 65536 + o[2] / 256 + o[3]) / 256
          }
          getTerrainMesh(e) {
            var o;
            const u = ((o = this.painter.style.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0,
              h = u && e.canonical.y === 0,
              p = u && e.canonical.y === (1 << e.canonical.z) - 1,
              g = `m_${h?"n":""}_${p?"s":""}`;
            if (this._meshCache[g]) return this._meshCache[g];
            const x = this.painter.context,
              T = new c.cy,
              I = new c.aR,
              A = this.meshSize,
              F = c.a3 / A,
              L = A * A;
            for (let gt = 0; gt <= A; gt++)
              for (let Rt = 0; Rt <= A; Rt++) T.emplaceBack(Rt * F, gt * F, 0);
            for (let gt = 0; gt < L; gt += A + 1)
              for (let Rt = 0; Rt < A; Rt++) I.emplaceBack(Rt + gt, A + Rt + gt + 1, A + Rt + gt + 2), I.emplaceBack(Rt + gt, A + Rt + gt + 2, Rt + gt + 1);
            const V = T.length,
              K = V + (A + 1),
              it = (A + 1) * A,
              ot = h ? c.bk : 0,
              st = h ? 0 : 1,
              pt = p ? c.bl : c.a3,
              wt = p ? 0 : 1;
            for (let gt = 0; gt <= A; gt++) T.emplaceBack(gt * F, ot, st);
            for (let gt = 0; gt <= A; gt++) T.emplaceBack(gt * F, pt, wt);
            for (let gt = 0; gt < A; gt++) I.emplaceBack(it + gt, K + gt, K + gt + 1), I.emplaceBack(it + gt, K + gt + 1, it + gt + 1), I.emplaceBack(0 + gt, V + gt + 1, V + gt), I.emplaceBack(0 + gt, 0 + gt + 1, V + gt + 1);
            const dt = T.length,
              kt = dt + 2 * (A + 1);
            for (const gt of [0, 1])
              for (let Rt = 0; Rt <= A; Rt++)
                for (const oe of [0, 1]) T.emplaceBack(gt * c.a3, Rt * F, oe);
            for (let gt = 0; gt < 2 * A; gt += 2) I.emplaceBack(dt + gt, dt + gt + 1, dt + gt + 3), I.emplaceBack(dt + gt, dt + gt + 3, dt + gt + 2), I.emplaceBack(kt + gt, kt + gt + 3, kt + gt + 1), I.emplaceBack(kt + gt, kt + gt + 2, kt + gt + 3);
            const It = new Cn(x.createVertexBuffer(T, Ph.members), x.createIndexBuffer(I), c.aQ.simpleSegment(0, 0, T.length, I.length));
            return this._meshCache[g] = It, It
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * c.bx / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, o) {
            var u;
            const {
              tileID: h
            } = this._getOverscaledTileIDFromLngLatZoom(e, o);
            return (u = this.getMinMaxElevation(h).minElevation) !== null && u !== void 0 ? u : 0
          }
          getMinMaxElevation(e) {
            const o = this.getTerrainData(e).tile,
              u = {
                minElevation: null,
                maxElevation: null
              };
            return o && o.dem && (u.minElevation = o.dem.min * this.exaggeration, u.maxElevation = o.dem.max * this.exaggeration), u
          }
          _getOverscaledTileIDFromLngLatZoom(e, o) {
            const u = c.a5.fromLngLat(e.wrap()),
              h = (1 << o) * c.a3,
              p = u.x * h,
              g = u.y * h,
              x = Math.floor(p / c.a3),
              T = Math.floor(g / c.a3);
            return {
              tileID: new c.a0(o, 0, o, x, T),
              mercatorX: p,
              mercatorY: g
            }
          }
        }
        class Jd {
          constructor(e, o, u) {
            this._context = e, this._size = o, this._tileSize = u, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const o = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              u = new c.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return u.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), o.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), o.colorAttachment.set(u.texture), {
              id: e,
              fbo: o,
              texture: u,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((o => e.id !== o)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const o of this._recentlyUsed)
              if (!this._objects[o].inUse) return this._objects[o];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const es = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class li {
          constructor(e, o) {
            this.painter = e, this.terrain = o, this.pool = new Jd(e.context, 30, o.tileManager.tileSize * o.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, o) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter((u => !e._layers[u].isHidden(o))), this._coordsAscending = {};
            for (const u in e.tileManagers) {
              this._coordsAscending[u] = {};
              const h = e.tileManagers[u].getVisibleCoordinates(),
                p = e.tileManagers[u].getSource(),
                g = p instanceof Pr ? p.terrainTileRanges : null;
              for (const x of h) {
                const T = this.terrain.tileManager.getTerrainCoords(x, g);
                for (const I in T) this._coordsAscending[u][I] || (this._coordsAscending[u][I] = []), this._coordsAscending[u][I].push(T[I])
              }
            }
            this._coordsAscendingStr = {};
            for (const u of e._order) {
              const h = e._layers[u],
                p = h.source;
              if (es[h.type] && !this._coordsAscendingStr[p]) {
                this._coordsAscendingStr[p] = {};
                for (const g in this._coordsAscending[p]) this._coordsAscendingStr[p][g] = this._coordsAscending[p][g].map((x => x.key)).sort().join()
              }
            }
            for (const u of this._renderableTiles)
              for (const h in this._coordsAscendingStr) {
                const p = this._coordsAscendingStr[h][u.tileID.key];
                p && p !== u.rttCoords[h] && (u.rtt = [])
              }
          }
          renderLayer(e, o) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const u = Object.assign(Object.assign({}, o), {
                isRenderingToTexture: !0
              }),
              h = e.type,
              p = this.painter,
              g = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (es[h] && (this._prevType && es[this._prevType] || this._stacks.push([]), this._prevType = h, this._stacks[this._stacks.length - 1].push(e.id), !g)) return !0;
            if (es[this._prevType] || es[h] && g) {
              this._prevType = h;
              const x = this._stacks.length - 1,
                T = this._stacks[x] || [];
              for (const I of this._renderableTiles) {
                if (this.pool.isFull() && (ol(this.painter, this.terrain, this._rttTiles, u), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(I), I.rtt[x]) {
                  const F = this.pool.getObjectForId(I.rtt[x].id);
                  if (F.stamp === I.rtt[x].stamp) {
                    this.pool.useObject(F);
                    continue
                  }
                }
                const A = this.pool.getOrCreateFreeObject();
                this.pool.useObject(A), this.pool.stampObject(A), I.rtt[x] = {
                  id: A.id,
                  stamp: A.stamp
                }, p.context.bindFramebuffer.set(A.fbo.framebuffer), p.context.clear({
                  color: c.bi.transparent,
                  stencil: 0
                }), p.currentStencilSource = void 0;
                for (let F = 0; F < T.length; F++) {
                  const L = p.style._layers[T[F]],
                    V = L.source ? this._coordsAscending[L.source][I.tileID.key] : [I.tileID];
                  p.context.viewport.set([0, 0, A.fbo.width, A.fbo.height]), p._renderTileClippingMasks(L, V, !0), p.renderLayer(p, p.style.tileManagers[L.source], L, V, u), L.source && (I.rttCoords[L.source] = this._coordsAscendingStr[L.source][I.tileID.key])
                }
              }
              return ol(this.painter, this.terrain, this._rttTiles, u), this._rttTiles = [], this.pool.freeAllObjects(), es[h]
            }
            return !1
          }
        }
        const bi = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use âŒ˜ + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Mh = R,
          Ca = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: iu,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: c.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          Wu = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class yl {
          constructor(e, o, u = !1) {
            this.mousedown = p => {
              this.startMove(p, G.mousePos(this.element, p)), G.addEventListener(window, "mousemove", this.mousemove), G.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = p => {
              this.move(p, G.mousePos(this.element, p))
            }, this.mouseup = p => {
              this._rotatePitchHandler.dragEnd(p), this.offTemp()
            }, this.touchstart = p => {
              p.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = G.touchPos(this.element, p.targetTouches)[0], this.startMove(p, this._startPos), G.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), G.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = p => {
              p.targetTouches.length !== 1 ? this.reset() : (this._lastPos = G.touchPos(this.element, p.targetTouches)[0], this.move(p, this._lastPos))
            }, this.touchend = p => {
              p.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = o;
            const h = new ll;
            this._rotatePitchHandler = new Sr({
              clickTolerance: 3,
              move: (p, g) => {
                const x = o.getBoundingClientRect(),
                  T = new c.P((x.bottom - x.top) / 2, (x.right - x.left) / 2);
                return {
                  bearingDelta: c.cq(new c.P(p.x, g.y), g, T),
                  pitchDelta: u ? -.5 * (g.y - p.y) : void 0
                }
              },
              moveStateManager: h,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, G.addEventListener(o, "mousedown", this.mousedown), G.addEventListener(o, "touchstart", this.touchstart, {
              passive: !1
            }), G.addEventListener(o, "touchcancel", this.reset)
          }
          startMove(e, o) {
            this._rotatePitchHandler.dragStart(e, o), G.disableDrag()
          }
          move(e, o) {
            const u = this.map,
              {
                bearingDelta: h,
                pitchDelta: p
              } = this._rotatePitchHandler.dragMove(e, o) || {};
            h && u.setBearing(u.getBearing() + h), p && u.setPitch(u.getPitch() + p)
          }
          off() {
            const e = this.element;
            G.removeEventListener(e, "mousedown", this.mousedown), G.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), G.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), G.removeEventListener(window, "touchend", this.touchend), G.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            G.enableDrag(), G.removeEventListener(window, "mousemove", this.mousemove), G.removeEventListener(window, "mouseup", this.mouseup), G.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), G.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let hs;

        function $u(d, e, o, u = !1) {
          if (u || !o.getCoveringTilesDetailsProvider().allowWorldCopies()) return d == null ? void 0 : d.wrap();
          const h = new c.U(d.lng, d.lat);
          if (d = new c.U(d.lng, d.lat), e) {
            const p = new c.U(d.lng - 360, d.lat),
              g = new c.U(d.lng + 360, d.lat),
              x = o.locationToScreenPoint(d).distSqr(e);
            o.locationToScreenPoint(p).distSqr(e) < x ? d = p : o.locationToScreenPoint(g).distSqr(e) < x && (d = g)
          }
          for (; Math.abs(d.lng - o.center.lng) > 180;) {
            const p = o.locationToScreenPoint(d);
            if (p.x >= 0 && p.y >= 0 && p.x <= o.width && p.y <= o.height) break;
            d.lng > o.center.lng ? d.lng -= 360 : d.lng += 360
          }
          return d.lng !== h.lng && o.isPointOnMapSurface(o.locationToScreenPoint(d)) ? d : h
        }
        const Xs = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function Xu(d, e, o) {
          const u = d.classList;
          for (const h in Xs) u.remove(`maplibregl-${o}-anchor-${h}`);
          u.add(`maplibregl-${o}-anchor-${e}`)
        }
        class ou extends c.E {
          constructor(e) {
            if (super(), this._onKeyPress = o => {
                const u = o.code,
                  h = o.charCode || o.keyCode;
                u !== "Space" && u !== "Enter" && h !== 32 && h !== 13 || this.togglePopup()
              }, this._onMapClick = o => {
                const u = o.originalEvent.target,
                  h = this._element;
                this._popup && (u === h || h.contains(u)) && this.togglePopup()
              }, this._update = o => {
                if (!this._map) return;
                const u = this._map.loaded() && !this._map.isMoving();
                ((o == null ? void 0 : o.type) === "terrain" || (o == null ? void 0 : o.type) === "render" && !u) && this._map.once("render", this._update), this._lngLat = $u(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let h = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? h = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (h = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let p = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? p = "rotateX(0deg)" : this._pitchAlignment === "map" && (p = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || o && o.type !== "moveend" || (this._pos = this._pos.round()), G.setTransform(this._element, `${Xs[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${p} ${h}`), ut.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(o && o.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = o => {
                if (!this._isDragging) {
                  const u = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = o.point.dist(this._pointerdownPos) >= u
                }
                this._isDragging && (this._pos = o.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.l("dragstart"))), this.fire(new c.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = o => {
                this._element.contains(o.originalEvent.target) && (o.preventDefault(), this._positionDelta = o.point.sub(this._pos).add(this._offset), this._pointerdownPos = o.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = c.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = G.create("div");
              const o = G.createNS("http://www.w3.org/2000/svg", "svg"),
                u = 41,
                h = 27;
              o.setAttributeNS(null, "display", "block"), o.setAttributeNS(null, "height", `${u}px`), o.setAttributeNS(null, "width", `${h}px`), o.setAttributeNS(null, "viewBox", `0 0 ${h} ${u}`);
              const p = G.createNS("http://www.w3.org/2000/svg", "g");
              p.setAttributeNS(null, "stroke", "none"), p.setAttributeNS(null, "stroke-width", "1"), p.setAttributeNS(null, "fill", "none"), p.setAttributeNS(null, "fill-rule", "evenodd");
              const g = G.createNS("http://www.w3.org/2000/svg", "g");
              g.setAttributeNS(null, "fill-rule", "nonzero");
              const x = G.createNS("http://www.w3.org/2000/svg", "g");
              x.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), x.setAttributeNS(null, "fill", "#000000");
              const T = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const st of T) {
                const pt = G.createNS("http://www.w3.org/2000/svg", "ellipse");
                pt.setAttributeNS(null, "opacity", "0.04"), pt.setAttributeNS(null, "cx", "10.5"), pt.setAttributeNS(null, "cy", "5.80029008"), pt.setAttributeNS(null, "rx", st.rx), pt.setAttributeNS(null, "ry", st.ry), x.appendChild(pt)
              }
              const I = G.createNS("http://www.w3.org/2000/svg", "g");
              I.setAttributeNS(null, "fill", this._color);
              const A = G.createNS("http://www.w3.org/2000/svg", "path");
              A.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), I.appendChild(A);
              const F = G.createNS("http://www.w3.org/2000/svg", "g");
              F.setAttributeNS(null, "opacity", "0.25"), F.setAttributeNS(null, "fill", "#000000");
              const L = G.createNS("http://www.w3.org/2000/svg", "path");
              L.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), F.appendChild(L);
              const V = G.createNS("http://www.w3.org/2000/svg", "g");
              V.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), V.setAttributeNS(null, "fill", "#FFFFFF");
              const K = G.createNS("http://www.w3.org/2000/svg", "g");
              K.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const it = G.createNS("http://www.w3.org/2000/svg", "circle");
              it.setAttributeNS(null, "fill", "#000000"), it.setAttributeNS(null, "opacity", "0.25"), it.setAttributeNS(null, "cx", "5.5"), it.setAttributeNS(null, "cy", "5.5"), it.setAttributeNS(null, "r", "5.4999962");
              const ot = G.createNS("http://www.w3.org/2000/svg", "circle");
              ot.setAttributeNS(null, "fill", "#FFFFFF"), ot.setAttributeNS(null, "cx", "5.5"), ot.setAttributeNS(null, "cy", "5.5"), ot.setAttributeNS(null, "r", "5.4999962"), K.appendChild(it), K.appendChild(ot), g.appendChild(x), g.appendChild(I), g.appendChild(F), g.appendChild(V), g.appendChild(K), o.appendChild(g), o.setAttributeNS(null, "height", u * this._scale + "px"), o.setAttributeNS(null, "width", h * this._scale + "px"), this._element.appendChild(o), this._offset = c.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (o => {
                o.preventDefault()
              })), this._element.addEventListener("mousedown", (o => {
                o.preventDefault()
              })), Xu(this._element, this._anchor, "marker"), e && e.className)
              for (const o of e.className.split(" ")) this._element.classList.add(o);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), G.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = c.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const h = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [h, -1 * (38.1 - 13.5 + h)],
                  "bottom-right": [-h, -1 * (38.1 - 13.5 + h)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var o, u;
            const h = (o = this._map) === null || o === void 0 ? void 0 : o.terrain,
              p = this._map.transform.isLocationOccluded(this._lngLat);
            if (!h || p) {
              const V = p ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== V && (this._element.style.opacity = V))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const g = this._map,
              x = g.terrain.depthAtPoint(this._pos),
              T = g.terrain.getElevationForLngLatZoom(this._lngLat, g.transform.tileZoom);
            if (g.transform.lngLatToCameraDepth(this._lngLat, T) - x < .006) return void(this._element.style.opacity = this._opacity);
            const I = -this._offset.y / g.transform.pixelsPerMeter,
              A = Math.sin(g.getPitch() * Math.PI / 180) * I,
              F = g.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)),
              L = g.transform.lngLatToCameraDepth(this._lngLat, T + A) - F > .006;
            !((u = this._popup) === null || u === void 0) && u.isOpen() && L && this._popup.remove(), this._element.style.opacity = L ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = c.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, o) {
            return (this._opacity === void 0 || e === void 0 && o === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), o !== void 0 && (this._opacityWhenCovered = o), this._map && this._updateOpacity(!0), this
          }
        }
        const vl = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let Ia = 0,
          Ys = !1;
        const bl = {
          maxWidth: 100,
          unit: "metric"
        };

        function Yu(d, e, o) {
          const u = o && o.maxWidth || 100,
            h = d._container.clientHeight / 2,
            p = d._container.clientWidth / 2,
            g = d.unproject([p - u / 2, h]),
            x = d.unproject([p + u / 2, h]),
            T = Math.round(d.project(x).x - d.project(g).x),
            I = Math.min(u, T, d._container.clientWidth),
            A = g.distanceTo(x);
          if (o && o.unit === "imperial") {
            const F = 3.2808 * A;
            F > 5280 ? Ks(e, I, F / 5280, d._getUIString("ScaleControl.Miles")) : Ks(e, I, F, d._getUIString("ScaleControl.Feet"))
          } else o && o.unit === "nautical" ? Ks(e, I, A / 1852, d._getUIString("ScaleControl.NauticalMiles")) : A >= 1e3 ? Ks(e, I, A / 1e3, d._getUIString("ScaleControl.Kilometers")) : Ks(e, I, A, d._getUIString("ScaleControl.Meters"))
        }

        function Ks(d, e, o, u) {
          const h = (function(p) {
            const g = Math.pow(10, `${Math.floor(p)}`.length - 1);
            let x = p / g;
            return x = x >= 10 ? 10 : x >= 5 ? 5 : x >= 3 ? 3 : x >= 2 ? 2 : x >= 1 ? 1 : (function(T) {
              const I = Math.pow(10, Math.ceil(-Math.log(T) / Math.LN10));
              return Math.round(T * I) / I
            })(x), g * x
          })(o);
          d.style.width = e * (h / o) + "px", d.innerHTML = `${h}&nbsp;${u}`
        }
        const xl = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          Ku = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function Ju(d) {
          if (d) {
            if (typeof d == "number") {
              const e = Math.round(Math.abs(d) / Math.SQRT2);
              return {
                center: new c.P(0, 0),
                top: new c.P(0, d),
                "top-left": new c.P(e, e),
                "top-right": new c.P(-e, e),
                bottom: new c.P(0, -d),
                "bottom-left": new c.P(e, -e),
                "bottom-right": new c.P(-e, -e),
                left: new c.P(d, 0),
                right: new c.P(-d, 0)
              }
            }
            if (d instanceof c.P || Array.isArray(d)) {
              const e = c.P.convert(d);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: c.P.convert(d.center || [0, 0]),
              top: c.P.convert(d.top || [0, 0]),
              "top-left": c.P.convert(d["top-left"] || [0, 0]),
              "top-right": c.P.convert(d["top-right"] || [0, 0]),
              bottom: c.P.convert(d.bottom || [0, 0]),
              "bottom-left": c.P.convert(d["bottom-left"] || [0, 0]),
              "bottom-right": c.P.convert(d["bottom-right"] || [0, 0]),
              left: c.P.convert(d.left || [0, 0]),
              right: c.P.convert(d.right || [0, 0])
            }
          }
          return Ju(new c.P(0, 0))
        }
        const wl = R;
        k.AJAXError = c.cC, k.Event = c.l, k.Evented = c.E, k.LngLat = c.U, k.MercatorCoordinate = c.a5, k.Point = c.P, k.addProtocol = c.cD, k.config = c.a, k.removeProtocol = c.cE, k.AttributionControl = io, k.BoxZoomHandler = dh, k.CanvasSource = jr, k.CooperativeGesturesHandler = Vo, k.DoubleClickZoomHandler = ru, k.DragPanHandler = fl, k.DragRotateHandler = ml, k.EdgeInsets = bn, k.FullscreenControl = class extends c.E {
          constructor(d = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let o = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = o == null ? void 0 : o.shadowRoot) === null || e === void 0) && e.fullscreenElement;) o = o.shadowRoot.fullscreenElement;
              o === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, d && d.container && (d.container instanceof HTMLElement ? this._container = d.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(d) {
            return this._map = d, this._container || (this._container = this._map.getContainer()), this._controlContainer = G.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            G.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const d = this._fullscreenButton = G.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            G.create("span", "maplibregl-ctrl-icon", d).setAttribute("aria-hidden", "true"), d.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const d = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", d), this._fullscreenButton.title = d
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, k.GeoJSONSource = Mr, k.GeolocateControl = class extends c.E {
          constructor(d) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new c.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const o = new c.U(e.coords.longitude, e.coords.latitude),
                u = e.coords.accuracy,
                h = this._map.getBearing(),
                p = c.e({
                  bearing: h
                }, this.options.fitBoundsOptions),
                g = ir.fromLngLat(o, u);
              this._map.fitBounds(g, p, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const o = new c.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(o).addTo(this._map), this._userLocationDotMarker.setLngLat(o).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const o = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = o, this._geolocateButton.setAttribute("aria-label", o), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Ys) return;
                  this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = G.create("button", "maplibregl-ctrl-geolocate", this._container), G.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  c.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const o = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = o, this._geolocateButton.setAttribute("aria-label", o)
                } else {
                  const o = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = o, this._geolocateButton.setAttribute("aria-label", o)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = G.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ou({
                  element: this._dotElement
                }), this._circleElement = G.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ou({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (o => {
                  const u = (o == null ? void 0 : o[0]) instanceof ResizeObserverEntry;
                  o.geolocateSource || this._watchState !== "ACTIVE_LOCK" || u || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.l("trackuserlocationend")), this.fire(new c.l("userlocationlostfocus")))
                }))
              }
            }, this.options = c.e({}, vl, d)
          }
          onAdd(d) {
            return this._map = d, this._container = G.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return c._(this, arguments, void 0, (function*(e = !1) {
                if (hs !== void 0 && !e) return hs;
                if (window.navigator.permissions === void 0) return hs = !!window.navigator.geolocation, hs;
                try {
                  hs = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  hs = !!window.navigator.geolocation
                }
                return hs
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), G.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Ia = 0, Ys = !1
          }
          _isOutOfMapMaxBounds(d) {
            const e = this._map.getMaxBounds(),
              o = d.coords;
            return e && (o.longitude < e.getWest() || o.longitude > e.getEast() || o.latitude < e.getSouth() || o.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadiusIfNeeded() {
            const d = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && d)) return;
            const e = this._map.project(d),
              o = this._map.unproject([e.x + 100, e.y]),
              u = d.distanceTo(o) / 100,
              h = 2 * this._accuracy / u;
            this._circleElement.style.width = `${h.toFixed(2)}px`, this._circleElement.style.height = `${h.toFixed(2)}px`
          }
          trigger() {
            if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new c.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ia--, Ys = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.l("trackuserlocationstart")), this.fire(new c.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let d;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ia++, Ia > 1 ? (d = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Ys = !0) : (d = this.options.positionOptions, Ys = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, d)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, k.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var d;
              const e = (d = this._map.getProjection()) === null || d === void 0 ? void 0 : d.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var d;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((d = this._map.getProjection()) === null || d === void 0 ? void 0 : d.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(d) {
            return this._map = d, this._container = G.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = G.create("button", "maplibregl-ctrl-globe", this._container), G.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            G.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, k.Hash = al, k.ImageSource = Pr, k.KeyboardHandler = xh, k.LngLatBounds = ir, k.LogoControl = gl, k.Map = class extends Sh {
          constructor(d) {
            var e, o;
            c.cz.mark(c.cA.create);
            const u = Object.assign(Object.assign(Object.assign({}, Ca), d), {
              canvasContextAttributes: Object.assign(Object.assign({}, Ca.canvasContextAttributes), d.canvasContextAttributes)
            });
            if (u.minZoom != null && u.maxZoom != null && u.minZoom > u.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (u.minPitch != null && u.maxPitch != null && u.minPitch > u.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (u.minPitch != null && u.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (u.maxPitch != null && u.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const h = new $i,
              p = new ji;
            if (u.minZoom !== void 0 && h.setMinZoom(u.minZoom), u.maxZoom !== void 0 && h.setMaxZoom(u.maxZoom), u.minPitch !== void 0 && h.setMinPitch(u.minPitch), u.maxPitch !== void 0 && h.setMaxPitch(u.maxPitch), u.renderWorldCopies !== void 0 && h.setRenderWorldCopies(u.renderWorldCopies), u.transformConstrain !== null && h.setConstrain(u.transformConstrain), super(h, p, {
                bearingSnap: u.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Uo, this._controls = [], this._mapId = c.ab(), this._contextLost = x => {
                x.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new c.l("webglcontextlost", {
                  originalEvent: x
                }))
              }, this._contextRestored = x => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new c.l("webglcontextrestored", {
                  originalEvent: x
                }))
              }, this._onMapScroll = x => {
                if (x.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = u.interactive, this._maxTileCacheSize = u.maxTileCacheSize, this._maxTileCacheZoomLevels = u.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, u.canvasContextAttributes), this._trackResize = u.trackResize === !0, this._bearingSnap = u.bearingSnap, this._centerClampedToGround = u.centerClampedToGround, this._refreshExpiredTiles = u.refreshExpiredTiles === !0, this._fadeDuration = u.fadeDuration, this._crossSourceCollisions = u.crossSourceCollisions === !0, this._collectResourceTiming = u.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, bi), u.locale), this._clickTolerance = u.clickTolerance, this._overridePixelRatio = u.pixelRatio, this._maxCanvasSize = u.maxCanvasSize, this.transformCameraUpdate = u.transformCameraUpdate, this.transformConstrain = u.transformConstrain, this.cancelPendingTileRequestsWhileZooming = u.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Zt.addThrottleControl((() => this.isMoving())), this._requestManager = new Et(u.transformRequest), typeof u.container == "string") {
              if (this._container = document.getElementById(u.container), !this._container) throw new Error(`Container '${u.container}' not found.`)
            } else {
              if (!(u.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = u.container
            }
            if (u.maxBounds && this.setMaxBounds(u.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let x = !1;
              const T = sl((I => {
                this._trackResize && !this._removed && (this.resize(I), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((I => {
                x ? T(I) : x = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new nu(this, u), this._hash = u.hash && new al(typeof u.hash == "string" && u.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: u.center,
              elevation: u.elevation,
              zoom: u.zoom,
              bearing: u.bearing,
              pitch: u.pitch,
              roll: u.roll
            }), u.bounds && (this.resize(), this.fitBounds(u.bounds, c.e({}, u.fitBoundsOptions, {
              duration: 0
            }))));
            const g = typeof u.style == "string" || ((o = (e = u.style) === null || e === void 0 ? void 0 : e.projection) === null || o === void 0 ? void 0 : o.type) !== "globe";
            this.resize(null, g), this._localIdeographFontFamily = u.localIdeographFontFamily, this._validateStyle = u.validateStyle, u.style && this.setStyle(u.style, {
              localIdeographFontFamily: u.localIdeographFontFamily
            }), u.attributionControl && this.addControl(new io(typeof u.attributionControl == "boolean" ? void 0 : u.attributionControl)), u.maplibreLogo && this.addControl(new gl, u.logoPosition), this.on("style.load", (() => {
              if (g || this._resizeTransform(), this.transform.unmodified) {
                const x = c.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(x)
              }
            })), this.on("data", (x => {
              this._update(x.dataType === "style"), this.fire(new c.l(`${x.dataType}data`, x))
            })), this.on("dataloading", (x => {
              this.fire(new c.l(`${x.dataType}dataloading`, x))
            })), this.on("dataabort", (x => {
              this.fire(new c.l("sourcedataabort", x))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(d, e) {
            return this.style.setGlobalStateProperty(d, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(d, e) {
            if (e === void 0 && (e = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd) return this.fire(new c.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o = d.onAdd(this);
            this._controls.push(d);
            const u = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? u.insertBefore(o, u.firstChild) : u.appendChild(o), this
          }
          removeControl(d) {
            if (!d || !d.onRemove) return this.fire(new c.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(d);
            return e > -1 && this._controls.splice(e, 1), d.onRemove(this), this
          }
          hasControl(d) {
            return this._controls.indexOf(d) > -1
          }
          coveringTiles(d) {
            return ye(this.transform, d)
          }
          calculateCameraOptionsFromTo(d, e, o, u) {
            return u == null && this.terrain && (u = this.terrain.getElevationForLngLatZoom(o, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(d, e, o, u)
          }
          resize(d, e = !0) {
            const [o, u] = this._containerDimensions(), h = this._getClampedPixelRatio(o, u);
            if (this._resizeCanvas(o, u, h), this.painter.resize(o, u, h), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const x = this._getClampedPixelRatio(o, u);
              this._resizeCanvas(o, u, x), this.painter.resize(o, u, x)
            }
            this._resizeTransform(e);
            const p = !this._moving;
            return p && (this.stop(), this.fire(new c.l("movestart", d)).fire(new c.l("move", d))), this.fire(new c.l("resize", d)), p && this.fire(new c.l("moveend", d)), this
          }
          _resizeTransform(d = !0) {
            var e;
            const [o, u] = this._containerDimensions();
            this.transform.resize(o, u, d), (e = this._requestedCameraState) === null || e === void 0 || e.resize(o, u, d)
          }
          _getClampedPixelRatio(d, e) {
            const {
              0: o,
              1: u
            } = this._maxCanvasSize, h = this.getPixelRatio(), p = d * h, g = e * h;
            return Math.min(p > o ? o / p : 1, g > u ? u / g : 1) * h
          }
          getPixelRatio() {
            var d;
            return (d = this._overridePixelRatio) !== null && d !== void 0 ? d : devicePixelRatio
          }
          setPixelRatio(d) {
            this._overridePixelRatio = d, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(d) {
            return this.transform.setMaxBounds(ir.convert(d)), this._update()
          }
          setMinZoom(d) {
            if ((d = d ?? -2) >= -2 && d <= this.transform.maxZoom) return this.transform.setMinZoom(d), this._update(), this.getZoom() < d && this.setZoom(d), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(d) {
            if ((d = d ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(d), this._update(), this.getZoom() > d && this.setZoom(d), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(d) {
            if ((d = d ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (d >= 0 && d <= this.transform.maxPitch) return this.transform.setMinPitch(d), this._update(), this.getPitch() < d && this.setPitch(d), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(d) {
            if ((d = d ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (d >= this.transform.minPitch) return this.transform.setMaxPitch(d), this._update(), this.getPitch() > d && this.setPitch(d), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(d) {
            return this.transform.setRenderWorldCopies(d), this._update()
          }
          setTransformConstrain(d) {
            return this.transform.setConstrain(d), this._update()
          }
          project(d) {
            return this.transform.locationToScreenPoint(c.U.convert(d), this.style && this.terrain)
          }
          unproject(d) {
            return this.transform.screenPointToLocation(c.P.convert(d), this.terrain)
          }
          isMoving() {
            var d;
            return this._moving || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isMoving())
          }
          isZooming() {
            var d;
            return this._zooming || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isZooming())
          }
          isRotating() {
            var d;
            return this._rotating || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isRotating())
          }
          _createDelegatedListener(d, e, o) {
            if (d === "mouseenter" || d === "mouseover") {
              let u = !1;
              return {
                layers: e,
                listener: o,
                delegates: {
                  mousemove: p => {
                    const g = e.filter((T => this.getLayer(T))),
                      x = g.length !== 0 ? this.queryRenderedFeatures(p.point, {
                        layers: g
                      }) : [];
                    x.length ? u || (u = !0, o.call(this, new mo(d, this, p.originalEvent, {
                      features: x
                    }))) : u = !1
                  },
                  mouseout: () => {
                    u = !1
                  }
                }
              }
            }
            if (d === "mouseleave" || d === "mouseout") {
              let u = !1;
              return {
                layers: e,
                listener: o,
                delegates: {
                  mousemove: g => {
                    const x = e.filter((T => this.getLayer(T)));
                    (x.length !== 0 ? this.queryRenderedFeatures(g.point, {
                      layers: x
                    }) : []).length ? u = !0 : u && (u = !1, o.call(this, new mo(d, this, g.originalEvent)))
                  },
                  mouseout: g => {
                    u && (u = !1, o.call(this, new mo(d, this, g.originalEvent)))
                  }
                }
              }
            } {
              const u = h => {
                const p = e.filter((x => this.getLayer(x))),
                  g = p.length !== 0 ? this.queryRenderedFeatures(h.point, {
                    layers: p
                  }) : [];
                g.length && (h.features = g, o.call(this, h), delete h.features)
              };
              return {
                layers: e,
                listener: o,
                delegates: {
                  [d]: u
                }
              }
            }
          }
          _saveDelegatedListener(d, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(e)
          }
          _removeDelegatedListener(d, e, o) {
            if (!this._delegatedListeners || !this._delegatedListeners[d]) return;
            const u = this._delegatedListeners[d];
            for (let h = 0; h < u.length; h++) {
              const p = u[h];
              if (p.listener === o && p.layers.length === e.length && p.layers.every((g => e.includes(g)))) {
                for (const g in p.delegates) this.off(g, p.delegates[g]);
                return void u.splice(h, 1)
              }
            }
          }
          on(d, e, o) {
            if (o === void 0) return super.on(d, e);
            const u = typeof e == "string" ? [e] : e,
              h = this._createDelegatedListener(d, u, o);
            this._saveDelegatedListener(d, h);
            for (const p in h.delegates) this.on(p, h.delegates[p]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(d, u, o)
              }
            }
          }
          once(d, e, o) {
            if (o === void 0) return super.once(d, e);
            const u = typeof e == "string" ? [e] : e,
              h = this._createDelegatedListener(d, u, o);
            for (const p in h.delegates) {
              const g = h.delegates[p];
              h.delegates[p] = (...x) => {
                this._removeDelegatedListener(d, u, o), g(...x)
              }
            }
            this._saveDelegatedListener(d, h);
            for (const p in h.delegates) this.once(p, h.delegates[p]);
            return this
          }
          off(d, e, o) {
            return o === void 0 ? super.off(d, e) : (this._removeDelegatedListener(d, typeof e == "string" ? [e] : e, o), this)
          }
          queryRenderedFeatures(d, e) {
            if (!this.style) return [];
            let o;
            const u = d instanceof c.P || Array.isArray(d),
              h = u ? d : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (u ? {} : d) || {}, h instanceof c.P || typeof h[0] == "number") o = [c.P.convert(h)];
            else {
              const p = c.P.convert(h[0]),
                g = c.P.convert(h[1]);
              o = [p, new c.P(g.x, p.y), g, new c.P(p.x, g.y), p]
            }
            return this.style.queryRenderedFeatures(o, e, this.transform)
          }
          querySourceFeatures(d, e) {
            return this.style.querySourceFeatures(d, e)
          }
          setStyle(d, e) {
            return (e = c.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && d ? (this._diffStyle(d, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(d, e))
          }
          setTransformRequest(d) {
            return this._requestManager.setTransformRequest(d), this
          }
          _getUIString(d) {
            const e = this._locale[d];
            if (e == null) throw new Error(`Missing UI string '${d}'`);
            return e
          }
          _updateStyle(d, e) {
            var o, u;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(d, e)));
            const h = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!d)), d ? (this.style = new Ua(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof d == "string" ? this.style.loadURL(d, e, h) : this.style.loadJSON(d, e, h), this) : ((u = (o = this.style) === null || o === void 0 ? void 0 : o.projection) === null || u === void 0 || u.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ua(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(d, e) {
            if (typeof d == "string") {
              const o = this._requestManager.transformRequest(d, "Style");
              c.j(o, new AbortController).then((u => {
                this._updateDiff(u.data, e)
              })).catch((u => {
                u && this.fire(new c.k(u))
              }))
            } else typeof d == "object" && this._updateDiff(d, e)
          }
          _updateDiff(d, e) {
            try {
              this.style.setState(d, e) && this._update(!0)
            } catch (o) {
              c.w(`Unable to perform style diff: ${o.message||o.error||o}.  Rebuilding the style from scratch.`), this._updateStyle(d, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : c.w("There is no style added to the map.")
          }
          addSource(d, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(d, e), this._update(!0)
          }
          isSourceLoaded(d) {
            const e = this.style && this.style.tileManagers[d];
            if (e !== void 0) return e.loaded();
            this.fire(new c.k(new Error(`There is no tile manager with ID '${d}'`)))
          }
          setTerrain(d) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), d) {
              const e = this.style.tileManagers[d.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${d.source}`);
              this.terrain === null && e.reload();
              for (const o in this.style._layers) {
                const u = this.style._layers[o];
                u.type === "hillshade" && u.source === d.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), u.type === "color-relief" && u.source === d.source && c.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new Kd(this.painter, e, d), this.painter.renderToTexture = new li(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = o => {
                var u;
                o.dataType === "style" ? this.terrain.tileManager.freeRtt() : o.dataType === "source" && o.tile && (o.sourceId !== d.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((u = o.source) === null || u === void 0 ? void 0 : u.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(o.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new c.l("terrain", {
              terrain: d
            })), this
          }
          getTerrain() {
            var d, e;
            return (e = (d = this.terrain) === null || d === void 0 ? void 0 : d.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const d = this.style && this.style.tileManagers;
            for (const e in d) {
              const o = d[e]._tiles;
              for (const u in o) {
                const h = o[u];
                if (h.state !== "loaded" && h.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(d) {
            return this.style.removeSource(d), this._update(!0)
          }
          getSource(d) {
            return this.style.getSource(d)
          }
          setSourceTileLodParams(d, e, o) {
            if (o) {
              const u = this.getSource(o);
              if (!u) throw new Error(`There is no source with ID "${o}", cannot set LOD parameters`);
              u.calculateTileZoom = Pt(Math.max(1, d), Math.max(1, e))
            } else
              for (const u in this.style.tileManagers) this.style.tileManagers[u].getSource().calculateTileZoom = Pt(Math.max(1, d), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(d, e) {
            const o = this.style.tileManagers[d];
            if (!o) throw new Error(`There is no tile manager with ID "${d}", cannot refresh tile`);
            e === void 0 ? o.reload(!0) : o.refreshTiles(e.map((u => new c.a8(u.z, u.x, u.y))))
          }
          addImage(d, e, o = {}) {
            const {
              pixelRatio: u = 1,
              sdf: h = !1,
              stretchX: p,
              stretchY: g,
              content: x,
              textFitWidth: T,
              textFitHeight: I
            } = o;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || c.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: A,
                  height: F,
                  data: L
                } = e, V = e;
                return this.style.addImage(d, {
                  data: new c.R({
                    width: A,
                    height: F
                  }, new Uint8Array(L)),
                  pixelRatio: u,
                  stretchX: p,
                  stretchY: g,
                  content: x,
                  textFitWidth: T,
                  textFitHeight: I,
                  sdf: h,
                  version: 0,
                  userImage: V
                }), V.onAdd && V.onAdd(this, d), this
              }
            } {
              const {
                width: A,
                height: F,
                data: L
              } = ut.getImageData(e);
              this.style.addImage(d, {
                data: new c.R({
                  width: A,
                  height: F
                }, L),
                pixelRatio: u,
                stretchX: p,
                stretchY: g,
                content: x,
                textFitWidth: T,
                textFitHeight: I,
                sdf: h,
                version: 0
              })
            }
          }
          updateImage(d, e) {
            const o = this.style.getImage(d);
            if (!o) return this.fire(new c.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const u = e instanceof HTMLImageElement || c.b(e) ? ut.getImageData(e) : e,
              {
                width: h,
                height: p,
                data: g
              } = u;
            if (h === void 0 || p === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (h !== o.data.width || p !== o.data.height) return this.fire(new c.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const x = !(e instanceof HTMLImageElement || c.b(e));
            return o.data.replace(g, x), this.style.updateImage(d, o), this
          }
          getImage(d) {
            return this.style.getImage(d)
          }
          hasImage(d) {
            return d ? !!this.style.getImage(d) : (this.fire(new c.k(new Error("Missing required image id"))), !1)
          }
          removeImage(d) {
            this.style.removeImage(d)
          }
          loadImage(d) {
            return Zt.getImage(this._requestManager.transformRequest(d, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(d, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(d, e), this._update(!0)
          }
          moveLayer(d, e) {
            return this.style.moveLayer(d, e), this._update(!0)
          }
          removeLayer(d) {
            return this.style.removeLayer(d), this._update(!0)
          }
          getLayer(d) {
            return this.style.getLayer(d)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(d, e, o) {
            return this.style.setLayerZoomRange(d, e, o), this._update(!0)
          }
          setFilter(d, e, o = {}) {
            return this.style.setFilter(d, e, o), this._update(!0)
          }
          getFilter(d) {
            return this.style.getFilter(d)
          }
          setPaintProperty(d, e, o, u = {}) {
            return this.style.setPaintProperty(d, e, o, u), this._update(!0)
          }
          getPaintProperty(d, e) {
            return this.style.getPaintProperty(d, e)
          }
          setLayoutProperty(d, e, o, u = {}) {
            return this.style.setLayoutProperty(d, e, o, u), this._update(!0)
          }
          getLayoutProperty(d, e) {
            return this.style.getLayoutProperty(d, e)
          }
          setGlyphs(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(d, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(d, e, o = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(d, e, o, (u => {
              u || this._update(!0)
            })), this
          }
          removeSprite(d) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(d), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(d, e, (o => {
              o || this._update(!0)
            })), this
          }
          setLight(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(d, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(d, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(d, e) {
            return this.style.setFeatureState(d, e), this._update()
          }
          removeFeatureState(d, e) {
            return this.style.removeFeatureState(d, e), this._update()
          }
          getFeatureState(d) {
            return this.style.getFeatureState(d)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let d = 0,
              e = 0;
            return this._container && (d = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [d, e]
          }
          _setupContainer() {
            const d = this._container;
            d.classList.add("maplibregl-map");
            const e = this._canvasContainer = G.create("div", "maplibregl-canvas-container", d);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = G.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const o = this._containerDimensions(),
              u = this._getClampedPixelRatio(o[0], o[1]);
            this._resizeCanvas(o[0], o[1], u);
            const h = this._controlContainer = G.create("div", "maplibregl-control-container", d),
              p = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g => {
              p[g] = G.create("div", `maplibregl-ctrl-${g} `, h)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(d, e, o) {
            this._canvas.width = Math.floor(o * d), this._canvas.height = Math.floor(o * e), this._canvas.style.width = `${d}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const d = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (u => {
              e = {
                requestedAttributes: d
              }, u && (e.statusMessage = u.statusMessage, e.type = u.type)
            }), {
              once: !0
            });
            let o = null;
            if (o = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, d) : this._canvas.getContext("webgl2", d) || this._canvas.getContext("webgl", d), !o) {
              const u = "Failed to initialize WebGL";
              throw e ? (e.message = u, new Error(JSON.stringify(e))) : new Error(u)
            }
            this.painter = new sh(o, this.transform), yt.testSupport(o)
          }
          migrateProjection(d, e) {
            super.migrateProjection(d, e), this.painter.transform = d, this.fire(new c.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(d) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(d) {
            return this._update(), this._renderTaskQueue.add(d)
          }
          _cancelRenderFrame(d) {
            this._renderTaskQueue.remove(d)
          }
          _render(d) {
            var e, o, u, h, p;
            const g = this._idleTriggered ? this._fadeDuration : 0,
              x = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(d), this._removed) return;
            let T = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const F = this.transform.zoom,
                L = lt();
              this.style.zoomHistory.update(F, L);
              const V = new c.G(F, {
                  now: L,
                  fadeDuration: g,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition()
                }),
                K = V.crossFadingFactor();
              K === 1 && K === this._crossFadingFactor || (T = !0, this._crossFadingFactor = K), this.style.update(V)
            }
            const I = ((o = this.style.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0 !== x;
            (u = this.style.projection) === null || u === void 0 || u.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((h = this.style.projection) === null || h === void 0 ? void 0 : h.transitionState, (p = this.style.projection) === null || p === void 0 ? void 0 : p.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || I) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, I), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: g,
              showPadding: this.showPadding
            }), this.fire(new c.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.cz.mark(c.cA.load), this.fire(new c.l("load"))), this.style && (this.style.hasTransitions() || T) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const A = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return A || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.l("idle")), !this._loaded || this._fullyLoaded || A || (this._fullyLoaded = !0, c.cz.mark(c.cA.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var d;
            this._hash && this._hash.remove();
            for (const o of this._controls) o.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Zt.removeThrottleControl(this._imageQueueHandle), (d = this._resizeObserver) === null || d === void 0 || d.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), G.remove(this._canvasContainer), G.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), c.cz.clearMetrics(), this._removed = !0, this.fire(new c.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, ut.frame(this._frameRequest, (d => {
              c.cz.frame(d), this._frameRequest = null;
              try {
                this._render(d)
              } catch (e) {
                if (!c.cB(e) && !(function(o) {
                    return o.message === J_
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(d) {
            this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(d) {
            this._showPadding !== d && (this._showPadding = d, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(d) {
            this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, d ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(d) {
            this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(d) {
            this._repaint !== d && (this._repaint = d, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(d) {
            this._vertices = d, this._update()
          }
          get version() {
            return Mh
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(d) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(d), this._update(!0)
          }
        }, k.MapMouseEvent = mo, k.MapTouchEvent = uo, k.MapWheelEvent = hh, k.Marker = ou, k.NavigationControl = class {
          constructor(d) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                o = e === this._map.getMaxZoom(),
                u = e === this._map.getMinZoom();
              this._zoomInButton.disabled = o, this._zoomOutButton.disabled = u, this._zoomInButton.setAttribute("aria-disabled", o.toString()), this._zoomOutButton.setAttribute("aria-disabled", u.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, o) => {
              const u = this._map._getUIString(`NavigationControl.${o}`);
              e.title = u, e.setAttribute("aria-label", u)
            }, this.options = c.e({}, Wu, d), this._container = G.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), G.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), G.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = G.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(d) {
            return this._map = d, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new yl(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            G.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(d, e) {
            const o = G.create("button", d, this._container);
            return o.type = "button", o.addEventListener("click", e), o
          }
        }, k.Popup = class extends c.E {
          constructor(d) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && G.remove(this._content), this._container && (G.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = G.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = G.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const g of this.options.className.split(" ")) this._container.classList.add(g);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = $u(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const o = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let u = this.options.anchor;
              const h = Ju(this.options.offset);
              if (!u) {
                const g = this._container.offsetWidth,
                  x = this._container.offsetHeight;
                let T;
                T = o.y + h.bottom.y < x ? ["top"] : o.y > this._map.transform.height - x ? ["bottom"] : [], o.x < g / 2 ? T.push("left") : o.x > this._map.transform.width - g / 2 && T.push("right"), u = T.length === 0 ? "bottom" : T.join("-")
              }
              let p = o.add(h[u]);
              this.options.subpixelPositioning || (p = p.round()), G.setTransform(this._container, `${Xs[u]} translate(${p.x}px,${p.y}px)`), Xu(this._container, u, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = c.e(Object.create(xl), d)
          }
          addTo(d) {
            return this._map && this.remove(), this._map = d, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(d) {
            return this._lngLat = c.U.convert(d), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(d) {
            return this.setDOMContent(document.createTextNode(d))
          }
          setHTML(d) {
            const e = document.createDocumentFragment(),
              o = document.createElement("body");
            let u;
            for (o.innerHTML = d; u = o.firstChild, u;) e.appendChild(u);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var d;
            return (d = this._container) === null || d === void 0 ? void 0 : d.style.maxWidth
          }
          setMaxWidth(d) {
            return this.options.maxWidth = d, this._update(), this
          }
          setDOMContent(d) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = G.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(d), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(d) {
            return this._container && this._container.classList.add(d), this
          }
          removeClassName(d) {
            return this._container && this._container.classList.remove(d), this
          }
          setOffset(d) {
            return this.options.offset = d, this._update(), this
          }
          toggleClassName(d) {
            if (this._container) return this._container.classList.toggle(d)
          }
          setSubpixelPositioning(d) {
            this.options.subpixelPositioning = d
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = G.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const d = this._container.querySelector(Ku);
            d && d.focus()
          }
        }, k.RasterDEMTileSource = zr, k.RasterTileSource = de, k.ScaleControl = class {
          constructor(d) {
            this._onMove = () => {
              Yu(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, Yu(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, bl), d)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(d) {
            return this._map = d, this._container = G.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", d.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            G.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, k.ScrollZoomHandler = wh, k.Style = Ua, k.TerrainControl = class {
          constructor(d) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = d
          }
          onAdd(d) {
            return this._map = d, this._container = G.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = G.create("button", "maplibregl-ctrl-terrain", this._container), G.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            G.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, k.TwoFingersTouchPitchHandler = vh, k.TwoFingersTouchRotateHandler = Gu, k.TwoFingersTouchZoomHandler = yh, k.TwoFingersTouchZoomRotateHandler = Th, k.VectorTileSource = or, k.VideoSource = Or, k.addSourceType = (d, e) => c._(void 0, void 0, void 0, (function*() {
          if (_n(d)) throw new Error(`A source type called "${d}" already exists.`);
          ((o, u) => {
            Lr[o] = u
          })(d, e)
        })), k.clearPrewarmedResources = function() {
          const d = Ye;
          d && (d.isPreloaded() && d.numActive() === 1 ? (d.release(Ae), Ye = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, k.createTileMesh = Jo, k.getMaxParallelImageRequests = function() {
          return c.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, k.getRTLTextPluginStatus = function() {
          return U().getRTLTextPluginStatus()
        }, k.getVersion = function() {
          return wl
        }, k.getWorkerCount = function() {
          return He.workerCount
        }, k.getWorkerUrl = function() {
          return c.a.WORKER_URL
        }, k.importScriptInWorkers = function(d) {
          return ur().broadcast("IS", d)
        }, k.isTimeFrozen = function() {
          return xt.isFrozen()
        }, k.now = lt, k.prewarm = function() {
          se().acquire(Ae)
        }, k.restoreNow = function() {
          xt.restoreNow()
        }, k.setMaxParallelImageRequests = function(d) {
          c.a.MAX_PARALLEL_IMAGE_REQUESTS = d
        }, k.setNow = function(d) {
          xt.setNow(d)
        }, k.setRTLTextPlugin = function(d, e) {
          return U().setRTLTextPlugin(d, e)
        }, k.setWorkerCount = function(d) {
          He.workerCount = d
        }, k.setWorkerUrl = function(d) {
          c.a.WORKER_URL = d
        }
      }));
      var E = t;
      return E
    }))
  })(od)), od.exports
}
var U0e = V0e();
const Yh = q0e(U0e);
class yy {
  constructor(s) {
    dn(this, "gm");
    dn(this, "markers", new Map);
    dn(this, "canvases", new Map);
    dn(this, "canvasSize");
    dn(this, "canvasOpacity", .8);
    this.input = s, this.gm = new Bo(this.input.tileSize);
    const t = Sv(s.img);
    this.canvasSize = Math.ceil(2e3 / t)
  }
  place([s, t]) {
    const w = this.gm.latLonToPixelsFloor(s, t, this.input.zoom),
      z = this.getMarkerId(w),
      E = this.gm.latLonToPixelBoundsLatLon(s, t, this.input.zoom),
      k = this.input.map;
    if (this.input.markerFn && !this.markers.has(z)) {
      const tt = this.input.markerFn();
      tt.setLngLat({
        lat: E.min[0],
        lng: (E.max[1] + E.min[1]) / 2
      }).addTo(k), this.markers.set(z, tt)
    }
    const {
      key: c,
      pos: R,
      innerPos: X
    } = this.getCanvasPos(w);
    let $ = this.canvases.get(c);
    if (!$) {
      const tt = this.canvasSize,
        ut = R.x * tt,
        xt = R.y * tt,
        lt = ut + tt - 1,
        G = xt + tt - 1,
        yt = this.gm.pixelsToLatLon(ut, G + 1, this.input.zoom),
        Lt = this.gm.pixelsToLatLon(lt + 1, xt, this.input.zoom);
      $ = new Z0e({
        id: `${this.input.id}-${c}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: rm({
          min: yt,
          max: Lt
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), $.addTo(this.input.map), this.canvases.set(c, $)
    }
    $.place(X.x, X.y)
  }
  clear() {
    const s = this.input.map;
    for (const t of this.canvases.values()) t.removeFrom(s), t.removeDOM();
    this.canvases.clear();
    for (const t of this.markers.values()) t.remove();
    this.markers.clear()
  }
  clearAndPlace(s) {
    this.clear(), this.place(s)
  }
  remove([s, t]) {
    let w = !1;
    const z = this.gm.latLonToPixelsFloor(s, t, this.input.zoom),
      {
        key: E,
        innerPos: k
      } = this.getCanvasPos(z),
      c = this.canvases.get(E);
    c && (w = c.remove(k.x, k.y), c.annotationsCount() === 0 && (this.canvases.delete(E), c.removeFrom(this.input.map), c.removeDOM()));
    const R = this.getMarkerId(z),
      X = this.markers.get(R);
    return X == null || X.remove(), this.markers.delete(R), w
  }
  setCanvasOpacity(s) {
    this.canvasOpacity = s;
    for (const t of this.canvases.values()) t.setOpacity(s)
  }
  getMarkerId([s, t]) {
    return `${this.input.id}:${s},${t}`
  }
  getCanvasPos([s, t]) {
    const w = {
        x: Math.floor(s / this.canvasSize),
        y: Math.floor(t / this.canvasSize)
      },
      z = {
        x: s % this.canvasSize,
        y: t % this.canvasSize
      },
      E = `${w.x},${w.y}`;
    return {
      pos: w,
      innerPos: z,
      key: E
    }
  }
}
class Z0e {
  constructor(s) {
    dn(this, "annotations", new Set);
    dn(this, "canvas");
    dn(this, "imgSize");
    dn(this, "maps", new Set);
    dn(this, "pendingRepaint", !1);
    this.input = s, this.imgSize = Sv(s.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(s, t) {
    const w = this.getPixelKey(s, t);
    if (this.annotations.has(w)) return !1;
    const z = this.canvas.getContext("2d");
    if (z) {
      const E = s * this.imgSize,
        k = t * this.imgSize;
      z.drawImage(this.input.img, E, k)
    }
    return this.annotations.add(w), this.triggerRepaint(), !0
  }
  remove(s, t) {
    const w = this.getPixelKey(s, t);
    if (!this.annotations.has(w)) return !1;
    const z = this.canvas.getContext("2d");
    if (z) {
      const E = s * this.imgSize,
        k = t * this.imgSize;
      z.clearRect(E, k, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(w), this.triggerRepaint(), !0
  }
  addTo(s) {
    const t = this.input.id;
    s.getSource(t) || s.addSource(t, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates,
      animate: !1
    }), s.getLayer(t) || s.addLayer({
      id: t,
      type: "raster",
      source: t,
      paint: this.input.layerPaint
    }), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: t
    } = this.input;
    s.getLayer(t) && s.removeLayer(t), s.getSource(t) && s.removeSource(t), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(s) {
    for (const t of this.maps.values()) t.setPaintProperty(this.input.id, "raster-opacity", s)
  }
  getPixelKey(s, t) {
    return `${s},${t}`
  }
  triggerRepaint() {
    this.pendingRepaint || (this.pendingRepaint = !0, requestAnimationFrame(() => {
      for (const s of this.maps.values()) {
        const t = s.getSource(this.input.id);
        t.play(), s.once("render", () => {
          t.pause(), this.pendingRepaint = !1
        })
      }
    }))
  }
}

function Sv(l) {
  return Math.max(l.naturalWidth, l.naturalHeight)
}

function G0e() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function H0e(l) {
  const s = {
      opaque: !0
    },
    t = l.searchParams.get("lat"),
    w = l.searchParams.get("lng");
  t && w && (s.pos = {
    lat: parseFloat(t),
    lng: parseFloat(w)
  });
  const z = l.searchParams.get("zoom");
  z && (s.zoom = parseFloat(z));
  const E = l.searchParams.get("season");
  E && (s.season = parseInt(E));
  const k = l.searchParams.get("opaque");
  return k && (s.opaque = k !== "0"), l.searchParams.get("select") && (s.select = !0), l.searchParams.get("twitch-migration") && (s.twitchMigration = !0), s.newUser = !!l.searchParams.get("new-user"), s.discordLinked = !!l.searchParams.get("discord-linked"), s.alliance = !!l.searchParams.get("alliance"), s
}

function W0e(l, s) {
  return l = new URL(l), s.pos !== void 0 && (l.searchParams.set("lat", s.pos.lat.toString()), l.searchParams.set("lng", s.pos.lng.toString())), s.zoom !== void 0 && l.searchParams.set("zoom", s.zoom.toString()), s.season !== void 0 && l.searchParams.set("season", s.season.toString()), s.opaque !== void 0 && l.searchParams.set("opaque", s.opaque ? "1" : "0"), s.newUser !== void 0 && l.searchParams.set("new-user", s.newUser ? "1" : "0"), s.alliance !== void 0 && l.searchParams.set("alliance", s.alliance ? "1" : "0"), s.select && l.searchParams.set("alliance", "1"), l
}
var of = function() {
  return of = Object.assign || function(s) {
    for (var t, w = 1, z = arguments.length; w < z; w++) {
      t = arguments[w];
      for (var E in t) Object.prototype.hasOwnProperty.call(t, E) && (s[E] = t[E])
    }
    return s
  }, of.apply(this, arguments)
};

function Ds(l, s, t, w) {
  function z(E) {
    return E instanceof t ? E : new t(function(k) {
      k(E)
    })
  }
  return new(t || (t = Promise))(function(E, k) {
    function c($) {
      try {
        X(w.next($))
      } catch (tt) {
        k(tt)
      }
    }

    function R($) {
      try {
        X(w.throw($))
      } catch (tt) {
        k(tt)
      }
    }

    function X($) {
      $.done ? E($.value) : z($.value).then(c, R)
    }
    X((w = w.apply(l, s || [])).next())
  })
}

function Rs(l, s) {
  var t = {
      label: 0,
      sent: function() {
        if (E[0] & 1) throw E[1];
        return E[1]
      },
      trys: [],
      ops: []
    },
    w, z, E, k = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return k.next = c(0), k.throw = c(1), k.return = c(2), typeof Symbol == "function" && (k[Symbol.iterator] = function() {
    return this
  }), k;

  function c(X) {
    return function($) {
      return R([X, $])
    }
  }

  function R(X) {
    if (w) throw new TypeError("Generator is already executing.");
    for (; k && (k = 0, X[0] && (t = 0)), t;) try {
      if (w = 1, z && (E = X[0] & 2 ? z.return : X[0] ? z.throw || ((E = z.return) && E.call(z), 0) : z.next) && !(E = E.call(z, X[1])).done) return E;
      switch (z = 0, E && (X = [X[0] & 2, E.value]), X[0]) {
        case 0:
        case 1:
          E = X;
          break;
        case 4:
          return t.label++, {
            value: X[1],
            done: !1
          };
        case 5:
          t.label++, z = X[1], X = [0];
          continue;
        case 7:
          X = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (E = t.trys, !(E = E.length > 0 && E[E.length - 1]) && (X[0] === 6 || X[0] === 2)) {
            t = 0;
            continue
          }
          if (X[0] === 3 && (!E || X[1] > E[0] && X[1] < E[3])) {
            t.label = X[1];
            break
          }
          if (X[0] === 6 && t.label < E[1]) {
            t.label = E[1], E = X;
            break
          }
          if (E && t.label < E[2]) {
            t.label = E[2], t.ops.push(X);
            break
          }
          E[2] && t.ops.pop(), t.trys.pop();
          continue
      }
      X = s.call(l, t)
    } catch ($) {
      X = [6, $], z = 0
    } finally {
      w = E = 0
    }
    if (X[0] & 5) throw X[1];
    return {
      value: X[0] ? X[1] : void 0,
      done: !0
    }
  }
}

function Pv(l, s, t) {
  if (t || arguments.length === 2)
    for (var w = 0, z = s.length, E; w < z; w++)(E || !(w in s)) && (E || (E = Array.prototype.slice.call(s, 0, w)), E[w] = s[w]);
  return l.concat(E || Array.prototype.slice.call(s))
}
var Mv = "4.6.2";

function gd(l, s) {
  return new Promise(function(t) {
    return setTimeout(t, l, s)
  })
}

function $0e() {
  return new Promise(function(l) {
    var s = new MessageChannel;
    s.port1.onmessage = function() {
      return l()
    }, s.port2.postMessage(null)
  })
}

function X0e(l, s) {
  s === void 0 && (s = 1 / 0);
  var t = window.requestIdleCallback;
  return t ? new Promise(function(w) {
    return t.call(window, function() {
      return w()
    }, {
      timeout: s
    })
  }) : gd(Math.min(l, s))
}

function Cv(l) {
  return !!l && typeof l.then == "function"
}

function vy(l, s) {
  try {
    var t = l();
    Cv(t) ? t.then(function(w) {
      return s(!0, w)
    }, function(w) {
      return s(!1, w)
    }) : s(!0, t)
  } catch (w) {
    s(!1, w)
  }
}

function by(l, s, t) {
  return t === void 0 && (t = 16), Ds(this, void 0, void 0, function() {
    var w, z, E, k;
    return Rs(this, function(c) {
      switch (c.label) {
        case 0:
          w = Array(l.length), z = Date.now(), E = 0, c.label = 1;
        case 1:
          return E < l.length ? (w[E] = s(l[E], E), k = Date.now(), k >= z + t ? (z = k, [4, $0e()]) : [3, 3]) : [3, 4];
        case 2:
          c.sent(), c.label = 3;
        case 3:
          return ++E, [3, 1];
        case 4:
          return [2, w]
      }
    })
  })
}

function $l(l) {
  return l.then(void 0, function() {}), l
}

function Y0e(l, s) {
  for (var t = 0, w = l.length; t < w; ++t)
    if (l[t] === s) return !0;
  return !1
}

function K0e(l, s) {
  return !Y0e(l, s)
}

function im(l) {
  return parseInt(l)
}

function bs(l) {
  return parseFloat(l)
}

function aa(l, s) {
  return typeof l == "number" && isNaN(l) ? s : l
}

function Eo(l) {
  return l.reduce(function(s, t) {
    return s + (t ? 1 : 0)
  }, 0)
}

function Iv(l, s) {
  if (s === void 0 && (s = 1), Math.abs(s) >= 1) return Math.round(l / s) * s;
  var t = 1 / s;
  return Math.round(l * t) / t
}

function J0e(l) {
  for (var s, t, w = "Unexpected syntax '".concat(l, "'"), z = /^\s*([a-z-]*)(.*)$/i.exec(l), E = z[1] || void 0, k = {}, c = /([.:#][\w-]+|\[.+?\])/gi, R = function(ut, xt) {
      k[ut] = k[ut] || [], k[ut].push(xt)
    };;) {
    var X = c.exec(z[2]);
    if (!X) break;
    var $ = X[0];
    switch ($[0]) {
      case ".":
        R("class", $.slice(1));
        break;
      case "#":
        R("id", $.slice(1));
        break;
      case "[": {
        var tt = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec($);
        if (tt) R(tt[1], (t = (s = tt[4]) !== null && s !== void 0 ? s : tt[5]) !== null && t !== void 0 ? t : "");
        else throw new Error(w);
        break
      }
      default:
        throw new Error(w)
    }
  }
  return [E, k]
}

function Q0e(l) {
  for (var s = new Uint8Array(l.length), t = 0; t < l.length; t++) {
    var w = l.charCodeAt(t);
    if (w > 127) return new TextEncoder().encode(l);
    s[t] = w
  }
  return s
}

function Da(l, s) {
  var t = l[0] >>> 16,
    w = l[0] & 65535,
    z = l[1] >>> 16,
    E = l[1] & 65535,
    k = s[0] >>> 16,
    c = s[0] & 65535,
    R = s[1] >>> 16,
    X = s[1] & 65535,
    $ = 0,
    tt = 0,
    ut = 0,
    xt = 0;
  xt += E + X, ut += xt >>> 16, xt &= 65535, ut += z + R, tt += ut >>> 16, ut &= 65535, tt += w + c, $ += tt >>> 16, tt &= 65535, $ += t + k, $ &= 65535, l[0] = $ << 16 | tt, l[1] = ut << 16 | xt
}

function ns(l, s) {
  var t = l[0] >>> 16,
    w = l[0] & 65535,
    z = l[1] >>> 16,
    E = l[1] & 65535,
    k = s[0] >>> 16,
    c = s[0] & 65535,
    R = s[1] >>> 16,
    X = s[1] & 65535,
    $ = 0,
    tt = 0,
    ut = 0,
    xt = 0;
  xt += E * X, ut += xt >>> 16, xt &= 65535, ut += z * X, tt += ut >>> 16, ut &= 65535, ut += E * R, tt += ut >>> 16, ut &= 65535, tt += w * X, $ += tt >>> 16, tt &= 65535, tt += z * R, $ += tt >>> 16, tt &= 65535, tt += E * c, $ += tt >>> 16, tt &= 65535, $ += t * X + w * R + z * c + E * k, $ &= 65535, l[0] = $ << 16 | tt, l[1] = ut << 16 | xt
}

function gc(l, s) {
  var t = l[0];
  s %= 64, s === 32 ? (l[0] = l[1], l[1] = t) : s < 32 ? (l[0] = t << s | l[1] >>> 32 - s, l[1] = l[1] << s | t >>> 32 - s) : (s -= 32, l[0] = l[1] << s | t >>> 32 - s, l[1] = t << s | l[1] >>> 32 - s)
}

function Xo(l, s) {
  s %= 64, s !== 0 && (s < 32 ? (l[0] = l[1] >>> 32 - s, l[1] = l[1] << s) : (l[0] = l[1] << s - 32, l[1] = 0))
}

function wi(l, s) {
  l[0] ^= s[0], l[1] ^= s[1]
}
var tbe = [4283543511, 3981806797],
  ebe = [3301882366, 444984403];

function xy(l) {
  var s = [0, l[0] >>> 1];
  wi(l, s), ns(l, tbe), s[1] = l[0] >>> 1, wi(l, s), ns(l, ebe), s[1] = l[0] >>> 1, wi(l, s)
}
var Kh = [2277735313, 289559509],
  Jh = [1291169091, 658871167],
  wy = [0, 5],
  rbe = [0, 1390208809],
  nbe = [0, 944331445];

function ibe(l, s) {
  var t = Q0e(l);
  s = s || 0;
  var w = [0, t.length],
    z = w[1] % 16,
    E = w[1] - z,
    k = [0, s],
    c = [0, s],
    R = [0, 0],
    X = [0, 0],
    $;
  for ($ = 0; $ < E; $ = $ + 16) R[0] = t[$ + 4] | t[$ + 5] << 8 | t[$ + 6] << 16 | t[$ + 7] << 24, R[1] = t[$] | t[$ + 1] << 8 | t[$ + 2] << 16 | t[$ + 3] << 24, X[0] = t[$ + 12] | t[$ + 13] << 8 | t[$ + 14] << 16 | t[$ + 15] << 24, X[1] = t[$ + 8] | t[$ + 9] << 8 | t[$ + 10] << 16 | t[$ + 11] << 24, ns(R, Kh), gc(R, 31), ns(R, Jh), wi(k, R), gc(k, 27), Da(k, c), ns(k, wy), Da(k, rbe), ns(X, Jh), gc(X, 33), ns(X, Kh), wi(c, X), gc(c, 31), Da(c, k), ns(c, wy), Da(c, nbe);
  R[0] = 0, R[1] = 0, X[0] = 0, X[1] = 0;
  var tt = [0, 0];
  switch (z) {
    case 15:
      tt[1] = t[$ + 14], Xo(tt, 48), wi(X, tt);
    case 14:
      tt[1] = t[$ + 13], Xo(tt, 40), wi(X, tt);
    case 13:
      tt[1] = t[$ + 12], Xo(tt, 32), wi(X, tt);
    case 12:
      tt[1] = t[$ + 11], Xo(tt, 24), wi(X, tt);
    case 11:
      tt[1] = t[$ + 10], Xo(tt, 16), wi(X, tt);
    case 10:
      tt[1] = t[$ + 9], Xo(tt, 8), wi(X, tt);
    case 9:
      tt[1] = t[$ + 8], wi(X, tt), ns(X, Jh), gc(X, 33), ns(X, Kh), wi(c, X);
    case 8:
      tt[1] = t[$ + 7], Xo(tt, 56), wi(R, tt);
    case 7:
      tt[1] = t[$ + 6], Xo(tt, 48), wi(R, tt);
    case 6:
      tt[1] = t[$ + 5], Xo(tt, 40), wi(R, tt);
    case 5:
      tt[1] = t[$ + 4], Xo(tt, 32), wi(R, tt);
    case 4:
      tt[1] = t[$ + 3], Xo(tt, 24), wi(R, tt);
    case 3:
      tt[1] = t[$ + 2], Xo(tt, 16), wi(R, tt);
    case 2:
      tt[1] = t[$ + 1], Xo(tt, 8), wi(R, tt);
    case 1:
      tt[1] = t[$], wi(R, tt), ns(R, Kh), gc(R, 31), ns(R, Jh), wi(k, R)
  }
  return wi(k, w), wi(c, w), Da(k, c), Da(c, k), xy(k), xy(c), Da(k, c), Da(c, k), ("00000000" + (k[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (k[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (c[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (c[1] >>> 0).toString(16)).slice(-8)
}

function obe(l) {
  var s;
  return of({
    name: l.name,
    message: l.message,
    stack: (s = l.stack) === null || s === void 0 ? void 0 : s.split(`
`)
  }, l)
}

function sbe(l) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(l))
}

function abe(l) {
  return typeof l != "function"
}

function ube(l, s) {
  var t = $l(new Promise(function(w) {
    var z = Date.now();
    vy(l.bind(null, s), function() {
      for (var E = [], k = 0; k < arguments.length; k++) E[k] = arguments[k];
      var c = Date.now() - z;
      if (!E[0]) return w(function() {
        return {
          error: E[1],
          duration: c
        }
      });
      var R = E[1];
      if (abe(R)) return w(function() {
        return {
          value: R,
          duration: c
        }
      });
      w(function() {
        return new Promise(function(X) {
          var $ = Date.now();
          vy(R, function() {
            for (var tt = [], ut = 0; ut < arguments.length; ut++) tt[ut] = arguments[ut];
            var xt = c + Date.now() - $;
            if (!tt[0]) return X({
              error: tt[1],
              duration: xt
            });
            X({
              value: tt[1],
              duration: xt
            })
          })
        })
      })
    })
  }));
  return function() {
    return t.then(function(z) {
      return z()
    })
  }
}

function cbe(l, s, t, w) {
  var z = Object.keys(l).filter(function(k) {
      return K0e(t, k)
    }),
    E = $l(by(z, function(k) {
      return ube(l[k], s)
    }, w));
  return function() {
    return Ds(this, void 0, void 0, function() {
      var c, R, X, $, tt;
      return Rs(this, function(ut) {
        switch (ut.label) {
          case 0:
            return [4, E];
          case 1:
            return c = ut.sent(), [4, by(c, function(xt) {
              return $l(xt())
            }, w)];
          case 2:
            return R = ut.sent(), [4, Promise.all(R)];
          case 3:
            for (X = ut.sent(), $ = {}, tt = 0; tt < z.length; ++tt) $[z[tt]] = X[tt];
            return [2, $]
        }
      })
    })
  }
}

function zv() {
  var l = window,
    s = navigator;
  return Eo(["MSCSSMatrix" in l, "msSetImmediate" in l, "msIndexedDB" in l, "msMaxTouchPoints" in s, "msPointerEnabled" in s]) >= 4
}

function lbe() {
  var l = window,
    s = navigator;
  return Eo(["msWriteProfilerMark" in l, "MSStream" in l, "msLaunchUri" in s, "msSaveBlob" in s]) >= 3 && !zv()
}

function z_() {
  var l = window,
    s = navigator;
  return Eo(["webkitPersistentStorage" in s, "webkitTemporaryStorage" in s, (s.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in l, "BatteryManager" in l, "webkitMediaStream" in l, "webkitSpeechGrammar" in l]) >= 5
}

function ks() {
  var l = window,
    s = navigator;
  return Eo(["ApplePayError" in l, "CSSPrimitiveValue" in l, "Counter" in l, s.vendor.indexOf("Apple") === 0, "RGBColor" in l, "WebKitMediaKeys" in l]) >= 4
}

function om() {
  var l = window,
    s = l.HTMLElement,
    t = l.Document;
  return Eo(["safari" in l, !("ongestureend" in l), !("TouchEvent" in l), !("orientation" in l), s && !("autocapitalize" in s.prototype), t && "pointerLockElement" in t.prototype]) >= 4
}

function A_() {
  var l = window;
  return sbe(l.print) && String(l.browser) === "[object WebPageNamespace]"
}

function Av() {
  var l, s, t = window;
  return Eo(["buildID" in navigator, "MozAppearance" in ((s = (l = document.documentElement) === null || l === void 0 ? void 0 : l.style) !== null && s !== void 0 ? s : {}), "onmozfullscreenchange" in t, "mozInnerScreenX" in t, "CSSMozDocumentRule" in t, "CanvasCaptureMediaStream" in t]) >= 4
}

function _be() {
  var l = window;
  return Eo([!("MediaSettingsRange" in l), "RTCEncodedAudioFrame" in l, "" + l.Intl == "[object Intl]", "" + l.Reflect == "[object Reflect]"]) >= 3
}

function hbe() {
  var l = window,
    s = l.URLPattern;
  return Eo(["union" in Set.prototype, "Iterator" in l, s && "hasRegExpGroups" in s.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function dbe() {
  var l = window;
  return Eo(["DOMRectList" in l, "RTCPeerConnectionIceEvent" in l, "SVGGeometryElement" in l, "ontransitioncancel" in l]) >= 3
}

function E_() {
  var l = window,
    s = navigator,
    t = l.CSS,
    w = l.HTMLButtonElement;
  return Eo([!("getStorageUpdates" in s), w && "popover" in w.prototype, "CSSCounterStyleRule" in l, t.supports("font-size-adjust: ex-height 0.5"), t.supports("text-transform: full-width")]) >= 4
}

function pbe() {
  if (navigator.platform === "iPad") return !0;
  var l = screen,
    s = l.width / l.height;
  return Eo(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, s > .65 && s < 1.53]) >= 2
}

function fbe() {
  var l = document;
  return l.fullscreenElement || l.msFullscreenElement || l.mozFullScreenElement || l.webkitFullscreenElement || null
}

function mbe() {
  var l = document;
  return (l.exitFullscreen || l.msExitFullscreen || l.mozCancelFullScreen || l.webkitExitFullscreen).call(l)
}

function sm() {
  var l = z_(),
    s = Av(),
    t = window,
    w = navigator,
    z = "connection";
  return l ? Eo([!("SharedWorker" in t), w[z] && "ontypechange" in w[z], !("sinkId" in new Audio)]) >= 2 : s ? Eo(["onorientationchange" in t, "orientation" in t, /android/i.test(w.appVersion)]) >= 2 : !1
}

function gbe() {
  var l = navigator,
    s = window,
    t = Audio.prototype,
    w = s.visualViewport;
  return Eo(["srLatency" in t, "srChannelCount" in t, "devicePosture" in l, w && "segments" in w, "getTextInformation" in Image.prototype]) >= 3
}

function ybe() {
  return xbe() ? -4 : vbe()
}

function vbe() {
  var l = window,
    s = l.OfflineAudioContext || l.webkitOfflineAudioContext;
  if (!s) return -2;
  if (bbe()) return -1;
  var t = 4500,
    w = 5e3,
    z = new s(1, w, 44100),
    E = z.createOscillator();
  E.type = "triangle", E.frequency.value = 1e4;
  var k = z.createDynamicsCompressor();
  k.threshold.value = -50, k.knee.value = 40, k.ratio.value = 12, k.attack.value = 0, k.release.value = .25, E.connect(k), k.connect(z.destination), E.start(0);
  var c = wbe(z),
    R = c[0],
    X = c[1],
    $ = $l(R.then(function(tt) {
      return kbe(tt.getChannelData(0).subarray(t))
    }, function(tt) {
      if (tt.name === "timeout" || tt.name === "suspended") return -3;
      throw tt
    }));
  return function() {
    return X(), $
  }
}

function bbe() {
  return ks() && !om() && !dbe()
}

function xbe() {
  return ks() && E_() && A_() || z_() && gbe() && hbe()
}

function wbe(l) {
  var s = 3,
    t = 500,
    w = 500,
    z = 5e3,
    E = function() {},
    k = new Promise(function(c, R) {
      var X = !1,
        $ = 0,
        tt = 0;
      l.oncomplete = function(lt) {
        return c(lt.renderedBuffer)
      };
      var ut = function() {
          setTimeout(function() {
            return R(ky("timeout"))
          }, Math.min(w, tt + z - Date.now()))
        },
        xt = function() {
          try {
            var lt = l.startRendering();
            switch (Cv(lt) && $l(lt), l.state) {
              case "running":
                tt = Date.now(), X && ut();
                break;
              case "suspended":
                document.hidden || $++, X && $ >= s ? R(ky("suspended")) : setTimeout(xt, t);
                break
            }
          } catch (G) {
            R(G)
          }
        };
      xt(), E = function() {
        X || (X = !0, tt > 0 && ut())
      }
    });
  return [k, E]
}

function kbe(l) {
  for (var s = 0, t = 0; t < l.length; ++t) s += Math.abs(l[t]);
  return s
}

function ky(l) {
  var s = new Error(l);
  return s.name = l, s
}

function Ev(l, s, t) {
  var w, z, E;
  return t === void 0 && (t = 50), Ds(this, void 0, void 0, function() {
    var k, c;
    return Rs(this, function(R) {
      switch (R.label) {
        case 0:
          k = document, R.label = 1;
        case 1:
          return k.body ? [3, 3] : [4, gd(t)];
        case 2:
          return R.sent(), [3, 1];
        case 3:
          c = k.createElement("iframe"), R.label = 4;
        case 4:
          return R.trys.push([4, , 10, 11]), [4, new Promise(function(X, $) {
            var tt = !1,
              ut = function() {
                tt = !0, X()
              },
              xt = function(yt) {
                tt = !0, $(yt)
              };
            c.onload = ut, c.onerror = xt;
            var lt = c.style;
            lt.setProperty("display", "block", "important"), lt.position = "absolute", lt.top = "0", lt.left = "0", lt.visibility = "hidden", s && "srcdoc" in c ? c.srcdoc = s : c.src = "about:blank", k.body.appendChild(c);
            var G = function() {
              var yt, Lt;
              tt || (((Lt = (yt = c.contentWindow) === null || yt === void 0 ? void 0 : yt.document) === null || Lt === void 0 ? void 0 : Lt.readyState) === "complete" ? ut() : setTimeout(G, 10))
            };
            G()
          })];
        case 5:
          R.sent(), R.label = 6;
        case 6:
          return !((z = (w = c.contentWindow) === null || w === void 0 ? void 0 : w.document) === null || z === void 0) && z.body ? [3, 8] : [4, gd(t)];
        case 7:
          return R.sent(), [3, 6];
        case 8:
          return [4, l(c, c.contentWindow)];
        case 9:
          return [2, R.sent()];
        case 10:
          return (E = c.parentNode) === null || E === void 0 || E.removeChild(c), [7];
        case 11:
          return [2]
      }
    })
  })
}

function Tbe(l) {
  for (var s = J0e(l), t = s[0], w = s[1], z = document.createElement(t ?? "div"), E = 0, k = Object.keys(w); E < k.length; E++) {
    var c = k[E],
      R = w[c].join(" ");
    c === "style" ? Sbe(z.style, R) : z.setAttribute(c, R)
  }
  return z
}

function Sbe(l, s) {
  for (var t = 0, w = s.split(";"); t < w.length; t++) {
    var z = w[t],
      E = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(z);
    if (E) {
      var k = E[1],
        c = E[2],
        R = E[4];
      l.setProperty(k, c, R || "")
    }
  }
}

function Pbe() {
  for (var l = window;;) {
    var s = l.parent;
    if (!s || s === l) return !1;
    try {
      if (s.location.origin !== l.location.origin) return !0
    } catch (t) {
      if (t instanceof Error && t.name === "SecurityError") return !0;
      throw t
    }
    l = s
  }
}
var Mbe = "mmMwWLliI0O&1",
  Cbe = "48px",
  yc = ["monospace", "sans-serif", "serif"],
  Ty = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function Ibe() {
  var l = this;
  return Ev(function(s, t) {
    var w = t.document;
    return Ds(l, void 0, void 0, function() {
      var z, E, k, c, R, X, $, tt, ut, xt, lt, G;
      return Rs(this, function(yt) {
        for (z = w.body, z.style.fontSize = Cbe, E = w.createElement("div"), E.style.setProperty("visibility", "hidden", "important"), k = {}, c = {}, R = function(Lt) {
            var Dt = w.createElement("span"),
              St = Dt.style;
            return St.position = "absolute", St.top = "0", St.left = "0", St.fontFamily = Lt, Dt.textContent = Mbe, E.appendChild(Dt), Dt
          }, X = function(Lt, Dt) {
            return R("'".concat(Lt, "',").concat(Dt))
          }, $ = function() {
            return yc.map(R)
          }, tt = function() {
            for (var Lt = {}, Dt = function(Zt) {
                Lt[Zt] = yc.map(function(Et) {
                  return X(Zt, Et)
                })
              }, St = 0, qt = Ty; St < qt.length; St++) {
              var Vt = qt[St];
              Dt(Vt)
            }
            return Lt
          }, ut = function(Lt) {
            return yc.some(function(Dt, St) {
              return Lt[St].offsetWidth !== k[Dt] || Lt[St].offsetHeight !== c[Dt]
            })
          }, xt = $(), lt = tt(), z.appendChild(E), G = 0; G < yc.length; G++) k[yc[G]] = xt[G].offsetWidth, c[yc[G]] = xt[G].offsetHeight;
        return [2, Ty.filter(function(Lt) {
          return ut(lt[Lt])
        })]
      })
    })
  })
}

function zbe() {
  var l = navigator.plugins;
  if (l) {
    for (var s = [], t = 0; t < l.length; ++t) {
      var w = l[t];
      if (w) {
        for (var z = [], E = 0; E < w.length; ++E) {
          var k = w[E];
          z.push({
            type: k.type,
            suffixes: k.suffixes
          })
        }
        s.push({
          name: w.name,
          description: w.description,
          mimeTypes: z
        })
      }
    }
    return s
  }
}

function Abe() {
  return Ebe(Obe())
}

function Ebe(l) {
  var s, t = !1,
    w, z, E = jbe(),
    k = E[0],
    c = E[1];
  return Lbe(k, c) ? (t = Dbe(c), l ? w = z = "skipped" : (s = Rbe(k, c), w = s[0], z = s[1])) : w = z = "unsupported", {
    winding: t,
    geometry: w,
    text: z
  }
}

function jbe() {
  var l = document.createElement("canvas");
  return l.width = 1, l.height = 1, [l, l.getContext("2d")]
}

function Lbe(l, s) {
  return !!(s && l.toDataURL)
}

function Dbe(l) {
  return l.rect(0, 0, 10, 10), l.rect(2, 2, 6, 6), !l.isPointInPath(5, 5, "evenodd")
}

function Rbe(l, s) {
  Bbe(l, s);
  var t = Np(l),
    w = Np(l);
  if (t !== w) return ["unstable", "unstable"];
  Fbe(l, s);
  var z = Np(l);
  return [z, t]
}

function Bbe(l, s) {
  l.width = 240, l.height = 60, s.textBaseline = "alphabetic", s.fillStyle = "#f60", s.fillRect(100, 1, 62, 20), s.fillStyle = "#069", s.font = '11pt "Times New Roman"';
  var t = "Cwm fjordbank gly ".concat("ğŸ˜ƒ");
  s.fillText(t, 2, 15), s.fillStyle = "rgba(102, 204, 0, 0.2)", s.font = "18pt Arial", s.fillText(t, 4, 45)
}

function Fbe(l, s) {
  l.width = 122, l.height = 110, s.globalCompositeOperation = "multiply";
  for (var t = 0, w = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; t < w.length; t++) {
    var z = w[t],
      E = z[0],
      k = z[1],
      c = z[2];
    s.fillStyle = E, s.beginPath(), s.arc(k, c, 40, 0, Math.PI * 2, !0), s.closePath(), s.fill()
  }
  s.fillStyle = "#f9c", s.arc(60, 60, 60, 0, Math.PI * 2, !0), s.arc(60, 60, 20, 0, Math.PI * 2, !0), s.fill("evenodd")
}

function Np(l) {
  return l.toDataURL()
}

function Obe() {
  return ks() && E_() && A_()
}

function qbe() {
  var l = navigator,
    s = 0,
    t;
  l.maxTouchPoints !== void 0 ? s = im(l.maxTouchPoints) : l.msMaxTouchPoints !== void 0 && (s = l.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), t = !0
  } catch {
    t = !1
  }
  var w = "ontouchstart" in window;
  return {
    maxTouchPoints: s,
    touchEvent: t,
    touchStart: w
  }
}

function Nbe() {
  return navigator.oscpu
}

function Vbe() {
  var l = navigator,
    s = [],
    t = l.language || l.userLanguage || l.browserLanguage || l.systemLanguage;
  if (t !== void 0 && s.push([t]), Array.isArray(l.languages)) z_() && _be() || s.push(l.languages);
  else if (typeof l.languages == "string") {
    var w = l.languages;
    w && s.push(w.split(","))
  }
  return s
}

function Ube() {
  return window.screen.colorDepth
}

function Zbe() {
  return aa(bs(navigator.deviceMemory), void 0)
}

function Gbe() {
  if (!(ks() && E_() && A_())) return Hbe()
}

function Hbe() {
  var l = screen,
    s = function(w) {
      return aa(im(w), null)
    },
    t = [s(l.width), s(l.height)];
  return t.sort().reverse(), t
}
var Wbe = 2500,
  $be = 10,
  sd, Vp;

function Xbe() {
  if (Vp === void 0) {
    var l = function() {
      var s = sf();
      af(s) ? Vp = setTimeout(l, Wbe) : (sd = s, Vp = void 0)
    };
    l()
  }
}

function Ybe() {
  var l = this;
  return Xbe(),
    function() {
      return Ds(l, void 0, void 0, function() {
        var s;
        return Rs(this, function(t) {
          switch (t.label) {
            case 0:
              return s = sf(), af(s) ? sd ? [2, Pv([], sd, !0)] : fbe() ? [4, mbe()] : [3, 2] : [3, 2];
            case 1:
              t.sent(), s = sf(), t.label = 2;
            case 2:
              return af(s) || (sd = s), [2, s]
          }
        })
      })
    }
}

function Kbe() {
  var l = this;
  if (ks() && E_() && A_()) return function() {
    return Promise.resolve(void 0)
  };
  var s = Ybe();
  return function() {
    return Ds(l, void 0, void 0, function() {
      var t, w;
      return Rs(this, function(z) {
        switch (z.label) {
          case 0:
            return [4, s()];
          case 1:
            return t = z.sent(), w = function(E) {
              return E === null ? null : Iv(E, $be)
            }, [2, [w(t[0]), w(t[1]), w(t[2]), w(t[3])]]
        }
      })
    })
  }
}

function sf() {
  var l = screen;
  return [aa(bs(l.availTop), null), aa(bs(l.width) - bs(l.availWidth) - aa(bs(l.availLeft), 0), null), aa(bs(l.height) - bs(l.availHeight) - aa(bs(l.availTop), 0), null), aa(bs(l.availLeft), null)]
}

function af(l) {
  for (var s = 0; s < 4; ++s)
    if (l[s]) return !1;
  return !0
}

function Jbe() {
  return aa(im(navigator.hardwareConcurrency), void 0)
}

function Qbe() {
  var l, s = (l = window.Intl) === null || l === void 0 ? void 0 : l.DateTimeFormat;
  if (s) {
    var t = new s().resolvedOptions().timeZone;
    if (t) return t
  }
  var w = -txe();
  return "UTC".concat(w >= 0 ? "+" : "").concat(w)
}

function txe() {
  var l = new Date().getFullYear();
  return Math.max(bs(new Date(l, 0, 1).getTimezoneOffset()), bs(new Date(l, 6, 1).getTimezoneOffset()))
}

function exe() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function rxe() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function nxe() {
  if (!(zv() || lbe())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function ixe() {
  return !!window.openDatabase
}

function oxe() {
  return navigator.cpuClass
}

function sxe() {
  var l = navigator.platform;
  return l === "MacIntel" && ks() && !om() ? pbe() ? "iPad" : "iPhone" : l
}

function axe() {
  return navigator.vendor || ""
}

function uxe() {
  for (var l = [], s = 0, t = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; s < t.length; s++) {
    var w = t[s],
      z = window[w];
    z && typeof z == "object" && l.push(w)
  }
  return l.sort()
}

function cxe() {
  var l = document;
  try {
    l.cookie = "cookietest=1; SameSite=Strict;";
    var s = l.cookie.indexOf("cookietest=") !== -1;
    return l.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", s
  } catch {
    return !1
  }
}

function lxe() {
  var l = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', l("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", l("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", l("LnNwb25zb3JpdA=="), ".ylamainos", l("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), l("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", l("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", l("LmhlYWRlci1ibG9ja2VkLWFk"), l("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", l("I2FkXzMwMFgyNTA="), l("I2Jhbm5lcmZsb2F0MjI="), l("I2NhbXBhaWduLWJhbm5lcg=="), l("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [l("LlppX2FkX2FfSA=="), l("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", l("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), l("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", l("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", l("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", l("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), l("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), l("LmFkZ29vZ2xl"), l("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [l("YW1wLWF1dG8tYWRz"), l("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", l("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [l("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), l("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', l("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [l("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), l("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", l("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), l("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), l("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", l("I3Jla2xhbWk="), l("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), l("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), l("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [l("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", l("LndpZGdldF9wb19hZHNfd2lkZ2V0"), l("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", l("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [l("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), l("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", l("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", l("I3Jla2xhbW5pLWJveA=="), l("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", l("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [l("I2FkdmVydGVudGll"), l("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", l("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", l("LnNwb25zb3JsaW5rZ3J1ZW4="), l("I3dlcmJ1bmdza3k="), l("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), l("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [l("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", l("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), l("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), l("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [l("LnJla2xhbW9zX3RhcnBhcw=="), l("LnJla2xhbW9zX251b3JvZG9z"), l("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), l("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), l("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [l("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [l("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), l("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", l("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [l("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), l("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), l("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", l("LmFkX19tYWlu"), l("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [l("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [l("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), l("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [l("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), l("I2xpdmVyZUFkV3JhcHBlcg=="), l("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), l("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [l("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", l("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), l("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), l("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [l("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), l("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), l("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", l("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), l("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), l("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), l("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [l("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), l("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), l("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), l("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [l("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), l("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), l("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", l("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), l("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", l("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function _xe(l) {
  var s = l === void 0 ? {} : l,
    t = s.debug;
  return Ds(this, void 0, void 0, function() {
    var w, z, E, k, c, R;
    return Rs(this, function(X) {
      switch (X.label) {
        case 0:
          return hxe() ? (w = lxe(), z = Object.keys(w), E = (R = []).concat.apply(R, z.map(function($) {
            return w[$]
          })), [4, dxe(E)]) : [2, void 0];
        case 1:
          return k = X.sent(), t && pxe(w, k), c = z.filter(function($) {
            var tt = w[$],
              ut = Eo(tt.map(function(xt) {
                return k[xt]
              }));
            return ut > tt.length * .6
          }), c.sort(), [2, c]
      }
    })
  })
}

function hxe() {
  return ks() || sm()
}

function dxe(l) {
  var s;
  return Ds(this, void 0, void 0, function() {
    var t, w, z, E, R, k, c, R;
    return Rs(this, function(X) {
      switch (X.label) {
        case 0:
          for (t = document, w = t.createElement("div"), z = new Array(l.length), E = {}, Sy(w), R = 0; R < l.length; ++R) k = Tbe(l[R]), k.tagName === "DIALOG" && k.show(), c = t.createElement("div"), Sy(c), c.appendChild(k), w.appendChild(c), z[R] = k;
          X.label = 1;
        case 1:
          return t.body ? [3, 3] : [4, gd(50)];
        case 2:
          return X.sent(), [3, 1];
        case 3:
          t.body.appendChild(w);
          try {
            for (R = 0; R < l.length; ++R) z[R].offsetParent || (E[l[R]] = !0)
          } finally {
            (s = w.parentNode) === null || s === void 0 || s.removeChild(w)
          }
          return [2, E]
      }
    })
  })
}

function Sy(l) {
  l.style.setProperty("visibility", "hidden", "important"), l.style.setProperty("display", "block", "important")
}

function pxe(l, s) {
  for (var t = "DOM blockers debug:\n```", w = 0, z = Object.keys(l); w < z.length; w++) {
    var E = z[w];
    t += `
`.concat(E, ":");
    for (var k = 0, c = l[E]; k < c.length; k++) {
      var R = c[k];
      t += `
  `.concat(s[R] ? "ğŸš«" : "â¡ï¸", " ").concat(R)
    }
  }
  console.log("".concat(t, "\n```"))
}

function fxe() {
  for (var l = 0, s = ["rec2020", "p3", "srgb"]; l < s.length; l++) {
    var t = s[l];
    if (matchMedia("(color-gamut: ".concat(t, ")")).matches) return t
  }
}

function mxe() {
  if (Py("inverted")) return !0;
  if (Py("none")) return !1
}

function Py(l) {
  return matchMedia("(inverted-colors: ".concat(l, ")")).matches
}

function gxe() {
  if (My("active")) return !0;
  if (My("none")) return !1
}

function My(l) {
  return matchMedia("(forced-colors: ".concat(l, ")")).matches
}
var yxe = 100;

function vxe() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var l = 0; l <= yxe; ++l)
      if (matchMedia("(max-monochrome: ".concat(l, ")")).matches) return l;
    throw new Error("Too high value")
  }
}

function bxe() {
  if (vc("no-preference")) return 0;
  if (vc("high") || vc("more")) return 1;
  if (vc("low") || vc("less")) return -1;
  if (vc("forced")) return 10
}

function vc(l) {
  return matchMedia("(prefers-contrast: ".concat(l, ")")).matches
}

function xxe() {
  if (Cy("reduce")) return !0;
  if (Cy("no-preference")) return !1
}

function Cy(l) {
  return matchMedia("(prefers-reduced-motion: ".concat(l, ")")).matches
}

function wxe() {
  if (Iy("reduce")) return !0;
  if (Iy("no-preference")) return !1
}

function Iy(l) {
  return matchMedia("(prefers-reduced-transparency: ".concat(l, ")")).matches
}

function kxe() {
  if (zy("high")) return !0;
  if (zy("standard")) return !1
}

function zy(l) {
  return matchMedia("(dynamic-range: ".concat(l, ")")).matches
}
var Qn = Math,
  Co = function() {
    return 0
  };

function Txe() {
  var l = Qn.acos || Co,
    s = Qn.acosh || Co,
    t = Qn.asin || Co,
    w = Qn.asinh || Co,
    z = Qn.atanh || Co,
    E = Qn.atan || Co,
    k = Qn.sin || Co,
    c = Qn.sinh || Co,
    R = Qn.cos || Co,
    X = Qn.cosh || Co,
    $ = Qn.tan || Co,
    tt = Qn.tanh || Co,
    ut = Qn.exp || Co,
    xt = Qn.expm1 || Co,
    lt = Qn.log1p || Co,
    G = function(Ct) {
      return Qn.pow(Qn.PI, Ct)
    },
    yt = function(Ct) {
      return Qn.log(Ct + Qn.sqrt(Ct * Ct - 1))
    },
    Lt = function(Ct) {
      return Qn.log(Ct + Qn.sqrt(Ct * Ct + 1))
    },
    Dt = function(Ct) {
      return Qn.log((1 + Ct) / (1 - Ct)) / 2
    },
    St = function(Ct) {
      return Qn.exp(Ct) - 1 / Qn.exp(Ct) / 2
    },
    qt = function(Ct) {
      return (Qn.exp(Ct) + 1 / Qn.exp(Ct)) / 2
    },
    Vt = function(Ct) {
      return Qn.exp(Ct) - 1
    },
    Zt = function(Ct) {
      return (Qn.exp(2 * Ct) - 1) / (Qn.exp(2 * Ct) + 1)
    },
    Et = function(Ct) {
      return Qn.log(1 + Ct)
    };
  return {
    acos: l(.12312423423423424),
    acosh: s(1e308),
    acoshPf: yt(1e154),
    asin: t(.12312423423423424),
    asinh: w(1),
    asinhPf: Lt(1),
    atanh: z(.5),
    atanhPf: Dt(.5),
    atan: E(.5),
    sin: k(-1e300),
    sinh: c(1),
    sinhPf: St(1),
    cos: R(10.000000000123),
    cosh: X(1),
    coshPf: qt(1),
    tan: $(-1e300),
    tanh: tt(1),
    tanhPf: Zt(1),
    exp: ut(1),
    expm1: xt(1),
    expm1Pf: Vt(1),
    log1p: lt(10),
    log1pPf: Et(10),
    powPI: G(-100)
  }
}
var Sxe = "mmMwWLliI0fiflO&1",
  Up = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function Pxe() {
  return Mxe(function(l, s) {
    for (var t = {}, w = {}, z = 0, E = Object.keys(Up); z < E.length; z++) {
      var k = E[z],
        c = Up[k],
        R = c[0],
        X = R === void 0 ? {} : R,
        $ = c[1],
        tt = $ === void 0 ? Sxe : $,
        ut = l.createElement("span");
      ut.textContent = tt, ut.style.whiteSpace = "nowrap";
      for (var xt = 0, lt = Object.keys(X); xt < lt.length; xt++) {
        var G = lt[xt],
          yt = X[G];
        yt !== void 0 && (ut.style[G] = yt)
      }
      t[k] = ut, s.append(l.createElement("br"), ut)
    }
    for (var Lt = 0, Dt = Object.keys(Up); Lt < Dt.length; Lt++) {
      var k = Dt[Lt];
      w[k] = t[k].getBoundingClientRect().width
    }
    return w
  })
}

function Mxe(l, s) {
  return s === void 0 && (s = 4e3), Ev(function(t, w) {
    var z = w.document,
      E = z.body,
      k = E.style;
    k.width = "".concat(s, "px"), k.webkitTextSizeAdjust = k.textSizeAdjust = "none", z_() ? E.style.zoom = "".concat(1 / w.devicePixelRatio) : ks() && (E.style.zoom = "reset");
    var c = z.createElement("div");
    return c.textContent = Pv([], Array(s / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), E.appendChild(c), l(z, E)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function Cxe() {
  return navigator.pdfViewerEnabled
}

function Ixe() {
  var l = new Float32Array(1),
    s = new Uint8Array(l.buffer);
  return l[0] = 1 / 0, l[0] = l[0] - l[0], s[3]
}

function zxe() {
  var l = window.ApplePaySession;
  if (typeof(l == null ? void 0 : l.canMakePayments) != "function") return -1;
  if (Axe()) return -3;
  try {
    return l.canMakePayments() ? 1 : 0
  } catch (s) {
    return Exe(s)
  }
}
var Axe = Pbe;

function Exe(l) {
  if (l instanceof Error && l.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(l.message)) return -2;
  throw l
}

function jxe() {
  var l, s = document.createElement("a"),
    t = (l = s.attributionSourceId) !== null && l !== void 0 ? l : s.attributionsourceid;
  return t === void 0 ? void 0 : String(t)
}
var jv = -1,
  Lv = -2,
  Lxe = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  Dxe = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  Rxe = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  Bxe = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  Dv = "WEBGL_debug_renderer_info",
  Fxe = "WEBGL_polygon_mode";

function Oxe(l) {
  var s, t, w, z, E, k, c = l.cache,
    R = Rv(c);
  if (!R) return jv;
  if (!Fv(R)) return Lv;
  var X = Bv() ? null : R.getExtension(Dv);
  return {
    version: ((s = R.getParameter(R.VERSION)) === null || s === void 0 ? void 0 : s.toString()) || "",
    vendor: ((t = R.getParameter(R.VENDOR)) === null || t === void 0 ? void 0 : t.toString()) || "",
    vendorUnmasked: X ? (w = R.getParameter(X.UNMASKED_VENDOR_WEBGL)) === null || w === void 0 ? void 0 : w.toString() : "",
    renderer: ((z = R.getParameter(R.RENDERER)) === null || z === void 0 ? void 0 : z.toString()) || "",
    rendererUnmasked: X ? (E = R.getParameter(X.UNMASKED_RENDERER_WEBGL)) === null || E === void 0 ? void 0 : E.toString() : "",
    shadingLanguageVersion: ((k = R.getParameter(R.SHADING_LANGUAGE_VERSION)) === null || k === void 0 ? void 0 : k.toString()) || ""
  }
}

function qxe(l) {
  var s = l.cache,
    t = Rv(s);
  if (!t) return jv;
  if (!Fv(t)) return Lv;
  var w = t.getSupportedExtensions(),
    z = t.getContextAttributes(),
    E = [],
    k = [],
    c = [],
    R = [],
    X = [];
  if (z)
    for (var $ = 0, tt = Object.keys(z); $ < tt.length; $++) {
      var ut = tt[$];
      k.push("".concat(ut, "=").concat(z[ut]))
    }
  for (var xt = Ay(t), lt = 0, G = xt; lt < G.length; lt++) {
    var yt = G[lt],
      Lt = t[yt];
    c.push("".concat(yt, "=").concat(Lt).concat(Lxe.has(Lt) ? "=".concat(t.getParameter(Lt)) : ""))
  }
  if (w)
    for (var Dt = 0, St = w; Dt < St.length; Dt++) {
      var qt = St[Dt];
      if (!(qt === Dv && Bv() || qt === Fxe && Uxe())) {
        var Vt = t.getExtension(qt);
        if (!Vt) {
          E.push(qt);
          continue
        }
        for (var Zt = 0, Et = Ay(Vt); Zt < Et.length; Zt++) {
          var yt = Et[Zt],
            Lt = Vt[yt];
          R.push("".concat(yt, "=").concat(Lt).concat(Dxe.has(Lt) ? "=".concat(t.getParameter(Lt)) : ""))
        }
      }
    }
  for (var Ct = 0, Wt = Rxe; Ct < Wt.length; Ct++)
    for (var jt = Wt[Ct], Ht = 0, _e = Bxe; Ht < _e.length; Ht++) {
      var Ut = _e[Ht],
        Xt = Nxe(t, jt, Ut);
      X.push("".concat(jt, ".").concat(Ut, "=").concat(Xt.join(",")))
    }
  return R.sort(), c.sort(), {
    contextAttributes: k,
    parameters: c,
    shaderPrecisions: X,
    extensions: w,
    extensionParameters: R,
    unsupportedExtensions: E
  }
}

function Rv(l) {
  if (l.webgl) return l.webgl.context;
  var s = document.createElement("canvas"),
    t;
  s.addEventListener("webglCreateContextError", function() {
    return t = void 0
  });
  for (var w = 0, z = ["webgl", "experimental-webgl"]; w < z.length; w++) {
    var E = z[w];
    try {
      t = s.getContext(E)
    } catch {}
    if (t) break
  }
  return l.webgl = {
    context: t
  }, t
}

function Nxe(l, s, t) {
  var w = l.getShaderPrecisionFormat(l[s], l[t]);
  return w ? [w.rangeMin, w.rangeMax, w.precision] : []
}

function Ay(l) {
  var s = Object.keys(l.__proto__);
  return s.filter(Vxe)
}

function Vxe(l) {
  return typeof l == "string" && !l.match(/[^A-Z0-9_x]/)
}

function Bv() {
  return Av()
}

function Uxe() {
  return z_() || ks()
}

function Fv(l) {
  return typeof l.getParameter == "function"
}

function Zxe() {
  var l = sm() || ks();
  if (!l) return -2;
  if (!window.AudioContext) return -1;
  var s = new AudioContext().baseLatency;
  return s == null ? -1 : isFinite(s) ? s : -3
}

function Gxe() {
  if (!window.Intl) return -1;
  var l = window.Intl.DateTimeFormat;
  if (!l) return -2;
  var s = l().resolvedOptions().locale;
  return !s && s !== "" ? -3 : s
}
var Hxe = {
  fonts: Ibe,
  domBlockers: _xe,
  fontPreferences: Pxe,
  audio: ybe,
  screenFrame: Kbe,
  canvas: Abe,
  osCpu: Nbe,
  languages: Vbe,
  colorDepth: Ube,
  deviceMemory: Zbe,
  screenResolution: Gbe,
  hardwareConcurrency: Jbe,
  timezone: Qbe,
  sessionStorage: exe,
  localStorage: rxe,
  indexedDB: nxe,
  openDatabase: ixe,
  cpuClass: oxe,
  platform: sxe,
  plugins: zbe,
  touchSupport: qbe,
  vendor: axe,
  vendorFlavors: uxe,
  cookiesEnabled: cxe,
  colorGamut: fxe,
  invertedColors: mxe,
  forcedColors: gxe,
  monochrome: vxe,
  contrast: bxe,
  reducedMotion: xxe,
  reducedTransparency: wxe,
  hdr: kxe,
  math: Txe,
  pdfViewerEnabled: Cxe,
  architecture: Ixe,
  applePay: zxe,
  privateClickMeasurement: jxe,
  audioBaseLatency: Zxe,
  dateTimeLocale: Gxe,
  webGlBasics: Oxe,
  webGlExtensions: qxe
};

function Wxe(l) {
  return cbe(Hxe, l, [])
}
var $xe = "$ if upgrade to Pro: https://fpjs.dev/pro";

function Xxe(l) {
  var s = Yxe(l),
    t = Kxe(s);
  return {
    score: s,
    comment: $xe.replace(/\$/g, "".concat(t))
  }
}

function Yxe(l) {
  if (sm()) return .4;
  if (ks()) return om() && !(E_() && A_()) ? .5 : .3;
  var s = "value" in l.platform ? l.platform.value : "";
  return /^Win/.test(s) ? .6 : /^Mac/.test(s) ? .5 : .7
}

function Kxe(l) {
  return Iv(.99 + .01 * l, 1e-4)
}

function Jxe(l) {
  for (var s = "", t = 0, w = Object.keys(l).sort(); t < w.length; t++) {
    var z = w[t],
      E = l[z],
      k = "error" in E ? "error" : JSON.stringify(E.value);
    s += "".concat(s ? "|" : "").concat(z.replace(/([:|\\])/g, "\\$1"), ":").concat(k)
  }
  return s
}

function Ov(l) {
  return JSON.stringify(l, function(s, t) {
    return t instanceof Error ? obe(t) : t
  }, 2)
}

function qv(l) {
  return ibe(Jxe(l))
}

function Qxe(l) {
  var s, t = Xxe(l);
  return {
    get visitorId() {
      return s === void 0 && (s = qv(this.components)), s
    },
    set visitorId(w) {
      s = w
    },
    confidence: t,
    components: l,
    version: Mv
  }
}

function t1e(l) {
  return l === void 0 && (l = 50), X0e(l, l * 2)
}

function e1e(l, s) {
  var t = Date.now();
  return {
    get: function(w) {
      return Ds(this, void 0, void 0, function() {
        var z, E, k;
        return Rs(this, function(c) {
          switch (c.label) {
            case 0:
              return z = Date.now(), [4, l()];
            case 1:
              return E = c.sent(), k = Qxe(E), (s || w != null && w.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(k.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(z - t, `
visitorId: `).concat(k.visitorId, `
components: `).concat(Ov(E), "\n```")), [2, k]
          }
        })
      })
    }
  }
}

function r1e() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var l = new XMLHttpRequest;
    l.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(Mv, "/npm-monitoring"), !0), l.send()
  } catch (s) {
    console.error(s)
  }
}

function n1e(l) {
  var s;
  return l === void 0 && (l = {}), Ds(this, void 0, void 0, function() {
    var t, w, z;
    return Rs(this, function(E) {
      switch (E.label) {
        case 0:
          return (!((s = l.monitoring) !== null && s !== void 0) || s) && r1e(), t = l.delayFallback, w = l.debug, [4, t1e(t)];
        case 1:
          return E.sent(), z = Wxe({
            cache: {},
            debug: w
          }), [2, e1e(z, w)]
      }
    })
  })
}
var i1e = {
  load: n1e,
  hashComponents: qv,
  componentsToDebugString: Ov
};
let Zp = null;
async function o1e() {
  return Zp || (Zp = i1e.load()), Zp
}
async function am() {
  return (await (await o1e()).get()).visitorId
}
var s1e = $r('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function vu(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = s1e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}

function ad(l) {
  const s = document.createElement("img");
  return s.src = l, new Promise((t, w) => {
    s.addEventListener("load", () => {
      t(s)
    }), s.addEventListener("error", z => {
      w(z)
    })
  })
}

function Nv(l) {
  const s = document.createElement("canvas");
  s.width = l.naturalWidth, s.height = l.naturalHeight;
  const t = s.getContext("2d");
  return t == null || t.drawImage(l, 0, 0), s
}
var a1e = ft('<button type="button"></button>'),
  u1e = ft('<div class="overlay pointer-events-auto svelte-rxq6cp"><canvas></canvas> <div class="overlay-border svelte-rxq6cp"></div> <!></div>'),
  c1e = ft('<div><!> <p class="text-base font-medium">Drop an image or click the button below to select a file</p> <input type="file" accept="image/*" class="hidden" id="auto-paint-file"/> <label for="auto-paint-file" class="btn btn-primary btn-sm">Upload image</label></div>'),
  l1e = ft("<option> </option>"),
  _1e = ft('<span class="loading loading-spinner loading-sm"></span> Processing', 1),
  h1e = ft('<button class="btn btn-primary"><!></button>'),
  d1e = ft('<span class="loading loading-spinner loading-sm"></span> Sending', 1),
  p1e = ft('<button class="btn btn-primary"><!></button>'),
  f1e = ft('<div class="rounded-box bg-success/10 text-success px-3 py-2 text-sm"> </div>'),
  m1e = ft('<div class="mt-4 grid gap-4 md:grid-cols-2"><div class="space-y-2"><div class="rounded-box bg-base-200/60 p-3 text-sm"><p class="font-semibold"> </p> <p class="text-base-content/70"> </p></div> <div class="flex items-center gap-2"><label class="text-base-content/70 text-sm">Opacity</label> <input type="range" min="20" max="100"/></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Dithering (Floyd-Steinberg)</span></label> <p class="text-base-content/70 text-xs">Makes color transitions smoother.</p></div> <div class="space-y-1"><label class="flex flex-col gap-1 text-sm font-medium">Color metric <select class="select select-bordered select-sm w-full max-w-xs"></select></label></div></div> <div class="space-y-2 text-sm"><p class="text-base-content/70">1. Set image position by draging it.<br/> 2. Click on <strong>Generate Preview</strong> to convert the colors.<br/> 3. Confirm to paint the canvas.</p> <div class="flex flex-wrap gap-2"><button class="btn btn-sm btn-outline">Change image</button></div></div></div> <div class="mt-4 flex flex-wrap items-center gap-3"><!> <button class="btn btn-ghost">Cancelar</button> <!></div>', 1),
  g1e = ft(`<div class="pointer-events-none absolute inset-0 z-40 select-none"><!></div> <div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-2xl sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 border-t p-4 shadow-xl"><div class="flex items-center justify-between gap-2"><div><h2 class="flex items-center gap-2 text-lg font-semibold"><!> Auto Painter</h2> <p class="text-base-content/70 text-sm">Drag the image to the desired position. Use the anchors to change it's size.</p></div> <button class="btn btn-circle btn-sm" title="Fechar"><!></button></div> <!></div></div>`, 1);

function y1e(l, s) {
  en(s, !1);
  const t = 2e3,
    w = 256,
    z = "admin-auto-painter-opacity",
    E = "admin-auto-painter-dithering";
  let k = $e(s, "map", 8),
    c = $e(s, "tileSize", 8),
    R = $e(s, "tileZoom", 8),
    X = $e(s, "season", 8),
    $ = $e(s, "refreshPixelArt", 8),
    tt = $e(s, "onclose", 8),
    ut = ho(new Bo(c())),
    xt = ho("upload"),
    lt = ho(!1),
    G = ho(!1),
    yt = ho(!1),
    Lt = ho(null),
    Dt = ho(""),
    St = ho(null),
    qt = ho(null),
    Vt = ho(null),
    Zt = ho({
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }),
    Et = [],
    Ct = ho(null),
    Wt = ho(null),
    jt = ho(1),
    Ht = ho(!1),
    _e = ho("lab");
  const Ut = [{
    value: "lab",
    label: "Perceptual (CIELAB Î”E94)"
  }, {
    value: "compuphase",
    label: "Weighted RGB (CompuPhase)"
  }];
  let Xt = ho(!1),
    me = null;
  const Ce = ["nw", "n", "ne", "e", "se", "s", "sw", "w"],
    Ve = new Set(["nw", "ne", "se", "sw"]);

  function Ie(mt) {
    return Ve.has(mt)
  }

  function ne(mt, et, W) {
    return Math.min(Math.max(mt, et), W)
  }

  function Xe(mt) {
    const et = Math.max(mt.north, mt.south),
      W = Math.min(mt.north, mt.south),
      vt = Math.min(mt.west, mt.east),
      $t = Math.max(mt.west, mt.east);
    return {
      north: ne(et, -85, 85),
      south: ne(W, -85, 85),
      west: ne(vt, -180, 180),
      east: ne($t, -180, 180)
    }
  }

  function pe(mt) {
    Y(St, Xe(mt)), Y(lt, !1), Y(Ct, null), Et = [], Y(Zt, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), Ue(), Ae(), or()
  }

  function Ue() {
    if (!y(St)) {
      Y(Vt, null);
      return
    }
    const [mt, et] = y(ut).latLonToPixels(y(St).north, y(St).west, R()), [W, vt] = y(ut).latLonToPixels(y(St).south, y(St).east, R()), $t = Math.min(mt, W), Pt = Math.max(mt, W), Gt = Math.min(et, vt), ae = Math.max(et, vt), ye = Math.max(1, Math.ceil(Pt - $t)), Te = Math.max(1, Math.ceil(ae - Gt));
    Y(Vt, {
      px0: $t,
      py0: Gt,
      width: ye,
      height: Te
    })
  }

  function Ae() {
    if (!y(St)) {
      Y(qt, null);
      return
    }
    const mt = k().project({
        lat: y(St).north,
        lng: y(St).west
      }),
      et = k().project({
        lat: y(St).south,
        lng: y(St).east
      }),
      W = Math.min(mt.x, et.x),
      vt = Math.min(mt.y, et.y),
      $t = Math.abs(et.x - mt.x),
      Pt = Math.abs(et.y - mt.y);
    Y(qt, {
      left: W,
      top: vt,
      width: $t,
      height: Pt
    })
  }

  function He() {
    Y(xt, "upload"), Y(Lt, null), Y(Dt, ""), Y(St, null), Y(Vt, null), Y(qt, null), Y(lt, !1), Et = [], Y(Ct, null), Y(Zt, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    })
  }

  function Tr() {
    if (!y(Lt)) return;
    const mt = k().getCenter(),
      [et, W] = y(ut).latLonToPixels(mt.lat, mt.lng, R()),
      vt = Math.min(1, w / y(Lt).width),
      $t = Math.max(8, Math.round(y(Lt).width * vt)),
      Pt = Math.max(8, Math.round(y(Lt).height * vt)),
      Gt = et - $t / 2,
      ae = et + $t / 2,
      ye = W - Pt / 2,
      Te = W + Pt / 2,
      [we, be] = y(ut).pixelsToLatLon(Gt, ye, R()),
      [Ee, Qe] = y(ut).pixelsToLatLon(ae, Te, R());
    pe({
      north: we,
      south: Ee,
      west: be,
      east: Qe
    }), or()
  }
  async function Ye(mt) {
    try {
      He();
      const et = URL.createObjectURL(mt),
        W = await ad(et);
      URL.revokeObjectURL(et), Y(Lt, Nv(W)), Y(Dt, mt.name), Y(xt, "place"), Tr()
    } catch (et) {
      console.error(et), Ne.error("Failed to load image. Try again.")
    }
  }

  function mr(mt) {
    var vt;
    const et = mt.target,
      W = (vt = et.files) == null ? void 0 : vt[0];
    W && Ye(W), et.value = ""
  }

  function se(mt) {
    mt.preventDefault(), Y(Xt, !0)
  }

  function ce(mt) {
    mt.preventDefault(), Y(Xt, !1)
  }

  function ur(mt) {
    var W, vt;
    mt.preventDefault(), Y(Xt, !1);
    const et = (vt = (W = mt.dataTransfer) == null ? void 0 : W.files) == null ? void 0 : vt[0];
    et && Ye(et)
  }

  function Ke(mt) {
    const et = k().getCanvas().getBoundingClientRect(),
      W = [mt.clientX - et.left, mt.clientY - et.top],
      vt = k().unproject(W);
    return {
      lat: vt.lat,
      lon: vt.lng
    }
  }

  function ve(mt, et, W) {
    if (!y(Lt)) return et;
    const vt = y(Lt).width / Math.max(y(Lt).height, 1);
    if (!isFinite(vt) || vt <= 0) return et;
    const $t = mt.includes("n") ? W.south : W.north,
      Pt = mt.includes("w") ? W.east : W.west,
      Gt = mt.includes("n") ? et.north : et.south,
      ae = mt.includes("w") ? et.west : et.east,
      [ye, Te] = y(ut).latLonToPixels($t, Pt, R()),
      [we, be] = y(ut).latLonToPixels(Gt, ae, R());
    let Ee = we - ye,
      Qe = be - Te,
      Yt = Math.sign(Ee) || (mt.includes("w") ? -1 : 1),
      je = Math.sign(Qe) || (mt.includes("n") ? -1 : 1),
      Fe = Math.abs(Ee),
      Nr = Math.abs(Qe);
    if (Fe === 0 && Nr === 0) return et;
    const Ar = Nr * vt,
      Kt = Fe / vt;
    Ar > Fe ? Fe = Ar : Nr = Kt;
    const Oe = ye + Yt * Fe,
      Be = Te + je * Nr,
      [fe, Me] = y(ut).pixelsToLatLon(Oe, Be, R());
    return mt.includes("n") ? et.north = fe : et.south = fe, mt.includes("w") ? et.west = Me : et.east = Me, et
  }

  function _r(mt) {
    if (!y(St)) return;
    mt.preventDefault();
    const {
      lat: et,
      lon: W
    } = Ke(mt);
    me = {
      type: "move",
      startLat: et,
      startLon: W,
      startBounds: {
        ...y(St)
      }
    }, gr()
  }

  function nr(mt, et) {
    y(St) && (mt.preventDefault(), mt.stopPropagation(), me = {
      type: "resize",
      handle: et,
      startBounds: {
        ...y(St)
      }
    }, gr())
  }

  function gr() {
    k().dragPan.disable(), window.addEventListener("pointermove", Ze), window.addEventListener("pointerup", ir)
  }

  function ir() {
    window.removeEventListener("pointermove", Ze), window.removeEventListener("pointerup", ir), k().dragPan.enable(), me = null
  }

  function Ze(mt) {
    if (!me || !me.startBounds) return;
    const {
      startBounds: et
    } = me;
    if (me.type === "move") {
      const {
        lat: Gt,
        lon: ae
      } = Ke(mt), ye = Gt - me.startLat, Te = ae - me.startLon;
      pe({
        north: et.north + ye,
        south: et.south + ye,
        west: et.west + Te,
        east: et.east + Te
      });
      return
    }
    const {
      handle: W
    } = me, {
      lat: vt,
      lon: $t
    } = Ke(mt);
    let Pt = {
      ...et
    };
    W.includes("n") && (Pt.north = vt), W.includes("s") && (Pt.south = vt), W.includes("w") && (Pt.west = $t), W.includes("e") && (Pt.east = $t), Ie(W) && (Pt = ve(W, Pt, et)), pe(Pt)
  }

  function or() {
    if (!y(Wt) || !y(Vt) || !y(Lt) || y(lt)) return;
    de().drawImage(y(Lt), 0, 0, y(Vt).width, y(Vt).height)
  }

  function de() {
    if (!y(Wt) || !y(Vt)) throw new Error("Canvas not ready");
    oy(Wt, y(Wt).width = y(Vt).width), oy(Wt, y(Wt).height = y(Vt).height);
    const mt = y(Wt).getContext("2d", {
      willReadFrequently: !0
    });
    if (!mt) throw new Error("Canvas context not available");
    return mt.imageSmoothingEnabled = !1, mt.clearRect(0, 0, y(Wt).width, y(Wt).height), mt
  }

  function zr() {
    if (!y(Wt) || !y(Vt) || !y(Ct) || !y(lt)) return;
    de().putImageData(y(Ct), 0, 0)
  }
  async function er() {
    if (!(!y(Vt) || !y(Lt))) {
      if (y(Vt).width > t || y(Vt).height > t) {
        Ne.error(`The selected area is too big (${y(Vt).width}Ã—${y(Vt).height}).`);
        return
      }
      Y(G, !0);
      try {
        const mt = hr();
        if (!mt || mt.pixels.length === 0) {
          Ne.error("Faile to convert into valid game_pixels");
          return
        }
        Y(Ct, mt.imageData), Et = mt.pixels, Y(Zt, mt.stats), Y(lt, !0), zr()
      } catch (mt) {
        console.error(mt), Ne.error("Failed to generate preview.")
      } finally {
        Y(G, !1)
      }
    }
  }

  function hr() {
    if (!y(Vt) || !y(Lt)) return;
    const mt = document.createElement("canvas");
    mt.width = y(Vt).width, mt.height = y(Vt).height;
    const et = mt.getContext("2d", {
      willReadFrequently: !0
    });
    if (!et) throw new Error("Context is null.");
    et.imageSmoothingEnabled = !1, et.drawImage(y(Lt), 0, 0, y(Vt).width, y(Vt).height);
    const W = y(Vt).width,
      vt = y(Vt).height,
      $t = et.getImageData(0, 0, W, vt),
      Pt = $t.data,
      Gt = [],
      ae = new Set,
      ye = y(Ht);
    let Te = null,
      we = null;
    if (ye) {
      const be = W * 3;
      Te = new Float32Array(be), we = new Float32Array(be)
    }
    for (let be = 0; be < vt; be++) {
      if (ye && Te && we) {
        const Ee = Te;
        Te = we, we = Ee, we.fill(0)
      }
      for (let Ee = 0; Ee < W; Ee++) {
        const Qe = (be * W + Ee) * 4;
        if (Pt[Qe + 3] < 16) {
          Pt[Qe + 3] = 0;
          continue
        }
        let je = Pt[Qe],
          Fe = Pt[Qe + 1],
          Nr = Pt[Qe + 2];
        if (ye && Te) {
          const qr = Ee * 3;
          je = ne(Math.round(je + Te[qr]), 0, 255), Fe = ne(Math.round(Fe + Te[qr + 1]), 0, 255), Nr = ne(Math.round(Nr + Te[qr + 2]), 0, 255)
        }
        const Ar = tv({
            r: je,
            g: Fe,
            b: Nr
          }, y(_e)),
          Kt = Zf(Ar);
        if (Pt[Qe] = Kt.r, Pt[Qe + 1] = Kt.g, Pt[Qe + 2] = Kt.b, Pt[Qe + 3] = Kt.a, ye && Te && we) {
          const qr = je - Kt.r,
            lr = Fe - Kt.g,
            Jt = Nr - Kt.b,
            Se = (rr, Le, sr) => {
              rr[Le] += qr * sr, rr[Le + 1] += lr * sr, rr[Le + 2] += Jt * sr
            };
          if (Ee + 1 < W) {
            const rr = (Ee + 1) * 3;
            Se(Te, rr, 7 / 16)
          }
          if (be + 1 < vt) {
            if (Ee > 0) {
              const Le = (Ee - 1) * 3;
              Se(we, Le, 3 / 16)
            }
            const rr = Ee * 3;
            if (Se(we, rr, 5 / 16), Ee + 1 < W) {
              const Le = (Ee + 1) * 3;
              Se(we, Le, 1 / 16)
            }
          }
        }
        const Oe = y(Vt).px0 + Ee + .5,
          Be = y(Vt).py0 + be + .5,
          {
            tile: fe,
            pixel: Me
          } = y(ut).pixelsToTileLocal(Oe, Be),
          cr = {
            tile: [fe[0], fe[1]],
            pixel: [Me[0], Me[1]],
            season: X(),
            colorIdx: Ar,
            color: Kt
          },
          Ge = `${fe[0]}:${fe[1]}`;
        ae.add(Ge), Gt.push(cr)
      }
    }
    return {
      pixels: Gt,
      imageData: $t,
      stats: {
        pixels: Gt.length,
        width: W,
        height: vt,
        tiles: ae.size
      }
    }
  }
  async function Mr() {
    if (!(!y(lt) || Et.length === 0)) {
      Y(yt, !0);
      try {
        mi.droppletAndPlop.play();
        const mt = await am(),
          et = Et.map(({
            color: W,
            ...vt
          }) => vt);
        await fn.adminAutoPainterPaint(et, mt), await qf(Et), $()(), ze.refresh(), Ne.success("Art painted successfully."), Pr()
      } catch (mt) {
        console.error(mt), Ne.error(mt.message ?? "Failed to paint art.")
      } finally {
        Y(yt, !1)
      }
    }
  }

  function Pr() {
    He(), tt()()
  }

  function Or() {
    Y(lt, !1), Y(Ct, null), Et = [], Y(Zt, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), or()
  }
  ti(() => {
    const mt = () => Ae();
    return k().on("move", mt), k().on("zoom", mt), k().on("resize", mt), () => {
      k().off("move", mt), k().off("zoom", mt), k().off("resize", mt)
    }
  }), fx(() => {
    He()
  }), Fp(() => Sx(c()), () => {
    Y(ut, new Bo(c()))
  }), Fp(() => (y(Wt), y(Vt), y(Lt), y(lt), y(xt)), () => {
    y(Wt) && y(Vt) && y(Lt) && !y(lt) && y(xt) === "place" && or()
  }), Fp(() => (y(Wt), y(Vt), y(Ct), y(lt)), () => {
    y(Wt) && y(Vt) && y(Ct) && y(lt) && zr()
  }), Tx(), Uf();
  var jr = g1e();
  jn("keydown", Oa, mt => {
    mt.key === "Escape" && Pr()
  }), jn("dragover", Oa, A1(se)), jn("drop", Oa, ur), jn("dragleave", Oa, ce);
  var Lr = xe(jr),
    _n = C(Lr);
  {
    var dr = mt => {
      var et = u1e(),
        W = C(et);
      let vt;
      os(W, Gt => Y(Wt, Gt), () => y(Wt));
      var $t = D(W, 2),
        Pt = D($t, 2);
      di(Pt, 1, () => Ce, Gt => Gt, (Gt, ae) => {
        var ye = a1e();
        Bt(Te => {
          Gr(ye, 1, `handle handle-${y(ae)}`, "svelte-rxq6cp"), pr(ye, "aria-label", Te)
        }, [() => (y(ae), Io(() => `Redimensionar (${y(ae).toUpperCase()})`))]), jn("pointerdown", ye, Te => nr(Te, y(ae))), Z(Gt, ye)
      }), P(et), Bt(() => {
        _a(et, (y(qt), y(jt), Io(() => `left:${y(qt).left}px;top:${y(qt).top}px;width:${y(qt).width}px;height:${y(qt).height}px;opacity:${y(jt)};`))), vt = Gr(W, 1, "h-full w-full svelte-rxq6cp", null, vt, {
          pixelated: y(lt)
        })
      }), jn("pointerdown", W, _r), jn("pointerdown", $t, _r), Z(mt, et)
    };
    At(_n, mt => {
      y(St) && y(qt) && mt(dr)
    })
  }
  P(Lr);
  var ct = D(Lr, 2),
    q = C(ct),
    U = C(q),
    Q = C(U),
    nt = C(Q),
    _t = C(nt);
  vu(_t, {
    class: "size-5"
  }), Mn(), P(nt), Mn(2), P(Q);
  var Tt = D(Q, 2),
    Ft = C(Tt);
  pa(Ft, {
    class: "size-4"
  }), P(Tt), P(U);
  var zt = D(U, 2);
  {
    var Nt = mt => {
        var et = c1e(),
          W = C(et);
        Xx(W, {
          class: "text-base-content/70 size-10"
        });
        var vt = D(W, 4);
        Mn(2), P(et), Bt(() => Gr(et, 1, `rounded-box mt-4 flex flex-col items-center justify-center gap-3 border border-dashed p-6 text-center transition ${y(Xt)?"border-primary bg-primary/10":"border-base-300"}`, "svelte-rxq6cp")), jn("change", vt, mr), Z(mt, et)
      },
      ie = mt => {
        var et = kr(),
          W = xe(et);
        {
          var vt = $t => {
            var Pt = m1e(),
              Gt = xe(Pt),
              ae = C(Gt),
              ye = C(ae),
              Te = C(ye),
              we = C(Te, !0);
            P(Te);
            var be = D(Te, 2),
              Ee = C(be);
            P(be), P(ye);
            var Qe = D(ye, 2),
              Yt = C(Qe);
            pr(Yt, "for", z);
            var je = D(Yt, 2);
            xo(je), pr(je, "id", z), P(Qe);
            var Fe = D(Qe, 2),
              Nr = C(Fe);
            pr(Nr, "for", E);
            var Ar = C(Nr);
            xo(Ar), pr(Ar, "id", E), Mn(2), P(Nr), Mn(2), P(Fe);
            var Kt = D(Fe, 2),
              Oe = C(Kt),
              Be = D(C(Oe));
            Bt(() => {
              y(_e), Px(() => {
                y(lt)
              })
            }), di(Be, 5, () => Ut, P_, (sr, De) => {
              var Cr = l1e(),
                on = C(Cr, !0);
              P(Cr);
              var ln = {};
              Bt(() => {
                at(on, (y(De), Io(() => y(De).label))), ln !== (ln = (y(De), Io(() => y(De).value))) && (Cr.value = (Cr.__value = (y(De), Io(() => y(De).value))) ?? "")
              }), Z(sr, Cr)
            }), P(Be), P(Oe), P(Kt), P(ae);
            var fe = D(ae, 2),
              Me = D(C(fe), 2),
              cr = C(Me);
            P(Me), P(fe), P(Gt);
            var Ge = D(Gt, 2),
              qr = C(Ge);
            {
              var lr = sr => {
                  var De = h1e(),
                    Cr = C(De);
                  {
                    var on = Br => {
                        var Dr = _1e();
                        Mn(), Z(Br, Dr)
                      },
                      ln = Br => {
                        var Dr = to("Generate Preview");
                        Z(Br, Dr)
                      };
                    At(Cr, Br => {
                      y(G) ? Br(on) : Br(ln, !1)
                    })
                  }
                  P(De), Bt(() => De.disabled = y(G)), jn("click", De, er), Z(sr, De)
                },
                Jt = sr => {
                  var De = p1e(),
                    Cr = C(De);
                  {
                    var on = Br => {
                        var Dr = d1e();
                        Mn(), Z(Br, Dr)
                      },
                      ln = Br => {
                        var Dr = to("Confirm painting");
                        Z(Br, Dr)
                      };
                    At(Cr, Br => {
                      y(yt) ? Br(on) : Br(ln, !1)
                    })
                  }
                  P(De), Bt(() => De.disabled = y(yt)), jn("click", De, Mr), Z(sr, De)
                };
              At(qr, sr => {
                y(lt) ? sr(Jt, !1) : sr(lr)
              })
            }
            var Se = D(qr, 2),
              rr = D(Se, 2);
            {
              var Le = sr => {
                var De = f1e(),
                  Cr = C(De);
                P(De), Bt(on => at(Cr, `Ready to paint ${on??""} pixels.`), [() => (y(Zt), Io(() => y(Zt).pixels.toLocaleString()))]), Z(sr, De)
              };
              At(rr, sr => {
                y(lt) && sr(Le)
              })
            }
            P(Ge), Bt(() => {
              at(we, y(Dt)), at(Ee, `Target size: ${y(Vt),Io(()=>y(Vt).width)??""} Ã— ${y(Vt),Io(()=>y(Vt).height)??""} pixels`), Of(je, y(jt) * 100)
            }), jn("input", je, sr => {
              const De = sr.target;
              Y(jt, Number(De.value) / 100)
            }), Nf(Ar, () => y(Ht), sr => Y(Ht, sr)), jn("change", Ar, () => {
              y(lt) && Or()
            }), Ex(Be, () => y(_e), sr => Y(_e, sr)), jn("change", Be, () => {
              y(lt) && Or()
            }), jn("click", cr, () => Y(xt, "upload")), jn("click", Se, Pr), Z($t, Pt)
          };
          At(W, $t => {
            y(St) && y(Vt) && $t(vt)
          }, !0)
        }
        Z(mt, et)
      };
    At(zt, mt => {
      y(xt) === "upload" ? mt(Nt) : mt(ie, !1)
    })
  }
  P(q), P(ct), jn("click", Tt, Pr), Z(l, jr), rn()
}
const ud = Qi({
  shouldReload: !0
});
var v1e = ft('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function b1e(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15),
    w = ee(!1),
    z = ee(Qi(s.description)),
    E = ee(void 0);
  ti(() => {
    const Dt = St => {
      var qt;
      St.key === "Escape" && ((qt = t()) == null || qt.close())
    };
    return document.addEventListener("keydown", Dt), () => document.removeEventListener("keydown", Dt)
  });
  var k = v1e(),
    c = C(k),
    R = C(c),
    X = C(R, !0);
  P(R);
  var $ = D(R, 2),
    tt = C($),
    ut = C(tt);
  {
    let Dt = ge(() => fv());
    ev(ut, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return y(Dt)
      },
      max: 512,
      get value() {
        return y(z)
      },
      set value(St) {
        Y(z, St, !0)
      },
      get validate() {
        return y(E)
      },
      set validate(St) {
        Y(E, St, !0)
      }
    })
  }
  P(tt);
  var xt = D(tt, 2),
    lt = C(xt);
  lt.__click = () => {
    var Dt;
    (Dt = t()) == null || Dt.close()
  };
  var G = C(lt, !0);
  P(lt);
  var yt = D(lt, 2),
    Lt = C(yt, !0);
  P(yt), P(xt), P($), P(c), Mn(2), P(k), os(k, Dt => t(Dt), () => t()), Bt((Dt, St, qt) => {
    at(X, Dt), lt.disabled = y(w), at(G, St), yt.disabled = y(w), at(Lt, qt)
  }, [() => e1(), () => C_(), () => Dit()]), jn("submit", $, async () => {
    var Dt, St, qt;
    try {
      if (!((Dt = y(E)) != null && Dt())) return;
      Y(w, !0), s.description !== y(z) && await fn.updateAllianceDescription(y(z)), await ((St = s.onsuccess) == null ? void 0 : St.call(s, y(z))), (qt = t()) == null || qt.close()
    } catch (Vt) {
      Ne.error(Vt.message)
    } finally {
      Y(w, !1)
    }
  }), Z(l, k), rn()
}
ri(["click"]);
var x1e = ft('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  w1e = ft('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function k1e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(""),
    z = ee(!1);
  const E = ge(() => gi.url.origin + `/join?id=${y(w)}`);
  cn(() => {
    t() && fn.getAllianceInvites().then(Zt => {
      Y(w, Zt[0], !0)
    }).catch(Zt => {
      Ne.error(Zt.message)
    })
  }), ti(() => {
    const Zt = Et => {
      Et.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", Zt), () => document.removeEventListener("keydown", Zt)
  });
  var k = w1e(),
    c = C(k),
    R = D(C(c), 2),
    X = C(R, !0);
  P(R);
  var $ = D(R, 2),
    tt = C($, !0);
  P($);
  var ut = D($, 2),
    xt = C(ut);
  let lt;
  var G = C(xt);
  xo(G);
  var yt = D(G, 2),
    Lt = C(yt);
  let Dt;
  Lt.__click = () => {
    navigator.clipboard.writeText(y(E).toString()), Y(z, !0), setTimeout(() => {
      Y(z, !1)
    }, 1e3)
  };
  var St = C(Lt, !0);
  P(Lt), P(yt), P(xt);
  var qt = D(xt, 2);
  {
    var Vt = Zt => {
      var Et = x1e();
      Z(Zt, Et)
    };
    At(qt, Zt => {
      y(w) || Zt(Vt)
    })
  }
  P(ut), P(c), Mn(2), P(k), eo(k, () => Zt => {
    cn(() => {
      t() ? Zt.show() : Zt.close()
    })
  }), Bt((Zt, Et, Ct, Wt) => {
    at(X, Zt), at(tt, Et), lt = Gr(xt, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, lt, {
      invisible: !y(w)
    }), Of(G, Ct), Dt = Gr(Lt, 1, "btn btn-primary", null, Dt, {
      "btn-success": y(z)
    }), at(St, Wt)
  }, [() => U8(), () => NY(), () => y(E).toString(), () => y(z) ? Kf() : tf()]), jn("close", k, () => t(!1)), Z(l, k), rn()
}
ri(["click"]);
var T1e = $r('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function uf(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = T1e();
  Er(w, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...t
  })), Z(l, w)
}
var S1e = ft('<span class="text-success">(Verified)</span>'),
  P1e = ft('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  M1e = ft("<button><!></button>"),
  C1e = ft('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function j_(l, s) {
  en(s, !0);
  const t = !!s.id;
  var w = C1e(),
    z = C(w),
    E = C(z),
    k = C(E);
  P(E);
  var c = D(E, 2);
  {
    var R = ut => {
      var xt = S1e();
      Z(ut, xt)
    };
    At(c, ut => {
      t && ut(R)
    })
  }
  P(z);
  var X = D(z, 2);
  {
    var $ = ut => {
        var xt = P1e(),
          lt = C(xt);
        uf(lt, {
          class: "size-4 opacity-70"
        }), P(xt), Bt(G => pr(xt, "href", G), [() => `https://discord.com/users/${encodeURIComponent(s.id)}`]), Z(ut, xt)
      },
      tt = ut => {
        var xt = M1e();
        xt.__click = async () => {
          await navigator.clipboard.writeText(s.username), Ne.info(aot())
        };
        var lt = C(xt);
        uf(lt, {
          class: "size-4 opacity-70"
        }), P(xt), Z(ut, xt)
      };
    At(X, ut => {
      t ? ut($) : ut(tt, !1)
    })
  }
  P(w), Bt(() => at(k, `Discord: ${s.username??""}`)), Z(l, w), rn()
}
ri(["click"]);
var I1e = ft('<input type="radio" class="tab max-[380px]:px-3"/>'),
  z1e = ft('<div class="tabs tabs-border w-max font-medium"></div>');

function um(l, s) {
  en(s, !0);
  const t = [];
  let w = $e(s, "value", 15, "today"),
    z = [{
      value: "today",
      label: Id()
    }, {
      value: "week",
      label: Hot()
    }, {
      value: "month",
      label: sB()
    }, {
      value: "all-time",
      label: r2()
    }];
  var E = z1e();
  di(E, 21, () => z, k => k.value, (k, c) => {
    var R = I1e();
    xo(R);
    var X;
    Bt(() => {
      pr(R, "aria-label", y(c).label), X !== (X = y(c).value) && (R.value = (R.__value = y(c).value) ?? "")
    }), Vf(t, [], R, () => (y(c).value, w()), w), Z(k, R)
  }), P(E), Z(l, E), rn()
}
const A1e = typeof window < "u" ? window : void 0;

function E1e(l) {
  let s = l.activeElement;
  for (; s != null && s.shadowRoot;) {
    const t = s.shadowRoot.activeElement;
    if (t === s) break;
    s = t
  }
  return s
}
var Pc, Ql, Wy;
let j1e = (Wy = class {
  constructor(s = {}) {
    yn(this, Pc);
    yn(this, Ql);
    const {
      window: t = A1e,
      document: w = t == null ? void 0 : t.document
    } = s;
    t !== void 0 && (Mo(this, Pc, w), Mo(this, Ql, Xy(z => {
      const E = dd(t, "focusin", z),
        k = dd(t, "focusout", z);
      return () => {
        E(), k()
      }
    })))
  }
  get current() {
    var s;
    return (s = We(this, Ql)) == null || s.call(this), We(this, Pc) ? E1e(We(this, Pc)) : null
  }
}, Pc = new WeakMap, Ql = new WeakMap, Wy);
new j1e;

function L1e(l) {
  return typeof l == "function"
}

function D1e(l, s) {
  if (L1e(l)) {
    const w = l();
    return w === void 0 ? s : w
  }
  return l === void 0 ? s : l
}

function R1e(l, s) {
  let t = ee(null);
  const w = ge(() => D1e(s, 250));

  function z(...E) {
    if (y(t)) y(t).timeout && clearTimeout(y(t).timeout);
    else {
      let k, c;
      const R = new Promise((X, $) => {
        k = X, c = $
      });
      Y(t, {
        timeout: null,
        runner: null,
        promise: R,
        resolve: k,
        reject: c
      }, !0)
    }
    return y(t).runner = async () => {
      if (!y(t)) return;
      const k = y(t);
      Y(t, null);
      try {
        k.resolve(await l.apply(this, E))
      } catch (c) {
        k.reject(c)
      }
    }, y(t).timeout = setTimeout(y(t).runner, y(w)), y(t).promise
  }
  return z.cancel = async () => {
    (!y(t) || y(t).timeout === null) && (await new Promise(E => setTimeout(E, 0)), !y(t) || y(t).timeout === null) || (clearTimeout(y(t).timeout), y(t).reject("Cancelled"), Y(t, null))
  }, z.runScheduledNow = async () => {
    var E, k;
    (!y(t) || !y(t).timeout) && (await new Promise(c => setTimeout(c, 0)), !y(t) || !y(t).timeout) || (clearTimeout(y(t).timeout), y(t).timeout = null, await ((k = (E = y(t)).runner) == null ? void 0 : k.call(E)))
  }, Object.defineProperty(z, "pending", {
    enumerable: !0,
    get() {
      var E;
      return !!((E = y(t)) != null && E.timeout)
    }
  }), z
}

function B1e(l, s) {
  switch (l) {
    case "post":
      cn(s);
      break;
    case "pre":
      Bf(s);
      break
  }
}

function Vv(l, s, t, w = {}) {
  const {
    lazy: z = !1
  } = w;
  let E = !z,
    k = Array.isArray(l) ? [] : void 0;
  B1e(s, () => {
    const c = Array.isArray(l) ? l.map(X => X()) : l();
    if (!E) {
      E = !0, k = c;
      return
    }
    const R = Io(() => t(c, k));
    return k = c, R
  })
}

function ha(l, s, t) {
  Vv(l, "post", s, t)
}

function F1e(l, s, t) {
  Vv(l, "pre", s, t)
}
ha.pre = F1e;

function O1e() {}
var gu, Ba;
class q1e {
  constructor(s, t = 250) {
    yn(this, gu, ee());
    yn(this, Ba);
    Y(We(this, gu), s(), !0), this.cancel = this.cancel.bind(this), this.setImmediately = this.setImmediately.bind(this), this.updateImmediately = this.updateImmediately.bind(this), Mo(this, Ba, R1e(() => {
      Y(We(this, gu), s(), !0)
    }, t)), ha(s, () => {
      We(this, Ba).call(this).catch(O1e)
    })
  }
  get current() {
    return y(We(this, gu))
  }
  get pending() {
    return We(this, Ba).pending
  }
  cancel() {
    We(this, Ba).cancel()
  }
  updateImmediately() {
    return We(this, Ba).runScheduledNow()
  }
  setImmediately(s) {
    this.cancel(), Y(We(this, gu), s, !0)
  }
}
gu = new WeakMap, Ba = new WeakMap;
var N1e = ft('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  V1e = ft('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  U1e = ft('<span class="font-flag tooltip ml-0.5"> </span>'),
  Z1e = ft("<button><!></button>"),
  G1e = ft('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  H1e = ft('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  W1e = ft('<div><!> <div class="mt-4"><!></div></div>');

function $1e(l, s) {
  en(s, !0);
  let t = $e(s, "reload", 15),
    w = ee(!0),
    z = ee([]),
    E = ee(0),
    k = ee("today"),
    c = {};
  t(R);

  function R() {
    const G = y(k);
    fn.allianceLeaderboard(G).then(yt => {
      Y(z, yt), c = {
        [G]: yt
      }, Y(w, !1)
    }).catch(yt => {
      Ne.error(yt.message)
    })
  }
  ha(() => [y(k)], () => {
    const G = y(k),
      yt = c[G];
    if (yt) {
      Y(z, yt), Y(w, !1);
      return
    }
    Y(w, !0), fn.allianceLeaderboard(G).then(Lt => {
      Y(z, Lt), c[G] = Lt, Y(w, !1)
    }).catch(Lt => {
      Ne.error(Lt.message)
    })
  });
  var X = W1e(),
    $ = C(X);
  um($, {
    get value() {
      return y(k)
    },
    set value(G) {
      Y(k, G, !0)
    }
  });
  var tt = D($, 2),
    ut = C(tt);
  {
    var xt = G => {
        var yt = N1e();
        Z(G, yt)
      },
      lt = G => {
        var yt = kr(),
          Lt = xe(yt);
        {
          var Dt = qt => {
              var Vt = V1e(),
                Zt = C(Vt),
                Et = D(Zt);
              {
                var Ct = jt => {
                    var Ht = to();
                    Bt(_e => at(Ht, _e), [() => Id().toLowerCase()]), Z(jt, Ht)
                  },
                  Wt = jt => {
                    var Ht = kr(),
                      _e = xe(Ht);
                    {
                      var Ut = me => {
                          var Ce = to();
                          Bt(Ve => at(Ce, Ve), [() => em()]), Z(me, Ce)
                        },
                        Xt = me => {
                          var Ce = kr(),
                            Ve = xe(Ce);
                          {
                            var Ie = ne => {
                              var Xe = to();
                              Bt(pe => at(Xe, pe), [() => tm()]), Z(ne, Xe)
                            };
                            At(Ve, ne => {
                              y(k) === "month" && ne(Ie)
                            }, !0)
                          }
                          Z(me, Ce)
                        };
                      At(_e, me => {
                        y(k) === "week" ? me(Ut) : me(Xt, !1)
                      }, !0)
                    }
                    Z(jt, Ht)
                  };
                At(Et, jt => {
                  y(k) === "today" ? jt(Ct) : jt(Wt, !1)
                })
              }
              P(Vt), Bt(jt => at(Zt, `${jt??""} `), [() => Qf()]), Z(qt, Vt)
            },
            St = qt => {
              var Vt = H1e(),
                Zt = C(Vt),
                Et = C(Zt),
                Ct = D(C(Et)),
                Wt = C(Ct, !0);
              P(Ct);
              var jt = D(Ct),
                Ht = C(jt, !0);
              P(jt), P(Et), P(Zt);
              var _e = D(Zt);
              di(_e, 31, () => y(z), Ut => Ut.userId, (Ut, Xt, me) => {
                const Ce = ge(() => {
                  var ir;
                  return ((ir = ze.data) == null ? void 0 : ir.id) === y(Xt).userId
                });
                var Ve = G1e();
                let Ie;
                var ne = C(Ve),
                  Xe = C(ne, !0);
                P(ne);
                var pe = D(ne),
                  Ue = C(pe),
                  Ae = C(Ue);
                ws(Ae, {
                  class: "size-10 border",
                  get userId() {
                    return y(Xt).userId
                  },
                  get pictureUrl() {
                    return y(Xt).picture
                  }
                });
                var He = D(Ae, 2),
                  Tr = C(He),
                  Ye = D(Tr),
                  mr = C(Ye);
                P(Ye), P(He);
                var se = D(He, 2);
                {
                  var ce = ir => {
                    const Ze = ge(() => Ls(y(Xt).equippedFlag));
                    var or = U1e(),
                      de = C(or, !0);
                    P(or), Bt(() => {
                      pr(or, "data-tip", y(Ze).name), at(de, y(Ze).flag)
                    }), Z(ir, or)
                  };
                  At(se, ir => {
                    y(Xt).equippedFlag && ir(ce)
                  })
                }
                var ur = D(se, 2);
                {
                  var Ke = ir => {
                    j_(ir, {
                      get username() {
                        return y(Xt).discord
                      },
                      get id() {
                        return y(Xt).discordId
                      }
                    })
                  };
                  At(ur, ir => {
                    y(Xt).discord && ir(Ke)
                  })
                }
                P(Ue), P(pe);
                var ve = D(pe),
                  _r = C(ve),
                  nr = D(_r);
                {
                  var gr = ir => {
                    var Ze = Z1e();
                    let or;
                    Ze.__click = () => {
                      s.onlastpixelclick({
                        lat: y(Xt).lastLatitude ?? 0,
                        lng: y(Xt).lastLongitude ?? 0
                      })
                    };
                    var de = C(Ze);
                    Pd(de, {
                      class: "size-4"
                    }), P(Ze), Bt(zr => {
                      or = Gr(Ze, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, or, {
                        tooltip: y(E) > 640
                      }), pr(Ze, "data-tip", zr)
                    }, [() => d1()]), Z(ir, Ze)
                  };
                  At(nr, ir => {
                    y(Xt).lastLatitude && y(Xt).lastLongitude && ir(gr)
                  })
                }
                P(ve), P(Ve), Bt((ir, Ze) => {
                  var or;
                  Ie = Gr(Ve, 1, "", null, Ie, {
                    "bg-base-200": y(Ce)
                  }), at(Xe, y(me) + 1), Gr(He, 1, `font-semibold ${ir??""} flex gap-1`), at(Tr, `${(y(Ce)?((or=ze.data)==null?void 0:or.name)??y(Xt).name:y(Xt).name)??""} `), at(mr, `#${y(Xt).userId??""}`), at(_r, `${Ze??""} `)
                }, [() => Ji(y(Xt).userId), () => y(Xt).pixelsPainted.toLocaleString("en-US")]), fu(Ve, () => mu, () => ({
                  duration: 200
                })), Z(Ut, Ve)
              }), P(_e), P(Vt), Bt((Ut, Xt) => {
                at(Wt, Ut), at(Ht, Xt)
              }, [() => Wf(), () => Gf()]), Z(qt, Vt)
            };
          At(Lt, qt => {
            y(z).length === 0 ? qt(Dt) : qt(St, !1)
          }, !0)
        }
        Z(G, yt)
      };
    At(ut, G => {
      y(w) ? G(xt) : G(lt, !1)
    })
  }
  P(tt), P(X), I_("innerWidth", G => Y(E, G, !0)), Z(l, X), rn()
}
ri(["click"]);
var X1e = $r('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function cm(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = X1e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var Y1e = ft('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  K1e = ft('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1),
  J1e = ft('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'),
  Q1e = ft('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'),
  twe = ft('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  ewe = ft('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'),
  rwe = ft('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  nwe = ft('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  iwe = ft('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function owe(l, s) {
  en(s, !0);
  let t = Qi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    w = Qi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var z = iwe(),
    E = C(z),
    k = C(E);
  k.__click = () => s.onclickback();
  var c = C(k);
  ov(c, {
    class: "size-5"
  }), P(k);
  var R = D(k, 2),
    X = C(R, !0);
  P(R), P(E);
  var $ = D(E, 2),
    tt = C($);
  xo(tt);
  var ut = D(tt, 2),
    xt = C(ut),
    lt = C(xt);
  di(lt, 21, () => t.data, Wt => Wt.id, (Wt, jt, Ht) => {
    const _e = ge(() => {
      var ce;
      return ((ce = ze.data) == null ? void 0 : ce.id) === y(jt).id
    });
    var Ut = Q1e(),
      Xt = C(Ut),
      me = C(Xt),
      Ce = C(me);
    ws(Ce, {
      class: "size-10 border",
      get userId() {
        return y(jt).id
      },
      get pictureUrl() {
        return y(jt).picture
      }
    });
    var Ve = D(Ce, 2),
      Ie = C(Ve);
    P(Ve);
    var ne = D(Ve, 2);
    {
      var Xe = ce => {
        var ur = Y1e();
        Z(ce, ur)
      };
      At(ne, ce => {
        y(jt).role === "admin" && ce(Xe)
      })
    }
    P(me), P(Xt);
    var pe = D(Xt),
      Ue = C(pe),
      Ae = C(Ue),
      He = C(Ae);
    cm(He, {
      class: "size-4"
    }), P(Ae);
    var Tr = D(Ae, 2),
      Ye = C(Tr);
    {
      var mr = ce => {
          var ur = K1e(),
            Ke = xe(ur),
            ve = C(Ke);
          ve.__click = async () => {
            try {
              y(jt).loading = !0, await fn.giveAllianceAdmin(y(jt).id), y(jt).role = "admin"
            } catch {
              Ne.error(RA())
            } finally {
              y(jt).loading = !1
            }
          };
          var _r = C(ve, !0);
          P(ve), P(Ke);
          var nr = D(Ke, 2),
            gr = C(nr);
          gr.__click = async () => {
            try {
              y(jt).loading = !0, await fn.banAllianceUser(y(jt).id), t.data = t.data.filter(Ze => Ze.id !== y(jt).id)
            } catch {
              Ne.error(ez())
            } finally {
              y(jt).loading = !1
            }
          };
          var ir = C(gr, !0);
          P(gr), P(nr), Bt((Ze, or) => {
            ve.disabled = y(jt).loading, at(_r, Ze), gr.disabled = y(jt).loading, at(ir, or)
          }, [() => kA(), () => dv()]), Z(ce, ur)
        },
        se = ce => {
          var ur = J1e(),
            Ke = C(ur);
          Ke.disabled = !0;
          var ve = C(Ke, !0);
          P(Ke), P(ur), Bt(_r => at(ve, _r), [() => IF()]), Z(ce, ur)
        };
      At(Ye, ce => {
        y(jt).role === "member" ? ce(mr) : ce(se, !1)
      })
    }
    P(Tr), P(Ue), P(pe), P(Ut), Bt(ce => {
      var ur;
      Gr(Ve, 1, `font-semibold ${ce??""}`), at(Ie, `${(y(_e)?((ur=ze.data)==null?void 0:ur.name)??y(jt).name:y(jt).name)??""} #${y(jt).id??""}`)
    }, [() => Ji(y(jt).id)]), Z(Wt, Ut)
  }), P(lt), P(xt);
  var G = D(xt, 2);
  {
    var yt = Wt => {
      var jt = kr(),
        Ht = xe(jt);
      Hl(Ht, () => t.page, _e => {
        var Ut = twe();
        eo(Ut, () => Xt => {
          const me = new IntersectionObserver(Ce => {
            Ce[0].isIntersecting && !t.loading && (t.loading = !0, fn.getAllianceMembers(t.page).then(Ve => {
              t.data = [...t.data, ...Ve.data], t.hasNextPage = Ve.hasNext, t.page++
            }).catch(Ve => {
              Ne.error(Ve.message)
            }).finally(() => {
              t.loading = !1
            }))
          });
          return me.observe(Xt), () => {
            me.disconnect()
          }
        }), Z(_e, Ut)
      }), Z(Wt, jt)
    };
    At(G, Wt => {
      t.hasNextPage && Wt(yt)
    })
  }
  P(ut);
  var Lt = D(ut, 2),
    Dt = D(Lt, 2),
    St = C(Dt),
    qt = C(St);
  di(qt, 21, () => w.data, Wt => Wt.id, (Wt, jt, Ht) => {
    var _e = ewe(),
      Ut = C(_e),
      Xt = C(Ut),
      me = C(Xt);
    ws(me, {
      class: "size-10 border",
      get userId() {
        return y(jt).id
      },
      get pictureUrl() {
        return y(jt).picture
      }
    });
    var Ce = D(me, 2),
      Ve = C(Ce);
    P(Ce), P(Xt), P(Ut);
    var Ie = D(Ut),
      ne = C(Ie);
    ne.__click = () => {
      fn.unbanAllianceUser(y(jt).id).then(() => {
        w.data = w.data.filter(pe => pe.id !== y(jt).id)
      }).catch(pe => Ne.error(pe.message)).finally(() => {
        y(jt).loading = !1
      })
    };
    var Xe = C(ne, !0);
    P(ne), P(Ie), P(_e), Bt((pe, Ue) => {
      Gr(Ce, 1, `font-semibold ${pe??""}`), at(Ve, `${y(jt).name??""} #${y(jt).id??""}`), ne.disabled = y(jt).loading, at(Xe, Ue)
    }, [() => Ji(y(jt).id), () => m1()]), Z(Wt, _e)
  }), P(qt), P(St);
  var Vt = D(St, 2);
  {
    var Zt = Wt => {
      var jt = rwe(),
        Ht = C(jt, !0);
      P(jt), Bt(_e => at(Ht, _e), [() => VF()]), Z(Wt, jt)
    };
    At(Vt, Wt => {
      !w.hasNextPage && w.data.length === 0 && Wt(Zt)
    })
  }
  var Et = D(Vt, 2);
  {
    var Ct = Wt => {
      var jt = kr(),
        Ht = xe(jt);
      Hl(Ht, () => w.page, _e => {
        var Ut = nwe();
        eo(Ut, () => Xt => {
          const me = new IntersectionObserver(Ce => {
            Ce[0].isIntersecting && !w.loading && (w.loading = !0, fn.getAllianceBannedMembers(w.page).then(Ve => {
              w.data = [...w.data, ...Ve.data], w.hasNextPage = Ve.hasNext, w.page++
            }).catch(Ve => {
              Ne.error(Ve.message)
            }).finally(() => {
              w.loading = !1
            }))
          });
          return me.observe(Xt), () => {
            me.disconnect()
          }
        }), Z(_e, Ut)
      }), Z(Wt, jt)
    };
    At(Et, Wt => {
      w.hasNextPage && Wt(Ct)
    })
  }
  P(Dt), P($), P(z), Bt((Wt, jt, Ht) => {
    at(X, Wt), pr(tt, "aria-label", jt), pr(Lt, "aria-label", Ht)
  }, [() => iv(), () => g1(), () => $f()]), Z(l, z), rn()
}
ri(["click"]);
var swe = ft('<span class="label"> </span>'),
  awe = ft('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  uwe = ft('<p class="text-error ml-3 text-sm"> </p>'),
  cwe = ft('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function cf(l, s) {
  en(s, !0);
  let t = $e(s, "value", 15),
    w = $e(s, "validate", 15),
    z = ee("");
  const E = ge(() => {
    var Lt;
    return ((Lt = t()) == null ? void 0 : Lt.length) ?? 0
  });
  w(k);

  function k() {
    return s.min !== void 0 && y(E) < s.min ? (Y(z, y(E) === 0 ? "Required" : `Min. characters: ${s.min}`, !0), !1) : s.max !== void 0 && y(E) > s.max ? (Y(z, `Max. characters: ${s.max}`), !1) : !0
  }
  cn(() => {
    var Lt;
    s.max !== void 0 && y(E) > s.max && t((Lt = t()) == null ? void 0 : Lt.substring(0, s.max))
  });
  var c = cwe(),
    R = C(c);
  let X;
  var $ = C(R);
  {
    var tt = Lt => {
      var Dt = swe(),
        St = C(Dt, !0);
      P(Dt), Bt(() => at(St, s.label)), Z(Lt, Dt)
    };
    At($, Lt => {
      s.label && Lt(tt)
    })
  }
  var ut = D($, 2);
  xo(ut);
  var xt = D(ut, 2);
  {
    var lt = Lt => {
      var Dt = awe(),
        St = C(Dt, !0);
      P(Dt), Bt(() => at(St, s.max - y(E))), Z(Lt, Dt)
    };
    At(xt, Lt => {
      s.max !== void 0 && Lt(lt)
    })
  }
  P(R);
  var G = D(R, 2);
  {
    var yt = Lt => {
      var Dt = uwe(),
        St = C(Dt, !0);
      P(Dt), Bt(() => at(St, y(z))), Z(Lt, Dt)
    };
    At(G, Lt => {
      y(z) && Lt(yt)
    })
  }
  P(c), Bt(() => {
    X = Gr(R, 1, "input w-full", null, X, {
      "input-error": !!y(z)
    }), pr(ut, "placeholder", s.placeholder), pr(ut, "maxlength", s.max)
  }), M_(ut, t), Z(l, c), rn()
}
var lwe = ft('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function _we(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15),
    w = ee(!1),
    z = ee(""),
    E = ee(void 0);
  ti(() => {
    const Dt = St => {
      var qt;
      St.key === "Escape" && ((qt = t()) == null || qt.close())
    };
    return document.addEventListener("keydown", Dt), () => document.removeEventListener("keydown", Dt)
  });
  var k = lwe(),
    c = C(k),
    R = C(c),
    X = C(R, !0);
  P(R);
  var $ = D(R, 2),
    tt = C($),
    ut = C(tt);
  {
    let Dt = ge(() => rf()),
      St = ge(() => f2());
    cf(ut, {
      get label() {
        return y(Dt)
      },
      get placeholder() {
        return y(St)
      },
      min: 1,
      max: 16,
      get value() {
        return y(z)
      },
      set value(qt) {
        Y(z, qt, !0)
      },
      get validate() {
        return y(E)
      },
      set validate(qt) {
        Y(E, qt, !0)
      }
    })
  }
  P(tt);
  var xt = D(tt, 2),
    lt = C(xt);
  lt.__click = () => {
    var Dt;
    (Dt = t()) == null || Dt.close()
  };
  var G = C(lt, !0);
  P(lt);
  var yt = D(lt, 2),
    Lt = C(yt, !0);
  P(yt), P(xt), P($), P(c), Mn(2), P(k), os(k, Dt => t(Dt), () => t()), Bt((Dt, St, qt) => {
    at(X, Dt), lt.disabled = y(w), at(G, St), yt.disabled = y(w), at(Lt, qt)
  }, [() => RP(), () => C_(), () => kP()]), jn("submit", $, async () => {
    var Dt, St;
    try {
      if (!((Dt = y(E)) != null && Dt())) return;
      Y(w, !0);
      const {
        id: qt
      } = await fn.createAlliance(y(z));
      await s.onsuccess(qt), (St = t()) == null || St.close()
    } catch (qt) {
      Ne.error(qt.message)
    } finally {
      Y(w, !1)
    }
  }), Z(l, k), rn()
}
ri(["click"]);
var hwe = $r('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'),
  dwe = $r('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');

function lf(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var w = kr(),
    z = xe(w);
  {
    var E = c => {
        var R = hwe();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      },
      k = c => {
        var R = dwe();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      };
    At(z, c => {
      s.filled ? c(E) : c(k, !1)
    })
  }
  Z(l, w)
}
var pwe = $r('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function fwe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = pwe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var mwe = $r('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function gwe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = mwe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var ywe = $r('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function vwe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = ywe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var bwe = $r('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function zd(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = bwe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}

function xwe(l, s = "_blank") {
  return l.replaceAll(/https?:\/\/[^\s]+/g, t => `<a href="${t}"${s?` target="${s}"`:""}>${t}</a>`)
}
var wwe = ft('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  kwe = ft('<div class="tooltip"><button class="btn"><!></button></div>'),
  Twe = ft('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'),
  Swe = ft('<section class="text-base-content/80 highlight-link"><!> <!></section>'),
  Pwe = ft('<span class="font-semibold"> </span>'),
  Mwe = ft('<button class="text-primary font-semibold underline"> </button>'),
  Cwe = ft('<span class="text-primary underline"> </span>'),
  Iwe = ft('<span class="text-primary underline"> </span>'),
  zwe = ft('<button class="text-base-content/80 p-1"><!></button>'),
  Awe = ft('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'),
  Ewe = ft('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1),
  jwe = ft('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1),
  Lwe = ft('<div class="h-full"><!></div>');

function Dwe(l, s) {
  en(s, !0);
  let t = ee(void 0),
    w = ee(!0),
    z = ee(void 0),
    E = ee(!1),
    k = ee(void 0),
    c = ee(!1),
    R = ee(!1),
    X = ee(() => {});
  ha(() => s.open, () => {
    s.open && ud.shouldReload && $()
  }), ti(() => {
    const G = setInterval(() => {
      ud.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(G)
    }
  });
  async function $() {
    try {
      Y(t, await fn.getAlliance(), !0), y(t) && y(X)(), Y(w, !1), ud.shouldReload = !1
    } catch (G) {
      Ne.error(G.message)
    }
  }
  var tt = Lwe(),
    ut = C(tt);
  {
    var xt = G => {
        var yt = wwe();
        Z(G, yt)
      },
      lt = G => {
        var yt = kr(),
          Lt = xe(yt);
        {
          var Dt = qt => {
              owe(qt, {
                onclickback: () => Y(R, !1)
              })
            },
            St = qt => {
              var Vt = kr(),
                Zt = xe(Vt);
              {
                var Et = Wt => {
                    var jt = Ewe(),
                      Ht = xe(jt),
                      _e = C(Ht),
                      Ut = C(_e, !0);
                    P(_e);
                    var Xt = D(_e, 2),
                      me = C(Xt),
                      Ce = C(me),
                      Ve = C(Ce);
                    cm(Ve, {
                      class: "size-4"
                    }), P(Ce);
                    var Ie = D(Ce, 2),
                      ne = C(Ie),
                      Xe = C(ne);
                    Xe.__click = async () => {
                      try {
                        Y(E, !0), await fn.leaveAlliance(), Y(w, !0), await $()
                      } catch (dr) {
                        Ne.error(dr.message)
                      } finally {
                        Y(E, !1)
                      }
                    };
                    var pe = C(Xe, !0);
                    P(Xe), P(ne), P(Ie), P(me);
                    var Ue = D(me, 2);
                    {
                      var Ae = dr => {
                        var ct = kwe(),
                          q = C(ct);
                        q.__click = () => {
                          Y(c, !0)
                        };
                        var U = C(q);
                        vwe(U, {
                          class: "size-4"
                        }), P(q), P(ct), Bt(Q => pr(ct, "data-tip", Q), [() => z8()]), Z(dr, ct)
                      };
                      At(Ue, dr => {
                        y(t).role == "admin" && dr(Ae)
                      })
                    }
                    P(Xt), P(Ht);
                    var He = D(Ht, 2);
                    {
                      var Tr = dr => {
                        var ct = Swe(),
                          q = C(ct);
                        Sd(q, () => xwe(y(t).description || fv()));
                        var U = D(q, 2);
                        {
                          var Q = nt => {
                            var _t = Twe();
                            _t.__click = () => {
                              var Ft;
                              (Ft = y(k)) == null || Ft.show()
                            };
                            var Tt = C(_t);
                            lf(Tt, {
                              class: "size-4"
                            }), P(_t), Z(nt, _t)
                          };
                          At(U, nt => {
                            y(t).role === "admin" && nt(Q)
                          })
                        }
                        P(ct), Z(dr, ct)
                      };
                      At(He, dr => {
                        (y(t).description || y(t).role === "admin") && dr(Tr)
                      })
                    }
                    var Ye = D(He, 2),
                      mr = C(Ye),
                      se = C(mr);
                    vu(se, {
                      class: "inline size-4"
                    });
                    var ce = D(se, 2),
                      ur = C(ce),
                      Ke = D(ur),
                      ve = C(Ke, !0);
                    P(Ke), P(ce), P(mr);
                    var _r = D(mr, 2),
                      nr = C(_r);
                    zd(nr, {
                      class: "inline size-4"
                    });
                    var gr = D(nr, 2),
                      ir = C(gr),
                      Ze = D(ir);
                    {
                      var or = dr => {
                          var ct = Pwe(),
                            q = C(ct, !0);
                          P(ct), Bt(U => at(q, U), [() => y(t).members.toLocaleString("en-US")]), Z(dr, ct)
                        },
                        de = dr => {
                          var ct = Mwe();
                          ct.__click = () => Y(R, !0);
                          var q = C(ct, !0);
                          P(ct), Bt(U => at(q, U), [() => y(t).members.toLocaleString("en-US")]), Z(dr, ct)
                        };
                      At(Ze, dr => {
                        y(t).role === "member" ? dr(or) : dr(de, !1)
                      })
                    }
                    P(gr), P(_r);
                    var zr = D(_r, 2);
                    {
                      var er = dr => {
                        var ct = Awe(),
                          q = C(ct);
                        fwe(q, {
                          class: "inline size-4"
                        });
                        var U = D(q, 2),
                          Q = C(U),
                          nt = D(Q);
                        nt.__click = () => {
                          var ie;
                          (ie = y(t)) != null && ie.hq ? s.onhqclick({
                            lat: y(t).hq.latitude,
                            lng: y(t).hq.longitude
                          }) : s.onhqchange()
                        };
                        var _t = C(nt);
                        {
                          var Tt = ie => {
                              var mt = Cwe(),
                                et = C(mt);
                              P(mt), Bt((W, vt) => at(et, `${W??""}, ${vt??""}`), [() => y(t).hq.latitude.toFixed(3), () => y(t).hq.longitude.toFixed(3)]), Z(ie, mt)
                            },
                            Ft = ie => {
                              var mt = Iwe(),
                                et = C(mt, !0);
                              P(mt), Bt(W => at(et, W), [() => Aq()]), Z(ie, mt)
                            };
                          At(_t, ie => {
                            y(t).hq ? ie(Tt) : ie(Ft, !1)
                          })
                        }
                        P(nt), P(U);
                        var zt = D(U, 2);
                        {
                          var Nt = ie => {
                            var mt = zwe();
                            mt.__click = function(...W) {
                              var vt;
                              (vt = s.onhqchange) == null || vt.apply(this, W)
                            };
                            var et = C(mt);
                            lf(et, {
                              class: "text-base-content/50 size-4"
                            }), P(mt), Z(ie, mt)
                          };
                          At(zt, ie => {
                            y(t).role === "admin" && ie(Nt)
                          })
                        }
                        P(ct), Bt(ie => at(Q, `${ie??""}: `), [() => XA()]), Z(dr, ct)
                      };
                      At(zr, dr => {
                        (y(t).hq || y(t).role === "admin") && dr(er)
                      })
                    }
                    P(Ye);
                    var hr = D(Ye, 2),
                      Mr = C(hr),
                      Pr = C(Mr, !0);
                    P(Mr);
                    var Or = D(Mr, 2),
                      jr = C(Or);
                    $1e(jr, {
                      get allianceId() {
                        return y(t).id
                      },
                      get onlastpixelclick() {
                        return s.onlastpixelclick
                      },
                      get reload() {
                        return y(X)
                      },
                      set reload(dr) {
                        Y(X, dr, !0)
                      }
                    }), P(Or), P(hr);
                    var Lr = D(hr, 2);
                    b1e(Lr, {
                      get description() {
                        return y(t).description
                      },
                      onsuccess: async dr => {
                        y(t) && (y(t).description = dr)
                      },
                      get ref() {
                        return y(k)
                      },
                      set ref(dr) {
                        Y(k, dr, !0)
                      }
                    });
                    var _n = D(Lr, 2);
                    k1e(_n, {
                      get open() {
                        return y(c)
                      },
                      set open(dr) {
                        Y(c, dr, !0)
                      }
                    }), Bt((dr, ct, q, U, Q) => {
                      at(Ut, y(t).name), Xe.disabled = y(E), at(pe, dr), at(ur, `${ct??""}: `), at(ve, q), at(ir, `${U??""}: `), at(Pr, Q)
                    }, [() => Cj(), () => Gf(), () => y(t).pixelsPainted.toLocaleString("en-US"), () => iv(), () => Xf()]), Z(Wt, jt)
                  },
                  Ct = Wt => {
                    var jt = jwe(),
                      Ht = xe(jt),
                      _e = C(Ht),
                      Ut = C(_e);
                    P(_e);
                    var Xt = D(_e, 2),
                      me = C(Xt);
                    gwe(me, {
                      class: "size-5"
                    });
                    var Ce = D(me, 1, !0);
                    P(Xt);
                    var Ve = D(Xt, 2),
                      Ie = C(Ve),
                      ne = C(Ie, !0);
                    P(Ie), P(Ve);
                    var Xe = D(Ve, 2);
                    Xe.__click = () => {
                      var He;
                      (He = y(z)) == null || He.show()
                    };
                    var pe = C(Xe);
                    Ky(pe, {
                      class: "size-6"
                    });
                    var Ue = D(pe);
                    P(Xe), P(Ht);
                    var Ae = D(Ht, 2);
                    _we(Ae, {
                      onsuccess: $,
                      get ref() {
                        return y(z)
                      },
                      set ref(He) {
                        Y(z, He, !0)
                      }
                    }), Bt((He, Tr, Ye, mr) => {
                      at(Ut, `${He??""}:`), at(Ce, Tr), at(ne, Ye), at(Ue, ` ${mr??""}`)
                    }, [() => oq(), () => K4(), () => G1(), () => XP()]), Z(Wt, jt)
                  };
                At(Zt, Wt => {
                  y(t) ? Wt(Et) : Wt(Ct, !1)
                }, !0)
              }
              Z(qt, Vt)
            };
          At(Lt, qt => {
            y(R) ? qt(Dt) : qt(St, !1)
          }, !0)
        }
        Z(G, yt)
      };
    At(ut, G => {
      y(w) ? G(xt) : G(lt, !1)
    })
  }
  P(tt), Z(l, tt), rn()
}
ri(["click"]);
var Rwe = $r('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function Ad(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = Rwe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var Bwe = ft('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Fwe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  ti(() => {
    const tt = ut => {
      ut.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", tt), () => document.removeEventListener("keydown", tt)
  });
  var w = Bwe(),
    z = C(w),
    E = D(C(z), 2),
    k = C(E);
  Ad(k, {
    class: "size-5 max-sm:size-6"
  });
  var c = D(k, 2),
    R = C(c, !0);
  P(c), P(E);
  var X = D(E, 2),
    $ = C(X);
  Dwe($, {
    get open() {
      return t()
    },
    get onhqchange() {
      return s.onhqchange
    },
    get onhqclick() {
      return s.onhqclick
    },
    get onlastpixelclick() {
      return s.onlastpixelclick
    }
  }), P(X), P(z), Mn(2), P(w), eo(w, () => tt => {
    cn(() => {
      t() ? (tt.show(), gi.url.searchParams.get("alliance") && (gi.url.searchParams.delete("alliance"), pd(gi.url.toString()))) : tt.close()
    })
  }), Bt(tt => at(R, tt), [() => Md()]), jn("close", w, () => t(!1)), vo(2, X, () => is, () => ({
    duration: 300
  })), Z(l, w), rn()
}

function Owe(l, s, t) {
  return new Promise((w, z) => {
    l.once("render", () => {
      const E = l.getCanvas().toDataURL(),
        k = document.createElement("img");
      k.src = E, k.onload = () => {
        const c = document.createElement("canvas");
        c.width = k.width, c.height = k.height;
        const R = c.getContext("2d");
        if (R) {
          R.drawImage(k, 0, 0);
          const [X, $, tt, ut] = R.getImageData(s, t, 1, 1).data;
          w([X, $, tt, ut])
        } else z(new Error("Could not get 2d context from canvas"));
        k.remove(), c.remove()
      }
    }), l.triggerRepaint()
  })
}

function yd(l, s) {
  return new Promise((t, w) => {
    l.once("render", () => {
      const z = l.getCanvas();
      let E = z;
      if (s != null && s.maxWidth || s != null && s.maxHeight) {
        const k = z.width,
          c = z.height,
          R = (s == null ? void 0 : s.maxWidth) ?? k,
          X = (s == null ? void 0 : s.maxHeight) ?? c;
        E = document.createElement("canvas");
        const $ = Math.min(R / k, X / c);
        E.width = Math.floor(k * $), E.height = Math.floor(c * $);
        const tt = E.getContext("2d");
        tt && tt.drawImage(z, 0, 0, E.width, E.height)
      }
      try {
        E.toBlob(k => {
          k && t(k)
        }, (s == null ? void 0 : s.type) ?? "image/png", (s == null ? void 0 : s.quality) ?? 1)
      } catch (k) {
        w(k)
      } finally {
        E !== z && E.remove()
      }
    })
  })
}
var qwe = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function Nwe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = qwe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var Vwe = $r('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function Uv(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = Vwe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
const wc = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function Zv(l) {
  const s = Math.floor(l / wc.hour);
  l -= s * wc.hour;
  const t = Math.floor(l / wc.min);
  l -= t * wc.min;
  const z = Math.floor(l / wc.sec).toString().padStart(2, "0");
  return s > 0 ? `${s}:${t.toString().padStart(2,"0")}:${z}` : `${t}:${z}`
}

function Uwe(l) {
  const s = l.getFullYear(),
    t = String(l.getMonth() + 1).padStart(2, "0"),
    w = String(l.getDate()).padStart(2, "0"),
    z = String(l.getHours()).padStart(2, "0"),
    E = String(l.getMinutes()).padStart(2, "0"),
    k = String(l.getSeconds()).padStart(2, "0");
  return `${s}-${t}-${w} ${z}:${E}:${k}`
}
var Zwe = ft('<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'),
  Gwe = ft('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  Hwe = ft('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  Wwe = ft('<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'),
  $we = ft('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Xwe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(!1);
  ti(() => {
    const Zt = Et => {
      Et.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", Zt), () => document.removeEventListener("keydown", Zt)
  });
  let z = ee(null),
    E = ee("");
  const k = ge(() => {
    const Zt = new URL(s.url.toString()),
      Et = Zt.searchParams.get("lat"),
      Ct = Zt.searchParams.get("lng");
    if (Et && Ct) return {
      lat: parseFloat(Et),
      lng: parseFloat(Ct)
    }
  });
  cn(() => {
    t() ? (s.hideHover(), setTimeout(async () => {
      yd(s.map).then(Zt => {
        Y(z, Zt, !0), Y(E, URL.createObjectURL(y(z)), !0)
      }).finally(() => {
        s.showHover()
      })
    }, 500)) : y(E) && (URL.revokeObjectURL(y(E)), Y(z, null), Y(E, ""))
  });
  var c = $we(),
    R = C(c),
    X = D(C(R), 2),
    $ = C(X);
  Uv($, {
    class: "size-5"
  });
  var tt = D($);
  P(X);
  var ut = D(X, 2),
    xt = C(ut);
  xo(xt);
  var lt = D(xt, 2),
    G = C(lt);
  let yt;
  G.__click = () => {
    navigator.clipboard.writeText(s.url.toString()), Y(w, !0), setTimeout(() => {
      Y(w, !1)
    }, 1e3)
  };
  var Lt = C(G, !0);
  P(G), P(lt), P(ut);
  var Dt = D(ut, 2);
  {
    var St = Zt => {
      var Et = Zwe(),
        Ct = C(Et),
        Wt = C(Ct);
      P(Ct);
      var jt = D(Ct);
      P(Et), Bt(Ht => {
        at(Wt, `${Ht??""}:`), at(jt, ` ${y(k).lat??""}, ${y(k).lng??""}`)
      }, [() => pv()]), Z(Zt, Et)
    };
    At(Dt, Zt => {
      y(k) && Zt(St)
    })
  }
  var qt = D(Dt, 2);
  {
    var Vt = Zt => {
      const Et = ge(() => {
        var Ue;
        return (Ue = s.map) == null ? void 0 : Ue.getCanvas()
      });
      var Ct = Wwe(),
        Wt = C(Ct),
        jt = C(Wt);
      Nwe(jt, {
        class: "inline size-5"
      });
      var Ht = D(jt);
      P(Wt);
      var _e = D(Wt, 2);
      {
        var Ut = Ue => {
            var Ae = Gwe();
            Bt(() => {
              pr(Ae, "src", y(E)), pr(Ae, "width", y(Et).width), pr(Ae, "height", y(Et).height)
            }), Z(Ue, Ae)
          },
          Xt = Ue => {
            var Ae = Hwe();
            Bt(() => _a(Ae, `aspect-ratio: ${y(Et).width/y(Et).height}`)), Z(Ue, Ae)
          };
        At(_e, Ue => {
          y(E) ? Ue(Ut) : Ue(Xt, !1)
        })
      }
      var me = D(_e, 2),
        Ce = C(me);
      Ce.__click = async () => {
        y(z) && (await navigator.clipboard.write([new ClipboardItem({
          "image/png": y(z)
        })]), Ne.info(vE()))
      };
      var Ve = C(Ce);
      Yf(Ve, {
        class: "size-5"
      });
      var Ie = D(Ve);
      P(Ce);
      var ne = D(Ce, 2),
        Xe = C(ne);
      Hf(Xe, {
        class: "size-5"
      });
      var pe = D(Xe);
      P(ne), P(me), P(Ct), Bt((Ue, Ae, He, Tr) => {
        at(Ht, ` ${Ue??""}`), at(Ie, ` ${Ae??""}`), pr(ne, "href", y(E)), pr(ne, "download", `wplace_${He??""}.png`), at(pe, ` ${Tr??""}`)
      }, [() => sE(), () => tf(), () => Uwe(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => nI()]), vo(2, Ct, () => is, () => ({
        duration: 300
      })), Z(Zt, Ct)
    };
    At(qt, Zt => {
      t() && Zt(Vt)
    })
  }
  P(R), Mn(2), P(c), eo(c, () => Zt => {
    cn(() => {
      t() ? Zt.show() : Zt.close()
    })
  }), Bt((Zt, Et, Ct) => {
    at(tt, ` ${Zt??""}`), Of(xt, Et), yt = Gr(G, 1, "btn btn-primary", null, yt, {
      "btn-success": y(w)
    }), at(Lt, Ct)
  }, [() => PK(), () => s.url.toString(), () => y(w) ? Kf() : tf()]), jn("close", c, () => t(!1)), Z(l, c), rn()
}
ri(["click"]);
var Ywe = $r('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function Kwe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = Ywe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var Jwe = ft('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  Qwe = ft('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function Gv(l, s) {
  en(s, !1);
  const t = [AC(), P7(), J7(), LO(), jM(), wU(), rG()];
  Uf();
  var w = Qwe(),
    z = C(w),
    E = C(z);
  Kwe(E, {
    class: "size-5"
  });
  var k = D(E, 2),
    c = C(k),
    R = D(c),
    X = C(R, !0);
  P(R), P(k), P(z);
  var $ = D(z, 2),
    tt = C($);
  di(tt, 5, () => t, P_, (Dt, St) => {
    var qt = Jwe(),
      Vt = C(qt, !0);
    P(qt), Bt(() => at(Vt, y(St))), Z(Dt, qt)
  }), P(tt);
  var ut = D(tt, 2),
    xt = C(ut, !0);
  P(ut);
  var lt = D(ut, 2),
    G = C(lt),
    yt = D(G),
    Lt = C(yt, !0);
  P(yt), Mn(), P(lt), P($), P(w), Bt((Dt, St, qt, Vt, Zt) => {
    at(c, `${Dt??""} `), at(X, St), at(xt, qt), at(G, `${Vt??""} `), at(Lt, Zt)
  }, [() => gX(), () => EE(), () => jot(), () => F4(), () => gw()]), Z(l, w), rn()
}
var t2e = ft('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function e2e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  ti(() => {
    const G = yt => {
      yt.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", G), () => document.removeEventListener("keydown", G)
  });
  var w = t2e(),
    z = C(w),
    E = C(z),
    k = C(E),
    c = C(k),
    R = C(c, !0);
  P(c);
  var X = D(c, 2);
  sv(X, {
    hasText: !0,
    size: "medium"
  }), P(k), P(E);
  var $ = D(E, 2),
    tt = C($);
  Gv(tt, {}), P($);
  var ut = D($, 2),
    xt = C(ut);
  xt.__click = () => {
    gi.url.searchParams.delete("new-user"), pd(gi.url.toString())
  };
  var lt = C(xt, !0);
  P(xt), P(ut), P(z), P(w), eo(w, () => G => {
    cn(() => {
      t() ? G.show() : G.close()
    })
  }), Bt((G, yt) => {
    at(R, G), at(lt, yt)
  }, [() => ost(), () => _nt()]), jn("close", w, () => t(!1)), Z(l, w), rn()
}
ri(["click"]);

function r2e() {
  const l = navigator.userAgent,
    s = navigator.vendor;
  return /Chrome/.test(l) && /Google Inc/.test(s) ? "Chrome" : /Safari/.test(l) && /Apple Computer/.test(s) ? "Safari" : /Firefox/.test(l) ? "Firefox" : /Edge/.test(l) ? "Edge" : /Opera|OPR/.test(l) ? "Opera" : "Unknown"
}
var n2e = $r('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function i2e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = n2e();
  Er(w, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...t
  })), Z(l, w)
}
var o2e = $r('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function _f(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = o2e();
  Er(w, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var s2e = $r('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function a2e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = s2e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...t
  })), Z(l, w)
}
var u2e = $r('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function vd(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = u2e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var c2e = $r(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function l2e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = c2e();
  Er(w, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...t
  })), Z(l, w)
}
var _2e = $r(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function h2e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = _2e();
  Er(w, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...t
  })), Z(l, w)
}
var d2e = ft(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  p2e = ft('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  f2e = ft('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  m2e = ft(' <kbd class="kbd kbd-sm h-fit px-3"> </kbd> <!>', 1),
  g2e = ft('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> Â· <a class="link" target="_blank"> </a> Â· <a class="link" target="_blank"> </a> Â· <a class="link" target="_blank"> </a> Â· <a class="link" href="https://forms.gle/tpDWwewuK5i9C52s8" target="_blank"> </a> Â· <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> Â· <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  y2e = ft('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function v2e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  ti(() => {
    const tt = ut => {
      ut.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", tt), () => document.removeEventListener("keydown", tt)
  });
  const w = r2e();
  var z = y2e(),
    E = C(z),
    k = D(C(E), 2);
  {
    var c = tt => {
      var ut = g2e(),
        xt = C(ut),
        lt = C(xt);
      sv(lt, {
        hasText: !0,
        size: "medium"
      });
      var G = D(lt, 2),
        yt = C(G),
        Lt = D(yt, 4);
      Mn(), P(G);
      var Dt = D(G, 2),
        St = C(Dt),
        qt = C(St),
        Vt = C(qt);
      _f(Vt, {
        class: "text-base-content mr-0.5 inline size-4"
      }), Mn(2), P(qt);
      var Zt = D(qt, 4),
        Et = C(Zt);
      i2e(Et, {
        class: "size-4.5 mr-0.5 inline"
      }), Mn(2), P(Zt);
      var Ct = D(Zt, 4),
        Wt = C(Ct);
      a2e(Wt, {
        class: "mr-0.5 inline size-3.5"
      }), Mn(2), P(Ct);
      var jt = D(Ct, 4),
        Ht = C(jt);
      h2e(Ht, {
        class: "mr-0.5 inline size-3.5"
      }), Mn(2), P(jt);
      var _e = D(jt, 4),
        Ut = C(_e);
      l2e(Ut, {
        class: "mr-0.5 inline size-3.5"
      }), Mn(2), P(_e), P(St), P(Dt), P(xt);
      var Xt = D(xt, 2),
        me = C(Xt),
        Ce = C(me, !0);
      P(me);
      var Ve = D(me, 2);
      P(Xt);
      var Ie = D(Xt, 2),
        ne = C(Ie),
        Xe = C(ne, !0);
      P(ne);
      var pe = D(ne, 2),
        Ue = C(pe),
        Ae = D(Ue),
        He = C(Ae);
      vd(He, {
        class: "size-5"
      }), P(Ae);
      var Tr = D(Ae);
      P(pe);
      var Ye = D(pe, 2),
        mr = C(Ye),
        se = D(mr),
        ce = C(se, !0);
      P(se);
      var ur = D(se);
      P(Ye), P(Ie);
      var Ke = D(Ie, 2),
        ve = C(Ke),
        _r = C(ve, !0);
      P(ve);
      var nr = D(ve, 2),
        gr = C(nr);
      {
        var ir = Q => {
            var nt = d2e(),
              _t = xe(nt);
            Mn(), Bt(Tt => at(_t, `${Tt??""}: `), [() => S4()]), Z(Q, nt)
          },
          Ze = Q => {
            var nt = m2e(),
              _t = xe(nt),
              Tt = D(_t),
              Ft = C(Tt, !0);
            P(Tt);
            var zt = D(Tt),
              Nt = D(zt);
            {
              var ie = et => {
                  var W = p2e();
                  Mn(), Z(et, W)
                },
                mt = et => {
                  var W = kr(),
                    vt = xe(W);
                  {
                    var $t = Pt => {
                      var Gt = f2e();
                      Mn(), Z(Pt, Gt)
                    };
                    At(vt, Pt => {
                      w === "Edge" && Pt($t)
                    }, !0)
                  }
                  Z(et, W)
                };
              At(Nt, et => {
                w === "Chrome" ? et(ie) : et(mt, !1)
              })
            }
            Bt((et, W, vt) => {
              at(_t, `${et??""} `), at(Ft, W), at(zt, ` ${vt??""} `)
            }, [() => bot(), () => $it(), () => rj()]), Z(Q, nt)
          };
        At(gr, Q => {
          w !== "Chrome" && w !== "Edge" ? Q(ir) : Q(Ze, !1)
        })
      }
      P(nr), P(Ke);
      var or = D(Ke, 2),
        de = C(or);
      Gv(de, {}), P(or);
      var zr = D(or, 4),
        er = D(C(zr), 2),
        hr = C(er, !0);
      P(er);
      var Mr = D(er, 2),
        Pr = C(Mr, !0);
      P(Mr);
      var Or = D(Mr, 2),
        jr = C(Or, !0);
      P(Or);
      var Lr = D(Or, 2),
        _n = C(Lr, !0);
      P(Lr);
      var dr = D(Lr, 2),
        ct = C(dr, !0);
      P(dr);
      var q = D(dr, 2),
        U = C(q, !0);
      P(q), P(zr), P(ut), Bt((Q, nt, _t, Tt, Ft, zt, Nt, ie, mt, et, W, vt, $t, Pt, Gt, ae, ye, Te) => {
        at(yt, `${Q??""} `), at(Lt, ` Â©
						${nt??""} `), at(Ce, _t), pr(Ve, "src", zo.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), at(Xe, Tt), at(Ue, `${Ft??""} `), at(Tr, ` ${zt??""}`), at(mr, `${Nt??""} `), at(ce, ie), at(ur, ` ${mt??""}`), at(_r, et), pr(er, "href", W), at(hr, vt), pr(Mr, "href", `${gi.url.origin??""}/terms/privacy`), at(Pr, $t), pr(Or, "href", Pt), at(jr, Gt), at(_n, ae), at(ct, ye), at(U, Te)
      }, [() => fG(), () => CN(), () => tV(), () => W6(), () => yst(), () => fN(), () => L6(), () => TJ(), () => tk(), () => YD(), y1, () => LQ(), () => CG(), av, () => vv(), () => hv(), () => uQ(), () => v3()]), vo(2, ut, () => is, () => ({
        duration: 300
      })), Z(tt, ut)
    };
    At(k, tt => {
      t() && tt(c)
    })
  }
  P(E);
  var R = D(E, 2),
    X = C(R),
    $ = C(X, !0);
  P(X), P(R), P(z), eo(z, () => tt => {
    cn(() => {
      t() ? tt.show() : tt.close()
    })
  }), Bt(tt => at($, tt), [() => la()]), jn("close", z, () => t(!1)), Z(l, z), rn()
}

function b2e(l) {
  return l !== null && typeof l == "object"
}
const x2e = ["string", "number", "bigint", "boolean"];

function hf(l) {
  return l == null || x2e.includes(typeof l) ? !0 : Array.isArray(l) ? l.every(s => hf(s)) : typeof l == "object" ? Object.getPrototypeOf(l) === Object.prototype : !1
}
const df = Symbol("box"),
  w2e = Symbol("is-writable");

function Nn(l, s) {
  const t = ge(l);
  return s ? {
    [df]: !0,
    [w2e]: !0,
    get current() {
      return y(t)
    },
    set current(w) {
      s(w)
    }
  } : {
    [df]: !0,
    get current() {
      return l()
    }
  }
}

function k2e(l) {
  return b2e(l) && df in l
}

function T2e(...l) {
  return function(s) {
    var t;
    for (const w of l)
      if (w) {
        if (s.defaultPrevented) return;
        typeof w == "function" ? w.call(this, s) : (t = w.current) == null || t.call(this, s)
      }
  }
}
var Ey = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  S2e = /\n/g,
  P2e = /^\s*/,
  M2e = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  C2e = /^:\s*/,
  I2e = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  z2e = /^[;\s]*/,
  A2e = /^\s+|\s+$/g,
  E2e = `
`,
  jy = "/",
  Ly = "*",
  du = "",
  j2e = "comment",
  L2e = "declaration";

function D2e(l, s) {
  if (typeof l != "string") throw new TypeError("First argument must be a string");
  if (!l) return [];
  s = s || {};
  var t = 1,
    w = 1;

  function z(lt) {
    var G = lt.match(S2e);
    G && (t += G.length);
    var yt = lt.lastIndexOf(E2e);
    w = ~yt ? lt.length - yt : w + lt.length
  }

  function E() {
    var lt = {
      line: t,
      column: w
    };
    return function(G) {
      return G.position = new k(lt), X(), G
    }
  }

  function k(lt) {
    this.start = lt, this.end = {
      line: t,
      column: w
    }, this.source = s.source
  }
  k.prototype.content = l;

  function c(lt) {
    var G = new Error(s.source + ":" + t + ":" + w + ": " + lt);
    if (G.reason = lt, G.filename = s.source, G.line = t, G.column = w, G.source = l, !s.silent) throw G
  }

  function R(lt) {
    var G = lt.exec(l);
    if (G) {
      var yt = G[0];
      return z(yt), l = l.slice(yt.length), G
    }
  }

  function X() {
    R(P2e)
  }

  function $(lt) {
    var G;
    for (lt = lt || []; G = tt();) G !== !1 && lt.push(G);
    return lt
  }

  function tt() {
    var lt = E();
    if (!(jy != l.charAt(0) || Ly != l.charAt(1))) {
      for (var G = 2; du != l.charAt(G) && (Ly != l.charAt(G) || jy != l.charAt(G + 1));) ++G;
      if (G += 2, du === l.charAt(G - 1)) return c("End of comment missing");
      var yt = l.slice(2, G - 2);
      return w += 2, z(yt), l = l.slice(G), w += 2, lt({
        type: j2e,
        comment: yt
      })
    }
  }

  function ut() {
    var lt = E(),
      G = R(M2e);
    if (G) {
      if (tt(), !R(C2e)) return c("property missing ':'");
      var yt = R(I2e),
        Lt = lt({
          type: L2e,
          property: Dy(G[0].replace(Ey, du)),
          value: yt ? Dy(yt[0].replace(Ey, du)) : du
        });
      return R(z2e), Lt
    }
  }

  function xt() {
    var lt = [];
    $(lt);
    for (var G; G = ut();) G !== !1 && (lt.push(G), $(lt));
    return lt
  }
  return X(), xt()
}

function Dy(l) {
  return l ? l.replace(A2e, du) : du
}

function R2e(l, s) {
  let t = null;
  if (!l || typeof l != "string") return t;
  const w = D2e(l),
    z = typeof s == "function";
  return w.forEach(E => {
    if (E.type !== "declaration") return;
    const {
      property: k,
      value: c
    } = E;
    z ? s(k, c, E) : c && (t = t || {}, t[k] = c)
  }), t
}
const B2e = /\d/,
  F2e = ["-", "_", "/", "."];

function O2e(l = "") {
  if (!B2e.test(l)) return l !== l.toLowerCase()
}

function q2e(l) {
  const s = [];
  let t = "",
    w, z;
  for (const E of l) {
    const k = F2e.includes(E);
    if (k === !0) {
      s.push(t), t = "", w = void 0;
      continue
    }
    const c = O2e(E);
    if (z === !1) {
      if (w === !1 && c === !0) {
        s.push(t), t = E, w = c;
        continue
      }
      if (w === !0 && c === !1 && t.length > 1) {
        const R = t.at(-1);
        s.push(t.slice(0, Math.max(0, t.length - 1))), t = R + E, w = c;
        continue
      }
    }
    t += E, w = c, z = k
  }
  return s.push(t), s
}

function Hv(l) {
  return l ? q2e(l).map(s => V2e(s)).join("") : ""
}

function N2e(l) {
  return U2e(Hv(l || ""))
}

function V2e(l) {
  return l ? l[0].toUpperCase() + l.slice(1) : ""
}

function U2e(l) {
  return l ? l[0].toLowerCase() + l.slice(1) : ""
}

function Qh(l) {
  if (!l) return {};
  const s = {};

  function t(w, z) {
    if (w.startsWith("-moz-") || w.startsWith("-webkit-") || w.startsWith("-ms-") || w.startsWith("-o-")) {
      s[Hv(w)] = z;
      return
    }
    if (w.startsWith("--")) {
      s[w] = z;
      return
    }
    s[N2e(w)] = z
  }
  return R2e(l, t), s
}

function Z2e(...l) {
  return (...s) => {
    for (const t of l) typeof t == "function" && t(...s)
  }
}

function G2e(l, s) {
  const t = RegExp(l, "g");
  return w => {
    if (typeof w != "string") throw new TypeError(`expected an argument of type string, but got ${typeof w}`);
    return w.match(t) ? w.replace(t, s) : w
  }
}
const H2e = G2e(/[A-Z]/, l => `-${l.toLowerCase()}`);

function W2e(l) {
  if (!l || typeof l != "object" || Array.isArray(l)) throw new TypeError(`expected an argument of type object, but got ${typeof l}`);
  return Object.keys(l).map(s => `${H2e(s)}: ${l[s]};`).join(`
`)
}

function Wv(l = {}) {
  return W2e(l).replace(`
`, " ")
}
const $2e = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  X2e = new Set($2e);

function Y2e(l) {
  return X2e.has(l)
}

function fa(...l) {
  const s = {
    ...l[0]
  };
  for (let t = 1; t < l.length; t++) {
    const w = l[t];
    if (w) {
      for (const z of Object.keys(w)) {
        const E = s[z],
          k = w[z],
          c = typeof E == "function",
          R = typeof k == "function";
        if (c && Y2e(z)) {
          const X = E,
            $ = k;
          s[z] = T2e(X, $)
        } else if (c && R) s[z] = Z2e(E, k);
        else if (z === "class") {
          const X = hf(E),
            $ = hf(k);
          X && $ ? s[z] = ed(E, k) : X ? s[z] = ed(E) : $ && (s[z] = ed(k))
        } else if (z === "style") {
          const X = typeof E == "object",
            $ = typeof k == "object",
            tt = typeof E == "string",
            ut = typeof k == "string";
          if (X && $) s[z] = {
            ...E,
            ...k
          };
          else if (X && ut) {
            const xt = Qh(k);
            s[z] = {
              ...E,
              ...xt
            }
          } else if (tt && $) {
            const xt = Qh(E);
            s[z] = {
              ...xt,
              ...k
            }
          } else if (tt && ut) {
            const xt = Qh(E),
              lt = Qh(k);
            s[z] = {
              ...xt,
              ...lt
            }
          } else X ? s[z] = E : $ ? s[z] = k : tt ? s[z] = E : ut && (s[z] = k)
        } else s[z] = k !== void 0 ? k : E
      }
      for (const z of Object.getOwnPropertySymbols(w)) {
        const E = s[z],
          k = w[z];
        s[z] = k !== void 0 ? k : E
      }
    }
  }
  return typeof s.style == "object" && (s.style = Wv(s.style).replaceAll(`
`, " ")), s.hidden === !1 && (s.hidden = void 0, delete s.hidden), s.disabled === !1 && (s.disabled = void 0, delete s.disabled), s
}
const $v = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
Wv($v);
const K2e = typeof window < "u" ? window : void 0;

function J2e(l) {
  let s = l.activeElement;
  for (; s != null && s.shadowRoot;) {
    const t = s.shadowRoot.activeElement;
    if (t === s) break;
    s = t
  }
  return s
}
var Mc, t_;
class Q2e {
  constructor(s = {}) {
    yn(this, Mc);
    yn(this, t_);
    const {
      window: t = K2e,
      document: w = t == null ? void 0 : t.document
    } = s;
    t !== void 0 && (Mo(this, Mc, w), Mo(this, t_, Xy(z => {
      const E = dd(t, "focusin", z),
        k = dd(t, "focusout", z);
      return () => {
        E(), k()
      }
    })))
  }
  get current() {
    var s;
    return (s = We(this, t_)) == null || s.call(this), We(this, Mc) ? J2e(We(this, Mc)) : null
  }
}
Mc = new WeakMap, t_ = new WeakMap;
new Q2e;
var e_, ca;
class lm {
  constructor(s) {
    yn(this, e_);
    yn(this, ca);
    Mo(this, e_, s), Mo(this, ca, Symbol(s))
  }
  get key() {
    return We(this, ca)
  }
  exists() {
    return Mx(We(this, ca))
  }
  get() {
    const s = sy(We(this, ca));
    if (s === void 0) throw new Error(`Context "${We(this,e_)}" not found`);
    return s
  }
  getOr(s) {
    const t = sy(We(this, ca));
    return t === void 0 ? s : t
  }
  set(s) {
    return Cx(We(this, ca), s)
  }
}
e_ = new WeakMap, ca = new WeakMap;

function tke(l, s) {
  switch (l) {
    case "post":
      cn(s);
      break;
    case "pre":
      Bf(s);
      break
  }
}

function Xv(l, s, t, w = {}) {
  const {
    lazy: z = !1
  } = w;
  let E = !z,
    k = Array.isArray(l) ? [] : void 0;
  tke(s, () => {
    const c = Array.isArray(l) ? l.map(X => X()) : l();
    if (!E) {
      E = !0, k = c;
      return
    }
    const R = Io(() => t(c, k));
    return k = c, R
  })
}

function Ac(l, s, t) {
  Xv(l, "post", s, t)
}

function eke(l, s, t) {
  Xv(l, "pre", s, t)
}
Ac.pre = eke;

function rke(l, s) {
  return setTimeout(s, l)
}

function bc(l) {
  Ff().then(l)
}

function ma(l, s) {
  return {
    [z1()]: t => k2e(l) ? (l.current = t, Io(() => s == null ? void 0 : s(t)), () => {
      "isConnected" in t && t.isConnected || (l.current = null, s == null || s(null))
    }) : (l(t), Io(() => s == null ? void 0 : s(t)), () => {
      "isConnected" in t && t.isConnected || (l(null), s == null || s(null))
    })
  }
}

function pf(l) {
  return l ? "true" : "false"
}

function Ry(l) {
  return l ? "" : void 0
}
var Cc, r_;
class nke {
  constructor(s) {
    yn(this, Cc);
    yn(this, r_);
    dn(this, "attrs");
    Mo(this, Cc, s.getVariant ? s.getVariant() : null), Mo(this, r_, We(this, Cc) ? `data-${We(this,Cc)}-` : `data-${s.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(s.parts.map(t => [t, this.getAttr(t)]))
  }
  getAttr(s, t) {
    return t ? `data-${t}-${s}` : `${We(this,r_)}${s}`
  }
  selector(s, t) {
    return `[${this.getAttr(s,t)}]`
  }
}
Cc = new WeakMap, r_ = new WeakMap;

function ike(l) {
  const s = new nke(l);
  return {
    ...s.attrs,
    selector: s.selector,
    getAttr: s.getAttr
  }
}
const oke = "ArrowDown",
  ske = "ArrowLeft",
  ake = "ArrowRight",
  uke = "ArrowUp",
  cke = "End",
  lke = "Enter",
  _ke = "Home",
  hke = "p",
  dke = "n",
  pke = "j",
  fke = "k",
  mke = "h",
  gke = "l";

function ff() {}

function ga(l, s) {
  return `bits-${l}`
}

function yke(l) {
  if (!l) return null;
  for (const s of l.childNodes)
    if (s.nodeType !== Node.COMMENT_NODE) return s;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function vke(l = "bits") {
  return globalThis.bitsIdCounter.current++, `${l}-${globalThis.bitsIdCounter.current}`
}

function bke(l, s) {
  let t = l.nextElementSibling;
  for (; t;) {
    if (t.matches(s)) return t;
    t = t.nextElementSibling
  }
}

function xke(l, s) {
  let t = l.previousElementSibling;
  for (; t;) {
    if (t.matches(s)) return t;
    t = t.previousElementSibling
  }
}

function Yv(l) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(l);
  const s = l.length;
  let t = -1,
    w, z = "";
  const E = l.charCodeAt(0);
  if (s === 1 && E === 45) return "\\" + l;
  for (; ++t < s;) {
    if (w = l.charCodeAt(t), w === 0) {
      z += "ï¿½";
      continue
    }
    if (w >= 1 && w <= 31 || w === 127 || t === 0 && w >= 48 && w <= 57 || t === 1 && w >= 48 && w <= 57 && E === 45) {
      z += "\\" + w.toString(16) + " ";
      continue
    }
    if (w >= 128 || w === 45 || w === 95 || w >= 48 && w <= 57 || w >= 65 && w <= 90 || w >= 97 && w <= 122) {
      z += l.charAt(t);
      continue
    }
    z += "\\" + l.charAt(t)
  }
  return z
}
const pu = "data-value",
  Fo = ike({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  xc = Fo.selector("group"),
  Gp = Fo.selector("group-items"),
  By = Fo.selector("group-heading"),
  Kv = Fo.selector("item"),
  Hp = `${Fo.selector("item")}:not([aria-disabled="true"])`,
  bu = new lm("Command.Root"),
  wke = new lm("Command.List"),
  Xl = new lm("Command.Group"),
  Fy = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var Ic, zc, n_, i_, o_, s_, a_, u_, Zr, Jv, cd, gf, ld, _d, hd, Ra, Qv, t0, yf, Vl, vf, bf, e0, Ul, xf, wf, r0, Zl, Gl, c_;
const pm = class pm {
  constructor(s) {
    yn(this, Zr);
    dn(this, "opts");
    dn(this, "attachment");
    yn(this, Ic, !1);
    yn(this, zc, !0);
    dn(this, "sortAfterTick", !1);
    dn(this, "sortAndFilterAfterTick", !1);
    dn(this, "allItems", new Set);
    dn(this, "allGroups", new Map);
    dn(this, "allIds", new Map);
    yn(this, n_, ee(0));
    yn(this, i_, ee(null));
    yn(this, o_, ee(null));
    yn(this, s_, ee(null));
    yn(this, a_, ee(Fy));
    yn(this, u_, ee(Qi(Fy)));
    yn(this, c_, ge(() => ({
      id: this.opts.id.current,
      role: "application",
      [Fo.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = s, this.attachment = ma(this.opts.ref);
    const t = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = t, this.commandState = t, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(s) {
    return bu.set(new pm(s))
  }
  get key() {
    return y(We(this, n_))
  }
  set key(s) {
    Y(We(this, n_), s, !0)
  }
  get viewportNode() {
    return y(We(this, i_))
  }
  set viewportNode(s) {
    Y(We(this, i_), s, !0)
  }
  get inputNode() {
    return y(We(this, o_))
  }
  set inputNode(s) {
    Y(We(this, o_), s, !0)
  }
  get labelNode() {
    return y(We(this, s_))
  }
  set labelNode(s) {
    Y(We(this, s_), s, !0)
  }
  get commandState() {
    return y(We(this, a_))
  }
  set commandState(s) {
    Y(We(this, a_), s)
  }
  get _commandState() {
    return y(We(this, u_))
  }
  set _commandState(s) {
    Y(We(this, u_), s, !0)
  }
  setState(s, t, w) {
    Object.is(this._commandState[s], t) || (this._commandState[s] = t, s === "search" ? (tn(this, Zr, hd).call(this), tn(this, Zr, ld).call(this)) : s === "value" && (w || tn(this, Zr, Qv).call(this)), tn(this, Zr, cd).call(this))
  }
  setValue(s, t) {
    s !== this.opts.value.current && s === "" && bc(() => {
      this.key++
    }), this.setState("value", s, t), this.opts.value.current = s
  }
  getValidItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(Hp)).filter(w => !!w) : []
  }
  getVisibleItems() {
    const s = this.opts.ref.current;
    return s ? Array.from(s.querySelectorAll(Kv)).filter(w => !!w) : []
  }
  get itemsGrid() {
    var c, R, X, $;
    if (!this.isGrid) return [];
    const s = this.opts.columns.current ?? 1,
      t = this.getVisibleItems(),
      w = [
        []
      ];
    let z = (c = t[0]) == null ? void 0 : c.getAttribute("data-group"),
      E = 0,
      k = 0;
    for (let tt = 0; tt < t.length; tt++) {
      const ut = t[tt],
        xt = ut == null ? void 0 : ut.getAttribute("data-group");
      z !== xt ? (z = xt, E = 1, k++, w.push([{
        index: tt,
        firstRowOfGroup: !0,
        ref: ut
      }])) : (E++, E > s && (k++, E = 1, w.push([])), ($ = w[k]) == null || $.push({
        index: tt,
        firstRowOfGroup: ((X = (R = w[k]) == null ? void 0 : R[0]) == null ? void 0 : X.firstRowOfGroup) ?? tt === 0,
        ref: ut
      }))
    }
    return w
  }
  updateSelectedToIndex(s) {
    const t = this.getValidItems()[s];
    t && this.setValue(t.getAttribute(pu) ?? "")
  }
  updateSelectedByItem(s) {
    const t = tn(this, Zr, Ra).call(this),
      w = this.getValidItems(),
      z = w.findIndex(k => k === t);
    let E = w[z + s];
    this.opts.loop.current && (E = z + s < 0 ? w[w.length - 1] : z + s === w.length ? w[0] : w[z + s]), E && this.setValue(E.getAttribute(pu) ?? "")
  }
  updateSelectedByGroup(s) {
    const t = tn(this, Zr, Ra).call(this);
    let w = t == null ? void 0 : t.closest(xc),
      z;
    for (; w && !z;) w = s > 0 ? bke(w, xc) : xke(w, xc), z = w == null ? void 0 : w.querySelector(Hp);
    z ? this.setValue(z.getAttribute(pu) ?? "") : this.updateSelectedByItem(s)
  }
  registerValue(s, t) {
    var w;
    return s && s === ((w = this.allIds.get(s)) == null ? void 0 : w.value) || this.allIds.set(s, {
      value: s,
      keywords: t
    }), this._commandState.filtered.items.set(s, tn(this, Zr, gf).call(this, s, t)), this.sortAfterTick || (this.sortAfterTick = !0, bc(() => {
      tn(this, Zr, ld).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(s)
    }
  }
  registerItem(s, t) {
    return this.allItems.add(s), t && (this.allGroups.has(t) ? this.allGroups.get(t).add(s) : this.allGroups.set(t, new Set([s]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, bc(() => {
      tn(this, Zr, hd).call(this), tn(this, Zr, ld).call(this), this.sortAndFilterAfterTick = !1
    })), tn(this, Zr, cd).call(this), () => {
      const w = tn(this, Zr, Ra).call(this);
      this.allItems.delete(s), this.commandState.filtered.items.delete(s), tn(this, Zr, hd).call(this), (w == null ? void 0 : w.getAttribute("id")) === s && tn(this, Zr, _d).call(this), tn(this, Zr, cd).call(this)
    }
  }
  registerGroup(s) {
    return this.allGroups.has(s) || this.allGroups.set(s, new Set), () => {
      this.allIds.delete(s), this.allGroups.delete(s)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(s) {
    const t = this.opts.vimBindings.current && s.ctrlKey;
    switch (s.key) {
      case dke:
      case pke: {
        t && (this.isGrid ? tn(this, Zr, vf).call(this, s) : tn(this, Zr, Vl).call(this, s));
        break
      }
      case gke: {
        t && this.isGrid && tn(this, Zr, Vl).call(this, s);
        break
      }
      case oke:
        this.isGrid ? tn(this, Zr, vf).call(this, s) : tn(this, Zr, Vl).call(this, s);
        break;
      case ake:
        if (!this.isGrid) break;
        tn(this, Zr, Vl).call(this, s);
        break;
      case hke:
      case fke: {
        t && (this.isGrid ? tn(this, Zr, wf).call(this, s) : tn(this, Zr, Gl).call(this, s));
        break
      }
      case mke: {
        t && this.isGrid && tn(this, Zr, Gl).call(this, s);
        break
      }
      case uke:
        this.isGrid ? tn(this, Zr, wf).call(this, s) : tn(this, Zr, Gl).call(this, s);
        break;
      case ske:
        if (!this.isGrid) break;
        tn(this, Zr, Gl).call(this, s);
        break;
      case _ke:
        s.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case cke:
        s.preventDefault(), tn(this, Zr, yf).call(this);
        break;
      case lke:
        if (!s.isComposing && s.keyCode !== 229) {
          s.preventDefault();
          const w = tn(this, Zr, Ra).call(this);
          w && (w == null || w.click())
        }
    }
  }
  get props() {
    return y(We(this, c_))
  }
  set props(s) {
    Y(We(this, c_), s)
  }
};
Ic = new WeakMap, zc = new WeakMap, n_ = new WeakMap, i_ = new WeakMap, o_ = new WeakMap, s_ = new WeakMap, a_ = new WeakMap, u_ = new WeakMap, Zr = new WeakSet, Jv = function() {
  return I1(this._commandState)
}, cd = function() {
  We(this, Ic) || (Mo(this, Ic, !0), bc(() => {
    var w, z;
    Mo(this, Ic, !1);
    const s = tn(this, Zr, Jv).call(this);
    !Object.is(this.commandState, s) && (this.commandState = s, (z = (w = this.opts.onStateChange) == null ? void 0 : w.current) == null || z.call(w, s))
  }))
}, gf = function(s, t) {
  const w = this.opts.filter.current ?? o0;
  return s ? w(s, this._commandState.search, t) : 0
}, ld = function() {
  var k;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    (!this._commandState.value || !We(this, zc)) && tn(this, Zr, _d).call(this);
    return
  }
  const s = this._commandState.filtered.items,
    t = [];
  for (const c of this._commandState.filtered.groups) {
    const R = this.allGroups.get(c);
    let X = 0;
    if (!R) {
      t.push([c, X]);
      continue
    }
    for (const $ of R) {
      const tt = s.get($);
      X = Math.max(tt ?? 0, X)
    }
    t.push([c, X])
  }
  const w = this.viewportNode,
    z = this.getValidItems().sort((c, R) => {
      const X = c.getAttribute("data-value"),
        $ = R.getAttribute("data-value"),
        tt = s.get(X) ?? 0;
      return (s.get($) ?? 0) - tt
    });
  for (const c of z) {
    const R = c.closest(Gp);
    if (R) {
      const X = c.parentElement === R ? c : c.closest(`${Gp} > *`);
      X && R.appendChild(X)
    } else {
      const X = c.parentElement === w ? c : c.closest(`${Gp} > *`);
      X && (w == null || w.appendChild(X))
    }
  }
  const E = t.sort((c, R) => R[1] - c[1]);
  for (const c of E) {
    const R = w == null ? void 0 : w.querySelector(`${xc}[${pu}="${Yv(c[0])}"]`);
    (k = R == null ? void 0 : R.parentElement) == null || k.appendChild(R)
  }
  tn(this, Zr, _d).call(this)
}, _d = function() {
  bc(() => {
    const s = this.getValidItems().find(z => z.getAttribute("aria-disabled") !== "true"),
      t = s == null ? void 0 : s.getAttribute(pu),
      w = We(this, zc) && this.opts.disableInitialScroll.current;
    this.setValue(t ?? "", w), Mo(this, zc, !1)
  })
}, hd = function() {
  var t, w;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let s = 0;
  for (const z of this.allItems) {
    const E = ((t = this.allIds.get(z)) == null ? void 0 : t.value) ?? "",
      k = ((w = this.allIds.get(z)) == null ? void 0 : w.keywords) ?? [],
      c = tn(this, Zr, gf).call(this, E, k);
    this._commandState.filtered.items.set(z, c), c > 0 && s++
  }
  for (const [z, E] of this.allGroups)
    for (const k of E) {
      const c = this._commandState.filtered.items.get(k);
      if (c && c > 0) {
        this._commandState.filtered.groups.add(z);
        break
      }
    }
  this._commandState.filtered.count = s
}, Ra = function() {
  const s = this.opts.ref.current;
  if (!s) return;
  const t = s.querySelector(`${Hp}[data-selected]`);
  if (t) return t
}, Qv = function() {
  bc(() => {
    var w, z, E, k, c;
    const s = tn(this, Zr, Ra).call(this);
    if (!s) return;
    const t = (w = s.parentElement) == null ? void 0 : w.parentElement;
    if (t) {
      if (this.isGrid) {
        const R = tn(this, Zr, t0).call(this, s);
        if (s.scrollIntoView({
            block: "nearest"
          }), R) {
          const X = (z = s == null ? void 0 : s.closest(xc)) == null ? void 0 : z.querySelector(By);
          X == null || X.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const R = yke(t);
        if (R && ((E = R.dataset) == null ? void 0 : E.value) === ((k = s.dataset) == null ? void 0 : k.value)) {
          const X = (c = s == null ? void 0 : s.closest(xc)) == null ? void 0 : c.querySelector(By);
          X == null || X.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      s.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, t0 = function(s) {
  const t = this.itemsGrid;
  if (t.length === 0) return !1;
  for (let w = 0; w < t.length; w++) {
    const z = t[w];
    if (z !== void 0)
      for (let E = 0; E < z.length; E++) {
        const k = z[E];
        if (!(k === void 0 || k.ref !== s)) return k.firstRowOfGroup
      }
  }
  return !1
}, yf = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Vl = function(s) {
  s.preventDefault(), s.metaKey ? tn(this, Zr, yf).call(this) : s.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, vf = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(tn(this, Zr, e0).call(this, s)))
}, bf = function(s, t) {
  if (t.length === 0) return null;
  for (let w = 0; w < t.length; w++) {
    const z = t[w];
    if (z !== void 0)
      for (let E = 0; E < z.length; E++) {
        const k = z[E];
        if (!(k === void 0 || k.ref !== s)) return {
          columnIndex: E,
          rowIndex: w
        }
      }
  }
  return null
}, e0 = function(s) {
  const t = this.itemsGrid,
    w = tn(this, Zr, Ra).call(this);
  if (!w) return 0;
  const z = tn(this, Zr, bf).call(this, w, t);
  if (!z) return 0;
  let E = null;
  const k = s.altKey ? 1 : 0;
  if (s.altKey && z.rowIndex === t.length - 2 && !this.opts.loop.current) E = tn(this, Zr, Ul).call(this, {
    start: t.length - 1,
    end: t.length,
    expectedColumnIndex: z.columnIndex,
    grid: t
  });
  else if (z.rowIndex === t.length - 1) {
    if (!this.opts.loop.current) return 0;
    E = tn(this, Zr, Ul).call(this, {
      start: 0 + k,
      end: z.rowIndex,
      expectedColumnIndex: z.columnIndex,
      grid: t
    })
  } else E = tn(this, Zr, Ul).call(this, {
    start: z.rowIndex + 1 + k,
    end: t.length,
    expectedColumnIndex: z.columnIndex,
    grid: t
  }), E === null && this.opts.loop.current && (E = tn(this, Zr, Ul).call(this, {
    start: 0,
    end: z.rowIndex,
    expectedColumnIndex: z.columnIndex,
    grid: t
  }));
  return tn(this, Zr, xf).call(this, w, E)
}, Ul = function({
  start: s,
  end: t,
  grid: w,
  expectedColumnIndex: z
}) {
  var k;
  let E = null;
  for (let c = s; c < t; c++) {
    const R = w[c];
    if (E = ((k = R[z]) == null ? void 0 : k.ref) ?? null, E !== null && td(E)) {
      E = null;
      continue
    }
    if (E === null)
      for (let X = R.length - 1; X >= 0; X--) {
        const $ = R[R.length - 1];
        if (!($ === void 0 || td($.ref))) {
          E = $.ref;
          break
        }
      }
    break
  }
  return E
}, xf = function(s, t) {
  if (t === null) return 0;
  const w = this.getValidItems(),
    z = w.findIndex(k => k === s);
  return w.findIndex(k => k === t) - z
}, wf = function(s) {
  this.opts.columns.current !== null && (s.preventDefault(), s.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(tn(this, Zr, r0).call(this, s)))
}, r0 = function(s) {
  const t = this.itemsGrid,
    w = tn(this, Zr, Ra).call(this);
  if (w === void 0) return 0;
  const z = tn(this, Zr, bf).call(this, w, t);
  if (z === null) return 0;
  let E = null;
  const k = s.altKey ? 1 : 0;
  if (s.altKey && z.rowIndex === 1 && this.opts.loop.current === !1) E = tn(this, Zr, Zl).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: z.columnIndex,
    grid: t
  });
  else if (z.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    E = tn(this, Zr, Zl).call(this, {
      start: t.length - 1 - k,
      end: z.rowIndex + 1,
      expectedColumnIndex: z.columnIndex,
      grid: t
    })
  } else E = tn(this, Zr, Zl).call(this, {
    start: z.rowIndex - 1 - k,
    end: 0,
    expectedColumnIndex: z.columnIndex,
    grid: t
  }), E === null && this.opts.loop.current && (E = tn(this, Zr, Zl).call(this, {
    start: t.length - 1,
    end: z.rowIndex + 1,
    expectedColumnIndex: z.columnIndex,
    grid: t
  }));
  return tn(this, Zr, xf).call(this, w, E)
}, Zl = function({
  start: s,
  end: t,
  grid: w,
  expectedColumnIndex: z
}) {
  var k;
  let E = null;
  for (let c = s; c >= t; c--) {
    const R = w[c];
    if (R !== void 0) {
      if (E = ((k = R[z]) == null ? void 0 : k.ref) ?? null, E !== null && td(E)) {
        E = null;
        continue
      }
      if (E === null)
        for (let X = R.length - 1; X >= 0; X--) {
          const $ = R[R.length - 1];
          if (!($ === void 0 || td($.ref))) {
            E = $.ref;
            break
          }
        }
      break
    }
  }
  return E
}, Gl = function(s) {
  s.preventDefault(), s.metaKey ? this.updateSelectedToIndex(0) : s.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, c_ = new WeakMap;
let mf = pm;

function td(l) {
  return l.getAttribute("aria-disabled") === "true"
}
var l_, __, h_;
const fm = class fm {
  constructor(s, t) {
    dn(this, "opts");
    dn(this, "root");
    dn(this, "attachment");
    yn(this, l_, ge(() => this.root._commandState.filtered.count === 0 && We(this, __) === !1 || this.opts.forceMount.current));
    yn(this, __, !0);
    yn(this, h_, ge(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [Fo.empty]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = t, this.attachment = ma(this.opts.ref), Bf(() => {
      Mo(this, __, !1)
    })
  }
  static create(s) {
    return new fm(s, bu.get())
  }
  get shouldRender() {
    return y(We(this, l_))
  }
  set shouldRender(s) {
    Y(We(this, l_), s)
  }
  get props() {
    return y(We(this, h_))
  }
  set props(s) {
    Y(We(this, h_), s)
  }
};
l_ = new WeakMap, __ = new WeakMap, h_ = new WeakMap;
let kf = fm;
var d_, p_, f_, m_;
const mm = class mm {
  constructor(s, t) {
    dn(this, "opts");
    dn(this, "root");
    dn(this, "attachment");
    yn(this, d_, ge(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    yn(this, p_, ee(null));
    yn(this, f_, ee(""));
    yn(this, m_, ge(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [Fo.group]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = t, this.attachment = ma(this.opts.ref), this.trueValue = s.value.current ?? s.id.current, Ac(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), cn(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(s) {
    return Xl.set(new mm(s, bu.get()))
  }
  get shouldRender() {
    return y(We(this, d_))
  }
  set shouldRender(s) {
    Y(We(this, d_), s)
  }
  get headingNode() {
    return y(We(this, p_))
  }
  set headingNode(s) {
    Y(We(this, p_), s, !0)
  }
  get trueValue() {
    return y(We(this, f_))
  }
  set trueValue(s) {
    Y(We(this, f_), s, !0)
  }
  get props() {
    return y(We(this, m_))
  }
  set props(s) {
    Y(We(this, m_), s)
  }
};
d_ = new WeakMap, p_ = new WeakMap, f_ = new WeakMap, m_ = new WeakMap;
let Tf = mm;
var g_;
const gm = class gm {
  constructor(s, t) {
    dn(this, "opts");
    dn(this, "group");
    dn(this, "attachment");
    yn(this, g_, ge(() => ({
      id: this.opts.id.current,
      [Fo["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = s, this.group = t, this.attachment = ma(this.opts.ref, w => this.group.headingNode = w)
  }
  static create(s) {
    return new gm(s, Xl.get())
  }
  get props() {
    return y(We(this, g_))
  }
  set props(s) {
    Y(We(this, g_), s)
  }
};
g_ = new WeakMap;
let Sf = gm;
var y_;
const ym = class ym {
  constructor(s, t) {
    dn(this, "opts");
    dn(this, "group");
    dn(this, "attachment");
    yn(this, y_, ge(() => {
      var s;
      return {
        id: this.opts.id.current,
        role: "group",
        [Fo["group-items"]]: "",
        "aria-labelledby": ((s = this.group.headingNode) == null ? void 0 : s.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = s, this.group = t, this.attachment = ma(this.opts.ref)
  }
  static create(s) {
    return new ym(s, Xl.get())
  }
  get props() {
    return y(We(this, y_))
  }
  set props(s) {
    Y(We(this, y_), s)
  }
};
y_ = new WeakMap;
let Pf = ym;
var xd, v_;
const vm = class vm {
  constructor(s, t) {
    dn(this, "opts");
    dn(this, "root");
    dn(this, "attachment");
    yn(this, xd, ge(() => {
      var t;
      const s = (t = this.root.viewportNode) == null ? void 0 : t.querySelector(`${Kv}[${pu}="${Yv(this.root.opts.value.current)}"]`);
      if (s != null) return s.getAttribute("id") ?? void 0
    }));
    yn(this, v_, ge(() => {
      var s, t;
      return {
        id: this.opts.id.current,
        type: "text",
        [Fo.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": pf(!0),
        "aria-controls": ((s = this.root.viewportNode) == null ? void 0 : s.id) ?? void 0,
        "aria-labelledby": ((t = this.root.labelNode) == null ? void 0 : t.id) ?? void 0,
        "aria-activedescendant": y(We(this, xd)),
        ...this.attachment
      }
    }));
    this.opts = s, this.root = t, this.attachment = ma(this.opts.ref, w => this.root.inputNode = w), Ac(() => this.opts.ref.current, () => {
      const w = this.opts.ref.current;
      w && this.opts.autofocus.current && rke(10, () => w.focus())
    }), Ac(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(s) {
    return new vm(s, bu.get())
  }
  get props() {
    return y(We(this, v_))
  }
  set props(s) {
    Y(We(this, v_), s)
  }
};
xd = new WeakMap, v_ = new WeakMap;
let Mf = vm;
var Fa, wd, b_, x_, w_, yu, n0, If, k_;
const bm = class bm {
  constructor(s, t) {
    yn(this, yu);
    dn(this, "opts");
    dn(this, "root");
    dn(this, "attachment");
    yn(this, Fa, null);
    yn(this, wd, ge(() => {
      var s;
      return this.opts.forceMount.current || ((s = We(this, Fa)) == null ? void 0 : s.opts.forceMount.current) === !0
    }));
    yn(this, b_, ge(() => {
      if (this.opts.ref.current, y(We(this, wd)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const s = this.root.commandState.filtered.items.get(this.trueValue);
      return s === void 0 ? !1 : s > 0
    }));
    yn(this, x_, ge(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    yn(this, w_, ee(""));
    yn(this, k_, ge(() => {
      var s;
      return {
        id: this.opts.id.current,
        "aria-disabled": pf(this.opts.disabled.current),
        "aria-selected": pf(this.isSelected),
        "data-disabled": Ry(this.opts.disabled.current),
        "data-selected": Ry(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (s = We(this, Fa)) == null ? void 0 : s.trueValue,
        [Fo.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = t, Mo(this, Fa, Xl.getOr(null)), this.trueValue = s.value.current, this.attachment = ma(this.opts.ref), Ac([() => this.trueValue, () => {
      var w;
      return (w = We(this, Fa)) == null ? void 0 : w.trueValue
    }, () => this.opts.forceMount.current], () => {
      var w;
      if (!(this.opts.forceMount.current || !this.trueValue)) return this.root.registerItem(this.trueValue, (w = We(this, Fa)) == null ? void 0 : w.trueValue)
    }), Ac([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var w, z;
      this.opts.value.current ? this.trueValue = this.opts.value.current : (w = this.opts.ref.current) != null && w.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, s.keywords.current.map(E => E.trim())), (z = this.opts.ref.current) == null || z.setAttribute(pu, this.trueValue))
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(s) {
    const t = Xl.getOr(null);
    return new bm({
      ...s,
      group: t
    }, bu.get())
  }
  get shouldRender() {
    return y(We(this, b_))
  }
  set shouldRender(s) {
    Y(We(this, b_), s)
  }
  get isSelected() {
    return y(We(this, x_))
  }
  set isSelected(s) {
    Y(We(this, x_), s)
  }
  get trueValue() {
    return y(We(this, w_))
  }
  set trueValue(s) {
    Y(We(this, w_), s, !0)
  }
  onpointermove(s) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || tn(this, yu, If).call(this)
  }
  onclick(s) {
    this.opts.disabled.current || tn(this, yu, n0).call(this)
  }
  get props() {
    return y(We(this, k_))
  }
  set props(s) {
    Y(We(this, k_), s)
  }
};
Fa = new WeakMap, wd = new WeakMap, b_ = new WeakMap, x_ = new WeakMap, w_ = new WeakMap, yu = new WeakSet, n0 = function() {
  var s;
  this.opts.disabled.current || (tn(this, yu, If).call(this), (s = this.opts.onSelect) == null || s.current())
}, If = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, k_ = new WeakMap;
let Cf = bm;
var T_;
const xm = class xm {
  constructor(s, t) {
    dn(this, "opts");
    dn(this, "root");
    dn(this, "attachment");
    yn(this, T_, ge(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [Fo.list]: "",
      ...this.attachment
    })));
    this.opts = s, this.root = t, this.attachment = ma(this.opts.ref)
  }
  static create(s) {
    return wke.set(new xm(s, bu.get()))
  }
  get props() {
    return y(We(this, T_))
  }
  set props(s) {
    Y(We(this, T_), s)
  }
};
T_ = new WeakMap;
let zf = xm;
var S_;
const wm = class wm {
  constructor(s, t) {
    dn(this, "opts");
    dn(this, "root");
    dn(this, "attachment");
    yn(this, S_, ge(() => {
      var s;
      return {
        id: this.opts.id.current,
        [Fo["input-label"]]: "",
        for: (s = this.opts.for) == null ? void 0 : s.current,
        style: $v,
        ...this.attachment
      }
    }));
    this.opts = s, this.root = t, this.attachment = ma(this.opts.ref, w => this.root.labelNode = w)
  }
  static create(s) {
    return new wm(s, bu.get())
  }
  get props() {
    return y(We(this, S_))
  }
  set props(s) {
    Y(We(this, S_), s)
  }
};
S_ = new WeakMap;
let Af = wm;
var kke = ft("<label><!></label>");

function Tke(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "id", 19, () => ga(t)),
    z = $e(s, "ref", 15, null),
    E = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const k = Af.create({
      id: Nn(() => w()),
      ref: Nn(() => z(), $ => z($))
    }),
    c = ge(() => fa(E, k.props));
  var R = kke();
  Er(R, () => ({
    ...y(c)
  }));
  var X = C(R);
  Bi(X, () => s.children ?? Yo), P(R), Z(l, R), rn()
}
var Ske = ft("<!> <!>", 1),
  Pke = ft("<div><!> <!></div>");

function Mke(l, s) {
  const t = da();
  en(s, !0);
  const w = Ut => {
    Tke(Ut, {
      children: (Xt, me) => {
        Mn();
        var Ce = to();
        Bt(() => at(Ce, ut())), Z(Xt, Ce)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let z = $e(s, "id", 19, () => ga(t)),
    E = $e(s, "ref", 15, null),
    k = $e(s, "value", 15, ""),
    c = $e(s, "onValueChange", 3, ff),
    R = $e(s, "onStateChange", 3, ff),
    X = $e(s, "loop", 3, !1),
    $ = $e(s, "shouldFilter", 3, !0),
    tt = $e(s, "filter", 3, o0),
    ut = $e(s, "label", 3, ""),
    xt = $e(s, "vimBindings", 3, !0),
    lt = $e(s, "disablePointerSelection", 3, !1),
    G = $e(s, "disableInitialScroll", 3, !1),
    yt = $e(s, "columns", 3, null),
    Lt = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const Dt = mf.create({
      id: Nn(() => z()),
      ref: Nn(() => E(), Ut => E(Ut)),
      filter: Nn(() => tt()),
      shouldFilter: Nn(() => $()),
      loop: Nn(() => X()),
      value: Nn(() => k(), Ut => {
        k() !== Ut && (k(Ut), c()(Ut))
      }),
      vimBindings: Nn(() => xt()),
      disablePointerSelection: Nn(() => lt()),
      disableInitialScroll: Nn(() => G()),
      onStateChange: Nn(() => R()),
      columns: Nn(() => yt())
    }),
    St = Ut => Dt.updateSelectedToIndex(Ut),
    qt = Ut => Dt.updateSelectedByGroup(Ut),
    Vt = Ut => Dt.updateSelectedByItem(Ut),
    Zt = () => Dt.getValidItems(),
    Et = ge(() => fa(Lt, Dt.props));
  var Ct = {
      updateSelectedToIndex: St,
      updateSelectedByGroup: qt,
      updateSelectedByItem: Vt,
      getValidItems: Zt
    },
    Wt = kr(),
    jt = xe(Wt);
  {
    var Ht = Ut => {
        var Xt = Ske(),
          me = xe(Xt);
        w(me);
        var Ce = D(me, 2);
        Bi(Ce, () => s.child, () => ({
          props: y(Et)
        })), Z(Ut, Xt)
      },
      _e = Ut => {
        var Xt = Pke();
        Er(Xt, () => ({
          ...y(Et)
        }));
        var me = C(Xt);
        w(me);
        var Ce = D(me, 2);
        Bi(Ce, () => s.children ?? Yo), P(Xt), Z(Ut, Xt)
      };
    At(jt, Ut => {
      s.child ? Ut(Ht) : Ut(_e, !1)
    })
  }
  return Z(l, Wt), rn(Ct)
}
var Cke = ft("<div><!></div>");

function Ike(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "id", 19, () => ga(t)),
    z = $e(s, "ref", 15, null),
    E = $e(s, "forceMount", 3, !1),
    k = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const c = kf.create({
      id: Nn(() => w()),
      ref: Nn(() => z(), ut => z(ut)),
      forceMount: Nn(() => E())
    }),
    R = ge(() => fa(c.props, k));
  var X = kr(),
    $ = xe(X);
  {
    var tt = ut => {
      var xt = kr(),
        lt = xe(xt);
      {
        var G = Lt => {
            var Dt = kr(),
              St = xe(Dt);
            Bi(St, () => s.child, () => ({
              props: y(R)
            })), Z(Lt, Dt)
          },
          yt = Lt => {
            var Dt = Cke();
            Er(Dt, () => ({
              ...y(R)
            }));
            var St = C(Dt);
            Bi(St, () => s.children ?? Yo), P(Dt), Z(Lt, Dt)
          };
        At(lt, Lt => {
          s.child ? Lt(G) : Lt(yt, !1)
        })
      }
      Z(ut, xt)
    };
    At($, ut => {
      c.shouldRender && ut(tt)
    })
  }
  Z(l, X), rn()
}
var zke = ft("<div><!></div>");

function Ake(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "id", 19, () => ga(t)),
    z = $e(s, "ref", 15, null),
    E = $e(s, "value", 3, ""),
    k = $e(s, "forceMount", 3, !1),
    c = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const R = Tf.create({
      id: Nn(() => w()),
      ref: Nn(() => z(), lt => z(lt)),
      forceMount: Nn(() => k()),
      value: Nn(() => E())
    }),
    X = ge(() => fa(c, R.props));
  var $ = kr(),
    tt = xe($);
  {
    var ut = lt => {
        var G = kr(),
          yt = xe(G);
        Bi(yt, () => s.child, () => ({
          props: y(X)
        })), Z(lt, G)
      },
      xt = lt => {
        var G = zke();
        Er(G, () => ({
          ...y(X)
        }));
        var yt = C(G);
        Bi(yt, () => s.children ?? Yo), P(G), Z(lt, G)
      };
    At(tt, lt => {
      s.child ? lt(ut) : lt(xt, !1)
    })
  }
  Z(l, $), rn()
}
var Eke = ft("<div><!></div>");

function jke(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "id", 19, () => ga(t)),
    z = $e(s, "ref", 15, null),
    E = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const k = Sf.create({
      id: Nn(() => w()),
      ref: Nn(() => z(), ut => z(ut))
    }),
    c = ge(() => fa(E, k.props));
  var R = kr(),
    X = xe(R);
  {
    var $ = ut => {
        var xt = kr(),
          lt = xe(xt);
        Bi(lt, () => s.child, () => ({
          props: y(c)
        })), Z(ut, xt)
      },
      tt = ut => {
        var xt = Eke();
        Er(xt, () => ({
          ...y(c)
        }));
        var lt = C(xt);
        Bi(lt, () => s.children ?? Yo), P(xt), Z(ut, xt)
      };
    At(X, ut => {
      s.child ? ut($) : ut(tt, !1)
    })
  }
  Z(l, R), rn()
}
var Lke = ft("<div><!></div>"),
  Dke = ft('<div style="display: contents;"><!></div>');

function Rke(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "id", 19, () => ga(t)),
    z = $e(s, "ref", 15, null),
    E = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const k = Pf.create({
      id: Nn(() => w()),
      ref: Nn(() => z(), ut => z(ut))
    }),
    c = ge(() => fa(E, k.props));
  var R = Dke(),
    X = C(R);
  {
    var $ = ut => {
        var xt = kr(),
          lt = xe(xt);
        Bi(lt, () => s.child, () => ({
          props: y(c)
        })), Z(ut, xt)
      },
      tt = ut => {
        var xt = Lke();
        Er(xt, () => ({
          ...y(c)
        }));
        var lt = C(xt);
        Bi(lt, () => s.children ?? Yo), P(xt), Z(ut, xt)
      };
    At(X, ut => {
      s.child ? ut($) : ut(tt, !1)
    })
  }
  P(R), Z(l, R), rn()
}
var Bke = ft("<input/>");

function Fke(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "value", 15, ""),
    z = $e(s, "autofocus", 3, !1),
    E = $e(s, "id", 19, () => ga(t)),
    k = $e(s, "ref", 15, null),
    c = Ir(s, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const R = Mf.create({
      id: Nn(() => E()),
      ref: Nn(() => k(), lt => k(lt)),
      value: Nn(() => w(), lt => {
        w(lt)
      }),
      autofocus: Nn(() => z() ?? !1)
    }),
    X = ge(() => fa(c, R.props));
  var $ = kr(),
    tt = xe($);
  {
    var ut = lt => {
        var G = kr(),
          yt = xe(G);
        Bi(yt, () => s.child, () => ({
          props: y(X)
        })), Z(lt, G)
      },
      xt = lt => {
        var G = Bke();
        Er(G, () => ({
          ...y(X)
        }), void 0, void 0, void 0, void 0, !0), M_(G, w), Z(lt, G)
      };
    At(tt, lt => {
      s.child ? lt(ut) : lt(xt, !1)
    })
  }
  Z(l, $), rn()
}
var Oke = ft("<div><!></div>"),
  qke = ft('<div style="display: contents;" data-item-wrapper=""><!></div>');

function Nke(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "id", 19, () => ga(t)),
    z = $e(s, "ref", 15, null),
    E = $e(s, "value", 3, ""),
    k = $e(s, "disabled", 3, !1),
    c = $e(s, "onSelect", 3, ff),
    R = $e(s, "forceMount", 3, !1),
    X = $e(s, "keywords", 19, () => []),
    $ = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const tt = Cf.create({
      id: Nn(() => w()),
      ref: Nn(() => z(), G => z(G)),
      value: Nn(() => E()),
      disabled: Nn(() => k()),
      onSelect: Nn(() => c()),
      forceMount: Nn(() => R()),
      keywords: Nn(() => X())
    }),
    ut = ge(() => fa($, tt.props));
  var xt = kr(),
    lt = xe(xt);
  Hl(lt, () => tt.root.key, G => {
    var yt = qke(),
      Lt = C(yt);
    {
      var Dt = St => {
        var qt = kr(),
          Vt = xe(qt);
        {
          var Zt = Ct => {
              var Wt = kr(),
                jt = xe(Wt);
              Bi(jt, () => s.child, () => ({
                props: y(ut)
              })), Z(Ct, Wt)
            },
            Et = Ct => {
              var Wt = Oke();
              Er(Wt, () => ({
                ...y(ut)
              }));
              var jt = C(Wt);
              Bi(jt, () => s.children ?? Yo), P(Wt), Z(Ct, Wt)
            };
          At(Vt, Ct => {
            s.child ? Ct(Zt) : Ct(Et, !1)
          })
        }
        Z(St, qt)
      };
      At(Lt, St => {
        tt.shouldRender && St(Dt)
      })
    }
    P(yt), Bt(() => pr(yt, "data-value", tt.trueValue)), Z(G, yt)
  }), Z(l, xt), rn()
}
var Vke = ft("<div><!></div>");

function Uke(l, s) {
  const t = da();
  en(s, !0);
  let w = $e(s, "id", 19, () => ga(t)),
    z = $e(s, "ref", 15, null),
    E = Ir(s, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const k = zf.create({
      id: Nn(() => w()),
      ref: Nn(() => z(), $ => z($)),
      ariaLabel: Nn(() => s["aria-label"] ?? "Suggestions...")
    }),
    c = ge(() => fa(E, k.props));
  var R = kr(),
    X = xe(R);
  Hl(X, () => k.root._commandState.search === "", $ => {
    var tt = kr(),
      ut = xe(tt);
    {
      var xt = G => {
          var yt = kr(),
            Lt = xe(yt);
          Bi(Lt, () => s.child, () => ({
            props: y(c)
          })), Z(G, yt)
        },
        lt = G => {
          var yt = Vke();
          Er(yt, () => ({
            ...y(c)
          }));
          var Lt = C(yt);
          Bi(Lt, () => s.children ?? Yo), P(yt), Z(G, yt)
        };
      At(ut, G => {
        s.child ? G(xt) : G(lt, !1)
      })
    }
    Z($, tt)
  }), Z(l, R), rn()
}
const Oy = 1,
  Zke = .9,
  Gke = .8,
  Hke = .17,
  Wp = .1,
  $p = .999,
  Wke = .9999,
  $ke = .99,
  Xke = /[\\/_+.#"@[({&]/,
  Yke = /[\\/_+.#"@[({&]/g,
  Kke = /[\s-]/,
  i0 = /[\s-]/g;

function Ef(l, s, t, w, z, E, k) {
  if (E === s.length) return z === l.length ? Oy : $ke;
  const c = `${z},${E}`;
  if (k[c] !== void 0) return k[c];
  const R = w.charAt(E);
  let X = t.indexOf(R, z),
    $ = 0,
    tt, ut, xt, lt;
  for (; X >= 0;) tt = Ef(l, s, t, w, X + 1, E + 1, k), tt > $ && (X === z ? tt *= Oy : Xke.test(l.charAt(X - 1)) ? (tt *= Gke, xt = l.slice(z, X - 1).match(Yke), xt && z > 0 && (tt *= $p ** xt.length)) : Kke.test(l.charAt(X - 1)) ? (tt *= Zke, lt = l.slice(z, X - 1).match(i0), lt && z > 0 && (tt *= $p ** lt.length)) : (tt *= Hke, z > 0 && (tt *= $p ** (X - z))), l.charAt(X) !== s.charAt(E) && (tt *= Wke)), (tt < Wp && t.charAt(X - 1) === w.charAt(E + 1) || w.charAt(E + 1) === w.charAt(E) && t.charAt(X - 1) !== w.charAt(E)) && (ut = Ef(l, s, t, w, X + 1, E + 2, k), ut * Wp > tt && (tt = ut * Wp)), tt > $ && ($ = tt), X = t.indexOf(R, X + 1);
  return k[c] = $, $
}

function qy(l) {
  return l.toLowerCase().replace(i0, " ")
}

function o0(l, s, t) {
  return l = t && t.length > 0 ? `${`${l} ${t==null?void 0:t.join(" ")}`}` : l, Ef(l, s, qy(l), qy(s), 0, 0, {})
}

function jc(...l) {
  return h1(ed(l))
}

function Jke(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15, null),
    w = $e(s, "value", 15, ""),
    z = Ir(s, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var E = kr(),
    k = xe(E);
  {
    let c = ge(() => jc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", s.class));
    bo(k, () => Mke, (R, X) => {
      X(R, Ec({
        "data-slot": "command",
        get class() {
          return y(c)
        }
      }, () => z, {
        get value() {
          return w()
        },
        set value($) {
          w($)
        },
        get ref() {
          return t()
        },
        set ref($) {
          t($)
        }
      }))
    })
  }
  Z(l, E), rn()
}

function Qke(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15, null),
    w = Ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = kr(),
    E = xe(z);
  {
    let k = ge(() => jc("py-6 text-center text-sm", s.class));
    bo(E, () => Ike, (c, R) => {
      R(c, Ec({
        "data-slot": "command-empty",
        get class() {
          return y(k)
        }
      }, () => w, {
        get ref() {
          return t()
        },
        set ref(X) {
          t(X)
        }
      }))
    })
  }
  Z(l, z), rn()
}
var t5e = ft("<!> <!>", 1);

function e5e(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15, null),
    w = Ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var z = kr(),
    E = xe(z);
  {
    let k = ge(() => jc("text-foreground overflow-hidden p-1", s.class)),
      c = ge(() => s.value ?? s.heading ?? `----${vke()}`);
    bo(E, () => Ake, (R, X) => {
      X(R, Ec({
        "data-slot": "command-group",
        get class() {
          return y(k)
        },
        get value() {
          return y(c)
        }
      }, () => w, {
        get ref() {
          return t()
        },
        set ref($) {
          t($)
        },
        children: ($, tt) => {
          var ut = t5e(),
            xt = xe(ut);
          {
            var lt = yt => {
              var Lt = kr(),
                Dt = xe(Lt);
              bo(Dt, () => jke, (St, qt) => {
                qt(St, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (Vt, Zt) => {
                    Mn();
                    var Et = to();
                    Bt(() => at(Et, s.heading)), Z(Vt, Et)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), Z(yt, Lt)
            };
            At(xt, yt => {
              s.heading && yt(lt)
            })
          }
          var G = D(xt, 2);
          bo(G, () => Rke, (yt, Lt) => {
            Lt(yt, {
              get children() {
                return s.children
              }
            })
          }), Z($, ut)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  Z(l, z), rn()
}

function r5e(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15, null),
    w = Ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = kr(),
    E = xe(z);
  {
    let k = ge(() => jc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", s.class));
    bo(E, () => Nke, (c, R) => {
      R(c, Ec({
        "data-slot": "command-item",
        get class() {
          return y(k)
        }
      }, () => w, {
        get ref() {
          return t()
        },
        set ref(X) {
          t(X)
        }
      }))
    })
  }
  Z(l, z), rn()
}
var n5e = ft('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function i5e(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15, null),
    w = $e(s, "value", 15, ""),
    z = Ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var E = n5e(),
    k = C(E);
  Gx(k, {
    class: "size-5 opacity-50"
  });
  var c = D(k, 2);
  {
    let R = ge(() => jc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", s.class));
    bo(c, () => Fke, (X, $) => {
      $(X, Ec({
        "data-slot": "command-input",
        get class() {
          return y(R)
        }
      }, () => z, {
        get ref() {
          return t()
        },
        set ref(tt) {
          t(tt)
        },
        get value() {
          return w()
        },
        set value(tt) {
          w(tt)
        }
      }))
    })
  }
  P(E), Z(l, E), rn()
}

function o5e(l, s) {
  en(s, !0);
  let t = $e(s, "ref", 15, null),
    w = Ir(s, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = kr(),
    E = xe(z);
  {
    let k = ge(() => jc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", s.class));
    bo(E, () => Uke, (c, R) => {
      R(c, Ec({
        "data-slot": "command-list",
        get class() {
          return y(k)
        }
      }, () => w, {
        get ref() {
          return t()
        },
        set ref(X) {
          t(X)
        }
      }))
    })
  }
  Z(l, z), rn()
}
var s5e = $r('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function a5e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = s5e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var u5e = ft("<span> </span> <!>", 1),
  c5e = ft('<span class="font-flag ml-0.5"> </span> ', 1),
  l5e = ft('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  _5e = ft("<!> <!>", 1),
  h5e = ft("<!> <!>", 1),
  d5e = ft('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  p5e = ft('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function Ny(l, s) {
  en(s, !0);
  let t = $e(s, "countryId", 15, 0),
    w = $e(s, "dropdownDirection", 3, "right"),
    z = ee(null),
    E = ee(null),
    k = ee("");

  function c() {
    Ff().then(() => {
      var St;
      (St = document.activeElement) == null || St.blur(), Y(k, "")
    })
  }
  var R = p5e(),
    X = C(R),
    $ = C(X),
    tt = C($);
  {
    var ut = St => {
        var qt = u5e(),
          Vt = xe(qt),
          Zt = C(Vt, !0);
        P(Vt);
        var Et = D(Vt, 2);
        a5e(Et, {
          class: "size-3.5"
        }), Bt(Ct => at(Zt, Ct), [() => Jf()]), Z(St, qt)
      },
      xt = St => {
        const qt = ge(() => Ls(t()));
        var Vt = c5e(),
          Zt = xe(Vt),
          Et = C(Zt, !0);
        P(Zt);
        var Ct = D(Zt);
        Bt(() => {
          at(Et, y(qt).flag), at(Ct, ` ${y(qt).name??""}`)
        }), Z(St, Vt)
      };
    At(tt, St => {
      t() === 0 ? St(ut) : St(xt, !1)
    })
  }
  P($);
  var lt = D($, 2);
  let G;
  var yt = C(lt);
  bo(yt, () => Jke, (St, qt) => {
    qt(St, {
      children: (Vt, Zt) => {
        var Et = h5e(),
          Ct = xe(Et);
        bo(Ct, () => i5e, (jt, Ht) => {
          Ht(jt, {
            placeholder: "Country",
            get ref() {
              return y(z)
            },
            set ref(_e) {
              Y(z, _e)
            },
            get value() {
              return y(k)
            },
            set value(_e) {
              Y(k, _e, !0)
            }
          })
        });
        var Wt = D(Ct, 2);
        bo(Wt, () => o5e, (jt, Ht) => {
          Ht(jt, {
            children: (_e, Ut) => {
              var Xt = _5e(),
                me = xe(Xt);
              bo(me, () => Qke, (Ve, Ie) => {
                Ie(Ve, {
                  children: (ne, Xe) => {
                    Mn();
                    var pe = to();
                    Bt(Ue => at(pe, Ue), [() => e7()]), Z(ne, pe)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var Ce = D(me, 2);
              bo(Ce, () => e5e, (Ve, Ie) => {
                Ie(Ve, {
                  children: (ne, Xe) => {
                    var pe = kr(),
                      Ue = xe(pe);
                    di(Ue, 17, () => Ao.countries, Ae => Ae.id, (Ae, He) => {
                      var Tr = kr(),
                        Ye = xe(Tr);
                      bo(Ye, () => r5e, (mr, se) => {
                        se(mr, {
                          get value() {
                            return y(He).name
                          },
                          onSelect: () => {
                            t(y(He).id), c()
                          },
                          children: (ce, ur) => {
                            var Ke = l5e(),
                              ve = C(Ke),
                              _r = C(ve, !0);
                            P(ve);
                            var nr = D(ve);
                            P(Ke), Bt(() => {
                              at(_r, y(He).flag), at(nr, ` ${y(He).name??""}`)
                            }), Z(ce, Ke)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), Z(Ae, Tr)
                    }), Z(ne, pe)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), Z(_e, Xt)
            },
            $$slots: {
              default: !0
            }
          })
        }), Z(Vt, Et)
      },
      $$slots: {
        default: !0
      }
    })
  }), P(lt), P(X);
  var Lt = D(X, 2);
  {
    var Dt = St => {
      var qt = d5e();
      qt.__click = () => {
        t(0)
      };
      var Vt = C(qt);
      pa(Vt, {
        class: "size-3.5"
      }), P(qt), Z(St, qt)
    };
    At(Lt, St => {
      t() != 0 && St(Dt)
    })
  }
  P(R), os(R, St => Y(E, St), () => y(E)), Bt(() => G = Gr(lt, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, G, {
    "right-1": w() === "left"
  })), jn("focus", $, () => {
    y(z).focus()
  }), Z(l, R), rn()
}
ri(["click"]);
var f5e = $r('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function s0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = f5e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var m5e = $r('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  g5e = $r('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function Yl(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var w = kr(),
    z = xe(w);
  {
    var E = c => {
        var R = m5e();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      },
      k = c => {
        var R = g5e();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      };
    At(z, c => {
      s.filled ? c(E) : c(k, !1)
    })
  }
  Z(l, w)
}
var y5e = ft('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  v5e = ft('<div class="mb-2"><!></div>'),
  b5e = ft('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  x5e = ft('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  w5e = ft('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  k5e = ft('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  T5e = ft('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  S5e = ft('<span class="font-flag tooltip ml-0.5"> </span>'),
  P5e = ft("<span> </span>"),
  M5e = ft('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  C5e = ft('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  I5e = ft('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  z5e = ft('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  A5e = ft('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  E5e = ft('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function j5e(l, s) {
  en(s, !0);
  const t = [];
  let w = ee(1e3);
  const z = ge(() => y(w) <= 640);
  let E = ee("today"),
    k = {
      regions: {
        label: u$(),
        icon: Pd
      },
      countries: {
        label: JS(),
        icon: s0
      },
      players: {
        label: yv(),
        icon: zd
      },
      alliances: {
        label: uv(),
        icon: Ad
      }
    },
    c = ee("regions"),
    R = ee(0),
    X = Qi({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    $ = ge(() => {
      var Et, Ct, Wt;
      return y(c) === "regions" ? (Ct = (Et = X[y(c)][y(R)]) == null ? void 0 : Et[y(E)]) == null ? void 0 : Ct.entries : (Wt = X[y(c)][y(E)]) == null ? void 0 : Wt.entries
    });
  const tt = 5 * 1e3;
  cn(() => {
    var jt;
    if (!s.open) return;
    const Et = y(E),
      Ct = y(c),
      Wt = y(R);
    Ct === "players" && (!X[Ct][Et] || Date.now() - X[Ct][Et].time > tt) ? fn.leaderboardPlayers(Et).then(Ht => {
      X[Ct][Et] = {
        time: Date.now(),
        entries: Ht
      }
    }).catch(Ht => Ne.error(Ht.message)) : Ct === "alliances" && (!X[Ct][Et] || Date.now() - X[Ct][Et].time > tt) ? fn.leaderboardAlliances(Et).then(Ht => {
      X[Ct][Et] = {
        time: Date.now(),
        entries: Ht
      }
    }).catch(Ht => Ne.error(Ht.message)) : Ct === "countries" && (!X[Ct][Et] || Date.now() - X[Ct][Et].time > tt) ? fn.leaderboardCountries(Et).then(Ht => {
      X[Ct][Et] = {
        time: Date.now(),
        entries: Ht
      }
    }).catch(Ht => Ne.error(Ht.message)) : Ct === "regions" && (!((jt = X[Ct][Wt]) != null && jt[Et]) || Date.now() - X[Ct][Wt][Et].time > tt) && fn.leaderboardRegions(Et, Wt).then(Ht => {
      X[Ct][Wt] || (X[Ct][Wt] = {}), X[Ct][Wt][Et] = {
        time: Date.now(),
        entries: Ht
      }
    }).catch(Ht => Ne.error(Ht.message))
  });
  var ut = E5e(),
    xt = xe(ut);
  di(xt, 21, () => Object.entries(k), ([Et, {
    label: Ct,
    icon: Wt
  }]) => Et, (Et, Ct) => {
    var Wt = ge(() => $y(y(Ct), 2));
    let jt = () => y(Wt)[0],
      Ht = () => y(Wt)[1].label,
      _e = () => y(Wt)[1].icon;
    const Ut = ge(_e);
    var Xt = y5e(),
      me = C(Xt);
    xo(me);
    var Ce, Ve = D(me, 2);
    bo(Ve, () => y(Ut), (ne, Xe) => {
      Xe(ne, {
        get this() {
          return _e()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Ie = D(Ve);
    P(Xt), Bt(() => {
      pr(me, "aria-label", Ht()), Ce !== (Ce = jt()) && (me.value = (me.__value = jt()) ?? ""), at(Ie, ` ${Ht()??""}`)
    }), Vf(t, [], me, () => (jt(), y(c)), ne => Y(c, ne)), Z(Et, Xt)
  }), P(xt);
  var lt = D(xt, 2),
    G = C(lt);
  um(G, {
    get value() {
      return y(E)
    },
    set value(Et) {
      Y(E, Et, !0)
    }
  });
  var yt = D(G, 2);
  {
    var Lt = Et => {
      Ny(Et, {
        dropdownDirection: "left",
        get countryId() {
          return y(R)
        },
        set countryId(Ct) {
          Y(R, Ct, !0)
        }
      })
    };
    At(yt, Et => {
      y(c) === "regions" && !y(z) && Et(Lt)
    })
  }
  P(lt);
  var Dt = D(lt, 2);
  {
    var St = Et => {
      var Ct = v5e(),
        Wt = C(Ct);
      Ny(Wt, {
        get countryId() {
          return y(R)
        },
        set countryId(jt) {
          Y(R, jt, !0)
        }
      }), P(Ct), Z(Et, Ct)
    };
    At(Dt, Et => {
      y(c) === "regions" && y(z) && Et(St)
    })
  }
  var qt = D(Dt, 2);
  {
    var Vt = Et => {
        var Ct = b5e(),
          Wt = C(Ct),
          jt = D(Wt);
        {
          var Ht = Ut => {
              var Xt = to();
              Bt(me => at(Xt, me), [() => Id().toLowerCase()]), Z(Ut, Xt)
            },
            _e = Ut => {
              var Xt = kr(),
                me = xe(Xt);
              {
                var Ce = Ie => {
                    var ne = to();
                    Bt(Xe => at(ne, Xe), [() => em()]), Z(Ie, ne)
                  },
                  Ve = Ie => {
                    var ne = kr(),
                      Xe = xe(ne);
                    {
                      var pe = Ue => {
                        var Ae = to();
                        Bt(He => at(Ae, He), [() => tm()]), Z(Ue, Ae)
                      };
                      At(Xe, Ue => {
                        y(E) === "month" && Ue(pe)
                      }, !0)
                    }
                    Z(Ie, ne)
                  };
                At(me, Ie => {
                  y(E) === "week" ? Ie(Ce) : Ie(Ve, !1)
                }, !0)
              }
              Z(Ut, Xt)
            };
          At(jt, Ut => {
            y(E) === "today" ? Ut(Ht) : Ut(_e, !1)
          })
        }
        P(Ct), Bt(Ut => at(Wt, `${Ut??""} `), [() => Qf()]), Z(Et, Ct)
      },
      Zt = Et => {
        var Ct = kr(),
          Wt = xe(Ct);
        {
          var jt = _e => {
              var Ut = kr(),
                Xt = xe(Ut);
              {
                var me = Ve => {
                    const Ie = ge(() => y($));
                    var ne = w5e(),
                      Xe = C(ne),
                      pe = C(Xe),
                      Ue = D(C(pe)),
                      Ae = C(Ue, !0);
                    P(Ue);
                    var He = D(Ue),
                      Tr = C(He),
                      Ye = D(Tr, 2),
                      mr = D(Ye),
                      se = C(mr);
                    Yl(se, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), P(mr), P(He), Mn(), P(pe), P(Xe);
                    var ce = D(Xe);
                    di(ce, 31, () => y(Ie), ur => ur.id, (ur, Ke, ve) => {
                      const _r = ge(() => Ls(y(Ke).countryId));
                      var nr = x5e(),
                        gr = C(nr),
                        ir = C(gr, !0);
                      P(gr);
                      var Ze = D(gr),
                        or = C(Ze),
                        de = C(or, !0);
                      P(or);
                      var zr = D(or, 2),
                        er = C(zr),
                        hr = D(er),
                        Mr = C(hr);
                      P(hr), P(zr), P(Ze);
                      var Pr = D(Ze),
                        Or = C(Pr, !0);
                      P(Pr);
                      var jr = D(Pr),
                        Lr = C(jr);
                      Lr.__click = () => {
                        s.onvisitclick({
                          lat: y(Ke).lastLatitude,
                          lng: y(Ke).lastLongitude
                        })
                      };
                      var _n = C(Lr, !0);
                      P(Lr), P(jr), P(nr), Bt((dr, ct, q) => {
                        at(ir, y(ve) + 1), pr(or, "data-tip", y(_r).name), at(de, y(_r).flag), Gr(zr, 1, `font-semibold ${dr??""}`), at(er, `${y(Ke).name??""} `), at(Mr, `#${y(Ke).number??""}`), at(Or, ct), at(_n, q)
                      }, [() => Ji(y(Ke).cityId), () => y(Ke).pixelsPainted.toLocaleString("en-US"), () => p1()]), fu(nr, () => mu, () => ({
                        duration: 200
                      })), Z(ur, nr)
                    }), P(ce), P(ne), Bt((ur, Ke, ve, _r) => {
                      at(Ae, ur), at(Tr, `${Ke??""} `), at(Ye, `${ve??""} `), pr(mr, "data-tip", _r)
                    }, [() => XW(), () => Sc(), () => Tc().toLowerCase(), () => AZ()]), Z(Ve, ne)
                  },
                  Ce = Ve => {
                    var Ie = kr(),
                      ne = xe(Ie);
                    {
                      var Xe = Ue => {
                          var Ae = T5e(),
                            He = C(Ae),
                            Tr = C(He),
                            Ye = D(C(Tr)),
                            mr = C(Ye, !0);
                          P(Ye);
                          var se = D(Ye),
                            ce = C(se),
                            ur = D(ce, 2),
                            Ke = D(ur),
                            ve = C(Ke);
                          Yl(ve, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), P(Ke), P(se), P(Tr), P(He);
                          var _r = D(He);
                          di(_r, 31, () => y($), nr => nr.id, (nr, gr, ir) => {
                            const Ze = ge(() => Ls(y(gr).id) ?? {
                              name: `Pais ID: ${y(gr).id}`,
                              flag: "ğŸ³ï¸",
                              code: "XX"
                            });
                            var or = k5e(),
                              de = C(or),
                              zr = C(de, !0);
                            P(de);
                            var er = D(de),
                              hr = C(er),
                              Mr = C(hr, !0);
                            P(hr);
                            var Pr = D(hr, 2),
                              Or = C(Pr, !0);
                            P(Pr), P(er);
                            var jr = D(er),
                              Lr = C(jr, !0);
                            P(jr), P(or), Bt((_n, dr) => {
                              at(zr, y(ir) + 1), pr(hr, "data-tip", y(Ze).name), at(Mr, y(Ze).flag), Gr(Pr, 1, `font-semibold ${_n??""}`), at(Or, y(Ze).name), at(Lr, dr)
                            }, [() => Ji(y(gr).id), () => y(gr).pixelsPainted.toLocaleString("en-US")]), fu(or, () => mu, () => ({
                              duration: 200
                            })), Z(nr, or)
                          }), P(_r), P(Ae), Bt((nr, gr, ir, Ze) => {
                            at(mr, nr), at(ce, `${gr??""} `), at(ur, `${ir??""} `), pr(Ke, "data-tip", Ze)
                          }, [() => Jf(), () => Sc(), () => Tc().toLowerCase(), () => yZ()]), Z(Ue, Ae)
                        },
                        pe = Ue => {
                          var Ae = kr(),
                            He = xe(Ae);
                          {
                            var Tr = mr => {
                                const se = ge(() => y($));
                                var ce = C5e(),
                                  ur = C(ce),
                                  Ke = C(ur),
                                  ve = D(C(Ke)),
                                  _r = C(ve, !0);
                                P(ve);
                                var nr = D(ve),
                                  gr = C(nr),
                                  ir = D(gr, 2, !0);
                                P(nr), P(Ke), P(ur);
                                var Ze = D(ur);
                                di(Ze, 31, () => y(se), or => or.id, (or, de, zr) => {
                                  const er = ge(() => {
                                    var et;
                                    return ((et = ze.data) == null ? void 0 : et.id) === y(de).id
                                  });
                                  var hr = M5e();
                                  let Mr;
                                  var Pr = C(hr),
                                    Or = C(Pr, !0);
                                  P(Pr);
                                  var jr = D(Pr),
                                    Lr = C(jr),
                                    _n = C(Lr);
                                  ws(_n, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return y(de).id
                                    },
                                    get pictureUrl() {
                                      return y(de).picture
                                    }
                                  });
                                  var dr = D(_n, 2),
                                    ct = C(dr),
                                    q = C(ct),
                                    U = D(q),
                                    Q = C(U);
                                  P(U), P(ct);
                                  var nt = D(ct, 2);
                                  {
                                    var _t = et => {
                                      const W = ge(() => Ls(y(de).equippedFlag));
                                      var vt = kr(),
                                        $t = xe(vt);
                                      {
                                        var Pt = Gt => {
                                          var ae = S5e(),
                                            ye = C(ae, !0);
                                          P(ae), Bt(() => {
                                            pr(ae, "data-tip", y(W).name), at(ye, y(W).flag)
                                          }), Z(Gt, ae)
                                        };
                                        At($t, Gt => {
                                          y(W) && Gt(Pt)
                                        })
                                      }
                                      Z(et, vt)
                                    };
                                    At(nt, et => {
                                      y(de).equippedFlag && et(_t)
                                    })
                                  }
                                  var Tt = D(nt, 2);
                                  {
                                    var Ft = et => {
                                      j_(et, {
                                        get username() {
                                          return y(de).discord
                                        },
                                        get id() {
                                          return y(de).discordId
                                        }
                                      })
                                    };
                                    At(Tt, et => {
                                      y(de).discord && et(Ft)
                                    })
                                  }
                                  var zt = D(Tt, 2);
                                  {
                                    var Nt = et => {
                                      var W = P5e(),
                                        vt = C(W, !0);
                                      P(W), Bt(($t, Pt) => {
                                        Gr(W, 1, `badge badge-sm ml-0.5 border-0 ${$t??""} ${Pt??""}`), at(vt, y(de).allianceName)
                                      }, [() => Td(y(de).allianceId), () => Ji(y(de).allianceId)]), Z(et, W)
                                    };
                                    At(zt, et => {
                                      "allianceName" in y(de) && y(de).allianceName && et(Nt)
                                    })
                                  }
                                  P(dr), P(Lr), P(jr);
                                  var ie = D(jr),
                                    mt = C(ie, !0);
                                  P(ie), P(hr), Bt((et, W) => {
                                    Mr = Gr(hr, 1, "", null, Mr, {
                                      "bg-base-200": y(er)
                                    }), at(Or, y(zr) + 1), Gr(ct, 1, `font-semibold max-sm:ml-2 ${et??""} flex gap-1`), at(q, `${y(de).name??""} `), at(Q, `#${y(de).id??""}`), at(mt, W)
                                  }, [() => Ji(y(de).id), () => y(de).pixelsPainted.toLocaleString("en-US")]), fu(hr, () => mu, () => ({
                                    duration: 200
                                  })), Z(or, hr)
                                }), P(Ze), P(ce), Bt((or, de, zr) => {
                                  at(_r, or), at(gr, `${de??""} `), at(ir, zr)
                                }, [() => Wf(), () => Sc(), () => Tc().toLowerCase()]), Z(mr, ce)
                              },
                              Ye = mr => {
                                var se = kr(),
                                  ce = xe(se);
                                {
                                  var ur = Ke => {
                                    var ve = z5e(),
                                      _r = C(ve),
                                      nr = C(_r),
                                      gr = D(C(nr)),
                                      ir = C(gr, !0);
                                    P(gr);
                                    var Ze = D(gr),
                                      or = C(Ze),
                                      de = D(or, 2, !0);
                                    P(Ze), P(nr), P(_r);
                                    var zr = D(_r);
                                    di(zr, 31, () => y($), er => er.id, (er, hr, Mr) => {
                                      const Pr = ge(() => {
                                        var nt;
                                        return ((nt = ze.data) == null ? void 0 : nt.allianceId) === y(hr).id
                                      });
                                      var Or = I5e();
                                      let jr;
                                      var Lr = C(Or),
                                        _n = C(Lr, !0);
                                      P(Lr);
                                      var dr = D(Lr),
                                        ct = C(dr),
                                        q = C(ct, !0);
                                      P(ct), P(dr);
                                      var U = D(dr),
                                        Q = C(U, !0);
                                      P(U), P(Or), Bt((nt, _t) => {
                                        jr = Gr(Or, 1, "", null, jr, {
                                          "bg-base-200": y(Pr)
                                        }), at(_n, y(Mr) + 1), Gr(ct, 1, `font-semibold ${nt??""}`), at(q, y(hr).name), at(Q, _t)
                                      }, [() => Ji(y(hr).id), () => y(hr).pixelsPainted.toLocaleString("en-US")]), fu(Or, () => mu, () => ({
                                        duration: 200
                                      })), Z(er, Or)
                                    }), P(zr), P(ve), Bt((er, hr, Mr) => {
                                      at(ir, er), at(or, `${hr??""} `), at(de, Mr)
                                    }, [() => Md(), () => Sc(), () => Tc().toLowerCase()]), Z(Ke, ve)
                                  };
                                  At(ce, Ke => {
                                    y(c) === "alliances" && Ke(ur)
                                  }, !0)
                                }
                                Z(mr, se)
                              };
                            At(He, mr => {
                              y(c) === "players" ? mr(Tr) : mr(Ye, !1)
                            }, !0)
                          }
                          Z(Ue, Ae)
                        };
                      At(ne, Ue => {
                        y(c) === "countries" ? Ue(Xe) : Ue(pe, !1)
                      }, !0)
                    }
                    Z(Ve, Ie)
                  };
                At(Xt, Ve => {
                  y(c) === "regions" ? Ve(me) : Ve(Ce, !1)
                })
              }
              Z(_e, Ut)
            },
            Ht = _e => {
              var Ut = A5e();
              Z(_e, Ut)
            };
          At(Wt, _e => {
            y($) ? _e(jt) : _e(Ht, !1)
          }, !0)
        }
        Z(Et, Ct)
      };
    At(qt, Et => {
      y($) && y($).length === 0 ? Et(Vt) : Et(Zt, !1)
    })
  }
  I_("innerWidth", Et => Y(w, Et, !0)), Z(l, ut), rn()
}
ri(["click"]);
var L5e = $r('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function a0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = L5e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var D5e = ft('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function R5e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  ti(() => {
    const tt = ut => {
      ut.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", tt), () => document.removeEventListener("keydown", tt)
  });
  var w = D5e(),
    z = C(w),
    E = D(C(z), 2),
    k = C(E);
  a0(k, {
    class: "size-6"
  });
  var c = D(k, 2),
    R = C(c, !0);
  P(c), P(E);
  var X = D(E, 2),
    $ = C(X);
  j5e($, {
    get onvisitclick() {
      return s.onvisitclick
    },
    get open() {
      return t()
    }
  }), P(X), P(z), Mn(2), P(w), eo(w, () => tt => {
    cn(() => {
      t() ? tt.show() : tt.close()
    })
  }), Bt(tt => at(R, tt), [() => Xf()]), jn("close", w, () => t(!1)), Z(l, w), rn()
}
var B5e = ft("<div><!></div>"),
  F5e = ft('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function O5e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  ti(() => {
    const c = R => {
      R.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", c), () => document.removeEventListener("keydown", c)
  });
  var w = F5e(),
    z = C(w),
    E = D(C(z), 2);
  {
    var k = c => {
      var R = B5e(),
        X = C(R);
      b1(X, {}), P(R), vo(2, R, () => is, () => ({
        duration: 300
      })), Z(c, R)
    };
    At(E, c => {
      t() && c(k)
    })
  }
  P(z), Mn(2), P(w), eo(w, () => c => {
    cn(() => {
      t() ? c.show() : c.close()
    })
  }), jn("close", w, () => t(!1)), Z(l, w), rn()
}
var q5e = ft("<p>You don't have charges to paint. <br/> </p>");

function N5e(l, s) {
  en(s, !1), Uf();
  var t = q5e(),
    w = D(C(t), 2);
  P(t), Bt(z => at(w, ` Next charge in ${z??""}`), [() => Zv(ze.cooldown ?? 0)]), Z(l, t), rn()
}
var V5e = ft('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form>'),
  U5e = ft('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  Z5e = ft("<dialog><div><!> <!></div> <!></dialog>");

function _m(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = $e(s, "hasBackdrop", 3, !0),
    z = $e(s, "hasCloseButton", 3, !0);
  var E = Z5e(),
    k = C(E),
    c = C(k);
  {
    var R = ut => {
      var xt = V5e();
      Z(ut, xt)
    };
    At(c, ut => {
      z() && ut(R)
    })
  }
  var X = D(c, 2);
  Bi(X, () => s.children ?? Yo), P(k);
  var $ = D(k, 2);
  {
    var tt = ut => {
      var xt = U5e(),
        lt = C(xt),
        G = C(lt, !0);
      P(lt), P(xt), Bt(yt => at(G, yt), [() => la()]), Z(ut, xt)
    };
    At($, ut => {
      w() && ut(tt)
    })
  }
  P(E), eo(E, () => ut => {
    cn(() => {
      t() ? ut.show() : ut.close()
    })
  }), Bt(() => {
    Gr(E, 1, `modal ${s.dialogClass??""}`), Gr(k, 1, `modal-box ${s.modalBoxClass??""}`)
  }), jn("close", E, () => t(!1)), Z(l, E), rn()
}
var G5e = ft('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function H5e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = $e(s, "buttonText", 3, "OK");
  _m(l, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return t()
    },
    set open(z) {
      t(z)
    },
    children: (z, E) => {
      var k = G5e(),
        c = C(k),
        R = C(c, !0);
      P(c);
      var X = D(c, 2),
        $ = C(X);
      Bi($, () => s.message), P(X);
      var tt = D(X, 2);
      tt.__click = () => {
        t(!1)
      };
      var ut = C(tt, !0);
      P(tt), P(k), Bt(() => {
        at(R, s.title), at(ut, w())
      }), Z(z, k)
    },
    $$slots: {
      default: !0
    }
  }), rn()
}
ri(["click"]);

function W5e(l) {
  const s = new Date;
  return l.getDate() === s.getDate() && l.getMonth() === s.getMonth() && l.getFullYear() === s.getFullYear() ? l.toLocaleTimeString(void 0, {
    timeStyle: "short"
  }) : l.toLocaleDateString(void 0, {
    dateStyle: "medium"
  })
}
var $5e = ft('<span class="size-2 rounded-full bg-red-400"></span>'),
  X5e = ft('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function Y5e(l, s) {
  en(s, !0);
  let t = $e(s, "read", 15);
  var w = X5e();
  w.__click = () => {
    t(!0), s.onclick()
  };
  var z = C(w),
    E = C(z);
  Bi(E, () => s.icon), P(z);
  var k = D(z, 2),
    c = C(k),
    R = C(c),
    X = C(R, !0);
  P(R);
  var $ = D(R, 2),
    tt = C($),
    ut = C(tt, !0);
  P(tt);
  var xt = D(tt, 2);
  {
    var lt = Lt => {
      var Dt = $5e();
      Z(Lt, Dt)
    };
    At(xt, Lt => {
      t() || Lt(lt)
    })
  }
  P($), P(c);
  var G = D(c, 2),
    yt = C(G, !0);
  P(G), P(k), P(w), Bt(Lt => {
    at(X, s.title), at(ut, Lt), at(yt, s.message)
  }, [() => W5e(s.createdAt)]), Z(l, w), rn()
}
ri(["click"]);
var K5e = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function J5e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = K5e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var Q5e = ft('<button class="btn btn-sm btn-ghost"> </button>'),
  t3e = ft('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  e3e = ft("<!> <!>", 1),
  r3e = ft('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  n3e = ft('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  i3e = ft("<p> </p>"),
  o3e = ft("<!> <!>", 1);

function s3e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(!1),
    z = ee(void 0),
    E = ee(void 0),
    k = ee(!1);
  var c = o3e(),
    R = xe(c);
  _m(R, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return t()
    },
    set open($) {
      t($)
    },
    children: ($, tt) => {
      var ut = n3e(),
        xt = xe(ut),
        lt = C(xt),
        G = C(lt, !0);
      P(lt);
      var yt = D(lt, 2);
      {
        var Lt = Et => {
          var Ct = Q5e();
          Ct.__click = async () => {
            if (fn.postNotificationMarkReadAll(), ze.notificiationCount = 0, y(z))
              for (const jt of y(z)) jt.read = !0
          };
          var Wt = C(Ct, !0);
          P(Ct), Bt(jt => at(Wt, jt), [() => cR()]), Z(Et, Ct)
        };
        At(yt, Et => {
          ze.notificiationCount !== 0 && Et(Lt)
        })
      }
      P(xt);
      var Dt = D(xt, 2),
        St = C(Dt);
      {
        var qt = Et => {
          var Ct = e3e(),
            Wt = xe(Ct);
          di(Wt, 17, () => y(z), _e => _e.id, (_e, Ut, Xt) => {
            var me = kr(),
              Ce = xe(me);
            {
              var Ve = Ie => {
                {
                  const ne = Ae => {
                    J5e(Ae, {
                      class: "size-5"
                    })
                  };
                  let Xe = ge(() => py()),
                    pe = ge(() => fy()),
                    Ue = ge(() => new Date(y(Ut).createdAt));
                  Y5e(Ie, {
                    get title() {
                      return y(Xe)
                    },
                    get message() {
                      return y(pe)
                    },
                    get createdAt() {
                      return y(Ue)
                    },
                    onclick: () => {
                      Y(k, !0)
                    },
                    get read() {
                      return y(Ut).read
                    },
                    set read(Ae) {
                      y(Ut).read = Ae
                    },
                    icon: ne,
                    $$slots: {
                      icon: !0
                    }
                  })
                }
              };
              At(Ce, Ie => {
                y(Ut).type === "report_feedback" && Ie(Ve)
              })
            }
            Z(_e, me)
          });
          var jt = D(Wt, 2);
          {
            var Ht = _e => {
              var Ut = t3e(),
                Xt = C(Ut, !0);
              P(Ut), Bt(me => at(Xt, me), [() => T9()]), Z(_e, Ut)
            };
            At(jt, _e => {
              y(z).length === 0 && !y(w) && _e(Ht)
            })
          }
          Z(Et, Ct)
        };
        At(St, Et => {
          y(z) && Et(qt)
        })
      }
      var Vt = D(St, 2);
      {
        var Zt = Et => {
          var Ct = r3e();
          eo(Ct, () => Wt => {
            const jt = new IntersectionObserver(Ht => {
              Ht[0].isIntersecting && !y(w) && (Y(w, !0), fn.getNotificationPage(y(E)).then(_e => {
                Y(z, [...y(z) ?? [], ..._e.notifications], !0), Y(E, _e.nextCursor, !0);
                const Ut = _e.notifications.filter(Xt => !Xt.read).map(Xt => Xt.id);
                Ut.length > 0 && (fn.postNotificationMarkRead(Ut), ze.notificiationCount && (ze.notificiationCount = Math.max(0, Ut.length - Ut.length)))
              }).catch(_e => {
                Ne.error(_e.message)
              }).finally(() => {
                Y(w, !1)
              }))
            });
            return jt.observe(Wt), () => {
              jt.disconnect()
            }
          }), Z(Et, Ct)
        };
        At(Vt, Et => {
          t() && (y(z) === void 0 || y(E) !== void 0) && Et(Zt)
        })
      }
      P(Dt), Bt(Et => at(G, Et), [() => mv()]), Z($, ut)
    },
    $$slots: {
      default: !0
    }
  });
  var X = D(R, 2);
  {
    const $ = ut => {
      var xt = i3e(),
        lt = C(xt);
      P(xt), Bt((G, yt) => at(lt, `${G??""} ${yt??""}`), [() => fy(), () => G$()]), Z(ut, xt)
    };
    let tt = ge(() => py());
    H5e(X, {
      get title() {
        return y(tt)
      },
      get open() {
        return y(k)
      },
      set open(ut) {
        Y(k, ut, !0)
      },
      message: $,
      $$slots: {
        message: !0
      }
    })
  }
  Z(l, c), rn()
}
ri(["click"]);
var a3e = ft("<canvas></canvas>");

function u0(l, s) {
  en(s, !0);
  let t = $e(s, "width", 15, 0),
    w = Ir(s, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    z = ge(() => Math.ceil(s.fontSize)),
    E = ee(null);
  const k = window.devicePixelRatio ?? 1,
    c = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    R = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  cn(() => {
    const $ = y(E).getContext("2d");
    $.textBaseline = "top", $.font = `${s.weight??"normal"} ${s.fontSize}px ${s.mono?R:c}`, $.fillStyle = s.color ?? "#394e6a", $.setTransform(k, 0, 0, k, 0, 0), $.clearRect(0, 0, t(), y(z)), $.fillText(s.value, 0, 0);
    const tt = $.measureText(s.value);
    t(Math.ceil(tt.actualBoundingBoxRight)), Y(z, tt.actualBoundingBoxDescent)
  });
  var X = a3e();
  Er(X, () => ({
    width: t() * k,
    height: y(z) * k,
    style: `width: ${t()??""}px; height: ${y(z)??""}px`,
    ...w
  })), os(X, $ => Y(E, $), () => y(E)), Z(l, X), rn()
}
var u3e = ft('<span class="w-7 text-xs"> </span>'),
  c3e = ft('<span class="flex items-center gap-1 sm:mt-px"><span><!></span> <!></span>'),
  l3e = ft('<span class="loading loading-spinner center-absolute absolute"></span>'),
  _3e = ft('<button><div class="flex items-center gap-1.5"><!> <div class="flex items-center gap-2 whitespace-nowrap"> <!></div></div> <!></button>');

function c0(l, s) {
  en(s, !0);
  let t = Ir(s, ["$$slots", "$$events", "$$legacy", "loading", "charges", "maxWidth"]),
    w = ee(0),
    z = ee(null),
    E = ee(void 0);
  ha(() => [s.loading, s.maxWidth], () => {
    Y(E, void 0), requestAnimationFrame(() => {
      const G = y(z).offsetWidth;
      !s.loading && s.maxWidth !== void 0 && G + 20 > s.maxWidth ? Y(E, 16 * (s.maxWidth / G) * .8) : Y(E, void 0)
    })
  });
  var k = _3e();
  Er(k, () => ({
    ...t,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${s.class??""}`,
    style: `max-width: ${s.maxWidth?`${s.maxWidth}px`:"none"}
	${y(E)?`;font-size: ${y(E)}px`:""}`
  }));
  var c = C(k),
    R = C(c);
  vu(R, {
    class: "size-6"
  });
  var X = D(R, 2),
    $ = C(X),
    tt = D($);
  {
    var ut = G => {
      const yt = ge(() => `${Math.floor(s.charges)}/${ze.data.charges.max}`);
      var Lt = c3e(),
        Dt = C(Lt),
        St = C(Dt);
      {
        let Zt = ge(() => y(E) ?? 16),
          Et = ge(() => s.disabled ? "#394e6a33" : "#ffffff");
        u0(St, {
          weight: 600,
          get fontSize() {
            return y(Zt)
          },
          get value() {
            return y(yt)
          },
          get color() {
            return y(Et)
          },
          get width() {
            return y(w)
          },
          set width(Ct) {
            Y(w, Ct, !0)
          }
        })
      }
      P(Dt);
      var qt = D(Dt, 2);
      {
        var Vt = Zt => {
          var Et = u3e(),
            Ct = C(Et);
          P(Et), Bt(Wt => at(Ct, `(${Wt??""})`), [() => Zv(ze.cooldown)]), Z(Zt, Et)
        };
        At(qt, Zt => {
          s.charges < ze.data.charges.max && ze.cooldown !== void 0 && Zt(Vt)
        })
      }
      P(Lt), Bt(Zt => _a(Dt, `width: ${Zt??""}px`), [() => (Math.floor(y(w) / 5) + 1) * 5]), Z(G, Lt)
    };
    At(tt, G => {
      s.charges !== void 0 && ze.data && G(ut)
    })
  }
  P(X), P(c), os(c, G => Y(z, G), () => y(z));
  var xt = D(c, 2);
  {
    var lt = G => {
      var yt = l3e();
      Z(G, yt)
    };
    At(xt, G => {
      s.loading && G(lt)
    })
  }
  P(k), Bt(G => at($, `${G??""} `), [() => gv()]), Z(l, k), rn()
}
const h3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  d3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  p3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  f3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class m3e {
  constructor(s) {
    dn(this, "gm");
    dn(this, "opacity", 1);
    dn(this, "id", `paint-preview-${Math.random()}`);
    dn(this, "tiles", new Map);
    this.input = s, this.gm = new Bo(this.input.tileSize)
  }
  place([s, t], w) {
    const {
      tile: z,
      pixel: E
    } = this.gm.latLonToTileAndPixel(s, t, this.input.tileZoom), k = this.getTileKey(z[0], z[1]);
    let c = this.tiles.get(k);
    if (!c) {
      const R = this.gm.tileBoundsLatLon(z[0], z[1], this.input.tileZoom),
        X = rm(R, !0),
        $ = new g3e({
          coordinates: X,
          id: `${this.id}-${k}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      $.addTo(this.input.map), this.tiles.set(k, $), c = $
    }
    c.place(E[0], this.input.tileSize - E[1] - 1, w)
  }
  clear() {
    const s = this.input.map;
    for (const t of this.tiles.values()) t.removeFrom(s), t.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(s, t) {
    this.clear(), this.place(s, t)
  }
  remove([s, t]) {
    const {
      tile: w,
      pixel: z
    } = this.gm.latLonToTileAndPixel(s, t, this.input.tileZoom), E = this.getTileKey(w[0], w[1]), k = this.tiles.get(E);
    k && k.remove(z[0], this.input.tileSize - z[1] - 1)
  }
  setCanvasOpacity(s) {
    this.opacity = s;
    for (const t of this.tiles.values()) t.setOpacity(s)
  }
  getTileKey(s, t) {
    return `${s},${t}`
  }
}
class g3e {
  constructor(s) {
    dn(this, "canvas");
    dn(this, "maps", new Set);
    this.input = s;
    const t = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = t, this.canvas.height = t
  }
  place(s, t, w) {
    var k;
    const z = ((k = Ao.colors) == null ? void 0 : k[w]) ?? Ao.colors[0],
      E = this.canvas.getContext("2d");
    if (E) {
      const c = E.createImageData(1, 1),
        [R, X, $] = z.rgb,
        tt = w === 0 ? 0 : 255;
      c.data[0] = R, c.data[1] = X, c.data[2] = $, c.data[3] = tt, E.putImageData(c, s, t)
    }
  }
  remove(s, t) {
    const w = this.canvas.getContext("2d");
    w && w.clearRect(s, t, 1, 1)
  }
  addTo(s) {
    const t = this.input.id;
    s.getSource(t) || s.addSource(t, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), s.getLayer(t) || (s.addLayer({
      id: t,
      type: "raster",
      source: t,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && s.moveLayer(t, this.input.beforeLayerId)), this.maps.add(s)
  }
  removeFrom(s) {
    const {
      id: t
    } = this.input;
    s.getLayer(t) && s.removeLayer(t), s.getSource(t) && s.removeSource(t), this.maps.delete(s)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(s) {
    for (const t of this.maps.values()) t.setPaintProperty(this.input.id, "raster-opacity", s)
  }
}
var y3e = $r('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function v3e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = y3e();
  Er(w, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...t
  })), Z(l, w)
}
var b3e = $r('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function x3e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = b3e();
  Er(w, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...t
  })), Z(l, w)
}
var w3e = ft("<div><!></div>");

function kc(l, s) {
  en(s, !0);
  var t = w3e(),
    w = C(t);
  Bi(w, () => s.children ?? Yo), P(t), Bt(() => Gr(t, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${s.class??""}`)), Z(l, t), rn()
}
var k3e = ft('<div class="confetti svelte-av71ki"></div>'),
  T3e = ft("<div></div>");

function hm(l, s) {
  en(s, !0);
  const t = $e(s, "size", 3, 10),
    w = $e(s, "x", 19, () => [-.5, .5]),
    z = $e(s, "y", 19, () => [.25, 1]),
    E = $e(s, "duration", 3, 2e3),
    k = $e(s, "infinite", 3, !1),
    c = $e(s, "delay", 19, () => [0, 50]),
    R = $e(s, "colorRange", 19, () => [0, 360]),
    X = $e(s, "colorArray", 19, () => []),
    $ = $e(s, "amount", 3, 50),
    tt = $e(s, "iterationCount", 3, 1),
    ut = $e(s, "fallDistance", 3, "100px"),
    xt = $e(s, "rounded", 3, !1),
    lt = $e(s, "cone", 3, !1),
    G = $e(s, "noGravity", 3, !1),
    yt = $e(s, "xSpread", 3, .15),
    Lt = $e(s, "destroyOnComplete", 3, !0),
    Dt = $e(s, "disableForReducedMotion", 3, !1);
  let St = ee(!1);
  ti(() => {
    !Lt() || k() || typeof tt() == "string" || setTimeout(() => Y(St, !0), (E() + c()[1]) * tt())
  });

  function qt(Wt, jt) {
    return Math.random() * (jt - Wt) + Wt
  }

  function Vt() {
    return X().length ? X()[Math.round(Math.random() * (X().length - 1))] : `hsl(${Math.round(qt(R()[0],R()[1]))}, 75%, 50%)`
  }
  var Zt = kr(),
    Et = xe(Zt);
  {
    var Ct = Wt => {
      var jt = T3e();
      let Ht;
      di(jt, 21, () => ({
        length: $()
      }), P_, (_e, Ut) => {
        var Xt = k3e();
        Bt((me, Ce, Ve, Ie, ne, Xe, pe, Ue, Ae, He, Tr) => _a(Xt, `
        --color: ${me??""};
        --skew: ${Ce??""}deg,${Ve??""}deg;
        --rotation-xyz: ${Ie??""}, ${ne??""}, ${Xe??""};
        --rotation-deg: ${pe??""}deg;
        --translate-y-multiplier: ${Ue??""};
        --translate-x-multiplier: ${Ae??""};
        --scale: ${He??""};
        --transition-delay: ${Tr??""}ms;
        --transition-duration: ${k()?`calc(${E()}ms * var(--scale))`:`${E()}ms`};`), [Vt, () => qt(-45, 45), () => qt(-45, 45), () => qt(-10, 10), () => qt(-10, 10), () => qt(-10, 10), () => qt(0, 360), () => qt(z()[0], z()[1]), () => qt(w()[0], w()[1]), () => .1 * qt(2, 10), () => qt(c()[0], c()[1])]), Z(_e, Xt)
      }), P(jt), Bt(() => {
        Ht = Gr(jt, 1, "confetti-holder svelte-av71ki", null, Ht, {
          rounded: xt(),
          cone: lt(),
          "no-gravity": G(),
          "reduced-motion": Dt()
        }), _a(jt, `
    --fall-distance: ${ut()??""};
    --size: ${t()??""}px;
    --x-spread: ${1-yt()};
    --transition-iteration-count: ${(k()?"infinite":tt())??""};`)
      }), Z(Wt, jt)
    };
    At(Et, Wt => {
      y(St) || Wt(Ct)
    })
  }
  Z(l, Zt), rn()
}
var S3e = ft('<span class="loading loading-spinner center-absolute absolute"></span>'),
  P3e = ft('<!> <span class="text-sm">Droplets</span>', 1),
  M3e = ft('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  C3e = ft('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'),
  I3e = ft('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function z3e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  const w = ge(() => Ao.colors[s.colorIdx]),
    z = ge(() => {
      var xt;
      return ((xt = ze.data) == null ? void 0 : xt.droplets) ?? 0
    });
  let E = ee(!1);
  const k = ge(() => (y(E), ze.hasColor(s.colorIdx)));
  ti(() => {
    const xt = lt => {
      lt.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", xt), () => document.removeEventListener("keydown", xt)
  });
  const c = 100,
    R = Ao.products[c];
  var X = I3e(),
    $ = C(X),
    tt = D(C($), 2);
  {
    var ut = xt => {
      var lt = C3e(),
        G = C(lt),
        yt = C(G),
        Lt = C(yt);
      vd(Lt, {
        class: "size-6"
      });
      var Dt = D(Lt, 4),
        St = C(Dt);
      Jy(St, {
        get value() {
          return y(z)
        }
      }), P(Dt), P(yt), Mn(2), P(G);
      var qt = D(G, 2),
        Vt = C(qt),
        Zt = C(Vt);
      P(Vt);
      var Et = D(Vt, 2),
        Ct = C(Et, !0);
      P(Et);
      var Wt = D(Et, 2),
        jt = C(Wt);
      let Ht;
      var _e = C(jt);
      _e.__click = async () => {
        try {
          Y(E, !0), await fn.purchase({
            id: c,
            amount: 1,
            variant: s.colorIdx
          }), await ze.refresh(), mi.notification1.play()
        } catch (ne) {
          Ne.error(ne.message)
        } finally {
          Y(E, !1)
        }
      };
      var Ut = C(_e);
      {
        var Xt = ne => {
          var Xe = S3e();
          Z(ne, Xe)
        };
        At(Ut, ne => {
          y(E) && ne(Xt)
        })
      }
      var me = D(Ut, 2);
      {
        var Ce = ne => {
            var Xe = P3e(),
              pe = xe(Xe);
            kd(pe, {
              class: "size-5"
            });
            var Ue = D(pe);
            Mn(), Bt(Ae => at(Ue, ` ${Ae??""} `), [() => R.price.toLocaleString("en-US")]), Z(ne, Xe)
          },
          Ve = ne => {
            var Xe = M3e(),
              pe = xe(Xe);
            vd(pe, {
              class: "size-5"
            });
            var Ue = D(pe, 2),
              Ae = C(Ue);
            hm(Ae, {}), P(Ue), Z(ne, Xe)
          };
        At(me, ne => {
          y(k) ? ne(Ve, !1) : ne(Ce)
        })
      }
      P(_e), P(jt);
      var Ie = D(jt, 2);
      Ie.__click = () => t(!1), P(Wt), P(qt), P(lt), Bt(ne => {
        _a(Zt, `background: rgb(${y(w).rgb[0]} ${y(w).rgb[1]} ${y(w).rgb[2]})`), pr(Zt, "aria-label", y(w).name), at(Ct, y(w).name), pr(jt, "data-tip", ne), Ht = Gr(jt, 1, "", null, Ht, {
          tooltip: !y(k) && y(z) < R.price
        }), _e.disabled = y(z) < R.price || y(E) || y(k)
      }, [() => Cd()]), Z(xt, lt)
    };
    At(tt, xt => {
      ze.data && xt(ut)
    })
  }
  P($), Mn(2), P(X), eo(X, () => xt => {
    cn(() => {
      t() ? xt.show() : xt.close()
    })
  }), jn("close", X, () => t(!1)), Z(l, X), rn()
}
ri(["click"]);
var A3e = $r('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function Vy(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = A3e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var E3e = $r('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function l0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = E3e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var j3e = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  L3e = $r('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function _0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var w = kr(),
    z = xe(w);
  {
    var E = c => {
        var R = j3e();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      },
      k = c => {
        var R = L3e();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      };
    At(z, c => {
      s.filled ? c(E) : c(k, !1)
    })
  }
  Z(l, w)
}
var D3e = $r('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function jf(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = D3e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var R3e = $r('<svg><path d="M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z"></path></svg>');

function B3e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = R3e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var F3e = $r('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function h0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = F3e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var O3e = $r('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function q3e(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = O3e();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
const Uy = {
  0: qut,
  1: Qut,
  2: hct,
  3: Sct,
  4: Fct,
  5: Kct,
  6: llt,
  7: klt,
  8: Rlt,
  9: Xlt,
  10: u_t,
  11: x_t,
  12: L_t,
  13: W_t,
  14: sht,
  15: vht,
  16: Eht,
  17: Ght,
  18: idt,
  19: gdt,
  20: zdt,
  21: Udt,
  22: rpt,
  23: fpt,
  24: Cpt,
  25: Npt,
  26: tft,
  27: dft,
  28: Pft,
  29: Oft,
  30: Jft,
  31: _mt,
  32: Tmt,
  33: Bmt,
  34: Ymt,
  35: cgt,
  36: wgt,
  37: Dgt,
  38: $gt,
  39: ayt,
  40: byt,
  41: jyt,
  42: Hyt,
  43: ovt,
  44: yvt,
  45: Avt,
  46: Zvt,
  47: n0t,
  48: m0t,
  49: I0t,
  50: V0t,
  51: ebt,
  52: pbt,
  53: Mbt,
  54: qbt,
  55: Qbt,
  56: hxt,
  57: Sxt,
  58: Fxt,
  59: Kxt,
  60: l1t,
  61: k1t,
  62: R1t,
  63: X1t
};
var N3e = ft("<!> ", 1),
  V3e = ft("<!> ", 1),
  U3e = ft("<!> ", 1),
  Z3e = ft('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  G3e = ft("<!> ", 1),
  H3e = ft('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  W3e = ft("<div><button><!></button></div>"),
  $3e = ft('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1.5"><h2 class="sm:min-w-38 select-none text-xl"> <!></h2> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip max-sm:hidden"><button title="Toggle art opacity"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Z</kbd></div> <button title="Undo"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Y</kbd></div> <button title="Redo"><!></button></div></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function X3e(l, s) {
  var qr, lr;
  en(s, !0);
  let t = $e(s, "screenLocked", 15),
    w = $e(s, "opaquePixelArt", 15);
  const z = ge(() => new Bo(s.tileSize));
  let E = ee(1),
    k = ee("pencil");
  const c = new Map,
    R = new Map;
  let X = ee(0),
    $ = ee(!1),
    tt = ee(!0),
    ut = ge(() => ze.charges ?? 0),
    xt = ge(() => y(ut) - y(X)),
    lt = ee(!1),
    G = !1,
    yt = ee(!1);
  const Lt = ge(() => y(k) === "pencil"),
    Dt = ge(() => y(k) === "eraser"),
    St = ge(() => y(k) === "colorpicker");
  let qt = ee(!1),
    Vt = ee(0),
    Zt = ee(void 0),
    Et = ee(void 0);
  const Ct = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Jt => ({
      ...Ao.colors[Jt],
      idx: Jt,
      label: Uy[Jt]()
    })),
    Wt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Jt => ({
      ...Ao.colors[Jt],
      idx: Jt,
      label: Uy[Jt]()
    }));
  let jt = ee(!1);
  const Ht = ge(() => y(jt) ? Ct : Wt),
    _e = "show-all-colors";
  ti(() => {
    Y(jt, localStorage.getItem(_e) === "true")
  }), cn(() => {
    localStorage.setItem(_e, y(jt) ? "true" : "false")
  });
  const Ut = "selected-color";
  ti(() => {
    const Jt = Number(localStorage.getItem(Ut));
    !isNaN(Jt) && Jt < Ao.colors.length && Jt > 0 && Y(E, Jt, !0)
  }), cn(() => {
    localStorage.setItem(Ut, y(E).toString())
  });
  const Xt = new m3e({
    map: s.map,
    tileSize: s.tileSize,
    tileZoom: s.tileZoom,
    beforeLayerId: s.hoverLayerId
  });
  cn(() => {
    const Jt = w() ? 1 : 0;
    Xt.setCanvasOpacity(Jt)
  }), cn(() => {
    w() ? Jp() : pe([...c.values()])
  });
  let me = !1;
  ti(() => {
    sa(s.map.getCenter(), s.map.getZoom());
    const Jt = s.map.on("click", Kr => {
      var An;
      s.zoom < s.tileZoom + 2 && ((An = ze.data) == null ? void 0 : An.role) === "user" && s.map.easeTo({
        center: Kr.lngLat,
        zoom: 17
      });
      const Hr = [Kr.lngLat.lat, Kr.lngLat.lng];
      y(Lt) ? (Ve([Hr], y(E)), ve.finishAction()) : y(Dt) ? (Ie([Hr]), ve.finishAction()) : y(St) && ne(Hr, Kr.point), Y(lt, !0)
    });

    function Se(Kr, Hr) {
      const An = y(z).latLonToPixels(Kr.lat, Kr.lng, s.tileZoom),
        Hi = Hr ? y(z).latLonToPixels(Hr.lat, Hr.lng, s.tileZoom) : An;
      return Kx(An, Hi).map(Ci => y(z).pixelsToLatLon(Ci[0] + .5, Ci[1] + .5, s.tileZoom))
    }

    function rr(Kr, Hr) {
      const An = Se(Kr, Hr);
      y(Lt) ? Ve(An, y(E)) : y(Dt) && Ie(An), Y(lt, !0)
    }
    let Le;

    function sr(Kr) {
      const Hr = s.map.unproject([Kr.clientX, Kr.clientY]);
      if (y(yt)) {
        const An = Se(Hr, Le);
        Ie(An)
      }(me || G) && rr(Hr, Le), Le = Hr
    }
    window.addEventListener("mousemove", sr);
    let De = !1;
    const Cr = s.map.on("touchstart", Kr => {
        if (Kr.points.length == 2) {
          t(!1), Tr(), De = !0, setTimeout(() => De = !1, 150);
          return
        }
        t() && setTimeout(() => {
          !De && rr(Kr.lngLat)
        }, 150), Le = Kr.lngLat
      }),
      on = s.map.on("touchend", () => {
        ve.finishAction()
      }),
      ln = s.map.on("touchmove", Kr => {
        t() && rr(Kr.lngLat, Le), Le = Kr.lngLat
      }),
      Br = Kr => {
        Kr.code === "Space" && (me || Le && rr(Le), me = !0, Kr.preventDefault())
      };
    document.addEventListener("keydown", Br);
    const Dr = Kr => {
      Kr.code === "Space" && (me = !1, Ce = !1, ve.finishAction(), y(X) === 0 && y(Dt) && Y(k, "pencil"))
    };
    document.addEventListener("keyup", Dr);

    function un(Kr) {
      if (Kr.button === 2) {
        Y(yt, !0);
        const An = s.map.unproject([Kr.clientX, Kr.clientY]);
        Ie([
          [An.lat, An.lng]
        ])
      }
    }
    document.addEventListener("mousedown", un);

    function Fn(Kr) {
      Kr.button === 2 && Y(yt, !1)
    }
    document.addEventListener("mouseup", Fn);
    const Rn = Kr => {
      switch (Kr.code) {
        case "KeyE":
          y(X) > 0 && (y(Dt) ? Y(k, "pencil") : Y(k, "eraser"));
          return;
        case "KeyI":
          Y(k, "colorpicker");
          return
      }
    };
    return document.addEventListener("keypress", Rn), () => {
      ln.unsubscribe(), Cr.unsubscribe(), on.unsubscribe(), Jt.unsubscribe(), document.removeEventListener("mousemove", sr), document.removeEventListener("keydown", Br), document.removeEventListener("keyup", Dr), document.removeEventListener("keypress", Rn), document.removeEventListener("mousedown", un), document.removeEventListener("mouseup", Fn), Ue()
    }
  });
  let Ce = !1;

  function Ve(Jt, Se, rr = !0) {
    let Le = !1;
    const sr = Se === 0;
    for (let De of Jt) {
      const [Cr, on] = De, ln = Zf(Se), {
        tile: Br,
        pixel: Dr
      } = y(z).latLonToTileAndPixel(Cr, on, s.tileZoom), un = {
        color: ln,
        tile: Br,
        pixel: Dr,
        season: s.season,
        colorIdx: Se
      }, Fn = qp(un), Rn = c.get(Fn), Kr = y(ut) - c.size;
      if (!Rn && Kr < 1) {
        if (Ce && (me || t())) continue;
        Ce = !0, Ne.info(O7());
        continue
      }
      if (!(Rn && Rn.colorIdx === Se) && (mi.plop.play(), Le || s.hidePixelHover(), c.set(Fn, un), Xt.place(De, Se), s.crosshair.place(De), Le = !0, sr && R.set(Fn, un), rr)) {
        const Hr = {
            type: "paint",
            latLons: [De],
            colorIdx: Se
          },
          An = Rn ? {
            type: "paint",
            latLons: [De],
            colorIdx: Rn.colorIdx
          } : {
            type: "erase",
            latLons: [De]
          };
        ve.saveAction(Hr, An)
      }
    }
    Y(X, c.size, !0), Le && !w() ? pe([...c.values()]) : Le && w() && sr && pe([...R.values()])
  }

  function Ie(Jt, Se = !0) {
    let rr = !1,
      Le = !1;
    for (let sr of Jt) {
      const [De, Cr] = sr, {
        tile: on,
        pixel: ln
      } = y(z).latLonToTileAndPixel(De, Cr, s.tileZoom), Br = qp({
        tile: on,
        pixel: ln,
        season: s.season
      }), Dr = c.get(Br);
      Dr && (mi.plop.play(), s.hidePixelHover(), c.delete(Br), R.delete(Br), Xt.remove([De, Cr]), s.crosshair.remove(sr), rr = !0, Dr.colorIdx === 0 && (Le = !0), Se && ve.saveAction({
        type: "erase",
        latLons: [sr]
      }, {
        type: "paint",
        latLons: [sr],
        colorIdx: Dr.colorIdx
      })), c.size === 0 && !(me || G || t()) && Y(k, "pencil")
    }
    Y(X, c.size, !0), rr && !w() ? pe([...c.values()]) : rr && w() && Le && pe([...R.values()])
  }

  function ne(Jt, Se) {
    const {
      tile: rr,
      pixel: Le
    } = y(z).latLonToTileAndPixel(Jt[0], Jt[1], s.tileZoom), sr = qp({
      tile: rr,
      pixel: Le,
      season: s.season
    }), De = c.get(sr);
    if (De) {
      Ye(De.colorIdx), requestAnimationFrame(() => {
        var Br;
        (Br = document.getElementById(`color-${De.colorIdx}`)) == null || Br.focus()
      });
      return
    }
    const Cr = window.devicePixelRatio,
      on = Math.floor(Se.x * Cr),
      ln = Math.floor(Se.y * Cr);
    s.hidePixelHover(), Owe(s.map, on, ln).then(([Br, Dr, un]) => {
      const Fn = tv({
        r: Br,
        g: Dr,
        b: un
      });
      Ye(Fn), requestAnimationFrame(() => {
        var Rn;
        (Rn = document.getElementById(`color-${Fn}`)) == null || Rn.focus()
      })
    })
  }
  ha(() => y(E), () => {
    s.clickedLatLon && !y(lt) && (y(E) === void 0 && Y(E, 1), Ve([s.clickedLatLon], y(E)))
  }), cn(() => {
    const Jt = y(tt) ? .8 : 0;
    s.crosshair.setCanvasOpacity(Jt)
  });
  let Xe = ee(16.5);
  cn(() => {
    if (y(Zt) && y(Et) && s.clickedLatLon) {
      const Jt = s.map.getZoom();
      if (Jt < y(Xe)) {
        const [Se, rr] = s.clickedLatLon, Le = y(z).latLonToPixelBoundsLatLon(Se, rr, s.tileZoom), sr = nm(Le), De = y(Zt) - y(Et).clientHeight, Cr = y(Zt) / 2 - De / 2;
        s.map.flyTo({
          center: {
            lat: sr[0],
            lng: sr[1]
          },
          zoom: 17.5,
          offset: Jt > 11 ? [0, -Cr] : [0, 0]
        })
      }
      Y(Xe, s.tileZoom, !0)
    }
  }), ti(() => {
    const Jt = () => {
      !document.hidden && (w() ? pe([...R.values()]) : pe([...c.values()]))
    };
    return document.addEventListener("visibilitychange", Jt), () => document.removeEventListener("visibilitychange", Jt)
  }), cn(() => {
    switch (y(k)) {
      case "pencil":
        s.map.getCanvas().style.cursor = `url('${p3e}') 8 8, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        s.map.getCanvas().style.cursor = `url('${h3e}') 0 16, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        s.map.getCanvas().style.cursor = `url('${d3e}') 2 14, default`, s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), cn(() => {
    t() ? He() : Tr()
  });
  async function pe(Jt) {
    await Zx(Jt), s.refreshPixelArt()
  }
  async function Ue() {
    await Jp(), Xt.clear(), s.refreshPixelArt(), s.crosshair.clear()
  }
  async function Ae() {
    await Ue(), Tr(), s.map.getCanvas().style.cursor = "default", s.map.setPaintProperty(s.hoverLayerId, "raster-opacity", .4), ve.clear(), s.onclose()
  }

  function He() {
    s.map.dragPan.disable(), s.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function Tr() {
    s.map.dragPan.enable(), s.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function Ye(Jt) {
    return Jt >= 32 && Y(jt, !0), ze.hasColor(Jt) ? (mi.smallDropplet.play(), Y(E, Jt, !0), Y(k, "pencil"), !0) : (mi.smallDropplet.play(), Y(qt, !0), Y(Vt, Jt, !0), !1)
  }
  jx(Jt => {
    Jt.type === "leave" && y(X) > 0 && Jt.cancel()
  });
  const mr = "show-paint-more-than-one-pixel-msg";
  let se = ee(!1);
  ti(() => {
    var Jt;
    Y(se, !localStorage.getItem(mr) && (((Jt = ze.data) == null ? void 0 : Jt.pixelsPainted) ?? 0) < 100, !0)
  }), cn(() => {
    y(X) > 1 && (Y(se, !1), localStorage.setItem(mr, "false"))
  });
  const ce = "lp";
  ti(() => {
    var Se;
    const Jt = localStorage.getItem(ce);
    if (Jt) try {
      const rr = JSON.parse(atob(Jt)),
        Le = (rr == null ? void 0 : rr.time) ?? 0,
        sr = 60 * 1e3;
      (rr == null ? void 0 : rr.userId) !== ((Se = ze.data) == null ? void 0 : Se.id) && Date.now() - Le < 30 * sr && !E1 && (Ne.error(_9()), Ae())
    } catch (rr) {
      console.error(rr)
    }
  });

  function ur() {
    var Se;
    const Jt = btoa(JSON.stringify({
      userId: (Se = ze.data) == null ? void 0 : Se.id,
      time: Date.now()
    }));
    localStorage.setItem(ce, Jt)
  }
  class Ke {
    constructor() {
      dn(this, "history", []);
      dn(this, "actionInProgress", !1);
      dn(this, "historyIdx", -1);
      yn(this, qr, ee(!1));
      yn(this, lr, ee(!1))
    }
    get canUndo() {
      return y(We(this, qr))
    }
    set canUndo(Se) {
      Y(We(this, qr), Se, !0)
    }
    get canRedo() {
      return y(We(this, lr))
    }
    set canRedo(Se) {
      Y(We(this, lr), Se, !0)
    }
    undo() {
      if (this.historyIdx < 0) return;
      const Se = this.history[this.historyIdx];
      if (Se) {
        const rr = this.mergeActions(Se.undo);
        for (const Le of rr) this.applyAction(Le)
      }
      this.historyIdx--, this.refreshCanUndoRedo()
    }
    redo() {
      if (this.historyIdx >= this.history.length - 1) return;
      this.historyIdx++;
      const Se = this.history[this.historyIdx];
      if (Se) {
        const rr = this.mergeActions(Se.redo);
        for (const Le of rr) this.applyAction(Le)
      }
      this.refreshCanUndoRedo()
    }
    saveAction(Se, rr) {
      this.actionInProgress || (this.historyIdx < this.history.length - 1 && (this.history = this.history.slice(0, this.historyIdx + 1)), this.actionInProgress = !0, this.historyIdx++, this.history.push({
        redo: [],
        undo: []
      }));
      const Le = this.history[this.historyIdx];
      Le && (Le.redo.push(Se), Le.undo.push(rr))
    }
    finishAction() {
      this.actionInProgress = !1, this.refreshCanUndoRedo()
    }
    clear() {
      this.history = [], this.actionInProgress = !1, this.historyIdx = -1, this.refreshCanUndoRedo()
    }
    mergeActions(Se) {
      const rr = {
          type: "erase",
          latLons: []
        },
        Le = new Map;
      for (const De of Se)
        if (De.type === "erase") rr.latLons.push(...De.latLons);
        else {
          const Cr = Le.get(De.colorIdx);
          Cr ? Cr.latLons.push(...De.latLons) : Le.set(De.colorIdx, {
            type: "paint",
            colorIdx: De.colorIdx,
            latLons: [...De.latLons]
          })
        } const sr = [];
      if (rr.latLons.length > 0 && sr.push(rr), Le.size > 0)
        for (const De of Le.values()) sr.push(De);
      return sr
    }
    applyAction(Se) {
      switch (Se.type) {
        case "paint":
          Ve(Se.latLons, Se.colorIdx, !1);
          break;
        case "erase":
          Ie(Se.latLons, !1);
          break
      }
    }
    refreshCanUndoRedo() {
      this.canUndo = this.historyIdx >= 0, this.canRedo = this.historyIdx < this.history.length - 1
    }
  }
  qr = new WeakMap, lr = new WeakMap;
  const ve = new Ke;
  var _r = $3e();
  jn("keypress", Oa, Jt => {
    switch (Jt.code) {
      case "KeyZ":
        (Jt.ctrlKey || Jt.metaKey) && (Jt.shiftKey ? ve.redo() : ve.undo());
        break;
      case "KeyY":
        (Jt.ctrlKey || Jt.metaKey) && ve.redo()
    }
  });
  var nr = xe(_r),
    gr = C(nr);
  {
    var ir = Jt => {
        kc(Jt, {
          children: (Se, rr) => {
            var Le = N3e(),
              sr = xe(Le);
            l0(sr, {
              class: "inline size-5"
            });
            var De = D(sr);
            Bt(Cr => at(De, ` ${Cr??""}`), [() => zX()]), Z(Se, Le)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Ze = Jt => {
        var Se = kr(),
          rr = xe(Se);
        {
          var Le = De => {
              kc(De, {
                class: "not-touchscreen:hidden",
                children: (Cr, on) => {
                  var ln = V3e(),
                    Br = xe(ln);
                  Qp(Br, {
                    class: "inline size-5"
                  });
                  var Dr = D(Br);
                  Bt(un => at(Dr, ` ${un??""}`), [() => UX()]), Z(Cr, ln)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            sr = De => {
              var Cr = kr(),
                on = xe(Cr);
              {
                var ln = Dr => {
                    kc(Dr, {
                      class: "not-touchscreen:hidden",
                      children: (un, Fn) => {
                        var Rn = U3e(),
                          Kr = xe(Rn);
                        Vy(Kr, {
                          class: "inline size-5"
                        });
                        var Hr = D(Kr, 1, !0);
                        Bt(An => at(Hr, An), [() => WU()]), Z(un, Rn)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Br = Dr => {
                    var un = kr(),
                      Fn = xe(un);
                    {
                      var Rn = Hr => {
                          kc(Hr, {
                            class: "touchscreen:hidden",
                            children: (An, Hi) => {
                              var Fi = Z3e(),
                                Ci = xe(Fi);
                              h0(Ci, {
                                class: "inline size-5"
                              });
                              var he = D(Ci),
                                qe = C(he, !0);
                              P(he);
                              var Vr = D(he, 2),
                                Pn = C(Vr),
                                Gn = D(Pn),
                                Xn = C(Gn, !0);
                              P(Gn), P(Vr);
                              var $n = D(Vr);
                              Bt((On, Ai, Rr, wr) => {
                                at(qe, On), at(Pn, `${Ai??""} `), at(Xn, Rr), at($n, ` ${wr??""}`)
                              }, [() => zT(), () => NN(), () => iw(), () => zet()]), Z(An, Fi)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        Kr = Hr => {
                          var An = kr(),
                            Hi = xe(An);
                          {
                            var Fi = Ci => {
                              kc(Ci, {
                                class: "bg-warning text-warning-content animate-bounce",
                                children: (he, qe) => {
                                  var Vr = G3e(),
                                    Pn = xe(Vr);
                                  vu(Pn, {
                                    class: "inline size-5"
                                  });
                                  var Gn = D(Pn);
                                  Bt(Xn => at(Gn, ` ${Xn??""}`), [() => Uet()]), Z(he, Vr)
                                },
                                $$slots: {
                                  default: !0
                                }
                              })
                            };
                            At(Hi, Ci => {
                              y(se) && Ci(Fi)
                            }, !0)
                          }
                          Z(Hr, An)
                        };
                      At(Fn, Hr => {
                        y(Lt) && y(X) === 0 ? Hr(Rn) : Hr(Kr, !1)
                      }, !0)
                    }
                    Z(Dr, un)
                  };
                At(on, Dr => {
                  y(St) ? Dr(ln) : Dr(Br, !1)
                }, !0)
              }
              Z(De, Cr)
            };
          At(rr, De => {
            y(Dt) ? De(Le) : De(sr, !1)
          }, !0)
        }
        Z(Jt, Se)
      };
    At(gr, Jt => {
      y(Dt) && y(X) === 0 ? Jt(ir) : Jt(Ze, !1)
    })
  }
  var or = D(gr, 2),
    de = C(or);
  de.__click = () => Y(tt, !y(tt));
  var zr = C(de);
  {
    var er = Jt => {
        v3e(Jt, {
          class: "size-4"
        })
      },
      hr = Jt => {
        x3e(Jt, {
          class: "size-4"
        })
      };
    At(zr, Jt => {
      y(tt) ? Jt(er) : Jt(hr, !1)
    })
  }
  P(de);
  var Mr = D(de, 2),
    Pr = C(Mr),
    Or = C(Pr),
    jr = D(Or);
  u0(jr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${y(X)??""})`
    },
    mono: !0
  }), P(Pr);
  var Lr = D(Pr, 2),
    _n = C(Lr),
    dr = C(_n);
  Mn(), P(_n);
  var ct = D(_n, 2);
  ct.__click = () => {
    Y(k, "colorpicker")
  };
  var q = C(ct);
  Vy(q, {
    class: "size-4.5"
  }), P(ct), P(Lr);
  var U = D(Lr, 2),
    Q = C(U);
  let nt;
  Q.__click = () => {
    w(!w())
  };
  var _t = C(Q);
  {
    let Jt = ge(() => !w());
    _0(_t, {
      class: "size-4.5",
      get filled() {
        return y(Jt)
      }
    })
  }
  P(Q), P(U);
  var Tt = D(U, 2),
    Ft = C(Tt),
    zt = C(Ft);
  Mn(), P(Ft);
  var Nt = D(Ft, 2);
  let ie;
  Nt.__click = () => {
    ve.undo()
  };
  var mt = C(Nt);
  q3e(mt, {
    class: "size-4.5"
  }), P(Nt), P(Tt);
  var et = D(Tt, 2),
    W = C(et),
    vt = C(W);
  Mn(), P(W);
  var $t = D(W, 2);
  let Pt;
  $t.__click = () => {
    ve.redo()
  };
  var Gt = C($t);
  B3e(Gt, {
    class: "size-4.5"
  }), P($t), P(et), P(Mr);
  var ae = D(Mr, 2);
  ae.__click = () => {
    mi.smallPlop.play(), Ae()
  };
  var ye = C(ae);
  pa(ye, {
    class: "size-4"
  }), P(ae), P(or);
  var Te = D(or, 2),
    we = C(Te);
  di(we, 23, () => y(Ht), Jt => Jt.idx, (Jt, Se, rr) => {
    const Le = ge(() => {
        const [un, Fn, Rn] = y(Se).rgb;
        return {
          r: un,
          g: Fn,
          b: Rn
        }
      }),
      sr = ge(() => y(E) === y(Se).idx && y(Lt)),
      De = ge(() => y(Se).idx === 0),
      Cr = ge(() => ze.hasColor(y(Se).idx));
    var on = W3e(),
      ln = C(on);
    ln.__click = () => {
      Ye(y(Se).idx)
    };
    var Br = C(ln);
    {
      var Dr = un => {
        var Fn = H3e(),
          Rn = xe(Fn);
        jf(Rn, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var Kr = D(Rn, 2),
          Hr = C(Kr);
        jf(Hr, {
          class: "text-base-content/80 size-4"
        }), P(Kr), Z(un, Fn)
      };
      At(Br, un => {
        y(Cr) || un(Dr)
      })
    }
    P(ln), P(on), Bt(() => {
      Gr(on, 1, qa({
        tooltip: !0,
        "max-sm:h-6": y(jt),
        "max-sm:before:translate-x-1/4": y(rr) % 8 === 0 && y(Se).label.length > 7,
        "max-sm:before:-translate-x-1/4": (y(rr) - 7) % 8 === 0 && y(Se).label.length > 7,
        "max-xl:before:translate-x-1/4": y(rr) % 16 === 0 && y(Se).label.length > 7,
        "max-xl:before:-translate-x-1/4": (y(rr) - 15) % 16 === 0 && y(Se).label.length > 7,
        "xl:before:translate-x-1/4": y(jt) && y(rr) % 32 === 0 && y(Se).label.length > 7,
        "xl:before:-translate-x-1/4": y(jt) && (y(rr) - 31) % 32 === 0 && y(Se).label.length > 7
      })), pr(on, "data-tip", y(Se).label), Gr(ln, 1, qa({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": y(sr),
        "border-base-300": !y(sr) && y(De),
        "border-base-content/20": !y(sr) && !y(De),
        "max-sm:h-6 max-sm:rounded-md": y(jt)
      })), _a(ln, y(De) ? `background-image: url(${f3e}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${y(Le).r} ${y(Le).g} ${y(Le).b})`), pr(ln, "aria-label", y(Se).label), pr(ln, "id", `color-${y(Se).idx??""}`)
    }), jn("focus", ln, () => {
      y(Cr) && (Y(E, y(Se).idx, !0), Y(k, "pencil"))
    }), Z(Jt, on)
  }), P(we), P(Te);
  var be = D(Te, 2),
    Ee = C(be);
  Ee.__click = () => {
    Y(jt, !y(jt))
  };
  var Qe = C(Ee);
  {
    var Yt = Jt => {
        Hx(Jt, {
          class: "size-5"
        })
      },
      je = Jt => {
        Wx(Jt, {
          class: "size-5"
        })
      };
    At(Qe, Jt => {
      y(jt) ? Jt(Yt) : Jt(je, !1)
    })
  }
  P(Ee);
  var Fe = D(Ee, 2),
    Nr = C(Fe);
  {
    let Jt = ge(() => y(X) > 100 ? "animate-pulse" : ""),
      Se = ge(() => y(X) === 0 || y($) || y(xt) < 0);
    c0(Nr, {
      get class() {
        return y(Jt)
      },
      get charges() {
        return y(xt)
      },
      get disabled() {
        return y(Se)
      },
      get loading() {
        return y($)
      },
      onclick: async () => {
        mi.droppletAndPlop.play();
        const rr = [...c.values()];
        Y($, !0);
        try {
          const Le = await am();
          await fn.paint(rr, Le), await qf(rr), ur(), ze.refresh(), ud.shouldReload = !0, await Ae()
        } catch (Le) {
          Ne.error(`${Le.message}`, {
            duration: 7e3
          })
        } finally {
          Y($, !1)
        }
      }
    })
  }
  P(Fe);
  var Ar = D(Fe, 2),
    Kt = C(Ar),
    Oe = C(Kt),
    Be = C(Oe);
  Mn(), P(Oe);
  var fe = D(Oe, 2);
  let Me;
  fe.__click = () => {
    Y(k, y(k) === "eraser" ? "pencil" : "eraser", !0)
  };
  var cr = C(fe);
  Qp(cr, {
    class: "size-5",
    get filled() {
      return y(Dt)
    }
  }), P(fe), P(Kt), P(Ar), P(be), P(nr), os(nr, Jt => Y(Et, Jt), () => y(Et));
  var Ge = D(nr, 2);
  z3e(Ge, {
    get colorIdx() {
      return y(Vt)
    },
    get open() {
      return y(qt)
    },
    set open(Jt) {
      Y(qt, Jt, !0)
    }
  }), Bt((Jt, Se, rr, Le, sr, De) => {
    at(Or, `${Jt??""} `), at(dr, `${Se??""} `), Gr(ct, 1, qa({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !y(St),
      "btn-primary": y(St)
    })), pr(U, "data-tip", rr), nt = Gr(Q, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, nt, {
      "text-primary": !w()
    }), at(zt, `${Le??""} `), ie = Gr(Nt, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, ie, {
      "opacity-50": !ve.canUndo
    }), Nt.disabled = !ve.canUndo, at(vt, `${sr??""} `), Pt = Gr($t, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Pt, {
      "opacity-50": !ve.canRedo
    }), $t.disabled = !ve.canRedo, Gr(we, 1, qa({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": y(jt),
      "gap-1": !y(jt)
    })), at(Be, `${De??""} `), Me = Gr(fe, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, Me, {
      "btn-primary": y(Dt)
    }), fe.disabled = y(X) === 0
  }, [() => FV(), () => UT(), () => xv(), () => Tnt(), () => TW(), () => Yx()]), I_("innerHeight", Jt => Y(Zt, Jt, !0)), Z(l, _r), rn()
}
ri(["click"]);
var Y3e = ft('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <div class="tooltip tooltip-top"><div class="tooltip-content translate-x-[-30%] p-2"> </div> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog>');

function K3e(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(!1),
    z = ee(""),
    E = ee(0),
    k = ee(!1);
  cn(() => {
    t() && (async () => {
      try {
        Y(w, !0);
        const Ct = await fn.getUserLastAppeal();
        if (Ct === null) {
          Y(k, !1), Y(E, 0);
          return
        }
        const Wt = new Date(Ct),
          jt = 1440 * 60 * 1e3;
        Date.now() - Wt.getTime() < 90 * jt ? (Y(k, !0), Y(E, Math.ceil((Wt.getTime() + 90 * jt - Date.now()) / jt), !0)) : Y(E, 0)
      } catch (Ct) {
        Ne.error(Ct.message)
      } finally {
        Y(w, !1)
      }
    })()
  });
  var c = Y3e(),
    R = C(c),
    X = D(C(R), 2),
    $ = C(X, !0);
  P(X);
  var tt = D(X, 2),
    ut = C(tt),
    xt = C(ut);
  Sd(xt, () => Pk()), P(ut);
  var lt = D(ut, 2),
    G = C(lt);
  {
    let Ct = ge(() => Ok()),
      Wt = ge(() => Jk()),
      jt = ge(() => y(w) || y(k));
    ev(G, {
      get label() {
        return y(Ct)
      },
      get placeholder() {
        return y(Wt)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return y(jt)
      },
      get value() {
        return y(z)
      },
      set value(Ht) {
        Y(z, Ht, !0)
      }
    })
  }
  P(lt);
  var yt = D(lt, 2),
    Lt = C(yt);
  Lt.__click = () => {
    t(!1)
  };
  var Dt = C(Lt, !0);
  P(Lt);
  var St = D(Lt, 2),
    qt = C(St),
    Vt = C(qt, !0);
  P(qt);
  var Zt = D(qt, 2),
    Et = C(Zt, !0);
  P(Zt), P(St), P(yt), P(tt), P(R), P(c), eo(c, () => Ct => {
    cn(() => {
      t() ? Ct.show() : Ct.close()
    })
  }), Bt((Ct, Wt, jt, Ht) => {
    at($, Ct), Lt.disabled = y(w), at(Dt, Wt), at(Vt, jt), Zt.disabled = y(w) || y(k) || y(z).length <= 1, at(Et, Ht)
  }, [() => s.userData.banned ? hv() : ret(), () => la(), () => y(k) ? dk({
    days: y(E)
  }) : "", () => XJ()]), jn("close", c, () => t(!1)), jn("submit", tt, async () => {
    try {
      Y(w, !0), await fn.submitBanAppeal(y(z)), Ne.success(_5()), t(!1)
    } catch (Ct) {
      Ne.error(Ct.message, {
        duration: 5e3
      })
    } finally {
      Y(w, !1)
    }
  }), Z(l, c), rn()
}
ri(["click"]);
var J3e = ft("<span> </span>");

function Zy(l, s) {
  en(s, !0);
  var t = J3e(),
    w = C(t, !0);
  P(t), Bt(() => {
    Gr(t, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${s.count<10?"text-xs":"text-[10px]"} ${s.class??""}`), at(w, s.count < 10 ? s.count : "9+")
  }), Z(l, t), rn()
}
var Q3e = ft('<p class="text-error mt-1 text-sm"> </p>'),
  tTe = ft('<span class="loading loading-spinner center-absolute absolute"></span>'),
  eTe = ft('<dialog class="modal !bg-black/80"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 border-1 mt-6 w-full py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function rTe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(""),
    z = ee(null),
    E = ee(!1),
    k = ge(() => {
      var Ie;
      return ((Ie = ze.data) == null ? void 0 : Ie.name) ?? ""
    });
  cn(() => {
    t() || (Y(w, ""), Y(z, null))
  });
  var c = eTe(),
    R = C(c),
    X = D(C(R), 2),
    $ = C(X);
  r1($, {
    class: "text-error size-5"
  });
  var tt = D($, 2),
    ut = C(tt, !0);
  P(tt), P(X);
  var xt = D(X, 2),
    lt = C(xt),
    G = C(lt, !0);
  P(lt);
  var yt = D(lt);
  P(xt);
  var Lt = D(xt, 2),
    Dt = C(Lt);
  P(Lt);
  var St = D(Lt, 2),
    qt = C(St, !0);
  P(St);
  var Vt = D(St, 2);
  xo(Vt);
  var Zt = D(Vt, 2);
  {
    var Et = Ie => {
      var ne = Q3e(),
        Xe = C(ne, !0);
      P(ne), Bt(() => at(Xe, y(z))), Z(Ie, ne)
    };
    At(Zt, Ie => {
      y(z) && Ie(Et)
    })
  }
  var Ct = D(Zt, 2),
    Wt = C(Ct);
  Wt.__click = () => {
    t(!1)
  };
  var jt = C(Wt, !0);
  P(Wt);
  var Ht = D(Wt, 2);
  Ht.__click = async () => {
    if (y(w) !== y(k)) {
      Y(z, Dx(), !0);
      return
    }
    try {
      Y(E, !0), await fn.deleteMe(y(k)), Ne.warning(zw()), await ze.logout(), t(!1)
    } catch (Ie) {
      Ne.error(Ie.message)
    } finally {
      Y(E, !1)
    }
  };
  var _e = C(Ht),
    Ut = D(_e);
  {
    var Xt = Ie => {
      var ne = tTe();
      Z(Ie, ne)
    };
    At(Ut, Ie => {
      y(E) && Ie(Xt)
    })
  }
  P(Ht), P(Ct), P(R);
  var me = D(R, 2),
    Ce = C(me),
    Ve = C(Ce, !0);
  P(Ce), P(me), P(c), eo(c, () => Ie => {
    cn(() => {
      t() ? Ie.show() : Ie.close()
    })
  }), Bt((Ie, ne, Xe, pe, Ue, Ae, He, Tr, Ye) => {
    at(ut, Ie), at(G, ne), at(yt, ` ${Xe??""}`), at(Dt, `${pe??""} ${Ue??""}`), at(qt, y(k)), pr(Vt, "placeholder", Ae), at(jt, He), Ht.disabled = y(E), at(_e, `${Tr??""} `), at(Ve, Ye)
  }, [() => ef(), () => T5(), () => ztt(), () => WQ(), () => Ort(), () => Jrt(), () => C_(), () => ef(), () => la()]), jn("close", c, () => t(!1)), M_(Vt, () => y(w), Ie => Y(w, Ie)), Z(l, c), rn()
}
ri(["click"]);
var nTe = ft('<p class="text-base-content/80 text-sm"> </p>'),
  iTe = ft('<span class="loading loading-spinner center-absolute absolute"></span>'),
  oTe = ft('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function sTe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = $e(s, "type", 3, "confirmation"),
    z = $e(s, "buttonText", 19, () => cv()),
    E = ee(!1);
  _m(l, {
    dialogClass: "!bg-black/80",
    get open() {
      return t()
    },
    set open(k) {
      t(k)
    },
    children: (k, c) => {
      var R = oTe(),
        X = xe(R),
        $ = C(X, !0);
      P(X);
      var tt = D(X, 2),
        ut = C(tt, !0);
      P(tt);
      var xt = D(tt, 2);
      {
        var lt = Ct => {
          var Wt = nTe(),
            jt = C(Wt, !0);
          P(Wt), Bt(() => at(jt, s.subDescription)), Z(Ct, Wt)
        };
        At(xt, Ct => {
          s.subDescription && Ct(lt)
        })
      }
      var G = D(xt, 2),
        yt = C(G),
        Lt = C(yt),
        Dt = C(Lt, !0);
      P(Lt), P(yt);
      var St = D(yt, 2);
      let qt;
      St.__click = async () => {
        try {
          Y(E, !0), t(await s.onConfirm())
        } finally {
          Y(E, !1)
        }
      };
      var Vt = C(St),
        Zt = D(Vt);
      {
        var Et = Ct => {
          var Wt = iTe();
          Z(Ct, Wt)
        };
        At(Zt, Ct => {
          y(E) && Ct(Et)
        })
      }
      P(St), P(G), Bt(Ct => {
        at($, s.title), at(ut, s.description), at(Dt, Ct), qt = Gr(St, 1, "btn relative", null, qt, {
          "btn-error": w() === "warning",
          "btn-primary": w() === "confirmation"
        }), St.disabled = y(E), at(Vt, `${z()??""} `)
      }, [() => C_()]), Z(k, R)
    },
    $$slots: {
      default: !0
    }
  }), rn()
}
ri(["click"]);

function aTe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  {
    let w = ge(() => rv()),
      z = ge(() => BD()),
      E = ge(() => iX());
    sTe(l, {
      type: "warning",
      get title() {
        return y(w)
      },
      get description() {
        return y(z)
      },
      get subDescription() {
        return y(E)
      },
      onConfirm: async () => {
        try {
          return await fn.deleteSessions(), Ne.success(n1()), await ze.logout(), !0
        } catch {
          return Ne.error(i1()), !1
        }
      },
      get open() {
        return t()
      },
      set open(k) {
        t(k)
      }
    })
  }
  rn()
}
var uTe = ft('<span class="center-absolute loading loading-spinner absolute"></span>'),
  cTe = ft('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  lTe = ft('<span class="center-absolute loading loading-spinner absolute"></span>'),
  _Te = ft('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  hTe = ft('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  dTe = ft('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  pTe = ft('<button class="btn btn-error btn-soft"><!> </button>'),
  fTe = ft('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="flex w-full flex-col gap-3"><div class="tooltip tooltip-bottom"><!></div> <!> <label class="label whitespace-pre-line text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!>', 1);

function mTe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(Qi(s.userData.name)),
    z = ee(Qi(s.userData.discord)),
    E = ee(Qi(s.userData.showLastPixel)),
    k = ee(!1),
    c = ee(void 0),
    R = ee(!1),
    X = ee(!1);
  const $ = Rx("2025-09_discord_linking");
  let tt = ee(!!s.userData.discordId),
    ut = ee(void 0),
    xt = ee(void 0);
  cn(() => {
    Y(w, s.userData.name, !0), Y(E, s.userData.showLastPixel, !0)
  }), cn(() => {
    t() && !y(c) && fn.getMyProfilePictures().then(er => {
      Y(c, er, !0)
    }).catch(er => {
      Ne.error(er.message)
    })
  });
  let lt = ee(!1);
  async function G(er) {
    try {
      Y(lt, !0), await fn.changeProfilePicture(er), await ze.refresh()
    } finally {
      Y(lt, !1)
    }
  }
  var yt = fTe(),
    Lt = xe(yt),
    Dt = C(Lt),
    St = D(C(Dt), 2),
    qt = C(St, !0);
  P(St);
  var Vt = D(St, 2),
    Zt = C(Vt),
    Et = C(Zt),
    Ct = C(Et),
    Wt = C(Ct);
  ws(Wt, {
    class: "size-30",
    get userId() {
      return s.userData.id
    },
    get pictureUrl() {
      return s.userData.picture
    }
  });
  var jt = D(Wt, 2),
    Ht = C(jt);
  Ky(Ht, {
    class: "size-5"
  }), P(jt), P(Ct);
  var _e = D(Ct, 2);
  {
    var Ut = er => {
      var hr = hTe(),
        Mr = C(hr),
        Pr = C(Mr, !0);
      P(Mr);
      var Or = D(Mr, 2),
        jr = C(Or);
      {
        var Lr = dr => {
          var ct = cTe();
          ct.__click = () => {
            G()
          };
          var q = C(ct);
          ws(q, {
            class: "size-10 border",
            get userId() {
              return s.userData.id
            }
          });
          var U = D(q, 2);
          {
            var Q = nt => {
              var _t = uTe();
              Z(nt, _t)
            };
            At(U, nt => {
              y(lt) && nt(Q)
            })
          }
          P(ct), Bt(() => ct.disabled = y(lt)), Z(dr, ct)
        };
        At(jr, dr => {
          s.userData.picture && dr(Lr)
        })
      }
      var _n = D(jr, 2);
      di(_n, 17, () => y(c), dr => dr.id, (dr, ct) => {
        var q = kr(),
          U = xe(q);
        {
          var Q = nt => {
            var _t = _Te();
            _t.__click = () => {
              G(y(ct).id)
            };
            var Tt = C(_t);
            ws(Tt, {
              class: "size-10 border",
              get userId() {
                return s.userData.id
              },
              get pictureUrl() {
                return y(ct).url
              }
            });
            var Ft = D(Tt, 2);
            {
              var zt = Nt => {
                var ie = lTe();
                Z(Nt, ie)
              };
              At(Ft, Nt => {
                y(lt) && Nt(zt)
              })
            }
            P(_t), Bt(() => _t.disabled = y(lt)), Z(nt, _t)
          };
          At(U, nt => {
            s.userData.picture !== y(ct).url && nt(Q)
          })
        }
        Z(dr, q)
      }), P(Or), P(hr), Bt(dr => at(Pr, dr), [() => G3()]), Z(er, hr)
    };
    At(_e, er => {
      var hr;
      (hr = y(c)) != null && hr.length && er(Ut)
    })
  }
  P(Et);
  var Xt = D(Et, 2),
    me = C(Xt),
    Ce = C(me);
  {
    let er = ge(() => rf()),
      hr = ge(() => rf());
    cf(Ce, {
      get label() {
        return y(er)
      },
      get placeholder() {
        return y(hr)
      },
      min: 1,
      max: 16,
      get value() {
        return y(w)
      },
      set value(Mr) {
        Y(w, Mr, !0)
      },
      get validate() {
        return y(ut)
      },
      set validate(Mr) {
        Y(ut, Mr, !0)
      }
    })
  }
  P(me);
  var Ve = D(me, 2);
  {
    var Ie = er => {
        var hr = kr(),
          Mr = xe(hr);
        {
          var Pr = jr => {
              var Lr = dTe(),
                _n = C(Lr);
              _f(_n, {
                class: "size-4.5"
              });
              var dr = D(_n);
              P(Lr), Bt((ct, q) => {
                pr(Lr, "href", ct), at(dr, ` ${q??""}`)
              }, [() => Bx("/discord/authorize"), () => dL()]), Z(jr, Lr)
            },
            Or = jr => {
              var Lr = pTe();
              Lr.__click = async () => {
                try {
                  Y(k, !0), await fn.unlinkDiscord(), ze.refresh(), Ne.success(Ynt()), Y(tt, !1)
                } catch (ct) {
                  Ne.error(ct.message, {
                    duration: 5e3
                  })
                } finally {
                  Y(k, !1)
                }
              };
              var _n = C(Lr);
              _f(_n, {
                class: "size-4.5"
              });
              var dr = D(_n);
              P(Lr), Bt(ct => {
                Lr.disabled = y(k), at(dr, ` ${ct??""}`)
              }, [() => {
                var ct;
                return Bnt({
                  username: ((ct = s.userData) == null ? void 0 : ct.discord) ?? ""
                })
              }]), Z(jr, Lr)
            };
          At(Mr, jr => {
            y(tt) ? jr(Or, !1) : jr(Pr)
          })
        }
        Z(er, hr)
      },
      ne = er => {
        {
          let hr = ge(() => oC());
          cf(er, {
            label: "Discord",
            get placeholder() {
              return y(hr)
            },
            max: 32,
            get value() {
              return y(z)
            },
            set value(Mr) {
              Y(z, Mr, !0)
            },
            get validate() {
              return y(xt)
            },
            set validate(Mr) {
              Y(xt, Mr, !0)
            }
          })
        }
      };
    At(Ve, er => {
      $ ? er(Ie) : er(ne, !1)
    })
  }
  var Xe = D(Ve, 2),
    pe = C(Xe);
  xo(pe);
  var Ue = D(pe);
  P(Xe), P(Xt), P(Zt);
  var Ae = D(Zt, 2),
    He = C(Ae),
    Tr = C(He),
    Ye = C(Tr, !0);
  P(Tr);
  var mr = D(Tr, 2),
    se = C(mr),
    ce = C(se);
  ce.__click = () => {
    Y(X, !0)
  };
  var ur = C(ce, !0);
  P(ce), P(se);
  var Ke = D(se, 2),
    ve = C(Ke);
  ve.__click = () => {
    Y(R, !0)
  };
  var _r = C(ve, !0);
  P(ve), P(Ke), P(mr), P(He);
  var nr = D(He, 2),
    gr = C(nr);
  gr.__click = () => {
    t(!1)
  };
  var ir = C(gr, !0);
  P(gr);
  var Ze = D(gr, 2),
    or = C(Ze, !0);
  P(Ze), P(nr), P(Ae), P(Vt), P(Dt), P(Lt), eo(Lt, () => er => {
    cn(() => {
      t() ? er.show() : er.close()
    })
  });
  var de = D(Lt, 2);
  rTe(de, {
    get open() {
      return y(R)
    },
    set open(er) {
      Y(R, er, !0)
    }
  });
  var zr = D(de, 2);
  aTe(zr, {
    get open() {
      return y(X)
    },
    set open(er) {
      Y(X, er, !0)
    }
  }), Bt((er, hr, Mr, Pr, Or, jr, Lr, _n, dr) => {
    at(qt, er), pr(jt, "data-tip", hr), pr(me, "data-tip", Mr), at(Ue, ` ${Pr??""}`), at(Ye, Or), at(ur, jr), at(_r, Lr), gr.disabled = y(k), at(ir, _n), Ze.disabled = y(k), at(or, dr)
  }, [() => mI(), () => Jx(), () => mF(), () => OK(), () => vB(), () => rv(), () => ef(), () => la(), () => f1()]), jn("close", Lt, () => t(!1)), jn("submit", Vt, async () => {
    var er;
    try {
      if (!((er = y(ut)) != null && er())) return;
      Y(k, !0), await fn.updateMe({
        name: y(w),
        showLastPixel: y(E)
      }), ze.refresh(), Ne.success(dH()), t(!1)
    } catch (hr) {
      Ne.error(hr.message, {
        duration: 5e3
      })
    } finally {
      Y(k, !1)
    }
  }), Nf(pe, () => y(E), er => Y(E, er)), Z(l, yt), rn()
}
ri(["click"]);
var gTe = $r('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function yTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = gTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var vTe = $r('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function bTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = vTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var xTe = $r('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function wTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = xTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var kTe = $r('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function Gy(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = kTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var TTe = $r('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function STe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = TTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var PTe = $r('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function MTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = PTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var CTe = $r('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function ITe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = CTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...t
  }), void 0, void 0, void 0, "svelte-14mu38d"), Z(l, w)
}
var zTe = $r('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function Lf(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = zTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var ATe = $r('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function Xp(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = ATe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var ETe = $r('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function jTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = ETe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var LTe = $r('<svg><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"></path></svg>');

function DTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = LTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var RTe = $r('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function d0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = RTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var BTe = $r('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function FTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = BTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var OTe = $r('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function qTe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = OTe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var NTe = ft('<span class="tooltip font-flag ml-0.5"> </span>'),
  VTe = ft('<div class="mt-1"><!></div>'),
  UTe = ft('<p class="w-full"> <!></p>'),
  ZTe = ft('<p class="w-full"><!></p>'),
  GTe = ft('<div class=" flex items-center gap-2"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  HTe = ft('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  WTe = ft("<li><button><!> </button></li>"),
  $Te = ft('<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'),
  XTe = ft('<button class="btn btn-sm btn-circle tooltip"><!></button>'),
  YTe = ft('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  KTe = ft('<a class="btn w-full" target="_blank"><!> </a>'),
  JTe = ft('<a class="btn w-full" target="_blank"><!> </a>'),
  QTe = ft('<a class="btn w-full" target="_blank"><!> </a>'),
  tSe = ft('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1),
  eSe = ft('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle tooltip"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 max-h-[50svh] w-max flex-nowrap overflow-y-auto rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <!> <button class="btn btn-sm btn-circle tooltip relative before:-left-1/2"><!> <!></button></div></div>  <!> <!> <!> <!> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> </a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> </a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function rSe(l, s) {
  var lt;
  en(s, !0);
  let t = ee(!1),
    w = ee(!1),
    z = ee(!0);

  function E() {
    var G;
    (G = document.activeElement) == null || G.blur()
  }
  const k = [{
    label: "ğŸ‡ºğŸ‡¸ English",
    key: "en"
  }, {
    label: "ğŸ‡§ğŸ‡· PortuguÃªs",
    key: "pt"
  }, ...(lt = s.user.data) != null && lt.role && s.user.data.role !== "user" ? [{
    label: "ğŸ‡¨ğŸ‡³ ä¸­æ–‡",
    key: "ch"
  }, {
    label: "ğŸ‡©ğŸ‡ª Deutsch",
    key: "de"
  }, {
    label: "ğŸ‡ªğŸ‡¸ EspaÃ±ol",
    key: "es"
  }, {
    label: "ğŸ‡«ğŸ‡· FranÃ§ais",
    key: "fr"
  }, {
    label: "ğŸ‡®ğŸ‡¹ Italiano",
    key: "it"
  }, {
    label: "ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª",
    key: "jp"
  }, {
    label: "ğŸ‡µğŸ‡± Polski",
    key: "pl"
  }, {
    label: "ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹",
    key: "ru"
  }, {
    label: "ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°",
    key: "uk"
  }, {
    label: "ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t",
    key: "vi"
  }] : []];
  let c = ee(""),
    R = ee(void 0);
  const X = ge(() => !!s.user.timeoutUntil);
  let $ = ee("");
  ti(async () => {
    if (s.user.data || await s.user.refresh(), s.user.hasAnyPermission(Ri.dashboard.summary)) {
      Y($, `${gi.url.origin}/dashboard/summary`);
      return
    }
    if (s.user.hasAnyPermission(Ri.dashboard.team)) {
      Y($, `${gi.url.origin}/dashboard/team`);
      return
    }
    if (s.user.hasAnyPermission(Ri.dashboard.users)) {
      Y($, `${gi.url.origin}/dashboard/users`);
      return
    }
    if (s.user.hasAnyPermission(Ri.dashboard.permissions)) {
      Y($, `${gi.url.origin}/dashboard/permissions`);
      return
    }
    if (s.user.hasAnyPermission(Ri.dashboard.alliances)) {
      Y($, `${gi.url.origin}/dashboard/alliances`);
      return
    }
    if (s.user.hasAnyPermission(Ri.dashboard.auditLogs)) {
      Y($, `${gi.url.origin}/dashboard/audit-logs`);
      return
    }
    if (s.user.hasAnyPermission(Ri.dashboard.banWaves)) {
      Y($, `${gi.url.origin}/dashboard/ban-waves`);
      return
    }
  });
  var tt = kr(),
    ut = xe(tt);
  {
    var xt = G => {
      var yt = eSe(),
        Lt = xe(yt),
        Dt = C(Lt);
      let St;
      var qt = C(Dt);
      Qy(qt, {
        get userId() {
          return s.user.data.id
        },
        get level() {
          return s.user.data.level
        },
        get pictureUrl() {
          return s.user.data.picture
        }
      });
      var Vt = D(qt, 2);
      {
        var Zt = fe => {
          Zy(fe, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return s.user.notificiationCount
            }
          })
        };
        At(Vt, fe => {
          s.user.notificiationCount && fe(Zt)
        })
      }
      P(Dt);
      var Et = D(Dt, 2),
        Ct = C(Et);
      Ct.__click = E;
      var Wt = C(Ct);
      pa(Wt, {
        class: "size-5"
      }), P(Ct);
      var jt = D(Ct, 2),
        Ht = C(jt),
        _e = C(Ht);
      ws(_e, {
        get userId() {
          return s.user.data.id
        },
        get pictureUrl() {
          return s.user.data.picture
        },
        get isSuspended() {
          return y(X)
        }
      });
      var Ut = D(_e, 2);
      Ut.__click = () => {
        Y(t, !0)
      };
      var Xt = C(Ut);
      lf(Xt, {
        class: "size-4"
      }), P(Ut), P(Ht);
      var me = D(Ht, 2),
        Ce = C(me),
        Ve = C(Ce),
        Ie = C(Ve, !0);
      P(Ve);
      var ne = D(Ve, 2),
        Xe = C(ne);
      P(ne);
      var pe = D(ne, 2);
      {
        var Ue = fe => {
          const Me = ge(() => Ls(s.user.data.equippedFlag));
          var cr = NTe(),
            Ge = C(cr, !0);
          P(cr), Bt(() => {
            pr(cr, "data-tip", y(Me).name), at(Ge, y(Me).flag)
          }), Z(fe, cr)
        };
        At(pe, fe => {
          s.user.data.equippedFlag && fe(Ue)
        })
      }
      var Ae = D(pe, 2);
      {
        var He = fe => {
          var Me = VTe(),
            cr = C(Me);
          j_(cr, {
            get username() {
              return s.user.data.discord
            },
            get id() {
              return s.user.data.discordId
            }
          }), P(Me), Z(fe, Me)
        };
        At(Ae, fe => {
          s.user.data.discord && fe(He)
        })
      }
      P(Ce);
      var Tr = D(Ce, 2),
        Ye = C(Tr);
      vu(Ye, {
        class: "inline size-4"
      });
      var mr = D(Ye, 2),
        se = C(mr),
        ce = D(se),
        ur = C(ce, !0);
      P(ce), P(mr), P(Tr);
      var Ke = D(Tr, 2),
        ve = C(Ke);
      yTe(ve, {
        class: "inline size-4"
      });
      var _r = D(ve, 2),
        nr = C(_r),
        gr = C(nr);
      P(nr);
      var ir = D(nr),
        Ze = D(ir),
        or = C(Ze);
      Yl(or, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), P(Ze), P(_r), P(Ke), P(me), P(jt);
      var de = D(jt, 2),
        zr = C(de);
      {
        var er = fe => {
          var Me = GTe(),
            cr = C(Me);
          Lf(cr, {
            class: "size-6 text-red-500"
          });
          var Ge = D(cr, 2);
          {
            var qr = Le => {
                var sr = UTe(),
                  De = C(sr),
                  Cr = D(De);
                {
                  var on = Br => {
                      var Dr = to();
                      Bt(un => at(Dr, `(${un??""})`), [() => _y({
                        reason: Ox()
                      })]), Z(Br, Dr)
                    },
                    ln = Br => {
                      var Dr = kr(),
                        un = xe(Dr);
                      {
                        var Fn = Rn => {
                          var Kr = to();
                          Bt(Hr => at(Kr, `(${Hr??""})`), [() => _y({
                            reason: qx()
                          })]), Z(Rn, Kr)
                        };
                        At(un, Rn => {
                          s.user.data.suspensionReason === "multi-accounting" && Rn(Fn)
                        }, !0)
                      }
                      Z(Br, Dr)
                    };
                  At(Cr, Br => {
                    s.user.data.suspensionReason === "bot" ? Br(on) : Br(ln, !1)
                  })
                }
                P(sr), Bt(Br => at(De, `${Br??""} `), [() => nat()]), Z(Le, sr)
              },
              lr = Le => {
                var sr = kr(),
                  De = xe(sr);
                {
                  var Cr = on => {
                    var ln = ZTe(),
                      Br = C(ln);
                    Sd(Br, () => Fx({
                      until: `<span class="text-secondary font-medium text-nowrap">${s.user.timeoutUntil.toLocaleString()}</span>`
                    })), P(ln), Z(on, ln)
                  };
                  At(De, on => {
                    s.user.timeoutUntil && on(Cr)
                  }, !0)
                }
                Z(Le, sr)
              };
            At(Ge, Le => {
              s.user.data.timeoutUntil && new Date(s.user.data.timeoutUntil).getTime() >= Date.now() + 31536e6 ? Le(qr) : Le(lr, !1)
            })
          }
          var Jt = D(Ge, 2);
          Jt.__click = Le => {
            var sr;
            (sr = s.onbanappeal) == null || sr.call(s)
          };
          var Se = C(Jt);
          Lf(Se, {
            class: "size-5 text-red-500"
          });
          var rr = D(Se, 1, !0);
          P(Jt), P(Me), Bt(Le => at(rr, Le), [() => met()]), Z(fe, Me)
        };
        At(zr, fe => {
          y(X) && fe(er)
        })
      }
      var hr = D(zr, 2),
        Mr = C(hr),
        Pr = C(Mr, !0);
      P(Mr);
      var Or = D(Mr, 2),
        jr = C(Or),
        Lr = C(jr),
        _n = C(Lr);
      jTe(_n, {
        class: "size-4"
      }), P(Lr);
      var dr = D(Lr, 2);
      di(dr, 21, () => k, P_, (fe, Me) => {
        const cr = ge(() => y(c) === y(Me).key),
          Ge = ge(() => v1() === y(Me).key);
        var qr = WTe(),
          lr = C(qr);
        let Jt;
        lr.__click = () => {
          localStorage.setItem(t1, y(Me).key), Y(c, y(Me).key, !0), location.reload()
        };
        var Se = C(lr);
        {
          var rr = sr => {
            var De = HTe();
            Z(sr, De)
          };
          At(Se, sr => {
            y(cr) && sr(rr)
          })
        }
        var Le = D(Se);
        P(lr), P(qr), Bt(() => {
          Jt = Gr(lr, 1, "font-flag relative font-medium", null, Jt, {
            "bg-base-200": y(cr),
            "bg-base-300": y(Ge)
          }), at(Le, ` ${y(Me).label??""}`)
        }), Z(fe, qr)
      }), P(dr), P(jr);
      var ct = D(jr, 2),
        q = C(ct);
      q.__click = () => {
        zo.muted = !zo.muted
      };
      var U = C(q);
      {
        var Q = fe => {
            FTe(fe, {
              class: "size-4"
            })
          },
          nt = fe => {
            qTe(fe, {
              class: "size-4"
            })
          };
        At(U, fe => {
          zo.muted ? fe(Q) : fe(nt, !1)
        })
      }
      P(q), P(ct);
      var _t = D(ct, 2);
      {
        var Tt = fe => {
          var Me = $Te(),
            cr = C(Me);
          cr.__click = () => {
            zo.theme = zo.theme === "dark" ? "custom-winter" : "dark"
          };
          var Ge = C(cr);
          {
            var qr = Jt => {
                wTe(Jt, {
                  class: "size-4"
                })
              },
              lr = Jt => {
                bTe(Jt, {
                  class: "size-4"
                })
              };
            At(Ge, Jt => {
              zo.theme === "dark" ? Jt(qr) : Jt(lr, !1)
            })
          }
          P(cr), P(Me), Bt(Jt => pr(Me, "data-tip", Jt), [() => zo.theme === "dark" ? Nj() : uM()]), Z(fe, Me)
        };
        At(_t, fe => {
          s.user.hasPermission(Ri.ui.themeDarkMode) && fe(Tt)
        })
      }
      var Ft = D(_t, 2);
      {
        var zt = fe => {
          var Me = XTe();
          Me.__click = () => {
            var lr;
            Y(z, !y(z)), (lr = s.ontogglepixelarts) == null || lr.call(s, y(z))
          };
          var cr = C(Me);
          {
            var Ge = lr => {
                DTe(lr, {
                  class: "size-4"
                })
              },
              qr = lr => {
                d0(lr, {
                  class: "size-4"
                })
              };
            At(cr, lr => {
              y(z) ? lr(qr, !1) : lr(Ge)
            })
          }
          P(Me), Bt(lr => pr(Me, "data-tip", lr), [() => y(z) == !1 ? JK() : u6()]), Z(fe, Me)
        };
        At(Ft, fe => {
          s.user.hasPermission(Ri.ui.tooglePixelArt) && fe(zt)
        })
      }
      var Nt = D(Ft, 2);
      Nt.__click = function(...fe) {
        var Me;
        (Me = s.onnotificationclick) == null || Me.apply(this, fe)
      };
      var ie = C(Nt);
      STe(ie, {
        class: "size-4"
      });
      var mt = D(ie, 2);
      {
        var et = fe => {
          Zy(fe, {
            class: "absolute -right-1 -top-1",
            get count() {
              return s.user.notificiationCount
            }
          })
        };
        At(mt, fe => {
          s.user.notificiationCount && fe(et)
        })
      }
      P(Nt), P(Or), P(hr);
      var W = D(hr, 2);
      {
        var vt = fe => {
          var Me = YTe();
          Me.__click = async () => {
            var qr;
            try {
              const lr = await ((qr = y(R)) == null ? void 0 : qr.prompt());
              (lr == null ? void 0 : lr.outcome) === "accepted" && Y(R, void 0)
            } catch (lr) {
              Ne.error(PS({
                error: lr.message
              }))
            }
          };
          var cr = C(Me);
          Hf(cr, {
            class: "size-5"
          });
          var Ge = D(cr);
          P(Me), Bt(qr => at(Ge, ` ${qr??""}`), [() => g8()]), Z(fe, Me)
        };
        At(W, fe => {
          y(R) && fe(vt)
        })
      }
      var $t = D(W, 2);
      {
        var Pt = fe => {
          var Me = KTe(),
            cr = C(Me);
          Xp(cr, {
            class: "size-5"
          });
          var Ge = D(cr);
          P(Me), Bt(qr => {
            pr(Me, "href", y($)), at(Ge, ` ${qr??""}`)
          }, [() => w1()]), Z(fe, Me)
        };
        At($t, fe => {
          s.user.hasAnyPermission(Ri.dashboard) && fe(Pt)
        })
      }
      var Gt = D($t, 2);
      {
        var ae = fe => {
          var Me = JTe(),
            cr = C(Me);
          Xp(cr, {
            class: "size-5"
          });
          var Ge = D(cr);
          P(Me), Bt(qr => {
            pr(Me, "href", `${gi.url.origin??""}/tickets`), at(Ge, ` ${qr??""}`)
          }, [() => Utt()]), Z(fe, Me)
        };
        At(Gt, fe => {
          s.user.hasAnyPermission(Ri.tickets) && fe(ae)
        })
      }
      var ye = D(Gt, 2);
      {
        var Te = fe => {
          var Me = QTe(),
            cr = C(Me);
          Xp(cr, {
            class: "size-5"
          });
          var Ge = D(cr);
          P(Me), Bt(qr => {
            pr(Me, "href", `${gi.url.origin??""}/appeals`), at(Ge, ` ${qr??""}`)
          }, [() => x1()]), Z(fe, Me)
        };
        At(ye, fe => {
          s.user.hasAnyPermission(Ri.appeals) && fe(Te)
        })
      }
      var we = D(ye, 2),
        be = C(we);
      uf(be, {
        class: "size-5"
      });
      var Ee = D(be);
      P(we);
      var Qe = D(we, 2),
        Yt = C(Qe);
      ITe(Yt, {
        class: "size-5"
      });
      var je = D(Yt);
      P(Qe);
      var Fe = D(Qe, 2);
      {
        var Nr = fe => {
          var Me = tSe(),
            cr = xe(Me),
            Ge = C(cr),
            qr = C(Ge);
          MTe(qr, {
            class: "size-5"
          });
          var lr = D(qr);
          P(Ge), P(cr);
          var Jt = D(cr, 2),
            Se = C(Jt);
          Yl(Se, {
            class: "size-5"
          });
          var rr = D(Se);
          P(Jt), Bt((Le, sr, De) => {
            pr(cr, "action", `${Lx}/payment/create-portal-session`), at(lr, ` ${Le??""}`), pr(Jt, "href", sr), at(rr, ` ${De??""}`)
          }, [() => a1(), av, () => vv()]), Z(fe, Me)
        };
        At(Fe, fe => {
          var Me;
          (Me = s.user.data) != null && Me.isCustomer && fe(Nr)
        })
      }
      var Ar = D(Fe, 2);
      Ar.__click = async () => {
        var fe;
        try {
          Y(w, !0), await s.user.logout(), E(), Ne.warning(TD(), {
            icon: Gy
          }), (fe = s.onlogout) == null || fe.call(s)
        } catch {
          Ne.error(OS())
        } finally {
          Y(w, !1)
        }
      };
      var Kt = C(Ar);
      Gy(Kt, {
        class: "size-5"
      });
      var Oe = D(Kt);
      P(Ar), P(de), P(Et), P(Lt);
      var Be = D(Lt, 2);
      mTe(Be, {
        get userData() {
          return s.user.data
        },
        get open() {
          return y(t)
        },
        set open(fe) {
          Y(t, fe, !0)
        }
      }), Bt((fe, Me, cr, Ge, qr, lr, Jt, Se, rr, Le, sr, De, Cr, on) => {
        St = Gr(Dt, 1, "btn relative size-12 p-0 shadow-md", null, St, {
          "bg-red-500": y(X)
        }), pr(Dt, "title", fe), pr(Ve, "title", s.user.data.name), at(Ie, s.user.data.name), Gr(ne, 1, Me), at(Xe, `#${s.user.data.id??""}`), at(se, `${cr??""}: `), at(ur, Ge), at(gr, `Level ${qr??""}`), at(ir, ` (${lr??""}%) `), pr(Ze, "data-tip", Jt), at(Pr, Se), pr(Lr, "data-tip", rr), pr(ct, "data-tip", Le), pr(Nt, "data-tip", sr), at(Ee, ` ${De??""}`), at(je, ` ${Cr??""}`), Ar.disabled = y(w), at(Oe, ` ${on??""}`)
      }, [() => _J(), () => qa(Ji(s.user.data.id)), () => Gf(), () => s.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(s.user.data.level), () => Math.floor(s.user.data.level % 1 * 100), () => wR(), () => WR(), () => E3(), () => zo.muted ? wit() : EB(), () => mv(), () => o1(), () => $x(), () => s1()]), jn("focus", Dt, () => {
        Y(R, window.pwaInstallPrompt, !0)
      }), Z(G, yt)
    };
    At(ut, G => {
      s.user.data && s.user.charges !== void 0 && G(xt)
    })
  }
  Z(l, tt), rn()
}
ri(["click"]);
var nSe = ft('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  iSe = ft('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  oSe = ft('<span class="font-flag tooltip ml-0.5"> </span>'),
  sSe = ft("<span> </span>"),
  aSe = ft('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  uSe = ft('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  cSe = ft('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  lSe = ft('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  _Se = ft('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  hSe = ft('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function dSe(l, s) {
  en(s, !0);
  const t = [];
  let w = ee("today"),
    z = {
      players: {
        label: yv(),
        icon: zd
      },
      alliances: {
        label: uv(),
        icon: Ad
      }
    },
    E = ee("players"),
    k = Qi({
      players: {},
      alliances: {}
    });
  const c = ge(() => k[y(E)][y(w)]);
  cn(() => {
    if (y(c)) return;
    const G = y(w),
      yt = y(E);
    yt === "players" ? fn.leaderboardRegionPlayers(s.regionId, G).then(Lt => {
      k[yt][G] = Lt
    }).catch(Lt => {
      Ne.error(Lt.message)
    }) : yt === "alliances" && fn.leaderboardRegionAlliances(s.regionId, G).then(Lt => {
      k[yt][G] = Lt
    }).catch(Lt => {
      Ne.error(Lt.message)
    })
  });
  var R = hSe(),
    X = xe(R);
  di(X, 21, () => Object.entries(z), ([G, {
    label: yt,
    icon: Lt
  }]) => G, (G, yt) => {
    var Lt = ge(() => $y(y(yt), 2));
    let Dt = () => y(Lt)[0],
      St = () => y(Lt)[1].label,
      qt = () => y(Lt)[1].icon;
    const Vt = ge(qt);
    var Zt = nSe(),
      Et = C(Zt);
    xo(Et);
    var Ct, Wt = D(Et, 2);
    bo(Wt, () => y(Vt), (Ht, _e) => {
      _e(Ht, {
        get this() {
          return qt()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var jt = D(Wt);
    P(Zt), Bt(() => {
      pr(Et, "aria-label", St()), Ct !== (Ct = Dt()) && (Et.value = (Et.__value = Dt()) ?? ""), at(jt, ` ${St()??""}`)
    }), Vf(t, [], Et, () => (Dt(), y(E)), Ht => Y(E, Ht)), Z(G, Zt)
  }), P(X);
  var $ = D(X, 2),
    tt = C($);
  um(tt, {
    get value() {
      return y(w)
    },
    set value(G) {
      Y(w, G, !0)
    }
  }), P($);
  var ut = D($, 2);
  {
    var xt = G => {
        var yt = iSe(),
          Lt = C(yt),
          Dt = D(Lt);
        {
          var St = Vt => {
              var Zt = to();
              Bt(Et => at(Zt, Et), [() => Id().toLowerCase()]), Z(Vt, Zt)
            },
            qt = Vt => {
              var Zt = kr(),
                Et = xe(Zt);
              {
                var Ct = jt => {
                    var Ht = to();
                    Bt(_e => at(Ht, _e), [() => em()]), Z(jt, Ht)
                  },
                  Wt = jt => {
                    var Ht = kr(),
                      _e = xe(Ht);
                    {
                      var Ut = Xt => {
                        var me = to();
                        Bt(Ce => at(me, Ce), [() => tm()]), Z(Xt, me)
                      };
                      At(_e, Xt => {
                        y(w) === "month" && Xt(Ut)
                      }, !0)
                    }
                    Z(jt, Ht)
                  };
                At(Et, jt => {
                  y(w) === "week" ? jt(Ct) : jt(Wt, !1)
                }, !0)
              }
              Z(Vt, Zt)
            };
          At(Dt, Vt => {
            y(w) === "today" ? Vt(St) : Vt(qt, !1)
          })
        }
        P(yt), Bt(Vt => at(Lt, `${Vt??""} `), [() => Qf()]), Z(G, yt)
      },
      lt = G => {
        var yt = kr(),
          Lt = xe(yt);
        {
          var Dt = qt => {
              var Vt = kr(),
                Zt = xe(Vt);
              {
                var Et = Wt => {
                    const jt = ge(() => y(c));
                    var Ht = uSe(),
                      _e = C(Ht),
                      Ut = C(_e),
                      Xt = D(C(Ut)),
                      me = C(Xt, !0);
                    P(Xt);
                    var Ce = D(Xt),
                      Ve = C(Ce),
                      Ie = D(Ve, 2, !0);
                    P(Ce), P(Ut), P(_e);
                    var ne = D(_e);
                    di(ne, 31, () => y(jt), Xe => Xe.id, (Xe, pe, Ue) => {
                      const Ae = ge(() => {
                        var Pr;
                        return ((Pr = ze.data) == null ? void 0 : Pr.id) === y(pe).id
                      });
                      var He = aSe();
                      let Tr;
                      var Ye = C(He),
                        mr = C(Ye, !0);
                      P(Ye);
                      var se = D(Ye),
                        ce = C(se),
                        ur = C(ce);
                      ws(ur, {
                        class: "size-10 border",
                        get userId() {
                          return y(pe).id
                        },
                        get pictureUrl() {
                          return y(pe).picture
                        }
                      });
                      var Ke = D(ur, 2),
                        ve = C(Ke),
                        _r = C(ve),
                        nr = D(_r),
                        gr = C(nr);
                      P(nr), P(ve);
                      var ir = D(ve, 2);
                      {
                        var Ze = Pr => {
                          const Or = ge(() => Ls(y(pe).equippedFlag));
                          var jr = oSe(),
                            Lr = C(jr, !0);
                          P(jr), Bt(() => {
                            pr(jr, "data-tip", y(Or).name), at(Lr, y(Or).flag)
                          }), Z(Pr, jr)
                        };
                        At(ir, Pr => {
                          "equippedFlag" in y(pe) && y(pe).equippedFlag && Pr(Ze)
                        })
                      }
                      var or = D(ir, 2);
                      {
                        var de = Pr => {
                          j_(Pr, {
                            get username() {
                              return y(pe).discord
                            },
                            get id() {
                              return y(pe).discordId
                            }
                          })
                        };
                        At(or, Pr => {
                          y(pe).discord && Pr(de)
                        })
                      }
                      var zr = D(or, 2);
                      {
                        var er = Pr => {
                          var Or = sSe(),
                            jr = C(Or, !0);
                          P(Or), Bt((Lr, _n) => {
                            Gr(Or, 1, `badge badge-sm ml-0.5 border-0 ${Lr??""} ${_n??""}`), at(jr, y(pe).allianceName)
                          }, [() => Td(y(pe).allianceId), () => Ji(y(pe).allianceId)]), Z(Pr, Or)
                        };
                        At(zr, Pr => {
                          "allianceName" in y(pe) && y(pe).allianceName && Pr(er)
                        })
                      }
                      P(Ke), P(ce), P(se);
                      var hr = D(se),
                        Mr = C(hr, !0);
                      P(hr), P(He), Bt((Pr, Or) => {
                        Tr = Gr(He, 1, "", null, Tr, {
                          "bg-base-200": y(Ae)
                        }), at(mr, y(Ue) + 1), Gr(ve, 1, `font-semibold max-sm:ml-2 ${Pr??""} flex gap-1`), at(_r, `${y(pe).name??""} `), at(gr, `#${y(pe).id??""}`), at(Mr, Or)
                      }, [() => Ji(y(pe).id), () => y(pe).pixelsPainted.toLocaleString("en-US")]), fu(He, () => mu, () => ({
                        duration: 200
                      })), Z(Xe, He)
                    }), P(ne), P(Ht), Bt((Xe, pe, Ue) => {
                      at(me, Xe), at(Ve, `${pe??""} `), at(Ie, Ue)
                    }, [() => Wf(), () => Sc(), () => Tc().toLowerCase()]), Z(Wt, Ht)
                  },
                  Ct = Wt => {
                    var jt = kr(),
                      Ht = xe(jt);
                    {
                      var _e = Ut => {
                        var Xt = lSe(),
                          me = C(Xt),
                          Ce = C(me),
                          Ve = D(C(Ce)),
                          Ie = C(Ve, !0);
                        P(Ve);
                        var ne = D(Ve),
                          Xe = C(ne),
                          pe = D(Xe, 2, !0);
                        P(ne), P(Ce), P(me);
                        var Ue = D(me);
                        di(Ue, 31, () => y(c), Ae => Ae.id, (Ae, He, Tr) => {
                          const Ye = ge(() => {
                            var ir;
                            return ((ir = ze.data) == null ? void 0 : ir.allianceId) === y(He).id
                          });
                          var mr = cSe();
                          let se;
                          var ce = C(mr),
                            ur = C(ce, !0);
                          P(ce);
                          var Ke = D(ce),
                            ve = C(Ke),
                            _r = C(ve, !0);
                          P(ve), P(Ke);
                          var nr = D(Ke),
                            gr = C(nr, !0);
                          P(nr), P(mr), Bt((ir, Ze) => {
                            se = Gr(mr, 1, "", null, se, {
                              "bg-base-200": y(Ye)
                            }), at(ur, y(Tr) + 1), Gr(ve, 1, `font-semibold ${ir??""}`), at(_r, y(He).name), at(gr, Ze)
                          }, [() => Ji(y(He).id), () => y(He).pixelsPainted.toLocaleString("en-US")]), fu(mr, () => mu, () => ({
                            duration: 200
                          })), Z(Ae, mr)
                        }), P(Ue), P(Xt), Bt((Ae, He, Tr) => {
                          at(Ie, Ae), at(Xe, `${He??""} `), at(pe, Tr)
                        }, [() => Md(), () => Sc(), () => Tc().toLowerCase()]), Z(Ut, Xt)
                      };
                      At(Ht, Ut => {
                        y(E) === "alliances" && Ut(_e)
                      }, !0)
                    }
                    Z(Wt, jt)
                  };
                At(Zt, Wt => {
                  y(E) === "players" ? Wt(Et) : Wt(Ct, !1)
                })
              }
              Z(qt, Vt)
            },
            St = qt => {
              var Vt = _Se();
              Z(qt, Vt)
            };
          At(Lt, qt => {
            y(c) ? qt(Dt) : qt(St, !1)
          }, !0)
        }
        Z(G, yt)
      };
    At(ut, G => {
      y(c) && y(c).length === 0 ? G(xt) : G(lt, !1)
    })
  }
  Z(l, R), rn()
}
var pSe = ft('<div class="mt-5"><!></div>'),
  fSe = ft('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function mSe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15);
  const w = ge(() => Ls(s.region.countryId));
  ti(() => {
    const G = yt => {
      yt.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", G), () => document.removeEventListener("keydown", G)
  });
  var z = fSe(),
    E = C(z),
    k = D(C(E), 2),
    c = C(k),
    R = C(c, !0);
  P(c);
  var X = D(c, 2),
    $ = C(X, !0);
  P(X);
  var tt = D(X, 2),
    ut = C(tt);
  P(tt), P(k);
  var xt = D(k, 2);
  {
    var lt = G => {
      var yt = pSe(),
        Lt = C(yt);
      dSe(Lt, {
        get regionId() {
          return s.region.id
        }
      }), P(yt), vo(2, yt, () => is, () => ({
        duration: 300
      })), Z(G, yt)
    };
    At(xt, G => {
      t() && G(lt)
    })
  }
  P(E), Mn(2), P(z), eo(z, () => G => {
    cn(() => {
      t() ? G.show() : G.close()
    })
  }), Bt(G => {
    Gr(k, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${G??""}`), pr(c, "data-tip", y(w).name), at(R, y(w).flag), at($, s.region.name), at(ut, `#${s.region.number??""}`)
  }, [() => Ji(s.region.cityId)]), jn("close", z, () => t(!1)), Z(l, z), rn()
}

function gSe(l) {
  switch (l) {
    case "en":
    case "pt":
    case "es":
    case "fr":
    case "de":
    case "it":
    case "pl":
    case "ru":
    case "uk":
    case "vi":
      return l;
    case "jp":
      return "ja";
    case "ch":
      return "zh";
    default:
      return ""
  }
}
async function ySe(l) {
  const s = gSe(B());
  let t = `https://geocoding.wplace.live/v1/autocomplete?text=${encodeURIComponent(l)}${s!=="en"?`&lang=${s}`:""}`;
  const w = await fetch(t);
  if (!w.ok) {
    const z = await w.text();
    throw console.error(`Geocoding API error: ${z}`), new Error(Nx())
  }
  return w.json()
}
var vSe = ft('<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'),
  bSe = ft('<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>');

function Yp(l, s) {
  en(s, !0);
  const t = (c, R) => {
    let X = () => R == null ? void 0 : R().name,
      $ = () => R == null ? void 0 : R().label,
      tt = () => R == null ? void 0 : R().onclick;
    var ut = bSe(),
      xt = C(ut);
    xt.__click = function(...Zt) {
      var Et;
      (Et = tt()) == null || Et.apply(this, Zt)
    };
    var lt = C(xt);
    Pd(lt, {
      class: "text-base-content/80 mt-0.5 size-6 min-w-6"
    });
    var G = D(lt, 2),
      yt = C(G),
      Lt = C(yt, !0);
    P(yt);
    var Dt = D(yt, 2),
      St = C(Dt, !0);
    P(Dt), P(G), P(xt);
    var qt = D(xt, 2);
    {
      var Vt = Zt => {
        var Et = vSe(),
          Ct = C(Et);
        Ct.__click = function(...jt) {
          var Ht;
          (Ht = s.onremove) == null || Ht.apply(this, jt)
        };
        var Wt = C(Ct);
        pa(Wt, {
          class: "size-4"
        }), P(Ct), P(Et), Z(Zt, Et)
      };
      At(qt, Zt => {
        s.onremove && Zt(Vt)
      })
    }
    P(ut), Bt(() => {
      at(Lt, X()), at(St, $())
    }), Z(c, ut)
  };
  var w = kr(),
    z = xe(w);
  {
    var E = c => {
        t(c, () => ({
          name: s.location.name,
          label: s.location.label,
          onclick: s.onclick
        }))
      },
      k = c => {
        var R = kr(),
          X = xe(R);
        {
          var $ = ut => {
              {
                let xt = ge(() => ({
                  name: s.location.name,
                  label: Jf(),
                  onclick: s.onclick
                }));
                t(ut, () => y(xt))
              }
            },
            tt = ut => {
              var xt = kr(),
                lt = xe(xt);
              {
                var G = yt => {
                  {
                    let Lt = ge(() => ({
                      name: `${s.location.pos.lat.toFixed(4)}, ${s.location.pos.lng.toFixed(4)}`,
                      label: pv(),
                      onclick: s.onclick
                    }));
                    t(yt, () => y(Lt))
                  }
                };
                At(lt, yt => {
                  s.location.type === "coordinates" && yt(G)
                }, !0)
              }
              Z(ut, xt)
            };
          At(X, ut => {
            s.location.type === "country" ? ut($) : ut(tt, !1)
          }, !0)
        }
        Z(c, R)
      };
    At(z, c => {
      s.location.type === "place" ? c(E) : c(k, !1)
    })
  }
  Z(l, w), rn()
}
ri(["click"]);
var xSe = $r('<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function wSe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = xSe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var kSe = $r('<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>');

function TSe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = kSe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var SSe = ft('<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'),
  PSe = ft('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  MSe = ft("<!> <!>", 1),
  CSe = ft('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  ISe = ft('<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>', 1),
  zSe = ft('<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function ASe(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(""),
    z = ee(!1),
    E = ee(!1);
  const k = new q1e(() => y(w), 400);
  let c = ee(null),
    R = ee(void 0),
    X = ee([]);
  const $ = /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    tt = ge(() => {
      const Ut = $.exec(y(w));
      if (Ut) {
        const Xt = parseFloat(Ut[1]),
          me = parseFloat(Ut[5]);
        return {
          type: "coordinates",
          id: `coords-${Xt}-${me}`,
          pos: {
            lat: Xt,
            lng: me
          },
          zoom: s.tileZoom + 2
        }
      }
    }),
    ut = "recent-locations";
  ti(() => {
    const Ut = localStorage.getItem(ut);
    if (Ut) try {
      Y(X, JSON.parse(Ut))
    } catch (Xt) {
      console.error("Failed to parse recent locations from localStorage", Xt)
    }
  }), cn(() => {
    k.current && ySe(k.current).then(Ut => {
      Y(R, Ut.features.map(Xt => {
        if (Xt.properties.layer === "country") return {
          type: "country",
          id: Xt.properties.id,
          name: Xt.properties.name,
          bbox: Xt.bbox,
          coordinates: Xt.geometry.type === "Point" ? {
            lat: Xt.geometry.coordinates[1],
            lng: Xt.geometry.coordinates[0]
          } : void 0
        };
        const me = Xt.properties.label.replace(Xt.properties.name + ",", "").trim();
        return {
          type: "place",
          id: Xt.properties.id,
          name: Xt.properties.name,
          label: me,
          bbox: Xt.bbox,
          coordinates: Xt.geometry.type === "Point" ? {
            lat: Xt.geometry.coordinates[1],
            lng: Xt.geometry.coordinates[0]
          } : void 0
        }
      })), y(z) && y(R).length > 0 && lt(y(R)[0])
    })
  }), cn(() => {
    y(w) || Y(R, void 0)
  }), cn(() => {
    t() ? setTimeout(() => {
      y(c).focus()
    }, 50) : (Y(w, ""), Y(z, !1), Y(R, void 0))
  });
  async function xt() {
    const {
      tile: Ut,
      pixel: Xt
    } = await fn.getRandomTile(s.season), me = new Bo(s.tileSize), Ce = Ut.x * s.tileSize + Xt.x, Ve = Ut.y * s.tileSize + Xt.y, [Ie, ne] = me.pixelsToLatLon(Ce, Ve, s.tileZoom), Xe = {
      lat: Ie,
      lng: ne
    }, pe = s.tileZoom + 2;
    s.map.flyTo({
      zoom: pe,
      center: Xe
    }), G({
      type: "coordinates",
      id: `coords-${Ie}-${ne}`,
      pos: Xe,
      zoom: pe
    })
  }

  function lt(Ut) {
    Ut.type === "coordinates" ? s.map.flyTo({
      zoom: Ut.zoom,
      center: Ut.pos
    }) : Ut.bbox ? s.map.fitBounds([
      [Ut.bbox[0], Ut.bbox[1]],
      [Ut.bbox[2], Ut.bbox[3]]
    ], {
      padding: 40,
      duration: 1e3
    }) : Ut.coordinates && s.map.flyTo({
      zoom: 16,
      center: Ut.coordinates,
      duration: 1e3
    }), t(!1), Y(R, void 0), G(Ut)
  }

  function G(Ut) {
    Y(X, y(X).filter(me => me.id !== Ut.id)), y(X).unshift(Ut);
    const Xt = 15;
    y(X).length > Xt && Y(X, y(X).slice(0, Xt)), Y(X, [...y(X)]), localStorage.setItem(ut, JSON.stringify(y(X)))
  }
  var yt = zSe(),
    Lt = C(yt),
    Dt = C(Lt),
    St = C(Dt),
    qt = C(St);
  xo(qt), os(qt, Ut => Y(c, Ut), () => y(c));
  var Vt = D(qt, 2);
  Vt.__click = () => t(!1);
  var Zt = C(Vt);
  ov(Zt, {
    class: "size-5"
  }), P(Vt);
  var Et = D(Vt, 2);
  {
    var Ct = Ut => {
      var Xt = SSe();
      Xt.__click = () => Y(w, "");
      var me = C(Xt);
      wSe(me, {
        class: "size-4.5"
      }), P(Xt), Z(Ut, Xt)
    };
    At(Et, Ut => {
      y(w) && Ut(Ct)
    })
  }
  P(St), P(Dt);
  var Wt = D(Dt, 2),
    jt = C(Wt);
  {
    var Ht = Ut => {
        Yp(Ut, {
          get location() {
            return y(tt)
          },
          onclick: () => lt(y(tt))
        })
      },
      _e = Ut => {
        var Xt = kr(),
          me = xe(Xt);
        {
          var Ce = Ie => {
              var ne = MSe(),
                Xe = xe(ne);
              di(Xe, 17, () => y(R), Ae => Ae.id, (Ae, He) => {
                Yp(Ae, {
                  get location() {
                    return y(He)
                  },
                  onclick: () => lt(y(He))
                })
              });
              var pe = D(Xe, 2);
              {
                var Ue = Ae => {
                  var He = PSe(),
                    Tr = C(He, !0);
                  P(He), Bt(Ye => at(Tr, Ye), [() => X9()]), Z(Ae, He)
                };
                At(pe, Ae => {
                  y(R).length === 0 && Ae(Ue)
                })
              }
              Z(Ie, ne)
            },
            Ve = Ie => {
              var ne = ISe(),
                Xe = xe(ne),
                pe = C(Xe),
                Ue = C(pe, !0);
              P(pe);
              var Ae = D(pe, 2);
              Ae.__click = async () => {
                try {
                  await xt(), t(!1)
                } catch (se) {
                  Ne.error(se.message)
                } finally {
                  Y(E, !1)
                }
              };
              var He = C(Ae);
              TSe(He, {
                class: "size-5"
              }), P(Ae), P(Xe);
              var Tr = D(Xe, 2);
              di(Tr, 17, () => y(X), se => se.id, (se, ce) => {
                Yp(se, {
                  get location() {
                    return y(ce)
                  },
                  onclick: () => {
                    lt(y(ce))
                  },
                  onremove: () => {
                    Y(X, y(X).filter(ur => ur.id !== y(ce).id)), localStorage.setItem(ut, JSON.stringify(y(X)))
                  }
                })
              });
              var Ye = D(Tr, 2);
              {
                var mr = se => {
                  var ce = CSe(),
                    ur = C(ce, !0);
                  P(ce), Bt(Ke => at(ur, Ke), [() => uO()]), Z(se, ce)
                };
                At(Ye, se => {
                  y(X).length === 0 && se(mr)
                })
              }
              Bt((se, ce) => {
                at(Ue, se), pr(Ae, "data-tip", ce), Ae.disabled = y(E)
              }, [() => JH(), () => OH()]), Z(Ie, ne)
            };
          At(me, Ie => {
            y(R) ? Ie(Ce) : Ie(Ve, !1)
          }, !0)
        }
        Z(Ut, Xt)
      };
    At(jt, Ut => {
      y(tt) ? Ut(Ht) : Ut(_e, !1)
    })
  }
  P(Wt), P(Lt), Mn(2), P(yt), eo(yt, () => Ut => {
    cn(() => {
      t() ? Ut.showModal() : Ut.close()
    })
  }), Bt(Ut => pr(qt, "placeholder", Ut), [() => nv()]), jn("close", yt, () => t(!1)), jn("submit", St, () => {
    var Ut;
    y(tt) ? lt(y(tt)) : k.pending ? Y(z, !0) : (Ut = y(R)) != null && Ut.length && lt(y(R)[0])
  }), M_(qt, () => y(w), Ut => Y(w, Ut)), Z(l, yt), rn()
}
ri(["click"]);
var ESe = $r('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function Df(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = ESe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var jSe = $r('<svg><path fill="currentColor" d="M9 14c1.381 0 2.631-.56 3.536-1.465C13.44 11.631 14 10.381 14 9s-.56-2.631-1.464-3.535C11.631 4.56 10.381 4 9 4s-2.631.56-3.536 1.465C4.56 6.369 4 7.619 4 9s.56 2.631 1.464 3.535A5 5 0 0 0 9 14m0 7c3.518 0 6-1 6-2c0-2-2.354-4-6-4c-3.75 0-6 2-6 4c0 1 2.25 2 6 2m12-9h-2v-2a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2"></path></svg>');

function LSe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = jSe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...t
  })), Z(l, w)
}
var DSe = $r('<svg><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>');

function RSe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = DSe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...t
  })), Z(l, w)
}
var BSe = $r('<svg><path fill="currentColor" d="m15 21l-6-2.1l-4.65 1.8q-.5.2-.925-.112T3 19.75v-14q0-.325.188-.575T3.7 4.8L9 3l6 2.1l4.65-1.8q.5-.2.925.113T21 4.25v14q0 .325-.187.575t-.513.375zm-1-2.45V6.85l-4-1.4v11.7zm2 0l3-1V5.7l-3 1.15zM5 18.3l3-1.15V5.45l-3 1zM16 6.85v11.7zm-8-1.4v11.7z"></path></svg>');

function FSe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = BSe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...t
  })), Z(l, w)
}
var OSe = $r('<svg><rect x="6" y="6" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" rx="2"></rect><rect x="10" y="10" width="4" height="4" fill="currentColor" rx="1"></rect></svg>');

function qSe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = OSe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...t
  })), Z(l, w)
}
var NSe = ft("<!> <!>", 1),
  VSe = ft('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  USe = ft('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  ZSe = ft('<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'),
  GSe = ft('<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'),
  HSe = ft('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button>'),
  WSe = ft('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'),
  $Se = ft('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  XSe = ft('<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'),
  YSe = ft('<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>', 1),
  KSe = ft("<span> </span>"),
  JSe = ft('<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'),
  QSe = ft('<span class="tooltip svelte-15blegn"><!></span>'),
  tPe = ft('<span class="tooltip svelte-15blegn"><!></span>'),
  ePe = ft('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>', 1),
  rPe = ft('<span class="text-primary ml-1 text-xs svelte-15blegn"> </span>'),
  nPe = ft('<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> <!></td></tr>'),
  iPe = ft('<div class="max-h-[27vh] overflow-y-auto overflow-x-hidden svelte-15blegn"><table class="table max-w-full svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <!> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'),
  oPe = ft('<div class="pointer-events-none w-full select-none svelte-15blegn"><div class="pointer-events-auto rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex cursor-grab flex-wrap items-center justify-between gap-1 active:cursor-grabbing svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <div class="flex items-center gap-1 svelte-15blegn"><div class="flex items-center gap-0 svelte-15blegn"><button class="btn btn-xs btn-soft text-base-content/80 flex items-center gap-1 whitespace-nowrap rounded-br-none rounded-tr-none pr-1 text-xs svelte-15blegn"><!> <input type="checkbox" class="checkbox checkbox-xs svelte-15blegn"/></button> <button class="btn btn-xs tooltip tooltip-bottom btn-soft rounded-bl-none rounded-tl-none svelte-15blegn"><!></button></div> <button><!></button> <button><!></button> <button><!></button> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div></div> <div class="pb-3 svelte-15blegn"><!></div></div></div></div>');

function sPe(l, s) {
  en(s, !0);
  let t = Qi([]),
    w = ee(Qi([])),
    z = ee(!1),
    E = ee(!1),
    k = ee(!1),
    c = ee(!1),
    R = ee(!1),
    X, $, tt, ut, xt, lt = ee(void 0),
    G = Qi({
      x: 0,
      y: 0
    }),
    yt, Lt;
  const Dt = 15e6,
    St = new md,
    qt = new Map;
  let Vt = ee(0);
  const Zt = ge(() => {
      y(Vt);
      const et = new Map;
      for (const W of qt.values()) et.set(W.userId, (et.get(W.userId) ?? 0) + 1);
      return et
    }),
    Et = ge(() => {
      y(Vt), St.size;
      let et = 0;
      for (const W of qt.values()) St.has(W.userId) || (et += 1);
      return et
    }),
    Ct = ge(() => {
      y(Vt);
      const et = y(Et);
      return St.size === 0 && et === 0 ? "none" : St.size === y(w).length && et === 0 ? "all" : "some"
    }),
    Wt = ge(() => {
      y(Vt);
      let et = 0;
      for (const W of St.values()) W.id !== 0 && (et += W.painted.latitudes.length);
      for (const W of qt.values()) St.has(W.userId) || (et += 1);
      return et
    }),
    jt = ge(() => y(Xt) * 2 + 1);
  let Ht = ee("area-select"),
    _e = ee(!1);
  const Ut = 15;
  let Xt = ee(Ut);
  const me = 0,
    Ce = 4096,
    Ve = "select-area-info:brush-radius",
    Ie = new md,
    ne = new Map,
    Xe = [],
    pe = () => y(Ht) === "brush-circle" || y(Ht) === "brush-square";
  let Ue, Ae = !1,
    He = !1;

  function Tr() {
    Ae && (Ae = !1, Ue = void 0)
  }

  function Ye() {
    if (Xe.length > 0) return;
    const et = [s.map.dragPan, s.map.scrollZoom, s.map.boxZoom, s.map.keyboard, s.map.doubleClickZoom, s.map.touchZoomRotate].filter(Boolean);
    for (const W of et) {
      const vt = W.isEnabled ? W.isEnabled() !== !1 : !0;
      W.disable && W.disable(), Xe.push({
        handler: W,
        wasEnabled: vt
      })
    }
  }

  function mr() {
    if (Xe.length !== 0) {
      for (const {
          handler: et,
          wasEnabled: W
        }
        of Xe) W && et.enable && et.enable();
      Xe.length = 0
    }
  }

  function se() {
    var vt, $t;
    if (!yt) return;
    const {
      handle: et,
      pointerId: W
    } = yt;
    (vt = et.hasPointerCapture) != null && vt.call(et, W) && (($t = et.releasePointerCapture) == null || $t.call(et, W)), yt = void 0, Lt !== void 0 && (document.body.style.userSelect = Lt, Lt = void 0), ce()
  }

  function ce() {
    var Ee, Qe;
    if (!y(lt)) return;
    const et = (Qe = (Ee = s.map).getContainer) == null ? void 0 : Qe.call(Ee);
    if (!et) return;
    const W = et.getBoundingClientRect(),
      vt = y(lt).getBoundingClientRect(),
      $t = vt.left - G.x,
      Pt = vt.top - G.y,
      Gt = W.left - $t,
      ae = W.right - $t - vt.width,
      ye = W.top - Pt,
      Te = W.bottom - Pt - vt.height;
    let we = G.x,
      be = G.y;
    ae >= Gt ? (we < Gt && (we = Gt), we > ae && (we = ae)) : we = Gt, Te >= ye ? (be < ye && (be = ye), be > Te && (be = Te)) : be = ye, we !== G.x && (G.x = we), be !== G.y && (G.y = be)
  }

  function ur(et) {
    var ye, Te, we;
    if (yt || et.pointerType === "mouse" && et.button !== 0) return;
    const W = et.target;
    if (W && W.closest('button, input, textarea, select, a, [role="button"]')) return;
    const vt = et.currentTarget;
    if (!vt) return;
    const $t = y(lt);
    if (!$t) return;
    const Pt = (Te = (ye = s.map).getContainer) == null ? void 0 : Te.call(ye);
    if (!Pt) return;
    const Gt = Pt.getBoundingClientRect(),
      ae = $t.getBoundingClientRect();
    yt = {
      pointerId: et.pointerId,
      handle: vt,
      startX: et.clientX,
      startY: et.clientY,
      startPosX: G.x,
      startPosY: G.y,
      baseLeft: ae.left - G.x,
      baseTop: ae.top - G.y,
      containerRect: Gt,
      panelWidth: ae.width,
      panelHeight: ae.height
    }, Lt === void 0 && (Lt = document.body.style.userSelect), document.body.style.userSelect = "none", (we = vt.setPointerCapture) == null || we.call(vt, et.pointerId), et.preventDefault(), et.stopPropagation()
  }
  ti(() => {
    const et = window.localStorage.getItem(Ve);
    if (et !== null) {
      const je = Number(et);
      if (!Number.isNaN(je)) {
        const Fe = Math.min(Ce, Math.max(me, Math.trunc(je)));
        Y(Xt, Fe, !0)
      }
    }
    mi.droppletAndPlop.play(), X = Ze();
    const W = async je => {
      if (y(Ht) === "user-picker") {
        await Mr(je, "select");
        return
      }
      if (pe()) {
        const Fe = je.originalEvent;
        q(je, "add", {
          silent: !!(Fe != null && Fe.altKey)
        });
        return
      }
      if (t.length >= 2) {
        s.onclose();
        return
      }
      if (t.push(je.lngLat), or(), mi.plop.play(), t.length === 2) try {
        Y(z, !0), Y(w, await ve(t[0], t[1]), !0)
      } finally {
        Y(z, !1)
      }
    }, vt = async je => {
      var Nr, Ar;
      if (y(Ht) === "user-picker") {
        (Nr = je.preventDefault) == null || Nr.call(je);
        const Kt = je.originalEvent;
        Kt == null || Kt.preventDefault();
        try {
          await Mr(je, "deselect")
        } catch (Oe) {
          console.error(Oe)
        }
        return
      }
      if (!pe()) return;
      (Ar = je.preventDefault) == null || Ar.call(je);
      const Fe = je.originalEvent;
      Fe == null || Fe.preventDefault(), q(je, "remove")
    }, $t = je => {
      if (!pe()) return;
      const Fe = je.originalEvent;
      if (!Fe || !Fe.altKey) return;
      const Nr = Fe.button === 2 ? "remove" : "add";
      Fe.preventDefault(), Ye(), Ue = Nr, Ae = !0, q(je, Nr, {
        silent: !0
      })
    }, Pt = () => {
      Tr()
    }, Gt = s.map.on("click", W), ae = s.map.on("contextmenu", vt), ye = s.map.on("mousedown", $t), Te = s.map.on("mouseup", Pt), we = je => {
      const Fe = yt;
      if (!Fe || je.pointerId !== Fe.pointerId) return;
      const Nr = je.clientX - Fe.startX,
        Ar = je.clientY - Fe.startY;
      let Kt = Fe.startPosX + Nr,
        Oe = Fe.startPosY + Ar;
      const Be = Fe.containerRect.left - Fe.baseLeft,
        fe = Fe.containerRect.right - Fe.baseLeft - Fe.panelWidth,
        Me = Fe.containerRect.top - Fe.baseTop,
        cr = Fe.containerRect.bottom - Fe.baseTop - Fe.panelHeight;
      fe >= Be ? (Kt < Be && (Kt = Be), Kt > fe && (Kt = fe)) : Kt = Be, cr >= Me ? (Oe < Me && (Oe = Me), Oe > cr && (Oe = cr)) : Oe = Me, G.x !== Kt && (G.x = Kt), G.y !== Oe && (G.y = Oe)
    }, be = je => {
      const Fe = yt;
      !Fe || je.pointerId !== Fe.pointerId || se()
    };
    window.addEventListener("pointermove", we), window.addEventListener("pointerup", be), window.addEventListener("pointercancel", be), window.addEventListener("resize", ce);
    const Ee = je => {
        if (je.altKey && (je.key === "r" || je.key === "R")) {
          Y(Xt, Ut), je.preventDefault(), de();
          return
        }
        je.key === "Alt" && (He || (He = !0, pe() && Ye()))
      },
      Qe = je => {
        je.key === "Alt" && (He = !1, Tr(), mr())
      },
      Yt = () => {
        se(), !(!He && !Ae) && (He = !1, Tr(), mr())
      };
    return window.addEventListener("keydown", Ee), window.addEventListener("keyup", Qe), window.addEventListener("blur", Yt), () => {
      var Fe, Nr;
      Gt.unsubscribe(), ae.unsubscribe(), ye.unsubscribe(), Te.unsubscribe(), window.removeEventListener("pointermove", we), window.removeEventListener("pointerup", be), window.removeEventListener("pointercancel", be), window.removeEventListener("resize", ce), window.removeEventListener("keydown", Ee), window.removeEventListener("keyup", Qe), window.removeEventListener("blur", Yt), se(), Tr(), mr(), He = !1, s.crosshair.clear();
      const je = (Nr = (Fe = s.map).getCanvas) == null ? void 0 : Nr.call(Fe);
      je && (je.style.cursor = ""), X == null || X(), X = void 0
    }
  });

  function Ke() {
    se(), y(E) || (X == null || X(), X = void 0, Y(Ht, "area-select"), Tr(), mr(), He = !1, G.x = 0, G.y = 0, qt.clear(), Y(Vt, y(Vt) + 1), Ie.clear(), ne.clear(), s.crosshair.clear(), s.onclose())
  }
  async function ve(et, W) {
    const vt = new Bo(s.tileSize),
      [$t, Pt] = vt.latLonToPixelsFloor(et.lat, et.lng, s.pixelArtZoom),
      [Gt, ae] = vt.latLonToPixelsFloor(W.lat, W.lng, s.pixelArtZoom),
      [ye, Te] = [Math.min($t, Gt), Math.min(Pt, ae)],
      [we, be] = [Math.max($t, Gt), Math.max(Pt, ae)],
      Ee = we - ye,
      Qe = be - Te;
    if (Ee * Qe > Dt) return Ne.error(`The selected area is too big. Please select an area smaller than ${Dt.toLocaleString()} pixels.`), [];
    const je = Math.floor(ye / s.tileSize),
      Fe = Math.floor(Te / s.tileSize),
      Nr = Math.floor(we / s.tileSize),
      Ar = Math.floor(be / s.tileSize),
      Kt = Nr - je + 1,
      Oe = Ar - Fe + 1,
      Be = new Array(Oe).fill(0).flatMap((lr, Jt) => new Array(Kt).fill(0).map(async (Se, rr) => {
        const Le = je + rr,
          sr = Fe + Jt;
        let De = 0,
          Cr = 0,
          on = s.tileSize - 1,
          ln = s.tileSize - 1;
        sr === Fe && (Cr = Te % s.tileSize), Le === je && (De = ye % s.tileSize), sr === Ar && (ln = be % s.tileSize), Le === Nr && (on = we % s.tileSize);
        const Rn = [Le, sr],
          Kr = [De, Cr],
          Hr = [on, ln];
        return {
          response: await fn.getPixelAreaInfo({
            season: s.season,
            tile: Rn,
            p0: Kr,
            p1: Hr
          }),
          tile: Rn,
          p0: Kr,
          p1: Hr
        }
      })),
      fe = await Promise.all(Be);
    Ie.clear(), ne.clear();
    const Me = new Map;
    for (const {
        response: lr,
        p0: Jt,
        p1: Se,
        tile: rr
      }
      of fe) {
      const [Le, sr] = rr, [De, Cr] = Jt, [on, ln] = Se, Br = on - De + 1, Dr = ln - Cr + 1;
      for (let un = 0; un < Dr; un++)
        for (let Fn = 0; Fn < Br; Fn++) {
          const Rn = un * Br + Fn,
            Kr = lr.paintedBy[Rn];
          let Hr = Me.get(Kr);
          Hr || (Hr = {
            latitudes: [],
            longitudes: [],
            tileXs: [],
            tileYs: [],
            pixelXs: [],
            pixelYs: [],
            globalPx: [],
            globalPy: [],
            minLat: 1 / 0,
            maxLat: -1 / 0,
            minLon: 1 / 0,
            maxLon: -1 / 0
          }, Me.set(Kr, Hr));
          const An = De + Fn,
            Hi = Cr + un,
            Fi = Le * s.tileSize + (An + .5),
            Ci = sr * s.tileSize + (Hi + .5),
            [he, qe] = vt.pixelsToLatLon(Fi, Ci, s.pixelArtZoom);
          if (Hr.latitudes.push(he), Hr.longitudes.push(qe), Hr.tileXs.push(Le), Hr.tileYs.push(sr), Hr.pixelXs.push(An), Hr.pixelYs.push(Hi), Hr.globalPx.push(Fi), Hr.globalPy.push(Ci), he < Hr.minLat && (Hr.minLat = he), he > Hr.maxLat && (Hr.maxLat = he), qe < Hr.minLon && (Hr.minLon = qe), qe > Hr.maxLon && (Hr.maxLon = qe), Kr !== 0) {
            const Vr = `${Le}:${sr}:${An}:${Hi}`,
              Pn = {
                key: Vr,
                userId: Kr,
                lat: he,
                lon: qe,
                tile: [Le, sr],
                pixel: [An, Hi],
                globalPx: Fi,
                globalPy: Ci
              };
            Ie.set(Vr, Pn);
            const Gn = `${Le}:${sr}`;
            let Xn = ne.get(Gn);
            Xn || (Xn = [], ne.set(Gn, Xn)), Xn.push(Pn)
          }
        }
    }
    const {
      users: cr
    } = await fn.getMultipleUsersInfoById([...Me.keys()]), Ge = Vx(cr, lr => lr.id), qr = [...Me.entries()].map(([lr, Jt]) => ({
      ...Ge[lr] ?? {
        id: lr,
        name: "Player",
        deleted: !0
      },
      painted: Jt
    }));
    return qr.sort((lr, Jt) => lr.id === 0 ? 1 : Jt.id === 0 ? -1 : Jt.painted.latitudes.length - lr.painted.latitudes.length), qr
  }
  async function _r({
    preserveSelection: et = !1
  } = {}) {
    if (t.length < 2) return;
    const W = et ? new Set([...St.keys()]) : void 0,
      vt = et ? [...qt.keys()] : void 0;
    try {
      Y(z, !0);
      const $t = await ve(t[0], t[1]);
      if (Y(w, $t, !0), St.clear(), qt.clear(), Y(Vt, y(Vt) + 1), s.crosshair.clear(), et && (W != null && W.size)) {
        for (const Pt of $t) W.has(Pt.id) && St.set(Pt.id, Pt);
        for (const Pt of St.values())
          for (let Gt = 0; Gt < Pt.painted.latitudes.length; Gt++) s.crosshair.place([Pt.painted.latitudes[Gt], Pt.painted.longitudes[Gt]])
      }
      if (et && (vt != null && vt.length)) {
        let Pt = !1;
        for (const Gt of vt) {
          const ae = Ie.get(Gt);
          ae && (qt.set(Gt, ae), Pt = !0)
        }
        Pt && Y(Vt, y(Vt) + 1)
      }
      for (const Pt of qt.values()) s.crosshair.place([Pt.lat, Pt.lon])
    } finally {
      Y(z, !1)
    }
  }

  function nr(et) {
    let W = !1;
    for (const vt of et)(Lr(vt) || vt.id === 0) && (W = !0);
    W && mi.plop.play()
  }

  function gr(et) {
    for (let W = 0; W < et.latitudes.length; W++) s.crosshair.remove([et.latitudes[W], et.longitudes[W]])
  }

  function ir(et) {
    if (!et) {
      xt = void 0;
      return
    }
    if (t.length >= 2 && y(Ht) === "area-select") {
      xt = void 0;
      return
    }
    xt = et
  }
  cn(() => {
    t.length < 2 && y(Ht) !== "area-select" && Y(Ht, "area-select");
    const et = s.map.getCanvas();
    if (!et) return;
    const W = y(Ht) === "user-picker" || y(Ht) === "brush-circle" || y(Ht) === "brush-square";
    et.style.cursor = W ? "crosshair" : "", de()
  }), cn(() => {
    const et = pe();
    et || Tr(), He && (et ? Ye() : mr())
  }), cn(() => {
    y(Xt), de()
  }), cn(() => {
    typeof window < "u" && window.localStorage.setItem(Ve, String(Math.trunc(y(Xt))))
  }), cn(() => {
    t.length, t.length < 2 ? (G.x !== 0 && (G.x = 0), G.y !== 0 && (G.y = 0)) : ce(), or(), zr()
  });

  function Ze() {
    const et = s.map.getContainer(),
      W = document.createElement("div");
    W.classList.add("selection-rectangle"), W.style.position = "absolute", W.style.pointerEvents = "none", W.style.display = "none", W.style.zIndex = "6", et.appendChild(W);
    const vt = document.createElement("div");
    vt.classList.add("selection-brush"), vt.style.position = "absolute", vt.style.pointerEvents = "none", vt.style.display = "none", vt.style.zIndex = "7", et.appendChild(vt);
    const $t = hr(et, "horizontal"),
      Pt = hr(et, "vertical");
    ut = {
      horizontal: $t,
      vertical: Pt
    }, tt = vt;
    const Gt = be => {
        ir({
          x: be.point.x,
          y: be.point.y
        }), or(), zr(), de();
        const Ee = be.originalEvent;
        if (!Ee) {
          Ae && Tr();
          return
        }
        if (!Ae && Ee.altKey && pe()) {
          let Qe = !1;
          if (Ee.buttons & 1 ? (Ye(), Ue = "add", Ae = !0, Qe = !0) : Ee.buttons & 2 && (Ye(), Ue = "remove", Ae = !0, Qe = !0), Qe && Ue) {
            q(be, Ue, {
              silent: !0
            });
            return
          }
        }
        if (Ae && Ue) {
          if (!Ee.altKey || Ee.buttons === 0) {
            Tr();
            return
          }
          q(be, Ue, {
            silent: !0
          })
        }
      },
      ae = be => {
        const Ee = et.getBoundingClientRect();
        ir({
          x: be.clientX - Ee.left,
          y: be.clientY - Ee.top
        }), or(), zr(), de()
      },
      ye = () => {
        xt = void 0, Tr(), or(), zr(), de()
      },
      Te = () => {
        ce(), or(), zr(), de()
      },
      we = be => {
        if (!pe()) return;
        if (!(be.altKey || He)) {
          Ae && (Tr(), mr());
          return
        }
        He = !0, Ye(), be.preventDefault(), be.stopPropagation(), typeof be.stopImmediatePropagation == "function" && be.stopImmediatePropagation();
        const Ee = be.deltaY < 0 ? 1 : -1,
          Qe = (be.shiftKey ? 10 : 1) * Ee,
          Yt = Math.min(Ce, Math.max(me, y(Xt) + Qe));
        Yt !== y(Xt) && (Y(Xt, Yt, !0), de())
      };
    return s.map.on("mousemove", Gt), et.addEventListener("pointermove", ae), et.addEventListener("mouseleave", ye), s.map.on("move", Te), s.map.on("resize", Te), et.addEventListener("wheel", we, {
      passive: !1
    }), $ = W, or(), zr(), de(), () => {
      s.map.off("mousemove", Gt), s.map.off("move", Te), s.map.off("resize", Te), et.removeEventListener("pointermove", ae), et.removeEventListener("mouseleave", ye), et.removeEventListener("wheel", we), W.remove(), $ = void 0, xt = void 0, ut == null || ut.horizontal.remove(), ut == null || ut.vertical.remove(), ut = void 0, tt == null || tt.remove(), tt = void 0
    }
  }

  function or() {
    const et = $;
    if (!et) return;
    const W = new Bo(s.tileSize);
    let vt, $t, Pt, Gt;
    if (t.length >= 2) {
      const Nr = t.map(Ar => W.latLonToPixelsFloor(Ar.lat, Ar.lng, s.pixelArtZoom));
      vt = Math.min(...Nr.map(([Ar]) => Ar)), $t = Math.max(...Nr.map(([Ar]) => Ar)) + 1, Pt = Math.min(...Nr.map(([, Ar]) => Ar)), Gt = Math.max(...Nr.map(([, Ar]) => Ar)) + 1
    } else if (t.length === 1 && xt) {
      const [Nr, Ar] = W.latLonToPixelsFloor(t[0].lat, t[0].lng, s.pixelArtZoom), Kt = s.map.unproject([xt.x, xt.y]), [Oe, Be] = W.latLonToPixelsFloor(Kt.lat, Kt.lng, s.pixelArtZoom);
      vt = Math.min(Nr, Oe), $t = Math.max(Nr, Oe) + 1, Pt = Math.min(Ar, Be), Gt = Math.max(Ar, Be) + 1
    } else {
      et.style.display = "none";
      return
    }
    const [ae, ye] = W.pixelsToLatLon(vt, Pt, s.pixelArtZoom), [Te, we] = W.pixelsToLatLon($t, Gt, s.pixelArtZoom), be = s.map.project([ye, ae]), Ee = s.map.project([we, Te]);
    let Qe = Math.min(be.x, Ee.x),
      Yt = Math.max(be.x, Ee.x),
      je = Math.min(be.y, Ee.y),
      Fe = Math.max(be.y, Ee.y);
    Yt - Qe < 1 && (Yt = Qe + 1), Fe - je < 1 && (Fe = je + 1), et.style.display = "block", et.style.left = `${Qe}px`, et.style.top = `${je}px`, et.style.width = `${Yt-Qe}px`, et.style.height = `${Fe-je}px`
  }

  function de() {
    const et = tt;
    if (!et) return;
    if (!(y(Ht) === "brush-circle" || y(Ht) === "brush-square") || !xt) {
      et.style.display = "none";
      return
    }
    const W = new Bo(s.tileSize),
      vt = s.map.unproject([xt.x, xt.y]),
      [$t, Pt] = W.latLonToPixels(vt.lat, vt.lng, s.pixelArtZoom),
      Gt = y(Xt) + .5,
      [ae, ye] = W.pixelsToLatLon($t - Gt, Pt - Gt, s.pixelArtZoom),
      [Te, we] = W.pixelsToLatLon($t + Gt, Pt + Gt, s.pixelArtZoom),
      be = s.map.project([ye, ae]),
      Ee = s.map.project([we, Te]),
      Qe = Math.min(be.x, Ee.x),
      Yt = Math.max(be.x, Ee.x),
      je = Math.min(be.y, Ee.y),
      Fe = Math.max(be.y, Ee.y);
    et.style.display = "block", et.style.left = `${Qe}px`, et.style.top = `${je}px`, et.style.width = `${Math.max(Yt-Qe,2)}px`, et.style.height = `${Math.max(Fe-je,2)}px`, et.style.borderRadius = y(Ht) === "brush-circle" ? "100%" : "4px", et.dataset.radius = String(y(Xt))
  }

  function zr() {
    const et = ut;
    if (et) {
      if (!xt || t.length >= 2) {
        er();
        return
      }
      et.horizontal.style.display = "block", et.horizontal.style.top = `${xt.y}px`, et.horizontal.style.transform = "translateY(-0.5px)", et.vertical.style.display = "block", et.vertical.style.left = `${xt.x}px`, et.vertical.style.transform = "translateX(-0.5px)"
    }
  }

  function er() {
    ut && (ut.horizontal.style.display = "none", ut.vertical.style.display = "none")
  }

  function hr(et, W) {
    const vt = document.createElement("div");
    return vt.style.position = "absolute", vt.style.pointerEvents = "none", vt.style.zIndex = "5", vt.style.display = "none", vt.style.mixBlendMode = "difference", vt.style.backgroundColor = "rgba(255, 255, 255, 0.9)", W === "horizontal" ? (vt.style.left = "0", vt.style.right = "0", vt.style.height = "1px") : (vt.style.top = "0", vt.style.bottom = "0", vt.style.width = "1px"), et.appendChild(vt), vt
  }
  async function Mr(et, W = "select") {
    var vt;
    if (!y(_e)) {
      if (y(z)) {
        Ne.info("Wait until the selected area finishes loading.");
        return
      }
      if (t.length < 2) {
        Ne.info("Select an area first to use the user picker.");
        return
      }
      Y(_e, !0);
      try {
        const $t = new Bo(s.tileSize),
          {
            tile: Pt,
            pixel: Gt
          } = $t.latLonToTileAndPixel(et.lngLat.lat, et.lngLat.lng, s.pixelArtZoom),
          {
            paintedBy: ae
          } = await fn.getPixelInfo({
            season: s.season,
            tile: Pt,
            pixel: Gt,
            role: (vt = ze.data) == null ? void 0 : vt.role
          });
        if (!ae || ae.id === 0) {
          Ne.info("That pixel is not painted by any player.");
          return
        }
        const ye = y(w).find(we => we.id === ae.id);
        if (!ye) {
          Ne.info("Selected pixel is outside the selected area.");
          return
        }
        if (W === "deselect") {
          if (!St.has(ye.id)) {
            jr(ye.id) ? (mi.plop.play(), Ne.success(`${ye.name} deselected`)) : Ne.info("That player is not selected.");
            return
          }
          St.delete(ye.id), gr(ye.painted), jr(ye.id, {
            skipCrosshair: !0
          }), mi.plop.play(), Ne.success(`${ye.name} deselected`);
          return
        }
        if (St.has(ye.id)) {
          Ne.info("Player already selected.");
          return
        }
        St.set(ye.id, ye), (Lr(ye) || ye.id === 0) && mi.plop.play(), Ne.success(`${ye.name} selected`)
      } catch ($t) {
        Ne.error($t.message)
      } finally {
        Y(_e, !1)
      }
    }
  }

  function Pr(et, {
    skipCrosshair: W = !1
  } = {}) {
    return qt.has(et.key) ? !1 : (qt.set(et.key, et), W || s.crosshair.place([et.lat, et.lon]), !0)
  }

  function Or(et, {
    skipCrosshair: W = !1
  } = {}) {
    const vt = qt.get(et);
    return vt ? (qt.delete(et), W || s.crosshair.remove([vt.lat, vt.lon]), !0) : !1
  }

  function jr(et, {
    skipCrosshair: W = !1
  } = {}) {
    const vt = [];
    for (const [Pt, Gt] of qt.entries()) Gt.userId === et && vt.push(Pt);
    let $t = !1;
    for (const Pt of vt) Or(Pt, {
      skipCrosshair: W
    }) && ($t = !0);
    return $t && Y(Vt, y(Vt) + 1), $t
  }

  function Lr(et, {
    skipCrosshair: W = !1
  } = {}) {
    if (et.id === 0) return !1;
    const vt = et.painted;
    let $t = !1;
    for (let Pt = 0; Pt < vt.latitudes.length; Pt++) {
      const Gt = vt.tileXs[Pt],
        ae = vt.tileYs[Pt],
        ye = vt.pixelXs[Pt],
        Te = vt.pixelYs[Pt],
        we = `${Gt}:${ae}:${ye}:${Te}`;
      let be = Ie.get(we);
      if (!be) {
        be = {
          key: we,
          userId: et.id,
          lat: vt.latitudes[Pt],
          lon: vt.longitudes[Pt],
          tile: [Gt, ae],
          pixel: [ye, Te],
          globalPx: vt.globalPx[Pt],
          globalPy: vt.globalPy[Pt]
        }, Ie.set(we, be);
        const Ee = `${Gt}:${ae}`;
        let Qe = ne.get(Ee);
        Qe || (Qe = [], ne.set(Ee, Qe)), Qe.push(be)
      }
      Pr(be, {
        skipCrosshair: W
      }) && ($t = !0)
    }
    return $t && Y(Vt, y(Vt) + 1), $t
  }

  function _n(et) {
    return y(w).find(W => W.id === et)
  }

  function dr(et, {
    silent: W = !1
  } = {}) {
    let vt = !1;
    for (const [$t, Pt] of et) {
      if (St.has($t)) continue;
      const Gt = _n($t);
      if (!Gt) continue;
      const ae = Gt.painted.latitudes.length;
      (y(Zt).get($t) ?? 0) + Pt >= ae && (St.set($t, Gt), vt = !0)
    }
    vt && !W && mi.plop.play()
  }

  function ct(et, W) {
    if (Ie.size === 0) return [];
    const vt = new Bo(s.tileSize),
      [$t, Pt] = vt.latLonToPixels(et, W, s.pixelArtZoom),
      Gt = y(Xt) + .5,
      ae = $t - Gt,
      ye = $t + Gt,
      Te = Pt - Gt,
      we = Pt + Gt,
      be = Math.floor(ae / s.tileSize),
      Ee = Math.floor(ye / s.tileSize),
      Qe = Math.floor(Te / s.tileSize),
      Yt = Math.floor(we / s.tileSize),
      je = [];
    for (let Fe = be; Fe <= Ee; Fe++)
      for (let Nr = Qe; Nr <= Yt; Nr++) {
        const Ar = `${Fe}:${Nr}`,
          Kt = ne.get(Ar);
        if (Kt)
          for (const Oe of Kt) {
            const Be = Oe.globalPx - $t,
              fe = Oe.globalPy - Pt;
            if (y(Ht) === "brush-circle") {
              if (Be * Be + fe * fe > Gt * Gt) continue
            } else if (Math.abs(Be) > Gt || Math.abs(fe) > Gt) continue;
            je.push(Oe)
          }
      }
    return je
  }

  function q(et, W, {
    silent: vt = !1
  } = {}) {
    if (y(z)) return vt || Ne.info("Wait until the selected area finishes loading."), !1;
    if (t.length < 2) return vt || Ne.info("Select an area first to use the brush tool."), !1;
    const $t = ct(et.lngLat.lat, et.lngLat.lng);
    if ($t.length === 0) {
      if (!vt) {
        const ae = W === "add" ? "No painted pixels found within the brush." : "No selected pixels to remove within the brush.";
        Ne.info(ae)
      }
      return !1
    }
    let Pt = !1;
    const Gt = new Map;
    if (W === "add")
      for (const ae of $t) St.has(ae.userId) || qt.has(ae.key) || Pr(ae) && (Pt = !0, Gt.set(ae.userId, (Gt.get(ae.userId) ?? 0) + 1));
    else
      for (const ae of $t) Or(ae.key) && (Pt = !0, St.has(ae.userId) && St.delete(ae.userId));
    return Pt ? (W === "add" && Gt.size > 0 && dr(Gt, {
      silent: vt
    }), Y(Vt, y(Vt) + 1), vt || mi.plop.play(), !0) : (!vt && W === "add" && Ne.info("All pixels inside the brush are already selected."), !1)
  }
  async function U() {
    const et = s.map.getCanvas();
    if (!et) return Ne.error("Unable to access map canvas."), !1;
    const W = et.getBoundingClientRect();
    if (!W.width || !W.height) return Ne.error("Map is not visible to capture."), !1;
    let vt = 1 / 0,
      $t = -1 / 0,
      Pt = 1 / 0,
      Gt = -1 / 0;
    for (const Jt of t) {
      const {
        lat: Se,
        lng: rr
      } = Jt;
      Se < vt && (vt = Se), Se > $t && ($t = Se), rr < Pt && (Pt = rr), rr > Gt && (Gt = rr)
    }
    if (!isFinite(vt) || !isFinite($t) || !isFinite(Pt) || !isFinite(Gt)) return Ne.error("Unable to determine selected area."), !1;
    const ae = s.map.project([Pt, $t]),
      ye = s.map.project([Gt, vt]);
    if (!Number.isFinite(ae.x) || !Number.isFinite(ae.y) || !Number.isFinite(ye.x) || !Number.isFinite(ye.y)) return Ne.error("Unable to project selected area on the map."), !1;
    let Te = Math.min(ae.x, ye.x),
      we = Math.max(ae.x, ye.x),
      be = Math.min(ae.y, ye.y),
      Ee = Math.max(ae.y, ye.y);
    Te = Math.max(0, Te), be = Math.max(0, be), we = Math.min(W.width, we), Ee = Math.min(W.height, Ee);
    const Qe = we - Te,
      Yt = Ee - be;
    if (Qe <= 0 || Yt <= 0) return Ne.error("Selected area is outside the current map view."), !1;
    const je = et.width / W.width,
      Fe = et.height / W.height,
      Nr = Math.floor(Te * je),
      Ar = Math.floor(be * Fe),
      Kt = Math.max(1, Math.ceil(we * je) - Nr),
      Oe = Math.max(1, Math.ceil(Ee * Fe) - Ar),
      Be = await yd(s.map);
    let fe;
    if ("createImageBitmap" in window) fe = await createImageBitmap(Be);
    else {
      const Jt = URL.createObjectURL(Be);
      fe = await new Promise((Se, rr) => {
        const Le = new Image;
        Le.crossOrigin = "anonymous", Le.onload = () => Se(Le), Le.onerror = () => rr(new Error("Failed to decode map image.")), Le.src = Jt
      }), URL.revokeObjectURL(Jt)
    }
    const Me = document.createElement("canvas");
    Me.width = Kt, Me.height = Oe;
    const cr = Me.getContext("2d");
    if (!cr) return "close" in fe && fe.close(), Ne.error("Unable to create drawing context."), !1;
    cr.drawImage(fe, Nr, Ar, Kt, Oe, 0, 0, Kt, Oe), "close" in fe && fe.close();
    const Ge = await new Promise((Jt, Se) => {
        Me.toBlob(rr => {
          rr ? Jt(rr) : Se(new Error("Failed to prepare download."))
        }, "image/png")
      }),
      qr = URL.createObjectURL(Ge),
      lr = document.createElement("a");
    return lr.href = qr, lr.download = `selected-map-${Kt}x${Oe}.png`, document.body.appendChild(lr), lr.click(), document.body.removeChild(lr), URL.revokeObjectURL(qr), !0
  }
  async function Q() {
    if (!(y(c) || y(z))) {
      if (t.length < 2) {
        Ne.info(y(R) ? "Select an area first to save the map view." : "Select an area first to save pixel art.");
        return
      }
      Y(c, !0);
      try {
        switch (y(R)) {
          case !0:
            if (y(R)) {
              await U() && Ne.success("Selected map view saved");
              return
            }
          case !1:
            const et = new Bo(s.tileSize);
            let W = 1 / 0,
              vt = -1 / 0,
              $t = 1 / 0,
              Pt = -1 / 0;
            for (let Kt = 0; Kt < t.length; Kt++) {
              const Oe = t[Kt],
                Be = et.latLonToPixelsFloor(Oe.lat, Oe.lng, s.pixelArtZoom),
                fe = Be[0],
                Me = Be[1];
              fe < W && (W = fe), fe > vt && (vt = fe), Me < $t && ($t = Me), Me > Pt && (Pt = Me)
            }
            if (!isFinite(W) || !isFinite(vt) || !isFinite($t) || !isFinite(Pt)) {
              Ne.error("Unable to determine selected area.");
              return
            }
            const Gt = vt + 1,
              ae = Pt + 1,
              ye = Gt - W,
              Te = ae - $t;
            if (ye <= 0 || Te <= 0) {
              Ne.error("Selected area has no size.");
              return
            }
            const we = document.createElement("canvas");
            we.width = ye, we.height = Te;
            const be = we.getContext("2d");
            if (!be) {
              Ne.error("Unable to create drawing context.");
              return
            }
            const Ee = Math.floor(W / s.tileSize),
              Qe = Math.floor((Gt - 1) / s.tileSize),
              Yt = Math.floor($t / s.tileSize),
              je = Math.floor((ae - 1) / s.tileSize);
            for (let Kt = Yt; Kt <= je; Kt++)
              for (let Oe = Ee; Oe <= Qe; Oe++) {
                const Be = Oe * s.tileSize,
                  fe = Kt * s.tileSize,
                  Me = Math.max(W, Be),
                  cr = Math.max($t, fe),
                  Ge = Math.min(Gt, Be + s.tileSize),
                  qr = Math.min(ae, fe + s.tileSize),
                  lr = Ge - Me,
                  Jt = qr - cr;
                if (lr <= 0 || Jt <= 0) continue;
                const Se = await fetch(`${Yy}/s${s.season}/tiles/${Oe}/${Kt}.png`);
                if (!Se.ok) throw new Error("Failed to load tile image.");
                const rr = await Se.blob();
                if ("createImageBitmap" in window) {
                  const Le = await createImageBitmap(rr);
                  be.drawImage(Le, Me - Be, cr - fe, lr, Jt, Me - W, cr - $t, lr, Jt), Le.close && Le.close()
                } else {
                  const Le = URL.createObjectURL(rr),
                    sr = await new Promise((De, Cr) => {
                      const on = new Image;
                      on.crossOrigin = "anonymous", on.onload = () => De(on), on.onerror = () => Cr(new Error("Failed to decode tile image.")), on.src = Le
                    });
                  be.drawImage(sr, Me - Be, cr - fe, lr, Jt, Me - W, cr - $t, lr, Jt), URL.revokeObjectURL(Le)
                }
              }
            const Fe = await new Promise((Kt, Oe) => {
                we.toBlob(Be => {
                  Be ? Kt(Be) : Oe(new Error("Failed to prepare download."))
                }, "image/png")
              }),
              Nr = URL.createObjectURL(Fe),
              Ar = document.createElement("a");
            Ar.href = Nr, Ar.download = `selected-area-${ye}x${Te}.png`, document.body.appendChild(Ar), Ar.click(), document.body.removeChild(Ar), URL.revokeObjectURL(Nr), Ne.success("Selected area image saved")
        }
      } catch (et) {
        Ne.error(et.message)
      } finally {
        Y(c, !1)
      }
    }
  }
  async function nt() {
    if (y(k) || y(z)) return;
    const et = new Map;
    for (const W of St.values()) {
      if (W.id === 0) continue;
      const {
        tileXs: vt,
        tileYs: $t,
        pixelXs: Pt,
        pixelYs: Gt
      } = W.painted;
      for (let ae = 0; ae < vt.length; ae++) {
        const ye = [vt[ae], $t[ae]],
          Te = [Pt[ae], Gt[ae]],
          we = {
            tile: ye,
            pixel: Te,
            season: s.season
          },
          be = `${ye[0]}:${ye[1]}:${Te[0]}:${Te[1]}`;
        et.set(be, we)
      }
    }
    for (const W of qt.values()) St.has(W.userId) || et.has(W.key) || et.set(W.key, {
      tile: W.tile,
      pixel: W.pixel,
      season: s.season
    });
    if (et.size === 0) {
      Ne.info("Select painted pixels to clear with transparent color");
      return
    }
    Y(k, !0);
    try {
      mi.droppletAndPlop.play();
      const W = await am(),
        vt = [];
      for (const Gt of et.values()) vt.push({
        ...Gt,
        colorIdx: 0
      });
      await fn.selectAreaClear(vt, W);
      const $t = Zf(0),
        Pt = vt.map(({
          tile: Gt,
          pixel: ae,
          season: ye
        }) => ({
          tile: Gt,
          pixel: ae,
          season: ye,
          color: $t
        }));
      await qf(Pt), Ne.success("Painted selected pixels with transparent color"), await _r()
    } catch (W) {
      Ne.error(W.message)
    } finally {
      Y(k, !1)
    }
  }
  const _t = et => ({
    id: et.id,
    name: et.name,
    picture: et.picture,
    allianceId: et.allianceId ?? void 0,
    allianceName: et.allianceName ?? void 0,
    timedOut: et.timedOut,
    banned: et.banned,
    deleted: et.deleted
  });

  function Tt() {
    const et = new Map;
    for (const W of St.values()) W.id !== 0 && et.set(W.id, W);
    if (qt.size > 0) {
      let W;
      for (const vt of qt.values()) {
        const $t = vt.userId;
        if ($t === 0 || et.has($t)) continue;
        if (!W) {
          W = new Map;
          for (const Gt of y(w)) W.set(Gt.id, Gt)
        }
        const Pt = W.get($t);
        Pt && et.set(Pt.id, Pt)
      }
    }
    return [...et.values()]
  }
  async function Ft(et, W) {
    try {
      Y(E, !0);
      const vt = et.filter(be => be.id !== 0);
      if (vt.length === 0) {
        Ne.info("Select at least one player");
        return
      }
      let $t = 1 / 0,
        Pt = -1 / 0,
        Gt = 1 / 0,
        ae = -1 / 0;
      if (t.length >= 2)
        for (const be of t) {
          const {
            lat: Ee,
            lng: Qe
          } = be;
          !isFinite(Ee) || !isFinite(Qe) || (Ee < $t && ($t = Ee), Ee > Pt && (Pt = Ee), Qe < Gt && (Gt = Qe), Qe > ae && (ae = Qe))
        }
      $t === Pt && ($t -= 1e-6, Pt += 1e-6), Gt === ae && (Gt -= 1e-6, ae += 1e-6), s.map.stop();
      const ye = s.map.getCanvas(),
        Te = Math.max(48, Math.min(ye.width, ye.height) * .08);
      s.map.fitBounds([
        [Math.min(Gt, ae), Math.min($t, Pt)],
        [Math.max(Gt, ae), Math.max($t, Pt)]
      ], {
        padding: Te,
        duration: 0
      });
      const we = (async () => await yd(s.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: .8,
        type: "image/jpeg"
      }))();
      s.onmodaction({
        action: W,
        targets: vt.map(_t),
        image: we,
        latLon: [($t + Pt) / 2, (Gt + ae) / 2],
        zoom: s.map.getZoom(),
        onSuccess: async () => {
          await _r({
            preserveSelection: !0
          })
        }
      })
    } catch (vt) {
      Ne.error(vt.message)
    } finally {
      Y(E, !1)
    }
  }
  var zt = kr();
  jn("keydown", Oa, et => et.code === "Escape" && Ke());
  var Nt = xe(zt);
  {
    var ie = et => {
        kc(et, {
          class: "bg-warning animate-bounce",
          children: (W, vt) => {
            var $t = NSe(),
              Pt = xe($t);
            Df(Pt, {
              class: "inline size-5"
            });
            var Gt = D(Pt, 2);
            {
              var ae = Te => {
                  var we = to();
                  Bt(be => at(we, be), [() => rY()]), Z(Te, we)
                },
                ye = Te => {
                  var we = kr(),
                    be = xe(we);
                  {
                    var Ee = Qe => {
                      var Yt = to();
                      Bt(je => at(Yt, je), [() => fY()]), Z(Qe, Yt)
                    };
                    At(be, Qe => {
                      t.length === 1 && Qe(Ee)
                    }, !0)
                  }
                  Z(Te, we)
                };
              At(Gt, Te => {
                t.length === 0 ? Te(ae) : Te(ye, !1)
              })
            }
            Z(W, $t)
          },
          $$slots: {
            default: !0
          }
        })
      },
      mt = et => {
        var W = oPe();
        let vt;
        var $t = C(W),
          Pt = C($t),
          Gt = C(Pt);
        Gt.__pointerdown = ur, _a(Gt, "", {}, {
          "touch-action": "none"
        });
        var ae = C(Gt),
          ye = C(ae),
          Te = C(ye);
        Df(Te, {
          class: "size-4"
        }), P(ye);
        var we = D(ye, 4),
          be = C(we);
        P(we), P(ae);
        var Ee = D(ae, 2),
          Qe = C(Ee),
          Yt = C(Qe);
        Yt.__click = () => {
          Y(R, y(R) !== !0)
        };
        var je = C(Yt);
        FSe(je, {
          class: "h-4 w-4"
        });
        var Fe = D(je, 2);
        xo(Fe), P(Yt);
        var Nr = D(Yt, 2);
        Nr.__click = Q;
        var Ar = C(Nr);
        {
          var Kt = Dr => {
              var un = VSe();
              Z(Dr, un)
            },
            Oe = Dr => {
              Hf(Dr, {
                class: "size-4"
              })
            };
          At(Ar, Dr => {
            y(c) ? Dr(Kt) : Dr(Oe, !1)
          })
        }
        P(Nr), P(Qe);
        var Be = D(Qe, 2);
        let fe;
        Be.__click = () => {
          if (y(Ht) === "brush-circle") {
            Y(Ht, "area-select");
            return
          }
          if (y(z)) {
            Ne.info("Wait until the selected area finishes loading.");
            return
          }
          if (t.length < 2) {
            Ne.info("Select an area first to use the brush tools.");
            return
          }
          Y(Ht, "brush-circle")
        };
        var Me = C(Be);
        RSe(Me, {
          class: "size-4"
        }), P(Be);
        var cr = D(Be, 2);
        let Ge;
        cr.__click = () => {
          if (y(Ht) === "brush-square") {
            Y(Ht, "area-select");
            return
          }
          if (y(z)) {
            Ne.info("Wait until the selected area finishes loading.");
            return
          }
          if (t.length < 2) {
            Ne.info("Select an area first to use the brush tools.");
            return
          }
          Y(Ht, "brush-square")
        };
        var qr = C(cr);
        qSe(qr, {
          class: "size-4"
        }), P(cr);
        var lr = D(cr, 2);
        let Jt;
        lr.__click = () => {
          if (y(Ht) === "user-picker") {
            Y(Ht, "area-select");
            return
          }
          if (y(z)) {
            Ne.info("Wait until the selected area finishes loading.");
            return
          }
          if (t.length < 2) {
            Ne.info("Select an area first to use the user picker.");
            return
          }
          Y(Ht, "user-picker")
        };
        var Se = C(lr);
        {
          var rr = Dr => {
              var un = USe();
              Z(Dr, un)
            },
            Le = Dr => {
              LSe(Dr, {
                class: "size-4"
              })
            };
          At(Se, Dr => {
            y(_e) ? Dr(rr) : Dr(Le, !1)
          })
        }
        P(lr);
        var sr = D(lr, 2);
        sr.__click = Ke;
        var De = C(sr);
        pa(De, {
          class: "size-4"
        }), P(sr), P(Ee), P(Gt);
        var Cr = D(Gt, 2),
          on = C(Cr);
        {
          var ln = Dr => {
              var un = ZSe();
              Z(Dr, un)
            },
            Br = Dr => {
              var un = kr(),
                Fn = xe(un);
              {
                var Rn = Hr => {
                    var An = GSe();
                    Z(Hr, An)
                  },
                  Kr = Hr => {
                    var An = iPe(),
                      Hi = C(An),
                      Fi = C(Hi),
                      Ci = C(Fi),
                      he = C(Ci),
                      qe = C(he);
                    xo(qe), qe.__click = wn => {
                      if (y(Ct) === "none") {
                        qt.clear(), Y(Vt, y(Vt) + 1), s.crosshair.clear();
                        const xr = [];
                        for (const vn of y(w)) St.has(vn.id) || (St.set(vn.id, vn), xr.push(vn));
                        xr.length && nr(xr);
                        return
                      }
                      St.clear(), qt.clear(), Y(Vt, y(Vt) + 1), s.crosshair.clear()
                    }, P(he);
                    var Vr = D(he),
                      Pn = D(C(Vr));
                    Pn.__click = () => {
                      navigator.clipboard.writeText([...St.keys()].filter(wn => wn !== 0).join(", ")), Ne.success("Player IDs copied to clipboard")
                    };
                    var Gn = C(Pn);
                    Yf(Gn, {
                      class: "size-3"
                    }), P(Pn);
                    var Xn = D(Pn, 2);
                    {
                      var $n = wn => {
                        var xr = HSe();
                        xr.__click = () => {
                          const Ur = Tt();
                          Ft(Ur, "timeout")
                        };
                        var vn = C(xr);
                        Wl(vn, {
                          class: "size-4"
                        }), P(xr), Bt(() => xr.disabled = y(E)), Z(wn, xr)
                      };
                      At(Xn, wn => {
                        ze.hasPermission(Ri.tools.selectArea.timeout) && wn($n)
                      })
                    }
                    var On = D(Xn, 2);
                    {
                      var Ai = wn => {
                        var xr = WSe();
                        xr.__click = () => {
                          const Ur = Tt();
                          Ft(Ur, "ban")
                        };
                        var vn = C(xr);
                        fd(vn, {
                          class: "size-4"
                        }), P(xr), Bt(() => xr.disabled = y(E)), Z(wn, xr)
                      };
                      At(On, wn => {
                        ze.hasPermission(Ri.tools.selectArea.ban) && wn(Ai)
                      })
                    }
                    P(Vr);
                    var Rr = D(Vr),
                      wr = C(Rr);
                    {
                      var xn = wn => {
                        var xr = XSe();
                        xr.__click = nt;
                        var vn = C(xr);
                        {
                          var Ur = Cn => {
                              var kn = $Se();
                              Z(Cn, kn)
                            },
                            Jr = Cn => {
                              Qp(Cn, {
                                class: "size-4"
                              })
                            };
                          At(vn, Cn => {
                            y(k) ? Cn(Ur) : Cn(Jr, !1)
                          })
                        }
                        P(xr), Bt(() => xr.disabled = y(k) || y(z) || St.size === 0 && y(Et) === 0), Z(wn, xr)
                      };
                      At(wr, wn => {
                        ze.hasPermission(Ri.tools.selectArea.clear) && wn(xn)
                      })
                    }
                    Mn(), P(Rr), P(Ci), P(Fi);
                    var qn = D(Fi);
                    di(qn, 23, () => y(w), wn => wn.id, (wn, xr, vn, Ur) => {
                      const Jr = ge(() => St.has(y(xr).id)),
                        Cn = ge(() => y(Zt).get(y(xr).id) ?? 0),
                        kn = ge(() => y(Jr) || y(Cn) > 0);
                      var sn = nPe();
                      let Bn;
                      sn.__click = () => {
                        y(Jr) ? (St.delete(y(xr).id), gr(y(xr).painted), jr(y(xr).id, {
                          skipCrosshair: !0
                        })) : (jr(y(xr).id, {
                          skipCrosshair: !0
                        }), St.set(y(xr).id, y(xr)), (Lr(y(xr)) || y(xr).id === 0) && mi.plop.play())
                      };
                      var Vn = C(sn),
                        bn = C(Vn);
                      xo(bn), P(Vn);
                      var In = D(Vn),
                        Ei = C(In);
                      {
                        var Wn = ai => {
                            var pi = YSe();
                            Mn(2), Z(ai, pi)
                          },
                          ki = ai => {
                            var pi = ePe(),
                              ji = xe(pi);
                            ws(ji, {
                              class: "size-5 border-0",
                              get userId() {
                                return y(xr).id
                              },
                              get pictureUrl() {
                                return y(xr).picture
                              }
                            });
                            var Sn = D(ji, 2),
                              jo = C(Sn),
                              pn = C(jo),
                              mn = C(pn, !0);
                            P(pn);
                            var Ko = D(pn, 2),
                              En = C(Ko);
                            P(Ko), P(jo);
                            var wo = D(jo, 2);
                            {
                              var ro = vi => {
                                var Ti = KSe(),
                                  po = C(Ti, !0);
                                P(Ti), Bt((ui, qo) => {
                                  Gr(Ti, 1, `badge badge-sm ml-0.5 border-0 ${ui??""} ${qo??""}`, "svelte-15blegn"), at(po, y(xr).allianceName)
                                }, [() => Td(y(xr).allianceId), () => Ji(y(xr).allianceId)]), Z(vi, Ti)
                              };
                              At(wo, vi => {
                                y(xr).allianceId && vi(ro)
                              })
                            }
                            var Oo = D(wo, 2);
                            {
                              var ko = vi => {
                                var Ti = JSe();
                                Z(vi, Ti)
                              };
                              At(Oo, vi => {
                                y(xr).deleted && vi(ko)
                              })
                            }
                            var Jo = D(Oo, 2),
                              Lo = C(Jo);
                            {
                              var Qo = vi => {
                                  var Ti = QSe(),
                                    po = C(Ti);
                                  fd(po, {
                                    class: "text-error size-4"
                                  }), P(Ti), Bt(ui => pr(Ti, "data-tip", ui), [() => $f()]), Z(vi, Ti)
                                },
                                Ts = vi => {
                                  var Ti = kr(),
                                    po = xe(Ti);
                                  {
                                    var ui = qo => {
                                      var Bs = tPe(),
                                        ya = C(Bs);
                                      Wl(ya, {
                                        class: "text-error size-4"
                                      }), P(Bs), Bt(Un => pr(Bs, "data-tip", Un), [() => _v()]), Z(qo, Bs)
                                    };
                                    At(po, qo => {
                                      y(xr).timedOut && qo(ui)
                                    }, !0)
                                  }
                                  Z(vi, Ti)
                                };
                              At(Lo, vi => {
                                y(xr).banned ? vi(Qo) : vi(Ts, !1)
                              })
                            }
                            P(Jo), P(Sn), Bt(vi => {
                              Gr(jo, 1, `font-medium ${vi??""} flex gap-1.5`, "svelte-15blegn"), at(mn, y(xr).name), at(En, `#${y(xr).id??""}`)
                            }, [() => Ji(y(xr).id)]), Z(ai, pi)
                          };
                        At(Ei, ai => {
                          y(xr).id === 0 ? ai(Wn) : ai(ki, !1)
                        })
                      }
                      P(In);
                      var yi = D(In),
                        Wi = C(yi),
                        $i = D(Wi);
                      {
                        var Yn = ai => {
                          var pi = rPe(),
                            ji = C(pi);
                          P(pi), Bt(Sn => at(ji, `(${Sn??""} selected)`), [() => y(Cn).toLocaleString()]), Z(ai, pi)
                        };
                        At($i, ai => {
                          !y(Jr) && y(Cn) > 0 && ai(Yn)
                        })
                      }
                      P(yi), P(sn), Bt(ai => {
                        Bn = Gr(sn, 1, "hover:bg-base-300 cursor-pointer svelte-15blegn", null, Bn, {
                          "bg-base-200": y(kn)
                        }), ay(bn, y(Jr)), bn.indeterminate = !y(Jr) && y(Cn) > 0, at(Wi, `${ai??""} `)
                      }, [() => y(xr).painted.latitudes.length.toLocaleString()]), Z(wn, sn)
                    }), P(qn), P(Hi), P(An), Bt(() => {
                      ay(qe, y(Ct) !== "none"), qe.indeterminate = y(Ct) === "some"
                    }), Z(Hr, An)
                  };
                At(Fn, Hr => {
                  y(w).length === 0 ? Hr(Rn) : Hr(Kr, !1)
                }, !0)
              }
              Z(Dr, un)
            };
          At(on, Dr => {
            y(z) ? Dr(ln) : Dr(Br, !1)
          })
        }
        P(Cr), P(Pt), P($t), P(W), os(W, Dr => Y(lt, Dr), () => y(lt)), Bt((Dr, un) => {
          vt = _a(W, "", vt, {
            transform: `translate3d(${G.x}px, ${G.y}px, 0)`,
            "will-change": "transform"
          }), at(be, `(Pixels: ${Dr??""})`), pr(Fe, "aria-label", `${un??""} toggle`), pr(Nr, "data-tip", y(R) ? "Save selected map view" : "Save selected pixel art"), Nr.disabled = y(c) || y(z), fe = Gr(Be, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, fe, {
            "btn-soft": y(Ht) !== "brush-circle",
            "btn-primary": y(Ht) === "brush-circle"
          }), pr(Be, "data-tip", `Circle brush (Alt + scroll to resize) Â· Size: ${y(jt)}`), pr(Be, "aria-label", y(Ht) === "brush-circle" ? "Disable circle brush tool" : `Enable circle brush tool (size ${y(jt)})`), pr(Be, "aria-pressed", y(Ht) === "brush-circle"), Ge = Gr(cr, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Ge, {
            "btn-soft": y(Ht) !== "brush-square",
            "btn-primary": y(Ht) === "brush-square"
          }), pr(cr, "data-tip", `Square brush (Alt + scroll to resize) Â· Size: ${y(jt)}`), pr(cr, "aria-label", y(Ht) === "brush-square" ? "Disable square brush tool" : `Enable square brush tool (size ${y(jt)})`), pr(cr, "aria-pressed", y(Ht) === "brush-square"), Jt = Gr(lr, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Jt, {
            "btn-soft": y(Ht) !== "user-picker",
            "btn-primary": y(Ht) === "user-picker"
          }), pr(lr, "data-tip", y(Ht) === "user-picker" ? "User picker enabled. Click pixels to select their painter." : "Enable the user picker to select a player by clicking a pixel."), pr(lr, "aria-label", y(Ht) === "user-picker" ? "Disable user picker tool" : "Enable user picker tool"), pr(lr, "aria-pressed", y(Ht) === "user-picker")
        }, [() => y(Wt).toLocaleString(), () => eut()]), Nf(Fe, () => y(R), Dr => Y(R, Dr)), vo(3, $t, () => rd, () => ({
          duration: 100
        })), Z(et, W)
      };
    At(Nt, et => {
      t.length < 2 ? et(ie) : et(mt, !1)
    })
  }
  Z(l, zt), rn()
}
ri(["pointerdown", "click"]);
const aPe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAfCAYAAAAfrhY5AAAByUlEQVR4AeyV0VEDMQxEbQqgDEqhFrpg6IJaKIUyaODQ89wqimKf75LM5AOY20harbWyf3gqD/z7N3/I49/j2RfbHFg49t1qvjx/vRVgtocXuMW8GZtp+Xn9JFR+jmCvObeKcI9gHPvkrhklM3OGLMv7S4mwYfAW/Btpss4PkIzMOeQDEQr149sX4dZaCl4aonjL2yyLF1/PvGvKSQwYSp4BT7/H0zOeJSycvmzejE/t+2W9BbL5pts6wDWz2oWDJJr7rXm+iMHZTTqeJ0e8LuvPH83pN6yilvPDYYF6BGmIUZPnqdc1V1NxWZYCqPNgOCAeHYCbYZd5HiIj8bkWP4tD8/hUtdZSa/VZ6slUNYJaa1dLL2NojjAOpQbiZKwoHo3Q49QjbpojYEAEHJhx9NFtYWqum/WGXNvTrGhe8zDVijpEFKcIJ4hTTHxVHc3FtaiDej7VNJUf7XE2Ipv77RkMECtiCiI368W+nfNbW16yOVxbQCYQQENynuuoo8ccYPmZsdVdc3iEF0swGCAA61BS/x/fCvuhB0hXWDj/ejePirMlGBZhQl8w8uT0VljofzNznWpLWJGjUSVzqultYq/55pBrm3/X/BcAAP//XVoCOwAAAAZJREFUAwCtKAFOt0LgOAAAAABJRU5ErkJgggAA";
var uPe = $r('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function p0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = uPe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var cPe = $r('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function lPe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = cPe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var _Pe = $r('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  hPe = $r('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function dPe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var w = kr(),
    z = xe(w);
  {
    var E = c => {
        var R = _Pe();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      },
      k = c => {
        var R = hPe();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      };
    At(z, c => {
      s.filled ? c(E) : c(k, !1)
    })
  }
  Z(l, w)
}
var pPe = ft('<a target="_blank"><button class="btn btn-xs py-3"><!></button></a>'),
  fPe = ft('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button> <!>', 1),
  mPe = ft('<div class="skeleton h-5 w-16"></div>'),
  gPe = ft('<div class="skeleton mt-1 h-5 w-32"></div>'),
  yPe = ft('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm"><img alt="Pumpkin" class="size-5"/></div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span> </span> <span> </span></span></div></div>'),
  vPe = ft('<span class="font-flag tooltip ml-0.5"> </span>'),
  bPe = ft("<button><!></button>"),
  xPe = ft("<span> </span> <!>", 1),
  wPe = ft('<span class="tooltip"><!></span>'),
  kPe = ft('<span class="tooltip"><!></span>'),
  TPe = ft("<li><button><!> </button></li>"),
  SPe = ft("<li><button><!> </button></li>"),
  PPe = ft("<li><button><!> </button></li>"),
  MPe = ft('<li><button class="text-error font-medium"><!> </button></li>'),
  CPe = ft('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'),
  IPe = ft('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'),
  zPe = ft('<button class="btn btn-primary"><!> </button>'),
  APe = ft("<!> ", 1),
  EPe = ft("<!> ", 1),
  jPe = ft('<button class="btn btn-primary"><!></button>'),
  LPe = ft("<button><!> </button>"),
  DPe = ft('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function RPe(l, s) {
  en(s, !0);
  let t = ee(void 0);
  const w = ge(() => new Bo(s.tileSize));
  let z = ee(void 0),
    E = ee(void 0),
    k = ee(!1),
    c = ee(!1);
  const R = ge(() => {
      var se, ce, ur;
      return !!((ce = (se = y(t)) == null ? void 0 : se.paintedBy) != null && ce.id) && ((ur = ze.data) == null ? void 0 : ur.id) === y(t).paintedBy.id
    }),
    X = ge(() => {
      const [se, ce] = s.latLon ?? [0, 0];
      return `https://wplace.eralyon.net/?lat=${se}&lng=${ce}&zoom=${s.zoom}`
    }),
    $ = ge(() => {
      const [se, ce] = s.latLon ?? [0, 0], ur = y(w).latLonToPixelBoundsLatLon(se, ce, s.pixelArtZoom), Ke = nm(ur), {
        tile: ve,
        pixel: _r
      } = y(w).latLonToTileAndPixel(se, ce, s.pixelArtZoom), nr = y(w).latLonToRegionAndPixel(se, ce, s.pixelArtZoom);
      return {
        lat: se,
        lon: ce,
        bounds: ur,
        center: Ke,
        tile: ve,
        pixel: _r,
        regionPixel: nr.pixel
      }
    });
  cn(() => {
    mi.plop.play(), s.crosshair.clearAndPlace(s.latLon)
  });
  let tt = 0;
  const ut = ({
    pixel: se,
    tile: ce,
    season: ur
  }) => `s${ur}:p(${se[0]},${se[1]}):t(${ce[0]},${ce[1]})`;
  let xt;
  ha(() => [y($), s.season], () => {
    const se = {
        ...y($),
        season: s.season
      },
      ce = ut(se);
    if (Y(t, s.pixelInfoCache.get(ce), !0), y(t) !== void 0) return;
    s.pixelInfoCache.size === 0 && (tt = 0), tt++, tt > 6 ? (clearTimeout(xt), xt = setTimeout(async () => lt(se), 500)) : lt(se)
  });
  async function lt(se) {
    var Ke;
    const ce = await fn.getPixelInfo({
      ...se,
      role: (Ke = ze.data) == null ? void 0 : Ke.role
    });
    if (ce.paintedBy !== void 0) {
      const ve = ut(se);
      s.pixelInfoCache.set(ve, ce)
    }
    const ur = ut({
      ...y($),
      season: s.season
    });
    return Y(t, s.pixelInfoCache.get(ur), !0), ce
  }
  ti(() => () => {
    s.crosshair.clear(), mi.smallPlop.play()
  });
  const G = ge(() => {
    const se = [];
    return ze.hasPermission(Ri.tools.selectPixel.ban) && se.push("ban-user"), ze.hasPermission(Ri.tools.selectPixel.timeout) && se.push("timeout-user"), !y(R) && ze.data && se.push("report-user"), se
  });

  function yt(se) {
    const ce = (async () => await yd(s.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    s.onclickmodaction(y(t), ce, s.latLon, se)
  }
  async function Lt() {
    try {
      await fn.claimEventPixel({
        ...y($),
        season: s.season
      }), Ne.success(Mz({
        droplets: 2e3.toLocaleString()
      })), await lt({
        ...y($),
        season: s.season
      }), await ze.refresh()
    } catch (se) {
      Ne.error(se.message)
    }
  }
  var Dt = DPe();
  jn("keypress", Oa, se => {
    se.key === "Escape" && s.onclose()
  });
  var St = C(Dt),
    qt = C(St),
    Vt = C(qt);
  Vt.__click = () => {
    if (y(z) && y(E)) {
      const se = y(z) - y(E).clientHeight,
        ce = y(z) / 2 - se / 2;
      s.map.flyTo({
        center: {
          lat: y($).center[0],
          lng: y($).center[1]
        },
        zoom: 17.5,
        offset: [0, -ce]
      })
    }
  };
  var Zt = C(Vt);
  Pd(Zt, {
    class: "fill-primary size-5"
  }), P(Vt);
  var Et = D(Vt, 2),
    Ct = C(Et),
    Wt = C(Ct);
  P(Ct);
  var jt = D(Ct, 2);
  {
    var Ht = se => {
        const ce = ge(() => y(t).region),
          ur = ge(() => Ls(y(ce).countryId));
        var Ke = fPe(),
          ve = xe(Ke);
        ve.__click = () => s.onclickregion(y(ce));
        var _r = C(ve),
          nr = C(_r, !0);
        P(_r);
        var gr = D(_r, 2),
          ir = C(gr, !0);
        P(gr);
        var Ze = D(gr, 2),
          or = C(Ze);
        P(Ze), P(ve);
        var de = D(ve, 2);
        {
          var zr = er => {
            var hr = pPe(),
              Mr = C(hr),
              Pr = C(Mr);
            s0(Pr, {
              class: "w-4 h-4"
            }), P(Mr), P(hr), Bt(() => pr(hr, "href", y(X))), Z(er, hr)
          };
          At(de, er => {
            var hr;
            ((hr = ze.data) == null ? void 0 : hr.role) !== "user" && ze.hasPermission(Ri.tools.selectPixel.archive) && er(zr)
          })
        }
        Bt(er => {
          Gr(ve, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${er??""}`), pr(_r, "data-tip", y(ur).name), at(nr, y(ur).flag), at(ir, y(ce).name), at(or, `#${y(ce).number??""}`)
        }, [() => Ji(y(ce).cityId)]), Z(se, Ke)
      },
      _e = se => {
        var ce = mPe();
        Z(se, ce)
      };
    At(jt, se => {
      var ce;
      (ce = y(t)) != null && ce.region ? se(Ht) : se(_e, !1)
    })
  }
  P(Et), P(qt);
  var Ut = D(qt, 2);
  Ut.__click = function(...se) {
    var ce;
    (ce = s.onclose) == null || ce.apply(this, se)
  };
  var Xt = C(Ut);
  pa(Xt, {
    class: "size-4"
  }), P(Ut), P(St);
  var me = D(St, 2),
    Ce = C(me);
  {
    var Ve = se => {
        var ce = gPe();
        Z(se, ce)
      },
      Ie = se => {
        var ce = kr(),
          ur = xe(ce);
        {
          var Ke = _r => {
              var nr = to();
              Bt(gr => at(nr, gr), [() => yq()]), Z(_r, nr)
            },
            ve = _r => {
              var nr = kr(),
                gr = xe(nr);
              {
                var ir = or => {
                    var de = yPe(),
                      zr = C(de),
                      er = C(zr);
                    P(zr);
                    var hr = D(zr, 2),
                      Mr = C(hr),
                      Pr = C(Mr);
                    P(Mr), P(hr);
                    var Or = D(hr, 2),
                      jr = C(Or),
                      Lr = C(jr),
                      _n = C(Lr, !0);
                    P(Lr);
                    var dr = D(Lr, 2),
                      ct = C(dr);
                    P(dr), P(jr), P(Or), P(de), Bt((q, U) => {
                      at(er, `${q??""}:`), pr(Pr, "src", aPe), at(_n, U), at(ct, `#${y(t).paintedBy.eventClaimNumber??""}`)
                    }, [() => pz(), () => PH()]), Z(or, de)
                  },
                  Ze = or => {
                    const de = ge(() => y(t).paintedBy);
                    var zr = IPe(),
                      er = C(zr),
                      hr = C(er);
                    P(er);
                    var Mr = D(er, 2),
                      Pr = C(Mr);
                    ws(Pr, {
                      class: "size-5 border-0",
                      get userId() {
                        return y(de).id
                      },
                      get pictureUrl() {
                        return y(de).picture
                      }
                    }), P(Mr);
                    var Or = D(Mr, 2),
                      jr = C(Or),
                      Lr = C(jr),
                      _n = C(Lr, !0);
                    P(Lr);
                    var dr = D(Lr, 2),
                      ct = C(dr);
                    P(dr), P(jr);
                    var q = D(jr, 2);
                    {
                      var U = vt => {
                        const $t = ge(() => Ls(y(de).equippedFlag));
                        var Pt = vPe(),
                          Gt = C(Pt, !0);
                        P(Pt), Bt(() => {
                          pr(Pt, "data-tip", y($t).name), at(Gt, y($t).flag)
                        }), Z(vt, Pt)
                      };
                      At(q, vt => {
                        y(de).equippedFlag && vt(U)
                      })
                    }
                    var Q = D(q, 2);
                    {
                      var nt = vt => {
                        j_(vt, {
                          get username() {
                            return y(de).discord
                          },
                          get id() {
                            return y(de).discordId
                          }
                        })
                      };
                      At(Q, vt => {
                        y(de).discord && vt(nt)
                      })
                    }
                    var _t = D(Q, 2);
                    {
                      var Tt = vt => {
                        lv(vt, {
                          get role() {
                            return y(de).role
                          },
                          big: !1
                        })
                      };
                      At(_t, vt => {
                        y(de).role && y(de).role !== "user" && vt(Tt)
                      })
                    }
                    var Ft = D(_t, 2);
                    {
                      var zt = vt => {
                        var $t = xPe(),
                          Pt = xe($t),
                          Gt = C(Pt, !0);
                        P(Pt);
                        var ae = D(Pt, 2);
                        {
                          var ye = Te => {
                            var we = bPe();
                            we.__click = () => {
                              navigator.clipboard.writeText(y(de).allianceId.toString()), Ne.success(Kf())
                            };
                            var be = C(we);
                            Yf(be, {
                              class: "size-3"
                            }), P(we), Bt((Ee, Qe) => {
                              Gr(we, 1, Ee), pr(we, "title", Qe)
                            }, [() => qa(Ji(y(de).allianceId)), () => k1({
                              allianceId: y(de).allianceId
                            })]), Z(Te, we)
                          };
                          At(ae, Te => {
                            var we, be, Ee;
                            (((we = ze.data) == null ? void 0 : we.role) === "admin" || ((be = ze.data) == null ? void 0 : be.role) === "moderator" || ((Ee = ze.data) == null ? void 0 : Ee.role) === "global_moderator") && Te(ye)
                          })
                        }
                        Bt((Te, we) => {
                          Gr(Pt, 1, `badge badge-sm ml-0.5 border-0 ${Te??""} ${we??""}`), at(Gt, y(de).allianceName)
                        }, [() => Td(y(de).allianceId), () => Ji(y(de).allianceId)]), Z(vt, $t)
                      };
                      At(Ft, vt => {
                        y(de).allianceId && vt(zt)
                      })
                    }
                    var Nt = D(Ft, 2);
                    {
                      var ie = vt => {
                          var $t = wPe(),
                            Pt = C($t);
                          fd(Pt, {
                            class: "text-error size-4"
                          }), P($t), Bt(Gt => pr($t, "data-tip", Gt), [() => $f()]), Z(vt, $t)
                        },
                        mt = vt => {
                          var $t = kr(),
                            Pt = xe($t);
                          {
                            var Gt = ae => {
                              var ye = kPe(),
                                Te = C(ye);
                              Wl(Te, {
                                class: "text-error size-4"
                              }), P(ye), Bt(we => pr(ye, "data-tip", we), [() => _v()]), Z(ae, ye)
                            };
                            At(Pt, ae => {
                              y(t).paintedBy.timedOut && ae(Gt)
                            }, !0)
                          }
                          Z(vt, $t)
                        };
                      At(Nt, vt => {
                        y(t).paintedBy.banned ? vt(ie) : vt(mt, !1)
                      })
                    }
                    P(Or);
                    var et = D(Or, 2);
                    {
                      var W = vt => {
                        var $t = CPe(),
                          Pt = C($t),
                          Gt = C(Pt);
                        cm(Gt, {
                          class: "size-4"
                        }), P(Pt);
                        var ae = D(Pt, 2);
                        di(ae, 21, () => y(G), P_, (ye, Te) => {
                          var we = kr(),
                            be = xe(we);
                          {
                            var Ee = Yt => {
                                var je = TPe(),
                                  Fe = C(je);
                                let Nr;
                                Fe.__click = () => {
                                  yt("report-user")
                                };
                                var Ar = C(Fe);
                                Lf(Ar, {
                                  class: "size-5"
                                });
                                var Kt = D(Ar);
                                P(Fe), P(je), Bt(Oe => {
                                  Nr = Gr(Fe, 1, "py-2 font-medium text-red-300", null, Nr, {
                                    "cursor-not-allowed": y(R)
                                  }), at(Kt, ` ${Oe??""}`)
                                }, [() => u1()]), Z(Yt, je)
                              },
                              Qe = Yt => {
                                var je = kr(),
                                  Fe = xe(je);
                                {
                                  var Nr = Kt => {
                                      var Oe = SPe(),
                                        Be = C(Oe);
                                      let fe;
                                      Be.__click = () => {
                                        yt("timeout")
                                      };
                                      var Me = C(Be);
                                      Wl(Me, {
                                        class: "size-5"
                                      });
                                      var cr = D(Me);
                                      P(Be), P(Oe), Bt(Ge => {
                                        fe = Gr(Be, 1, "text-warning font-medium", null, fe, {
                                          "cursor-not-allowed": y(R)
                                        }), at(cr, ` ${Ge??""}`)
                                      }, [() => c1()]), Z(Kt, Oe)
                                    },
                                    Ar = Kt => {
                                      var Oe = kr(),
                                        Be = xe(Oe);
                                      {
                                        var fe = cr => {
                                            var Ge = PPe(),
                                              qr = C(Ge);
                                            let lr;
                                            qr.__click = () => {
                                              yt("ban")
                                            };
                                            var Jt = C(qr);
                                            fd(Jt, {
                                              class: "size-5"
                                            });
                                            var Se = D(Jt);
                                            P(qr), P(Ge), Bt(rr => {
                                              lr = Gr(qr, 1, "text-error font-medium", null, lr, {
                                                "cursor-not-allowed": y(R)
                                              }), at(Se, ` ${rr??""}`)
                                            }, [() => l1()]), Z(cr, Ge)
                                          },
                                          Me = cr => {
                                            var Ge = kr(),
                                              qr = xe(Ge);
                                            {
                                              var lr = Jt => {
                                                var Se = MPe(),
                                                  rr = C(Se);
                                                rr.__click = async () => {
                                                  Y(c, !0);
                                                  try {
                                                    await fn.banAllianceUser(y(de).id), await lt({
                                                      ...y($),
                                                      season: s.season
                                                    })
                                                  } catch (De) {
                                                    Ne.error(De.message)
                                                  } finally {
                                                    Y(c, !1)
                                                  }
                                                };
                                                var Le = C(rr);
                                                lPe(Le, {
                                                  class: "size-5"
                                                });
                                                var sr = D(Le);
                                                P(rr), P(Se), Bt(De => at(sr, ` ${De??""}`), [() => dv()]), Z(Jt, Se)
                                              };
                                              At(qr, Jt => {
                                                y(Te) === "ban-alliance" && Jt(lr)
                                              }, !0)
                                            }
                                            Z(cr, Ge)
                                          };
                                        At(Be, cr => {
                                          y(Te) === "ban-user" ? cr(fe) : cr(Me, !1)
                                        }, !0)
                                      }
                                      Z(Kt, Oe)
                                    };
                                  At(Fe, Kt => {
                                    y(Te) === "timeout-user" ? Kt(Nr) : Kt(Ar, !1)
                                  }, !0)
                                }
                                Z(Yt, je)
                              };
                            At(be, Yt => {
                              y(Te) === "report-user" ? Yt(Ee) : Yt(Qe, !1)
                            })
                          }
                          Z(ye, we)
                        }), P(ae), P($t), Z(vt, $t)
                      };
                      At(et, vt => {
                        y(G).length > 0 && vt(W)
                      })
                    }
                    P(zr), Bt((vt, $t) => {
                      var Pt;
                      at(hr, `${vt??""}:`), Gr(jr, 1, `font-medium ${$t??""} flex gap-1.5`), at(_n, ((Pt = ze.data) == null ? void 0 : Pt.id) === y(de).id ? ze.data.name : y(de).name), at(ct, `#${y(de).id??""}`)
                    }, [() => cU(), () => Ji(y(de).id)]), Z(or, zr)
                  };
                At(gr, or => {
                  y(t).paintedBy.event ? or(ir) : or(Ze, !1)
                }, !0)
              }
              Z(_r, nr)
            };
          At(ur, _r => {
            y(t).paintedBy.id === 0 ? _r(Ke) : _r(ve, !1)
          }, !0)
        }
        Z(se, ce)
      };
    At(Ce, se => {
      y(t) === void 0 ? se(Ve) : se(Ie, !1)
    })
  }
  P(me);
  var ne = D(me, 2),
    Xe = C(ne);
  {
    var pe = se => {
        var ce = zPe();
        ce.__click = () => s.onclickpaint(s.latLon);
        var ur = C(ce);
        vu(ur, {
          class: "size-4.5"
        });
        var Ke = D(ur);
        P(ce), Bt(ve => {
          ce.disabled = ze.loading, at(Ke, ` ${ve??""}`)
        }, [() => gv()]), Z(se, ce)
      },
      Ue = se => {
        var ce = kr(),
          ur = xe(ce);
        {
          var Ke = ve => {
            var _r = jPe();
            _r.__click = () => Lt();
            var nr = C(_r);
            {
              var gr = Ze => {
                  var or = APe(),
                    de = xe(or);
                  T1(de, {
                    class: "size-4.5"
                  });
                  var zr = D(de);
                  Bt(er => at(zr, ` ${er??""}`), [() => gT()]), Z(Ze, or)
                },
                ir = Ze => {
                  var or = EPe(),
                    de = xe(or);
                  p0(de, {
                    class: "size-4.5"
                  });
                  var zr = D(de);
                  Bt(er => at(zr, ` ${er??""}`), [() => iT()]), Z(Ze, or)
                };
              At(nr, Ze => {
                y(t).paintedBy.claimed ? Ze(gr) : Ze(ir, !1)
              })
            }
            P(_r), Bt(() => _r.disabled = ze.loading || y(t).paintedBy.claimed), Z(ve, _r)
          };
          At(ur, ve => {
            ze.data && ve(Ke)
          }, !0)
        }
        Z(se, ce)
      };
    At(Xe, se => {
      var ce;
      (ce = y(t)) != null && ce.paintedBy.event ? se(Ue, !1) : se(pe)
    })
  }
  var Ae = D(Xe, 2);
  {
    var He = se => {
      const ce = ge(() => ze.data.favoriteLocations.find(gr => Math.abs(gr.latitude - y($).center[0]) < 5e-5 && Math.abs(gr.longitude - y($).center[1]) < 5e-5)),
        ur = ge(() => !y(ce) && ze.data.favoriteLocations.length >= ze.data.maxFavoriteLocations);
      var Ke = LPe();
      let ve;
      Ke.__click = async () => {
        try {
          Y(k, !0), y(ce) ? (await fn.deleteFavoriteLocation(y(ce).id), Ne.warning(OL())) : (await fn.favoriteLocation(y($).center), Ne.success(PL())), mi.smallPlop.play(), ze.refresh()
        } catch (gr) {
          Ne.error(gr.message)
        } finally {
          Y(k, !1)
        }
      };
      var _r = C(Ke);
      {
        let gr = ge(() => !!y(ce));
        dPe(_r, {
          class: "size-4.5",
          get filled() {
            return y(gr)
          }
        })
      }
      var nr = D(_r);
      P(Ke), Bt(gr => {
        ve = Gr(Ke, 1, "btn btn-primary btn-soft", null, ve, {
          "text-yellow-400": !!y(ce)
        }), Ke.disabled = y(k) || y(ur), at(nr, ` ${gr??""}`)
      }, [() => y(ur) ? tL() : qz()]), Z(se, Ke)
    };
    At(Ae, se => {
      ze.data && se(He)
    })
  }
  var Tr = D(Ae, 2);
  Tr.__click = () => s.onclickshare(W0e(gi.url, {
    pos: {
      lat: y($).center[0],
      lng: y($).center[1]
    },
    zoom: s.zoom
  }));
  var Ye = C(Tr);
  Uv(Ye, {
    class: "size-4.5"
  });
  var mr = D(Ye);
  P(Tr), P(ne), P(Dt), os(Dt, se => Y(E, se), () => y(E)), Bt(se => {
    at(Wt, `Pixel: ${y($).regionPixel[0]??""}, ${y($).regionPixel[1]??""}`), at(mr, ` ${se??""}`)
  }, [() => dK()]), I_("innerHeight", se => Y(z, se, !0)), Z(l, Dt), rn()
}
ri(["click"]);

function BPe(l) {
  var w;
  const s = document.createElement("div");
  (w = l.parentElement) == null || w.insertBefore(s, l.nextSibling);
  const t = new IntersectionObserver(z => {
    z[0].isIntersecting ? l.classList.remove("stuck") : l.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return t.observe(s), () => {
    s.remove(), t.disconnect()
  }
}
var Rf;
(l => {
  function s() {
    let t, w;
    return {
      promise: new Promise((E, k) => {
        t = E, w = k
      }),
      resolve: t,
      reject: w
    }
  }
  l.withResolvers = s
})(Rf || (Rf = {}));
var FPe = $r('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  OPe = $r('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function qPe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy", "filled"]);
  var w = kr(),
    z = xe(w);
  {
    var E = c => {
        var R = FPe();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      },
      k = c => {
        var R = OPe();
        Er(R, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...t
        })), Z(c, R)
      };
    At(z, c => {
      s.filled ? c(E) : c(k, !1)
    })
  }
  Z(l, w)
}
const Kp = {
  AF: uwt,
  AL: xwt,
  DZ: Lwt,
  AS: Wwt,
  AD: s2t,
  AO: v2t,
  AI: E2t,
  AQ: G2t,
  AG: ikt,
  AR: gkt,
  AM: zkt,
  AW: Ukt,
  AU: r5t,
  AT: f5t,
  AZ: C5t,
  BS: N5t,
  BH: t3t,
  BD: d3t,
  BB: P3t,
  BY: O3t,
  BE: J3t,
  BZ: _Tt,
  BJ: TTt,
  BM: BTt,
  BT: YTt,
  BO: cSt,
  BQ: wSt,
  BA: DSt,
  BW: $St,
  BV: aPt,
  BR: bPt,
  IO: jPt,
  BN: HPt,
  BG: oMt,
  BF: yMt,
  BI: AMt,
  CV: ZMt,
  KH: nCt,
  CM: mCt,
  CA: ICt,
  KY: VCt,
  CF: eIt,
  TD: pIt,
  CL: MIt,
  CN: qIt,
  CX: QIt,
  CC: hzt,
  CO: Szt,
  KM: Fzt,
  CG: Kzt,
  CK: l4t,
  CR: k4t,
  HR: R4t,
  CU: X4t,
  CW: uAt,
  CY: xAt,
  CZ: LAt,
  CI: WAt,
  DK: s6t,
  DJ: v6t,
  DM: E6t,
  DO: G6t,
  EC: iEt,
  EG: gEt,
  SV: zEt,
  GQ: UEt,
  ER: r8t,
  EE: f8t,
  SZ: C8t,
  ET: N8t,
  FK: tjt,
  FO: djt,
  FJ: Pjt,
  FI: Ojt,
  FR: Jjt,
  GF: _Lt,
  PF: TLt,
  TF: BLt,
  GA: YLt,
  GM: cDt,
  GE: wDt,
  DE: DDt,
  GH: $Dt,
  GI: aRt,
  GR: bRt,
  GL: jRt,
  GD: HRt,
  GP: oBt,
  GU: yBt,
  GT: ABt,
  GG: ZBt,
  GN: nFt,
  GW: mFt,
  GY: IFt,
  HT: VFt,
  HM: e7t,
  HN: p7t,
  HK: M7t,
  HU: q7t,
  IS: Q7t,
  IN: h9t,
  ID: S9t,
  IR: F9t,
  IQ: K9t,
  IE: lOt,
  IM: kOt,
  IL: ROt,
  IT: XOt,
  JM: uqt,
  JP: xqt,
  JE: Lqt,
  JO: Wqt,
  KZ: sNt,
  KE: vNt,
  KI: ENt,
  XK: GNt,
  KW: iVt,
  KG: gVt,
  LA: zVt,
  LV: UVt,
  LB: rUt,
  LS: fUt,
  LR: CUt,
  LY: NUt,
  LI: tZt,
  LT: dZt,
  LU: PZt,
  MO: OZt,
  MG: JZt,
  MW: _Gt,
  MY: TGt,
  MV: BGt,
  ML: YGt,
  MT: cHt,
  MH: wHt,
  MQ: DHt,
  MR: $Ht,
  MU: aWt,
  YT: bWt,
  MX: jWt,
  FM: HWt,
  MD: o$t,
  MC: y$t,
  MN: A$t,
  ME: Z$t,
  MS: nXt,
  MA: mXt,
  MZ: IXt,
  MM: VXt,
  NA: eYt,
  NR: pYt,
  NP: MYt,
  NL: qYt,
  NC: QYt,
  NZ: hKt,
  NI: SKt,
  NE: FKt,
  NG: KKt,
  NU: lJt,
  NF: kJt,
  KP: RJt,
  MK: XJt,
  MP: uQt,
  NO: xQt,
  OM: LQt,
  PK: WQt,
  PW: ste,
  PS: vte,
  PA: Ete,
  PG: Gte,
  PY: iee,
  PE: gee,
  PH: zee,
  PN: Uee,
  PL: rre,
  PT: fre,
  PR: Cre,
  QA: Nre,
  CD: tne,
  RO: dne,
  RU: Pne,
  RW: One,
  RE: Jne,
  BL: _ie,
  SH: Tie,
  KN: Bie,
  LC: Yie,
  MF: coe,
  PM: woe,
  VC: Doe,
  WS: $oe,
  SM: ase,
  ST: bse,
  SA: jse,
  SN: Hse,
  RS: oae,
  SC: yae,
  SL: Aae,
  SG: Zae,
  SX: nue,
  SK: mue,
  SI: Iue,
  SB: Vue,
  SO: ece,
  ZA: pce,
  GS: Mce,
  KR: qce,
  SS: Qce,
  ES: hle,
  LK: Sle,
  SD: Fle,
  SR: Kle,
  SJ: l_e,
  SE: k_e,
  CH: R_e,
  SY: X_e,
  TW: uhe,
  TJ: xhe,
  TZ: Lhe,
  TH: Whe,
  TL: sde,
  TG: vde,
  TK: Ede,
  TO: Gde,
  TT: ipe,
  TN: gpe,
  TM: zpe,
  TC: Upe,
  TV: rfe,
  TR: ffe,
  UG: Cfe,
  UA: Nfe,
  AE: tme,
  GB: dme,
  US: Pme,
  UM: Ome,
  UY: Jme,
  UZ: _ge,
  VU: Tge,
  VA: Bge,
  VE: Yge,
  VN: cye,
  VG: wye,
  VI: Dye,
  WF: $ye,
  EH: ave,
  YE: bve,
  ZM: jve,
  ZW: Hve,
  AX: o0e,
  IC: y0e
};
var NPe = ft("<p><!></p>"),
  VPe = ft('<span class="loading loading-spinner center-absolute absolute"></span>'),
  UPe = ft('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'),
  ZPe = ft('<span class="loading loading-spinner center-absolute absolute"></span>'),
  GPe = ft('<!> <span class="text-sm"> </span>', 1),
  HPe = ft('<span class="text-sm"> </span>'),
  WPe = ft('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  $Pe = ft('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  XPe = ft('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function YPe(l, s) {
  en(s, !0);
  const t = (Zt, Et = Yo, Ct = Yo) => {
      const Wt = ge(() => {
          var Ye;
          return (((Ye = ze.data) == null ? void 0 : Ye.droplets) ?? 0) >= c.price
        }),
        jt = ge(() => y(X) === Et().id),
        Ht = ge(() => w.has(Et().id));
      var _e = $Pe(),
        Ut = C(_e),
        Xt = C(Ut, !0);
      P(Ut);
      var me = D(Ut, 2),
        Ce = C(me),
        Ve = D(Ce);
      {
        var Ie = Ye => {
          var mr = NPe(),
            se = C(mr);
          Yl(se, {
            class: "text-base-content/60 size-4.5 inline pb-0.5"
          }), P(mr), Bt(ce => {
            Gr(mr, 1, qa({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": (Ct() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": Ct() % 4 === 0,
              "before:-translate-x-1/3": (Ct() + 1) % 2 === 0,
              "before:translate-x-1/3": Ct() % 2 === 0
            })), pr(mr, "data-tip", ce)
          }, [() => xO()]), Z(Ye, mr)
        };
        At(Ve, Ye => {
          y(Ht) && Ye(Ie)
        })
      }
      P(me);
      var ne = D(me, 2);
      {
        var Xe = Ye => {
          hm(Ye, {})
        };
        At(ne, Ye => {
          Et().id === y($) && Ye(Xe)
        })
      }
      var pe = D(ne, 2);
      let Ue;
      var Ae = C(pe);
      {
        var He = Ye => {
            var mr = UPe();
            mr.__click = async () => {
              if (!(y(Ht) && !await s.promptUserConfirmation(Et().label))) try {
                const ve = Et().id;
                Y(X, ve, !0), await fn.purchase({
                  id: k,
                  amount: 1,
                  variant: ve
                }), ze.refresh(), mi.notification1.play();
                const _r = E.find(nr => nr.id === ve);
                _r && (_r.owned = !0), Y($, ve, !0)
              } catch (ve) {
                Ne.error(ve.message)
              } finally {
                Y(X, void 0)
              }
            };
            var se = C(mr);
            {
              var ce = ve => {
                var _r = VPe();
                Z(ve, _r)
              };
              At(se, ve => {
                y(jt) && ve(ce)
              })
            }
            var ur = D(se, 2);
            kd(ur, {
              class: "size-4"
            });
            var Ke = D(ur);
            Mn(), P(mr), Bt(ve => {
              mr.disabled = !y(Wt) || y(jt), at(Ke, ` ${ve??""} `)
            }, [() => c.price.toLocaleString("en-US")]), Z(Ye, mr)
          },
          Tr = Ye => {
            const mr = ge(() => {
              var Ze;
              return ((Ze = ze.data) == null ? void 0 : Ze.equippedFlag) === Et().id
            });
            var se = WPe();
            let ce;
            se.__click = async () => {
              try {
                Y(X, Et().id, !0);
                const Ze = y(mr) ? 0 : Et().id;
                await fn.equipFlag(Ze), ze.data && (ze.data.equippedFlag = Ze), ze.refresh()
              } catch (Ze) {
                Ne.error(Ze.message)
              } finally {
                Y(X, void 0)
              }
            };
            var ur = C(se),
              Ke = C(ur, !0);
            P(ur);
            var ve = D(ur, 2);
            {
              var _r = Ze => {
                var or = ZPe();
                Z(Ze, or)
              };
              At(ve, Ze => {
                y(jt) && Ze(_r)
              })
            }
            var nr = D(ve, 2);
            {
              var gr = Ze => {
                  var or = GPe(),
                    de = xe(or);
                  pa(de, {
                    class: "size-4"
                  });
                  var zr = D(de, 2),
                    er = C(zr, !0);
                  P(zr), Bt(hr => at(er, hr), [() => VI()]), Z(Ze, or)
                },
                ir = Ze => {
                  var or = HPe(),
                    de = C(or, !0);
                  P(or), Bt(zr => at(de, zr), [() => II()]), Z(Ze, or)
                };
              At(nr, Ze => {
                y(mr) ? Ze(gr) : Ze(ir, !1)
              })
            }
            P(se), Bt(Ze => {
              ce = Gr(se, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, ce, {
                "btn-warning": y(mr)
              }), se.disabled = y(jt), at(Ke, Ze)
            }, [() => ZC()]), Z(Ye, se)
          };
        At(Ae, Ye => {
          Et().owned ? Ye(Tr, !1) : Ye(He)
        })
      }
      P(pe), P(_e), Bt(Ye => {
        at(Xt, Et().flag), at(Ce, `${Et().label??""} `), Ue = Gr(pe, 1, "mt-3", null, Ue, {
          tooltip: !y(Wt)
        }), pr(pe, "data-tip", Ye)
      }, [() => Cd()]), Z(Zt, _e)
    },
    w = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    z = Ao.countries.map(Zt => {
      var Et;
      return {
        ...Zt,
        owned: ze.flagsBitmap.get(Zt.id),
        label: ((Et = Kp[Zt.code]) == null ? void 0 : Et.call(Kp)) ?? Zt.name
      }
    });
  z.sort((Zt, Et) => Number(Et.owned) - Number(Zt.owned));
  const E = Qi(z),
    k = 110,
    c = Ao.products[k];
  let R = ee(!1),
    X = ee(void 0),
    $ = ee(void 0);
  var tt = XPe(),
    ut = C(tt),
    xt = C(ut);
  qPe(xt, {
    class: "size-5.5",
    filled: !0
  });
  var lt = D(xt, 2),
    G = C(lt, !0);
  P(lt), P(ut);
  var yt = D(ut, 2),
    Lt = C(yt, !0);
  P(yt);
  var Dt = D(yt, 2);
  di(Dt, 23, () => E, Zt => Zt.id, (Zt, Et, Ct) => {
    var Wt = kr(),
      jt = xe(Wt);
    {
      var Ht = _e => {
        t(_e, () => y(Et), () => y(Ct))
      };
      At(jt, _e => {
        (y(Ct) < 8 || y(R)) && _e(Ht)
      })
    }
    Z(Zt, Wt)
  }), P(Dt);
  var St = D(Dt, 2),
    qt = C(St);
  qt.__click = () => {
    Y(R, !y(R))
  };
  var Vt = C(qt, !0);
  P(qt), P(St), P(tt), Bt((Zt, Et, Ct) => {
    at(G, Zt), at(Lt, Et), at(Vt, Ct)
  }, [() => A0e(), () => yC(), () => y(R) ? put() : Mut()]), Z(l, tt), rn()
}
ri(["click"]);
var KPe = ft('<p class="mt-1 text-center text-sm"> </p>'),
  JPe = ft('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  QPe = ft('<span class="loading loading-spinner center-absolute absolute"></span>'),
  tMe = ft('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function Hy(l, s) {
  en(s, !0);
  let t = $e(s, "amount", 15, 1);
  const w = ge(() => t() * s.unitPrice),
    z = ge(() => Math.floor(s.userDroplets / s.unitPrice));
  let E = ee(!1);
  cn(() => {
    t() < 0 && t(0)
  });
  var k = tMe(),
    c = C(k),
    R = C(c);
  Bi(R, () => s.icon ?? Yo), P(c);
  var X = D(c, 2),
    $ = C(X, !0);
  P(X);
  var tt = D(X, 2);
  {
    var ut = jt => {
      var Ht = KPe(),
        _e = C(Ht, !0);
      P(Ht), Bt(() => at(_e, s.subtitle)), Z(jt, Ht)
    };
    At(tt, jt => {
      s.subtitle && jt(ut)
    })
  }
  var xt = D(tt, 2),
    lt = C(xt);
  lt.__click = () => {
    cy(t, -1)
  };
  var G = D(lt, 2);
  xo(G);
  var yt = D(G, 2);
  yt.__click = () => {
    cy(t)
  };
  var Lt = D(yt, 2);
  {
    var Dt = jt => {
      var Ht = JPe();
      Ht.__click = () => {
        t(y(z))
      }, Z(jt, Ht)
    };
    At(Lt, jt => {
      t() < y(z) && jt(Dt)
    })
  }
  P(xt);
  var St = D(xt, 2);
  let qt;
  var Vt = C(St);
  Vt.__click = async () => {
    try {
      Y(E, !0), await fn.purchase({
        id: s.productId,
        amount: t()
      }), mi.notification1.play(), s.onpurchasecompleted(t())
    } catch (jt) {
      Ne.error(jt.message)
    } finally {
      Y(E, !1)
    }
  };
  var Zt = C(Vt);
  {
    var Et = jt => {
      var Ht = QPe();
      Z(jt, Ht)
    };
    At(Zt, jt => {
      y(E) && jt(Et)
    })
  }
  var Ct = D(Zt, 2);
  kd(Ct, {
    class: "size-4"
  });
  var Wt = D(Ct);
  Mn(), P(Vt), P(St), P(k), Bt((jt, Ht, _e) => {
    at($, jt), yt.disabled = t() >= y(z), pr(St, "data-tip", Ht), qt = Gr(St, 1, "", null, qt, {
      tooltip: s.userDroplets < y(w)
    }), Vt.disabled = s.userDroplets < y(w) || y(E) || !t(), at(Wt, ` ${_e??""} `)
  }, [() => s.title(t()), () => Cd(), () => y(w).toLocaleString("en-US")]), M_(G, t), Z(l, k), rn()
}
ri(["click"]);
var eMe = $r('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function rMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = eMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var nMe = $r('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function f0(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = nMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var iMe = $r('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function oMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = iMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var sMe = $r('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function aMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = sMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var uMe = ft('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">âœ•</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  cMe = ft('<span class="center-absolute absolute"><!></span>'),
  lMe = ft('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function _Me(l, s) {
  en(s, !0);
  let t = $e(s, "open", 15),
    w = ee(null),
    z = ee(Qi({
      name: hy(),
      prev: 1e3,
      new: 1e5
    }));
  ti(() => {
    const de = zr => {
      zr.key === "Escape" && t(!1)
    };
    return document.addEventListener("keydown", de), () => document.removeEventListener("keydown", de)
  });
  const E = {
      id: 70,
      product: Ao.products[70]
    },
    k = {
      id: 80,
      product: Ao.products[80]
    },
    c = {
      product: Ao.products[120]
    };
  let R = ee(null),
    X = ee(null),
    $ = ee("");
  async function tt(de) {
    return y(R).showModal(), Y(X, Rf.withResolvers(), !0), Y($, de, !0), y(X).promise
  }
  var ut = lMe(),
    xt = xe(ut),
    lt = C(xt),
    G = C(lt);
  {
    var yt = de => {
      var zr = uMe(),
        er = C(zr),
        hr = C(er),
        Mr = C(hr);
      f0(Mr, {
        class: "size-8"
      });
      var Pr = D(Mr, 2),
        Or = C(Pr, !0);
      P(Pr);
      var jr = D(Pr, 2),
        Lr = C(jr);
      {
        let Be = ge(() => {
          var fe;
          return ((fe = ze.data) == null ? void 0 : fe.droplets) ?? 0
        });
        Jy(Lr, {
          get value() {
            return y(Be)
          }
        })
      }
      P(jr), Mn(2), P(hr), P(er), eo(er, () => BPe);
      var _n = D(er, 2),
        dr = C(_n),
        ct = C(dr),
        q = C(ct);
      rMe(q, {
        class: "size-5.5",
        filled: !0
      });
      var U = D(q, 2),
        Q = C(U, !0);
      P(U), P(ct);
      var nt = D(ct, 2),
        _t = C(nt, !0);
      P(nt);
      var Tt = D(nt, 2),
        Ft = C(Tt);
      {
        const Be = Me => {
          aMe(Me, {
            class: "text-primary size-26"
          })
        };
        let fe = ge(() => GE());
        Hy(Ft, {
          get productId() {
            return E.id
          },
          title: Me => C2({
            amount: E.product.items[0].amount * Me
          }),
          get subtitle() {
            return y(fe)
          },
          get unitPrice() {
            return E.product.price
          },
          get userDroplets() {
            return ze.data.droplets
          },
          onpurchasecompleted: async Me => {
            var qr, lr, Jt, Se;
            const cr = (lr = (qr = ze.data) == null ? void 0 : qr.charges) == null ? void 0 : lr.max;
            await ze.refresh();
            const Ge = (Se = (Jt = ze.data) == null ? void 0 : Jt.charges) == null ? void 0 : Se.max;
            cr !== void 0 && Ge !== void 0 && (Y(z, {
              name: hy(),
              prev: cr,
              new: Ge
            }, !0), y(w).show())
          },
          icon: Be,
          $$slots: {
            icon: !0
          }
        })
      }
      var zt = D(Ft, 2);
      {
        const Be = Me => {
          l0(Me, {
            class: "text-primary my-3 size-20"
          })
        };
        let fe = ge(() => _W());
        Hy(zt, {
          get productId() {
            return k.id
          },
          title: Me => N2({
            amount: k.product.items[0].amount * Me
          }),
          get subtitle() {
            return y(fe)
          },
          get unitPrice() {
            return k.product.price
          },
          get userDroplets() {
            return ze.data.droplets
          },
          onpurchasecompleted: async Me => {
            var Ge, qr, lr;
            const cr = (qr = (Ge = ze.data) == null ? void 0 : Ge.charges) == null ? void 0 : qr.count;
            await ze.refresh(), cr !== void 0 && (Y(z, {
              name: SV(),
              prev: Math.floor(cr),
              new: Math.floor(cr + k.product.items[0].amount * Me)
            }, !0), (lr = y(w)) == null || lr.show())
          },
          icon: Be,
          $$slots: {
            icon: !0
          }
        })
      }
      P(Tt), P(dr);
      var Nt = D(dr, 2),
        ie = C(Nt),
        mt = C(ie);
      zd(mt, {
        class: "size-5.5",
        filled: !0
      });
      var et = D(mt, 2),
        W = C(et, !0);
      P(et), P(ie);
      var vt = D(ie, 2),
        $t = C(vt),
        Pt = C($t),
        Gt = C(Pt),
        ae = C(Gt),
        ye = C(ae);
      Qy(ye, {
        get userId() {
          return ze.data.id
        },
        get level() {
          return ze.data.level
        },
        get pictureUrl() {
          return ze.data.picture
        }
      }), P(ae), P(Gt), P(Pt);
      var Te = D(Pt, 2),
        we = C(Te, !0);
      P(Te);
      var be = D(Te, 2),
        Ee = C(be, !0);
      P(be);
      var Qe = D(be, 2);
      let Yt;
      var je = C(Qe),
        Fe = C(je),
        Nr = C(Fe);
      kd(Nr, {
        class: "size-4"
      });
      var Ar = D(Nr);
      Mn(), P(Fe), P(je), P(Qe), P($t), P(vt), P(Nt);
      var Kt = D(Nt, 2),
        Oe = C(Kt);
      YPe(Oe, {
        promptUserConfirmation: tt
      }), P(Kt), P(_n), P(zr), Bt((Be, fe, Me, cr, Ge, qr, lr, Jt) => {
        at(Or, Be), at(Q, fe), at(_t, Me), at(W, cr), at(we, Ge), at(Ee, qr), pr(Qe, "data-tip", lr), Yt = Gr(Qe, 1, "", null, Yt, {
          tooltip: ze.data.droplets < c.product.price
        }), Fe.disabled = ze.data.droplets < c.product.price, at(Ar, ` ${Jt??""} `)
      }, [() => bv(), () => fj(), () => lA(), () => NG(), () => tH(), () => Uw(), () => Cd(), () => c.product.price.toLocaleString("en-US")]), vo(2, zr, () => is), Z(de, zr)
    };
    At(G, de => {
      ze.data && t() && de(yt)
    })
  }
  P(lt);
  var Lt = D(lt, 2),
    Dt = C(Lt),
    St = C(Dt, !0);
  P(Dt), P(Lt), P(xt), eo(xt, () => de => {
    cn(() => {
      t() ? de.show() : de.close()
    })
  });
  var qt = D(xt, 2),
    Vt = C(qt),
    Zt = C(Vt),
    Et = C(Zt),
    Ct = C(Et, !0);
  P(Et);
  var Wt = D(Et, 2),
    jt = C(Wt),
    Ht = C(jt),
    _e = D(Ht),
    Ut = C(_e);
  P(_e), P(jt);
  var Xt = D(jt, 2),
    me = C(Xt);
  oMe(me, {
    class: "size-5"
  }), P(Xt);
  var Ce = D(Xt, 2),
    Ve = C(Ce, !0);
  P(Ce), P(Wt);
  var Ie = D(Wt, 2),
    ne = C(Ie),
    Xe = C(ne),
    pe = D(Xe);
  Hl(pe, () => y(z).new, de => {
    var zr = cMe(),
      er = C(zr);
    hm(er, {}), P(zr), Z(de, zr)
  }), P(ne), P(Ie), P(Zt), P(Vt);
  var Ue = D(Vt, 2),
    Ae = C(Ue),
    He = C(Ae, !0);
  P(Ae), P(Ue), P(qt), os(qt, de => Y(w, de), () => y(w));
  var Tr = D(qt, 2),
    Ye = C(Tr),
    mr = C(Ye),
    se = C(mr, !0);
  P(mr);
  var ce = D(mr, 2),
    ur = C(ce);
  Sd(ur, () => Qz({
    country: y($)
  })), P(ce);
  var Ke = D(ce, 2),
    ve = C(Ke);
  ve.__click = () => {
    var de;
    (de = y(X)) == null || de.resolve(!1), y(R).close()
  };
  var _r = C(ve, !0);
  P(ve);
  var nr = D(ve, 2);
  nr.__click = () => {
    var de;
    (de = y(X)) == null || de.resolve(!0), y(R).close()
  };
  var gr = C(nr, !0);
  P(nr), P(Ke), P(Ye);
  var ir = D(Ye, 2),
    Ze = C(ir),
    or = C(Ze, !0);
  P(Ze), P(ir), P(Tr), os(Tr, de => Y(R, de), () => y(R)), Bt((de, zr, er, hr, Mr, Pr, Or) => {
    at(St, de), at(Ct, y(z).name), at(Ht, `${y(z).prev??""} `), at(Ut, `(+${y(z).new-y(z).prev})`), at(Ve, y(z).new), at(Xe, `${zr??""} `), at(He, er), at(se, hr), at(_r, Mr), at(gr, Pr), at(or, Or)
  }, [() => la(), () => la(), () => la(), () => h4(), () => C_(), () => cv(), () => la()]), jn("close", xt, () => t(!1)), Z(l, ut), rn()
}
ri(["click"]);
var hMe = $r('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function dMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = hMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var pMe = $r('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function fMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = pMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var mMe = $r('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function gMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = mMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var yMe = $r('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function vMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = yMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}
var bMe = $r('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function xMe(l, s) {
  let t = Ir(s, ["$$slots", "$$events", "$$legacy"]);
  var w = bMe();
  Er(w, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...t
  })), Z(l, w)
}

function wMe(l, s, t) {
  return l < s ? s : l > t ? t : l
}

function kMe(l, s) {
  const t = 10 ** s;
  return Math.round(l * t) / t
}
var TMe = ft('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  SMe = ft("<button><!></button>"),
  PMe = ft('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'),
  MMe = ft('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'),
  CMe = ft('<button class="btn btn-primary shadow-xl"> </button>'),
  IMe = ft('<div class="absolute -left-2 top-0 -translate-x-full translate-y-1/2 select-none"><!></div>'),
  zMe = ft('<div class="relative"><!> <!></div>'),
  AMe = ft('<button class="btn btn-square shadow-md"><!></button> <button class="btn btn-square relative shadow-md"><!></button>', 1),
  EMe = ft('<button title="Auto painter" class="btn btn-square shadow-md"><!></button>'),
  jMe = ft('<div class="flex flex-col items-center gap-3"><!> <button class="btn btn-square relative shadow-md"><!></button> <button class="btn btn-square shadow-md"><!></button> <!></div>'),
  LMe = ft('<div class="flex flex-col gap-3"><button><!></button></div>'),
  DMe = ft('<button class="btn btn-sm btn-circle"><!></button>'),
  RMe = ft('<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'),
  BMe = ft('<button class="btn btn-sm btn-circle"><!></button>'),
  FMe = ft('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
  OMe = ft('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'),
  qMe = ft('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'),
  NMe = ft("<span></span>"),
  VMe = ft('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'),
  UMe = ft('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'),
  ZMe = ft('<div class="pointer-events-none absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-lg sm:-translate-x-1/2 md:max-w-xl"><!></div>'),
  GMe = ft('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'),
  HMe = ft('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-1uha8ag"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function KCe(l, s) {
  en(s, !0);
  const t = Op,
    w = Ux,
    z = new Bo(w),
    E = t - .4,
    k = H0e(gi.url),
    c = k.season ?? uy;
  let R = ee(0);
  const X = new Map;
  let $ = ee(void 0),
    tt = ee(14.5),
    ut = ee(!1);
  const xt = ge(() => {
    var he;
    return ((he = ze.data) == null ? void 0 : he.id) === 401
  });
  let lt = ee(!1),
    G = ee("select-pixel"),
    yt = ee(Qi(k.select && k.pos ? {
      name: "pixelSelected",
      latLon: [k.pos.lat, k.pos.lng]
    } : {
      name: "mainMenu"
    }));
  ti(() => {
    qt().then(Vr => Y($, Vr)).catch(Vr => {
      Ne.error(tK(), {
        duration: 5e3
      }), console.error("Error setting up map:", Vr)
    });
    let he = [0, 0];

    function qe(Vr) {
      var Pn;
      if (y($) && y(tt) > t + 1) {
        const {
          lat: Gn,
          lng: Xn
        } = y($).unproject([Vr.clientX, Vr.clientY]), $n = z.latLonToPixels(Gn, Xn, t), On = Math.floor($n[0]), Ai = Math.floor($n[1]);
        if (he[0] !== On || he[1] !== Ai) {
          const Rr = z.latLonToPixelBoundsLatLon(Gn, Xn, t),
            wr = rm(Rr, !0);
          (Pn = y($).getSource(Et)) == null || Pn.setCoordinates(wr), he = [On, Ai]
        }
      }
    }
    return window.addEventListener("mousemove", qe), () => {
      var Vr;
      (Vr = y($)) == null || Vr.remove(), window.removeEventListener("mousemove", qe), St && clearInterval(St), Jp()
    }
  }), ha(() => [zo.theme], () => {
    if (y($)) {
      Dt = !1;
      const he = Lt(zo.theme);
      y($).setStyle(he)
    }
  });

  function Lt(he) {
    return `https://maps.wplace.live/styles/${he==="custom-winter"?"liberty":"fiord"}`
  }
  let Dt = !1,
    St;
  async function qt() {
    let he = k.pos ? {
      ...k.pos,
      zoom: y(tt)
    } : await L0e();
    k.zoom !== void 0 && (he.zoom = k.zoom), B0e(he) || (he = {
      zoom: he.zoom,
      ...wv.tokyo
    });
    const qe = await new Promise($n => {
        const On = new Yh.Map({
          style: Lt(zo.theme),
          center: he,
          zoom: he.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        On.touchZoomRotate.disableRotation(), On.on("styledata", Ai => {
          Dt || (zo.theme === "custom-winter" && (On.setLayoutProperty("poi_transit", "visibility", "none"), On.setLayoutProperty("poi_r20", "visibility", "none"), On.setLayoutProperty("poi_r7", "visibility", "none"), On.setLayoutProperty("poi_r1", "visibility", "none"), On.setLayoutProperty("building", "visibility", "none"), On.setLayoutProperty("building-3d", "visibility", "none"), On.setLayoutProperty("landuse_pitch", "visibility", "none"), On.setLayoutProperty("landuse_hospital", "visibility", "none"), On.setLayoutProperty("landuse_school", "visibility", "none"), On.setLayoutProperty("landuse_residential", "visibility", "none"), On.setLayoutProperty("waterway_tunnel", "visibility", "none"), On.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), Zt(On), Ht(), Dt = !0)
        }), On.on("style.load", () => {
          $n(On)
        })
      }),
      Vr = Ao.refreshIntervalMs;

    function Pn() {
      let $n = y(tt) > t + 1.5 ? Vr : 2.5 * Vr;
      try {
        document.visibilityState === "visible" && Zt(qe)
      } finally {
        setTimeout(Pn, $n)
      }
    }
    St = setTimeout(Pn, Vr), qe.on("load", () => {
      k.discordLinked && (Ne.success(HM()), gi.url.searchParams.delete("discord-linked"), pd(gi.url.toString())), k.twitchMigration && (Ne.success(Prt()), gi.url.searchParams.delete("twitch-migration"), pd(gi.url.toString()))
    });
    let Gn = y(tt);
    qe.on("zoom", () => {
      Y(tt, qe.getZoom(), !0);
      const $n = kMe(y(tt), 1);
      $n != Gn && (y(ne) && y(ne).setOpacity(Xe(Gn)), Gn = $n)
    });
    let Xn = "default";
    return qe.on("dragstart", () => {
      const $n = qe.getCanvas();
      Xn = $n.style.cursor, $n.style.cursor = "move"
    }), qe.on("dragend", () => {
      qe.getCanvas().style.cursor = Xn
    }), qe.on("mouseout", () => {
      _e()
    }), qe.on("click", async $n => {
      var xn;
      const On = $n.lngLat.lat,
        Ai = $n.lngLat.lng,
        Rr = [On, Ai];
      if (y(yt).name === "paintingPixel" || y(yt).name === "selectArea") return;
      if (y(yt).name === "selectHq") {
        y(yt).hq = Rr, (xn = y(pe)) == null || xn.clearAndPlace(Rr);
        return
      }
      const wr = qe.getZoom();
      if (wr < E) {
        Ne.info(Zst());
        return
      }
      sa({
        lat: On,
        lng: Ai
      }, wr), Y(yt, {
        name: "pixelSelected",
        latLon: Rr
      }, !0)
    }), qe
  }
  const Vt = "pixel-art-layer";

  function Zt(he) {
    const qe = window.innerWidth,
      Vr = `${Yy}/s${uy}/tiles/{x}/{y}.png`;
    if (X.clear(), !he.style) return;
    he.getSource(Vt) ? he.refreshTiles(Vt) : he.addSource(Vt, {
      type: "raster",
      tiles: [Vr],
      minzoom: t,
      maxzoom: t,
      tileSize: qe > 640 ? 550 : 400
    }), he.getLayer(Vt) || he.addLayer({
      id: Vt,
      type: "raster",
      source: Vt,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": y(me)
      }
    })
  }
  const Et = "pixel-hover",
    Ct = 1e-5,
    Wt = [
      [0, 0],
      [Ct, 0],
      [Ct, -Ct],
      [0, -Ct]
    ],
    jt = .4;
  async function Ht() {
    var he, qe, Vr, Pn;
    if (!((he = y($)) != null && he.getSource(Et))) {
      const Gn = Nv(await ad(E0e));
      (qe = y($)) == null || qe.addSource(Et, {
        type: "canvas",
        canvas: Gn,
        coordinates: Wt
      })
    }(Vr = y($)) != null && Vr.getLayer(Et) || (Pn = y($)) == null || Pn.addLayer({
      id: Et,
      type: "raster",
      source: Et,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": jt
      }
    })
  }

  function _e() {
    var he, qe;
    (qe = (he = y($)) == null ? void 0 : he.getSource(Et)) == null || qe.setCoordinates(Wt)
  }
  let Ut = ee(Qi(k.opaque ?? !0)),
    Xt = ee(!0),
    me = ge(() => y(Xt) ? y(Ut) ? 1 : .2 : 0);
  cn(() => {
    var he;
    (he = y($)) != null && he.getLayer(Vt) && y($).setPaintProperty(Vt, "raster-opacity", y(me))
  });
  let Ce = ee(void 0),
    Ve = ee(void 0),
    Ie = ee(void 0);
  ti(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(he => {
    he.state === "granted" && Y(Ie, navigator.geolocation.watchPosition(qe => {
      Y(Ce, qe)
    }, qe => {
      Y(Ve, qe)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    y(Ie) && navigator.geolocation.clearWatch(y(Ie))
  }));
  let ne = ee(void 0);
  ha(() => [y(Ce), y($)], () => {
    var he, qe;
    if (y(Ce) && y($)) {
      const Vr = {
          lat: y(Ce).coords.latitude,
          lng: y(Ce).coords.longitude
        },
        Pn = Xe(y(tt));
      if (!y(ne)) {
        const Gn = document.createElement("div");
        Gn.classList.add("maplibregl-user-location-dot"), Gn.classList.add("cursor-auto"), Y(ne, new Yh.Marker({
          element: Gn,
          opacity: Pn
        }).setLngLat(Vr).addTo(y($)))
      }(qe = (he = y(ne)) == null ? void 0 : he.setLngLat(Vr)) == null || qe.setOpacity(Pn)
    }
  });

  function Xe(he) {
    return he < t ? "1.0" : wMe((he - t) * .2, .5, 1).toFixed(2)
  }
  let pe = ee(void 0);
  cn(() => {
    var he;
    y($) && ((he = Io(() => y(pe))) == null || he.clear(), ad(my).then(qe => {
      Y(pe, new yy({
        id: "select-crosshair",
        map: y($),
        tileSize: w,
        zoom: t,
        img: qe,
        markerFn: () => {
          const Vr = new Yh.Marker({
            color: "#0069ff"
          });
          return Vr.addClassName("z-20"), Vr
        }
      }))
    }))
  });
  let Ue = ee(void 0);
  cn(() => {
    var he;
    y($) && ((he = Io(() => y(pe))) == null || he.clear(), ad(my).then(qe => {
      Y(Ue, new yy({
        id: "paint-crosshair",
        map: y($),
        tileSize: w,
        zoom: t,
        img: qe
      }))
    }))
  });
  let Ae = ee(!1),
    He = ee(Qi(gi.url)),
    Tr = ee(Qi({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    Ye = ee(!1);
  cn(() => {
    var he;
    Y(Ye, !!((he = ze.data) != null && he.needsPhoneVerification))
  });
  let mr = ee([]),
    se = ge(() => y(tt) < E ? "1.0" : y(tt) < E + 2 ? "0.5" : "0.3");
  cn(() => {
    var qe;
    const he = (qe = ze.data) == null ? void 0 : qe.favoriteLocations;
    if (he && y($)) {
      for (const Vr of Io(() => y(mr))) Vr.remove();
      Y(mr, he.map(Vr => {
        const Pn = document.createElement("div");
        Pn.classList.add("text-yellow-400"), Pn.classList.add("cursor-pointer"), Pn.classList.add("z-10"), Pn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Gn = {
          lat: Vr.latitude,
          lng: Vr.longitude
        };
        return Pn.addEventListener("click", $n => {
          $n.stopPropagation(), ce([Vr.latitude, Vr.longitude])
        }), new Yh.Marker({
          element: Pn,
          opacity: y(se)
        }).setLngLat(Gn).addTo(y($))
      }))
    }
  });

  function ce(he) {
    var Vr;
    const qe = {
      lat: he[0],
      lng: he[1]
    };
    (Vr = y($)) == null || Vr.flyTo({
      center: qe,
      zoom: Math.max(y(tt), 15)
    }), sa(qe, y(tt)), Y(yt, {
      name: "pixelSelected",
      latLon: [qe.lat, qe.lng]
    }, !0)
  }
  cn(() => {
    if (y(yt).name === "paintingPixel")
      for (const he of y(mr)) he.addClassName("hidden");
    else
      for (const he of y(mr)) he.removeClassName("hidden"), he.setOpacity(y(se))
  });
  let ur = Number.MAX_VALUE;
  cn(() => {
    if (ze.charges !== void 0 && ze.data) {
      const he = ze.data.charges.max,
        qe = ze.charges;
      ur < he && qe >= he && mi.notification1.play(), ur = ze.charges
    }
  });
  let Ke = ee(!1),
    ve = Date.now();
  ti(() => {
    const he = G0e(),
      qe = () => {
        var Pn;
        if (!document.hidden && Date.now() - ve > 30 * wc.min) {
          if (he) {
            const Xn = (Pn = y($)) == null ? void 0 : Pn.getCenter();
            Xn && sa(Xn, y(tt)), window.location.replace(gi.url.origin)
          } else ze.refresh();
          ve = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", qe), () => document.removeEventListener("visibilitychange", qe)
  }), ti(() => {
    function he() {
      fn.online = !0
    }
    window.addEventListener("online", he);

    function qe() {
      fn.online = !1
    }
    return window.addEventListener("offline", qe), () => {
      window.removeEventListener("online", he), window.removeEventListener("offline", qe)
    }
  }), cn(() => {
    if (!fn.online) {
      const he = setInterval(() => {
        fn.health().then(() => {
          fn.online = !0, !ze.data && !ze.loading && ze.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(he)
      }
    }
  }), ti(() => {
    if (!navigator.serviceWorker) {
      setTimeout(() => {
        console.log("Setting up service worker message listener", navigator.serviceWorker), Ne.warning(xQ(), {
          duration: 5e3
        })
      });
      return
    }

    function he(qe) {
      qe.data.type && y($) && Zt(y($))
    }
    return navigator.serviceWorker.addEventListener("message", he), () => {
      navigator.serviceWorker.removeEventListener("message", he)
    }
  });
  let _r = ee(!1),
    nr = ee("report-user"),
    gr = ee(void 0),
    ir = ee(void 0),
    Ze = ee(void 0),
    or = ee(0),
    de = ee(void 0);
  cn(() => {
    y(_r) || (Y(de, void 0), Y(ir, void 0), Y(gr, void 0), Y(Ze, void 0))
  });

  function zr() {
    Y(yt, {
      name: "mainMenu"
    }, !0), _e()
  }
  let er = !1,
    hr = ee(!1),
    Mr = ee(!1),
    Pr = ee(!1),
    Or = ee(!1),
    jr = ee(!1),
    Lr = ee(!1),
    _n = ee(!!k.newUser),
    dr = ee(!1),
    ct = ee(!!k.alliance),
    q = ee(!1);
  const U = ge(() => y(hr) || y(Mr) || y(Pr) || y(Or) || y(jr) || y(Lr) || y(_n) || y(dr) || y(ct) || y(q));
  var Q = HMe();
  jn("keydown", Oa, async he => {
    if (!y(U) && !(he.target instanceof HTMLInputElement || he.target instanceof HTMLTextAreaElement) && !he.ctrlKey) switch (he.code) {
      case "KeyC":
        if (!ze.hasAnyPermission(Ri.tools.selectArea) || y(yt).name === "paintingPixel" || he.repeat) return;
        zr(), await Ff(), Y(yt, {
          name: "selectArea"
        }, !0);
        break
    }
  }), Ax("1uha8ag", he => {
    var qe = TMe();
    Mn(6), Ix(() => {
      zx.title = "Wplace - Paint the world"
    }), Z(he, qe)
  });
  var nt = xe(Q);
  {
    const he = Rr => {
        var wr = SMe();
        wr.__click = () => {
          Y(Ut, !y(Ut))
        };
        var xn = C(wr);
        {
          let qn = ge(() => !y(Ut));
          _0(xn, {
            class: "size-5",
            get filled() {
              return y(qn)
            }
          })
        }
        P(wr), Bt(qn => {
          pr(wr, "title", qn), Gr(wr, 1, qa({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": y(Ut),
            "btn-primary btn-soft": !y(Ut)
          }))
        }, [() => xv()]), Z(Rr, wr)
      },
      qe = Rr => {
        var wr = MMe();
        wr.__click = async () => {
          var xr;
          y(Ce) || Y(Ce, await new Promise((vn, Ur) => {
            navigator.geolocation.getCurrentPosition(Jr => {
              vn(Jr)
            }, Jr => {
              Ur(Jr)
            })
          })), y(Ce) && (sa({
            lat: y(Ce).coords.latitude,
            lng: y(Ce).coords.longitude
          }, y(tt)), (xr = y($)) == null || xr.flyTo({
            center: {
              lat: y(Ce).coords.latitude,
              lng: y(Ce).coords.longitude
            },
            zoom: 16.5
          }))
        };
        var xn = C(wr);
        {
          var qn = xr => {
              gMe(xr, {
                class: "size-5.5 fill-blue-800"
              })
            },
            wn = xr => {
              var vn = PMe(),
                Ur = C(vn);
              fMe(Ur, {
                class: "size-5.5 fill-red-400"
              }), Mn(2), P(vn), Z(xr, vn)
            };
          At(xn, xr => {
            y(Ce) ? xr(qn) : xr(wn, !1)
          })
        }
        P(wr), Bt(xr => pr(wr, "title", xr), [() => GB()]), Z(Rr, wr)
      };
    var _t = D(C(nt), 2);
    let Vr;
    var Tt = C(_t);
    let Pn;
    var Ft = C(Tt);
    {
      var zt = Rr => {
          var wr = CMe();
          wr.__click = () => {
            var qn;
            Y(Or, !0), y($) && sa((qn = y($)) == null ? void 0 : qn.getCenter(), y(tt))
          };
          var xn = C(wr, !0);
          P(wr), Bt(qn => at(xn, qn), [() => _D()]), Z(Rr, wr)
        },
        Nt = Rr => {
          var wr = kr(),
            xn = xe(wr);
          {
            var qn = wn => {
              var xr = zMe(),
                vn = C(xr);
              {
                var Ur = Cn => {
                  var kn = IMe(),
                    sn = C(kn);
                  lv(sn, {
                    get role() {
                      return ze.data.role
                    }
                  }), P(kn), Z(Cn, kn)
                };
                At(vn, Cn => {
                  var kn;
                  (kn = ze.data) != null && kn.role && ze.data.role !== "user" && Cn(Ur)
                })
              }
              var Jr = D(vn, 2);
              rSe(Jr, {
                get user() {
                  return ze
                },
                onlogout: () => {
                  Y(yt, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  Y(hr, !0)
                },
                onnotificationclick: () => {
                  Y(Mr, !0)
                },
                ontogglepixelarts: Cn => {
                  Y(Xt, Cn, !0)
                }
              }), P(xr), vo(3, xr, () => is, () => ({
                duration: 150
              })), Z(wn, xr)
            };
            At(xn, wn => {
              ze.data && y($) && y(yt).name !== "paintingPixel" && wn(qn)
            }, !0)
          }
          Z(Rr, wr)
        };
      At(Ft, Rr => {
        !ze.loading && !ze.data ? Rr(zt) : Rr(Nt, !1)
      })
    }
    var ie = D(Ft, 2);
    {
      var mt = Rr => {
          var wr = jMe(),
            xn = C(wr);
          {
            var qn = kn => {
              var sn = AMe(),
                Bn = xe(sn);
              Bn.__click = () => {
                var Wn;
                Y(jr, !0);
                const Ei = (Wn = y($)) == null ? void 0 : Wn.getCenter();
                Ei && sa(Ei, y(tt))
              };
              var Vn = C(Bn);
              f0(Vn, {
                class: "size-5"
              }), P(Bn);
              var bn = D(Bn, 2);
              bn.__click = () => {
                Y(ct, !0)
              };
              var In = C(bn);
              Ad(In, {
                class: "size-5"
              }), P(bn), Bt((Ei, Wn) => {
                pr(Bn, "title", Ei), pr(bn, "title", Wn)
              }, [() => bv(), () => Md()]), Z(kn, sn)
            };
            At(xn, kn => {
              ze.data && kn(qn)
            })
          }
          var wn = D(xn, 2);
          wn.__click = () => {
            Y(Lr, !0)
          };
          var xr = C(wn);
          a0(xr, {
            class: "size-5"
          }), P(wn);
          var vn = D(wn, 2);
          vn.__click = () => {
            Y(Pr, !0)
          };
          var Ur = C(vn);
          xMe(Ur, {
            class: "size-5"
          }), P(vn);
          var Jr = D(vn, 2);
          {
            var Cn = kn => {
              var sn = EMe();
              sn.__click = () => {
                y($) && Y(yt, {
                  name: "adminAutoPaint"
                }, !0)
              };
              var Bn = C(sn);
              vu(Bn, {
                class: "size-5"
              }), P(sn), Z(kn, sn)
            };
            At(Jr, kn => {
              ze.hasPermission(Ri.tools.autoPainter) && kn(Cn)
            })
          }
          P(wr), Bt((kn, sn) => {
            pr(wn, "title", kn), pr(vn, "title", sn)
          }, [() => Xf(), () => nv()]), vo(3, wr, () => is, () => ({
            duration: 150
          })), Z(Rr, wr)
        },
        et = Rr => {
          var wr = kr(),
            xn = xe(wr);
          {
            var qn = wn => {
              var xr = LMe(),
                vn = C(xr);
              let Ur;
              vn.__click = () => {
                Y(ut, !y(ut))
              };
              var Jr = C(vn);
              {
                var Cn = sn => {
                    jf(sn, {
                      class: "size-5"
                    })
                  },
                  kn = sn => {
                    vd(sn, {
                      class: "size-5"
                    })
                  };
                At(Jr, sn => {
                  y(ut) ? sn(Cn) : sn(kn, !1)
                })
              }
              P(vn), P(xr), Bt(sn => {
                pr(vn, "title", sn), Ur = Gr(vn, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, Ur, {
                  "btn-primary": y(ut)
                })
              }, [() => y(ut) ? cit() : JL()]), vo(1, xr, () => is, () => ({
                delay: 150,
                duration: 150
              })), Z(wn, xr)
            };
            At(xn, wn => {
              y($) && y(yt).name === "paintingPixel" && wn(qn)
            }, !0)
          }
          Z(Rr, wr)
        };
      At(ie, Rr => {
        y($) && y(yt).name !== "paintingPixel" ? Rr(mt) : Rr(et, !1)
      })
    }
    P(Tt), P(_t);
    var W = D(_t, 2);
    let Gn;
    var vt = C(W);
    {
      var $t = Rr => {
        var wr = DMe();
        wr.__click = () => {
          Y(dr, !0)
        };
        var xn = C(wr);
        dMe(xn, {
          class: "size-3.5"
        }), P(wr), Bt(qn => pr(wr, "title", qn), [() => i8()]), Z(Rr, wr)
      };
      At(vt, Rr => {
        y(yt).name !== "paintingPixel" && Rr($t)
      })
    }
    var Pt = D(vt, 2),
      Gt = C(Pt);
    Gt.__click = () => {
      var Rr;
      (Rr = y($)) == null || Rr.zoomIn()
    };
    var ae = D(Gt, 2);
    ae.__click = () => {
      var Rr;
      (Rr = y($)) == null || Rr.zoomOut()
    }, P(Pt);
    var ye = D(Pt, 2);
    {
      var Te = Rr => {
        var wr = RMe(),
          xn = D(C(wr), 2);
        xn.__click = () => {
          Y(yt, {
            name: "selectArea"
          }, !0)
        };
        var qn = C(xn);
        Df(qn, {
          class: "size-4"
        }), P(xn), P(wr), Z(Rr, wr)
      };
      At(ye, Rr => {
        y(yt).name !== "paintingPixel" && ze.hasAnyPermission(Ri.tools.selectArea) && Rr(Te)
      })
    }
    var we = D(ye, 2);
    {
      var be = Rr => {
        var wr = BMe(),
          xn = C(wr);
        d0(xn, {
          class: "size-4",
          onclick: () => {
            Y(lt, !y(lt))
          }
        }), P(wr), Bt(qn => pr(wr, "title", qn), [() => x6()]), Z(Rr, wr)
      };
      At(we, Rr => {
        y(xt) && Rr(be)
      })
    }
    var Ee = D(we, 2);
    {
      var Qe = Rr => {
        var wr = FMe();
        wr.__click = () => {
          window.location.replace(gi.url.origin)
        };
        var xn = C(wr);
        S1(xn, {
          class: "size-3"
        }), P(wr), Bt(qn => pr(wr, "title", qn), [() => M1()]), Z(Rr, wr)
      };
      At(Ee, Rr => {
        y(yt).name !== "paintingPixel" && Rr(Qe)
      })
    }
    P(W);
    var Yt = D(W, 2);
    let Xn;
    var je = C(Yt);
    {
      var Fe = Rr => {
        var wr = OMe(),
          xn = C(wr);
        P1(xn, {
          class: "size-5"
        });
        var qn = D(xn);
        P(wr), Bt(wn => at(qn, ` ${wn??""}`), [() => rN()]), vo(1, wr, () => is, () => ({
          duration: 1e3
        })), vo(2, wr, () => is), Z(Rr, wr)
      };
      At(je, Rr => {
        fn.online || Rr(Fe)
      })
    }
    var Nr = D(je, 2);
    {
      var Ar = Rr => {
        var wr = qMe();
        wr.__click = () => {
          var wn;
          (wn = y($)) == null || wn.flyTo({
            center: y($).getCenter(),
            zoom: t
          })
        };
        var xn = C(wr);
        vMe(xn, {
          class: "size-5"
        });
        var qn = D(xn);
        P(wr), Bt(wn => at(qn, ` ${wn??""}`), [() => Iat()]), vo(3, wr, () => is, () => ({
          duration: 300
        })), Z(Rr, wr)
      };
      At(Nr, Rr => {
        y(tt) < E && Rr(Ar)
      })
    }
    P(Yt);
    var Kt = D(Yt, 2);
    let $n;
    var Oe = C(Kt);
    he(Oe), P(Kt);
    var Be = D(Kt, 2);
    let On;
    var fe = C(Be);
    {
      var Me = Rr => {
          {
            let wr = ge(() => y(R) - 96 - 32);
            c0(Rr, {
              class: "z-30",
              get maxWidth() {
                return y(wr)
              },
              onclick: () => {
                var xn;
                (xn = ze.data) != null && xn.needsPhoneVerification ? (Y(Ye, !0), Ne.warning(dy())) : ze.charges !== void 0 && ze.charges < 1 ? Ne.warning(N5e, {
                  icon: Wl
                }) : y($) && ze.data ? (mi.smallDropplet.play(), Y(yt, {
                  name: "paintingPixel"
                }, !0)) : (Y(Or, !0), y($) && sa(y($).getCenter(), y(tt)))
              },
              get disabled() {
                return ze.loading
              },
              get loading() {
                return ze.loading
              },
              get charges() {
                return ze.charges
              }
            })
          }
        },
        cr = Rr => {
          var wr = NMe();
          Z(Rr, wr)
        };
      At(fe, Rr => {
        y(yt).name === "mainMenu" ? Rr(Me) : Rr(cr, !1)
      })
    }
    P(Be);
    var Ge = D(Be, 2);
    let Ai;
    var qr = C(Ge);
    qe(qr), P(Ge);
    var lr = D(Ge, 2);
    {
      var Jt = Rr => {
        var wr = kr(),
          xn = xe(wr);
        {
          var qn = xr => {
              var vn = VMe(),
                Ur = C(vn),
                Jr = C(Ur);
              RPe(Jr, {
                get latLon() {
                  return y(yt).latLon
                },
                get map() {
                  return y($)
                },
                get crosshair() {
                  return y(pe)
                },
                get pixelInfoCache() {
                  return X
                },
                get season() {
                  return c
                },
                get tileSize() {
                  return w
                },
                get pixelArtZoom() {
                  return t
                },
                get zoom() {
                  return y(tt)
                },
                get opaquePixelArt() {
                  return y(Ut)
                },
                onclose: () => Y(yt, {
                  name: "mainMenu"
                }, !0),
                onclickshare: Cn => {
                  Y(He, Cn, !0), Y(Ae, !0)
                },
                onclickpaint: ([Cn, kn]) => {
                  var Bn, Vn, bn;
                  if (!ze.data) {
                    Y(Or, !0);
                    return
                  }
                  if ((Bn = ze.data) != null && Bn.needsPhoneVerification) {
                    Y(Ye, !0), Ne.warning(dy());
                    return
                  }
                  if (ze.charges !== void 0 && ze.charges < 1) {
                    Ne.warning(Ast());
                    return
                  }
                  const sn = nm(z.latLonToPixelBoundsLatLon(Cn, kn, t));
                  (Vn = y($)) == null || Vn.flyTo({
                    center: {
                      lat: sn[0],
                      lon: sn[1]
                    }
                  }), Y(yt, {
                    name: "paintingPixel",
                    clickedLatLon: [Cn, kn]
                  }, !0), (bn = y(pe)) == null || bn.clear()
                },
                onclickregion: Cn => {
                  Y(Tr, Cn, !0), Y(q, !0)
                },
                onclickmodaction: (Cn, kn, sn, Bn) => {
                  var In, Ei, Wn;
                  (In = y($)) == null || In.setZoom(Math.max(y(tt), t + 3.5));
                  const Vn = z.latLonToPixelBoundsLatLon(sn[0], sn[1], t);
                  if ((Ei = y($)) == null || Ei.setCenter({
                      lat: Vn.min[0],
                      lng: (Vn.max[1] + Vn.min[1]) / 2
                    }), !(Cn != null && Cn.paintedBy)) {
                    Ne.error(ly());
                    return
                  }
                  const bn = Cn.paintedBy;
                  Y(gr, kn, !0), Y(ir, [{
                    id: bn.id,
                    name: bn.name,
                    picture: bn.picture,
                    allianceId: bn.allianceId ?? void 0,
                    allianceName: bn.allianceName ?? void 0,
                    timedOut: bn.timedOut,
                    banned: bn.banned
                  }], !0), Y(Ze, sn, !0), Y(or, ((Wn = y($)) == null ? void 0 : Wn.getZoom()) ?? 0, !0), Y(nr, Bn, !0), Y(de, void 0), Y(_r, !0), Y(G, "select-pixel")
                }
              }), P(Ur), P(vn), vo(3, Ur, () => rd, () => ({
                duration: 100
              })), Z(xr, vn)
            },
            wn = xr => {
              var vn = kr(),
                Ur = xe(vn);
              {
                var Jr = kn => {
                    var sn = UMe(),
                      Bn = C(sn),
                      Vn = C(Bn);
                    X3e(Vn, {
                      get map() {
                        return y($)
                      },
                      get clickedLatLon() {
                        return y(yt).clickedLatLon
                      },
                      get tileSize() {
                        return w
                      },
                      get tileZoom() {
                        return t
                      },
                      get season() {
                        return c
                      },
                      get zoom() {
                        return y(tt)
                      },
                      get crosshair() {
                        return y(Ue)
                      },
                      refreshPixelArt: () => y($) && Zt(y($)),
                      hidePixelHover: _e,
                      hoverLayerId: Et,
                      onclose: () => {
                        Y(yt, {
                          name: "mainMenu"
                        }, !0), _e()
                      },
                      get screenLocked() {
                        return y(ut)
                      },
                      set screenLocked(bn) {
                        Y(ut, bn, !0)
                      },
                      get opaquePixelArt() {
                        return y(Ut)
                      },
                      set opaquePixelArt(bn) {
                        Y(Ut, bn, !0)
                      }
                    }), P(Bn), P(sn), vo(3, Bn, () => rd, () => ({
                      duration: 100
                    })), Z(kn, sn)
                  },
                  Cn = kn => {
                    var sn = kr(),
                      Bn = xe(sn);
                    {
                      var Vn = In => {
                          var Ei = ZMe(),
                            Wn = C(Ei);
                          sPe(Wn, {
                            get map() {
                              return y($)
                            },
                            get tileSize() {
                              return w
                            },
                            get pixelArtZoom() {
                              return Op
                            },
                            get season() {
                              return c
                            },
                            get crosshair() {
                              return y(Ue)
                            },
                            onmodaction: ki => {
                              var ji;
                              const {
                                targets: yi,
                                image: Wi,
                                latLon: $i,
                                zoom: Yn,
                                action: ai,
                                onSuccess: pi
                              } = ki;
                              if (!yi || yi.length === 0) {
                                Ne.error(ly());
                                return
                              }
                              Y(gr, Wi, !0), Y(ir, yi, !0), Y(Ze, $i, !0), Y(or, Yn ?? ((ji = y($)) == null ? void 0 : ji.getZoom()) ?? 0, !0), Y(nr, ai, !0), Y(de, {
                                onSuccess: pi
                              }, !0), Y(_r, !0), Y(G, "select-area")
                            },
                            onclose: zr
                          }), P(Ei), Z(In, Ei)
                        },
                        bn = In => {
                          var Ei = kr(),
                            Wn = xe(Ei);
                          {
                            var ki = Wi => {
                                y1e(Wi, {
                                  get map() {
                                    return y($)
                                  },
                                  get tileSize() {
                                    return w
                                  },
                                  get tileZoom() {
                                    return t
                                  },
                                  get season() {
                                    return c
                                  },
                                  refreshPixelArt: () => y($) && Zt(y($)),
                                  onclose: () => {
                                    Y(yt, {
                                      name: "mainMenu"
                                    }, !0)
                                  }
                                })
                              },
                              yi = Wi => {
                                var $i = kr(),
                                  Yn = xe($i);
                                {
                                  var ai = pi => {
                                    var ji = GMe(),
                                      Sn = C(ji),
                                      jo = C(Sn),
                                      pn = C(jo),
                                      mn = C(pn),
                                      Ko = C(mn);
                                    h0(Ko, {
                                      class: "inline size-4"
                                    });
                                    var En = D(Ko);
                                    P(mn);
                                    var wo = D(mn, 2);
                                    wo.__click = () => {
                                      Y(yt, {
                                        name: "mainMenu"
                                      }, !0)
                                    };
                                    var ro = C(wo);
                                    pa(ro, {
                                      class: "size-4"
                                    }), P(wo), P(pn);
                                    var Oo = D(pn, 2),
                                      ko = C(Oo);
                                    ko.__click = async () => {
                                      var Lo;
                                      if (y(yt).name === "selectHq") {
                                        const Qo = y(yt).hq;
                                        if (Qo) try {
                                          Y(Ke, !0), await fn.updateAllianceHeadquarters(Qo[0], Qo[1]), (Lo = y(pe)) == null || Lo.clear(), Y(ct, !0), Y(yt, {
                                            name: "mainMenu"
                                          }, !0)
                                        } catch (Ts) {
                                          Ne.error(Ts.message)
                                        } finally {
                                          Y(Ke, !1)
                                        }
                                      }
                                    };
                                    var Jo = C(ko);
                                    p0(Jo, {
                                      class: "size-6"
                                    }), P(ko), P(Oo), P(jo), P(Sn), P(ji), Bt(Lo => {
                                      at(En, ` ${Lo??""}`), ko.disabled = y(yt).hq === void 0 || y(Ke)
                                    }, [() => CY()]), vo(3, Sn, () => rd, () => ({
                                      duration: 100
                                    })), Z(pi, ji)
                                  };
                                  At(Yn, pi => {
                                    y(yt).name === "selectHq" && pi(ai)
                                  }, !0)
                                }
                                Z(Wi, $i)
                              };
                            At(Wn, Wi => {
                              y(yt).name === "adminAutoPaint" && y($) ? Wi(ki) : Wi(yi, !1)
                            }, !0)
                          }
                          Z(In, Ei)
                        };
                      At(Bn, In => {
                        y(yt).name === "selectArea" ? In(Vn) : In(bn, !1)
                      }, !0)
                    }
                    Z(kn, sn)
                  };
                At(Ur, kn => {
                  y(yt).name === "paintingPixel" && y(Ue) ? kn(Jr) : kn(Cn, !1)
                }, !0)
              }
              Z(xr, vn)
            };
          At(xn, xr => {
            y(yt).name === "pixelSelected" && y(pe) ? xr(qn) : xr(wn, !1)
          })
        }
        Z(Rr, wr)
      };
      At(lr, Rr => {
        y($) && Rr(Jt)
      })
    }
    P(nt), Bt((Rr, wr) => {
      Vr = Gr(_t, 1, "absolute right-2 top-2 z-30", null, Vr, {
        hidden: y(lt)
      }), Pn = Gr(Tt, 1, "flex flex-col gap-4", null, Pn, {
        "items-end": !ze.data,
        "items-center": ze.data
      }), Gn = Gr(W, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Gn, {
        hidden: y(lt)
      }), pr(Gt, "title", Rr), pr(ae, "title", wr), Xn = Gr(Yt, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Xn, {
        hidden: y(lt)
      }), $n = Gr(Kt, 1, "absolute bottom-3 left-3 z-30", null, $n, {
        hidden: y(lt)
      }), On = Gr(Be, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, On, {
        hidden: y(lt)
      }), Ai = Gr(Ge, 1, "absolute bottom-3 right-3 z-30", null, Ai, {
        hidden: y(lt)
      })
    }, [() => mat(), () => Vat()])
  }
  var Se = D(nt, 2);
  O5e(Se, {
    get open() {
      return y(Or)
    },
    set open(he) {
      Y(Or, he, !0)
    }
  });
  var rr = D(Se, 2);
  _Me(rr, {
    get open() {
      return y(jr)
    },
    set open(he) {
      Y(jr, he, !0)
    }
  });
  var Le = D(rr, 2);
  e2e(Le, {
    get open() {
      return y(_n)
    },
    set open(he) {
      Y(_n, he, !0)
    }
  });
  var sr = D(Le, 2);
  v2e(sr, {
    get open() {
      return y(dr)
    },
    set open(he) {
      Y(dr, he, !0)
    }
  });
  var De = D(sr, 2);
  R5e(De, {
    onvisitclick: he => {
      var qe;
      (qe = y($)) == null || qe.flyTo({
        center: he,
        zoom: Op + 1
      }), sa(he, y(tt)), O0e.push({
        pos: he,
        zoom: y(tt)
      }), Y(Lr, !1)
    },
    get open() {
      return y(Lr)
    },
    set open(he) {
      Y(Lr, he, !0)
    }
  });
  var Cr = D(De, 2);
  mSe(Cr, {
    get region() {
      return y(Tr)
    },
    get open() {
      return y(q)
    },
    set open(he) {
      Y(q, he, !0)
    }
  });
  var on = D(Cr, 2);
  Qx(on, {
    get open() {
      return zo.dropletsDialogOpen
    },
    set open(he) {
      zo.dropletsDialogOpen = he
    }
  });
  var ln = D(on, 2);
  {
    var Br = he => {
      Fwe(he, {
        onhqchange: () => {
          Y(yt, {
            name: "selectHq"
          }, !0), Y(ct, !1)
        },
        onhqclick: qe => {
          var Vr;
          (Vr = y($)) == null || Vr.flyTo({
            center: qe,
            zoom: Math.max(y(tt), 15)
          }), Y(yt, {
            name: "pixelSelected",
            latLon: [qe.lat, qe.lng]
          }, !0), Y(ct, !1)
        },
        onlastpixelclick: qe => {
          var Vr;
          (Vr = y($)) == null || Vr.flyTo({
            center: qe,
            zoom: Math.max(y(tt), 15)
          }), Y(yt, {
            name: "pixelSelected",
            latLon: [qe.lat, qe.lng]
          }, !0), Y(ct, !1)
        },
        get open() {
          return y(ct)
        },
        set open(qe) {
          Y(ct, qe, !0)
        }
      })
    };
    At(ln, he => {
      y($) && he(Br)
    })
  }
  var Dr = D(ln, 2);
  {
    var un = he => {
      Xwe(he, {
        get url() {
          return y(He)
        },
        get map() {
          return y($)
        },
        hideHover: () => {
          var qe, Vr;
          (qe = y($)) == null || qe.setPaintProperty(Et, "raster-opacity", 0), (Vr = y(pe)) == null || Vr.setCanvasOpacity(0)
        },
        showHover: () => {
          var qe, Vr;
          (qe = y($)) == null || qe.setPaintProperty(Et, "raster-opacity", jt), (Vr = y(pe)) == null || Vr.setCanvasOpacity(1)
        },
        get open() {
          return y(Ae)
        },
        set open(qe) {
          Y(Ae, qe, !0)
        }
      })
    };
    At(Dr, he => {
      y($) && he(un)
    })
  }
  var Fn = D(Dr, 2);
  {
    var Rn = he => {
      _1(he, {
        get image() {
          return y(gr)
        },
        get targets() {
          return y(ir)
        },
        get latLon() {
          return y(Ze)
        },
        get zoom() {
          return y(or)
        },
        get action() {
          return y(nr)
        },
        onsuccess: () => {
          var qe, Vr;
          (Vr = (qe = y(de)) == null ? void 0 : qe.onSuccess) == null || Vr.call(qe)
        },
        get origin() {
          return y(G)
        },
        get open() {
          return y(_r)
        },
        set open(qe) {
          Y(_r, qe, !0)
        }
      })
    };
    At(Fn, he => {
      y(ir) && y(ir).length > 0 && y(gr) && y(Ze) && he(Rn)
    })
  }
  var Kr = D(Fn, 2);
  {
    var Hr = he => {
      K3e(he, {
        get userData() {
          return ze.data
        },
        get open() {
          return y(hr)
        },
        set open(qe) {
          Y(hr, qe, !0)
        }
      })
    };
    At(Kr, he => {
      ze.data && he(Hr)
    })
  }
  var An = D(Kr, 2);
  s3e(An, {
    get open() {
      return y(Mr)
    },
    set open(he) {
      Y(Mr, he, !0)
    }
  });
  var Hi = D(An, 2);
  {
    var Fi = he => {
      ASe(he, {
        get map() {
          return y($)
        },
        get tileSize() {
          return w
        },
        get season() {
          return c
        },
        get tileZoom() {
          return t
        },
        get open() {
          return y(Pr)
        },
        set open(qe) {
          Y(Pr, qe, !0)
        }
      })
    };
    At(Hi, he => {
      y($) && he(Fi)
    })
  }
  var Ci = D(Hi, 2);
  At(Ci, he => {
    y($)
  }), I_("innerWidth", he => Y(R, he, !0)), Z(l, Q), rn()
}
ri(["click"]);
export {
  KCe as component
};