var Ux = Object.defineProperty;
var Zx = Object.getPrototypeOf;
var Gx = Reflect.get;
var Cv = _ => {
  throw TypeError(_)
};
var $x = (_, o, f) => o in _ ? Ux(_, o, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: f
}) : _[o] = f;
var Cr = (_, o, f) => $x(_, typeof o != "symbol" ? o + "" : o, f),
  lm = (_, o, f) => o.has(_) || Cv("Cannot " + f);
var Xe = (_, o, f) => (lm(_, o, "read from private field"), f ? f.call(_) : o.get(_)),
  Pr = (_, o, f) => o.has(_) ? Cv("Cannot add the same private member more than once") : o instanceof WeakSet ? o.add(_) : o.set(_, f),
  Hi = (_, o, f, x) => (lm(_, o, "write to private field"), x ? x.call(_, f) : o.set(_, f), f),
  Nr = (_, o, f) => (lm(_, o, "access private method"), f);
var Pv = (_, o, f) => Gx(Zx(_), f, o);
import "../chunks/CoyfYV77.js";
import {
  o as Dn,
  s as ai
} from "../chunks/CeSVFyiR.js";
import {
  ac as Hx,
  bm as Wx,
  bB as Xx,
  bo as Yx,
  bC as Kx,
  aY as Jx,
  bD as Qx,
  l as Qe,
  bE as Iv,
  aa as eb,
  g as y,
  o as te,
  a_ as $u,
  m as Si,
  k as Rn,
  p as zr,
  f as me,
  d as M,
  r as P,
  s as q,
  u as ct,
  n as bn,
  t as je,
  v as Un,
  b as G,
  c as Lr,
  D as Zr,
  z as Dr,
  bz as eh,
  C as s_,
  F as yl,
  w as Jt,
  a as gt,
  q as ji,
  aF as tb,
  aE as Mv,
  aG as rb,
  M as g0,
  bF as _o,
  x as oa,
  bG as v0,
  by as l_,
  e as nb,
  $ as ib
} from "../chunks/q9bO_DSU.js";
import {
  s as le,
  c as y0
} from "../chunks/Cmtfxv8v.js";
import {
  i as Ae
} from "../chunks/BmdGBhaI.js";
import {
  h as ab
} from "../chunks/-orGpXrW.js";
import {
  r as Ba,
  e as yi,
  a as Or,
  g as x0,
  d as cr,
  s as mr,
  f as Oc,
  h as Qu,
  c as ls,
  i as Av
} from "../chunks/CqluXB0O.js";
import {
  a as _l,
  t as aa
} from "../chunks/CMZ1WONP.js";
import {
  g as Ep,
  b as ob
} from "../chunks/BlGBfRuM.js";
import {
  p as ui
} from "../chunks/CVI3x9Sh.js";
import {
  g as fa,
  P as sb,
  b as lb
} from "../chunks/DhWx5VbC.js";
import {
  S as ma,
  a as Jr,
  t as vr,
  u as Mt,
  p as Ao,
  q as cb,
  v as ub,
  w as hb,
  y as db,
  x as pb,
  e as fb,
  z as mb,
  c as _b,
  A as gb,
  C as kv,
  P as cm,
  B as vb
} from "../chunks/DEvoHVj4.js";
import {
  A as Wi,
  c as Tm,
  g as um,
  p as yb,
  a as b0
} from "../chunks/B9el3unU.js";
import {
  f as gl,
  h as Ra,
  R as w0
} from "../chunks/QZQaTvzN.js";
import {
  p as At,
  r as lr,
  s as Fs,
  u as Ev
} from "../chunks/tQ1KAbXL.js";
import {
  h as Gp
} from "../chunks/Cn7ZWQHE.js";
import {
  b as ko
} from "../chunks/Cqhm8a28.js";
import {
  L as T0
} from "../chunks/dYv29Rfc.js";
import {
  g as De,
  l as xb
} from "../chunks/BkjxUA7W.js";
import {
  c as Gh
} from "../chunks/DRehdENg.js";
import {
  d as bb,
  L as $p,
  p as c_
} from "../chunks/D3O8hove.js";
import {
  c as Sm,
  b as u_,
  D as S0,
  W as wb,
  s as Tb,
  d as Sb,
  l as C0,
  a as Cb,
  p as Pb,
  r as Ib,
  t as Mb,
  e as Ab,
  R as kb,
  f as zv
} from "../chunks/rd2RFHto.js";
import {
  e as ii,
  i as Hp
} from "../chunks/fQ7nNgyB.js";
import {
  c as h_,
  b as $h,
  a as Eb
} from "../chunks/DhwiKPC7.js";
import {
  P as mo,
  t as P0
} from "../chunks/Mq-UeEVM.js";
import {
  l as zb,
  p as d_,
  m as I0,
  v as Lb,
  s as Db
} from "../chunks/DYUfLul6.js";
import {
  g as Ni,
  a as Wp,
  c as M0,
  b as Rb
} from "../chunks/JL5Q4bby.js";
import {
  k as th
} from "../chunks/DGXYwP1j.js";
import {
  A as A0,
  c as cs
} from "../chunks/zbQm_RRe.js";
import {
  A as k0,
  d as E0,
  D as z0,
  a as Xp,
  r as Fb,
  I as Cm,
  e as Bb,
  c as Ob,
  P as L0,
  b as Nb
} from "../chunks/BfOed5Lh.js";
import {
  f as Wa,
  s as bp
} from "../chunks/2qQUb2gF.js";
import {
  C as p_,
  c as jb
} from "../chunks/D_f-dc5A.js";
import "../chunks/_DuaeR9c.js";
import {
  i as D0
} from "../chunks/CFF5w9KY.js";
import {
  L as f_
} from "../chunks/CkEKCt7d.js";
import {
  c as Ti
} from "../chunks/CABSah-0.js";
import {
  L as Vb
} from "../chunks/BSyLJ8ST.js";
import {
  _ as qb
} from "../chunks/D6h70I3T.js";
import {
  c as R0
} from "../chunks/BVXVI3D4.js";
import {
  s as F0
} from "../chunks/BUV3Cfgz.js";
import {
  T as rh,
  G as zp,
  t as B0
} from "../chunks/Ct6BJ5Hw.js";
import {
  C as Ub
} from "../chunks/BGvoK3UU.js";
import {
  R as Zb
} from "../chunks/DjuzlcSU.js";
import {
  W as Gb
} from "../chunks/thS8MyQP.js";
import {
  r as $b
} from "../chunks/3Vbu53zm.js";
(function() {
  try {
    var _ = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    _.SENTRY_RELEASE = {
      id: "15fb4e3d80a4de2b957e29f1299dd0b2bef7a1e3"
    }
  } catch {}
})();
try {
  (function() {
    var _ = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      o = new _.Error().stack;
    o && (_._sentryDebugIds = _._sentryDebugIds || {}, _._sentryDebugIds[o] = "ff33305f-15b4-4ab3-b73d-a3871997ee23", _._sentryDebugIdIdentifier = "sentry-dbid-ff33305f-15b4-4ab3-b73d-a3871997ee23")
  })()
} catch {}
const Hb = [];

function Wb(_, o = !1, f = !1) {
  return wp(_, new Map, "", Hb, null, f)
}

function wp(_, o, f, x, A = null, L = !1) {
  if (typeof _ == "object" && _ !== null) {
    var w = o.get(_);
    if (w !== void 0) return w;
    if (_ instanceof Map) return new Map(_);
    if (_ instanceof Set) return new Set(_);
    if (Hx(_)) {
      var s = Array(_.length);
      o.set(_, s), A !== null && o.set(A, s);
      for (var B = 0; B < _.length; B += 1) {
        var j = _[B];
        B in _ && (s[B] = wp(j, o, f, x, null, L))
      }
      return s
    }
    if (Wx(_) === Xx) {
      s = {}, o.set(_, s), A !== null && o.set(A, s);
      for (var K in _) s[K] = wp(_[K], o, f, x, null, L);
      return s
    }
    if (_ instanceof Date) return structuredClone(_);
    if (typeof _.toJSON == "function" && !L) return wp(_.toJSON(), o, f, x, _)
  }
  if (_ instanceof EventTarget) return _;
  try {
    return structuredClone(_)
  } catch {
    return _
  }
}

function Xb() {
  return Symbol(Yx)
}

function Yp(_, o) {
  Kx(window, ["resize"], () => Jx(() => o(window[_])))
}
const Yb = Qx;
var Po, Io, is, Bp, fo, Wu, Tp;
const D_ = class D_ extends Map {
  constructor(f) {
    super();
    Pr(this, fo);
    Pr(this, Po, new Map);
    Pr(this, Io, Qe(0));
    Pr(this, is, Qe(0));
    Pr(this, Bp, Iv || -1);
    if (f) {
      for (var [x, A] of f) super.set(x, A);
      Xe(this, is).v = super.size
    }
  }
  has(f) {
    var x = Xe(this, Po),
      A = x.get(f);
    if (A === void 0) {
      var L = super.get(f);
      if (L !== void 0) A = Nr(this, fo, Wu).call(this, 0), x.set(f, A);
      else return y(Xe(this, Io)), !1
    }
    return y(A), !0
  }
  forEach(f, x) {
    Nr(this, fo, Tp).call(this), super.forEach(f, x)
  }
  get(f) {
    var x = Xe(this, Po),
      A = x.get(f);
    if (A === void 0) {
      var L = super.get(f);
      if (L !== void 0) A = Nr(this, fo, Wu).call(this, 0), x.set(f, A);
      else {
        y(Xe(this, Io));
        return
      }
    }
    return y(A), super.get(f)
  }
  set(f, x) {
    var ee;
    var A = Xe(this, Po),
      L = A.get(f),
      w = super.get(f),
      s = super.set(f, x),
      B = Xe(this, Io);
    if (L === void 0) L = Nr(this, fo, Wu).call(this, 0), A.set(f, L), te(Xe(this, is), super.size), $u(B);
    else if (w !== x) {
      $u(L);
      var j = B.reactions === null ? null : new Set(B.reactions),
        K = j === null || !((ee = L.reactions) != null && ee.every(re => j.has(re)));
      K && $u(B)
    }
    return s
  }
  delete(f) {
    var x = Xe(this, Po),
      A = x.get(f),
      L = super.delete(f);
    return A !== void 0 && (x.delete(f), te(Xe(this, is), super.size), te(A, -1), $u(Xe(this, Io))), L
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var f = Xe(this, Po);
      te(Xe(this, is), 0);
      for (var x of f.values()) te(x, -1);
      $u(Xe(this, Io)), f.clear()
    }
  }
  keys() {
    return y(Xe(this, Io)), super.keys()
  }
  values() {
    return Nr(this, fo, Tp).call(this), super.values()
  }
  entries() {
    return Nr(this, fo, Tp).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return y(Xe(this, is)), super.size
  }
};
Po = new WeakMap, Io = new WeakMap, is = new WeakMap, Bp = new WeakMap, fo = new WeakSet, Wu = function(f) {
  return Iv === Xe(this, Bp) ? Qe(f) : eb(f)
}, Tp = function() {
  y(Xe(this, Io));
  var f = Xe(this, Po);
  if (Xe(this, is).v !== f.size) {
    for (var x of Pv(D_.prototype, this, "keys").call(this))
      if (!f.has(x)) {
        var A = Nr(this, fo, Wu).call(this, 0);
        f.set(x, A)
      }
  }
  for ([, A] of Xe(this, Po)) y(A)
};
let Pm = D_;
const Kb = () => "Log in",
  Jb = () => "Entrar",
  Qb = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Kb() : Jb(),
  e2 = () => "Store",
  t2 = () => "Loja",
  O0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? e2() : t2(),
  r2 = () => "Alliance",
  n2 = () => "Alian√ßa",
  Kp = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? r2() : n2(),
  i2 = () => "Leaderboard",
  a2 = () => "Ranking",
  m_ = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? i2() : a2(),
  o2 = () => "Unlock",
  s2 = () => "Destravar",
  l2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? o2() : s2(),
  c2 = () => "Lock",
  u2 = () => "Travar",
  h2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? c2() : u2(),
  d2 = () => "Info",
  p2 = () => "Informa√ß√µes",
  f2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? d2() : p2(),
  m2 = () => "Zoom in",
  _2 = () => "Aumentar zoom",
  g2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? m2() : _2(),
  v2 = () => "Zoom out",
  y2 = () => "Diminuir zoom",
  x2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? v2() : y2(),
  b2 = () => "Offline",
  w2 = () => "Offline",
  T2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? b2() : w2(),
  S2 = () => "Zoom in to see the pixels",
  C2 = () => "Amplie para ver os pixels",
  P2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? S2() : C2(),
  I2 = () => "Phone verification required",
  M2 = () => "Verifica√ß√£o de telefone necess√°ria",
  Lv = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? I2() : M2(),
  A2 = () => "My location",
  k2 = () => "Minha localiza√ß√£o",
  E2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? A2() : k2(),
  z2 = () => "You don't have charges to paint. Wait to recharge.",
  L2 = () => "Voc√™ n√£o possui tinta para pintar. Aguarde para carrega-las.",
  D2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? z2() : L2(),
  R2 = () => "Map powered by:",
  F2 = () => "Mapa fornecido por:",
  B2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? R2() : F2(),
  O2 = () => "OpenMapTiles Data from",
  N2 = () => "OpenMapTiles com dados do",
  j2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? O2() : N2(),
  V2 = () => "Overview",
  q2 = () => "Vis√£o Geral",
  U2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? V2() : q2(),
  Z2 = () => "How to paint faster",
  G2 = () => "Como pintar mais r√°pido",
  $2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Z2() : G2(),
  H2 = () => "When painting, click on the button",
  W2 = () => "Quando pintar clique no bot√£o",
  X2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? H2() : W2(),
  Y2 = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  K2 = () => "no canto superior direito da tela. Isso bloquear√° a tela, mas tamb√©m permitir√° pintar movendo o dedo sobre o mapa.",
  J2 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Y2() : K2(),
  Q2 = () => "Hold",
  ew = () => "Segure",
  tw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Q2() : ew(),
  rw = () => "SPACE",
  nw = () => "Espa√ßo",
  iw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? rw() : nw(),
  aw = () => "and move your cursor over the map.",
  ow = () => "e mova seu cursor sobre o mapa.",
  sw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? aw() : ow(),
  lw = () => "Recharge paint charges",
  cw = () => "Recarga de tinta",
  uw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? lw() : cw(),
  hw = () => "Items",
  dw = () => "Itens",
  pw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? hw() : dw(),
  fw = () => "Get more charges",
  mw = () => "Recarregue tinta para pintar",
  _w = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? fw() : mw(),
  gw = _ => `+${_.amount} Max. Charges`,
  vw = _ => `+${_.amount} Tinta m√°xima`,
  yw = (_, o = {}) => (o.locale ?? De()) === "en" ? gw(_) : vw(_),
  xw = () => "Increase your maximum paint charges capacity",
  bw = () => "Aumente sua capacidade m√°xima de tinta",
  ww = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? xw() : bw(),
  Tw = () => "Profile picture",
  Sw = () => "Imagem de perfil",
  Cw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Tw() : Sw(),
  Pw = () => "Add a new 16x16 profile picture",
  Iw = () => "Adicionar uma nova imagem de perfil 16x16",
  Mw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Pw() : Iw(),
  Aw = () => "Not enough droplets",
  kw = () => "Droplets insuficientes",
  Jp = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Aw() : kw(),
  Ew = () => "Show profile",
  zw = () => "Exibir perfil",
  Lw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Ew() : zw(),
  Dw = () => "Menu",
  Rw = () => "Menu",
  Fw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Dw() : Rw(),
  Bw = _ => `Could not install the app: ${_.error}`,
  Ow = _ => `N√£o pode instalar o app: ${_.error}`,
  Nw = (_, o = {}) => (o.locale ?? De()) === "en" ? Bw(_) : Ow(_),
  jw = () => "Install App",
  Vw = () => "Instalar App",
  qw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? jw() : Vw(),
  Uw = () => "Livestreams",
  Zw = () => "Livestreams",
  Gw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Uw() : Zw(),
  $w = () => "Hide UI",
  Hw = () => "Esconder UI",
  Ww = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? $w() : Hw(),
  Xw = () => "Change picture:",
  Yw = () => "Change picture:",
  Kw = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Xw() : Yw(),
  Jw = () => "Show last painted pixel on alliance",
  Qw = () => "Mostrar √∫ltimo pixel pintado na alian√ßa",
  e5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Jw() : Qw(),
  t5 = () => "Delete Account",
  r5 = () => "Deletar Conta",
  Im = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? t5() : r5(),
  n5 = () => "Are you absolutely sure?",
  i5 = () => "Voc√™ tem certeza absoluta?",
  a5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? n5() : i5(),
  o5 = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  s5 = () => "Isso excluir√° permanentemente sua conta e todos os dados associados. Esta a√ß√£o n√£o pode ser desfeita.",
  l5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? o5() : s5(),
  c5 = () => "Profile",
  u5 = () => "Perfil",
  h5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? c5() : u5(),
  d5 = () => "Display your country‚Äôs flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  p5 = () => "Exiba a bandeira do seu pa√≠s ao lado do seu nome de usu√°rio. Al√©m disso, ao pintar em regi√µes onde voc√™ possui a bandeira correspondente, voc√™ recupera 10% das tintas gastas.",
  f5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? d5() : p5(),
  m5 = () => "Does not need to be equipped to provide the bonus",
  _5 = () => "N√£o precisa estar equipada para obter o b√¥nus",
  g5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? m5() : _5(),
  v5 = () => "Equipped",
  y5 = () => "Equipado",
  x5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? v5() : y5(),
  b5 = () => "Equip",
  w5 = () => "Equipar",
  T5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? b5() : w5(),
  S5 = () => "Country",
  C5 = () => "Pa√≠s",
  __ = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? S5() : C5(),
  P5 = () => "No country found.",
  I5 = () => "Pa√≠s n√£o encontrado.",
  M5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? P5() : I5(),
  A5 = () => "Welcome to",
  k5 = () => "Bem vindo ao",
  E5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? A5() : k5(),
  z5 = () => "Rules",
  L5 = () => "Regras",
  D5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? z5() : L5(),
  R5 = () => "Important",
  F5 = () => "Importante",
  B5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? R5() : F5(),
  O5 = () => "üö´ No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
  N5 = () => "üö´ Conte√∫do inapropriado n√£o permitido (+18, discurso de √≥dio, links inapropriados, conte√∫do altamente sugestivo, ...)",
  j5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? O5() : N5(),
  V5 = () => "üòà Do not paint over other artworks using random colors or patterns just to mess things up",
  q5 = () => "üòà N√£o desenhe por cima de outras artes usando cores ou padr√µes aleat√≥rios s√≥ para bagun√ßar",
  U5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? V5() : q5(),
  Z5 = () => "üßë‚Äçü§ù‚Äçüßë Do not paint with more than one account",
  G5 = () => "üßë‚Äçü§ù‚Äçüßë N√£o desenhe com mais de uma conta",
  $5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Z5() : G5(),
  H5 = () => "ü§ñ Use of bots is not allowed",
  W5 = () => "ü§ñ Usar bots n√£o √© permitido",
  X5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? H5() : W5(),
  Y5 = () => "üôÖ Disclosing other's personal information is not allowed",
  K5 = () => "üôÖ Divulgar informa√ß√µes pessoais dos outros n√£o √© permitido",
  J5 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Y5() : K5(),
  Q5 = () => "‚úÖ Painting over other artworks to complement them or create a new drawing is allowed",
  e3 = () => "‚úÖ Desenhar sobre outras artes para complementar ou criar novas artes √© permitido",
  t3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Q5() : e3(),
  r3 = () => "‚úÖ Griefing political party flags or portraits of politicians is allowed",
  n3 = () => "‚úÖ Desenhar sobre bandeiras de partidos e retratos de pol√≠ticos √© permitido",
  i3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? r3() : n3(),
  a3 = () => "Violations of these rules may lead to suspension of your account or removal of drawings.",
  o3 = () => "A viola√ß√£o destas regras pode levar √† suspens√£o da conta ou √† remo√ß√£o de desenhos.",
  s3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? a3() : o3(),
  l3 = () => "Understood",
  c3 = () => "Entendido",
  u3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? l3() : c3(),
  h3 = () => "Toggle art opacity",
  d3 = () => "Alterar opacidade",
  N0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? h3() : d3(),
  p3 = () => "Paint",
  f3 = () => "Pintar",
  j0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? p3() : f3(),
  m3 = () => "Select a color",
  _3 = () => "Selecione uma color",
  g3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? m3() : _3(),
  v3 = () => "Select a pixel to erase",
  y3 = () => "Selecione um pixel para apagar",
  x3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? v3() : y3(),
  b3 = () => "Pick a color from the map",
  w3 = () => "Escolha uma cor do mapa",
  T3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? b3() : w3(),
  S3 = () => "Click",
  C3 = () => "Clique",
  P3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? S3() : C3(),
  I3 = () => "SPACE",
  M3 = () => "ESPA√áO",
  A3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? I3() : M3(),
  k3 = () => "or hold",
  E3 = () => "ou segure",
  z3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? k3() : E3(),
  L3 = () => "to paint,",
  D3 = () => "para pintar",
  R3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? L3() : D3(),
  F3 = () => "You can paint more than 1 pixel",
  B3 = () => "Voc√™ pode pintar mais de 1 pixel",
  O3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? F3() : B3(),
  N3 = () => "Paint pixel",
  j3 = () => "Pintar pixel",
  V3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? N3() : j3(),
  q3 = () => "Color Picker",
  U3 = () => "Conta Gotas",
  Z3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? q3() : U3(),
  G3 = () => "+2 max. charge/level",
  $3 = () => "+2 tinta m√°xima/level",
  H3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? G3() : $3(),
  W3 = () => "Name",
  X3 = () => "Nome",
  Mm = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? W3() : X3(),
  Y3 = () => "Discord Username",
  K3 = () => "Usu√°rio do Discord",
  J3 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Y3() : K3(),
  Q3 = () => "Max. Charges",
  eT = () => "Tinta m√°xima",
  Dv = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? Q3() : eT(),
  tT = () => "Paint Charges",
  rT = () => "Tintas",
  nT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? tT() : rT(),
  iT = _ => `+${_.amount} Paint Charges`,
  aT = _ => `+${_.amount} Tintas`,
  oT = (_, o = {}) => (o.locale ?? De()) === "en" ? iT(_) : aT(_),
  sT = () => "Leave alliance",
  lT = () => "Sair da alian√ßa",
  cT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? sT() : lT(),
  uT = () => "Headquarters",
  hT = () => "Quartel General",
  dT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? uT() : hT(),
  pT = () => "Not set",
  fT = () => "N√£o configurado",
  mT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? pT() : fT(),
  _T = () => "You are not in an alliance",
  gT = () => "Voc√™ n√£o est√° em uma alian√ßa",
  vT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? _T() : gT(),
  yT = () => "Get invited to an alliance",
  xT = () => "Seja convidado para uma alian√ßa",
  bT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? yT() : xT(),
  wT = () => "OR",
  TT = () => "OU",
  ST = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? wT() : TT(),
  CT = () => "Create an alliance",
  PT = () => "Crie uma alian√ßa",
  IT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? CT() : PT(),
  MT = () => "Invite link",
  AT = () => "Link de convite",
  kT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? MT() : AT(),
  ET = () => "Send the link below to everybody you want to invite to the alliance",
  zT = () => "Envie o link abaixo para quem voc√™ deseja convidar para a alian√ßa",
  LT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? ET() : zT(),
  DT = () => "Copied",
  RT = () => "Copiado",
  g_ = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? DT() : RT(),
  FT = () => "No description",
  BT = () => "Sem descri√ß√£o",
  V0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? FT() : BT(),
  OT = () => "Invite",
  NT = () => "Convite",
  jT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? OT() : NT(),
  VT = () => "No pixels painted",
  qT = () => "Nenhum pixel pintado",
  v_ = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? VT() : qT(),
  UT = () => "Today",
  ZT = () => "Hoje",
  Qp = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? UT() : ZT(),
  GT = () => "Week",
  $T = () => "Semana",
  HT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? GT() : $T(),
  WT = () => "Month",
  XT = () => "M√™s",
  YT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? WT() : XT(),
  KT = () => "All time",
  JT = () => "Geral",
  QT = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? KT() : JT(),
  eS = () => "this week",
  tS = () => "nesta semana",
  y_ = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? eS() : tS(),
  rS = () => "this month",
  nS = () => "neste m√™s",
  x_ = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? rS() : nS(),
  iS = () => "Create alliance",
  aS = () => "Criar alian√ßa",
  oS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? iS() : aS(),
  sS = () => "Alliance Name",
  lS = () => "Nome da alian√ßa",
  cS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? sS() : lS(),
  uS = () => "Create",
  hS = () => "Criar",
  dS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? uS() : hS(),
  pS = () => "Give admin",
  fS = () => "Tornar admin",
  mS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? pS() : fS(),
  _S = () => "Ban from alliance",
  gS = () => "Banir da alian√ßa",
  q0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? _S() : gS(),
  vS = () => "No action",
  yS = () => "Sem op√ß√£o",
  xS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? vS() : yS(),
  bS = () => "Unban",
  wS = () => "Desbanir",
  TS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? bS() : wS(),
  SS = () => "No banned users",
  CS = () => "Sem usu√°rios banidos",
  PS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? SS() : CS(),
  IS = () => "Update",
  MS = () => "Atualizar",
  AS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? IS() : MS(),
  kS = () => "Error giving admin to user",
  ES = () => "Erro ao tornar usu√°rio admin",
  zS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? kS() : ES(),
  LS = () => "Users",
  DS = () => "Usu√°rios",
  RS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? LS() : DS(),
  FS = () => "Regions",
  BS = () => "Regi√µes",
  OS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? FS() : BS(),
  NS = () => "Countries",
  jS = () => "Pa√≠ses",
  VS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? NS() : jS(),
  qS = () => "Players",
  US = () => "Jogadores",
  U0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? qS() : US(),
  ZS = () => "Alliances",
  GS = () => "Alian√ßas",
  Z0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? ZS() : GS(),
  $S = () => "Region",
  HS = () => "Regi√£o",
  WS = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? $S() : HS(),
  XS = () => "Pixels",
  YS = () => "Pixels",
  Mc = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? XS() : YS(),
  KS = () => "Painted",
  JS = () => "Pintados",
  Ac = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? KS() : JS(),
  QS = () => "Pixels painted inside the region",
  eC = () => "Pixels pintados dentro da regi√£o",
  tC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? QS() : eC(),
  rC = () => "Not painted",
  nC = () => "N√£o pintado",
  iC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? rC() : nC(),
  aC = () => "Painted by",
  oC = () => "Pintado por",
  sC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? aC() : oC(),
  lC = () => "Limit reached",
  cC = () => "Limite atingido",
  uC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? lC() : cC(),
  hC = () => "Favorite",
  dC = () => "Favoritar",
  pC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? hC() : dC(),
  fC = () => "Share",
  mC = () => "Compartilhar",
  _C = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? fC() : mC(),
  gC = () => "Share place",
  vC = () => "Compartilhar local",
  yC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? gC() : vC(),
  xC = () => "Mute",
  bC = () => "Mutar",
  wC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? xC() : bC(),
  TC = () => "Unmute",
  SC = () => "Desmutar",
  CC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? TC() : SC(),
  PC = () => "Select the headquarters location",
  IC = () => "Selecione a localiza√ß√£o do quartel general",
  MC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? PC() : IC(),
  AC = () => "Pixels painted inside the country",
  kC = () => "Pixels pintados dentro do pa√≠s",
  EC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? AC() : kC(),
  zC = () => "Username copied to clipboard",
  LC = () => "Usu√°rio copiado",
  DC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? zC() : LC(),
  RC = () => "No more charges",
  FC = () => "Acabou a tinta",
  BC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? RC() : FC(),
  OC = () => "You are not allowed to use multiple accounts. Use your main account to paint.",
  NC = () => "N√£o √© permitido usar v√°rias contas. Use sua conta principal para pintar.",
  jC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? OC() : NC(),
  VC = () => "SMS sent to",
  qC = () => "SMS enviado para",
  UC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? VC() : qC(),
  ZC = () => "Phone successfully verified",
  GC = () => "Telefone verificado com sucesso",
  $C = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? ZC() : GC(),
  HC = () => "Not a valid phone number",
  WC = () => "N√£o √© um n√∫mero v√°lido",
  XC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? HC() : WC(),
  YC = () => "Location unfavorited",
  KC = () => "Localiza√ß√£o desfavoritada",
  JC = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? YC() : KC(),
  QC = () => "Location favorited",
  eP = () => "Localiza√ß√£o favoritada",
  tP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? QC() : eP(),
  rP = () => "Giving admin to user",
  nP = () => "Tornar usu√°rio um admin",
  iP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? rP() : nP(),
  aP = () => "Profile updated",
  oP = () => "Perfil atualizado",
  sP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? aP() : oP(),
  lP = () => "Successfully linked your Discord account.",
  cP = () => "A sua conta Discord foi conectada com sucesso.",
  uP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? lP() : cP(),
  hP = () => "Discord unlinked",
  dP = () => "Discord desconectado",
  pP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? hP() : dP(),
  fP = () => "Link your Discord",
  mP = () => "Conectar Discord",
  _P = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? fP() : mP(),
  gP = _ => `Unlink Discord (${_.username})`,
  vP = _ => `Desconectar Discord (${_.username})`,
  yP = (_, o = {}) => (o.locale ?? De()) === "en" ? gP(_) : vP(_),
  xP = () => "Account successfully deleted",
  bP = () => "Conta deletada com sucesso",
  wP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? xP() : bP(),
  TP = () => "Logged out",
  SP = () => "Logout feito",
  CP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? TP() : SP(),
  PP = () => "Could not logout. Try refreshing the page.",
  IP = () => "N√£o foi poss√≠vel sair da conta. Tente recarregar a p√°gina.",
  MP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? PP() : IP(),
  AP = () => "You need to zoom in to select a pixel",
  kP = () => "D√™ zoom para selecionar um pixel",
  EP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? AP() : kP(),
  zP = () => "Phone verification",
  LP = () => "Verifica√ß√£o de telefone",
  DP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? zP() : LP(),
  RP = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
  FP = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experi√™ncia segura e criativa para todos.",
  BP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? RP() : FP(),
  OP = () => "Send Code",
  NP = () => "Enviar o c√≥digo",
  jP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? OP() : NP(),
  VP = () => "Input the code",
  qP = () => "Insira o c√≥digo",
  UP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? VP() : qP(),
  ZP = () => "Sent to",
  GP = () => "Enviar para",
  $P = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? ZP() : GP(),
  HP = () => "Resend Code",
  WP = () => "Reenviar C√≥digo",
  XP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? HP() : WP(),
  YP = () => "Try another number",
  KP = () => "Tentar outro n√∫mero",
  JP = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? YP() : KP(),
  QP = () => "Edit profile",
  eI = () => "Editar perfil",
  tI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? QP() : eI(),
  rI = () => "Image",
  nI = () => "Imagem",
  iI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? rI() : nI(),
  aI = () => "Download",
  oI = () => "Download",
  sI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? aI() : oI(),
  lI = () => "Image copied to clipboard",
  cI = () => "Imagem copiada para a √°rea de transfer√™ncia",
  uI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? lI() : cI(),
  hI = () => "My map is lagging",
  dI = () => "Meu mapa est√° travando",
  pI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? hI() : dI(),
  fI = () => "Verify if",
  mI = () => "Verifique se",
  _I = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? fI() : mI(),
  gI = () => "Use hardware acceleration when available",
  vI = () => "Usar acelera√ß√£o gr√°fica quando dispon√≠vel",
  yI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? gI() : vI(),
  xI = () => "is enabled on",
  bI = () => "est√° habilitado em",
  wI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? xI() : bI(),
  TI = () => "Follow the instructions to enable hardware acceleration",
  SI = () => "Siga a instru√ß√£o para habilitar a acelera√ß√£o de hardware",
  CI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? TI() : SI(),
  PI = () => "Moderation",
  II = () => "Modera√ß√£o",
  MI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? PI() : II(),
  AI = () => "Terms",
  kI = () => "Termos",
  EI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? AI() : kI(),
  zI = () => "Privacy",
  LI = () => "Privacidade",
  DI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? zI() : LI(),
  RI = () => "Refund",
  FI = () => "Reembolso",
  G0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? RI() : FI(),
  BI = () => "Clear area",
  OI = () => "Limpar √°rea",
  NI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? BI() : OI(),
  jI = () => "Select the area's first corner",
  VI = () => "Selecione o primeiro canto da √°rea",
  $0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? jI() : VI(),
  qI = () => "Select the area's opposite corner",
  UI = () => "Selecione o canto oposto da √°rea",
  H0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? qI() : UI(),
  ZI = () => "Admin",
  GI = () => "Administra√ß√£o",
  $I = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? ZI() : GI(),
  HI = _ => `Reason: ${_.reason}`,
  WI = _ => `Motivo: ${_.reason}`,
  Rv = (_, o = {}) => (o.locale ?? De()) === "en" ? HI(_) : WI(_),
  XI = () => "No corresponding region on the map (cosmetic effect only)",
  YI = () => "N√£o possui regi√£o no mapa (apenas efeito cosm√©tico)",
  KI = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? XI() : YI(),
  JI = () => "Flag without region on the map",
  QI = () => "Bandeira sem regi√£o no mapa",
  e4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? JI() : QI(),
  t4 = _ => `The flag of <b>${_.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
  r4 = _ => `A bandeira <b>${_.country}</b> n√£o possui regi√µes correspondente no mapa e s√≥ ter√° efeito cosm√©tico.`,
  n4 = (_, o = {}) => (o.locale ?? De()) === "en" ? t4(_) : r4(_),
  i4 = () => "Dark mode",
  a4 = () => "Modo escuro",
  o4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? i4() : a4(),
  s4 = () => "Light mode",
  l4 = () => "Modo claro",
  c4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? s4() : l4(),
  u4 = () => "This action will log your account out from all devices.",
  h4 = () => "Essa a√ß√£o ira desconectar sua conta de todos os dispositivos.",
  d4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? u4() : h4(),
  p4 = () => "More",
  f4 = () => "Mais",
  m4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? p4() : f4(),
  _4 = () => "This action is irreversible, do you want to proceed?",
  g4 = () => "Esta a√ß√£o √© irrevers√≠vel, voc√™ deseja prosseguir?",
  v4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? _4() : g4(),
  y4 = () => "Please confirm by entering your username:",
  x4 = () => "Por favor, confirme digitando seu nome de usu√°rio:",
  b4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? y4() : x4(),
  w4 = () => "Type your username",
  T4 = () => "Digite seu nome de usu√°rio",
  S4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? w4() : T4(),
  C4 = () => "This action may take some time to be completed.",
  P4 = () => "Essa a√ß√£o pode levar algum tempo para ser realizada.",
  I4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? C4() : P4(),
  M4 = () => "Ban appeal",
  A4 = () => "Revis√£o de banimento",
  W0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? M4() : A4(),
  k4 = () => "Suggestions",
  E4 = () => "Sugest√µes",
  z4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? k4() : E4(),
  L4 = () => "Bug report",
  D4 = () => "Reportar bug",
  R4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? L4() : D4(),
  F4 = () => "For more details, see our",
  B4 = () => "Para mais detalhes, veja nossa",
  O4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? F4() : B4(),
  N4 = () => "Account Enforcement Policy and Code of Conduct",
  j4 = () => "Pol√≠tica de Aplica√ß√£o da Conta e C√≥digo de Conduta",
  V4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? N4() : j4(),
  q4 = () => "Community Leader",
  U4 = () => "L√≠der de Comunidade",
  Z4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? q4() : U4(),
  G4 = () => "Your name is how other users will see you in Wplace. It can be changed every 60 days.",
  $4 = () => "Seu nome √© como outros usu√°rios o ver√£o no Wplace. Voc√™ pode alter√°-lo a cada 60 dias.",
  H4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? G4() : $4(),
  W4 = () => "Twitch account migrated successfully.",
  X4 = () => "Conta da Twitch migrada com sucesso.",
  Y4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? W4() : X4(),
  K4 = () => "Timeout appeal",
  J4 = () => "Revis√£o de suspens√£o",
  Q4 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? K4() : J4(),
  eM = () => `If you believe your suspension was a mistake, you can send one appeal <b>every 90 days</b> to have your case reviewed again.

Please note that submitting an appeal <b>does not guarantee that your suspension will be lifted</b>; however, our team will review your situation.

Reviews usually take up to <b>a week</b>.`,
  tM = () => `Se voc√™ acredita que sua suspens√£o foi um erro, voc√™ pode enviar um apelo <b>a cada 90 dias</b> para que seu caso seja revisado novamente.

Por favor, note que enviar um recurso <b>n√£o garante que sua suspens√£o ser√° removida</b>; no entanto, nossa equipe analisar√° a sua situa√ß√£o novamente.

As revis√µes geralmente levam at√© <b>uma semana</b>.`,
  rM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? eM() : tM(),
  nM = () => "Why your suspension should be lifted?",
  iM = () => "Por que sua suspens√£o deve ser reconsiderada?",
  aM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? nM() : iM(),
  oM = () => "Tell us why you think your suspension should be reconsidered",
  sM = () => "Explique por que voc√™ acha que sua suspens√£o deve ser reconsiderada",
  lM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? oM() : sM(),
  cM = () => "Submit",
  uM = () => "Enviar",
  hM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? cM() : uM(),
  dM = () => "Appeal sent successfully",
  pM = () => "Apelo enviado com sucesso",
  fM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? dM() : pM(),
  mM = () => "User appeal",
  _M = () => "Apelo do usu√°rio",
  gM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? mM() : _M(),
  vM = _ => `You can send another appeal in ${_.days} days`,
  yM = _ => `Voc√™ pode enviar outro apelo em ${_.days} dias`,
  xM = (_, o = {}) => (o.locale ?? De()) === "en" ? vM(_) : yM(_),
  bM = () => "Appeal",
  wM = () => "Apelar",
  TM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? bM() : wM(),
  SM = () => "Notifications",
  CM = () => "Notifica√ß√µes",
  PM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? SM() : CM(),
  IM = () => "No notifications",
  MM = () => "Nenhuma notifica√ß√£o",
  AM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? IM() : MM(),
  kM = () => "Report feedback",
  EM = () => "Feedback de report",
  Fv = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? kM() : EM(),
  zM = () => "Your report has been reviewed, and a penalty has been applied to the reported player.",
  LM = () => "Sua den√∫ncia foi analisada e uma penalidade foi aplicada ao jogador denunciado.",
  Bv = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? zM() : LM(),
  DM = () => "Thank you for helping keep the community fair and safe.",
  RM = () => "Obrigado por ajudar a manter a comunidade justa e segura!",
  FM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? DM() : RM(),
  BM = () => "Mark all as read",
  OM = () => "Marcar tudo como lido",
  NM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? BM() : OM(),
  jM = () => "Recent",
  VM = () => "Recente",
  qM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? jM() : VM(),
  UM = () => "Random place",
  ZM = () => "Local aleat√≥rio",
  GM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? UM() : ZM(),
  $M = () => "No place found",
  HM = () => "Nenhum local encontrado",
  WM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? $M() : HM(),
  XM = () => "No recent locations",
  YM = () => "Nenhum local recente",
  KM = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? XM() : YM(),
  JM = () => "Coordinates",
  QM = () => "Coordenadas",
  X0 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? JM() : QM(),
  e6 = () => "Pumpkin",
  t6 = () => "Ab√≥bora",
  r6 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? e6() : t6(),
  n6 = () => "Claim",
  i6 = () => "Resgatar",
  a6 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? n6() : i6(),
  o6 = () => "Claimed",
  s6 = () => "Resgatado",
  l6 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? o6() : s6(),
  c6 = _ => `You received ${_.droplets} droplets!`,
  u6 = _ => `Voc√™ recebeu ${_.droplets} droplets!`,
  h6 = (_, o = {}) => (o.locale ?? De()) === "en" ? c6(_) : u6(_),
  d6 = () => "Event",
  p6 = () => "Evento",
  f6 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? d6() : p6(),
  m6 = () => "Service Workers are not supported/enabled in your browser. Some features might not work properly.",
  _6 = () => "Service Workers n√£o s√£o suportados ou est√£o desativados em seu navegador. Alguns recursos podem n√£o funcionar corretamente.",
  g6 = (_ = {}, o = {}) => (o.locale ?? De()) === "en" ? m6() : _6(),
  ts = 2 * Math.PI * 6378137 / 2;
class us {
  constructor(o = 256) {
    Cr(this, "initialResolution");
    this.tileSize = o, this.initialResolution = 2 * ts / this.tileSize
  }
  latLonToMeters(o, f) {
    const x = f / 180 * ts,
      A = Math.log(Math.tan((90 + o) * Math.PI / 360)) / (Math.PI / 180) * ts / 180;
    return [x, A]
  }
  metersToLatLon(o, f) {
    const x = o / ts * 180;
    let A = f / ts * 180;
    return A = 180 / Math.PI * (2 * Math.atan(Math.exp(A * Math.PI / 180)) - Math.PI / 2), [A, x]
  }
  pixelsToMeters(o, f, x) {
    const A = this.resolution(x),
      L = o * A - ts,
      w = ts - f * A;
    return [L, w]
  }
  pixelsToLatLon(o, f, x) {
    const [A, L] = this.pixelsToMeters(o, f, x);
    return this.metersToLatLon(A, L)
  }
  latLonToPixels(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f);
    return this.metersToPixels(A, L, x)
  }
  latLonToPixelsFloor(o, f, x) {
    const [A, L] = this.latLonToPixels(o, f, x);
    return [Math.floor(A), Math.floor(L)]
  }
  metersToPixels(o, f, x) {
    const A = this.resolution(x),
      L = (o + ts) / A,
      w = (ts - f) / A;
    return [L, w]
  }
  latLonToTile(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f);
    return this.metersToTile(A, L, x)
  }
  metersToTile(o, f, x) {
    const [A, L] = this.metersToPixels(o, f, x);
    return this.pixelsToTile(A, L)
  }
  pixelsToTile(o, f) {
    const x = Math.ceil(o / this.tileSize) - 1,
      A = Math.ceil(f / this.tileSize) - 1;
    return [x, A]
  }
  pixelsToTileLocal(o, f) {
    return {
      tile: this.pixelsToTile(o, f),
      pixel: [Math.floor(o) % this.tileSize, Math.floor(f) % this.tileSize]
    }
  }
  tileBounds(o, f, x) {
    const [A, L] = this.pixelsToMeters(o * this.tileSize, f * this.tileSize, x), [w, s] = this.pixelsToMeters((o + 1) * this.tileSize, (f + 1) * this.tileSize, x);
    return {
      min: [A, L],
      max: [w, s]
    }
  }
  tileBoundsLatLon(o, f, x) {
    const A = this.tileBounds(o, f, x);
    return {
      min: this.metersToLatLon(A.min[0], A.min[1]),
      max: this.metersToLatLon(A.max[0], A.max[1])
    }
  }
  resolution(o) {
    return this.initialResolution / 2 ** o
  }
  latLonToTileAndPixel(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f), [w, s] = this.metersToTile(A, L, x), [B, j] = this.metersToPixels(A, L, x);
    return {
      tile: [w, s],
      pixel: [Math.floor(B) % this.tileSize, Math.floor(j) % this.tileSize]
    }
  }
  pixelBounds(o, f, x) {
    return {
      min: this.pixelsToMeters(o, f, x),
      max: this.pixelsToMeters(o + 1, f + 1, x)
    }
  }
  pixelToBoundsLatLon(o, f, x) {
    const A = this.pixelBounds(o, f, x),
      L = .001885,
      w = (A.max[0] - A.min[0]) * L,
      s = (A.max[1] - A.min[1]) * L;
    return A.min[0] -= w, A.max[0] -= w, A.min[1] -= s, A.max[1] -= s, {
      min: this.metersToLatLon(A.min[0], A.min[1]),
      max: this.metersToLatLon(A.max[0], A.max[1])
    }
  }
  latLonToTileBoundsLatLon(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f), [w, s] = this.metersToTile(A, L, x);
    return this.tileBoundsLatLon(w, s, x)
  }
  latLonToPixelBoundsLatLon(o, f, x) {
    const [A, L] = this.latLonToMeters(o, f), [w, s] = this.metersToPixels(A, L, x);
    return this.pixelToBoundsLatLon(Math.floor(w), Math.floor(s), x)
  }
  latLonToRegionAndPixel(o, f, x, A = ma.regionSize) {
    const [L, w] = this.latLonToPixelsFloor(o, f, x), s = this.tileSize * A;
    return {
      region: [Math.floor(L / s), Math.floor(w / s)],
      pixel: [L % s, w % s]
    }
  }
}

function b_(_, o = !0) {
  const {
    min: f,
    max: x
  } = _;
  return o ? [
    [f[1], x[0]],
    [x[1], x[0]],
    [x[1], f[0]],
    [f[1], f[0]]
  ] : [
    [f[0], x[1]],
    [x[0], x[1]],
    [x[0], f[1]],
    [f[0], f[1]]
  ]
}

function w_(_) {
  return [(_.min[0] + _.max[0]) / 2, (_.min[1] + _.max[1]) / 2]
}
const v6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  Ov = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function y6(_) {
  return Math.floor(Math.random() * _)
}
const Am = 14.5;
async function x6() {
  const _ = T6();
  if (_) return _;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const f = await new Promise((x, A) => navigator.geolocation.getCurrentPosition(L => x(L), L => A(L)));
      return {
        lat: f.coords.latitude,
        lng: f.coords.longitude,
        zoom: Am
      }
    }
  } catch (o) {
    console.error(o)
  }
  return {
    ...b6().pos,
    zoom: Am
  }
}

function b6() {
  const _ = Object.entries(w6),
    o = y6(_.length),
    [f, x] = _[o];
  return {
    city: f,
    pos: x
  }
}
const w6 = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  Y0 = "location";

function rs(_, o) {
  localStorage.setItem(Y0, JSON.stringify({
    ..._,
    zoom: o
  }))
}

function T6() {
  const _ = localStorage.getItem(Y0);
  if (!_) return;
  const o = JSON.parse(_);
  return o.zoom ?? (o.zoom = Am), o
}
var lh, ch;
class S6 {
  constructor() {
    Pr(this, lh, Qe(-1));
    Pr(this, ch, Qe([]))
  }
  get idx() {
    return y(Xe(this, lh))
  }
  set idx(o) {
    te(Xe(this, lh), o, !0)
  }
  get entries() {
    return y(Xe(this, ch))
  }
  set entries(o) {
    te(Xe(this, ch), o)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(o) {
    const f = this.idx + 1,
      x = this.entries[f];
    x && (this.idx = f, o.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(o) {
    const f = this.idx - 1,
      x = this.entries[f];
    x && (this.idx = f, o.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(o) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), o]
  }
}
lh = new WeakMap, ch = new WeakMap;
const C6 = new S6;

function K0(_) {
  return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
}
var Sp = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */
var P6 = Sp.exports,
  Nv;

function I6() {
  return Nv || (Nv = 1, (function(_, o) {
    (function(f, x) {
      _.exports = x()
    })(P6, (function() {
      var f = {},
        x = {};

      function A(w, s, B) {
        if (x[w] = B, w === "index") {
          var j = "var sharedModule = {}; (" + x.shared + ")(sharedModule); (" + x.worker + ")(sharedModule);",
            K = {};
          return x.shared(K), x.index(f, K), typeof window < "u" && f.setWorkerUrl(window.URL.createObjectURL(new Blob([j], {
            type: "text/javascript"
          }))), f
        }
      }
      A("shared", ["exports"], (function(w) {
        function s(n, t, r, a) {
          return new(r || (r = Promise))((function(c, p) {
            function m(C) {
              try {
                b(a.next(C))
              } catch (I) {
                p(I)
              }
            }

            function v(C) {
              try {
                b(a.throw(C))
              } catch (I) {
                p(I)
              }
            }

            function b(C) {
              var I;
              C.done ? c(C.value) : (I = C.value, I instanceof r ? I : new r((function(R) {
                R(I)
              }))).then(m, v)
            }
            b((a = a.apply(n, t || [])).next())
          }))
        }

        function B(n, t) {
          this.x = n, this.y = t
        }

        function j(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var K, ee;
        typeof SuppressedError == "function" && SuppressedError, B.prototype = {
          clone() {
            return new B(this.x, this.y)
          },
          add(n) {
            return this.clone()._add(n)
          },
          sub(n) {
            return this.clone()._sub(n)
          },
          multByPoint(n) {
            return this.clone()._multByPoint(n)
          },
          divByPoint(n) {
            return this.clone()._divByPoint(n)
          },
          mult(n) {
            return this.clone()._mult(n)
          },
          div(n) {
            return this.clone()._div(n)
          },
          rotate(n) {
            return this.clone()._rotate(n)
          },
          rotateAround(n, t) {
            return this.clone()._rotateAround(n, t)
          },
          matMult(n) {
            return this.clone()._matMult(n)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(n) {
            return this.x === n.x && this.y === n.y
          },
          dist(n) {
            return Math.sqrt(this.distSqr(n))
          },
          distSqr(n) {
            const t = n.x - this.x,
              r = n.y - this.y;
            return t * t + r * r
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(n) {
            return Math.atan2(this.y - n.y, this.x - n.x)
          },
          angleWith(n) {
            return this.angleWithSep(n.x, n.y)
          },
          angleWithSep(n, t) {
            return Math.atan2(this.x * t - this.y * n, this.x * n + this.y * t)
          },
          _matMult(n) {
            const t = n[2] * this.x + n[3] * this.y;
            return this.x = n[0] * this.x + n[1] * this.y, this.y = t, this
          },
          _add(n) {
            return this.x += n.x, this.y += n.y, this
          },
          _sub(n) {
            return this.x -= n.x, this.y -= n.y, this
          },
          _mult(n) {
            return this.x *= n, this.y *= n, this
          },
          _div(n) {
            return this.x /= n, this.y /= n, this
          },
          _multByPoint(n) {
            return this.x *= n.x, this.y *= n.y, this
          },
          _divByPoint(n) {
            return this.x /= n.x, this.y /= n.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const n = this.y;
            return this.y = this.x, this.x = -n, this
          },
          _rotate(n) {
            const t = Math.cos(n),
              r = Math.sin(n),
              a = r * this.x + t * this.y;
            return this.x = t * this.x - r * this.y, this.y = a, this
          },
          _rotateAround(n, t) {
            const r = Math.cos(n),
              a = Math.sin(n),
              c = t.y + a * (this.x - t.x) + r * (this.y - t.y);
            return this.x = t.x + r * (this.x - t.x) - a * (this.y - t.y), this.y = c, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: B
        }, B.convert = function(n) {
          if (n instanceof B) return n;
          if (Array.isArray(n)) return new B(+n[0], +n[1]);
          if (n.x !== void 0 && n.y !== void 0) return new B(+n.x, +n.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var re = (function() {
            if (ee) return K;

            function n(t, r, a, c) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = a, this.p2y = c
            }
            return ee = 1, K = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, c = 0; c < 8; c++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < r) return a;
                  var m = this.sampleCurveDerivativeX(a);
                  if (Math.abs(m) < 1e-6) break;
                  a -= p / m
                }
                var v = 0,
                  b = 1;
                for (a = t, c = 0; c < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < r)); c++) t > p ? v = a : b = a, a = .5 * (b - v) + v;
                return a
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, K
          })(),
          de = j(re);
        let ne, Y;

        function we() {
          return ne == null && (ne = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ne
        }

        function Ie() {
          if (Y == null && (Y = !1, we())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let a = 0; a < 25; a++) {
                const c = 4 * a;
                t.fillStyle = `rgb(${c},${c+1},${c+2})`, t.fillRect(a % 5, Math.floor(a / 5), 1, 1)
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let a = 0; a < 100; a++)
                if (a % 4 != 3 && r[a] !== a) {
                  Y = !0;
                  break
                }
            }
          }
          return Y || !1
        }
        var ze = 1e-6,
          Re = typeof Float32Array < "u" ? Float32Array : Array;

        function ke() {
          var n = new Re(9);
          return Re != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n
        }

        function qe(n) {
          return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }

        function $e() {
          var n = new Re(3);
          return Re != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n
        }

        function Be(n) {
          var t = n[0],
            r = n[1],
            a = n[2];
          return Math.sqrt(t * t + r * r + a * a)
        }

        function Ee(n, t, r) {
          var a = new Re(3);
          return a[0] = n, a[1] = t, a[2] = r, a
        }

        function He(n, t, r) {
          return n[0] = t[0] + r[0], n[1] = t[1] + r[1], n[2] = t[2] + r[2], n
        }

        function Le(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n
        }

        function it(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            m = r[0],
            v = r[1],
            b = r[2];
          return n[0] = c * b - p * v, n[1] = p * m - a * b, n[2] = a * v - c * m, n
        }
        var pt, Oe = Be;

        function Je(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            m = t[3];
          return n[0] = r[0] * a + r[4] * c + r[8] * p + r[12] * m, n[1] = r[1] * a + r[5] * c + r[9] * p + r[13] * m, n[2] = r[2] * a + r[6] * c + r[10] * p + r[14] * m, n[3] = r[3] * a + r[7] * c + r[11] * p + r[15] * m, n
        }

        function bt() {
          var n = new Re(4);
          return Re != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n
        }

        function We(n, t, r, a) {
          var c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx",
            p = Math.PI / 360;
          t *= p, a *= p, r *= p;
          var m = Math.sin(t),
            v = Math.cos(t),
            b = Math.sin(r),
            C = Math.cos(r),
            I = Math.sin(a),
            R = Math.cos(a);
          switch (c) {
            case "xyz":
              n[0] = m * C * R + v * b * I, n[1] = v * b * R - m * C * I, n[2] = v * C * I + m * b * R, n[3] = v * C * R - m * b * I;
              break;
            case "xzy":
              n[0] = m * C * R - v * b * I, n[1] = v * b * R - m * C * I, n[2] = v * C * I + m * b * R, n[3] = v * C * R + m * b * I;
              break;
            case "yxz":
              n[0] = m * C * R + v * b * I, n[1] = v * b * R - m * C * I, n[2] = v * C * I - m * b * R, n[3] = v * C * R + m * b * I;
              break;
            case "yzx":
              n[0] = m * C * R + v * b * I, n[1] = v * b * R + m * C * I, n[2] = v * C * I - m * b * R, n[3] = v * C * R - m * b * I;
              break;
            case "zxy":
              n[0] = m * C * R - v * b * I, n[1] = v * b * R + m * C * I, n[2] = v * C * I + m * b * R, n[3] = v * C * R - m * b * I;
              break;
            case "zyx":
              n[0] = m * C * R - v * b * I, n[1] = v * b * R + m * C * I, n[2] = v * C * I - m * b * R, n[3] = v * C * R + m * b * I;
              break;
            default:
              throw new Error("Unknown angle order " + c)
          }
          return n
        }

        function Ue() {
          var n = new Re(2);
          return Re != Float32Array && (n[0] = 0, n[1] = 0), n
        }

        function Ge(n, t) {
          var r = new Re(2);
          return r[0] = n, r[1] = t, r
        }
        $e(), pt = new Re(4), Re != Float32Array && (pt[0] = 0, pt[1] = 0, pt[2] = 0, pt[3] = 0), $e(), Ee(1, 0, 0), Ee(0, 1, 0), bt(), bt(), ke(), Ue();
        const Ve = 8192;

        function mt(n, t, r) {
          return t * (Ve / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)))
        }

        function lt(n, t) {
          return (n % t + t) % t
        }

        function yt(n, t, r) {
          return n * (1 - r) + t * r
        }

        function _t(n) {
          if (n <= 0) return 0;
          if (n >= 1) return 1;
          const t = n * n,
            r = t * n;
          return 4 * (n < .5 ? r : 3 * (n - t) + r - .75)
        }

        function ut(n, t, r, a) {
          const c = new de(n, t, r, a);
          return p => c.solve(p)
        }
        const Ut = ut(.25, .1, .25, 1);

        function Lt(n, t, r) {
          return Math.min(r, Math.max(t, n))
        }

        function Ke(n, t, r) {
          const a = r - t,
            c = ((n - t) % a + a) % a + t;
          return c === t ? r : c
        }

        function ot(n, ...t) {
          for (const r of t)
            for (const a in r) n[a] = r[a];
          return n
        }
        let xt = 1;

        function Ct(n, t, r) {
          const a = {};
          for (const c in n) a[c] = t.call(this, n[c], c, n);
          return a
        }

        function wt(n, t, r) {
          const a = {};
          for (const c in n) t.call(this, n[c], c, n) && (a[c] = n[c]);
          return a
        }

        function kt(n) {
          return Array.isArray(n) ? n.map(kt) : typeof n == "object" && n ? Ct(n, kt) : n
        }
        const Zt = {};

        function Nt(n) {
          Zt[n] || (typeof console < "u" && console.warn(n), Zt[n] = !0)
        }

        function $t(n, t, r) {
          return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x)
        }

        function It(n) {
          return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope
        }
        let Xt = null;

        function Ot(n) {
          if (Xt == null) {
            const t = n.navigator ? n.navigator.userAgent : null;
            Xt = !!n.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return Xt
        }

        function jt(n) {
          return typeof ImageBitmap < "u" && n instanceof ImageBitmap
        }
        const qt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function fr(n, t, r, a, c) {
          return s(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const p = new VideoFrame(n, {
              timestamp: 0
            });
            try {
              const m = p == null ? void 0 : p.format;
              if (!m || !m.startsWith("BGR") && !m.startsWith("RGB")) throw new Error(`Unrecognized format ${m}`);
              const v = m.startsWith("BGR"),
                b = new Uint8ClampedArray(a * c * 4);
              if (yield p.copyTo(b, (function(C, I, R, U, Z) {
                  const X = 4 * Math.max(-I, 0),
                    Q = (Math.max(0, R) - R) * U * 4 + X,
                    ie = 4 * U,
                    ue = Math.max(0, I),
                    Ne = Math.max(0, R);
                  return {
                    rect: {
                      x: ue,
                      y: Ne,
                      width: Math.min(C.width, I + U) - ue,
                      height: Math.min(C.height, R + Z) - Ne
                    },
                    layout: [{
                      offset: Q,
                      stride: ie
                    }]
                  }
                })(n, t, r, a, c)), v)
                for (let C = 0; C < b.length; C += 4) {
                  const I = b[C];
                  b[C] = b[C + 2], b[C + 2] = I
                }
              return b
            } finally {
              p.close()
            }
          }))
        }
        let Kt, _r;

        function rr(n, t, r, a) {
          return n.addEventListener(t, r, a), {
            unsubscribe: () => {
              n.removeEventListener(t, r, a)
            }
          }
        }

        function hr(n) {
          return n * Math.PI / 180
        }

        function nr(n) {
          return n / Math.PI * 180
        }
        const Et = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          kr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          Te = "AbortError";

        function O() {
          return new Error(Te)
        }
        const E = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function D(n) {
          return E.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))]
        }
        const N = "global-dispatcher";
        class H extends Error {
          constructor(t, r, a, c) {
            super(`AJAXError: ${r} (${t}): ${a}`), this.status = t, this.statusText = r, this.url = a, this.body = c
          }
        }
        const W = () => It(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          ce = function(n, t) {
            if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
              const a = D(n.url);
              if (a) return a(n, t);
              if (It(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                targetMapId: N
              }, t)
            }
            if (!(/^file:/.test(r = n.url) || /^file:/.test(W()) && !/^\w+:/.test(r))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(a, c) {
                return s(this, void 0, void 0, (function*() {
                  const p = new Request(a.url, {
                    method: a.method || "GET",
                    body: a.body,
                    credentials: a.credentials,
                    headers: a.headers,
                    cache: a.cache,
                    referrer: W(),
                    signal: c.signal
                  });
                  let m, v;
                  a.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                  try {
                    m = yield fetch(p)
                  } catch (C) {
                    throw new H(0, C.message, a.url, new Blob)
                  }
                  if (!m.ok) {
                    const C = yield m.blob();
                    throw new H(m.status, m.statusText, a.url, C)
                  }
                  v = a.type === "arrayBuffer" || a.type === "image" ? m.arrayBuffer() : a.type === "json" ? m.json() : m.text();
                  const b = yield v;
                  if (c.signal.aborted) throw O();
                  return {
                    data: b,
                    cacheControl: m.headers.get("Cache-Control"),
                    expires: m.headers.get("Expires")
                  }
                }))
              })(n, t);
              if (It(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                mustQueue: !0,
                targetMapId: N
              }, t)
            }
            var r;
            return (function(a, c) {
              return new Promise(((p, m) => {
                var v;
                const b = new XMLHttpRequest;
                b.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (b.responseType = "arraybuffer");
                for (const C in a.headers) b.setRequestHeader(C, a.headers[C]);
                a.type === "json" && (b.responseType = "text", !((v = a.headers) === null || v === void 0) && v.Accept || b.setRequestHeader("Accept", "application/json")), b.withCredentials = a.credentials === "include", b.onerror = () => {
                  m(new Error(b.statusText))
                }, b.onload = () => {
                  if (!c.signal.aborted)
                    if ((b.status >= 200 && b.status < 300 || b.status === 0) && b.response !== null) {
                      let C = b.response;
                      if (a.type === "json") try {
                        C = JSON.parse(b.response)
                      } catch (I) {
                        return void m(I)
                      }
                      p({
                        data: C,
                        cacheControl: b.getResponseHeader("Cache-Control"),
                        expires: b.getResponseHeader("Expires")
                      })
                    } else {
                      const C = new Blob([b.response], {
                        type: b.getResponseHeader("Content-Type")
                      });
                      m(new H(b.status, b.statusText, a.url, C))
                    }
                }, c.signal.addEventListener("abort", (() => {
                  b.abort(), m(O())
                })), b.send(a.body)
              }))
            })(n, t)
          };

        function ve(n) {
          if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0) return !0;
          const t = new URL(n),
            r = window.location;
          return t.protocol === r.protocol && t.host === r.host
        }

        function he(n, t, r) {
          r[n] && r[n].indexOf(t) !== -1 || (r[n] = r[n] || [], r[n].push(t))
        }

        function Se(n, t, r) {
          if (r && r[n]) {
            const a = r[n].indexOf(t);
            a !== -1 && r[n].splice(a, 1)
          }
        }
        class Ye {
          constructor(t, r = {}) {
            ot(this, r), this.type = t
          }
        }
        class Ze extends Ye {
          constructor(t, r = {}) {
            super("error", ot({
              error: t
            }, r))
          }
        }
        class Tt {
          on(t, r) {
            return this._listeners = this._listeners || {}, he(t, r, this._listeners), {
              unsubscribe: () => {
                this.off(t, r)
              }
            }
          }
          off(t, r) {
            return Se(t, r, this._listeners), Se(t, r, this._oneTimeListeners), this
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, he(t, r, this._oneTimeListeners), this) : new Promise((a => this.once(t, a)))
          }
          fire(t, r) {
            typeof t == "string" && (t = new Ye(t, r || {}));
            const a = t.type;
            if (this.listens(a)) {
              t.target = this;
              const c = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
              for (const v of c) v.call(this, t);
              const p = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
              for (const v of p) Se(a, v, this._oneTimeListeners), v.call(this, t);
              const m = this._eventedParent;
              m && (ot(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), m.fire(t))
            } else t instanceof Ze && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this
          }
        }
        var _e = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            "font-faces": {
              type: "array",
              value: "fontFaces"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            encoding: {
              type: "enum",
              values: {
                mvt: {},
                mlt: {}
              },
              default: "mvt"
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Vt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function ur(n, t) {
          const r = {};
          for (const a in n) a !== "ref" && (r[a] = n[a]);
          return Vt.forEach((a => {
            a in t && (r[a] = t[a])
          })), r
        }

        function Ft(n, t) {
          if (Array.isArray(n)) {
            if (!Array.isArray(t) || n.length !== t.length) return !1;
            for (let r = 0; r < n.length; r++)
              if (!Ft(n[r], t[r])) return !1;
            return !0
          }
          if (typeof n == "object" && n !== null && t !== null) {
            if (typeof t != "object" || Object.keys(n).length !== Object.keys(t).length) return !1;
            for (const r in n)
              if (!Ft(n[r], t[r])) return !1;
            return !0
          }
          return n === t
        }

        function or(n, t) {
          n.push(t)
        }

        function Vr(n, t, r) {
          or(r, {
            command: "addSource",
            args: [n, t[n]]
          })
        }

        function qr(n, t, r) {
          or(t, {
            command: "removeSource",
            args: [n]
          }), r[n] = !0
        }

        function Wr(n, t, r, a) {
          qr(n, r, a), Vr(n, t, r)
        }

        function rn(n, t, r) {
          let a;
          for (a in n[r])
            if (Object.prototype.hasOwnProperty.call(n[r], a) && a !== "data" && !Ft(n[r][a], t[r][a])) return !1;
          for (a in t[r])
            if (Object.prototype.hasOwnProperty.call(t[r], a) && a !== "data" && !Ft(n[r][a], t[r][a])) return !1;
          return !0
        }

        function hn(n, t, r, a, c, p) {
          n = n || {}, t = t || {};
          for (const m in n) Object.prototype.hasOwnProperty.call(n, m) && (Ft(n[m], t[m]) || r.push({
            command: p,
            args: [a, m, t[m], c]
          }));
          for (const m in t) Object.prototype.hasOwnProperty.call(t, m) && !Object.prototype.hasOwnProperty.call(n, m) && (Ft(n[m], t[m]) || r.push({
            command: p,
            args: [a, m, t[m], c]
          }))
        }

        function cn(n) {
          return n.id
        }

        function an(n, t) {
          return n[t.id] = t, n
        }
        class ht {
          constructor(t, r, a, c) {
            this.message = (t ? `${t}: ` : "") + a, c && (this.identifier = c), r != null && r.__line__ && (this.line = r.__line__)
          }
        }

        function un(n, ...t) {
          for (const r of t)
            for (const a in r) n[a] = r[a];
          return n
        }
        class Pn extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t
          }
        }
        class Bt {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [a, c] of r) this.bindings[a] = c
          }
          concat(t) {
            return new Bt(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const st = {
            kind: "null"
          },
          Me = {
            kind: "number"
          },
          ft = {
            kind: "string"
          },
          zt = {
            kind: "boolean"
          },
          ar = {
            kind: "color"
          },
          br = {
            kind: "projectionDefinition"
          },
          Tr = {
            kind: "object"
          },
          Dt = {
            kind: "value"
          },
          Br = {
            kind: "collator"
          },
          Ir = {
            kind: "formatted"
          },
          wr = {
            kind: "padding"
          },
          Xr = {
            kind: "colorArray"
          },
          Mr = {
            kind: "numberArray"
          },
          nn = {
            kind: "resolvedImage"
          },
          sn = {
            kind: "variableAnchorOffsetCollection"
          };

        function dn(n, t) {
          return {
            kind: "array",
            itemType: n,
            N: t
          }
        }

        function _n(n) {
          if (n.kind === "array") {
            const t = _n(n.itemType);
            return typeof n.N == "number" ? `array<${t}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return n.kind
        }
        const Yn = [st, Me, ft, zt, ar, br, Ir, Tr, dn(Dt), wr, Mr, Xr, nn, sn];

        function fi(n, t) {
          if (t.kind === "error") return null;
          if (n.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !fi(n.itemType, t.itemType)) && (typeof n.N != "number" || n.N === t.N)) return null
          } else {
            if (n.kind === t.kind) return null;
            if (n.kind === "value") {
              for (const r of Yn)
                if (!fi(r, t)) return null
            }
          }
          return `Expected ${_n(n)} but found ${_n(t)} instead.`
        }

        function fn(n, t) {
          return t.some((r => r.kind === n.kind))
        }

        function oi(n, t) {
          return t.some((r => r === "null" ? n === null : r === "array" ? Array.isArray(n) : r === "object" ? n && !Array.isArray(n) && typeof n == "object" : r === typeof n))
        }

        function ti(n, t) {
          return n.kind === "array" && t.kind === "array" ? n.itemType.kind === t.itemType.kind && typeof n.N == "number" : n.kind === t.kind
        }
        const xi = .96422,
          Ri = .82521,
          sa = 4 / 29,
          Ci = 6 / 29,
          Vi = 3 * Ci * Ci,
          wa = Ci * Ci * Ci,
          ga = Math.PI / 180,
          Oa = 180 / Math.PI;

        function hs(n) {
          return (n %= 360) < 0 && (n += 360), n
        }

        function Ta([n, t, r, a]) {
          let c, p;
          const m = Yt((.2225045 * (n = vt(n)) + .7168786 * (t = vt(t)) + .0606169 * (r = vt(r))) / 1);
          n === t && t === r ? c = p = m : (c = Yt((.4360747 * n + .3850649 * t + .1430804 * r) / xi), p = Yt((.0139322 * n + .0971045 * t + .7141733 * r) / Ri));
          const v = 116 * m - 16;
          return [v < 0 ? 0 : v, 500 * (c - m), 200 * (m - p), a]
        }

        function vt(n) {
          return n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
        }

        function Yt(n) {
          return n > wa ? Math.pow(n, 1 / 3) : n / Vi + sa
        }

        function Gr([n, t, r, a]) {
          let c = (n + 16) / 116,
            p = isNaN(t) ? c : c + t / 500,
            m = isNaN(r) ? c : c - r / 200;
          return c = 1 * Zn(c), p = xi * Zn(p), m = Ri * Zn(m), [Cn(3.1338561 * p - 1.6168667 * c - .4906146 * m), Cn(-.9787684 * p + 1.9161415 * c + .033454 * m), Cn(.0719453 * p - .2289914 * c + 1.4052427 * m), a]
        }

        function Cn(n) {
          return (n = n <= .00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055) < 0 ? 0 : n > 1 ? 1 : n
        }

        function Zn(n) {
          return n > Ci ? n * n * n : Vi * (n - sa)
        }
        const mi = Object.hasOwn || function(n, t) {
          return Object.prototype.hasOwnProperty.call(n, t)
        };

        function Gn(n, t) {
          return mi(n, t) ? n[t] : void 0
        }

        function An(n) {
          return parseInt(n.padEnd(2, n), 16) / 255
        }

        function qi(n, t) {
          return yr(t ? n / 100 : n, 0, 1)
        }

        function yr(n, t, r) {
          return Math.min(Math.max(t, n), r)
        }

        function dr(n) {
          return !n.some(Number.isNaN)
        }
        const Tn = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function gn(n, t, r) {
          return n + r * (t - n)
        }

        function zn(n, t, r) {
          return n.map(((a, c) => gn(a, t[c], r)))
        }
        class pr {
          constructor(t, r, a, c = 1, p = !0) {
            this.r = t, this.g = r, this.b = a, this.a = c, p || (this.r *= c, this.g *= c, this.b *= c, c || this.overwriteGetter("rgb", [t, r, a, c]))
          }
          static parse(t) {
            if (t instanceof pr) return t;
            if (typeof t != "string") return;
            const r = (function(a) {
              if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const c = Gn(Tn, a);
              if (c) {
                const [m, v, b] = c;
                return [m / 255, v / 255, b / 255, 1]
              }
              if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
                const m = a.length < 6 ? 1 : 2;
                let v = 1;
                return [An(a.slice(v, v += m)), An(a.slice(v, v += m)), An(a.slice(v, v += m)), An(a.slice(v, v + m) || "ff")]
              }
              if (a.startsWith("rgb")) {
                const m = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (m) {
                  const [v, b, C, I, R, U, Z, X, Q, ie, ue, Ne] = m, ye = [I || " ", Z || " ", ie].join("");
                  if (ye === "  " || ye === "  /" || ye === ",," || ye === ",,,") {
                    const Ce = [C, U, Q].join(""),
                      tt = Ce === "%%%" ? 100 : Ce === "" ? 255 : 0;
                    if (tt) {
                      const dt = [yr(+b / tt, 0, 1), yr(+R / tt, 0, 1), yr(+X / tt, 0, 1), ue ? qi(+ue, Ne) : 1];
                      if (dr(dt)) return dt
                    }
                  }
                  return
                }
              }
              const p = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (p) {
                const [m, v, b, C, I, R, U, Z, X] = p, Q = [b || " ", I || " ", U].join("");
                if (Q === "  " || Q === "  /" || Q === ",," || Q === ",,,") {
                  const ie = [+v, yr(+C, 0, 100), yr(+R, 0, 100), Z ? qi(+Z, X) : 1];
                  if (dr(ie)) return (function([ue, Ne, ye, Ce]) {
                    function tt(dt) {
                      const Rt = (dt + ue / 30) % 12,
                        ir = Ne * Math.min(ye, 1 - ye);
                      return ye - ir * Math.max(-1, Math.min(Rt - 3, 9 - Rt, 1))
                    }
                    return ue = hs(ue), Ne /= 100, ye /= 100, [tt(0), tt(8), tt(4), Ce]
                  })(ie)
                }
              }
            })(t);
            return r ? new pr(...r, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: r,
              b: a,
              a: c
            } = this, p = c || 1 / 0;
            return this.overwriteGetter("rgb", [t / p, r / p, a / p, c])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, a, c, p] = Ta(t), m = Math.sqrt(a * a + c * c);
              return [Math.round(1e4 * m) ? hs(Math.atan2(c, a) * Oa) : NaN, m, r, p]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", Ta(this.rgb))
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, {
              value: r
            }), r
          }
          toString() {
            const [t, r, a, c] = this.rgb;
            return `rgba(${[t,r,a].map((p=>Math.round(255*p))).join(",")},${c})`
          }
          static interpolate(t, r, a, c = "rgb") {
            switch (c) {
              case "rgb": {
                const [p, m, v, b] = zn(t.rgb, r.rgb, a);
                return new pr(p, m, v, b, !1)
              }
              case "hcl": {
                const [p, m, v, b] = t.hcl, [C, I, R, U] = r.hcl;
                let Z, X;
                if (isNaN(p) || isNaN(C)) isNaN(p) ? isNaN(C) ? Z = NaN : (Z = C, v !== 1 && v !== 0 || (X = I)) : (Z = p, R !== 1 && R !== 0 || (X = m));
                else {
                  let ye = C - p;
                  C > p && ye > 180 ? ye -= 360 : C < p && p - C > 180 && (ye += 360), Z = p + a * ye
                }
                const [Q, ie, ue, Ne] = (function([ye, Ce, tt, dt]) {
                  return ye = isNaN(ye) ? 0 : ye * ga, Gr([tt, Math.cos(ye) * Ce, Math.sin(ye) * Ce, dt])
                })([Z, X ?? gn(m, I, a), gn(v, R, a), gn(b, U, a)]);
                return new pr(Q, ie, ue, Ne, !1)
              }
              case "lab": {
                const [p, m, v, b] = Gr(zn(t.lab, r.lab, a));
                return new pr(p, m, v, b, !1)
              }
            }
          }
        }
        pr.black = new pr(0, 0, 0, 1), pr.white = new pr(1, 1, 1, 1), pr.transparent = new pr(0, 0, 0, 0), pr.red = new pr(1, 0, 0, 1);
        class Er {
          constructor(t, r, a) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, r) {
            return this.collator.compare(t, r)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const ri = ["bottom", "center", "top"];
        class jn {
          constructor(t, r, a, c, p, m) {
            this.text = t, this.image = r, this.scale = a, this.fontStack = c, this.textColor = p, this.verticalAlign = m
          }
        }
        class Sn {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new Sn([new jn(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof Sn ? t : Sn.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class en {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof en) return t;
            if (typeof t == "number") return new en([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t)
                if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new en(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            return new en(zn(t.values, r.values, a))
          }
        }
        class Rr {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Rr) return t;
            if (typeof t == "number") return new Rr([t]);
            if (Array.isArray(t)) {
              for (const r of t)
                if (typeof r != "number") return;
              return new Rr(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            return new Rr(zn(t.values, r.values, a))
          }
        }
        class vn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof vn) return t;
            if (typeof t == "string") {
              const a = pr.parse(t);
              return a ? new vn([a]) : void 0
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const a of t) {
              if (typeof a != "string") return;
              const c = pr.parse(a);
              if (!c) return;
              r.push(c)
            }
            return new vn(r)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a, c = "rgb") {
            const p = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let m = 0; m < t.values.length; m++) p.push(pr.interpolate(t.values[m], r.values[m], a, c));
            return new vn(p)
          }
        }
        class Yr extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const Ln = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class In {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof In) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const a = t[r],
                  c = t[r + 1];
                if (typeof a != "string" || !Ln.has(a) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number") return
              }
              return new In(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, a) {
            const c = t.values,
              p = r.values;
            if (c.length !== p.length) throw new Yr(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const m = [];
            for (let v = 0; v < c.length; v += 2) {
              if (c[v] !== p[v]) throw new Yr(`Cannot interpolate values containing mismatched anchors. from[${v}]: ${c[v]}, to[${v}]: ${p[v]}`);
              m.push(c[v]);
              const [b, C] = c[v + 1], [I, R] = p[v + 1];
              m.push([gn(b, I, a), gn(C, R, a)])
            }
            return new In(m)
          }
        }
        class Vn {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new Vn({
              name: t,
              available: !1
            }) : null
          }
        }
        class _i {
          constructor(t, r, a) {
            this.from = t, this.to = r, this.transition = a
          }
          static interpolate(t, r, a) {
            return new _i(t, r, a)
          }
          static parse(t) {
            return t instanceof _i ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new _i(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new _i(t.from, t.to, t.transition) : typeof t == "string" ? new _i(t, t, 1) : void 0
          }
        }

        function Ka(n, t, r, a) {
          return typeof n == "number" && n >= 0 && n <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[n,t,r,a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a=="number"?[n,t,r,a]:[n,t,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Pi(n) {
          if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof _i || n instanceof pr || n instanceof Er || n instanceof Sn || n instanceof en || n instanceof Rr || n instanceof vn || n instanceof In || n instanceof Vn) return !0;
          if (Array.isArray(n)) {
            for (const t of n)
              if (!Pi(t)) return !1;
            return !0
          }
          if (typeof n == "object") {
            for (const t in n)
              if (!Pi(n[t])) return !1;
            return !0
          }
          return !1
        }

        function Fn(n) {
          if (n === null) return st;
          if (typeof n == "string") return ft;
          if (typeof n == "boolean") return zt;
          if (typeof n == "number") return Me;
          if (n instanceof pr) return ar;
          if (n instanceof _i) return br;
          if (n instanceof Er) return Br;
          if (n instanceof Sn) return Ir;
          if (n instanceof en) return wr;
          if (n instanceof Rr) return Mr;
          if (n instanceof vn) return Xr;
          if (n instanceof In) return sn;
          if (n instanceof Vn) return nn;
          if (Array.isArray(n)) {
            const t = n.length;
            let r;
            for (const a of n) {
              const c = Fn(a);
              if (r) {
                if (r === c) continue;
                r = Dt;
                break
              }
              r = c
            }
            return dn(r || Dt, t)
          }
          return Tr
        }

        function va(n) {
          const t = typeof n;
          return n === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(n) : n instanceof pr || n instanceof _i || n instanceof Sn || n instanceof en || n instanceof Rr || n instanceof vn || n instanceof In || n instanceof Vn ? n.toString() : JSON.stringify(n)
        }
        class la {
          constructor(t, r) {
            this.type = t, this.value = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Pi(t[1])) return r.error("invalid value");
            const a = t[1];
            let c = Fn(a);
            const p = r.expectedType;
            return c.kind !== "array" || c.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (c = p), new la(c, a)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const ca = {
          string: ft,
          number: Me,
          boolean: zt,
          object: Tr
        };
        class mn {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let a, c = 1;
            const p = t[0];
            if (p === "array") {
              let v, b;
              if (t.length > 2) {
                const C = t[1];
                if (typeof C != "string" || !(C in ca) || C === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                v = ca[C], c++
              } else v = Dt;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                b = t[2], c++
              }
              a = dn(v, b)
            } else {
              if (!ca[p]) throw new Error(`Types doesn't contain name = ${p}`);
              a = ca[p]
            }
            const m = [];
            for (; c < t.length; c++) {
              const v = r.parse(t[c], c, Dt);
              if (!v) return null;
              m.push(v)
            }
            return new mn(a, m)
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const a = this.args[r].evaluate(t);
              if (!fi(this.type, Fn(a))) return a;
              if (r === this.args.length - 1) throw new Yr(`Expected value to be of type ${_n(this.type)}, but found ${_n(Fn(a))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const Na = {
          "to-boolean": zt,
          "to-color": ar,
          "to-number": Me,
          "to-string": ft
        };
        class ln {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const a = t[0];
            if (!Na[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`);
            if ((a === "to-boolean" || a === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const c = Na[a],
              p = [];
            for (let m = 1; m < t.length; m++) {
              const v = r.parse(t[m], m, Dt);
              if (!v) return null;
              p.push(v)
            }
            return new ln(c, p)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, a;
                for (const c of this.args) {
                  if (r = c.evaluate(t), a = null, r instanceof pr) return r;
                  if (typeof r == "string") {
                    const p = t.parseColor(r);
                    if (p) return p
                  } else if (Array.isArray(r) && (a = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : Ka(r[0], r[1], r[2], r[3]), !a)) return new pr(r[0] / 255, r[1] / 255, r[2] / 255, r[3])
                }
                throw new Yr(a || `Could not parse color from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "padding": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = en.parse(r);
                  if (c) return c
                }
                throw new Yr(`Could not parse padding from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "numberArray": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = Rr.parse(r);
                  if (c) return c
                }
                throw new Yr(`Could not parse numberArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "colorArray": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = vn.parse(r);
                  if (c) return c
                }
                throw new Yr(`Could not parse colorArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const a of this.args) {
                  r = a.evaluate(t);
                  const c = In.parse(r);
                  if (c) return c
                }
                throw new Yr(`Could not parse variableAnchorOffsetCollection from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "number": {
                let r = null;
                for (const a of this.args) {
                  if (r = a.evaluate(t), r === null) return 0;
                  const c = Number(r);
                  if (!isNaN(c)) return c
                }
                throw new Yr(`Could not convert ${JSON.stringify(r)} to number.`)
              }
              case "formatted":
                return Sn.fromString(va(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Vn.fromString(va(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return va(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const tn = ["Unknown", "Point", "LineString", "Polygon"];
        class ds {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? tn[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = pr.parse(t), this._parseColorCache.set(t, r)), r
          }
        }
        class yn {
          constructor(t, r, a = [], c, p = new Bt, m = []) {
            this.registry = t, this.path = a, this.key = a.map((v => `[${v}]`)).join(""), this.scope = p, this.errors = m, this.expectedType = c, this._isConstant = r
          }
          parse(t, r, a, c, p = {}) {
            return r ? this.concat(r, a, c)._parse(t, p) : this._parse(t, p)
          }
          _parse(t, r) {
            function a(c, p, m) {
              return m === "assert" ? new mn(p, [c]) : m === "coerce" ? new ln(p, [c]) : c
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = t[0];
              if (typeof c != "string") return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const p = this.registry[c];
              if (p) {
                let m = p.parse(t, this);
                if (!m) return null;
                if (this.expectedType) {
                  const v = this.expectedType,
                    b = m.type;
                  if (v.kind !== "string" && v.kind !== "number" && v.kind !== "boolean" && v.kind !== "object" && v.kind !== "array" || b.kind !== "value") {
                    if (v.kind === "projectionDefinition" && ["string", "array"].includes(b.kind) || ["color", "formatted", "resolvedImage"].includes(v.kind) && ["value", "string"].includes(b.kind) || ["padding", "numberArray"].includes(v.kind) && ["value", "number", "array"].includes(b.kind) || v.kind === "colorArray" && ["value", "string", "array"].includes(b.kind) || v.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(b.kind)) m = a(m, v, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(v, b)) return null
                  } else m = a(m, v, r.typeAnnotation || "assert")
                }
                if (!(m instanceof la) && m.type.kind !== "resolvedImage" && this._isConstant(m)) {
                  const v = new ds;
                  try {
                    m = new la(m.type, m.evaluate(v))
                  } catch (b) {
                    return this.error(b.message), null
                  }
                }
                return m
              }
              return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, r, a) {
            const c = typeof t == "number" ? this.path.concat(t) : this.path,
              p = a ? this.scope.concat(a) : this.scope;
            return new yn(this.registry, this._isConstant, c, r || null, p, this.errors)
          }
          error(t, ...r) {
            const a = `${this.key}${r.map((c=>`[${c}]`)).join("")}`;
            this.errors.push(new Pn(a, t))
          }
          checkSubtype(t, r) {
            const a = fi(t, r);
            return a && this.error(a), a
          }
        }
        class Sa {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result)
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const a = [];
            for (let p = 1; p < t.length - 1; p += 2) {
              const m = t[p];
              if (typeof m != "string") return r.error(`Expected string, but found ${typeof m} instead.`, p);
              if (/[^a-zA-Z0-9_]/.test(m)) return r.error("Variable names must contain only alphanumeric characters or '_'.", p);
              const v = r.parse(t[p + 1], p + 1);
              if (!v) return null;
              a.push([m, v])
            }
            const c = r.parse(t[t.length - 1], t.length - 1, r.expectedType, a);
            return c ? new Sa(a, c) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class ea {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const a = t[1];
            return r.scope.has(a) ? new ea(a, r.scope.get(a)) : r.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class ja {
          constructor(t, r, a) {
            this.type = t, this.index = r, this.input = a
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, Me),
              c = r.parse(t[2], 2, dn(r.expectedType || Dt));
            return a && c ? new ja(c.type.itemType, a, c) : null
          }
          evaluate(t) {
            const r = this.index.evaluate(t),
              a = this.input.evaluate(t);
            if (r < 0) throw new Yr(`Array index out of bounds: ${r} < 0.`);
            if (r >= a.length) throw new Yr(`Array index out of bounds: ${r} > ${a.length-1}.`);
            if (r !== Math.floor(r)) throw new Yr(`Array index must be an integer, but found ${r} instead.`);
            return a[r]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Va {
          constructor(t, r) {
            this.type = zt, this.needle = t, this.haystack = r
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, Dt),
              c = r.parse(t[2], 2, Dt);
            return a && c ? fn(a.type, [zt, ft, Me, st, Dt]) ? new Va(a, c) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${_n(a.type)} instead`) : null
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!a) return !1;
            if (!oi(r, ["boolean", "string", "number", "null"])) throw new Yr(`Expected first argument to be of type boolean, string, number or null, but found ${_n(Fn(r))} instead.`);
            if (!oi(a, ["string", "array"])) throw new Yr(`Expected second argument to be of type array or string, but found ${_n(Fn(a))} instead.`);
            return a.indexOf(r) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class Lo {
          constructor(t, r, a) {
            this.type = Me, this.needle = t, this.haystack = r, this.fromIndex = a
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, Dt),
              c = r.parse(t[2], 2, Dt);
            if (!a || !c) return null;
            if (!fn(a.type, [zt, ft, Me, st, Dt])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${_n(a.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, Me);
              return p ? new Lo(a, c, p) : null
            }
            return new Lo(a, c)
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!oi(r, ["boolean", "string", "number", "null"])) throw new Yr(`Expected first argument to be of type boolean, string, number or null, but found ${_n(Fn(r))} instead.`);
            let c;
            if (this.fromIndex && (c = this.fromIndex.evaluate(t)), oi(a, ["string"])) {
              const p = a.indexOf(r, c);
              return p === -1 ? -1 : [...a.slice(0, p)].length
            }
            if (oi(a, ["array"])) return a.indexOf(r, c);
            throw new Yr(`Expected second argument to be of type array or string, but found ${_n(Fn(a))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class Os {
          constructor(t, r, a, c, p, m) {
            this.inputType = t, this.type = r, this.input = a, this.cases = c, this.outputs = p, this.otherwise = m
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let a, c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const p = {},
              m = [];
            for (let C = 2; C < t.length - 1; C += 2) {
              let I = t[C];
              const R = t[C + 1];
              Array.isArray(I) || (I = [I]);
              const U = r.concat(C);
              if (I.length === 0) return U.error("Expected at least one branch label.");
              for (const X of I) {
                if (typeof X != "number" && typeof X != "string") return U.error("Branch labels must be numbers or strings.");
                if (typeof X == "number" && Math.abs(X) > Number.MAX_SAFE_INTEGER) return U.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof X == "number" && Math.floor(X) !== X) return U.error("Numeric branch labels must be integer values.");
                if (a) {
                  if (U.checkSubtype(a, Fn(X))) return null
                } else a = Fn(X);
                if (p[String(X)] !== void 0) return U.error("Branch labels must be unique.");
                p[String(X)] = m.length
              }
              const Z = r.parse(R, C, c);
              if (!Z) return null;
              c = c || Z.type, m.push(Z)
            }
            const v = r.parse(t[1], 1, Dt);
            if (!v) return null;
            const b = r.parse(t[t.length - 1], t.length - 1, c);
            return b ? v.type.kind !== "value" && r.concat(1).checkSubtype(a, v.type) ? null : new Os(a, c, v, p, m, b) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (Fn(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Tl {
          constructor(t, r, a) {
            this.type = t, this.branches = r, this.otherwise = a
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let a;
            r.expectedType && r.expectedType.kind !== "value" && (a = r.expectedType);
            const c = [];
            for (let m = 1; m < t.length - 1; m += 2) {
              const v = r.parse(t[m], m, zt);
              if (!v) return null;
              const b = r.parse(t[m + 1], m + 1, a);
              if (!b) return null;
              c.push([v, b]), a = a || b.type
            }
            const p = r.parse(t[t.length - 1], t.length - 1, a);
            if (!p) return null;
            if (!a) throw new Error("Can't infer output type");
            return new Tl(a, c, p)
          }
          evaluate(t) {
            for (const [r, a] of this.branches)
              if (r.evaluate(t)) return a.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [r, a] of this.branches) t(r), t(a);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class Sl {
          constructor(t, r, a, c) {
            this.type = t, this.input = r, this.beginIndex = a, this.endIndex = c
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1, Dt),
              c = r.parse(t[2], 2, Me);
            if (!a || !c) return null;
            if (!fn(a.type, [dn(Dt), ft, Dt])) return r.error(`Expected first argument to be of type array or string, but found ${_n(a.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, Me);
              return p ? new Sl(a.type, a, c, p) : null
            }
            return new Sl(a.type, a, c)
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              a = this.beginIndex.evaluate(t);
            let c;
            if (this.endIndex && (c = this.endIndex.evaluate(t)), oi(r, ["string"])) return [...r].slice(a, c).join("");
            if (oi(r, ["array"])) return r.slice(a, c);
            throw new Yr(`Expected first argument to be of type array or string, but found ${_n(Fn(r))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function Ns(n, t) {
          const r = n.length - 1;
          let a, c, p = 0,
            m = r,
            v = 0;
          for (; p <= m;)
            if (v = Math.floor((p + m) / 2), a = n[v], c = n[v + 1], a <= t) {
              if (v === r || t < c) return v;
              p = v + 1
            } else {
              if (!(a > t)) throw new Yr("Input is not a number.");
              m = v - 1
            } return 0
        }
        class ps {
          constructor(t, r, a) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [c, p] of a) this.labels.push(c), this.outputs.push(p)
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const a = r.parse(t[1], 1, Me);
            if (!a) return null;
            const c = [];
            let p = null;
            r.expectedType && r.expectedType.kind !== "value" && (p = r.expectedType);
            for (let m = 1; m < t.length; m += 2) {
              const v = m === 1 ? -1 / 0 : t[m],
                b = t[m + 1],
                C = m,
                I = m + 1;
              if (typeof v != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
              if (c.length && c[c.length - 1][0] >= v) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', C);
              const R = r.parse(b, I, p);
              if (!R) return null;
              p = p || R.type, c.push([v, R])
            }
            return new ps(p, a, c)
          }
          evaluate(t) {
            const r = this.labels,
              a = this.outputs;
            if (r.length === 1) return a[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return a[0].evaluate(t);
            const p = r.length;
            return c >= r[p - 1] ? a[p - 1].evaluate(t) : a[Ns(r, c)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function vo(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var Ii, js, Qh = (function() {
            if (js) return Ii;

            function n(t, r, a, c) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = a, this.p2y = c
            }
            return js = 1, Ii = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, c = 0; c < 8; c++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < r) return a;
                  var m = this.sampleCurveDerivativeX(a);
                  if (Math.abs(m) < 1e-6) break;
                  a -= p / m
                }
                var v = 0,
                  b = 1;
                for (a = t, c = 0; c < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < r)); c++) t > p ? v = a : b = a, a = .5 * (b - v) + v;
                return a
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, Ii
          })(),
          Cl = vo(Qh);
        class kn {
          constructor(t, r, a, c, p) {
            this.type = t, this.operator = r, this.interpolation = a, this.input = c, this.labels = [], this.outputs = [];
            for (const [m, v] of p) this.labels.push(m), this.outputs.push(v)
          }
          static interpolationFactor(t, r, a, c) {
            let p = 0;
            if (t.name === "exponential") p = Pl(r, t.base, a, c);
            else if (t.name === "linear") p = Pl(r, 1, a, c);
            else if (t.name === "cubic-bezier") {
              const m = t.controlPoints;
              p = new Cl(m[0], m[1], m[2], m[3]).solve(Pl(r, 1, a, c))
            }
            return p
          }
          static parse(t, r) {
            let [a, c, p, ...m] = t;
            if (!Array.isArray(c) || c.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = {
              name: "linear"
            };
            else if (c[0] === "exponential") {
              const C = c[1];
              if (typeof C != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = {
                name: "exponential",
                base: C
              }
            } else {
              if (c[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const C = c.slice(1);
                if (C.length !== 4 || C.some((I => typeof I != "number" || I < 0 || I > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = {
                  name: "cubic-bezier",
                  controlPoints: C
                }
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (p = r.parse(p, 2, Me), !p) return null;
            const v = [];
            let b = null;
            a !== "interpolate-hcl" && a !== "interpolate-lab" || r.expectedType == Xr ? r.expectedType && r.expectedType.kind !== "value" && (b = r.expectedType) : b = ar;
            for (let C = 0; C < m.length; C += 2) {
              const I = m[C],
                R = m[C + 1],
                U = C + 3,
                Z = C + 4;
              if (typeof I != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', U);
              if (v.length && v[v.length - 1][0] >= I) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', U);
              const X = r.parse(R, Z, b);
              if (!X) return null;
              b = b || X.type, v.push([I, X])
            }
            return ti(b, Me) || ti(b, br) || ti(b, ar) || ti(b, wr) || ti(b, Mr) || ti(b, Xr) || ti(b, sn) || ti(b, dn(Me)) ? new kn(b, a, c, p, v) : r.error(`Type ${_n(b)} is not interpolatable.`)
          }
          evaluate(t) {
            const r = this.labels,
              a = this.outputs;
            if (r.length === 1) return a[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return a[0].evaluate(t);
            const p = r.length;
            if (c >= r[p - 1]) return a[p - 1].evaluate(t);
            const m = Ns(r, c),
              v = kn.interpolationFactor(this.interpolation, c, r[m], r[m + 1]),
              b = a[m].evaluate(t),
              C = a[m + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return gn(b, C, v);
                  case "color":
                    return pr.interpolate(b, C, v);
                  case "padding":
                    return en.interpolate(b, C, v);
                  case "colorArray":
                    return vn.interpolate(b, C, v);
                  case "numberArray":
                    return Rr.interpolate(b, C, v);
                  case "variableAnchorOffsetCollection":
                    return In.interpolate(b, C, v);
                  case "array":
                    return zn(b, C, v);
                  case "projectionDefinition":
                    return _i.interpolate(b, C, v)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return pr.interpolate(b, C, v, "hcl");
                  case "colorArray":
                    return vn.interpolate(b, C, v, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return pr.interpolate(b, C, v, "lab");
                  case "colorArray":
                    return vn.interpolate(b, C, v, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function Pl(n, t, r, a) {
          const c = a - r,
            p = n - r;
          return c === 0 ? 0 : t === 1 ? p / c : (Math.pow(t, p) - 1) / (Math.pow(t, c) - 1)
        }
        const ya = {
          color: pr.interpolate,
          number: gn,
          padding: en.interpolate,
          numberArray: Rr.interpolate,
          colorArray: vn.interpolate,
          variableAnchorOffsetCollection: In.interpolate,
          array: zn
        };
        class Vs {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let a = null;
            const c = r.expectedType;
            c && c.kind !== "value" && (a = c);
            const p = [];
            for (const v of t.slice(1)) {
              const b = r.parse(v, 1 + p.length, a, void 0, {
                typeAnnotation: "omit"
              });
              if (!b) return null;
              a = a || b.type, p.push(b)
            }
            if (!a) throw new Error("No output type");
            const m = c && p.some((v => fi(c, v.type)));
            return new Vs(m ? Dt : a, p)
          }
          evaluate(t) {
            let r, a = null,
              c = 0;
            for (const p of this.args)
              if (c++, a = p.evaluate(t), a && a instanceof Vn && !a.available && (r || (r = a.name), a = null, c === this.args.length && (a = r)), a !== null) break;
            return a
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function ed(n, t) {
          return n === "==" || n === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function Do(n, t, r, a) {
          return a.compare(t, r) === 0
        }

        function Ja(n, t, r) {
          const a = n !== "==" && n !== "!=";
          return class J0 {
            constructor(p, m, v) {
              this.type = zt, this.lhs = p, this.rhs = m, this.collator = v, this.hasUntypedArgument = p.type.kind === "value" || m.type.kind === "value"
            }
            static parse(p, m) {
              if (p.length !== 3 && p.length !== 4) return m.error("Expected two or three arguments.");
              const v = p[0];
              let b = m.parse(p[1], 1, Dt);
              if (!b) return null;
              if (!ed(v, b.type)) return m.concat(1).error(`"${v}" comparisons are not supported for type '${_n(b.type)}'.`);
              let C = m.parse(p[2], 2, Dt);
              if (!C) return null;
              if (!ed(v, C.type)) return m.concat(2).error(`"${v}" comparisons are not supported for type '${_n(C.type)}'.`);
              if (b.type.kind !== C.type.kind && b.type.kind !== "value" && C.type.kind !== "value") return m.error(`Cannot compare types '${_n(b.type)}' and '${_n(C.type)}'.`);
              a && (b.type.kind === "value" && C.type.kind !== "value" ? b = new mn(C.type, [b]) : b.type.kind !== "value" && C.type.kind === "value" && (C = new mn(b.type, [C])));
              let I = null;
              if (p.length === 4) {
                if (b.type.kind !== "string" && C.type.kind !== "string" && b.type.kind !== "value" && C.type.kind !== "value") return m.error("Cannot use collator to compare non-string types.");
                if (I = m.parse(p[3], 3, Br), !I) return null
              }
              return new J0(b, C, I)
            }
            evaluate(p) {
              const m = this.lhs.evaluate(p),
                v = this.rhs.evaluate(p);
              if (a && this.hasUntypedArgument) {
                const b = Fn(m),
                  C = Fn(v);
                if (b.kind !== C.kind || b.kind !== "string" && b.kind !== "number") throw new Yr(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${b.kind}, ${C.kind}) instead.`)
              }
              if (this.collator && !a && this.hasUntypedArgument) {
                const b = Fn(m),
                  C = Fn(v);
                if (b.kind !== "string" || C.kind !== "string") return t(p, m, v)
              }
              return this.collator ? r(p, m, v, this.collator.evaluate(p)) : t(p, m, v)
            }
            eachChild(p) {
              p(this.lhs), p(this.rhs), this.collator && p(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const jc = Ja("==", (function(n, t, r) {
            return t === r
          }), Do),
          rf = Ja("!=", (function(n, t, r) {
            return t !== r
          }), (function(n, t, r, a) {
            return !Do(0, t, r, a)
          })),
          td = Ja("<", (function(n, t, r) {
            return t < r
          }), (function(n, t, r, a) {
            return a.compare(t, r) < 0
          })),
          Il = Ja(">", (function(n, t, r) {
            return t > r
          }), (function(n, t, r, a) {
            return a.compare(t, r) > 0
          })),
          Ml = Ja("<=", (function(n, t, r) {
            return t <= r
          }), (function(n, t, r, a) {
            return a.compare(t, r) <= 0
          })),
          Ca = Ja(">=", (function(n, t, r) {
            return t >= r
          }), (function(n, t, r, a) {
            return a.compare(t, r) >= 0
          }));
        class qs {
          constructor(t, r, a) {
            this.type = Br, this.locale = a, this.caseSensitive = t, this.diacriticSensitive = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const a = t[1];
            if (typeof a != "object" || Array.isArray(a)) return r.error("Collator options argument must be an object.");
            const c = r.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, zt);
            if (!c) return null;
            const p = r.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, zt);
            if (!p) return null;
            let m = null;
            return a.locale && (m = r.parse(a.locale, 1, ft), !m) ? null : new qs(c, p, m)
          }
          evaluate(t) {
            return new Er(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class fs {
          constructor(t, r, a, c, p) {
            this.type = ft, this.number = t, this.locale = r, this.currency = a, this.minFractionDigits = c, this.maxFractionDigits = p
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const a = r.parse(t[1], 1, Me);
            if (!a) return null;
            const c = t[2];
            if (typeof c != "object" || Array.isArray(c)) return r.error("NumberFormat options argument must be an object.");
            let p = null;
            if (c.locale && (p = r.parse(c.locale, 1, ft), !p)) return null;
            let m = null;
            if (c.currency && (m = r.parse(c.currency, 1, ft), !m)) return null;
            let v = null;
            if (c["min-fraction-digits"] && (v = r.parse(c["min-fraction-digits"], 1, Me), !v)) return null;
            let b = null;
            return c["max-fraction-digits"] && (b = r.parse(c["max-fraction-digits"], 1, Me), !b) ? null : new fs(a, p, m, v, b)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class Al {
          constructor(t) {
            this.type = Ir, this.sections = t
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const a = t[1];
            if (!Array.isArray(a) && typeof a == "object") return r.error("First argument must be an image or text section.");
            const c = [];
            let p = !1;
            for (let m = 1; m <= t.length - 1; ++m) {
              const v = t[m];
              if (p && typeof v == "object" && !Array.isArray(v)) {
                p = !1;
                let b = null;
                if (v["font-scale"] && (b = r.parse(v["font-scale"], 1, Me), !b)) return null;
                let C = null;
                if (v["text-font"] && (C = r.parse(v["text-font"], 1, dn(ft)), !C)) return null;
                let I = null;
                if (v["text-color"] && (I = r.parse(v["text-color"], 1, ar), !I)) return null;
                let R = null;
                if (v["vertical-align"]) {
                  if (typeof v["vertical-align"] == "string" && !ri.includes(v["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${v["vertical-align"]}' instead.`);
                  if (R = r.parse(v["vertical-align"], 1, ft), !R) return null
                }
                const U = c[c.length - 1];
                U.scale = b, U.font = C, U.textColor = I, U.verticalAlign = R
              } else {
                const b = r.parse(t[m], 1, Dt);
                if (!b) return null;
                const C = b.type.kind;
                if (C !== "string" && C !== "value" && C !== "null" && C !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                p = !0, c.push({
                  content: b,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new Al(c)
          }
          evaluate(t) {
            return new Sn(this.sections.map((r => {
              const a = r.content.evaluate(t);
              return Fn(a) === nn ? new jn("", a, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new jn(va(a), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Us {
          constructor(t) {
            this.type = nn, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const a = r.parse(t[1], 1, ft);
            return a ? new Us(a) : r.error("No image name provided.")
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              a = Vn.fromString(r);
            return a && t.availableImages && (a.available = t.availableImages.indexOf(r) > -1), a
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Vc {
          constructor(t) {
            this.type = Me, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = r.parse(t[1], 1);
            return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${_n(a.type)} instead.`) : new Vc(a) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new Yr(`Expected value to be of type string or array, but found ${_n(Fn(r))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const qa = 8192;

        function nf(n, t) {
          const r = (180 + n[0]) / 360,
            a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360,
            c = Math.pow(2, t.z);
          return [Math.round(r * c * qa), Math.round(a * c * qa)]
        }

        function qc(n, t) {
          const r = Math.pow(2, t.z);
          return [(c = (n[0] / qa + t.x) / r, 360 * c - 180), (a = (n[1] / qa + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
          var a, c
        }

        function yo(n, t) {
          n[0] = Math.min(n[0], t[0]), n[1] = Math.min(n[1], t[1]), n[2] = Math.max(n[2], t[0]), n[3] = Math.max(n[3], t[1])
        }

        function Zs(n, t) {
          return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3])
        }

        function rd(n, t, r) {
          const a = n[0] - t[0],
            c = n[1] - t[1],
            p = n[0] - r[0],
            m = n[1] - r[1];
          return a * m - p * c == 0 && a * p <= 0 && c * m <= 0
        }

        function Gs(n, t, r, a) {
          return (c = [a[0] - r[0], a[1] - r[1]])[0] * (p = [t[0] - n[0], t[1] - n[1]])[1] - c[1] * p[0] != 0 && !(!id(n, t, r, a) || !id(r, a, n, t));
          var c, p
        }

        function af(n, t, r) {
          for (const a of r)
            for (let c = 0; c < a.length - 1; ++c)
              if (Gs(n, t, a[c], a[c + 1])) return !0;
          return !1
        }

        function Ro(n, t, r = !1) {
          let a = !1;
          for (const v of t)
            for (let b = 0; b < v.length - 1; b++) {
              if (rd(n, v[b], v[b + 1])) return r;
              (p = v[b])[1] > (c = n)[1] != (m = v[b + 1])[1] > c[1] && c[0] < (m[0] - p[0]) * (c[1] - p[1]) / (m[1] - p[1]) + p[0] && (a = !a)
            }
          var c, p, m;
          return a
        }

        function of(n, t) {
          for (const r of t)
            if (Ro(n, r)) return !0;
          return !1
        }

        function nd(n, t) {
          for (const r of n)
            if (!Ro(r, t)) return !1;
          for (let r = 0; r < n.length - 1; ++r)
            if (af(n[r], n[r + 1], t)) return !1;
          return !0
        }

        function sf(n, t) {
          for (const r of t)
            if (nd(n, r)) return !0;
          return !1
        }

        function id(n, t, r, a) {
          const c = a[0] - r[0],
            p = a[1] - r[1],
            m = (n[0] - r[0]) * p - c * (n[1] - r[1]),
            v = (t[0] - r[0]) * p - c * (t[1] - r[1]);
          return m > 0 && v < 0 || m < 0 && v > 0
        }

        function Uc(n, t, r) {
          const a = [];
          for (let c = 0; c < n.length; c++) {
            const p = [];
            for (let m = 0; m < n[c].length; m++) {
              const v = nf(n[c][m], r);
              yo(t, v), p.push(v)
            }
            a.push(p)
          }
          return a
        }

        function Zc(n, t, r) {
          const a = [];
          for (let c = 0; c < n.length; c++) {
            const p = Uc(n[c], t, r);
            a.push(p)
          }
          return a
        }

        function Gc(n, t, r, a) {
          if (n[0] < r[0] || n[0] > r[2]) {
            const c = .5 * a;
            let p = n[0] - r[0] > c ? -a : r[0] - n[0] > c ? a : 0;
            p === 0 && (p = n[0] - r[2] > c ? -a : r[2] - n[0] > c ? a : 0), n[0] += p
          }
          yo(t, n)
        }

        function $c(n, t, r, a) {
          const c = Math.pow(2, a.z) * qa,
            p = [a.x * qa, a.y * qa],
            m = [];
          for (const v of n)
            for (const b of v) {
              const C = [b.x + p[0], b.y + p[1]];
              Gc(C, t, r, c), m.push(C)
            }
          return m
        }

        function ad(n, t, r, a) {
          const c = Math.pow(2, a.z) * qa,
            p = [a.x * qa, a.y * qa],
            m = [];
          for (const b of n) {
            const C = [];
            for (const I of b) {
              const R = [I.x + p[0], I.y + p[1]];
              yo(t, R), C.push(R)
            }
            m.push(C)
          }
          if (t[2] - t[0] <= c / 2) {
            (v = t)[0] = v[1] = 1 / 0, v[2] = v[3] = -1 / 0;
            for (const b of m)
              for (const C of b) Gc(C, t, r, c)
          }
          var v;
          return m
        }
        class Fo {
          constructor(t, r) {
            this.type = zt, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Pi(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") {
                const c = [];
                for (const p of a.features) {
                  const {
                    type: m,
                    coordinates: v
                  } = p.geometry;
                  m === "Polygon" && c.push(v), m === "MultiPolygon" && c.push(...v)
                }
                if (c.length) return new Fo(a, {
                  type: "MultiPolygon",
                  coordinates: c
                })
              } else if (a.type === "Feature") {
                const c = a.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new Fo(a, a.geometry)
              } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new Fo(a, a)
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, a) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = r.canonicalID();
                if (a.type === "Polygon") {
                  const v = Uc(a.coordinates, p, m),
                    b = $c(r.geometry(), c, p, m);
                  if (!Zs(c, p)) return !1;
                  for (const C of b)
                    if (!Ro(C, v)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const v = Zc(a.coordinates, p, m),
                    b = $c(r.geometry(), c, p, m);
                  if (!Zs(c, p)) return !1;
                  for (const C of b)
                    if (!of(C, v)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, a) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = r.canonicalID();
                if (a.type === "Polygon") {
                  const v = Uc(a.coordinates, p, m),
                    b = ad(r.geometry(), c, p, m);
                  if (!Zs(c, p)) return !1;
                  for (const C of b)
                    if (!nd(C, v)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const v = Zc(a.coordinates, p, m),
                    b = ad(r.geometry(), c, p, m);
                  if (!Zs(c, p)) return !1;
                  for (const C of b)
                    if (!sf(C, v)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let od = class {
          constructor(n = [], t = (r, a) => r < a ? -1 : r > a ? 1 : 0) {
            if (this.data = n, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r)
          }
          push(n) {
            this.data.push(n), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const n = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), n
          }
          peek() {
            return this.data[0]
          }
          _up(n) {
            const {
              data: t,
              compare: r
            } = this, a = t[n];
            for (; n > 0;) {
              const c = n - 1 >> 1,
                p = t[c];
              if (r(a, p) >= 0) break;
              t[n] = p, n = c
            }
            t[n] = a
          }
          _down(n) {
            const {
              data: t,
              compare: r
            } = this, a = this.length >> 1, c = t[n];
            for (; n < a;) {
              let p = 1 + (n << 1);
              const m = p + 1;
              if (m < this.length && r(t[m], t[p]) < 0 && (p = m), r(t[p], c) >= 0) break;
              t[n] = t[p], n = p
            }
            t[n] = c
          }
        };

        function sd(n, t, r = 0, a = n.length - 1, c = lf) {
          for (; a > r;) {
            if (a - r > 600) {
              const b = a - r + 1,
                C = t - r + 1,
                I = Math.log(b),
                R = .5 * Math.exp(2 * I / 3),
                U = .5 * Math.sqrt(I * R * (b - R) / b) * (C - b / 2 < 0 ? -1 : 1);
              sd(n, t, Math.max(r, Math.floor(t - C * R / b + U)), Math.min(a, Math.floor(t + (b - C) * R / b + U)), c)
            }
            const p = n[t];
            let m = r,
              v = a;
            for (xo(n, r, t), c(n[a], p) > 0 && xo(n, r, a); m < v;) {
              for (xo(n, m, v), m++, v--; c(n[m], p) < 0;) m++;
              for (; c(n[v], p) > 0;) v--
            }
            c(n[r], p) === 0 ? xo(n, r, v) : (v++, xo(n, v, a)), v <= t && (r = v + 1), t <= v && (a = v - 1)
          }
        }

        function xo(n, t, r) {
          const a = n[t];
          n[t] = n[r], n[r] = a
        }

        function lf(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function kl(n, t) {
          if (n.length <= 1) return [n];
          const r = [];
          let a, c;
          for (const p of n) {
            const m = uf(p);
            m !== 0 && (p.area = Math.abs(m), c === void 0 && (c = m < 0), c === m < 0 ? (a && r.push(a), a = [p]) : a.push(p))
          }
          if (a && r.push(a), t > 1)
            for (let p = 0; p < r.length; p++) r[p].length <= t || (sd(r[p], t, 1, r[p].length - 1, cf), r[p] = r[p].slice(0, t));
          return r
        }

        function cf(n, t) {
          return t.area - n.area
        }

        function uf(n) {
          let t = 0;
          for (let r, a, c = 0, p = n.length, m = p - 1; c < p; m = c++) r = n[c], a = n[m], t += (a.x - r.x) * (r.y + a.y);
          return t
        }
        const El = 1 / 298.257223563,
          Hc = El * (2 - El),
          ld = Math.PI / 180;
        class Wc {
          constructor(t) {
            const r = 6378.137 * ld * 1e3,
              a = Math.cos(t * ld),
              c = 1 / (1 - Hc * (1 - a * a)),
              p = Math.sqrt(c);
            this.kx = r * p * a, this.ky = r * p * c * (1 - Hc)
          }
          distance(t, r) {
            const a = this.wrap(t[0] - r[0]) * this.kx,
              c = (t[1] - r[1]) * this.ky;
            return Math.sqrt(a * a + c * c)
          }
          pointOnLine(t, r) {
            let a, c, p, m, v = 1 / 0;
            for (let b = 0; b < t.length - 1; b++) {
              let C = t[b][0],
                I = t[b][1],
                R = this.wrap(t[b + 1][0] - C) * this.kx,
                U = (t[b + 1][1] - I) * this.ky,
                Z = 0;
              R === 0 && U === 0 || (Z = (this.wrap(r[0] - C) * this.kx * R + (r[1] - I) * this.ky * U) / (R * R + U * U), Z > 1 ? (C = t[b + 1][0], I = t[b + 1][1]) : Z > 0 && (C += R / this.kx * Z, I += U / this.ky * Z)), R = this.wrap(r[0] - C) * this.kx, U = (r[1] - I) * this.ky;
              const X = R * R + U * U;
              X < v && (v = X, a = C, c = I, p = b, m = Z)
            }
            return {
              point: [a, c],
              index: p,
              t: Math.max(0, Math.min(1, m))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function Xc(n, t) {
          return t[0] - n[0]
        }

        function $s(n) {
          return n[1] - n[0] + 1
        }

        function Qa(n, t) {
          return n[1] >= n[0] && n[1] < t
        }

        function Yc(n, t) {
          if (n[0] > n[1]) return [null, null];
          const r = $s(n);
          if (t) {
            if (r === 2) return [n, null];
            const c = Math.floor(r / 2);
            return [
              [n[0], n[0] + c],
              [n[0] + c, n[1]]
            ]
          }
          if (r === 1) return [n, null];
          const a = Math.floor(r / 2) - 1;
          return [
            [n[0], n[0] + a],
            [n[0] + a + 1, n[1]]
          ]
        }

        function Kc(n, t) {
          if (!Qa(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let a = t[0]; a <= t[1]; ++a) yo(r, n[a]);
          return r
        }

        function zl(n) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of n)
            for (const a of r) yo(t, a);
          return t
        }

        function cd(n) {
          return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0
        }

        function Jc(n, t, r) {
          if (!cd(n) || !cd(t)) return NaN;
          let a = 0,
            c = 0;
          return n[2] < t[0] && (a = t[0] - n[2]), n[0] > t[2] && (a = n[0] - t[2]), n[1] > t[3] && (c = n[1] - t[3]), n[3] < t[1] && (c = t[1] - n[3]), r.distance([0, 0], [a, c])
        }

        function Bo(n, t, r) {
          const a = r.pointOnLine(t, n);
          return r.distance(n, a.point)
        }

        function Qc(n, t, r, a, c) {
          const p = Math.min(Bo(n, [r, a], c), Bo(t, [r, a], c)),
            m = Math.min(Bo(r, [n, t], c), Bo(a, [n, t], c));
          return Math.min(p, m)
        }

        function Mn(n, t, r, a, c) {
          if (!Qa(t, n.length) || !Qa(a, r.length)) return 1 / 0;
          let p = 1 / 0;
          for (let m = t[0]; m < t[1]; ++m) {
            const v = n[m],
              b = n[m + 1];
            for (let C = a[0]; C < a[1]; ++C) {
              const I = r[C],
                R = r[C + 1];
              if (Gs(v, b, I, R)) return 0;
              p = Math.min(p, Qc(v, b, I, R, c))
            }
          }
          return p
        }

        function hf(n, t, r, a, c) {
          if (!Qa(t, n.length) || !Qa(a, r.length)) return NaN;
          let p = 1 / 0;
          for (let m = t[0]; m <= t[1]; ++m)
            for (let v = a[0]; v <= a[1]; ++v)
              if (p = Math.min(p, c.distance(n[m], r[v])), p === 0) return p;
          return p
        }

        function df(n, t, r) {
          if (Ro(n, t, !0)) return 0;
          let a = 1 / 0;
          for (const c of t) {
            const p = c[0],
              m = c[c.length - 1];
            if (p !== m && (a = Math.min(a, Bo(n, [m, p], r)), a === 0)) return a;
            const v = r.pointOnLine(c, n);
            if (a = Math.min(a, r.distance(n, v.point)), a === 0) return a
          }
          return a
        }

        function pf(n, t, r, a) {
          if (!Qa(t, n.length)) return NaN;
          for (let p = t[0]; p <= t[1]; ++p)
            if (Ro(n[p], r, !0)) return 0;
          let c = 1 / 0;
          for (let p = t[0]; p < t[1]; ++p) {
            const m = n[p],
              v = n[p + 1];
            for (const b of r)
              for (let C = 0, I = b.length, R = I - 1; C < I; R = C++) {
                const U = b[R],
                  Z = b[C];
                if (Gs(m, v, U, Z)) return 0;
                c = Math.min(c, Qc(m, v, U, Z, a))
              }
          }
          return c
        }

        function ud(n, t) {
          for (const r of n)
            for (const a of r)
              if (Ro(a, t, !0)) return !0;
          return !1
        }

        function ff(n, t, r, a = 1 / 0) {
          const c = zl(n),
            p = zl(t);
          if (a !== 1 / 0 && Jc(c, p, r) >= a) return a;
          if (Zs(c, p)) {
            if (ud(n, t)) return 0
          } else if (ud(t, n)) return 0;
          let m = 1 / 0;
          for (const v of n)
            for (let b = 0, C = v.length, I = C - 1; b < C; I = b++) {
              const R = v[I],
                U = v[b];
              for (const Z of t)
                for (let X = 0, Q = Z.length, ie = Q - 1; X < Q; ie = X++) {
                  const ue = Z[ie],
                    Ne = Z[X];
                  if (Gs(R, U, ue, Ne)) return 0;
                  m = Math.min(m, Qc(R, U, ue, Ne, r))
                }
            }
          return m
        }

        function hd(n, t, r, a, c, p) {
          if (!p) return;
          const m = Jc(Kc(a, p), c, r);
          m < t && n.push([m, p, [0, 0]])
        }

        function Ll(n, t, r, a, c, p, m) {
          if (!p || !m) return;
          const v = Jc(Kc(a, p), Kc(c, m), r);
          v < t && n.push([v, p, m])
        }

        function Dl(n, t, r, a, c = 1 / 0) {
          let p = Math.min(a.distance(n[0], r[0][0]), c);
          if (p === 0) return p;
          const m = new od([
              [0, [0, n.length - 1],
                [0, 0]
              ]
            ], Xc),
            v = zl(r);
          for (; m.length > 0;) {
            const b = m.pop();
            if (b[0] >= p) continue;
            const C = b[1],
              I = t ? 50 : 100;
            if ($s(C) <= I) {
              if (!Qa(C, n.length)) return NaN;
              if (t) {
                const R = pf(n, C, r, a);
                if (isNaN(R) || R === 0) return R;
                p = Math.min(p, R)
              } else
                for (let R = C[0]; R <= C[1]; ++R) {
                  const U = df(n[R], r, a);
                  if (p = Math.min(p, U), p === 0) return 0
                }
            } else {
              const R = Yc(C, t);
              hd(m, p, a, n, v, R[0]), hd(m, p, a, n, v, R[1])
            }
          }
          return p
        }

        function Rl(n, t, r, a, c, p = 1 / 0) {
          let m = Math.min(p, c.distance(n[0], r[0]));
          if (m === 0) return m;
          const v = new od([
            [0, [0, n.length - 1],
              [0, r.length - 1]
            ]
          ], Xc);
          for (; v.length > 0;) {
            const b = v.pop();
            if (b[0] >= m) continue;
            const C = b[1],
              I = b[2],
              R = t ? 50 : 100,
              U = a ? 50 : 100;
            if ($s(C) <= R && $s(I) <= U) {
              if (!Qa(C, n.length) && Qa(I, r.length)) return NaN;
              let Z;
              if (t && a) Z = Mn(n, C, r, I, c), m = Math.min(m, Z);
              else if (t && !a) {
                const X = n.slice(C[0], C[1] + 1);
                for (let Q = I[0]; Q <= I[1]; ++Q)
                  if (Z = Bo(r[Q], X, c), m = Math.min(m, Z), m === 0) return m
              } else if (!t && a) {
                const X = r.slice(I[0], I[1] + 1);
                for (let Q = C[0]; Q <= C[1]; ++Q)
                  if (Z = Bo(n[Q], X, c), m = Math.min(m, Z), m === 0) return m
              } else Z = hf(n, C, r, I, c), m = Math.min(m, Z)
            } else {
              const Z = Yc(C, t),
                X = Yc(I, a);
              Ll(v, m, c, n, r, Z[0], X[0]), Ll(v, m, c, n, r, Z[0], X[1]), Ll(v, m, c, n, r, Z[1], X[0]), Ll(v, m, c, n, r, Z[1], X[1])
            }
          }
          return m
        }

        function eu(n) {
          return n.type === "MultiPolygon" ? n.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : n.type === "MultiLineString" ? n.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : n.type === "MultiPoint" ? n.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [n]
        }
        class Oo {
          constructor(t, r) {
            this.type = Me, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Pi(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") return new Oo(a, a.features.map((c => eu(c.geometry))).flat());
              if (a.type === "Feature") return new Oo(a, eu(a.geometry));
              if ("type" in a && "coordinates" in a) return new Oo(a, eu(a))
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, a) {
                const c = r.geometry(),
                  p = c.flat().map((b => qc([b.x, b.y], r.canonical)));
                if (c.length === 0) return NaN;
                const m = new Wc(p[0][1]);
                let v = 1 / 0;
                for (const b of a) {
                  switch (b.type) {
                    case "Point":
                      v = Math.min(v, Rl(p, !1, [b.coordinates], !1, m, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Rl(p, !1, b.coordinates, !0, m, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Dl(p, !1, b.coordinates, m, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, a) {
                const c = r.geometry(),
                  p = c.flat().map((b => qc([b.x, b.y], r.canonical)));
                if (c.length === 0) return NaN;
                const m = new Wc(p[0][1]);
                let v = 1 / 0;
                for (const b of a) {
                  switch (b.type) {
                    case "Point":
                      v = Math.min(v, Rl(p, !0, [b.coordinates], !1, m, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Rl(p, !0, b.coordinates, !0, m, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Dl(p, !0, b.coordinates, m, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, a) {
                const c = r.geometry();
                if (c.length === 0 || c[0].length === 0) return NaN;
                const p = kl(c, 0).map((b => b.map((C => C.map((I => qc([I.x, I.y], r.canonical))))))),
                  m = new Wc(p[0][0][0][1]);
                let v = 1 / 0;
                for (const b of a)
                  for (const C of p) {
                    switch (b.type) {
                      case "Point":
                        v = Math.min(v, Dl([b.coordinates], !1, C, m, v));
                        break;
                      case "LineString":
                        v = Math.min(v, Dl(b.coordinates, !0, C, m, v));
                        break;
                      case "Polygon":
                        v = Math.min(v, ff(C, b.coordinates, m, v))
                    }
                    if (v === 0) return v
                  }
                return v
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Hs {
          constructor(t) {
            this.type = Dt, this.key = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = t[1];
            return a == null ? r.error("Global state property must be defined.") : typeof a != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Hs(a)
          }
          evaluate(t) {
            var r;
            const a = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return a && Object.keys(a).length !== 0 ? Gn(a, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const ms = {
          "==": jc,
          "!=": rf,
          ">": Il,
          "<": td,
          ">=": Ca,
          "<=": Ml,
          array: mn,
          at: ja,
          boolean: mn,
          case: Tl,
          coalesce: Vs,
          collator: qs,
          format: Al,
          image: Us,
          in: Va,
          "index-of": Lo,
          interpolate: kn,
          "interpolate-hcl": kn,
          "interpolate-lab": kn,
          length: Vc,
          let: Sa,
          literal: la,
          match: Os,
          number: mn,
          "number-format": fs,
          object: mn,
          slice: Sl,
          step: ps,
          string: mn,
          "to-boolean": ln,
          "to-color": ln,
          "to-number": ln,
          "to-string": ln,
          var: ea,
          within: Fo,
          distance: Oo,
          "global-state": Hs
        };
        class xa {
          constructor(t, r, a, c) {
            this.name = t, this.type = r, this._evaluate = a, this.args = c
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, r) {
            const a = t[0],
              c = xa.definitions[a];
            if (!c) return r.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const p = Array.isArray(c) ? c[0] : c.type,
              m = Array.isArray(c) ? [
                [c[1], c[2]]
              ] : c.overloads,
              v = m.filter((([C]) => !Array.isArray(C) || C.length === t.length - 1));
            let b = null;
            for (const [C, I] of v) {
              b = new yn(r.registry, Fl, r.path, null, r.scope);
              const R = [];
              let U = !1;
              for (let Z = 1; Z < t.length; Z++) {
                const X = t[Z],
                  Q = Array.isArray(C) ? C[Z - 1] : C.type,
                  ie = b.parse(X, 1 + R.length, Q);
                if (!ie) {
                  U = !0;
                  break
                }
                R.push(ie)
              }
              if (!U)
                if (Array.isArray(C) && C.length !== R.length) b.error(`Expected ${C.length} arguments, but found ${R.length} instead.`);
                else {
                  for (let Z = 0; Z < R.length; Z++) {
                    const X = Array.isArray(C) ? C[Z] : C.type,
                      Q = R[Z];
                    b.concat(Z + 1).checkSubtype(X, Q.type)
                  }
                  if (b.errors.length === 0) return new xa(a, p, I, R)
                }
            }
            if (v.length === 1) r.errors.push(...b.errors);
            else {
              const C = (v.length ? v : m).map((([R]) => {
                  return U = R, Array.isArray(U) ? `(${U.map(_n).join(", ")})` : `(${_n(U.type)}...)`;
                  var U
                })).join(" | "),
                I = [];
              for (let R = 1; R < t.length; R++) {
                const U = r.parse(t[R], 1 + I.length);
                if (!U) return null;
                I.push(_n(U.type))
              }
              r.error(`Expected arguments of type ${C}, but found (${I.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, r) {
            xa.definitions = r;
            for (const a in r) t[a] = xa
          }
        }

        function dd(n, [t, r, a, c]) {
          t = t.evaluate(n), r = r.evaluate(n), a = a.evaluate(n);
          const p = c ? c.evaluate(n) : 1,
            m = Ka(t, r, a, p);
          if (m) throw new Yr(m);
          return new pr(t / 255, r / 255, a / 255, p, !1)
        }

        function pd(n, t) {
          return n in t
        }

        function tu(n, t) {
          const r = t[n];
          return r === void 0 ? null : r
        }

        function No(n) {
          return {
            type: n
          }
        }

        function Fl(n) {
          if (n instanceof ea) return Fl(n.boundExpression);
          if (n instanceof xa && n.name === "error" || n instanceof qs || n instanceof Fo || n instanceof Oo || n instanceof Hs) return !1;
          const t = n instanceof ln || n instanceof mn;
          let r = !0;
          return n.eachChild((a => {
            r = t ? r && Fl(a) : r && a instanceof la
          })), !!r && Bl(n) && Ol(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function Bl(n) {
          if (n instanceof xa && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof Fo || n instanceof Oo) return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !Bl(r) && (t = !1)
          })), t
        }

        function Ws(n) {
          if (n instanceof xa && n.name === "feature-state") return !1;
          let t = !0;
          return n.eachChild((r => {
            t && !Ws(r) && (t = !1)
          })), t
        }

        function Ol(n, t) {
          if (n instanceof xa && t.indexOf(n.name) >= 0) return !1;
          let r = !0;
          return n.eachChild((a => {
            r && !Ol(a, t) && (r = !1)
          })), r
        }

        function fd(n) {
          return {
            result: "success",
            value: n
          }
        }

        function _s(n) {
          return {
            result: "error",
            value: n
          }
        }

        function gs(n) {
          return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven"
        }

        function md(n) {
          return !!n.expression && n.expression.parameters.indexOf("zoom") > -1
        }

        function ru(n) {
          return !!n.expression && n.expression.interpolated
        }

        function xn(n) {
          return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n
        }

        function Nl(n) {
          return typeof n == "object" && n !== null && !Array.isArray(n) && Fn(n) === Tr
        }

        function mf(n) {
          return n
        }

        function _d(n, t) {
          const r = n.stops && typeof n.stops[0][0] == "object",
            a = r || !(r || n.property !== void 0),
            c = n.type || (ru(t) ? "exponential" : "interval"),
            p = (function(I) {
              switch (I.type) {
                case "color":
                  return pr.parse;
                case "padding":
                  return en.parse;
                case "numberArray":
                  return Rr.parse;
                case "colorArray":
                  return vn.parse;
                default:
                  return null
              }
            })(t);
          if (p && ((n = un({}, n)).stops && (n.stops = n.stops.map((I => [I[0], p(I[1])]))), n.default = p(n.default ? n.default : t.default)), n.colorSpace && (m = n.colorSpace) !== "rgb" && m !== "hcl" && m !== "lab") throw new Error(`Unknown color space: "${n.colorSpace}"`);
          var m;
          const v = (function(I) {
            switch (I) {
              case "exponential":
                return gd;
              case "interval":
                return gf;
              case "categorical":
                return _f;
              case "identity":
                return vd;
              default:
                throw new Error(`Unknown function type "${I}"`)
            }
          })(c);
          let b, C;
          if (c === "categorical") {
            b = Object.create(null);
            for (const I of n.stops) b[I[0]] = I[1];
            C = typeof n.stops[0][0]
          }
          if (r) {
            const I = {},
              R = [];
            for (let X = 0; X < n.stops.length; X++) {
              const Q = n.stops[X],
                ie = Q[0].zoom;
              I[ie] === void 0 && (I[ie] = {
                zoom: ie,
                type: n.type,
                property: n.property,
                default: n.default,
                stops: []
              }, R.push(ie)), I[ie].stops.push([Q[0].value, Q[1]])
            }
            const U = [];
            for (const X of R) U.push([I[X].zoom, _d(I[X], t)]);
            const Z = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: Z,
              interpolationFactor: kn.interpolationFactor.bind(void 0, Z),
              zoomStops: U.map((X => X[0])),
              evaluate: ({
                zoom: X
              }, Q) => gd({
                stops: U,
                base: n.base
              }, t, X).evaluate(X, Q)
            }
          }
          if (a) {
            const I = c === "exponential" ? {
              name: "exponential",
              base: n.base !== void 0 ? n.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: I,
              interpolationFactor: kn.interpolationFactor.bind(void 0, I),
              zoomStops: n.stops.map((R => R[0])),
              evaluate: ({
                zoom: R
              }) => v(n, t, R, b, C)
            }
          }
          return {
            kind: "source",
            evaluate(I, R) {
              const U = R && R.properties ? R.properties[n.property] : void 0;
              return U === void 0 ? jo(n.default, t.default) : v(n, t, U, b, C)
            }
          }
        }

        function jo(n, t, r) {
          return n !== void 0 ? n : t !== void 0 ? t : r !== void 0 ? r : void 0
        }

        function _f(n, t, r, a, c) {
          return jo(typeof r === c ? a[r] : void 0, n.default, t.default)
        }

        function gf(n, t, r) {
          if (xn(r) !== "number") return jo(n.default, t.default);
          const a = n.stops.length;
          if (a === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[a - 1][0]) return n.stops[a - 1][1];
          const c = Ns(n.stops.map((p => p[0])), r);
          return n.stops[c][1]
        }

        function gd(n, t, r) {
          const a = n.base !== void 0 ? n.base : 1;
          if (xn(r) !== "number") return jo(n.default, t.default);
          const c = n.stops.length;
          if (c === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[c - 1][0]) return n.stops[c - 1][1];
          const p = Ns(n.stops.map((I => I[0])), r),
            m = (function(I, R, U, Z) {
              const X = Z - U,
                Q = I - U;
              return X === 0 ? 0 : R === 1 ? Q / X : (Math.pow(R, Q) - 1) / (Math.pow(R, X) - 1)
            })(r, a, n.stops[p][0], n.stops[p + 1][0]),
            v = n.stops[p][1],
            b = n.stops[p + 1][1],
            C = ya[t.type] || mf;
          return typeof v.evaluate == "function" ? {
            evaluate(...I) {
              const R = v.evaluate.apply(void 0, I),
                U = b.evaluate.apply(void 0, I);
              if (R !== void 0 && U !== void 0) return C(R, U, m, n.colorSpace)
            }
          } : C(v, b, m, n.colorSpace)
        }

        function vd(n, t, r) {
          switch (t.type) {
            case "color":
              r = pr.parse(r);
              break;
            case "formatted":
              r = Sn.fromString(r.toString());
              break;
            case "resolvedImage":
              r = Vn.fromString(r.toString());
              break;
            case "padding":
              r = en.parse(r);
              break;
            case "colorArray":
              r = vn.parse(r);
              break;
            case "numberArray":
              r = Rr.parse(r);
              break;
            default:
              xn(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
          }
          return jo(r, n.default, t.default)
        }
        xa.register(ms, {
          error: [{
              kind: "error"
            },
            [ft], (n, [t]) => {
              throw new Yr(t.evaluate(n))
            }
          ],
          typeof: [ft, [Dt], (n, [t]) => _n(Fn(t.evaluate(n)))],
          "to-rgba": [dn(Me, 4), [ar], (n, [t]) => {
            const [r, a, c, p] = t.evaluate(n).rgb;
            return [255 * r, 255 * a, 255 * c, p]
          }],
          rgb: [ar, [Me, Me, Me], dd],
          rgba: [ar, [Me, Me, Me, Me], dd],
          has: {
            type: zt,
            overloads: [
              [
                [ft], (n, [t]) => pd(t.evaluate(n), n.properties())
              ],
              [
                [ft, Tr], (n, [t, r]) => pd(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          get: {
            type: Dt,
            overloads: [
              [
                [ft], (n, [t]) => tu(t.evaluate(n), n.properties())
              ],
              [
                [ft, Tr], (n, [t, r]) => tu(t.evaluate(n), r.evaluate(n))
              ]
            ]
          },
          "feature-state": [Dt, [ft], (n, [t]) => tu(t.evaluate(n), n.featureState || {})],
          properties: [Tr, [], n => n.properties()],
          "geometry-type": [ft, [], n => n.geometryType()],
          id: [Dt, [], n => n.id()],
          zoom: [Me, [], n => n.globals.zoom],
          "heatmap-density": [Me, [], n => n.globals.heatmapDensity || 0],
          elevation: [Me, [], n => n.globals.elevation || 0],
          "line-progress": [Me, [], n => n.globals.lineProgress || 0],
          accumulated: [Dt, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated],
          "+": [Me, No(Me), (n, t) => {
            let r = 0;
            for (const a of t) r += a.evaluate(n);
            return r
          }],
          "*": [Me, No(Me), (n, t) => {
            let r = 1;
            for (const a of t) r *= a.evaluate(n);
            return r
          }],
          "-": {
            type: Me,
            overloads: [
              [
                [Me, Me], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)
              ],
              [
                [Me], (n, [t]) => -t.evaluate(n)
              ]
            ]
          },
          "/": [Me, [Me, Me], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)],
          "%": [Me, [Me, Me], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)],
          ln2: [Me, [], () => Math.LN2],
          pi: [Me, [], () => Math.PI],
          e: [Me, [], () => Math.E],
          "^": [Me, [Me, Me], (n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n))],
          sqrt: [Me, [Me], (n, [t]) => Math.sqrt(t.evaluate(n))],
          log10: [Me, [Me], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10],
          ln: [Me, [Me], (n, [t]) => Math.log(t.evaluate(n))],
          log2: [Me, [Me], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
          sin: [Me, [Me], (n, [t]) => Math.sin(t.evaluate(n))],
          cos: [Me, [Me], (n, [t]) => Math.cos(t.evaluate(n))],
          tan: [Me, [Me], (n, [t]) => Math.tan(t.evaluate(n))],
          asin: [Me, [Me], (n, [t]) => Math.asin(t.evaluate(n))],
          acos: [Me, [Me], (n, [t]) => Math.acos(t.evaluate(n))],
          atan: [Me, [Me], (n, [t]) => Math.atan(t.evaluate(n))],
          min: [Me, No(Me), (n, t) => Math.min(...t.map((r => r.evaluate(n))))],
          max: [Me, No(Me), (n, t) => Math.max(...t.map((r => r.evaluate(n))))],
          abs: [Me, [Me], (n, [t]) => Math.abs(t.evaluate(n))],
          round: [Me, [Me], (n, [t]) => {
            const r = t.evaluate(n);
            return r < 0 ? -Math.round(-r) : Math.round(r)
          }],
          floor: [Me, [Me], (n, [t]) => Math.floor(t.evaluate(n))],
          ceil: [Me, [Me], (n, [t]) => Math.ceil(t.evaluate(n))],
          "filter-==": [zt, [ft, Dt], (n, [t, r]) => n.properties()[t.value] === r.value],
          "filter-id-==": [zt, [Dt], (n, [t]) => n.id() === t.value],
          "filter-type-==": [zt, [ft], (n, [t]) => n.geometryType() === t.value],
          "filter-<": [zt, [ft, Dt], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a < c
          }],
          "filter-id-<": [zt, [Dt], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r < a
          }],
          "filter->": [zt, [ft, Dt], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a > c
          }],
          "filter-id->": [zt, [Dt], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r > a
          }],
          "filter-<=": [zt, [ft, Dt], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a <= c
          }],
          "filter-id-<=": [zt, [Dt], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r <= a
          }],
          "filter->=": [zt, [ft, Dt], (n, [t, r]) => {
            const a = n.properties()[t.value],
              c = r.value;
            return typeof a == typeof c && a >= c
          }],
          "filter-id->=": [zt, [Dt], (n, [t]) => {
            const r = n.id(),
              a = t.value;
            return typeof r == typeof a && r >= a
          }],
          "filter-has": [zt, [Dt], (n, [t]) => t.value in n.properties()],
          "filter-has-id": [zt, [], n => n.id() !== null && n.id() !== void 0],
          "filter-type-in": [zt, [dn(ft)], (n, [t]) => t.value.indexOf(n.geometryType()) >= 0],
          "filter-id-in": [zt, [dn(Dt)], (n, [t]) => t.value.indexOf(n.id()) >= 0],
          "filter-in-small": [zt, [ft, dn(Dt)], (n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0],
          "filter-in-large": [zt, [ft, dn(Dt)], (n, [t, r]) => (function(a, c, p, m) {
            for (; p <= m;) {
              const v = p + m >> 1;
              if (c[v] === a) return !0;
              c[v] > a ? m = v - 1 : p = v + 1
            }
            return !1
          })(n.properties()[t.value], r.value, 0, r.value.length - 1)],
          all: {
            type: zt,
            overloads: [
              [
                [zt, zt], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)
              ],
              [No(zt), (n, t) => {
                for (const r of t)
                  if (!r.evaluate(n)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: zt,
            overloads: [
              [
                [zt, zt], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)
              ],
              [No(zt), (n, t) => {
                for (const r of t)
                  if (r.evaluate(n)) return !0;
                return !1
              }]
            ]
          },
          "!": [zt, [zt], (n, [t]) => !t.evaluate(n)],
          "is-supported-script": [zt, [ft], (n, [t]) => {
            const r = n.globals && n.globals.isSupportedScript;
            return !r || r(t.evaluate(n))
          }],
          upcase: [ft, [ft], (n, [t]) => t.evaluate(n).toUpperCase()],
          downcase: [ft, [ft], (n, [t]) => t.evaluate(n).toLowerCase()],
          concat: [ft, No(Dt), (n, t) => t.map((r => va(r.evaluate(n)))).join("")],
          "resolved-locale": [ft, [Br], (n, [t]) => t.evaluate(n).resolvedLocale()]
        });
        class nu {
          constructor(t, r, a) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new ds, this._defaultValue = r ? (function(c) {
              if (c.type === "color" && Nl(c.default)) return new pr(0, 0, 0, 0);
              switch (c.type) {
                case "color":
                  return pr.parse(c.default) || null;
                case "padding":
                  return en.parse(c.default) || null;
                case "numberArray":
                  return Rr.parse(c.default) || null;
                case "colorArray":
                  return vn.parse(c.default) || null;
                case "variableAnchorOffsetCollection":
                  return In.parse(c.default) || null;
                case "projectionDefinition":
                  return _i.parse(c.default) || null;
                default:
                  return c.default === void 0 ? null : c.default
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this._globalState = a
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, m) {
            return this._globalState && (t = qo(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = a, this._evaluator.canonical = c, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = m, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, r, a, c, p, m) {
            this._globalState && (t = qo(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = a || null, this._evaluator.canonical = c, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = m || null;
            try {
              const v = this.expression.evaluate(this._evaluator);
              if (v == null || typeof v == "number" && v != v) return this._defaultValue;
              if (this._enumValues && !(v in this._enumValues)) throw new Yr(`Expected value to be one of ${Object.keys(this._enumValues).map((b=>JSON.stringify(b))).join(", ")}, but found ${JSON.stringify(v)} instead.`);
              return v
            } catch (v) {
              return this._warningHistory[v.message] || (this._warningHistory[v.message] = !0, typeof console < "u" && console.warn(v.message)), this._defaultValue
            }
          }
        }

        function jl(n) {
          return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in ms
        }

        function Vo(n, t, r) {
          const a = new yn(ms, Fl, [], t ? (function(p) {
              const m = {
                color: ar,
                string: ft,
                number: Me,
                enum: ft,
                boolean: zt,
                formatted: Ir,
                padding: wr,
                numberArray: Mr,
                colorArray: Xr,
                projectionDefinition: br,
                resolvedImage: nn,
                variableAnchorOffsetCollection: sn
              };
              return p.type === "array" ? dn(m[p.value] || Dt, p.length) : m[p.type]
            })(t) : void 0),
            c = a.parse(n, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return c ? fd(new nu(c, t, r)) : _s(a.errors)
        }
        class Xs {
          constructor(t, r, a) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !Ws(r.expression), this.globalStateRefs = Ul(r.expression), this._globalState = a
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, m) {
            return this._globalState && (t = qo(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, m)
          }
          evaluate(t, r, a, c, p, m) {
            return this._globalState && (t = qo(t, this._globalState)), this._styleExpression.evaluate(t, r, a, c, p, m)
          }
        }
        class iu {
          constructor(t, r, a, c, p) {
            this.kind = t, this.zoomStops = a, this._styleExpression = r, this.isStateDependent = t !== "camera" && !Ws(r.expression), this.globalStateRefs = Ul(r.expression), this.interpolationType = c, this._globalState = p
          }
          evaluateWithoutErrorHandling(t, r, a, c, p, m) {
            return this._globalState && (t = qo(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, m)
          }
          evaluate(t, r, a, c, p, m) {
            return this._globalState && (t = qo(t, this._globalState)), this._styleExpression.evaluate(t, r, a, c, p, m)
          }
          interpolationFactor(t, r, a) {
            return this.interpolationType ? kn.interpolationFactor(this.interpolationType, t, r, a) : 0
          }
        }

        function yd(n, t, r) {
          const a = Vo(n, t, r);
          if (a.result === "error") return a;
          const c = a.value.expression,
            p = Bl(c);
          if (!p && !gs(t)) return _s([new Pn("", "data expressions not supported")]);
          const m = Ol(c, ["zoom"]);
          if (!m && !md(t)) return _s([new Pn("", "zoom expressions not supported")]);
          const v = ql(c);
          return v || m ? v instanceof Pn ? _s([v]) : v instanceof kn && !ru(t) ? _s([new Pn("", '"interpolate" expressions cannot be used with this property')]) : fd(v ? new iu(p ? "camera" : "composite", a.value, v.labels, v instanceof kn ? v.interpolation : void 0, r) : new Xs(p ? "constant" : "source", a.value, r)) : _s([new Pn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Vl {
          constructor(t, r) {
            this._parameters = t, this._specification = r, un(this, _d(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new Vl(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function ql(n) {
          let t = null;
          if (n instanceof Sa) t = ql(n.result);
          else if (n instanceof Vs) {
            for (const r of n.args)
              if (t = ql(r), t) break
          } else(n instanceof ps || n instanceof kn) && n.input instanceof xa && n.input.name === "zoom" && (t = n);
          return t instanceof Pn || n.eachChild((r => {
            const a = ql(r);
            a instanceof Pn ? t = a : !t && a ? t = new Pn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new Pn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Ul(n, t = new Set) {
          return n instanceof Hs && t.add(n.key), n.eachChild((r => {
            Ul(r, t)
          })), t
        }

        function qo(n, t) {
          const {
            zoom: r,
            heatmapDensity: a,
            elevation: c,
            lineProgress: p,
            isSupportedScript: m,
            accumulated: v
          } = n ?? {};
          return {
            zoom: r,
            heatmapDensity: a,
            elevation: c,
            lineProgress: p,
            isSupportedScript: m,
            accumulated: v,
            globalState: t
          }
        }

        function Zl(n) {
          if (n === !0 || n === !1) return !0;
          if (!Array.isArray(n) || n.length === 0) return !1;
          switch (n[0]) {
            case "has":
              return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
            case "in":
              return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
            case "any":
            case "all":
              for (const t of n.slice(1))
                if (!Zl(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const vf = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function Ys(n, t) {
          if (n == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          Zl(n) || (n = Ks(n));
          const r = Vo(n, vf, t);
          if (r.result === "error") throw new Error(r.value.map((a => `${a.key}: ${a.message}`)).join(", "));
          return {
            filter: (a, c, p) => r.value.evaluate(a, c, {}, p),
            needGeometry: au(n),
            getGlobalStateRefs: () => Ul(r.value.expression)
          }
        }

        function xd(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function au(n) {
          if (!Array.isArray(n)) return !1;
          if (n[0] === "within" || n[0] === "distance") return !0;
          for (let t = 1; t < n.length; t++)
            if (au(n[t])) return !0;
          return !1
        }

        function Ks(n) {
          if (!n) return !0;
          const t = n[0];
          return n.length <= 1 ? t !== "any" : t === "==" ? ou(n[1], n[2], "==") : t === "!=" ? Gl(ou(n[1], n[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? ou(n[1], n[2], t) : t === "any" ? (r = n.slice(1), ["any"].concat(r.map(Ks))) : t === "all" ? ["all"].concat(n.slice(1).map(Ks)) : t === "none" ? ["all"].concat(n.slice(1).map(Ks).map(Gl)) : t === "in" ? bd(n[1], n.slice(2)) : t === "!in" ? Gl(bd(n[1], n.slice(2))) : t === "has" ? wd(n[1]) : t !== "!has" || Gl(wd(n[1]));
          var r
        }

        function ou(n, t, r) {
          switch (n) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, n, t]
          }
        }

        function bd(n, t) {
          if (t.length === 0) return !1;
          switch (n) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", n, ["literal", t.sort(xd)]] : ["filter-in-small", n, ["literal", t]]
          }
        }

        function wd(n) {
          switch (n) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", n]
          }
        }

        function Gl(n) {
          return ["!", n]
        }

        function $l(n) {
          const t = typeof n;
          if (t === "number" || t === "boolean" || t === "string" || n == null) return JSON.stringify(n);
          if (Array.isArray(n)) {
            let c = "[";
            for (const p of n) c += `${$l(p)},`;
            return `${c}]`
          }
          const r = Object.keys(n).sort();
          let a = "{";
          for (let c = 0; c < r.length; c++) a += `${JSON.stringify(r[c])}:${$l(n[r[c]])},`;
          return `${a}}`
        }

        function Td(n) {
          let t = "";
          for (const r of Vt) t += `/${$l(n[r])}`;
          return t
        }

        function Hl(n) {
          const t = n.value;
          return t ? [new ht(n.key, t, "constants have been deprecated as of v8")] : []
        }

        function Kn(n) {
          return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
        }

        function eo(n) {
          if (Array.isArray(n)) return n.map(eo);
          if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
            const t = {};
            for (const r in n) t[r] = eo(n[r]);
            return t
          }
          return Kn(n)
        }

        function ta(n) {
          const t = n.key,
            r = n.value,
            a = n.valueSpec || {},
            c = n.objectElementValidators || {},
            p = n.style,
            m = n.styleSpec,
            v = n.validateSpec;
          let b = [];
          const C = xn(r);
          if (C !== "object") return [new ht(t, r, `object expected, ${C} found`)];
          for (const I in r) {
            const R = I.split(".")[0],
              U = Gn(a, R) || a["*"];
            let Z;
            if (Gn(c, R)) Z = c[R];
            else if (Gn(a, R)) Z = v;
            else if (c["*"]) Z = c["*"];
            else {
              if (!a["*"]) {
                b.push(new ht(t, r[I], `unknown property "${I}"`));
                continue
              }
              Z = v
            }
            b = b.concat(Z({
              key: (t && `${t}.`) + I,
              value: r[I],
              valueSpec: U,
              style: p,
              styleSpec: m,
              object: r,
              objectKey: I,
              validateSpec: v
            }, r))
          }
          for (const I in a) c[I] || a[I].required && a[I].default === void 0 && r[I] === void 0 && b.push(new ht(t, r, `missing required property "${I}"`));
          return b
        }

        function vs(n) {
          const t = n.value,
            r = n.valueSpec,
            a = n.style,
            c = n.styleSpec,
            p = n.key,
            m = n.arrayElementValidator || n.validateSpec;
          if (xn(t) !== "array") return [new ht(p, t, `array expected, ${xn(t)} found`)];
          if (r.length && t.length !== r.length) return [new ht(p, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new ht(p, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let v = {
            type: r.value,
            values: r.values
          };
          c.$version < 7 && (v.function = r.function), xn(r.value) === "object" && (v = r.value);
          let b = [];
          for (let C = 0; C < t.length; C++) b = b.concat(m({
            array: t,
            arrayIndex: C,
            value: t[C],
            valueSpec: v,
            validateSpec: n.validateSpec,
            style: a,
            styleSpec: c,
            key: `${p}[${C}]`
          }));
          return b
        }

        function Wl(n) {
          const t = n.key,
            r = n.value,
            a = n.valueSpec;
          let c = xn(r);
          return c === "number" && r != r && (c = "NaN"), c !== "number" ? [new ht(t, r, `number expected, ${c} found`)] : "minimum" in a && r < a.minimum ? [new ht(t, r, `${r} is less than the minimum value ${a.minimum}`)] : "maximum" in a && r > a.maximum ? [new ht(t, r, `${r} is greater than the maximum value ${a.maximum}`)] : []
        }

        function Sd(n) {
          const t = n.valueSpec,
            r = Kn(n.value.type);
          let a, c, p, m = {};
          const v = r !== "categorical" && n.value.property === void 0,
            b = !v,
            C = xn(n.value.stops) === "array" && xn(n.value.stops[0]) === "array" && xn(n.value.stops[0][0]) === "object",
            I = ta({
              key: n.key,
              value: n.value,
              valueSpec: n.styleSpec.function,
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: n.styleSpec,
              objectElementValidators: {
                stops: function(Z) {
                  if (r === "identity") return [new ht(Z.key, Z.value, 'identity function may not have a "stops" property')];
                  let X = [];
                  const Q = Z.value;
                  return X = X.concat(vs({
                    key: Z.key,
                    value: Q,
                    valueSpec: Z.valueSpec,
                    validateSpec: Z.validateSpec,
                    style: Z.style,
                    styleSpec: Z.styleSpec,
                    arrayElementValidator: R
                  })), xn(Q) === "array" && Q.length === 0 && X.push(new ht(Z.key, Q, "array must have at least one stop")), X
                },
                default: function(Z) {
                  return Z.validateSpec({
                    key: Z.key,
                    value: Z.value,
                    valueSpec: t,
                    validateSpec: Z.validateSpec,
                    style: Z.style,
                    styleSpec: Z.styleSpec
                  })
                }
              }
            });
          return r === "identity" && v && I.push(new ht(n.key, n.value, 'missing required property "property"')), r === "identity" || n.value.stops || I.push(new ht(n.key, n.value, 'missing required property "stops"')), r === "exponential" && n.valueSpec.expression && !ru(n.valueSpec) && I.push(new ht(n.key, n.value, "exponential functions not supported")), n.styleSpec.$version >= 8 && (b && !gs(n.valueSpec) ? I.push(new ht(n.key, n.value, "property functions not supported")) : v && !md(n.valueSpec) && I.push(new ht(n.key, n.value, "zoom functions not supported"))), r !== "categorical" && !C || n.value.property !== void 0 || I.push(new ht(n.key, n.value, '"property" property is required')), I;

          function R(Z) {
            let X = [];
            const Q = Z.value,
              ie = Z.key;
            if (xn(Q) !== "array") return [new ht(ie, Q, `array expected, ${xn(Q)} found`)];
            if (Q.length !== 2) return [new ht(ie, Q, `array length 2 expected, length ${Q.length} found`)];
            if (C) {
              if (xn(Q[0]) !== "object") return [new ht(ie, Q, `object expected, ${xn(Q[0])} found`)];
              if (Q[0].zoom === void 0) return [new ht(ie, Q, "object stop key must have zoom")];
              if (Q[0].value === void 0) return [new ht(ie, Q, "object stop key must have value")];
              if (p && p > Kn(Q[0].zoom)) return [new ht(ie, Q[0].zoom, "stop zoom values must appear in ascending order")];
              Kn(Q[0].zoom) !== p && (p = Kn(Q[0].zoom), c = void 0, m = {}), X = X.concat(ta({
                key: `${ie}[0]`,
                value: Q[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: Z.validateSpec,
                style: Z.style,
                styleSpec: Z.styleSpec,
                objectElementValidators: {
                  zoom: Wl,
                  value: U
                }
              }))
            } else X = X.concat(U({
              key: `${ie}[0]`,
              value: Q[0],
              validateSpec: Z.validateSpec,
              style: Z.style,
              styleSpec: Z.styleSpec
            }, Q));
            return jl(eo(Q[1])) ? X.concat([new ht(`${ie}[1]`, Q[1], "expressions are not allowed in function stops.")]) : X.concat(Z.validateSpec({
              key: `${ie}[1]`,
              value: Q[1],
              valueSpec: t,
              validateSpec: Z.validateSpec,
              style: Z.style,
              styleSpec: Z.styleSpec
            }))
          }

          function U(Z, X) {
            const Q = xn(Z.value),
              ie = Kn(Z.value),
              ue = Z.value !== null ? Z.value : X;
            if (a) {
              if (Q !== a) return [new ht(Z.key, ue, `${Q} stop domain type must match previous stop domain type ${a}`)]
            } else a = Q;
            if (Q !== "number" && Q !== "string" && Q !== "boolean") return [new ht(Z.key, ue, "stop domain value must be a number, string, or boolean")];
            if (Q !== "number" && r !== "categorical") {
              let Ne = `number expected, ${Q} found`;
              return gs(t) && r === void 0 && (Ne += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ht(Z.key, ue, Ne)]
            }
            return r !== "categorical" || Q !== "number" || isFinite(ie) && Math.floor(ie) === ie ? r !== "categorical" && Q === "number" && c !== void 0 && ie < c ? [new ht(Z.key, ue, "stop domain values must appear in ascending order")] : (c = ie, r === "categorical" && ie in m ? [new ht(Z.key, ue, "stop domain values must be unique")] : (m[ie] = !0, [])) : [new ht(Z.key, ue, `integer expected, found ${ie}`)]
          }
        }

        function ys(n) {
          const t = (n.expressionContext === "property" ? yd : Vo)(eo(n.value), n.valueSpec);
          if (t.result === "error") return t.value.map((a => new ht(`${n.key}${a.key}`, n.value, a.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (n.expressionContext === "property" && n.propertyKey === "text-font" && !r.outputDefined()) return [new ht(n.key, n.value, `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (n.expressionContext === "property" && n.propertyType === "layout" && !Ws(r)) return [new ht(n.key, n.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (n.expressionContext === "filter" && !Ws(r)) return [new ht(n.key, n.value, '"feature-state" data expressions are not supported with filters.')];
          if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) {
            if (!Ol(r, ["zoom", "feature-state"])) return [new ht(n.key, n.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (n.expressionContext === "cluster-initial" && !Bl(r)) return [new ht(n.key, n.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function su(n) {
          const t = n.key,
            r = n.value,
            a = xn(r);
          return a !== "string" ? [new ht(t, r, `color expected, ${a} found`)] : pr.parse(String(r)) ? [] : [new ht(t, r, `color expected, "${r}" found`)]
        }

        function Js(n) {
          const t = n.key,
            r = n.value,
            a = n.valueSpec,
            c = [];
          return Array.isArray(a.values) ? a.values.indexOf(Kn(r)) === -1 && c.push(new ht(t, r, `expected one of [${a.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(a.values).indexOf(Kn(r)) === -1 && c.push(new ht(t, r, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(r)} found`)), c
        }

        function lu(n) {
          return Zl(eo(n.value)) ? ys(un({}, n, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : cu(n)
        }

        function cu(n) {
          const t = n.value,
            r = n.key;
          if (xn(t) !== "array") return [new ht(r, t, `array expected, ${xn(t)} found`)];
          const a = n.styleSpec;
          let c, p = [];
          if (t.length < 1) return [new ht(r, t, "filter array must have at least 1 element")];
          switch (p = p.concat(Js({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: a.filter_operator,
              style: n.style,
              styleSpec: n.styleSpec
            })), Kn(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && Kn(t[1]) === "$type" && p.push(new ht(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && p.push(new ht(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (c = xn(t[1]), c !== "string" && p.push(new ht(`${r}[1]`, t[1], `string expected, ${c} found`)));
              for (let m = 2; m < t.length; m++) c = xn(t[m]), Kn(t[1]) === "$type" ? p = p.concat(Js({
                key: `${r}[${m}]`,
                value: t[m],
                valueSpec: a.geometry_type,
                style: n.style,
                styleSpec: n.styleSpec
              })) : c !== "string" && c !== "number" && c !== "boolean" && p.push(new ht(`${r}[${m}]`, t[m], `string, number, or boolean expected, ${c} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let m = 1; m < t.length; m++) p = p.concat(cu({
                key: `${r}[${m}]`,
                value: t[m],
                style: n.style,
                styleSpec: n.styleSpec
              }));
              break;
            case "has":
            case "!has":
              c = xn(t[1]), t.length !== 2 ? p.push(new ht(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && p.push(new ht(`${r}[1]`, t[1], `string expected, ${c} found`))
          }
          return p
        }

        function uu(n, t) {
          const r = n.key,
            a = n.validateSpec,
            c = n.style,
            p = n.styleSpec,
            m = n.value,
            v = n.objectKey,
            b = p[`${t}_${n.layerType}`];
          if (!b) return [];
          const C = v.match(/^(.*)-transition$/);
          if (t === "paint" && C && b[C[1]] && b[C[1]].transition) return a({
            key: r,
            value: m,
            valueSpec: p.transition,
            style: c,
            styleSpec: p
          });
          const I = n.valueSpec || b[v];
          if (!I) return [new ht(r, m, `unknown property "${v}"`)];
          let R;
          if (xn(m) === "string" && gs(I) && !I.tokens && (R = /^{([^}]+)}$/.exec(m))) return [new ht(r, m, `"${v}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(R[1])} }\`.`)];
          const U = [];
          return n.layerType === "symbol" && v === "text-font" && Nl(eo(m)) && Kn(m.type) === "identity" && U.push(new ht(r, m, '"text-font" does not support identity functions')), U.concat(a({
            key: n.key,
            value: m,
            valueSpec: I,
            style: c,
            styleSpec: p,
            expressionContext: "property",
            propertyType: t,
            propertyKey: v
          }))
        }

        function Qs(n) {
          return uu(n, "paint")
        }

        function Cd(n) {
          return uu(n, "layout")
        }

        function hu(n) {
          let t = [];
          const r = n.value,
            a = n.key,
            c = n.style,
            p = n.styleSpec;
          if (xn(r) !== "object") return [new ht(a, r, `object expected, ${xn(r)} found`)];
          r.type || r.ref || t.push(new ht(a, r, 'either "type" or "ref" is required'));
          let m = Kn(r.type);
          const v = Kn(r.ref);
          if (r.id) {
            const b = Kn(r.id);
            for (let C = 0; C < n.arrayIndex; C++) {
              const I = c.layers[C];
              Kn(I.id) === b && t.push(new ht(a, r.id, `duplicate layer id "${r.id}", previously used at line ${I.id.__line__}`))
            }
          }
          if ("ref" in r) {
            let b;
            ["type", "source", "source-layer", "filter", "layout"].forEach((C => {
              C in r && t.push(new ht(a, r[C], `"${C}" is prohibited for ref layers`))
            })), c.layers.forEach((C => {
              Kn(C.id) === v && (b = C)
            })), b ? b.ref ? t.push(new ht(a, r.ref, "ref cannot reference another ref layer")) : m = Kn(b.type) : t.push(new ht(a, r.ref, `ref layer "${v}" not found`))
          } else if (m !== "background")
            if (r.source) {
              const b = c.sources && c.sources[r.source],
                C = b && Kn(b.type);
              b ? C === "vector" && m === "raster" ? t.push(new ht(a, r.source, `layer "${r.id}" requires a raster source`)) : C !== "raster-dem" && m === "hillshade" || C !== "raster-dem" && m === "color-relief" ? t.push(new ht(a, r.source, `layer "${r.id}" requires a raster-dem source`)) : C === "raster" && m !== "raster" ? t.push(new ht(a, r.source, `layer "${r.id}" requires a vector source`)) : C !== "vector" || r["source-layer"] ? C === "raster-dem" && m !== "hillshade" && m !== "color-relief" ? t.push(new ht(a, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : m !== "line" || !r.paint || !r.paint["line-gradient"] || C === "geojson" && b.lineMetrics || t.push(new ht(a, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ht(a, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new ht(a, r.source, `source "${r.source}" not found`))
            } else t.push(new ht(a, r, 'missing required property "source"'));
          return t = t.concat(ta({
            key: a,
            value: r,
            valueSpec: p.layer,
            style: n.style,
            styleSpec: n.styleSpec,
            validateSpec: n.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => n.validateSpec({
                key: `${a}.type`,
                value: r.type,
                valueSpec: p.layer.type,
                style: n.style,
                styleSpec: n.styleSpec,
                validateSpec: n.validateSpec,
                object: r,
                objectKey: "type"
              }),
              filter: lu,
              layout: b => ta({
                layer: r,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": C => Cd(un({
                    layerType: m
                  }, C))
                }
              }),
              paint: b => ta({
                layer: r,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": C => Qs(un({
                    layerType: m
                  }, C))
                }
              })
            }
          })), t
        }

        function bo(n) {
          const t = n.value,
            r = n.key,
            a = xn(t);
          return a !== "string" ? [new ht(r, t, `string expected, ${a} found`)] : []
        }
        const Pd = {
          promoteId: function({
            key: n,
            value: t
          }) {
            if (xn(t) === "string") return bo({
              key: n,
              value: t
            });
            {
              const r = [];
              for (const a in t) r.push(...bo({
                key: `${n}.${a}`,
                value: t[a]
              }));
              return r
            }
          }
        };

        function du(n) {
          const t = n.value,
            r = n.key,
            a = n.styleSpec,
            c = n.style,
            p = n.validateSpec;
          if (!t.type) return [new ht(r, t, '"type" is required')];
          const m = Kn(t.type);
          let v;
          switch (m) {
            case "vector":
            case "raster":
              return v = ta({
                key: r,
                value: t,
                valueSpec: a[`source_${m.replace("-","_")}`],
                style: n.style,
                styleSpec: a,
                objectElementValidators: Pd,
                validateSpec: p
              }), v;
            case "raster-dem":
              return v = (function(b) {
                var C;
                const I = (C = b.sourceName) !== null && C !== void 0 ? C : "",
                  R = b.value,
                  U = b.styleSpec,
                  Z = U.source_raster_dem,
                  X = b.style;
                let Q = [];
                const ie = xn(R);
                if (R === void 0) return Q;
                if (ie !== "object") return Q.push(new ht("source_raster_dem", R, `object expected, ${ie} found`)), Q;
                const ue = Kn(R.encoding) === "custom",
                  Ne = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  ye = b.value.encoding ? `"${b.value.encoding}"` : "Default";
                for (const Ce in R) !ue && Ne.includes(Ce) ? Q.push(new ht(Ce, R[Ce], `In "${I}": "${Ce}" is only valid when "encoding" is set to "custom". ${ye} encoding found`)) : Z[Ce] ? Q = Q.concat(b.validateSpec({
                  key: Ce,
                  value: R[Ce],
                  valueSpec: Z[Ce],
                  validateSpec: b.validateSpec,
                  style: X,
                  styleSpec: U
                })) : Q.push(new ht(Ce, R[Ce], `unknown property "${Ce}"`));
                return Q
              })({
                sourceName: r,
                value: t,
                style: n.style,
                styleSpec: a,
                validateSpec: p
              }), v;
            case "geojson":
              if (v = ta({
                  key: r,
                  value: t,
                  valueSpec: a.source_geojson,
                  style: c,
                  styleSpec: a,
                  validateSpec: p,
                  objectElementValidators: Pd
                }), t.cluster)
                for (const b in t.clusterProperties) {
                  const [C, I] = t.clusterProperties[b], R = typeof C == "string" ? [C, ["accumulated"],
                    ["get", b]
                  ] : C;
                  v.push(...ys({
                    key: `${r}.${b}.map`,
                    value: I,
                    expressionContext: "cluster-map"
                  })), v.push(...ys({
                    key: `${r}.${b}.reduce`,
                    value: R,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return v;
            case "video":
              return ta({
                key: r,
                value: t,
                valueSpec: a.source_video,
                style: c,
                validateSpec: p,
                styleSpec: a
              });
            case "image":
              return ta({
                key: r,
                value: t,
                valueSpec: a.source_image,
                style: c,
                validateSpec: p,
                styleSpec: a
              });
            case "canvas":
              return [new ht(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Js({
                key: `${r}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function pu(n) {
          const t = n.value,
            r = n.styleSpec,
            a = r.light,
            c = n.style;
          let p = [];
          const m = xn(t);
          if (t === void 0) return p;
          if (m !== "object") return p = p.concat([new ht("light", t, `object expected, ${m} found`)]), p;
          for (const v in t) {
            const b = v.match(/^(.*)-transition$/);
            p = p.concat(b && a[b[1]] && a[b[1]].transition ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: r.transition,
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : a[v] ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: a[v],
              validateSpec: n.validateSpec,
              style: c,
              styleSpec: r
            }) : [new ht(v, t[v], `unknown property "${v}"`)])
          }
          return p
        }

        function xs(n) {
          const t = n.value,
            r = n.styleSpec,
            a = r.sky,
            c = n.style,
            p = xn(t);
          if (t === void 0) return [];
          if (p !== "object") return [new ht("sky", t, `object expected, ${p} found`)];
          let m = [];
          for (const v in t) m = m.concat(a[v] ? n.validateSpec({
            key: v,
            value: t[v],
            valueSpec: a[v],
            style: c,
            styleSpec: r
          }) : [new ht(v, t[v], `unknown property "${v}"`)]);
          return m
        }

        function Id(n) {
          const t = n.value,
            r = n.styleSpec,
            a = r.terrain,
            c = n.style;
          let p = [];
          const m = xn(t);
          if (t === void 0) return p;
          if (m !== "object") return p = p.concat([new ht("terrain", t, `object expected, ${m} found`)]), p;
          for (const v in t) p = p.concat(a[v] ? n.validateSpec({
            key: v,
            value: t[v],
            valueSpec: a[v],
            validateSpec: n.validateSpec,
            style: c,
            styleSpec: r
          }) : [new ht(v, t[v], `unknown property "${v}"`)]);
          return p
        }

        function Md(n) {
          let t = [];
          const r = n.value,
            a = n.key;
          if (Array.isArray(r)) {
            const c = [],
              p = [];
            for (const m in r) r[m].id && c.includes(r[m].id) && t.push(new ht(a, r, `all the sprites' ids must be unique, but ${r[m].id} is duplicated`)), c.push(r[m].id), r[m].url && p.includes(r[m].url) && t.push(new ht(a, r, `all the sprites' URLs must be unique, but ${r[m].url} is duplicated`)), p.push(r[m].url), t = t.concat(ta({
              key: `${a}[${m}]`,
              value: r[m],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: n.validateSpec
            }));
            return t
          }
          return bo({
            key: a,
            value: r
          })
        }

        function Ad(n) {
          return t = n.value, t && t.constructor === Object ? [] : [new ht(n.key, n.value, `object expected, ${xn(n.value)} found`)];
          var t
        }
        const kd = {
          "*": () => [],
          array: vs,
          boolean: function(n) {
            const t = n.value,
              r = n.key,
              a = xn(t);
            return a !== "boolean" ? [new ht(r, t, `boolean expected, ${a} found`)] : []
          },
          number: Wl,
          color: su,
          constants: Hl,
          enum: Js,
          filter: lu,
          function: Sd,
          layer: hu,
          object: ta,
          source: du,
          light: pu,
          sky: xs,
          terrain: Id,
          projection: function(n) {
            const t = n.value,
              r = n.styleSpec,
              a = r.projection,
              c = n.style,
              p = xn(t);
            if (t === void 0) return [];
            if (p !== "object") return [new ht("projection", t, `object expected, ${p} found`)];
            let m = [];
            for (const v in t) m = m.concat(a[v] ? n.validateSpec({
              key: v,
              value: t[v],
              valueSpec: a[v],
              style: c,
              styleSpec: r
            }) : [new ht(v, t[v], `unknown property "${v}"`)]);
            return m
          },
          projectionDefinition: function(n) {
            const t = n.key;
            let r = n.value;
            r = r instanceof String ? r.valueOf() : r;
            const a = xn(r);
            return a !== "array" || (function(c) {
              return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
            })(r) || (function(c) {
              return !!["interpolate", "step", "literal"].includes(c[0])
            })(r) ? ["array", "string"].includes(a) ? [] : [new ht(t, r, `projection expected, invalid type "${a}" found`)] : [new ht(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)]
          },
          string: bo,
          formatted: function(n) {
            return bo(n).length === 0 ? [] : ys(n)
          },
          resolvedImage: function(n) {
            return bo(n).length === 0 ? [] : ys(n)
          },
          padding: function(n) {
            const t = n.key,
              r = n.value;
            if (xn(r) === "array") {
              if (r.length < 1 || r.length > 4) return [new ht(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
              const a = {
                type: "number"
              };
              let c = [];
              for (let p = 0; p < r.length; p++) c = c.concat(n.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: n.validateSpec,
                valueSpec: a
              }));
              return c
            }
            return Wl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          numberArray: function(n) {
            const t = n.key,
              r = n.value;
            if (xn(r) === "array") {
              const a = {
                type: "number"
              };
              if (r.length < 1) return [new ht(t, r, "array length at least 1 expected, length 0 found")];
              let c = [];
              for (let p = 0; p < r.length; p++) c = c.concat(n.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: n.validateSpec,
                valueSpec: a
              }));
              return c
            }
            return Wl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          colorArray: function(n) {
            const t = n.key,
              r = n.value;
            if (xn(r) === "array") {
              if (r.length < 1) return [new ht(t, r, "array length at least 1 expected, length 0 found")];
              let a = [];
              for (let c = 0; c < r.length; c++) a = a.concat(su({
                key: `${t}[${c}]`,
                value: r[c]
              }));
              return a
            }
            return su({
              key: t,
              value: r
            })
          },
          variableAnchorOffsetCollection: function(n) {
            const t = n.key,
              r = n.value,
              a = xn(r),
              c = n.styleSpec;
            if (a !== "array" || r.length < 1 || r.length % 2 != 0) return [new ht(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let p = [];
            for (let m = 0; m < r.length; m += 2) p = p.concat(Js({
              key: `${t}[${m}]`,
              value: r[m],
              valueSpec: c.layout_symbol["text-anchor"]
            })), p = p.concat(vs({
              key: `${t}[${m+1}]`,
              value: r[m + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: c
            }));
            return p
          },
          sprite: Md,
          state: Ad
        };

        function Xl(n) {
          const t = n.value,
            r = n.valueSpec,
            a = n.styleSpec;
          return n.validateSpec = Xl, r.expression && Nl(Kn(t)) ? Sd(n) : r.expression && jl(eo(t)) ? ys(n) : r.type && kd[r.type] ? kd[r.type](n) : ta(un({}, n, {
            valueSpec: r.type ? a[r.type] : r
          }))
        }

        function Ed(n) {
          const t = n.value,
            r = n.key,
            a = bo(n);
          return a.length || (t.indexOf("{fontstack}") === -1 && a.push(new ht(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && a.push(new ht(r, t, '"glyphs" url must include a "{range}" token'))), a
        }

        function Ui(n, t = _e) {
          let r = [];
          return r = r.concat(Xl({
            key: "",
            value: n,
            valueSpec: t.$root,
            styleSpec: t,
            style: n,
            validateSpec: Xl,
            objectElementValidators: {
              glyphs: Ed,
              "*": () => []
            }
          })), n.constants && (r = r.concat(Hl({
            key: "constants",
            value: n.constants
          }))), ra(r)
        }

        function Xi(n) {
          return function(t) {
            return n(Object.assign({}, t, {
              validateSpec: Xl
            }))
          }
        }

        function ra(n) {
          return [].concat(n).sort(((t, r) => t.line - r.line))
        }

        function Yi(n) {
          return function(...t) {
            return ra(n.apply(this, t))
          }
        }
        Ui.source = Yi(Xi(du)), Ui.sprite = Yi(Xi(Md)), Ui.glyphs = Yi(Xi(Ed)), Ui.light = Yi(Xi(pu)), Ui.sky = Yi(Xi(xs)), Ui.terrain = Yi(Xi(Id)), Ui.state = Yi(Xi(Ad)), Ui.layer = Yi(Xi(hu)), Ui.filter = Yi(Xi(lu)), Ui.paintProperty = Yi(Xi(Qs)), Ui.layoutProperty = Yi(Xi(Cd));
        const zd = _e,
          bs = Ui,
          yf = bs.light,
          el = bs.sky,
          Ld = bs.paintProperty,
          fu = bs.layoutProperty;

        function Dd(n, t) {
          let r = !1;
          if (t && t.length)
            for (const a of t) n.fire(new Ze(new Error(a.message))), r = !0;
          return r
        }
        class Uo {
          constructor(t, r, a) {
            const c = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const m = new Int32Array(this.arrayBuffer);
              t = m[0], this.d = (r = m[1]) + 2 * (a = m[2]);
              for (let b = 0; b < this.d * this.d; b++) {
                const C = m[3 + b],
                  I = m[3 + b + 1];
                c.push(C === I ? null : m.subarray(C, I))
              }
              const v = m[3 + c.length + 1];
              this.keys = m.subarray(m[3 + c.length], v), this.bboxes = m.subarray(v), this.insert = this._insertReadonly
            } else {
              this.d = r + 2 * a;
              for (let m = 0; m < this.d * this.d; m++) c.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = r, this.extent = t, this.padding = a, this.scale = r / t, this.uid = 0;
            const p = a / r * t;
            this.min = -p, this.max = t + p
          }
          insert(t, r, a, c, p) {
            this._forEachCell(r, a, c, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(p)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, r, a, c, p, m) {
            this.cells[p].push(m)
          }
          query(t, r, a, c, p) {
            const m = this.min,
              v = this.max;
            if (t <= m && r <= m && v <= a && v <= c && !p) return Array.prototype.slice.call(this.keys);
            {
              const b = [];
              return this._forEachCell(t, r, a, c, this._queryCell, b, {}, p), b
            }
          }
          _queryCell(t, r, a, c, p, m, v, b) {
            const C = this.cells[p];
            if (C !== null) {
              const I = this.keys,
                R = this.bboxes;
              for (let U = 0; U < C.length; U++) {
                const Z = C[U];
                if (v[Z] === void 0) {
                  const X = 4 * Z;
                  (b ? b(R[X + 0], R[X + 1], R[X + 2], R[X + 3]) : t <= R[X + 2] && r <= R[X + 3] && a >= R[X + 0] && c >= R[X + 1]) ? (v[Z] = !0, m.push(I[Z])) : v[Z] = !1
                }
              }
            }
          }
          _forEachCell(t, r, a, c, p, m, v, b) {
            const C = this._convertToCellCoord(t),
              I = this._convertToCellCoord(r),
              R = this._convertToCellCoord(a),
              U = this._convertToCellCoord(c);
            for (let Z = C; Z <= R; Z++)
              for (let X = I; X <= U; X++) {
                const Q = this.d * X + Z;
                if ((!b || b(this._convertFromCellCoord(Z), this._convertFromCellCoord(X), this._convertFromCellCoord(Z + 1), this._convertFromCellCoord(X + 1))) && p.call(this, t, r, a, c, Q, m, v, b)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              r = 3 + this.cells.length + 1 + 1;
            let a = 0;
            for (let m = 0; m < this.cells.length; m++) a += this.cells[m].length;
            const c = new Int32Array(r + a + this.keys.length + this.bboxes.length);
            c[0] = this.extent, c[1] = this.n, c[2] = this.padding;
            let p = r;
            for (let m = 0; m < t.length; m++) {
              const v = t[m];
              c[3 + m] = p, c.set(v, p), p += v.length
            }
            return c[3 + t.length] = p, c.set(this.keys, p), p += this.keys.length, c[3 + t.length + 1] = p, c.set(this.bboxes, p), p += this.bboxes.length, c.buffer
          }
          static serialize(t, r) {
            const a = t.toArrayBuffer();
            return r && r.push(a), {
              buffer: a
            }
          }
          static deserialize(t) {
            return new Uo(t.buffer)
          }
        }
        const to = {};

        function sr(n, t, r = {}) {
          if (to[n]) throw new Error(`${n} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: n,
            writeable: !1
          }), to[n] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          }
        }
        sr("Object", Object), sr("Set", Set), sr("TransferableGridIndex", Uo), sr("Color", pr), sr("Error", Error), sr("AJAXError", H), sr("ResolvedImage", Vn), sr("StylePropertyFunction", Vl), sr("StyleExpression", nu, {
          omit: ["_evaluator"]
        }), sr("ZoomDependentExpression", iu), sr("ZoomConstantExpression", Xs), sr("CompoundExpression", xa, {
          omit: ["_evaluate"]
        });
        for (const n in ms) ms[n]._classRegistryKey || sr(`Expression_${n}`, ms[n]);

        function Rd(n) {
          return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer")
        }

        function mu(n) {
          return n.$name || n.constructor._classRegistryKey
        }

        function Fd(n) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const r = mu(t);
            return !(!r || r === "Object")
          })(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || Rd(n) || jt(n) || ArrayBuffer.isView(n) || n instanceof ImageData)
        }

        function ro(n, t) {
          if (Fd(n)) return (Rd(n) || jt(n)) && t && t.push(n), ArrayBuffer.isView(n) && t && t.push(n.buffer), n instanceof ImageData && t && t.push(n.data.buffer), n;
          if (Array.isArray(n)) {
            const p = [];
            for (const m of n) p.push(ro(m, t));
            return p
          }
          if (typeof n != "object") throw new Error("can't serialize object of type " + typeof n);
          const r = mu(n);
          if (!r) throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`);
          if (!to[r]) throw new Error(`${r} is not registered.`);
          const {
            klass: a
          } = to[r], c = a.serialize ? a.serialize(n, t) : {};
          if (a.serialize) {
            if (t && c === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const p in n) {
              if (!n.hasOwnProperty(p) || to[r].omit.indexOf(p) >= 0) continue;
              const m = n[p];
              c[p] = to[r].shallow.indexOf(p) >= 0 ? m : ro(m, t)
            }
            n instanceof Error && (c.message = n.message)
          }
          if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (c.$name = r), c
        }

        function tl(n) {
          if (Fd(n)) return n;
          if (Array.isArray(n)) return n.map(tl);
          if (typeof n != "object") throw new Error("can't deserialize object of type " + typeof n);
          const t = mu(n) || "Object";
          if (!to[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: r
          } = to[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(n);
          const a = Object.create(r.prototype);
          for (const c of Object.keys(n)) {
            if (c === "$name") continue;
            const p = n[c];
            a[c] = to[t].shallow.indexOf(c) >= 0 ? p : tl(p)
          }
          return a
        }
        class _u {
          constructor() {
            this.first = !0
          }
          update(t, r) {
            const a = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = a, !0))
          }
        }
        const pn = {
          "Latin-1 Supplement": n => n >= 128 && n <= 255,
          "Hangul Jamo": n => n >= 4352 && n <= 4607,
          Khmer: n => n >= 6016 && n <= 6143,
          "General Punctuation": n => n >= 8192 && n <= 8303,
          "Letterlike Symbols": n => n >= 8448 && n <= 8527,
          "Number Forms": n => n >= 8528 && n <= 8591,
          "Miscellaneous Technical": n => n >= 8960 && n <= 9215,
          "Control Pictures": n => n >= 9216 && n <= 9279,
          "Optical Character Recognition": n => n >= 9280 && n <= 9311,
          "Enclosed Alphanumerics": n => n >= 9312 && n <= 9471,
          "Geometric Shapes": n => n >= 9632 && n <= 9727,
          "Miscellaneous Symbols": n => n >= 9728 && n <= 9983,
          "Miscellaneous Symbols and Arrows": n => n >= 11008 && n <= 11263,
          "Ideographic Description Characters": n => n >= 12272 && n <= 12287,
          "CJK Symbols and Punctuation": n => n >= 12288 && n <= 12351,
          Hiragana: n => n >= 12352 && n <= 12447,
          Katakana: n => n >= 12448 && n <= 12543,
          Kanbun: n => n >= 12688 && n <= 12703,
          "CJK Strokes": n => n >= 12736 && n <= 12783,
          "Enclosed CJK Letters and Months": n => n >= 12800 && n <= 13055,
          "CJK Compatibility": n => n >= 13056 && n <= 13311,
          "Yijing Hexagram Symbols": n => n >= 19904 && n <= 19967,
          "CJK Unified Ideographs": n => n >= 19968 && n <= 40959,
          "Hangul Syllables": n => n >= 44032 && n <= 55215,
          "Private Use Area": n => n >= 57344 && n <= 63743,
          "Vertical Forms": n => n >= 65040 && n <= 65055,
          "CJK Compatibility Forms": n => n >= 65072 && n <= 65103,
          "Small Form Variants": n => n >= 65104 && n <= 65135,
          "Halfwidth and Fullwidth Forms": n => n >= 65280 && n <= 65519
        };

        function gu(n) {
          for (const t of n)
            if (Yl(t.charCodeAt(0))) return !0;
          return !1
        }

        function vu(n) {
          for (const t of n)
            if (!Od(t.charCodeAt(0))) return !1;
          return !0
        }

        function ws(n) {
          const t = n.map((r => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source
            } catch {
              return null
            }
          })).filter((r => r));
          return new RegExp(t.join("|"), "u")
        }
        const Bd = ws(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function Od(n) {
          return !Bd.test(String.fromCodePoint(n))
        }
        const yu = ws(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function Yl(n) {
          return !(n !== 746 && n !== 747 && (n < 4352 || !(pn["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || pn["CJK Compatibility"](n) || pn["CJK Strokes"](n) || !(!pn["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || pn["Enclosed CJK Letters and Months"](n) || pn["Ideographic Description Characters"](n) || pn.Kanbun(n) || pn.Katakana(n) && n !== 12540 || !(!pn["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!pn["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || pn["Vertical Forms"](n) || pn["Yijing Hexagram Symbols"](n) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(n)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(n)) || yu.test(String.fromCodePoint(n)))))
        }

        function Kl(n) {
          return !(Yl(n) || (function(t) {
            return !!(pn["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || pn["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || pn["Letterlike Symbols"](t) || pn["Number Forms"](t) || pn["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || pn["Control Pictures"](t) && t !== 9251 || pn["Optical Character Recognition"](t) || pn["Enclosed Alphanumerics"](t) || pn["Geometric Shapes"](t) || pn["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || pn["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || pn["CJK Symbols and Punctuation"](t) || pn.Katakana(t) || pn["Private Use Area"](t) || pn["CJK Compatibility Forms"](t) || pn["Small Form Variants"](t) || pn["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(n))
        }
        const Nd = ws(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function jd(n) {
          return Nd.test(String.fromCodePoint(n))
        }

        function Vd(n, t) {
          return !(!t && jd(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || pn.Khmer(n))
        }

        function xf(n) {
          for (const t of n)
            if (jd(t.charCodeAt(0))) return !0;
          return !1
        }
        const no = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(n) {
            this.pluginStatus = n.pluginStatus, this.pluginURL = n.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(n) {
            if (no.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = n.applyArabicShaping, this.processBidirectionalText = n.processBidirectionalText, this.processStyledBidirectionalText = n.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(n, t) {
            return s(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (n.pluginStatus !== "loading") return this.setState(n), n;
              const r = n.pluginURL,
                a = new Promise((p => {
                  this.loadScriptResolve = p
                }));
              t(r);
              const c = new Promise((p => setTimeout((() => p()), this.TIMEOUT)));
              if (yield Promise.race([a, c]), this.isParsed()) {
                const p = {
                  pluginStatus: "loaded",
                  pluginURL: r
                };
                return this.setState(p), p
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            }))
          }
        };
        class Bn {
          constructor(t, r) {
            this.isSupportedScript = qd, this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new _u, this.transition = r.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new _u, this.transition = {})
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              r = t - Math.floor(t),
              a = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: r + (1 - r) * a
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - a) * r
            }
          }
        }

        function qd(n) {
          return (function(t, r) {
            for (const a of t)
              if (!Vd(a.charCodeAt(0), r)) return !1;
            return !0
          })(n, no.getRTLTextPluginStatus() === "loaded")
        }
        class rl {
          constructor(t, r, a) {
            this.property = t, this.value = r, this.expression = (function(c, p, m) {
              if (Nl(c)) return new Vl(c, p);
              if (jl(c)) {
                const v = yd(c, p, m);
                if (v.result === "error") throw new Error(v.value.map((b => `${b.key}: ${b.message}`)).join(", "));
                return v.value
              } {
                let v = c;
                return p.type === "color" && typeof c == "string" ? v = pr.parse(c) : p.type !== "padding" || typeof c != "number" && !Array.isArray(c) ? p.type !== "numberArray" || typeof c != "number" && !Array.isArray(c) ? p.type !== "colorArray" || typeof c != "string" && !Array.isArray(c) ? p.type === "variableAnchorOffsetCollection" && Array.isArray(c) ? v = In.parse(c) : p.type === "projectionDefinition" && typeof c == "string" && (v = _i.parse(c)) : v = vn.parse(c) : v = Rr.parse(c) : v = en.parse(c), {
                  globalStateRefs: new Set,
                  _globalState: null,
                  kind: "constant",
                  evaluate: () => v
                }
              }
            })(r === void 0 ? t.specification.default : r, t.specification, a)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, r, a) {
            return this.property.possiblyEvaluate(this, t, r, a)
          }
        }
        class xu {
          constructor(t, r) {
            this.property = t, this.value = new rl(t, void 0, r)
          }
          transitioned(t, r) {
            return new bu(this.property, this.value, r, ot({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new bu(this.property, this.value, null, {}, 0)
          }
        }
        class Ud {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = r
          }
          getValue(t) {
            return kt(this._values[t].value.value)
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new xu(this._values[t].property, this._globalState)), this._values[t].value = new rl(this._values[t].property, r === null ? void 0 : kt(r), this._globalState)
          }
          getTransition(t) {
            return kt(this._values[t].transition)
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new xu(this._values[t].property, this._globalState)), this._values[t].transition = kt(r) || void 0
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const a = this.getValue(r);
              a !== void 0 && (t[r] = a);
              const c = this.getTransition(r);
              c !== void 0 && (t[`${r}-transition`] = c)
            }
            return t
          }
          transitioned(t, r) {
            const a = new wu(this._properties);
            for (const c of Object.keys(this._values)) a._values[c] = this._values[c].transitioned(t, r._values[c]);
            return a
          }
          untransitioned() {
            const t = new wu(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t
          }
        }
        class bu {
          constructor(t, r, a, c, p) {
            this.property = t, this.value = r, this.begin = p + c.delay || 0, this.end = this.begin + c.duration || 0, t.specification.transition && (c.delay || c.duration) && (this.prior = a)
          }
          possiblyEvaluate(t, r, a) {
            const c = t.now || 0,
              p = this.value.possiblyEvaluate(t, r, a),
              m = this.prior;
            if (m) {
              if (c > this.end) return this.prior = null, p;
              if (this.value.isDataDriven()) return this.prior = null, p;
              if (c < this.begin) return m.possiblyEvaluate(t, r, a);
              {
                const v = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(m.possiblyEvaluate(t, r, a), p, _t(v))
              }
            }
            return p
          }
        }
        class wu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, r, a) {
            const c = new Zo(this._properties);
            for (const p of Object.keys(this._values)) c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
            return c
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class Zd {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = r
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return kt(this._values[t].value)
          }
          setValue(t, r) {
            this._values[t] = new rl(this._values[t].property, r === null ? void 0 : kt(r), this._globalState)
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const a = this.getValue(r);
              a !== void 0 && (t[r] = a)
            }
            return t
          }
          possiblyEvaluate(t, r, a) {
            const c = new Zo(this._properties);
            for (const p of Object.keys(this._values)) c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
            return c
          }
        }
        class Pa {
          constructor(t, r, a) {
            this.property = t, this.value = r, this.parameters = a
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, r, a, c) {
            return this.property.evaluate(this.value, this.parameters, t, r, a, c)
          }
        }
        class Zo {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class Ar {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r)
          }
          interpolate(t, r, a) {
            const c = ya[this.specification.type];
            return c ? c(t, r, a) : t
          }
        }
        class Ur {
          constructor(t, r) {
            this.specification = t, this.overrides = r
          }
          possiblyEvaluate(t, r, a, c) {
            return new Pa(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(r, null, {}, a, c)
            } : t.expression, r)
          }
          interpolate(t, r, a) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new Pa(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const c = ya[this.specification.type];
            if (c) {
              const p = c(t.value.value, r.value.value, a);
              return new Pa(this, {
                kind: "constant",
                value: p
              }, t.parameters)
            }
            return t
          }
          evaluate(t, r, a, c, p, m) {
            return t.kind === "constant" ? t.value : t.evaluate(r, a, c, p, m)
          }
        }
        class nl extends Ur {
          possiblyEvaluate(t, r, a, c) {
            if (t.value === void 0) return new Pa(this, {
              kind: "constant",
              value: void 0
            }, r);
            if (t.expression.kind === "constant") {
              const p = t.expression.evaluate(r, null, {}, a, c),
                m = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p,
                v = this._calculate(m, m, m, r);
              return new Pa(this, {
                kind: "constant",
                value: v
              }, r)
            }
            if (t.expression.kind === "camera") {
              const p = this._calculate(t.expression.evaluate({
                zoom: r.zoom - 1
              }), t.expression.evaluate({
                zoom: r.zoom
              }), t.expression.evaluate({
                zoom: r.zoom + 1
              }), r);
              return new Pa(this, {
                kind: "constant",
                value: p
              }, r)
            }
            return new Pa(this, t.expression, r)
          }
          evaluate(t, r, a, c, p, m) {
            if (t.kind === "source") {
              const v = t.evaluate(r, a, c, p, m);
              return this._calculate(v, v, v, r)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(r.zoom) - 1
            }, a, c), t.evaluate({
              zoom: Math.floor(r.zoom)
            }, a, c), t.evaluate({
              zoom: Math.floor(r.zoom) + 1
            }, a, c), r) : t.value
          }
          _calculate(t, r, a, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: a,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Gd {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, a, c) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const p = t.expression.evaluate(r, null, {}, a, c);
                return this._calculate(p, p, p, r)
              }
              return this._calculate(t.expression.evaluate(new Bn(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new Bn(Math.floor(r.zoom), r)), t.expression.evaluate(new Bn(Math.floor(r.zoom + 1), r)), r)
            }
          }
          _calculate(t, r, a, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: a,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class il {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, a, c) {
            return !!t.expression.evaluate(r, null, {}, a, c)
          }
          interpolate() {
            return !1
          }
        }
        class Zi {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const a = t[r];
              a.specification.overridable && this.overridableProperties.push(r);
              const c = this.defaultPropertyValues[r] = new rl(a, void 0, void 0),
                p = this.defaultTransitionablePropertyValues[r] = new xu(a, void 0);
              this.defaultTransitioningPropertyValues[r] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = c.possiblyEvaluate({})
            }
          }
        }
        sr("DataDrivenProperty", Ur), sr("DataConstantProperty", Ar), sr("CrossFadedDataDrivenProperty", nl), sr("CrossFadedProperty", Gd), sr("ColorRampProperty", il);
        const Tu = "-transition";
        class Ia extends Tt {
          constructor(t, r, a) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = a, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Ys(t.filter, a)), r.layout && (this._unevaluatedLayout = new Zd(r.layout, a)), r.paint)) {
              this._transitionablePaint = new Ud(r.paint, a);
              for (const c in t.paint) this.setPaintProperty(c, t.paint[c], {
                validate: !1
              });
              for (const c in t.layout) this.setLayoutProperty(c, t.layout[c], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Zo(r.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Ys(t, this._globalState)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const r in this._unevaluatedLayout._values) {
                const a = this._unevaluatedLayout._values[r];
                for (const c of a.getGlobalStateRefs()) t.add(c)
              }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const r = new globalThis.Map;
            if (this._transitionablePaint)
              for (const a in this._transitionablePaint._values) {
                const c = this._transitionablePaint._values[a].value;
                for (const p of c.getGlobalStateRefs()) {
                  const m = (t = r.get(p)) !== null && t !== void 0 ? t : [];
                  m.push({
                    name: a,
                    value: c.value
                  }), r.set(p, m)
                }
              }
            return r
          }
          setLayoutProperty(t, r, a = {}) {
            r != null && this._validate(fu, `layers.${this.id}.layout.${t}`, t, r, a) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
          }
          getPaintProperty(t) {
            return t.endsWith(Tu) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, r, a = {}) {
            if (r != null && this._validate(Ld, `layers.${this.id}.paint.${t}`, t, r, a)) return !1;
            if (t.endsWith(Tu)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
            {
              const c = this._transitionablePaint._values[t],
                p = c.property.specification["property-type"] === "cross-faded-data-driven",
                m = c.value.isDataDriven(),
                v = c.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const b = this._transitionablePaint._values[t].value;
              return b.isDataDriven() || m || p || this._handleOverridablePaintPropertyUpdate(t, v, b)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, r, a) {
            return !1
          }
          isHidden(t, r = !1) {
            return !!(this.minzoom && t < (r ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), wt(t, ((r, a) => !(r === void 0 || a === "layout" && !Object.keys(r).length || a === "paint" && !Object.keys(r).length)))
          }
          _validate(t, r, a, c, p = {}) {
            return (!p || p.validate !== !1) && Dd(this, t.call(bs, {
              key: r,
              layerType: this.type,
              objectKey: a,
              value: c,
              styleSpec: _e,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof Pa && gs(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0
            }
            return !1
          }
        }
        let $d;
        var bf = {
          get paint() {
            return $d = $d || new Zi({
              "raster-opacity": new Ar(_e.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new Ar(_e.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new Ar(_e.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new Ar(_e.paint_raster["raster-brightness-max"]),
              "raster-saturation": new Ar(_e.paint_raster["raster-saturation"]),
              "raster-contrast": new Ar(_e.paint_raster["raster-contrast"]),
              "raster-resampling": new Ar(_e.paint_raster["raster-resampling"]),
              "raster-fade-duration": new Ar(_e.paint_raster["raster-fade-duration"])
            })
          }
        };
        class wf extends Ia {
          constructor(t, r) {
            super(t, bf, r)
          }
        }
        const Tf = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class Ua {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class Jn {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function si(n, t = 1) {
          let r = 0,
            a = 0;
          return {
            members: n.map((c => {
              const p = Tf[c.type].BYTES_PER_ELEMENT,
                m = r = Hd(r, Math.max(t, p)),
                v = c.components || 1;
              return a = Math.max(a, p), r += p * v, {
                name: c.name,
                type: c.type,
                components: v,
                offset: m
              }
            })),
            size: Hd(r, Math.max(a, t)),
            alignment: t
          }
        }

        function Hd(n, t) {
          return Math.ceil(n / t) * t
        }
        class Ts extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.int16[c + 0] = r, this.int16[c + 1] = a, t
          }
        }
        Ts.prototype.bytesPerElement = 4, sr("StructArrayLayout2i4", Ts);
        class Jl extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.int16[p + 0] = r, this.int16[p + 1] = a, this.int16[p + 2] = c, t
          }
        }
        Jl.prototype.bytesPerElement = 6, sr("StructArrayLayout3i6", Jl);
        class Su extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, a, c)
          }
          emplace(t, r, a, c, p) {
            const m = 4 * t;
            return this.int16[m + 0] = r, this.int16[m + 1] = a, this.int16[m + 2] = c, this.int16[m + 3] = p, t
          }
        }
        Su.prototype.bytesPerElement = 8, sr("StructArrayLayout4i8", Su);
        class io extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m)
          }
          emplace(t, r, a, c, p, m, v) {
            const b = 6 * t;
            return this.int16[b + 0] = r, this.int16[b + 1] = a, this.int16[b + 2] = c, this.int16[b + 3] = p, this.int16[b + 4] = m, this.int16[b + 5] = v, t
          }
        }
        io.prototype.bytesPerElement = 12, sr("StructArrayLayout2i4i12", io);
        class Ql extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m)
          }
          emplace(t, r, a, c, p, m, v) {
            const b = 4 * t,
              C = 8 * t;
            return this.int16[b + 0] = r, this.int16[b + 1] = a, this.uint8[C + 4] = c, this.uint8[C + 5] = p, this.uint8[C + 6] = m, this.uint8[C + 7] = v, t
          }
        }
        Ql.prototype.bytesPerElement = 8, sr("StructArrayLayout2i4ub8", Ql);
        class Go extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.float32[c + 0] = r, this.float32[c + 1] = a, t
          }
        }
        Go.prototype.bytesPerElement = 8, sr("StructArrayLayout2f8", Go);
        class ec extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m, v, b, C, I) {
            const R = this.length;
            return this.resize(R + 1), this.emplace(R, t, r, a, c, p, m, v, b, C, I)
          }
          emplace(t, r, a, c, p, m, v, b, C, I, R) {
            const U = 10 * t;
            return this.uint16[U + 0] = r, this.uint16[U + 1] = a, this.uint16[U + 2] = c, this.uint16[U + 3] = p, this.uint16[U + 4] = m, this.uint16[U + 5] = v, this.uint16[U + 6] = b, this.uint16[U + 7] = C, this.uint16[U + 8] = I, this.uint16[U + 9] = R, t
          }
        }
        ec.prototype.bytesPerElement = 20, sr("StructArrayLayout10ui20", ec);
        class al extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m, v, b) {
            const C = this.length;
            return this.resize(C + 1), this.emplace(C, t, r, a, c, p, m, v, b)
          }
          emplace(t, r, a, c, p, m, v, b, C) {
            const I = 8 * t;
            return this.uint16[I + 0] = r, this.uint16[I + 1] = a, this.uint16[I + 2] = c, this.uint16[I + 3] = p, this.uint16[I + 4] = m, this.uint16[I + 5] = v, this.uint16[I + 6] = b, this.uint16[I + 7] = C, t
          }
        }
        al.prototype.bytesPerElement = 16, sr("StructArrayLayout8ui16", al);
        class Cu extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m, v, b, C, I, R, U) {
            const Z = this.length;
            return this.resize(Z + 1), this.emplace(Z, t, r, a, c, p, m, v, b, C, I, R, U)
          }
          emplace(t, r, a, c, p, m, v, b, C, I, R, U, Z) {
            const X = 12 * t;
            return this.int16[X + 0] = r, this.int16[X + 1] = a, this.int16[X + 2] = c, this.int16[X + 3] = p, this.uint16[X + 4] = m, this.uint16[X + 5] = v, this.uint16[X + 6] = b, this.uint16[X + 7] = C, this.int16[X + 8] = I, this.int16[X + 9] = R, this.int16[X + 10] = U, this.int16[X + 11] = Z, t
          }
        }
        Cu.prototype.bytesPerElement = 24, sr("StructArrayLayout4i4ui4i24", Cu);
        class Ss extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.float32[p + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = c, t
          }
        }
        Ss.prototype.bytesPerElement = 12, sr("StructArrayLayout3f12", Ss);
        class $o extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t
          }
        }
        $o.prototype.bytesPerElement = 4, sr("StructArrayLayout1ul4", $o);
        class Pu extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m, v, b, C) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, r, a, c, p, m, v, b, C)
          }
          emplace(t, r, a, c, p, m, v, b, C, I) {
            const R = 10 * t,
              U = 5 * t;
            return this.int16[R + 0] = r, this.int16[R + 1] = a, this.int16[R + 2] = c, this.int16[R + 3] = p, this.int16[R + 4] = m, this.int16[R + 5] = v, this.uint32[U + 3] = b, this.uint16[R + 8] = C, this.uint16[R + 9] = I, t
          }
        }
        Pu.prototype.bytesPerElement = 20, sr("StructArrayLayout6i1ul2ui20", Pu);
        class tc extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m)
          }
          emplace(t, r, a, c, p, m, v) {
            const b = 6 * t;
            return this.int16[b + 0] = r, this.int16[b + 1] = a, this.int16[b + 2] = c, this.int16[b + 3] = p, this.int16[b + 4] = m, this.int16[b + 5] = v, t
          }
        }
        tc.prototype.bytesPerElement = 12, sr("StructArrayLayout2i2i2i12", tc);
        class Ho extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, r, a, c, p)
          }
          emplace(t, r, a, c, p, m) {
            const v = 4 * t,
              b = 8 * t;
            return this.float32[v + 0] = r, this.float32[v + 1] = a, this.float32[v + 2] = c, this.int16[b + 6] = p, this.int16[b + 7] = m, t
          }
        }
        Ho.prototype.bytesPerElement = 16, sr("StructArrayLayout2f1f2i16", Ho);
        class Iu extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, a, c, p, m)
          }
          emplace(t, r, a, c, p, m, v) {
            const b = 16 * t,
              C = 4 * t,
              I = 8 * t;
            return this.uint8[b + 0] = r, this.uint8[b + 1] = a, this.float32[C + 1] = c, this.float32[C + 2] = p, this.int16[I + 6] = m, this.int16[I + 7] = v, t
          }
        }
        Iu.prototype.bytesPerElement = 16, sr("StructArrayLayout2ub2f2i16", Iu);
        class rc extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.uint16[p + 0] = r, this.uint16[p + 1] = a, this.uint16[p + 2] = c, t
          }
        }
        rc.prototype.bytesPerElement = 6, sr("StructArrayLayout3ui6", rc);
        class nc extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, ue) {
            const Ne = this.length;
            return this.resize(Ne + 1), this.emplace(Ne, t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, ue)
          }
          emplace(t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, ue, Ne) {
            const ye = 24 * t,
              Ce = 12 * t,
              tt = 48 * t;
            return this.int16[ye + 0] = r, this.int16[ye + 1] = a, this.uint16[ye + 2] = c, this.uint16[ye + 3] = p, this.uint32[Ce + 2] = m, this.uint32[Ce + 3] = v, this.uint32[Ce + 4] = b, this.uint16[ye + 10] = C, this.uint16[ye + 11] = I, this.uint16[ye + 12] = R, this.float32[Ce + 7] = U, this.float32[Ce + 8] = Z, this.uint8[tt + 36] = X, this.uint8[tt + 37] = Q, this.uint8[tt + 38] = ie, this.uint32[Ce + 10] = ue, this.int16[ye + 22] = Ne, t
          }
        }
        nc.prototype.bytesPerElement = 48, sr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", nc);
        class Mu extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, ue, Ne, ye, Ce, tt, dt, Rt, ir, Wt, er, Fr, Qt) {
            const tr = this.length;
            return this.resize(tr + 1), this.emplace(tr, t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, ue, Ne, ye, Ce, tt, dt, Rt, ir, Wt, er, Fr, Qt)
          }
          emplace(t, r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, ue, Ne, ye, Ce, tt, dt, Rt, ir, Wt, er, Fr, Qt, tr) {
            const St = 32 * t,
              $r = 16 * t;
            return this.int16[St + 0] = r, this.int16[St + 1] = a, this.int16[St + 2] = c, this.int16[St + 3] = p, this.int16[St + 4] = m, this.int16[St + 5] = v, this.int16[St + 6] = b, this.int16[St + 7] = C, this.uint16[St + 8] = I, this.uint16[St + 9] = R, this.uint16[St + 10] = U, this.uint16[St + 11] = Z, this.uint16[St + 12] = X, this.uint16[St + 13] = Q, this.uint16[St + 14] = ie, this.uint16[St + 15] = ue, this.uint16[St + 16] = Ne, this.uint16[St + 17] = ye, this.uint16[St + 18] = Ce, this.uint16[St + 19] = tt, this.uint16[St + 20] = dt, this.uint16[St + 21] = Rt, this.uint16[St + 22] = ir, this.uint32[$r + 12] = Wt, this.float32[$r + 13] = er, this.float32[$r + 14] = Fr, this.uint16[St + 30] = Qt, this.uint16[St + 31] = tr, t
          }
        }
        Mu.prototype.bytesPerElement = 64, sr("StructArrayLayout8i15ui1ul2f2ui64", Mu);
        class h extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t
          }
        }
        h.prototype.bytesPerElement = 4, sr("StructArrayLayout1f4", h);
        class e extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = c, t
          }
        }
        e.prototype.bytesPerElement = 12, sr("StructArrayLayout1ui2f12", e);
        class i extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, a)
          }
          emplace(t, r, a, c) {
            const p = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[p + 2] = a, this.uint16[p + 3] = c, t
          }
        }
        i.prototype.bytesPerElement = 8, sr("StructArrayLayout1ul2ui8", i);
        class l extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, r)
          }
          emplace(t, r, a) {
            const c = 2 * t;
            return this.uint16[c + 0] = r, this.uint16[c + 1] = a, t
          }
        }
        l.prototype.bytesPerElement = 4, sr("StructArrayLayout2ui4", l);
        class u extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t
          }
        }
        u.prototype.bytesPerElement = 2, sr("StructArrayLayout1ui2", u);
        class d extends Jn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, a, c) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, a, c)
          }
          emplace(t, r, a, c, p) {
            const m = 4 * t;
            return this.float32[m + 0] = r, this.float32[m + 1] = a, this.float32[m + 2] = c, this.float32[m + 3] = p, t
          }
        }
        d.prototype.bytesPerElement = 16, sr("StructArrayLayout4f16", d);
        class g extends Ua {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new B(this.anchorPointX, this.anchorPointY)
          }
        }
        g.prototype.size = 20;
        class T extends Pu {
          get(t) {
            return new g(this, t)
          }
        }
        sr("CollisionBoxArray", T);
        class S extends Ua {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        S.prototype.size = 48;
        class k extends nc {
          get(t) {
            return new S(this, t)
          }
        }
        sr("PlacedSymbolArray", k);
        class z extends Ua {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        z.prototype.size = 64;
        class V extends Mu {
          get(t) {
            return new z(this, t)
          }
        }
        sr("SymbolInstanceArray", V);
        class F extends h {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        sr("GlyphOffsetArray", F);
        class $ extends Jl {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        sr("SymbolLineVertexArray", $);
        class J extends Ua {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        J.prototype.size = 12;
        class ae extends e {
          get(t) {
            return new J(this, t)
          }
        }
        sr("TextAnchorOffsetArray", ae);
        class oe extends Ua {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        oe.prototype.size = 8;
        class se extends i {
          get(t) {
            return new oe(this, t)
          }
        }
        sr("FeatureIndexArray", se);
        class fe extends Ts {}
        class xe extends Ts {}
        class pe extends Ts {}
        class be extends io {}
        class Pe extends Ql {}
        class ge extends Go {}
        class Fe extends ec {}
        class nt extends al {}
        class et extends Cu {}
        class rt extends Ss {}
        class at extends $o {}
        class Gt extends tc {}
        class Ht extends Iu {}
        class Pt extends rc {}
        class gr extends l {}
        const Qr = si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: En
          } = Qr;
        class on {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, r, a, c) {
            const p = this.segments[this.segments.length - 1];
            return t > on.MAX_VERTEX_ARRAY_LENGTH && Nt(`Max vertices per segment is ${on.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${on.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > on.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== c ? this.createNewSegment(r, a, c) : p
          }
          createNewSegment(t, r, a) {
            const c = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return a !== void 0 && (c.sortKey = a), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(c), c
          }
          getOrCreateLatestSegment(t, r, a) {
            return this.prepareSegment(0, t, r, a)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const r in t.vaos) t.vaos[r].destroy()
          }
          static simpleSegment(t, r, a, c) {
            return new on([{
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: a,
              primitiveLength: c,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function On(n, t) {
          return 256 * (n = Lt(Math.floor(n), 0, 255)) + Lt(Math.floor(t), 0, 255)
        }
        on.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, sr("SegmentVector", on);
        const Qn = si([{
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
          }]),
          qn = si([{
            name: "a_dasharray_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_dasharray_to",
            components: 4,
            type: "Uint16"
          }]);
        var gi, Wn, Mi, Xn = {
            exports: {}
          },
          hi = {
            exports: {}
          },
          Ki = {
            exports: {}
          },
          Wo = (function() {
            if (Mi) return Xn.exports;
            Mi = 1;
            var n = (gi || (gi = 1, hi.exports = function(r, a) {
                var c, p, m, v, b, C, I, R;
                for (p = r.length - (c = 3 & r.length), m = a, b = 3432918353, C = 461845907, R = 0; R < p;) I = 255 & r.charCodeAt(R) | (255 & r.charCodeAt(++R)) << 8 | (255 & r.charCodeAt(++R)) << 16 | (255 & r.charCodeAt(++R)) << 24, ++R, m = 27492 + (65535 & (v = 5 * (65535 & (m = (m ^= I = (65535 & (I = (I = (65535 & I) * b + (((I >>> 16) * b & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * C + (((I >>> 16) * C & 65535) << 16) & 4294967295) << 13 | m >>> 19)) + ((5 * (m >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
                switch (I = 0, c) {
                  case 3:
                    I ^= (255 & r.charCodeAt(R + 2)) << 16;
                  case 2:
                    I ^= (255 & r.charCodeAt(R + 1)) << 8;
                  case 1:
                    m ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & r.charCodeAt(R))) * b + (((I >>> 16) * b & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * C + (((I >>> 16) * C & 65535) << 16) & 4294967295
                }
                return m ^= r.length, m = 2246822507 * (65535 & (m ^= m >>> 16)) + ((2246822507 * (m >>> 16) & 65535) << 16) & 4294967295, m = 3266489909 * (65535 & (m ^= m >>> 13)) + ((3266489909 * (m >>> 16) & 65535) << 16) & 4294967295, (m ^= m >>> 16) >>> 0
              }), hi.exports),
              t = (Wn || (Wn = 1, Ki.exports = function(r, a) {
                for (var c, p = r.length, m = a ^ p, v = 0; p >= 4;) c = 1540483477 * (65535 & (c = 255 & r.charCodeAt(v) | (255 & r.charCodeAt(++v)) << 8 | (255 & r.charCodeAt(++v)) << 16 | (255 & r.charCodeAt(++v)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), m = 1540483477 * (65535 & m) + ((1540483477 * (m >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), p -= 4, ++v;
                switch (p) {
                  case 3:
                    m ^= (255 & r.charCodeAt(v + 2)) << 16;
                  case 2:
                    m ^= (255 & r.charCodeAt(v + 1)) << 8;
                  case 1:
                    m = 1540483477 * (65535 & (m ^= 255 & r.charCodeAt(v))) + ((1540483477 * (m >>> 16) & 65535) << 16)
                }
                return m = 1540483477 * (65535 & (m ^= m >>> 13)) + ((1540483477 * (m >>> 16) & 65535) << 16), (m ^= m >>> 15) >>> 0
              }), Ki.exports);
            return Xn.exports = n, Xn.exports.murmur3 = n, Xn.exports.murmur2 = t, Xn.exports
          })(),
          ao = j(Wo);
        class Za {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, r, a, c) {
            this.ids.push(Xo(t)), this.positions.push(r, a, c)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = Xo(t);
            let a = 0,
              c = this.ids.length - 1;
            for (; a < c;) {
              const m = a + c >> 1;
              this.ids[m] >= r ? c = m : a = m + 1
            }
            const p = [];
            for (; this.ids[a] === r;) p.push({
              index: this.positions[3 * a],
              start: this.positions[3 * a + 1],
              end: this.positions[3 * a + 2]
            }), a++;
            return p
          }
          static serialize(t, r) {
            const a = new Float64Array(t.ids),
              c = new Uint32Array(t.positions);
            return Cs(a, c, 0, a.length - 1), r && r.push(a.buffer, c.buffer), {
              ids: a,
              positions: c
            }
          }
          static deserialize(t) {
            const r = new Za;
            return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r
          }
        }

        function Xo(n) {
          const t = +n;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : ao(String(n))
        }

        function Cs(n, t, r, a) {
          for (; r < a;) {
            const c = n[r + a >> 1];
            let p = r - 1,
              m = a + 1;
            for (;;) {
              do p++; while (n[p] < c);
              do m--; while (n[m] > c);
              if (p >= m) break;
              Yo(n, p, m), Yo(t, 3 * p, 3 * m), Yo(t, 3 * p + 1, 3 * m + 1), Yo(t, 3 * p + 2, 3 * m + 2)
            }
            m - r < a - m ? (Cs(n, t, r, m), r = m + 1) : (Cs(n, t, m + 1, a), a = m)
          }
        }

        function Yo(n, t, r) {
          const a = n[t];
          n[t] = n[r], n[r] = a
        }
        sr("FeaturePositionMap", Za);
        class na {
          constructor(t, r) {
            this.gl = t.gl, this.location = r
          }
        }
        class Ji extends na {
          constructor(t, r) {
            super(t, r), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class oo extends na {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class wo extends na {
          constructor(t, r) {
            super(t, r), this.current = pr.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const ol = new Float32Array(16);

        function di(n) {
          return [On(255 * n.r, 255 * n.g), On(255 * n.b, 255 * n.a)]
        }
        class li {
          constructor(t, r, a) {
            this.value = t, this.uniformNames = r.map((c => `u_${c}`)), this.type = a
          }
          setUniform(t, r, a) {
            t.set(a.constantOr(this.value))
          }
          getBinding(t, r, a) {
            return this.type === "color" ? new wo(t, r) : new Ji(t, r)
          }
        }
        class Ai {
          constructor(t, r) {
            this.uniformNames = r.map((a => `u_${a}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr
          }
          setConstantDashPositions(t, r) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, r.y, r.height, r.width]
          }
          setUniform(t, r, a, c) {
            let p = null;
            c === "u_pattern_to" ? p = this.patternTo : c === "u_pattern_from" ? p = this.patternFrom : c === "u_dasharray_to" ? p = this.dashTo : c === "u_dasharray_from" ? p = this.dashFrom : c === "u_pixel_ratio_to" ? p = this.pixelRatioTo : c === "u_pixel_ratio_from" && (p = this.pixelRatioFrom), p !== null && t.set(p)
          }
          getBinding(t, r, a) {
            return a.substr(0, 9) === "u_pattern" || a.substr(0, 12) === "u_dasharray_" ? new oo(t, r) : new Ji(t, r)
          }
        }
        class $n {
          constructor(t, r, a, c) {
            this.expression = t, this.type = a, this.maxValue = 0, this.paintVertexAttributes = r.map((p => ({
              name: `a_${p}`,
              type: "Float32",
              components: a === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new c
          }
          populatePaintArray(t, r, a) {
            const c = this.paintVertexArray.length,
              p = this.expression.evaluate(new Bn(0, a), r, {}, a.canonical, [], a.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(c, t, p)
          }
          updatePaintArray(t, r, a, c, p) {
            const m = this.expression.evaluate(new Bn(0, p), a, c);
            this._setPaintValue(t, r, m)
          }
          _setPaintValue(t, r, a) {
            if (this.type === "color") {
              const c = di(a);
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, c[0], c[1])
            } else {
              for (let c = t; c < r; c++) this.paintVertexArray.emplace(c, a);
              this.maxValue = Math.max(this.maxValue, Math.abs(a))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Ma {
          constructor(t, r, a, c, p, m) {
            this.expression = t, this.uniformNames = r.map((v => `u_${v}_t`)), this.type = a, this.useIntegerZoom = c, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = r.map((v => ({
              name: `a_${v}`,
              type: "Float32",
              components: a === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new m
          }
          populatePaintArray(t, r, a) {
            const c = this.expression.evaluate(new Bn(this.zoom, a), r, {}, a.canonical, [], a.formattedSection),
              p = this.expression.evaluate(new Bn(this.zoom + 1, a), r, {}, a.canonical, [], a.formattedSection),
              m = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(m, t, c, p)
          }
          updatePaintArray(t, r, a, c, p) {
            const m = this.expression.evaluate(new Bn(this.zoom, p), a, c),
              v = this.expression.evaluate(new Bn(this.zoom + 1, p), a, c);
            this._setPaintValue(t, r, m, v)
          }
          _setPaintValue(t, r, a, c) {
            if (this.type === "color") {
              const p = di(a),
                m = di(c);
              for (let v = t; v < r; v++) this.paintVertexArray.emplace(v, p[0], p[1], m[0], m[1])
            } else {
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, a, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(c))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, r) {
            const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
              c = Lt(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
            t.set(c)
          }
          getBinding(t, r, a) {
            return new Ji(t, r)
          }
        }
        class To {
          constructor(t, r, a, c, p, m) {
            this.expression = t, this.type = r, this.useIntegerZoom = a, this.zoom = c, this.layerId = m, this.zoomInPaintVertexArray = new p, this.zoomOutPaintVertexArray = new p
          }
          populatePaintArray(t, r, a) {
            const c = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(c, t, this.getPositionIds(r), a)
          }
          updatePaintArray(t, r, a, c, p) {
            this._setPaintValues(t, r, this.getPositionIds(a), p)
          }
          _setPaintValues(t, r, a, c) {
            const p = this.getPositions(c);
            if (!p || !a) return;
            const m = p[a.min],
              v = p[a.mid],
              b = p[a.max];
            if (m && v && b)
              for (let C = t; C < r; C++) this.emplace(this.zoomInPaintVertexArray, C, v, m), this.emplace(this.zoomOutPaintVertexArray, C, v, b)
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const r = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, r, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, r, this.expression.isStateDependent)
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Wd extends To {
          getPositions(t) {
            return t.imagePositions
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId]
          }
          getVertexAttributes() {
            return Qn.members
          }
          emplace(t, r, a, c) {
            t.emplace(r, a.tlbr[0], a.tlbr[1], a.tlbr[2], a.tlbr[3], c.tlbr[0], c.tlbr[1], c.tlbr[2], c.tlbr[3], a.pixelRatio, c.pixelRatio)
          }
        }
        class Xd extends To {
          getPositions(t) {
            return t.dashPositions
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId]
          }
          getVertexAttributes() {
            return qn.members
          }
          emplace(t, r, a, c) {
            t.emplace(r, 0, a.y, a.height, a.width, 0, c.y, c.height, c.width)
          }
        }
        class Yd {
          constructor(t, r, a) {
            this.binders = {}, this._buffers = [];
            const c = [];
            for (const p in t.paint._values) {
              if (!a(p)) continue;
              const m = t.paint.get(p);
              if (!(m instanceof Pa && gs(m.property.specification))) continue;
              const v = Jo(p, t.type),
                b = m.value,
                C = m.property.specification.type,
                I = m.property.useIntegerZoom,
                R = m.property.specification["property-type"],
                U = R === "cross-faded" || R === "cross-faded-data-driven";
              if (b.kind === "constant") this.binders[p] = U ? new Ai(b.value, v) : new li(b.value, v, C), c.push(`/u_${p}`);
              else if (b.kind === "source" || U) {
                const Z = Au(p, C, "source");
                this.binders[p] = U ? p === "line-dasharray" ? new Xd(b, C, I, r, Z, t.id) : new Wd(b, C, I, r, Z, t.id) : new $n(b, v, C, Z), c.push(`/a_${p}`)
              } else {
                const Z = Au(p, C, "composite");
                this.binders[p] = new Ma(b, v, C, I, r, Z), c.push(`/z_${p}`)
              }
            }
            this.cacheKey = c.sort().join("")
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof $n || r instanceof Ma ? r.maxValue : 0
          }
          populatePaintArrays(t, r, a) {
            for (const c in this.binders) {
              const p = this.binders[c];
              (p instanceof $n || p instanceof Ma || p instanceof To) && p.populatePaintArray(t, r, a)
            }
          }
          setConstantPatternPositions(t, r) {
            for (const a in this.binders) {
              const c = this.binders[a];
              c instanceof Ai && c.setConstantPatternPositions(t, r)
            }
          }
          setConstantDashPositions(t, r) {
            for (const a in this.binders) {
              const c = this.binders[a];
              c instanceof Ai && c.setConstantDashPositions(t, r)
            }
          }
          updatePaintArrays(t, r, a, c, p) {
            let m = !1;
            for (const v in t) {
              const b = r.getPositions(v);
              for (const C of b) {
                const I = a.feature(C.index);
                for (const R in this.binders) {
                  const U = this.binders[R];
                  if ((U instanceof $n || U instanceof Ma || U instanceof To) && U.expression.isStateDependent === !0) {
                    const Z = c.paint.get(R);
                    U.expression = Z.value, U.updatePaintArray(C.start, C.end, I, t[v], p), m = !0
                  }
                }
              }
            }
            return m
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              (a instanceof li || a instanceof Ai) && t.push(...a.uniformNames.map((c => `#define HAS_UNIFORM_${c}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (a instanceof $n || a instanceof Ma)
                for (let c = 0; c < a.paintVertexAttributes.length; c++) t.push(a.paintVertexAttributes[c].name);
              else if (a instanceof To) {
                const c = a.getVertexAttributes();
                for (const p of c) t.push(p.name)
              }
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (a instanceof li || a instanceof Ai || a instanceof Ma)
                for (const c of a.uniformNames) t.push(c)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, r) {
            const a = [];
            for (const c in this.binders) {
              const p = this.binders[c];
              if (p instanceof li || p instanceof Ai || p instanceof Ma) {
                for (const m of p.uniformNames)
                  if (r[m]) {
                    const v = p.getBinding(t, r[m], m);
                    a.push({
                      name: m,
                      property: c,
                      binding: v
                    })
                  }
              }
            }
            return a
          }
          setUniforms(t, r, a, c) {
            for (const {
                name: p,
                property: m,
                binding: v
              }
              of r) this.binders[m].setUniform(v, c, a.get(m), p)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const a = this.binders[r];
              if (t && a instanceof To) {
                const c = t.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
                c && this._buffers.push(c)
              } else(a instanceof $n || a instanceof Ma) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const a = this.binders[r];
              (a instanceof $n || a instanceof Ma || a instanceof To) && a.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof $n || r instanceof Ma || r instanceof To) && r.destroy()
            }
          }
        }
        class Ko {
          constructor(t, r, a = () => !0) {
            this.programConfigurations = {};
            for (const c of t) this.programConfigurations[c.id] = new Yd(c, r, a);
            this.needsUpload = !1, this._featureMap = new Za, this._bufferOffset = 0
          }
          populatePaintArrays(t, r, a, c) {
            for (const p in this.programConfigurations) this.programConfigurations[p].populatePaintArrays(t, r, c);
            r.id !== void 0 && this._featureMap.add(r.id, a, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, r, a, c) {
            for (const p of a) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, r, p, c) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function Jo(n, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-dasharray": ["dasharray_to", "dasharray_from"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function Au(n, t, r) {
          const a = {
              color: {
                source: Go,
                composite: d
              },
              number: {
                source: h,
                composite: Go
              }
            },
            c = (function(p) {
              return {
                "line-pattern": {
                  source: Fe,
                  composite: Fe
                },
                "fill-pattern": {
                  source: Fe,
                  composite: Fe
                },
                "fill-extrusion-pattern": {
                  source: Fe,
                  composite: Fe
                },
                "line-dasharray": {
                  source: nt,
                  composite: nt
                }
              } [p]
            })(n);
          return c && c[r] || a[t][r]
        }
        sr("ConstantBinder", li), sr("CrossFadedConstantBinder", Ai), sr("SourceExpressionBinder", $n), sr("CrossFadedPatternBinder", Wd), sr("CrossFadedDasharrayBinder", Xd), sr("CompositeExpressionBinder", Ma), sr("ProgramConfiguration", Yd, {
          omit: ["_buffers"]
        }), sr("ProgramConfigurationSet", Ko);
        const ic = Math.pow(2, 14) - 1,
          ku = -ic - 1;

        function so(n) {
          const t = Ve / n.extent,
            r = n.loadGeometry();
          for (let a = 0; a < r.length; a++) {
            const c = r[a];
            for (let p = 0; p < c.length; p++) {
              const m = c[p],
                v = Math.round(m.x * t),
                b = Math.round(m.y * t);
              m.x = Lt(v, ku, ic), m.y = Lt(b, ku, ic), (v < m.x || v > m.x + 1 || b < m.y || b > m.y + 1) && Nt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return r
        }

        function So(n, t) {
          return {
            type: n.type,
            id: n.id,
            properties: n.properties,
            geometry: t ? so(n) : []
          }
        }
        const ac = -32768;

        function Wy(n, t, r, a, c) {
          n.emplaceBack(ac + 8 * t + a, ac + 8 * r + c)
        }
        class Sf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new xe, this.indexArray = new Pt, this.segments = new on, this.programConfigurations = new Ko(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            const c = this.layers[0],
              p = [];
            let m = null,
              v = !1,
              b = c.type === "heatmap";
            if (c.type === "circle") {
              const I = c;
              m = I.layout.get("circle-sort-key"), v = !m.isConstant(), b = b || I.paint.get("circle-pitch-alignment") === "map"
            }
            const C = b ? r.subdivisionGranularity.circle : 1;
            for (const {
                feature: I,
                id: R,
                index: U,
                sourceLayerIndex: Z
              }
              of t) {
              const X = this.layers[0]._featureFilter.needGeometry,
                Q = So(I, X);
              if (!this.layers[0]._featureFilter.filter(new Bn(this.zoom), Q, a)) continue;
              const ie = v ? m.evaluate(Q, {}, a) : void 0,
                ue = {
                  id: R,
                  properties: I.properties,
                  type: I.type,
                  sourceLayerIndex: Z,
                  index: U,
                  geometry: X ? Q.geometry : so(I),
                  patterns: {},
                  sortKey: ie
                };
              p.push(ue)
            }
            v && p.sort(((I, R) => I.sortKey - R.sortKey));
            for (const I of p) {
              const {
                geometry: R,
                index: U,
                sourceLayerIndex: Z
              } = I, X = t[U].feature;
              this.addFeature(I, R, U, a, C), r.featureIndex.insert(X, R, U, Z, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: a
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, En), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, r, a, c, p = 1) {
            let m;
            switch (p) {
              case 1:
                m = [0, 7];
                break;
              case 3:
                m = [0, 2, 5, 7];
                break;
              case 5:
                m = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                m = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`)
            }
            const v = m.length;
            for (const b of r)
              for (const C of b) {
                const I = C.x,
                  R = C.y;
                if (I < 0 || I >= Ve || R < 0 || R >= Ve) continue;
                const U = this.segments.prepareSegment(v * v, this.layoutVertexArray, this.indexArray, t.sortKey),
                  Z = U.vertexLength;
                for (let X = 0; X < v; X++)
                  for (let Q = 0; Q < v; Q++) Wy(this.layoutVertexArray, I, R, m[Q], m[X]);
                for (let X = 0; X < v - 1; X++)
                  for (let Q = 0; Q < v - 1; Q++) {
                    const ie = Z + X * v + Q,
                      ue = Z + (X + 1) * v + Q;
                    this.indexArray.emplaceBack(ie, ue + 1, ie + 1), this.indexArray.emplaceBack(ie, ue, ue + 1)
                  }
                U.vertexLength += v * v, U.primitiveLength += (v - 1) * (v - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {
              imagePositions: {},
              canonical: c
            })
          }
        }

        function $_(n, t) {
          for (let r = 0; r < n.length; r++)
            if (oc(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (oc(n, t[r])) return !0;
          return !!Cf(n, t)
        }

        function Kd(n, t, r) {
          return !!oc(n, t) || !!Pf(t, n, r)
        }

        function H_(n, t) {
          if (n.length === 1) return X_(t, n[0]);
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            for (let c = 0; c < a.length; c++)
              if (oc(n, a[c])) return !0
          }
          for (let r = 0; r < n.length; r++)
            if (X_(t, n[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (Cf(n, t[r])) return !0;
          return !1
        }

        function Xy(n, t, r) {
          if (n.length > 1) {
            if (Cf(n, t)) return !0;
            for (let a = 0; a < t.length; a++)
              if (Pf(t[a], n, r)) return !0
          }
          for (let a = 0; a < n.length; a++)
            if (Pf(n[a], t, r)) return !0;
          return !1
        }

        function Cf(n, t) {
          if (n.length === 0 || t.length === 0) return !1;
          for (let r = 0; r < n.length - 1; r++) {
            const a = n[r],
              c = n[r + 1];
            for (let p = 0; p < t.length - 1; p++)
              if (Yy(a, c, t[p], t[p + 1])) return !0
          }
          return !1
        }

        function Yy(n, t, r, a) {
          return $t(n, r, a) !== $t(t, r, a) && $t(n, t, r) !== $t(n, t, a)
        }

        function Pf(n, t, r) {
          const a = r * r;
          if (t.length === 1) return n.distSqr(t[0]) < a;
          for (let c = 1; c < t.length; c++)
            if (W_(n, t[c - 1], t[c]) < a) return !0;
          return !1
        }

        function W_(n, t, r) {
          const a = t.distSqr(r);
          if (a === 0) return n.distSqr(t);
          const c = ((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / a;
          return n.distSqr(c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t))
        }

        function X_(n, t) {
          let r, a, c, p = !1;
          for (let m = 0; m < n.length; m++) {
            r = n[m];
            for (let v = 0, b = r.length - 1; v < r.length; b = v++) a = r[v], c = r[b], a.y > t.y != c.y > t.y && t.x < (c.x - a.x) * (t.y - a.y) / (c.y - a.y) + a.x && (p = !p)
          }
          return p
        }

        function oc(n, t) {
          let r = !1;
          for (let a = 0, c = n.length - 1; a < n.length; c = a++) {
            const p = n[a],
              m = n[c];
            p.y > t.y != m.y > t.y && t.x < (m.x - p.x) * (t.y - p.y) / (m.y - p.y) + p.x && (r = !r)
          }
          return r
        }

        function Ky(n, t, r) {
          const a = r[0],
            c = r[2];
          if (n.x < a.x && t.x < a.x || n.x > c.x && t.x > c.x || n.y < a.y && t.y < a.y || n.y > c.y && t.y > c.y) return !1;
          const p = $t(n, t, r[0]);
          return p !== $t(n, t, r[1]) || p !== $t(n, t, r[2]) || p !== $t(n, t, r[3])
        }

        function sc(n, t, r) {
          const a = t.paint.get(n).value;
          return a.kind === "constant" ? a.value : r.programConfigurations.get(t.id).getMaxValue(n)
        }

        function Jd(n) {
          return Math.sqrt(n[0] * n[0] + n[1] * n[1])
        }

        function Qd(n, t, r, a, c) {
          if (!t[0] && !t[1]) return n;
          const p = B.convert(t)._mult(c);
          r === "viewport" && p._rotate(-a);
          const m = [];
          for (let v = 0; v < n.length; v++) m.push(n[v].sub(p));
          return m
        }

        function Jy({
          queryGeometry: n,
          size: t
        }, r) {
          return Kd(n, r, t)
        }

        function Qy({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: a,
          getElevation: c
        }, p) {
          return Kd(n, p, t * (r.projectTileCoordinates(p.x, p.y, a, c).signedDistanceFromCamera / r.cameraToCenterDistance))
        }

        function e1({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: a,
          getElevation: c
        }, p) {
          const m = r.projectTileCoordinates(p.x, p.y, a, c).signedDistanceFromCamera,
            v = t * (r.cameraToCenterDistance / m);
          return Kd(n, If(p, r, a, c), v)
        }

        function t1({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: a,
          getElevation: c
        }, p) {
          return Kd(n, If(p, r, a, c), t)
        }

        function Y_({
          queryGeometry: n,
          size: t,
          transform: r,
          unwrappedTileID: a,
          getElevation: c,
          pitchAlignment: p = "map",
          pitchScale: m = "map"
        }, v) {
          const b = p === "map" ? m === "map" ? Jy : Qy : m === "map" ? e1 : t1,
            C = {
              queryGeometry: n,
              size: t,
              transform: r,
              unwrappedTileID: a,
              getElevation: c
            };
          for (const I of v)
            for (const R of I)
              if (b(C, R)) return !0;
          return !1
        }

        function If(n, t, r, a) {
          const c = t.projectTileCoordinates(n.x, n.y, r, a).point;
          return new B((.5 * c.x + .5) * t.width, (.5 * -c.y + .5) * t.height)
        }
        let K_, J_;
        sr("CircleBucket", Sf, {
          omit: ["layers"]
        });
        var r1 = {
          get paint() {
            return J_ = J_ || new Zi({
              "circle-radius": new Ur(_e.paint_circle["circle-radius"]),
              "circle-color": new Ur(_e.paint_circle["circle-color"]),
              "circle-blur": new Ur(_e.paint_circle["circle-blur"]),
              "circle-opacity": new Ur(_e.paint_circle["circle-opacity"]),
              "circle-translate": new Ar(_e.paint_circle["circle-translate"]),
              "circle-translate-anchor": new Ar(_e.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new Ar(_e.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new Ar(_e.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new Ur(_e.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new Ur(_e.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new Ur(_e.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return K_ = K_ || new Zi({
              "circle-sort-key": new Ur(_e.layout_circle["circle-sort-key"])
            })
          }
        };
        class n1 extends Ia {
          constructor(t, r) {
            super(t, r1, r)
          }
          createBucket(t) {
            return new Sf(t)
          }
          queryRadius(t) {
            const r = t;
            return sc("circle-radius", this, r) + sc("circle-stroke-width", this, r) + Jd(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: m,
            unwrappedTileID: v,
            getElevation: b
          }) {
            const C = Qd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, m),
              I = this.paint.get("circle-radius").evaluate(r, a) + this.paint.get("circle-stroke-width").evaluate(r, a),
              R = this.paint.get("circle-pitch-scale"),
              U = this.paint.get("circle-pitch-alignment");
            let Z, X;
            return U === "map" ? (Z = C, X = I * m) : (Z = (function(Q, ie, ue, Ne) {
              return Q.map((ye => If(ye, ie, ue, Ne)))
            })(C, p, v, b), X = I), Y_({
              queryGeometry: Z,
              size: X,
              transform: p,
              unwrappedTileID: v,
              getElevation: b,
              pitchAlignment: U,
              pitchScale: R
            }, c)
          }
        }
        class Q_ extends Sf {}
        let eg;
        sr("HeatmapBucket", Q_, {
          omit: ["layers"]
        });
        var i1 = {
          get paint() {
            return eg = eg || new Zi({
              "heatmap-radius": new Ur(_e.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new Ur(_e.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new Ar(_e.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new il(_e.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new Ar(_e.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function Mf(n, {
          width: t,
          height: r
        }, a, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== t * r * a) throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t*r*a}`)
          } else c = new Uint8Array(t * r * a);
          return n.width = t, n.height = r, n.data = c, n
        }

        function tg(n, {
          width: t,
          height: r
        }, a) {
          if (t === n.width && r === n.height) return;
          const c = Mf({}, {
            width: t,
            height: r
          }, a);
          Af(n, c, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(n.width, t),
            height: Math.min(n.height, r)
          }, a), n.width = t, n.height = r, n.data = c.data
        }

        function Af(n, t, r, a, c, p) {
          if (c.width === 0 || c.height === 0) return t;
          if (c.width > n.width || c.height > n.height || r.x > n.width - c.width || r.y > n.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > t.width || c.height > t.height || a.x > t.width - c.width || a.y > t.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const m = n.data,
            v = t.data;
          if (m === v) throw new Error("srcData equals dstData, so image is already copied");
          for (let b = 0; b < c.height; b++) {
            const C = ((r.y + b) * n.width + r.x) * p,
              I = ((a.y + b) * t.width + a.x) * p;
            for (let R = 0; R < c.width * p; R++) v[I + R] = m[C + R]
          }
          return t
        }
        class Eu {
          constructor(t, r) {
            Mf(this, t, 1, r)
          }
          resize(t) {
            tg(this, t, 1)
          }
          clone() {
            return new Eu({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, a, c, p) {
            Af(t, r, a, c, p, 1)
          }
        }
        class ua {
          constructor(t, r) {
            Mf(this, t, 4, r)
          }
          resize(t) {
            tg(this, t, 4)
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new ua({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, a, c, p) {
            Af(t, r, a, c, p, 4)
          }
          setPixel(t, r, a) {
            const c = 4 * (t * this.width + r);
            this.data[c + 0] = Math.round(255 * a.r / a.a), this.data[c + 1] = Math.round(255 * a.g / a.a), this.data[c + 2] = Math.round(255 * a.b / a.a), this.data[c + 3] = Math.round(255 * a.a)
          }
        }

        function rg(n) {
          const t = {},
            r = n.resolution || 256,
            a = n.clips ? n.clips.length : 1,
            c = n.image || new ua({
              width: r,
              height: a
            });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const p = (m, v, b) => {
            t[n.evaluationKey] = b;
            const C = n.expression.evaluate(t);
            c.setPixel(m / 4 / r, v / 4, C)
          };
          if (n.clips)
            for (let m = 0, v = 0; m < a; ++m, v += 4 * r)
              for (let b = 0, C = 0; b < r; b++, C += 4) {
                const I = b / (r - 1),
                  {
                    start: R,
                    end: U
                  } = n.clips[m];
                p(v, C, R * (1 - I) + U * I)
              } else
                for (let m = 0, v = 0; m < r; m++, v += 4) p(0, v, m / (r - 1));
          return c
        }
        sr("AlphaImage", Eu), sr("RGBAImage", ua);
        const kf = "big-fb";
        class a1 extends Ia {
          createBucket(t) {
            return new Q_(t)
          }
          constructor(t, r) {
            super(t, i1, r), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = rg({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(kf) && this.heatmapFbos.delete(kf)
          }
          queryRadius(t) {
            return sc("heatmap-radius", this, t)
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: m,
            unwrappedTileID: v,
            getElevation: b
          }) {
            return Y_({
              queryGeometry: t,
              size: this.paint.get("heatmap-radius").evaluate(r, a) * m,
              transform: p,
              unwrappedTileID: v,
              getElevation: b
            }, c)
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let ng;
        var o1 = {
          get paint() {
            return ng = ng || new Zi({
              "hillshade-illumination-direction": new Ar(_e.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new Ar(_e.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new Ar(_e.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new Ar(_e.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new Ar(_e.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new Ar(_e.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new Ar(_e.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new Ar(_e.paint_hillshade["hillshade-method"])
            })
          }
        };
        class s1 extends Ia {
          constructor(t, r) {
            super(t, o1, r), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              r = this.paint.get("hillshade-illumination-altitude").values,
              a = this.paint.get("hillshade-highlight-color").values,
              c = this.paint.get("hillshade-shadow-color").values;
            const p = Math.max(t.length, r.length, a.length, c.length);
            t = t.concat(Array(p - t.length).fill(t.at(-1))), r = r.concat(Array(p - r.length).fill(r.at(-1))), a = a.concat(Array(p - a.length).fill(a.at(-1))), c = c.concat(Array(p - c.length).fill(c.at(-1)));
            const m = r.map(hr);
            return {
              directionRadians: t.map(hr),
              altitudeRadians: m,
              shadowColor: c,
              highlightColor: a
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let ig;
        var l1 = {
          get paint() {
            return ig = ig || new Zi({
              "color-relief-opacity": new Ar(_e["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new il(_e["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class Ef {
          constructor(t, r, a, c) {
            this.context = t, this.format = a, this.texture = t.gl.createTexture(), this.update(r, c)
          }
          update(t, r, a) {
            const {
              width: c,
              height: p
            } = t, m = !(this.size && this.size[0] === c && this.size[1] === p || a), {
              context: v
            } = this, {
              gl: b
            } = v;
            if (this.useMipmap = !!(r && r.useMipmap), b.bindTexture(b.TEXTURE_2D, this.texture), v.pixelStoreUnpackFlipY.set(!1), v.pixelStoreUnpack.set(1), v.pixelStoreUnpackPremultiplyAlpha.set(this.format === b.RGBA && (!r || r.premultiply !== !1)), m) this.size = [c, p], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || jt(t) ? b.texImage2D(b.TEXTURE_2D, 0, this.format, this.format, b.UNSIGNED_BYTE, t) : b.texImage2D(b.TEXTURE_2D, 0, this.format, c, p, 0, this.format, b.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: C,
                y: I
              } = a || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || jt(t) ? b.texSubImage2D(b.TEXTURE_2D, 0, C, I, b.RGBA, b.UNSIGNED_BYTE, t) : b.texSubImage2D(b.TEXTURE_2D, 0, C, I, c, p, b.RGBA, b.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && b.generateMipmap(b.TEXTURE_2D), v.pixelStoreUnpackFlipY.setDefault(), v.pixelStoreUnpack.setDefault(), v.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, r, a) {
            const {
              context: c
            } = this, {
              gl: p
            } = c;
            p.bindTexture(p.TEXTURE_2D, this.texture), a !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = p.LINEAR), t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || t), this.filter = t), r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r), this.wrap = r)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class ag {
          constructor(t, r, a, c = 1, p = 1, m = 1, v = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void Nt(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const b = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), a) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = c, this.greenFactor = p, this.blueFactor = m, this.baseShift = v;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let C = 0; C < b; C++) this.data[this._idx(-1, C)] = this.data[this._idx(0, C)], this.data[this._idx(b, C)] = this.data[this._idx(b - 1, C)], this.data[this._idx(C, -1)] = this.data[this._idx(C, 0)], this.data[this._idx(C, b)] = this.data[this._idx(C, b - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(b, -1)] = this.data[this._idx(b - 1, 0)], this.data[this._idx(-1, b)] = this.data[this._idx(0, b - 1)], this.data[this._idx(b, b)] = this.data[this._idx(b - 1, b - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let C = 0; C < b; C++)
              for (let I = 0; I < b; I++) {
                const R = this.get(C, I);
                R > this.max && (this.max = R), R < this.min && (this.min = R)
              }
          }
          get(t, r) {
            const a = new Uint8Array(this.data.buffer),
              c = 4 * this._idx(t, r);
            return this.unpack(a[c], a[c + 1], a[c + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1)
          }
          unpack(t, r, a) {
            return t * this.redFactor + r * this.greenFactor + a * this.blueFactor - this.baseShift
          }
          pack(t) {
            return og(t, this.getUnpackVector())
          }
          getPixels() {
            return new ua({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, r, a) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let c = r * this.dim,
              p = r * this.dim + this.dim,
              m = a * this.dim,
              v = a * this.dim + this.dim;
            switch (r) {
              case -1:
                c = p - 1;
                break;
              case 1:
                p = c + 1
            }
            switch (a) {
              case -1:
                m = v - 1;
                break;
              case 1:
                v = m + 1
            }
            const b = -r * this.dim,
              C = -a * this.dim;
            for (let I = m; I < v; I++)
              for (let R = c; R < p; R++) this.data[this._idx(R, I)] = t.data[this._idx(R + b, I + C)]
          }
        }

        function og(n, t) {
          const r = t[0],
            a = t[1],
            c = t[2],
            p = t[3],
            m = Math.min(r, a, c),
            v = Math.round((n + p) / m);
          return {
            r: Math.floor(v * m / r) % 256,
            g: Math.floor(v * m / a) % 256,
            b: Math.floor(v * m / c) % 256
          }
        }
        sr("DEMData", ag);
        class c1 extends Ia {
          constructor(t, r) {
            super(t, l1, r)
          }
          _createColorRamp(t) {
            const r = {
                elevationStops: [],
                colorStops: []
              },
              a = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (a instanceof Xs && a._styleExpression.expression instanceof kn) {
              this.colorRampExpression = a;
              const m = a._styleExpression.expression;
              r.elevationStops = m.labels, r.colorStops = [];
              for (const v of r.elevationStops) r.colorStops.push(m.evaluate({
                globals: {
                  elevation: v
                }
              }))
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [pr.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const c = {
                elevationStops: [],
                colorStops: []
              },
              p = (r.elevationStops.length - 1) / (t - 1);
            for (let m = 0; m < r.elevationStops.length - .5; m += p) c.elevationStops.push(r.elevationStops[Math.round(m)]), c.colorStops.push(r.colorStops[Math.round(m)]);
            return Nt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${r.elevationStops.length}`), c
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, r, a) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const c = this._createColorRamp(r),
              p = new ua({
                width: c.colorStops.length,
                height: 1
              }),
              m = new ua({
                width: c.colorStops.length,
                height: 1
              });
            for (let v = 0; v < c.elevationStops.length; v++) {
              const b = og(c.elevationStops[v], a);
              m.setPixel(0, v, new pr(b.r / 255, b.g / 255, b.b / 255, 1)), p.setPixel(0, v, c.colorStops[v])
            }
            return this.colorRampTextures = {
              elevationTexture: new Ef(t, m, t.gl.RGBA),
              colorTexture: new Ef(t, p, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const u1 = si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: h1
          } = u1;

        function ep(n, t, r) {
          const a = r.patternDependencies;
          let c = !1;
          for (const p of t) {
            const m = p.paint.get(`${n}-pattern`);
            m.isConstant() || (c = !0);
            const v = m.constantOr(null);
            v && (c = !0, a[v.to] = !0, a[v.from] = !0)
          }
          return c
        }

        function zf(n, t, r, a, c) {
          const {
            zoom: p
          } = a, m = c.patternDependencies;
          for (const v of t) {
            const b = v.paint.get(`${n}-pattern`).value;
            if (b.kind !== "constant") {
              let C = b.evaluate({
                  zoom: p - 1
                }, r, {}, c.availableImages),
                I = b.evaluate({
                  zoom: p
                }, r, {}, c.availableImages),
                R = b.evaluate({
                  zoom: p + 1
                }, r, {}, c.availableImages);
              C = C && C.name ? C.name : C, I = I && I.name ? I.name : I, R = R && R.name ? R.name : R, m[C] = !0, m[I] = !0, m[R] = !0, r.patterns[v.id] = {
                min: C,
                mid: I,
                max: R
              }
            }
          }
          return r
        }

        function sg(n, t, r, a, c) {
          let p;
          if (c === (function(m, v, b, C) {
              let I = 0;
              for (let R = v, U = b - C; R < b; R += C) I += (m[U] - m[R]) * (m[R + 1] + m[U + 1]), U = R;
              return I
            })(n, t, r, a) > 0)
            for (let m = t; m < r; m += a) p = hg(m / a | 0, n[m], n[m + 1], p);
          else
            for (let m = r - a; m >= t; m -= a) p = hg(m / a | 0, n[m], n[m + 1], p);
          return p && lc(p, p.next) && (Ru(p), p = p.next), p
        }

        function sl(n, t) {
          if (!n) return n;
          t || (t = n);
          let r, a = n;
          do
            if (r = !1, a.steiner || !lc(a, a.next) && pi(a.prev, a, a.next) !== 0) a = a.next;
            else {
              if (Ru(a), a = t = a.prev, a === a.next) break;
              r = !0
            } while (r || a !== t);
          return t
        }

        function zu(n, t, r, a, c, p, m) {
          if (!n) return;
          !m && p && (function(b, C, I, R) {
            let U = b;
            do U.z === 0 && (U.z = Lf(U.x, U.y, C, I, R)), U.prevZ = U.prev, U.nextZ = U.next, U = U.next; while (U !== b);
            U.prevZ.nextZ = null, U.prevZ = null, (function(Z) {
              let X, Q = 1;
              do {
                let ie, ue = Z;
                Z = null;
                let Ne = null;
                for (X = 0; ue;) {
                  X++;
                  let ye = ue,
                    Ce = 0;
                  for (let dt = 0; dt < Q && (Ce++, ye = ye.nextZ, ye); dt++);
                  let tt = Q;
                  for (; Ce > 0 || tt > 0 && ye;) Ce !== 0 && (tt === 0 || !ye || ue.z <= ye.z) ? (ie = ue, ue = ue.nextZ, Ce--) : (ie = ye, ye = ye.nextZ, tt--), Ne ? Ne.nextZ = ie : Z = ie, ie.prevZ = Ne, Ne = ie;
                  ue = ye
                }
                Ne.nextZ = null, Q *= 2
              } while (X > 1)
            })(U)
          })(n, a, c, p);
          let v = n;
          for (; n.prev !== n.next;) {
            const b = n.prev,
              C = n.next;
            if (p ? p1(n, a, c, p) : d1(n)) t.push(b.i, n.i, C.i), Ru(n), n = C.next, v = C.next;
            else if ((n = C) === v) {
              m ? m === 1 ? zu(n = f1(sl(n), t), t, r, a, c, p, 2) : m === 2 && m1(n, t, r, a, c, p) : zu(sl(n), t, r, a, c, p, 1);
              break
            }
          }
        }

        function d1(n) {
          const t = n.prev,
            r = n,
            a = n.next;
          if (pi(t, r, a) >= 0) return !1;
          const c = t.x,
            p = r.x,
            m = a.x,
            v = t.y,
            b = r.y,
            C = a.y,
            I = Math.min(c, p, m),
            R = Math.min(v, b, C),
            U = Math.max(c, p, m),
            Z = Math.max(v, b, C);
          let X = a.next;
          for (; X !== t;) {
            if (X.x >= I && X.x <= U && X.y >= R && X.y <= Z && Lu(c, v, p, b, m, C, X.x, X.y) && pi(X.prev, X, X.next) >= 0) return !1;
            X = X.next
          }
          return !0
        }

        function p1(n, t, r, a) {
          const c = n.prev,
            p = n,
            m = n.next;
          if (pi(c, p, m) >= 0) return !1;
          const v = c.x,
            b = p.x,
            C = m.x,
            I = c.y,
            R = p.y,
            U = m.y,
            Z = Math.min(v, b, C),
            X = Math.min(I, R, U),
            Q = Math.max(v, b, C),
            ie = Math.max(I, R, U),
            ue = Lf(Z, X, t, r, a),
            Ne = Lf(Q, ie, t, r, a);
          let ye = n.prevZ,
            Ce = n.nextZ;
          for (; ye && ye.z >= ue && Ce && Ce.z <= Ne;) {
            if (ye.x >= Z && ye.x <= Q && ye.y >= X && ye.y <= ie && ye !== c && ye !== m && Lu(v, I, b, R, C, U, ye.x, ye.y) && pi(ye.prev, ye, ye.next) >= 0 || (ye = ye.prevZ, Ce.x >= Z && Ce.x <= Q && Ce.y >= X && Ce.y <= ie && Ce !== c && Ce !== m && Lu(v, I, b, R, C, U, Ce.x, Ce.y) && pi(Ce.prev, Ce, Ce.next) >= 0)) return !1;
            Ce = Ce.nextZ
          }
          for (; ye && ye.z >= ue;) {
            if (ye.x >= Z && ye.x <= Q && ye.y >= X && ye.y <= ie && ye !== c && ye !== m && Lu(v, I, b, R, C, U, ye.x, ye.y) && pi(ye.prev, ye, ye.next) >= 0) return !1;
            ye = ye.prevZ
          }
          for (; Ce && Ce.z <= Ne;) {
            if (Ce.x >= Z && Ce.x <= Q && Ce.y >= X && Ce.y <= ie && Ce !== c && Ce !== m && Lu(v, I, b, R, C, U, Ce.x, Ce.y) && pi(Ce.prev, Ce, Ce.next) >= 0) return !1;
            Ce = Ce.nextZ
          }
          return !0
        }

        function f1(n, t) {
          let r = n;
          do {
            const a = r.prev,
              c = r.next.next;
            !lc(a, c) && cg(a, r, r.next, c) && Du(a, c) && Du(c, a) && (t.push(a.i, r.i, c.i), Ru(r), Ru(r.next), r = n = c), r = r.next
          } while (r !== n);
          return sl(r)
        }

        function m1(n, t, r, a, c, p) {
          let m = n;
          do {
            let v = m.next.next;
            for (; v !== m.prev;) {
              if (m.i !== v.i && x1(m, v)) {
                let b = ug(m, v);
                return m = sl(m, m.next), b = sl(b, b.next), zu(m, t, r, a, c, p, 0), void zu(b, t, r, a, c, p, 0)
              }
              v = v.next
            }
            m = m.next
          } while (m !== n)
        }

        function _1(n, t) {
          let r = n.x - t.x;
          return r === 0 && (r = n.y - t.y, r === 0) && (r = (n.next.y - n.y) / (n.next.x - n.x) - (t.next.y - t.y) / (t.next.x - t.x)), r
        }

        function g1(n, t) {
          const r = (function(c, p) {
            let m = p;
            const v = c.x,
              b = c.y;
            let C, I = -1 / 0;
            if (lc(c, m)) return m;
            do {
              if (lc(c, m.next)) return m.next;
              if (b <= m.y && b >= m.next.y && m.next.y !== m.y) {
                const Q = m.x + (b - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
                if (Q <= v && Q > I && (I = Q, C = m.x < m.next.x ? m : m.next, Q === v)) return C
              }
              m = m.next
            } while (m !== p);
            if (!C) return null;
            const R = C,
              U = C.x,
              Z = C.y;
            let X = 1 / 0;
            m = C;
            do {
              if (v >= m.x && m.x >= U && v !== m.x && lg(b < Z ? v : I, b, U, Z, b < Z ? I : v, b, m.x, m.y)) {
                const Q = Math.abs(b - m.y) / (v - m.x);
                Du(m, c) && (Q < X || Q === X && (m.x > C.x || m.x === C.x && v1(C, m))) && (C = m, X = Q)
              }
              m = m.next
            } while (m !== R);
            return C
          })(n, t);
          if (!r) return t;
          const a = ug(r, n);
          return sl(a, a.next), sl(r, r.next)
        }

        function v1(n, t) {
          return pi(n.prev, n, t.prev) < 0 && pi(t.next, n, n.next) < 0
        }

        function Lf(n, t, r, a, c) {
          return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - r) * c | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - a) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function y1(n) {
          let t = n,
            r = n;
          do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== n);
          return r
        }

        function lg(n, t, r, a, c, p, m, v) {
          return (c - m) * (t - v) >= (n - m) * (p - v) && (n - m) * (a - v) >= (r - m) * (t - v) && (r - m) * (p - v) >= (c - m) * (a - v)
        }

        function Lu(n, t, r, a, c, p, m, v) {
          return !(n === m && t === v) && lg(n, t, r, a, c, p, m, v)
        }

        function x1(n, t) {
          return n.next.i !== t.i && n.prev.i !== t.i && !(function(r, a) {
            let c = r;
            do {
              if (c.i !== r.i && c.next.i !== r.i && c.i !== a.i && c.next.i !== a.i && cg(c, c.next, r, a)) return !0;
              c = c.next
            } while (c !== r);
            return !1
          })(n, t) && (Du(n, t) && Du(t, n) && (function(r, a) {
            let c = r,
              p = !1;
            const m = (r.x + a.x) / 2,
              v = (r.y + a.y) / 2;
            do c.y > v != c.next.y > v && c.next.y !== c.y && m < (c.next.x - c.x) * (v - c.y) / (c.next.y - c.y) + c.x && (p = !p), c = c.next; while (c !== r);
            return p
          })(n, t) && (pi(n.prev, n, t.prev) || pi(n, t.prev, t)) || lc(n, t) && pi(n.prev, n, n.next) > 0 && pi(t.prev, t, t.next) > 0)
        }

        function pi(n, t, r) {
          return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y)
        }

        function lc(n, t) {
          return n.x === t.x && n.y === t.y
        }

        function cg(n, t, r, a) {
          const c = rp(pi(n, t, r)),
            p = rp(pi(n, t, a)),
            m = rp(pi(r, a, n)),
            v = rp(pi(r, a, t));
          return c !== p && m !== v || !(c !== 0 || !tp(n, r, t)) || !(p !== 0 || !tp(n, a, t)) || !(m !== 0 || !tp(r, n, a)) || !(v !== 0 || !tp(r, t, a))
        }

        function tp(n, t, r) {
          return t.x <= Math.max(n.x, r.x) && t.x >= Math.min(n.x, r.x) && t.y <= Math.max(n.y, r.y) && t.y >= Math.min(n.y, r.y)
        }

        function rp(n) {
          return n > 0 ? 1 : n < 0 ? -1 : 0
        }

        function Du(n, t) {
          return pi(n.prev, n, n.next) < 0 ? pi(n, t, n.next) >= 0 && pi(n, n.prev, t) >= 0 : pi(n, t, n.prev) < 0 || pi(n, n.next, t) < 0
        }

        function ug(n, t) {
          const r = Df(n.i, n.x, n.y),
            a = Df(t.i, t.x, t.y),
            c = n.next,
            p = t.prev;
          return n.next = t, t.prev = n, r.next = c, c.prev = r, a.next = r, r.prev = a, p.next = a, a.prev = p, a
        }

        function hg(n, t, r, a) {
          const c = Df(n, t, r);
          return a ? (c.next = a.next, c.prev = a, a.next.prev = c, a.next = c) : (c.prev = c, c.next = c), c
        }

        function Ru(n) {
          n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
        }

        function Df(n, t, r) {
          return {
            i: n,
            x: t,
            y: r,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class cc {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class np {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        np.noSubdivision = new np({
          fill: new cc(0, 0),
          line: new cc(0, 0),
          tile: new cc(0, 0),
          stencil: new cc(0, 0),
          circle: 1
        }), sr("SubdivisionGranularityExpression", cc), sr("SubdivisionGranularitySetting", np);
        const uc = -32768,
          Fu = 32767;
        class b1 {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = Ve / t, this._canonical = r
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const a = 0 | Math.round(t),
              c = 0 | Math.round(r),
              p = this._getKey(a, c);
            if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p);
            const m = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(p, m), this._vertexBuffer.push(a, c), m
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(c, p) {
              const m = [];
              for (let v = 0; v < p.length; v += 3) {
                const b = p[v],
                  C = p[v + 1],
                  I = p[v + 2],
                  R = c[2 * b],
                  U = c[2 * b + 1];
                (c[2 * C] - R) * (c[2 * I + 1] - U) - (c[2 * C + 1] - U) * (c[2 * I] - R) > 0 ? (m.push(b), m.push(I), m.push(C)) : (m.push(b), m.push(C), m.push(I))
              }
              return m
            })(this._vertexBuffer, t);
            const r = [],
              a = t.length;
            for (let c = 0; c < a; c += 3) {
              const p = [t[c + 0], t[c + 1], t[c + 2]],
                m = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
              let v = 1 / 0,
                b = 1 / 0,
                C = -1 / 0,
                I = -1 / 0;
              for (let Q = 0; Q < 3; Q++) {
                const ie = m[2 * Q],
                  ue = m[2 * Q + 1];
                v = Math.min(v, ie), C = Math.max(C, ie), b = Math.min(b, ue), I = Math.max(I, ue)
              }
              if (v === C || b === I) continue;
              const R = Math.floor(v / this._granularityCellSize),
                U = Math.ceil(C / this._granularityCellSize),
                Z = Math.floor(b / this._granularityCellSize),
                X = Math.ceil(I / this._granularityCellSize);
              if (R !== U || Z !== X)
                for (let Q = Z; Q < X; Q++) {
                  const ie = this._scanlineGenerateVertexRingForCellRow(Q, m, p);
                  w1(this._vertexBuffer, ie, r)
                } else r.push(...p)
            }
            return r
          }
          _scanlineGenerateVertexRingForCellRow(t, r, a) {
            const c = t * this._granularityCellSize,
              p = c + this._granularityCellSize,
              m = [];
            for (let v = 0; v < 3; v++) {
              const b = r[2 * v],
                C = r[2 * v + 1],
                I = r[2 * (v + 1) % 6],
                R = r[(2 * (v + 1) + 1) % 6],
                U = r[2 * (v + 2) % 6],
                Z = r[(2 * (v + 2) + 1) % 6],
                X = I - b,
                Q = R - C,
                ie = X === 0,
                ue = Q === 0,
                Ne = (c - C) / Q,
                ye = (p - C) / Q,
                Ce = Math.min(Ne, ye),
                tt = Math.max(Ne, ye);
              if (!ue && (Ce >= 1 || tt <= 0) || ue && (C < c || C > p)) {
                R >= c && R <= p && m.push(a[(v + 1) % 3]);
                continue
              }!ue && Ce > 0 && m.push(this._vertexToIndex(b + X * Ce, C + Q * Ce));
              const dt = b + X * Math.max(Ce, 0),
                Rt = b + X * Math.min(tt, 1);
              ie || this._generateIntraEdgeVertices(m, b, C, I, R, dt, Rt), !ue && tt < 1 && m.push(this._vertexToIndex(b + X * tt, C + Q * tt)), (ue || R >= c && R <= p) && m.push(a[(v + 1) % 3]), !ue && (R <= c || R >= p) && this._generateInterEdgeVertices(m, b, C, I, R, U, Z, Rt, c, p)
            }
            return m
          }
          _generateIntraEdgeVertices(t, r, a, c, p, m, v) {
            const b = c - r,
              C = p - a,
              I = C === 0,
              R = I ? Math.min(r, c) : Math.min(m, v),
              U = I ? Math.max(r, c) : Math.max(m, v),
              Z = Math.floor(R / this._granularityCellSize) + 1,
              X = Math.ceil(U / this._granularityCellSize) - 1;
            if (I ? r < c : m < v)
              for (let Q = Z; Q <= X; Q++) {
                const ie = Q * this._granularityCellSize;
                t.push(this._vertexToIndex(ie, a + C * (ie - r) / b))
              } else
                for (let Q = X; Q >= Z; Q--) {
                  const ie = Q * this._granularityCellSize;
                  t.push(this._vertexToIndex(ie, a + C * (ie - r) / b))
                }
          }
          _generateInterEdgeVertices(t, r, a, c, p, m, v, b, C, I) {
            const R = p - a,
              U = m - c,
              Z = v - p,
              X = (C - p) / Z,
              Q = (I - p) / Z,
              ie = Math.min(X, Q),
              ue = Math.max(X, Q),
              Ne = c + U * ie;
            let ye = Math.floor(Math.min(Ne, b) / this._granularityCellSize) + 1,
              Ce = Math.ceil(Math.max(Ne, b) / this._granularityCellSize) - 1,
              tt = b < Ne;
            const dt = Z === 0;
            if (dt && (v === C || v === I)) return;
            if (dt || ie >= 1 || ue <= 0) {
              const ir = a - v,
                Wt = m + (r - m) * Math.min((C - v) / ir, (I - v) / ir);
              ye = Math.floor(Math.min(Wt, b) / this._granularityCellSize) + 1, Ce = Math.ceil(Math.max(Wt, b) / this._granularityCellSize) - 1, tt = b < Wt
            }
            const Rt = R > 0 ? I : C;
            if (tt)
              for (let ir = ye; ir <= Ce; ir++) t.push(this._vertexToIndex(ir * this._granularityCellSize, Rt));
            else
              for (let ir = Ce; ir >= ye; ir--) t.push(this._vertexToIndex(ir * this._granularityCellSize, Rt))
          }
          _generateOutline(t) {
            const r = [];
            for (const a of t) {
              const c = ll(a, this._granularity, !0),
                p = this._pointArrayToIndices(c),
                m = [];
              for (let v = 1; v < p.length; v++) m.push(p[v - 1]), m.push(p[v]);
              r.push(m)
            }
            return r
          }
          _handlePoles(t) {
            let r = !1,
              a = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)), (r || a) && this._fillPoles(t, r, a)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const a = t[r + 1];
              a === uc && (t[r + 1] = -32767), a === Fu && (t[r + 1] = 32766)
            }
          }
          _generatePoleQuad(t, r, a, c, p, m) {
            c > p != (m === uc) ? (t.push(r), t.push(a), t.push(this._vertexToIndex(c, m)), t.push(a), t.push(this._vertexToIndex(p, m)), t.push(this._vertexToIndex(c, m))) : (t.push(a), t.push(r), t.push(this._vertexToIndex(c, m)), t.push(this._vertexToIndex(p, m)), t.push(a), t.push(this._vertexToIndex(c, m)))
          }
          _fillPoles(t, r, a) {
            const c = this._vertexBuffer,
              p = Ve,
              m = t.length;
            for (let v = 2; v < m; v += 3) {
              const b = t[v - 2],
                C = t[v - 1],
                I = t[v],
                R = c[2 * b],
                U = c[2 * b + 1],
                Z = c[2 * C],
                X = c[2 * C + 1],
                Q = c[2 * I],
                ie = c[2 * I + 1];
              r && (U === 0 && X === 0 && this._generatePoleQuad(t, b, C, R, Z, uc), X === 0 && ie === 0 && this._generatePoleQuad(t, C, I, Z, Q, uc), ie === 0 && U === 0 && this._generatePoleQuad(t, I, b, Q, R, uc)), a && (U === p && X === p && this._generatePoleQuad(t, b, C, R, Z, Fu), X === p && ie === p && this._generatePoleQuad(t, C, I, Z, Q, Fu), ie === p && U === p && this._generatePoleQuad(t, I, b, Q, R, Fu))
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1])
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: a,
              holeIndices: c
            } = (function(v) {
              const b = [],
                C = [];
              for (const I of v)
                if (I.length !== 0) {
                  I !== v[0] && b.push(C.length / 2);
                  for (let R = 0; R < I.length; R++) C.push(I[R].x), C.push(I[R].y)
                } return {
                flattened: C,
                holeIndices: b
              }
            })(t);
            let p;
            this._initializeVertices(a);
            try {
              const v = (function(C, I, R = 2) {
                  const U = I && I.length,
                    Z = U ? I[0] * R : C.length;
                  let X = sg(C, 0, Z, R, !0);
                  const Q = [];
                  if (!X || X.next === X.prev) return Q;
                  let ie, ue, Ne;
                  if (U && (X = (function(ye, Ce, tt, dt) {
                      const Rt = [];
                      for (let ir = 0, Wt = Ce.length; ir < Wt; ir++) {
                        const er = sg(ye, Ce[ir] * dt, ir < Wt - 1 ? Ce[ir + 1] * dt : ye.length, dt, !1);
                        er === er.next && (er.steiner = !0), Rt.push(y1(er))
                      }
                      Rt.sort(_1);
                      for (let ir = 0; ir < Rt.length; ir++) tt = g1(Rt[ir], tt);
                      return tt
                    })(C, I, X, R)), C.length > 80 * R) {
                    ie = C[0], ue = C[1];
                    let ye = ie,
                      Ce = ue;
                    for (let tt = R; tt < Z; tt += R) {
                      const dt = C[tt],
                        Rt = C[tt + 1];
                      dt < ie && (ie = dt), Rt < ue && (ue = Rt), dt > ye && (ye = dt), Rt > Ce && (Ce = Rt)
                    }
                    Ne = Math.max(ye - ie, Ce - ue), Ne = Ne !== 0 ? 32767 / Ne : 0
                  }
                  return zu(X, Q, R, ie, ue, Ne, 0), Q
                })(a, c),
                b = this._convertIndices(a, v);
              p = this._subdivideTrianglesScanline(b)
            } catch (v) {
              console.error(v)
            }
            let m = [];
            return r && (m = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(p), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: p,
              indicesLineList: m
            }
          }
          _convertIndices(t, r) {
            const a = [];
            for (let c = 0; c < r.length; c++) a.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
            return a
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let a = 0; a < t.length; a++) {
              const c = t[a];
              r.push(this._vertexToIndex(c.x, c.y))
            }
            return r
          }
        }

        function dg(n, t, r, a = !0) {
          return new b1(r, t).subdividePolygonInternal(n, a)
        }

        function ll(n, t, r = !1) {
          if (!n || n.length < 1) return [];
          if (n.length < 2) return [];
          const a = n[0],
            c = n[n.length - 1],
            p = r && (a.x !== c.x || a.y !== c.y);
          if (t < 2) return p ? [...n, n[0]] : [...n];
          const m = Math.floor(Ve / t),
            v = [];
          v.push(new B(n[0].x, n[0].y));
          const b = n.length,
            C = p ? b : b - 1;
          for (let I = 0; I < C; I++) {
            const R = n[I],
              U = I < b - 1 ? n[I + 1] : n[0],
              Z = R.x,
              X = R.y,
              Q = U.x,
              ie = U.y,
              ue = Z !== Q,
              Ne = X !== ie;
            if (!ue && !Ne) continue;
            const ye = Q - Z,
              Ce = ie - X,
              tt = Math.abs(ye),
              dt = Math.abs(Ce);
            let Rt = Z,
              ir = X;
            for (;;) {
              const er = ye > 0 ? (Math.floor(Rt / m) + 1) * m : (Math.ceil(Rt / m) - 1) * m,
                Fr = Ce > 0 ? (Math.floor(ir / m) + 1) * m : (Math.ceil(ir / m) - 1) * m,
                Qt = Math.abs(Rt - er),
                tr = Math.abs(ir - Fr),
                St = Math.abs(Rt - Q),
                $r = Math.abs(ir - ie),
                Kr = ue ? Qt / tt : Number.POSITIVE_INFINITY,
                jr = Ne ? tr / dt : Number.POSITIVE_INFINITY;
              if ((St <= Qt || !ue) && ($r <= tr || !Ne)) break;
              if (Kr < jr && ue || !Ne) {
                Rt = er, ir += Ce * Kr;
                const Sr = new B(Rt, Math.round(ir));
                v[v.length - 1].x === Sr.x && v[v.length - 1].y === Sr.y || v.push(Sr)
              } else {
                Rt += ye * jr, ir = Fr;
                const Sr = new B(Math.round(Rt), ir);
                v[v.length - 1].x === Sr.x && v[v.length - 1].y === Sr.y || v.push(Sr)
              }
            }
            const Wt = new B(Q, ie);
            v[v.length - 1].x === Wt.x && v[v.length - 1].y === Wt.y || v.push(Wt)
          }
          return v
        }

        function w1(n, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let a = 0,
            c = n[2 * t[0]];
          for (let b = 1; b < t.length; b++) {
            const C = n[2 * t[b]];
            C < c && (c = C, a = b)
          }
          const p = t.length;
          let m = a,
            v = (m + 1) % p;
          for (;;) {
            const b = m - 1 >= 0 ? m - 1 : p - 1,
              C = (v + 1) % p,
              I = n[2 * t[b]],
              R = n[2 * t[C]],
              U = n[2 * t[m]],
              Z = n[2 * t[m] + 1],
              X = n[2 * t[v] + 1];
            let Q = !1;
            if (I < R) Q = !0;
            else if (I > R) Q = !1;
            else {
              const ie = X - Z,
                ue = -(n[2 * t[v]] - U),
                Ne = Z < X ? 1 : -1;
              ((I - U) * ie + (n[2 * t[b] + 1] - Z) * ue) * Ne > ((R - U) * ie + (n[2 * t[C] + 1] - Z) * ue) * Ne && (Q = !0)
            }
            if (Q) {
              const ie = t[b],
                ue = t[m],
                Ne = t[v];
              ie !== ue && ie !== Ne && ue !== Ne && r.push(Ne, ue, ie), m--, m < 0 && (m = p - 1)
            } else {
              const ie = t[C],
                ue = t[m],
                Ne = t[v];
              ie !== ue && ie !== Ne && ue !== Ne && r.push(Ne, ue, ie), v++, v >= p && (v = 0)
            }
            if (b === C) break
          }
        }

        function pg(n, t, r, a, c, p, m, v, b) {
          const C = c.length / 2,
            I = m && v && b;
          if (C < on.MAX_VERTEX_ARRAY_LENGTH) {
            const R = t.prepareSegment(C, r, a),
              U = R.vertexLength;
            for (let Q = 0; Q < p.length; Q += 3) a.emplaceBack(U + p[Q], U + p[Q + 1], U + p[Q + 2]);
            let Z, X;
            R.vertexLength += C, R.primitiveLength += p.length / 3, I && (X = m.prepareSegment(C, r, v), Z = X.vertexLength, X.vertexLength += C);
            for (let Q = 0; Q < c.length; Q += 2) n(c[Q], c[Q + 1]);
            if (I)
              for (let Q = 0; Q < b.length; Q++) {
                const ie = b[Q];
                for (let ue = 1; ue < ie.length; ue += 2) v.emplaceBack(Z + ie[ue - 1], Z + ie[ue]);
                X.primitiveLength += ie.length / 2
              }
          } else(function(R, U, Z, X, Q, ie) {
            const ue = [];
            for (let dt = 0; dt < X.length / 2; dt++) ue.push(-1);
            const Ne = {
              count: 0
            };
            let ye = 0,
              Ce = R.getOrCreateLatestSegment(U, Z),
              tt = Ce.vertexLength;
            for (let dt = 2; dt < Q.length; dt += 3) {
              const Rt = Q[dt - 2],
                ir = Q[dt - 1],
                Wt = Q[dt];
              let er = ue[Rt] < ye,
                Fr = ue[ir] < ye,
                Qt = ue[Wt] < ye;
              Ce.vertexLength + ((er ? 1 : 0) + (Fr ? 1 : 0) + (Qt ? 1 : 0)) > on.MAX_VERTEX_ARRAY_LENGTH && (Ce = R.createNewSegment(U, Z), ye = Ne.count, er = !0, Fr = !0, Qt = !0, tt = 0);
              const tr = Bu(ue, X, ie, Ne, Rt, er, Ce),
                St = Bu(ue, X, ie, Ne, ir, Fr, Ce),
                $r = Bu(ue, X, ie, Ne, Wt, Qt, Ce);
              Z.emplaceBack(tt + tr - ye, tt + St - ye, tt + $r - ye), Ce.primitiveLength++
            }
          })(t, r, a, c, p, n), I && (function(R, U, Z, X, Q, ie) {
            const ue = [];
            for (let dt = 0; dt < X.length / 2; dt++) ue.push(-1);
            const Ne = {
              count: 0
            };
            let ye = 0,
              Ce = R.getOrCreateLatestSegment(U, Z),
              tt = Ce.vertexLength;
            for (let dt = 0; dt < Q.length; dt++) {
              const Rt = Q[dt];
              for (let ir = 1; ir < Q[dt].length; ir += 2) {
                const Wt = Rt[ir - 1],
                  er = Rt[ir];
                let Fr = ue[Wt] < ye,
                  Qt = ue[er] < ye;
                Ce.vertexLength + ((Fr ? 1 : 0) + (Qt ? 1 : 0)) > on.MAX_VERTEX_ARRAY_LENGTH && (Ce = R.createNewSegment(U, Z), ye = Ne.count, Fr = !0, Qt = !0, tt = 0);
                const tr = Bu(ue, X, ie, Ne, Wt, Fr, Ce),
                  St = Bu(ue, X, ie, Ne, er, Qt, Ce);
                Z.emplaceBack(tt + tr - ye, tt + St - ye), Ce.primitiveLength++
              }
            }
          })(m, r, v, c, b, n), t.forceNewSegmentOnNextPrepare(), m == null || m.forceNewSegmentOnNextPrepare()
        }

        function Bu(n, t, r, a, c, p, m) {
          if (p) {
            const v = a.count;
            return r(t[2 * c], t[2 * c + 1]), n[c] = a.count, a.count++, m.vertexLength++, v
          }
          return n[c]
        }
        class Rf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new pe, this.indexArray = new Pt, this.indexArray2 = new gr, this.programConfigurations = new Ko(t.layers, t.zoom), this.segments = new on, this.segments2 = new on, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.hasDependencies = ep("fill", this.layers, r);
            const c = this.layers[0].layout.get("fill-sort-key"),
              p = !c.isConstant(),
              m = [];
            for (const {
                feature: v,
                id: b,
                index: C,
                sourceLayerIndex: I
              }
              of t) {
              const R = this.layers[0]._featureFilter.needGeometry,
                U = So(v, R);
              if (!this.layers[0]._featureFilter.filter(new Bn(this.zoom), U, a)) continue;
              const Z = p ? c.evaluate(U, {}, a, r.availableImages) : void 0,
                X = {
                  id: b,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: I,
                  index: C,
                  geometry: R ? U.geometry : so(v),
                  patterns: {},
                  sortKey: Z
                };
              m.push(X)
            }
            p && m.sort(((v, b) => v.sortKey - b.sortKey));
            for (const v of m) {
              const {
                geometry: b,
                index: C,
                sourceLayerIndex: I
              } = v;
              if (this.hasDependencies) {
                const R = zf("fill", this.layers, v, {
                  zoom: this.zoom
                }, r);
                this.patternFeatures.push(R)
              } else this.addFeature(v, b, C, a, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[C].feature, b, C, I, this.index)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: a
            })
          }
          addFeatures(t, r, a) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, a, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, h1), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, r, a, c, p, m) {
            for (const v of kl(r, 500)) {
              const b = dg(v, c, m.fill.getGranularityForZoomLevel(c.z)),
                C = this.layoutVertexArray;
              pg(((I, R) => {
                C.emplaceBack(I, R)
              }), this.segments, this.layoutVertexArray, this.indexArray, b.verticesFlattened, b.indicesTriangles, this.segments2, this.indexArray2, b.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {
              imagePositions: p,
              canonical: c
            })
          }
        }
        let fg, mg;
        sr("FillBucket", Rf, {
          omit: ["layers", "patternFeatures"]
        });
        var T1 = {
          get paint() {
            return mg = mg || new Zi({
              "fill-antialias": new Ar(_e.paint_fill["fill-antialias"]),
              "fill-opacity": new Ur(_e.paint_fill["fill-opacity"]),
              "fill-color": new Ur(_e.paint_fill["fill-color"]),
              "fill-outline-color": new Ur(_e.paint_fill["fill-outline-color"]),
              "fill-translate": new Ar(_e.paint_fill["fill-translate"]),
              "fill-translate-anchor": new Ar(_e.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new nl(_e.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return fg = fg || new Zi({
              "fill-sort-key": new Ur(_e.layout_fill["fill-sort-key"])
            })
          }
        };
        class S1 extends Ia {
          constructor(t, r) {
            super(t, T1, r)
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const a = this.paint._values["fill-outline-color"];
            a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new Rf(t)
          }
          queryRadius() {
            return Jd(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: r,
            transform: a,
            pixelsToTileUnits: c
          }) {
            return H_(Qd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, c), r)
          }
          isTileClipped() {
            return !0
          }
        }
        const C1 = si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          P1 = si([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: I1
          } = C1;
        class hc {
          constructor(t, r, a, c, p) {
            this.properties = {}, this.extent = a, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = c, this._values = p, t.readFields(M1, this, r)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos,
              a = [];
            let c, p = 1,
              m = 0,
              v = 0,
              b = 0;
            for (; t.pos < r;) {
              if (m <= 0) {
                const C = t.readVarint();
                p = 7 & C, m = C >> 3
              }
              if (m--, p === 1 || p === 2) v += t.readSVarint(), b += t.readSVarint(), p === 1 && (c && a.push(c), c = []), c && c.push(new B(v, b));
              else {
                if (p !== 7) throw new Error(`unknown command ${p}`);
                c && c.push(c[0].clone())
              }
            }
            return c && a.push(c), a
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let a = 1,
              c = 0,
              p = 0,
              m = 0,
              v = 1 / 0,
              b = -1 / 0,
              C = 1 / 0,
              I = -1 / 0;
            for (; t.pos < r;) {
              if (c <= 0) {
                const R = t.readVarint();
                a = 7 & R, c = R >> 3
              }
              if (c--, a === 1 || a === 2) p += t.readSVarint(), m += t.readSVarint(), p < v && (v = p), p > b && (b = p), m < C && (C = m), m > I && (I = m);
              else if (a !== 7) throw new Error(`unknown command ${a}`)
            }
            return [v, C, b, I]
          }
          toGeoJSON(t, r, a) {
            const c = this.extent * Math.pow(2, a),
              p = this.extent * t,
              m = this.extent * r,
              v = this.loadGeometry();

            function b(U) {
              return [360 * (U.x + p) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (U.y + m) / c) * Math.PI)) - 90]
            }

            function C(U) {
              return U.map(b)
            }
            let I;
            if (this.type === 1) {
              const U = [];
              for (const X of v) U.push(X[0]);
              const Z = C(U);
              I = U.length === 1 ? {
                type: "Point",
                coordinates: Z[0]
              } : {
                type: "MultiPoint",
                coordinates: Z
              }
            } else if (this.type === 2) {
              const U = v.map(C);
              I = U.length === 1 ? {
                type: "LineString",
                coordinates: U[0]
              } : {
                type: "MultiLineString",
                coordinates: U
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const U = (function(X) {
                    const Q = X.length;
                    if (Q <= 1) return [X];
                    const ie = [];
                    let ue, Ne;
                    for (let ye = 0; ye < Q; ye++) {
                      const Ce = A1(X[ye]);
                      Ce !== 0 && (Ne === void 0 && (Ne = Ce < 0), Ne === Ce < 0 ? (ue && ie.push(ue), ue = [X[ye]]) : ue && ue.push(X[ye]))
                    }
                    return ue && ie.push(ue), ie
                  })(v),
                  Z = [];
                for (const X of U) Z.push(X.map(C));
                I = Z.length === 1 ? {
                  type: "Polygon",
                  coordinates: Z[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: Z
                }
              }
            }
            const R = {
              type: "Feature",
              geometry: I,
              properties: this.properties
            };
            return this.id != null && (R.id = this.id), R
          }
        }

        function M1(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? (function(a, c) {
            const p = a.readVarint() + a.pos;
            for (; a.pos < p;) {
              const m = c._keys[a.readVarint()],
                v = c._values[a.readVarint()];
              c.properties[m] = v
            }
          })(r, t) : n === 3 ? t.type = r.readVarint() : n === 4 && (t._geometry = r.pos)
        }

        function A1(n) {
          let t = 0;
          for (let r, a, c = 0, p = n.length, m = p - 1; c < p; m = c++) r = n[c], a = n[m], t += (a.x - r.x) * (r.y + a.y);
          return t
        }
        hc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class _g {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(k1, this, r), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new hc(this._pbf, r, this.extent, this._keys, this._values)
          }
        }

        function k1(n, t, r) {
          n === 15 ? t.version = r.readVarint() : n === 1 ? t.name = r.readString() : n === 5 ? t.extent = r.readVarint() : n === 2 ? t._features.push(r.pos) : n === 3 ? t._keys.push(r.readString()) : n === 4 && t._values.push((function(a) {
            let c = null;
            const p = a.readVarint() + a.pos;
            for (; a.pos < p;) {
              const m = a.readVarint() >> 3;
              c = m === 1 ? a.readString() : m === 2 ? a.readFloat() : m === 3 ? a.readDouble() : m === 4 ? a.readVarint64() : m === 5 ? a.readVarint() : m === 6 ? a.readSVarint() : m === 7 ? a.readBoolean() : null
            }
            if (c == null) throw new Error("unknown feature value");
            return c
          })(r))
        }
        class gg {
          constructor(t, r) {
            this.layers = t.readFields(E1, {}, r)
          }
        }

        function E1(n, t, r) {
          if (n === 3) {
            const a = new _g(r, r.readVarint() + r.pos);
            a.length && (t[a.name] = a)
          }
        }
        const Ff = Math.pow(2, 13);

        function Ou(n, t, r, a, c, p, m, v) {
          n.emplaceBack(t, r, 2 * Math.floor(a * Ff) + m, c * Ff * 2, p * Ff * 2, Math.round(v))
        }
        class Bf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new be, this.centroidVertexArray = new fe, this.indexArray = new Pt, this.programConfigurations = new Ko(t.layers, t.zoom), this.segments = new on, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.features = [], this.hasDependencies = ep("fill-extrusion", this.layers, r);
            for (const {
                feature: c,
                id: p,
                index: m,
                sourceLayerIndex: v
              }
              of t) {
              const b = this.layers[0]._featureFilter.needGeometry,
                C = So(c, b);
              if (!this.layers[0]._featureFilter.filter(new Bn(this.zoom), C, a)) continue;
              const I = {
                id: p,
                sourceLayerIndex: v,
                index: m,
                geometry: b ? C.geometry : so(c),
                properties: c.properties,
                type: c.type,
                patterns: {}
              };
              this.hasDependencies ? this.features.push(zf("fill-extrusion", this.layers, I, {
                zoom: this.zoom
              }, r)) : this.addFeature(I, I.geometry, m, a, {}, r.subdivisionGranularity), r.featureIndex.insert(c, I.geometry, m, v, this.index, !0)
            }
          }
          addFeatures(t, r, a) {
            for (const c of this.features) {
              const {
                geometry: p
              } = c;
              this.addFeature(c, p, c.index, r, a, t.subdivisionGranularity)
            }
          }
          update(t, r, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: a
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, I1), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, P1.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, r, a, c, p, m) {
            for (const v of kl(r, 500)) {
              const b = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                C = this.layoutVertexArray.length;
              this.processPolygon(b, c, t, v, m);
              const I = this.layoutVertexArray.length - C,
                R = Math.floor(b.x / b.sampleCount),
                U = Math.floor(b.y / b.sampleCount);
              for (let Z = 0; Z < I; Z++) this.centroidVertexArray.emplaceBack(R, U)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {
              imagePositions: p,
              canonical: c
            })
          }
          processPolygon(t, r, a, c, p) {
            if (c.length < 1 || vg(c[0])) return;
            for (const R of c) R.length !== 0 && z1(t, R);
            const m = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              v = p.fill.getGranularityForZoomLevel(r.z),
              b = hc.types[a.type] === "Polygon";
            for (const R of c) {
              if (R.length === 0 || vg(R)) continue;
              const U = ll(R, v, b);
              this._generateSideFaces(U, m)
            }
            if (!b) return;
            const C = dg(c, r, v, !1),
              I = this.layoutVertexArray;
            pg(((R, U) => {
              Ou(I, R, U, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, C.verticesFlattened, C.indicesTriangles)
          }
          _generateSideFaces(t, r) {
            let a = 0;
            for (let c = 1; c < t.length; c++) {
              const p = t[c],
                m = t[c - 1];
              if (L1(p, m)) continue;
              r.segment.vertexLength + 4 > on.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const v = p.sub(m)._perp()._unit(),
                b = m.dist(p);
              a + b > 32768 && (a = 0), Ou(this.layoutVertexArray, p.x, p.y, v.x, v.y, 0, 0, a), Ou(this.layoutVertexArray, p.x, p.y, v.x, v.y, 0, 1, a), a += b, Ou(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 0, a), Ou(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 1, a);
              const C = r.segment.vertexLength;
              this.indexArray.emplaceBack(C, C + 2, C + 1), this.indexArray.emplaceBack(C + 1, C + 2, C + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2
            }
          }
        }

        function z1(n, t) {
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            r === t.length - 1 && t[0].x === a.x && t[0].y === a.y || (n.x += a.x, n.y += a.y, n.sampleCount++)
          }
        }

        function L1(n, t) {
          return n.x === t.x && (n.x < 0 || n.x > Ve) || n.y === t.y && (n.y < 0 || n.y > Ve)
        }

        function vg(n) {
          return n.every((t => t.x < 0)) || n.every((t => t.x > Ve)) || n.every((t => t.y < 0)) || n.every((t => t.y > Ve))
        }
        let yg;
        sr("FillExtrusionBucket", Bf, {
          omit: ["layers", "features"]
        });
        var D1 = {
          get paint() {
            return yg = yg || new Zi({
              "fill-extrusion-opacity": new Ar(_e["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new Ur(_e["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new Ar(_e["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new Ar(_e["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new nl(_e["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new Ur(_e["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new Ur(_e["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new Ar(_e["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class R1 extends Ia {
          constructor(t, r) {
            super(t, D1, r)
          }
          createBucket(t) {
            return new Bf(t)
          }
          queryRadius() {
            return Jd(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: m,
            pixelPosMatrix: v
          }) {
            const b = Qd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, m),
              C = this.paint.get("fill-extrusion-height").evaluate(r, a),
              I = this.paint.get("fill-extrusion-base").evaluate(r, a),
              R = (function(Z, X) {
                const Q = [];
                for (const ie of Z) {
                  const ue = [ie.x, ie.y, 0, 1];
                  Je(ue, ue, X), Q.push(new B(ue[0] / ue[3], ue[1] / ue[3]))
                }
                return Q
              })(b, v),
              U = (function(Z, X, Q, ie) {
                const ue = [],
                  Ne = [],
                  ye = ie[8] * X,
                  Ce = ie[9] * X,
                  tt = ie[10] * X,
                  dt = ie[11] * X,
                  Rt = ie[8] * Q,
                  ir = ie[9] * Q,
                  Wt = ie[10] * Q,
                  er = ie[11] * Q;
                for (const Fr of Z) {
                  const Qt = [],
                    tr = [];
                  for (const St of Fr) {
                    const $r = St.x,
                      Kr = St.y,
                      jr = ie[0] * $r + ie[4] * Kr + ie[12],
                      Sr = ie[1] * $r + ie[5] * Kr + ie[13],
                      wn = ie[2] * $r + ie[6] * Kr + ie[14],
                      ni = ie[3] * $r + ie[7] * Kr + ie[15],
                      bi = wn + tt,
                      $i = ni + dt,
                      ka = jr + Rt,
                      ha = Sr + ir,
                      Fi = wn + Wt,
                      ei = ni + er,
                      Ei = new B((jr + ye) / $i, (Sr + Ce) / $i);
                    Ei.z = bi / $i, Qt.push(Ei);
                    const Bi = new B(ka / ei, ha / ei);
                    Bi.z = Fi / ei, tr.push(Bi)
                  }
                  ue.push(Qt), Ne.push(tr)
                }
                return [ue, Ne]
              })(c, I, C, v);
            return (function(Z, X, Q) {
              let ie = 1 / 0;
              H_(Q, X) && (ie = xg(Q, X[0]));
              for (let ue = 0; ue < X.length; ue++) {
                const Ne = X[ue],
                  ye = Z[ue];
                for (let Ce = 0; Ce < Ne.length - 1; Ce++) {
                  const tt = Ne[Ce],
                    dt = [tt, Ne[Ce + 1], ye[Ce + 1], ye[Ce], tt];
                  $_(Q, dt) && (ie = Math.min(ie, xg(Q, dt)))
                }
              }
              return ie !== 1 / 0 && ie
            })(U[0], U[1], R)
          }
        }

        function Nu(n, t) {
          return n.x * t.x + n.y * t.y
        }

        function xg(n, t) {
          if (n.length === 1) {
            let r = 0;
            const a = t[r++];
            let c;
            for (; !c || a.equals(c);)
              if (c = t[r++], !c) return 1 / 0;
            for (; r < t.length; r++) {
              const p = t[r],
                m = n[0],
                v = c.sub(a),
                b = p.sub(a),
                C = m.sub(a),
                I = Nu(v, v),
                R = Nu(v, b),
                U = Nu(b, b),
                Z = Nu(C, v),
                X = Nu(C, b),
                Q = I * U - R * R,
                ie = (U * Z - R * X) / Q,
                ue = (I * X - R * Z) / Q,
                Ne = a.z * (1 - ie - ue) + c.z * ie + p.z * ue;
              if (isFinite(Ne)) return Ne
            }
            return 1 / 0
          } {
            let r = 1 / 0;
            for (const a of t) r = Math.min(r, a.z);
            return r
          }
        }
        const F1 = si([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: B1
          } = F1,
          O1 = si([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: N1
          } = O1,
          j1 = Math.cos(Math.PI / 180 * 37.5),
          bg = Math.pow(2, 14) / .5;
        class Of {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r => {
              this.gradients[r.id] = {}
            })), this.layoutVertexArray = new Pe, this.layoutVertexArray2 = new ge, this.indexArray = new Pt, this.programConfigurations = new Ko(t.layers, t.zoom), this.segments = new on, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, a) {
            this.hasDependencies = ep("line", this.layers, r) || this.hasLineDasharray(this.layers);
            const c = this.layers[0].layout.get("line-sort-key"),
              p = !c.isConstant(),
              m = [];
            for (const {
                feature: v,
                id: b,
                index: C,
                sourceLayerIndex: I
              }
              of t) {
              const R = this.layers[0]._featureFilter.needGeometry,
                U = So(v, R);
              if (!this.layers[0]._featureFilter.filter(new Bn(this.zoom), U, a)) continue;
              const Z = p ? c.evaluate(U, {}, a) : void 0,
                X = {
                  id: b,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: I,
                  index: C,
                  geometry: R ? U.geometry : so(v),
                  patterns: {},
                  dashes: {},
                  sortKey: Z
                };
              m.push(X)
            }
            p && m.sort(((v, b) => v.sortKey - b.sortKey));
            for (const v of m) {
              const {
                geometry: b,
                index: C,
                sourceLayerIndex: I
              } = v;
              this.hasDependencies ? (ep("line", this.layers, r) ? zf("line", this.layers, v, {
                zoom: this.zoom
              }, r) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, v, this.zoom, r), this.patternFeatures.push(v)) : this.addFeature(v, b, C, a, {}, {}, r.subdivisionGranularity), r.featureIndex.insert(t[C].feature, b, C, I, this.index)
            }
          }
          update(t, r, a, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: a,
              dashPositions: c
            })
          }
          addFeatures(t, r, a, c) {
            for (const p of this.patternFeatures) this.addFeature(p, p.geometry, p.index, r, a, c, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, N1)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, B1), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, r, a, c, p, m, v) {
            const b = this.layers[0].layout,
              C = b.get("line-join").evaluate(t, {}),
              I = b.get("line-cap"),
              R = b.get("line-miter-limit"),
              U = b.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const Z of r) this.addLine(Z, t, C, I, R, U, c, v);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {
              imagePositions: p,
              dashPositions: m,
              canonical: c
            })
          }
          addLine(t, r, a, c, p, m, v, b) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ll(t, v ? b.line.getGranularityForZoomLevel(v.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ye = 0; ye < t.length - 1; ye++) this.totalDistance += t[ye].dist(t[ye + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const C = hc.types[r.type] === "Polygon";
            let I = t.length;
            for (; I >= 2 && t[I - 1].equals(t[I - 2]);) I--;
            let R = 0;
            for (; R < I - 1 && t[R].equals(t[R + 1]);) R++;
            if (I < (C ? 3 : 2)) return;
            a === "bevel" && (p = 1.05);
            const U = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              Z = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
            let X, Q, ie, ue, Ne;
            this.e1 = this.e2 = -1, C && (X = t[I - 2], Ne = t[R].sub(X)._unit()._perp());
            for (let ye = R; ye < I; ye++) {
              if (ie = ye === I - 1 ? C ? t[R + 1] : void 0 : t[ye + 1], ie && t[ye].equals(ie)) continue;
              Ne && (ue = Ne), X && (Q = X), X = t[ye], Ne = ie ? ie.sub(X)._unit()._perp() : ue, ue = ue || Ne;
              let Ce = ue.add(Ne);
              Ce.x === 0 && Ce.y === 0 || Ce._unit();
              const tt = ue.x * Ne.x + ue.y * Ne.y,
                dt = Ce.x * Ne.x + Ce.y * Ne.y,
                Rt = dt !== 0 ? 1 / dt : 1 / 0,
                ir = 2 * Math.sqrt(2 - 2 * dt),
                Wt = dt < j1 && Q && ie,
                er = ue.x * Ne.y - ue.y * Ne.x > 0;
              if (Wt && ye > R) {
                const tr = X.dist(Q);
                if (tr > 2 * U) {
                  const St = X.sub(X.sub(Q)._mult(U / tr)._round());
                  this.updateDistance(Q, St), this.addCurrentVertex(St, ue, 0, 0, Z), Q = St
                }
              }
              const Fr = Q && ie;
              let Qt = Fr ? a : C ? "butt" : c;
              if (Fr && Qt === "round" && (Rt < m ? Qt = "miter" : Rt <= 2 && (Qt = "fakeround")), Qt === "miter" && Rt > p && (Qt = "bevel"), Qt === "bevel" && (Rt > 2 && (Qt = "flipbevel"), Rt < p && (Qt = "miter")), Q && this.updateDistance(Q, X), Qt === "miter") Ce._mult(Rt), this.addCurrentVertex(X, Ce, 0, 0, Z);
              else if (Qt === "flipbevel") {
                if (Rt > 100) Ce = Ne.mult(-1);
                else {
                  const tr = Rt * ue.add(Ne).mag() / ue.sub(Ne).mag();
                  Ce._perp()._mult(tr * (er ? -1 : 1))
                }
                this.addCurrentVertex(X, Ce, 0, 0, Z), this.addCurrentVertex(X, Ce.mult(-1), 0, 0, Z)
              } else if (Qt === "bevel" || Qt === "fakeround") {
                const tr = -Math.sqrt(Rt * Rt - 1),
                  St = er ? tr : 0,
                  $r = er ? 0 : tr;
                if (Q && this.addCurrentVertex(X, ue, St, $r, Z), Qt === "fakeround") {
                  const Kr = Math.round(180 * ir / Math.PI / 20);
                  for (let jr = 1; jr < Kr; jr++) {
                    let Sr = jr / Kr;
                    if (Sr !== .5) {
                      const ni = Sr - .5;
                      Sr += Sr * ni * (Sr - 1) * ((1.0904 + tt * (tt * (3.55645 - 1.43519 * tt) - 3.2452)) * ni * ni + (.848013 + tt * (.215638 * tt - 1.06021)))
                    }
                    const wn = Ne.sub(ue)._mult(Sr)._add(ue)._unit()._mult(er ? -1 : 1);
                    this.addHalfVertex(X, wn.x, wn.y, !1, er, 0, Z)
                  }
                }
                ie && this.addCurrentVertex(X, Ne, -St, -$r, Z)
              } else if (Qt === "butt") this.addCurrentVertex(X, Ce, 0, 0, Z);
              else if (Qt === "square") {
                const tr = Q ? 1 : -1;
                this.addCurrentVertex(X, Ce, tr, tr, Z)
              } else Qt === "round" && (Q && (this.addCurrentVertex(X, ue, 0, 0, Z), this.addCurrentVertex(X, ue, 1, 1, Z, !0)), ie && (this.addCurrentVertex(X, Ne, -1, -1, Z, !0), this.addCurrentVertex(X, Ne, 0, 0, Z)));
              if (Wt && ye < I - 1) {
                const tr = X.dist(ie);
                if (tr > 2 * U) {
                  const St = X.add(ie.sub(X)._mult(U / tr)._round());
                  this.updateDistance(X, St), this.addCurrentVertex(St, Ne, 0, 0, Z), X = St
                }
              }
            }
          }
          addCurrentVertex(t, r, a, c, p, m = !1) {
            const v = r.y * c - r.x,
              b = -r.y - r.x * c;
            this.addHalfVertex(t, r.x + r.y * a, r.y - r.x * a, m, !1, a, p), this.addHalfVertex(t, v, b, m, !0, -c, p), this.distance > bg / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, a, c, p, m))
          }
          addHalfVertex({
            x: t,
            y: r
          }, a, c, p, m, v, b) {
            const C = .5 * (this.lineClips ? this.scaledDistance * (bg - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (r << 1) + (m ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * c) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & C) << 2, C >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const I = b.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2), b.primitiveLength++), m ? this.e2 = I : this.e1 = I
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance()
          }
          hasLineDasharray(t) {
            for (const r of t) {
              const a = r.paint.get("line-dasharray");
              if (a && !a.isConstant()) return !0
            }
            return !1
          }
          addLineDashDependencies(t, r, a, c) {
            for (const p of t) {
              const m = p.paint.get("line-dasharray");
              if (!m || m.value.kind === "constant") continue;
              const v = p.layout.get("line-cap") === "round",
                b = {
                  dasharray: m.value.evaluate({
                    zoom: a - 1
                  }, r, {}),
                  round: v
                },
                C = {
                  dasharray: m.value.evaluate({
                    zoom: a
                  }, r, {}),
                  round: v
                },
                I = {
                  dasharray: m.value.evaluate({
                    zoom: a + 1
                  }, r, {}),
                  round: v
                },
                R = `${b.dasharray.join(",")},${b.round}`,
                U = `${C.dasharray.join(",")},${C.round}`,
                Z = `${I.dasharray.join(",")},${I.round}`;
              c.dashDependencies[R] = b, c.dashDependencies[U] = C, c.dashDependencies[Z] = I, r.dashes[p.id] = {
                min: R,
                mid: U,
                max: Z
              }
            }
          }
        }
        let wg, Tg;
        sr("LineBucket", Of, {
          omit: ["layers", "patternFeatures"]
        });
        var Sg = {
          get paint() {
            return Tg = Tg || new Zi({
              "line-opacity": new Ur(_e.paint_line["line-opacity"]),
              "line-color": new Ur(_e.paint_line["line-color"]),
              "line-translate": new Ar(_e.paint_line["line-translate"]),
              "line-translate-anchor": new Ar(_e.paint_line["line-translate-anchor"]),
              "line-width": new Ur(_e.paint_line["line-width"]),
              "line-gap-width": new Ur(_e.paint_line["line-gap-width"]),
              "line-offset": new Ur(_e.paint_line["line-offset"]),
              "line-blur": new Ur(_e.paint_line["line-blur"]),
              "line-dasharray": new nl(_e.paint_line["line-dasharray"]),
              "line-pattern": new nl(_e.paint_line["line-pattern"]),
              "line-gradient": new il(_e.paint_line["line-gradient"])
            })
          },
          get layout() {
            return wg = wg || new Zi({
              "line-cap": new Ar(_e.layout_line["line-cap"]),
              "line-join": new Ur(_e.layout_line["line-join"]),
              "line-miter-limit": new Ar(_e.layout_line["line-miter-limit"]),
              "line-round-limit": new Ar(_e.layout_line["line-round-limit"]),
              "line-sort-key": new Ur(_e.layout_line["line-sort-key"])
            })
          }
        };
        class V1 extends Ur {
          possiblyEvaluate(t, r) {
            return r = new Bn(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition
            }), super.possiblyEvaluate(t, r)
          }
          evaluate(t, r, a, c) {
            return r = ot({}, r, {
              zoom: Math.floor(r.zoom)
            }), super.evaluate(t, r, a, c)
          }
        }
        let ip;
        class q1 extends Ia {
          constructor(t, r) {
            super(t, Sg, r), this.gradientVersion = 0, ip || (ip = new V1(Sg.paint.properties["line-width"].specification), ip.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(a) {
                return a._styleExpression !== void 0
              })(r) && r._styleExpression.expression instanceof ps, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = ip.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new Of(t)
          }
          queryRadius(t) {
            const r = t,
              a = Cg(sc("line-width", this, r), sc("line-gap-width", this, r)),
              c = sc("line-offset", this, r);
            return a / 2 + Math.abs(c) + Jd(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: a,
            geometry: c,
            transform: p,
            pixelsToTileUnits: m
          }) {
            const v = Qd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, m),
              b = m / 2 * Cg(this.paint.get("line-width").evaluate(r, a), this.paint.get("line-gap-width").evaluate(r, a)),
              C = this.paint.get("line-offset").evaluate(r, a);
            return C && (c = (function(I, R) {
              const U = [];
              for (let Z = 0; Z < I.length; Z++) {
                const X = I[Z],
                  Q = [];
                for (let ie = 0; ie < X.length; ie++) {
                  const ue = X[ie - 1],
                    Ne = X[ie],
                    ye = X[ie + 1],
                    Ce = ie === 0 ? new B(0, 0) : Ne.sub(ue)._unit()._perp(),
                    tt = ie === X.length - 1 ? new B(0, 0) : ye.sub(Ne)._unit()._perp(),
                    dt = Ce._add(tt)._unit(),
                    Rt = dt.x * tt.x + dt.y * tt.y;
                  Rt !== 0 && dt._mult(1 / Rt), Q.push(dt._mult(R)._add(Ne))
                }
                U.push(Q)
              }
              return U
            })(c, C * m)), (function(I, R, U) {
              for (let Z = 0; Z < R.length; Z++) {
                const X = R[Z];
                if (I.length >= 3) {
                  for (let Q = 0; Q < X.length; Q++)
                    if (oc(I, X[Q])) return !0
                }
                if (Xy(I, X, U)) return !0
              }
              return !1
            })(v, c, b)
          }
          isTileClipped() {
            return !0
          }
        }

        function Cg(n, t) {
          return t > 0 ? t + 2 * n : n
        }
        const U1 = si([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          Z1 = si([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        si([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const G1 = si([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        si([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const Pg = si([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          $1 = si([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function H1(n, t, r) {
          return n.sections.forEach((a => {
            a.text = (function(c, p, m) {
              const v = p.layout.get("text-transform").evaluate(m, {});
              return v === "uppercase" ? c = c.toLocaleUpperCase() : v === "lowercase" && (c = c.toLocaleLowerCase()), no.applyArabicShaping && (c = no.applyArabicShaping(c)), c
            })(a.text, t, r)
          })), n
        }
        si([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), si([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), si([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), si([{
          type: "Float32",
          name: "offsetX"
        }]), si([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), si([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const ju = {
          "!": "Ô∏ï",
          "#": "ÔºÉ",
          $: "ÔºÑ",
          "%": "ÔºÖ",
          "&": "ÔºÜ",
          "(": "Ô∏µ",
          ")": "Ô∏∂",
          "*": "Ôºä",
          "+": "Ôºã",
          ",": "Ô∏ê",
          "-": "Ô∏≤",
          ".": "„Éª",
          "/": "Ôºè",
          ":": "Ô∏ì",
          ";": "Ô∏î",
          "<": "Ô∏ø",
          "=": "Ôºù",
          ">": "ÔπÄ",
          "?": "Ô∏ñ",
          "@": "Ôº†",
          "[": "Ôπá",
          "\\": "Ôºº",
          "]": "Ôπà",
          "^": "Ôºæ",
          _: "Ô∏≥",
          "`": "ÔΩÄ",
          "{": "Ô∏∑",
          "|": "‚Äï",
          "}": "Ô∏∏",
          "~": "ÔΩû",
          "¬¢": "Ôø†",
          "¬£": "Ôø°",
          "¬•": "Ôø•",
          "¬¶": "Ôø§",
          "¬¨": "Ôø¢",
          "¬Ø": "Ôø£",
          "‚Äì": "Ô∏≤",
          "‚Äî": "Ô∏±",
          "‚Äò": "ÔπÉ",
          "‚Äô": "ÔπÑ",
          "‚Äú": "ÔπÅ",
          "‚Äù": "ÔπÇ",
          "‚Ä¶": "Ô∏ô",
          "‚Äß": "„Éª",
          "‚Ç©": "Ôø¶",
          "„ÄÅ": "Ô∏ë",
          "„ÄÇ": "Ô∏í",
          "„Äà": "Ô∏ø",
          "„Äâ": "ÔπÄ",
          "„Ää": "Ô∏Ω",
          "„Äã": "Ô∏æ",
          "„Äå": "ÔπÅ",
          "„Äç": "ÔπÇ",
          "„Äé": "ÔπÉ",
          "„Äè": "ÔπÑ",
          "„Äê": "Ô∏ª",
          "„Äë": "Ô∏º",
          "„Äî": "Ô∏π",
          "„Äï": "Ô∏∫",
          "„Äñ": "Ô∏ó",
          "„Äó": "Ô∏ò",
          "ÔºÅ": "Ô∏ï",
          "Ôºà": "Ô∏µ",
          "Ôºâ": "Ô∏∂",
          "Ôºå": "Ô∏ê",
          "Ôºç": "Ô∏≤",
          "Ôºé": "„Éª",
          "Ôºö": "Ô∏ì",
          "Ôºõ": "Ô∏î",
          "Ôºú": "Ô∏ø",
          "Ôºû": "ÔπÄ",
          "Ôºü": "Ô∏ñ",
          "Ôºª": "Ôπá",
          "ÔºΩ": "Ôπà",
          "Ôºø": "Ô∏≥",
          "ÔΩõ": "Ô∏∑",
          "ÔΩú": "‚Äï",
          "ÔΩù": "Ô∏∏",
          "ÔΩü": "Ô∏µ",
          "ÔΩ†": "Ô∏∂",
          "ÔΩ°": "Ô∏í",
          "ÔΩ¢": "ÔπÅ",
          "ÔΩ£": "ÔπÇ"
        };
        var ki = 24;
        const Nf = 4294967296,
          Ig = 1 / Nf,
          Mg = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class jf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, r, a = this.length) {
            for (; this.pos < a;) {
              const c = this.readVarint(),
                p = c >> 3,
                m = this.pos;
              this.type = 7 & c, t(p, r, this), this.pos === m && this.skip(c)
            }
            return r
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Nf;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Nf;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const r = this.buf;
            let a, c;
            return c = r[this.pos++], a = 127 & c, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 7, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 14, c < 128 ? a : (c = r[this.pos++], a |= (127 & c) << 21, c < 128 ? a : (c = r[this.pos], a |= (15 & c) << 28, (function(p, m, v) {
              const b = v.buf;
              let C, I;
              if (I = b[v.pos++], C = (112 & I) >> 4, I < 128 || (I = b[v.pos++], C |= (127 & I) << 3, I < 128) || (I = b[v.pos++], C |= (127 & I) << 10, I < 128) || (I = b[v.pos++], C |= (127 & I) << 17, I < 128) || (I = b[v.pos++], C |= (127 & I) << 24, I < 128) || (I = b[v.pos++], C |= (1 & I) << 31, I < 128)) return dc(p, C, m);
              throw new Error("Expected varint not more than 10 bytes")
            })(a, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              r = this.pos;
            return this.pos = t, t - r >= 12 && Mg ? Mg.decode(this.buf.subarray(r, t)) : (function(a, c, p) {
              let m = "",
                v = c;
              for (; v < p;) {
                const b = a[v];
                let C, I, R, U = null,
                  Z = b > 239 ? 4 : b > 223 ? 3 : b > 191 ? 2 : 1;
                if (v + Z > p) break;
                Z === 1 ? b < 128 && (U = b) : Z === 2 ? (C = a[v + 1], (192 & C) == 128 && (U = (31 & b) << 6 | 63 & C, U <= 127 && (U = null))) : Z === 3 ? (C = a[v + 1], I = a[v + 2], (192 & C) == 128 && (192 & I) == 128 && (U = (15 & b) << 12 | (63 & C) << 6 | 63 & I, (U <= 2047 || U >= 55296 && U <= 57343) && (U = null))) : Z === 4 && (C = a[v + 1], I = a[v + 2], R = a[v + 3], (192 & C) == 128 && (192 & I) == 128 && (192 & R) == 128 && (U = (15 & b) << 18 | (63 & C) << 12 | (63 & I) << 6 | 63 & R, (U <= 65535 || U >= 1114112) && (U = null))), U === null ? (U = 65533, Z = 1) : U > 65535 && (U -= 65536, m += String.fromCharCode(U >>> 10 & 1023 | 55296), U = 56320 | 1023 & U), m += String.fromCharCode(U), v += Z
              }
              return m
            })(this.buf, r, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              r = this.buf.subarray(this.pos, t);
            return this.pos = t, r
          }
          readPackedVarint(t = [], r) {
            const a = this.readPackedEnd();
            for (; this.pos < a;) t.push(this.readVarint(r));
            return t
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r)
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t;) r *= 2;
            if (r !== this.length) {
              const a = new Uint8Array(r);
              a.set(this.buf), this.buf = a, this.dataView = new DataView(a.buffer), this.length = r
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Ig), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Ig), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, a) {
              let c, p;
              if (r >= 0 ? (c = r % 4294967296 | 0, p = r / 4294967296 | 0) : (c = ~(-r % 4294967296), p = ~(-r / 4294967296), 4294967295 ^ c ? c = c + 1 | 0 : (c = 0, p = p + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              a.realloc(10), (function(m, v, b) {
                b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, b.buf[b.pos] = 127 & (m >>>= 7)
              })(c, 0, a), (function(m, v) {
                const b = (7 & m) << 4;
                v.buf[v.pos++] |= b | ((m >>>= 3) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m)))))
              })(p, a)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(c, p, m) {
              for (let v, b, C = 0; C < p.length; C++) {
                if (v = p.charCodeAt(C), v > 55295 && v < 57344) {
                  if (!b) {
                    v > 56319 || C + 1 === p.length ? (c[m++] = 239, c[m++] = 191, c[m++] = 189) : b = v;
                    continue
                  }
                  if (v < 56320) {
                    c[m++] = 239, c[m++] = 191, c[m++] = 189, b = v;
                    continue
                  }
                  v = b - 55296 << 10 | v - 56320 | 65536, b = null
                } else b && (c[m++] = 239, c[m++] = 191, c[m++] = 189, b = null);
                v < 128 ? c[m++] = v : (v < 2048 ? c[m++] = v >> 6 | 192 : (v < 65536 ? c[m++] = v >> 12 | 224 : (c[m++] = v >> 18 | 240, c[m++] = v >> 12 & 63 | 128), c[m++] = v >> 6 & 63 | 128), c[m++] = 63 & v | 128)
              }
              return m
            })(this.buf, t, this.pos);
            const a = this.pos - r;
            a >= 128 && Ag(r, a, this), this.pos = r - 1, this.writeVarint(a), this.pos += a
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let a = 0; a < r; a++) this.buf[this.pos++] = t[a]
          }
          writeRawMessage(t, r) {
            this.pos++;
            const a = this.pos;
            t(r, this);
            const c = this.pos - a;
            c >= 128 && Ag(a, c, this), this.pos = a - 1, this.writeVarint(c), this.pos += c
          }
          writeMessage(t, r, a) {
            this.writeTag(t, 2), this.writeRawMessage(r, a)
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, W1, r)
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, X1, r)
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, J1, r)
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, Y1, r)
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, K1, r)
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, Q1, r)
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, ex, r)
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, tx, r)
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, rx, r)
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r)
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r)
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r)
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r)
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r)
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r)
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r)
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r)
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r)
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r)
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r)
          }
        }

        function dc(n, t, r) {
          return r ? 4294967296 * t + (n >>> 0) : 4294967296 * (t >>> 0) + (n >>> 0)
        }

        function Ag(n, t, r) {
          const a = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(a);
          for (let c = r.pos - 1; c >= n; c--) r.buf[c + a] = r.buf[c]
        }

        function W1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeVarint(n[r])
        }

        function X1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSVarint(n[r])
        }

        function Y1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFloat(n[r])
        }

        function K1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeDouble(n[r])
        }

        function J1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeBoolean(n[r])
        }

        function Q1(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed32(n[r])
        }

        function ex(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed32(n[r])
        }

        function tx(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed64(n[r])
        }

        function rx(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed64(n[r])
        }

        function nx(n, t, r) {
          n === 1 && r.readMessage(ix, t)
        }

        function ix(n, t, r) {
          if (n === 3) {
            const {
              id: a,
              bitmap: c,
              width: p,
              height: m,
              left: v,
              top: b,
              advance: C
            } = r.readMessage(ax, {});
            t.push({
              id: a,
              bitmap: new Eu({
                width: p + 6,
                height: m + 6
              }, c),
              metrics: {
                width: p,
                height: m,
                left: v,
                top: b,
                advance: C
              }
            })
          }
        }

        function ax(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? t.bitmap = r.readBytes() : n === 3 ? t.width = r.readVarint() : n === 4 ? t.height = r.readVarint() : n === 5 ? t.left = r.readSVarint() : n === 6 ? t.top = r.readSVarint() : n === 7 && (t.advance = r.readVarint())
        }

        function kg(n) {
          let t = 0,
            r = 0;
          for (const m of n) t += m.w * m.h, r = Math.max(r, m.w);
          n.sort(((m, v) => v.h - m.h));
          const a = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let c = 0,
            p = 0;
          for (const m of n)
            for (let v = a.length - 1; v >= 0; v--) {
              const b = a[v];
              if (!(m.w > b.w || m.h > b.h)) {
                if (m.x = b.x, m.y = b.y, p = Math.max(p, m.y + m.h), c = Math.max(c, m.x + m.w), m.w === b.w && m.h === b.h) {
                  const C = a.pop();
                  C && v < a.length && (a[v] = C)
                } else m.h === b.h ? (b.x += m.w, b.w -= m.w) : m.w === b.w ? (b.y += m.h, b.h -= m.h) : (a.push({
                  x: b.x + m.w,
                  y: b.y,
                  w: b.w - m.w,
                  h: m.h
                }), b.y += m.h, b.h -= m.h);
                break
              }
            }
          return {
            w: c,
            h: p,
            fill: t / (c * p) || 0
          }
        }
        class Vf {
          constructor(t, {
            pixelRatio: r,
            version: a,
            stretchX: c,
            stretchY: p,
            content: m,
            textFitWidth: v,
            textFitHeight: b
          }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = c, this.stretchY = p, this.content = m, this.version = a, this.textFitWidth = v, this.textFitHeight = b
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class Eg {
          constructor(t, r) {
            const a = {},
              c = {};
            this.haveRenderCallbacks = [];
            const p = [];
            this.addImages(t, a, p), this.addImages(r, c, p);
            const {
              w: m,
              h: v
            } = kg(p), b = new ua({
              width: m || 1,
              height: v || 1
            });
            for (const C in t) {
              const I = t[C],
                R = a[C].paddedRect;
              ua.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: R.x + 1,
                y: R.y + 1
              }, I.data)
            }
            for (const C in r) {
              const I = r[C],
                R = c[C].paddedRect,
                U = R.x + 1,
                Z = R.y + 1,
                X = I.data.width,
                Q = I.data.height;
              ua.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: U,
                y: Z
              }, I.data), ua.copy(I.data, b, {
                x: 0,
                y: Q - 1
              }, {
                x: U,
                y: Z - 1
              }, {
                width: X,
                height: 1
              }), ua.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: U,
                y: Z + Q
              }, {
                width: X,
                height: 1
              }), ua.copy(I.data, b, {
                x: X - 1,
                y: 0
              }, {
                x: U - 1,
                y: Z
              }, {
                width: 1,
                height: Q
              }), ua.copy(I.data, b, {
                x: 0,
                y: 0
              }, {
                x: U + X,
                y: Z
              }, {
                width: 1,
                height: Q
              })
            }
            this.image = b, this.iconPositions = a, this.patternPositions = c
          }
          addImages(t, r, a) {
            for (const c in t) {
              const p = t[c],
                m = {
                  x: 0,
                  y: 0,
                  w: p.data.width + 2,
                  h: p.data.height + 2
                };
              a.push(m), r[c] = new Vf(m, p), p.hasRenderCallback && this.haveRenderCallbacks.push(c)
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const a in t.updatedImages) this.patchUpdatedImage(this.iconPositions[a], t.getImage(a), r), this.patchUpdatedImage(this.patternPositions[a], t.getImage(a), r)
          }
          patchUpdatedImage(t, r, a) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [c, p] = t.tl;
            a.update(r.data, void 0, {
              x: c,
              y: p
            })
          }
        }
        var Ps;
        sr("ImagePosition", Vf), sr("ImageAtlas", Eg), w.as = void 0, (Ps = w.as || (w.as = {}))[Ps.none = 0] = "none", Ps[Ps.horizontal = 1] = "horizontal", Ps[Ps.vertical = 2] = "vertical", Ps[Ps.horizontalOnly = 3] = "horizontalOnly";
        class Vu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, r, a) {
            const c = new Vu;
            return c.scale = t || 1, c.fontStack = r, c.verticalAlign = a || "bottom", c
          }
          static forImage(t, r) {
            const a = new Vu;
            return a.imageName = t, a.verticalAlign = r || "bottom", a
          }
        }
        class pc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, r) {
            const a = new pc;
            for (let c = 0; c < t.sections.length; c++) {
              const p = t.sections[c];
              p.image ? a.addImageSection(p) : a.addTextSection(p, r)
            }
            return a
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let a = 0; a < t.length; a++) {
                const c = t.charCodeAt(a + 1) || null,
                  p = t.charCodeAt(a - 1) || null;
                r += c && Kl(c) && !ju[t[a + 1]] || p && Kl(p) && !ju[t[a - 1]] || !ju[t[a]] ? t[a] : ju[t[a]]
              }
              return r
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let a = 0; a < this.text.length && op[this.text.charCodeAt(a)]; a++) t++;
            let r = this.text.length;
            for (let a = this.text.length - 1; a >= 0 && a >= t && op[this.text.charCodeAt(a)]; a--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r)
          }
          substring(t, r) {
            const a = new pc;
            return a.text = this.text.substring(t, r), a.sectionIndex = this.sectionIndex.slice(t, r), a.sections = this.sections, a
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0)
          }
          getMaxImageSize(t) {
            let r = 0,
              a = 0;
            for (let c = 0; c < this.length(); c++) {
              const p = this.getSection(c);
              if (p.imageName) {
                const m = t[p.imageName];
                if (!m) continue;
                const v = m.displaySize;
                r = Math.max(r, v[0]), a = Math.max(a, v[1])
              }
            }
            return {
              maxImageWidth: r,
              maxImageHeight: a
            }
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(Vu.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const a = this.sections.length - 1;
            for (let c = 0; c < t.text.length; ++c) this.sectionIndex.push(a)
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void Nt("Can't add FormattedSection with an empty image.");
            const a = this.getNextImageSectionCharCode();
            a ? (this.text += String.fromCharCode(a), this.sections.push(Vu.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Nt("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function ap(n, t, r, a, c, p, m, v, b, C, I, R, U, Z, X) {
          const Q = pc.fromFeature(n, c);
          let ie;
          R === w.as.vertical && Q.verticalizePunctuation();
          const {
            processBidirectionalText: ue,
            processStyledBidirectionalText: Ne
          } = no;
          if (ue && Q.sections.length === 1) {
            ie = [];
            const tt = ue(Q.toString(), qf(Q, C, p, t, a, Z));
            for (const dt of tt) {
              const Rt = new pc;
              Rt.text = dt, Rt.sections = Q.sections;
              for (let ir = 0; ir < dt.length; ir++) Rt.sectionIndex.push(0);
              ie.push(Rt)
            }
          } else if (Ne) {
            ie = [];
            const tt = Ne(Q.text, Q.sectionIndex, qf(Q, C, p, t, a, Z));
            for (const dt of tt) {
              const Rt = new pc;
              Rt.text = dt[0], Rt.sectionIndex = dt[1], Rt.sections = Q.sections, ie.push(Rt)
            }
          } else ie = (function(tt, dt) {
            const Rt = [],
              ir = tt.text;
            let Wt = 0;
            for (const er of dt) Rt.push(tt.substring(Wt, er)), Wt = er;
            return Wt < ir.length && Rt.push(tt.substring(Wt, ir.length)), Rt
          })(Q, qf(Q, C, p, t, a, Z));
          const ye = [],
            Ce = {
              positionedLines: ye,
              text: Q.toString(),
              top: I[1],
              bottom: I[1],
              left: I[0],
              right: I[0],
              writingMode: R,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(tt, dt, Rt, ir, Wt, er, Fr, Qt, tr, St, $r, Kr) {
            let jr = 0,
              Sr = 0,
              wn = 0,
              ni = 0;
            const bi = Qt === "right" ? 1 : Qt === "left" ? 0 : .5,
              $i = ki / Kr;
            let ka = 0;
            for (const ei of Wt) {
              ei.trim();
              const Ei = ei.getMaxScale(),
                Bi = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              tt.positionedLines[ka] = Bi;
              const Oi = Bi.positionedGlyphs;
              let ia = 0;
              if (!ei.length()) {
                Sr += er, ++ka;
                continue
              }
              const Ea = cx(ir, ei, $i);
              for (let da = 0; da < ei.length(); da++) {
                const wi = ei.getSection(da),
                  Li = ei.getSectionIndex(da),
                  Di = ei.getCharCode(da),
                  vi = ux(tr, $r, Di);
                let Hn;
                if (wi.imageName) {
                  if (tt.iconsInText = !0, wi.scale = wi.scale * $i, Hn = dx(wi, vi, Ei, Ea, ir), !Hn) continue;
                  ia = Math.max(ia, Hn.imageOffset)
                } else if (Hn = hx(wi, Di, vi, Ea, dt, Rt), !Hn) continue;
                const {
                  rect: lo,
                  metrics: gc,
                  baselineOffset: co
                } = Hn;
                Oi.push({
                  glyph: Di,
                  imageName: wi.imageName,
                  x: jr,
                  y: Sr + co + -17,
                  vertical: vi,
                  scale: wi.scale,
                  fontStack: wi.fontStack,
                  sectionIndex: Li,
                  metrics: gc,
                  rect: lo
                }), vi ? (tt.verticalizable = !0, jr += (wi.imageName ? gc.advance : ki) * wi.scale + St) : jr += gc.advance * wi.scale + St
              }
              Oi.length !== 0 && (wn = Math.max(jr - St, wn), px(Oi, 0, Oi.length - 1, bi)), jr = 0, Bi.lineOffset = Math.max(ia, (Ei - 1) * ki);
              const zi = er * Ei + ia;
              Sr += zi, ni = Math.max(zi, ni), ++ka
            }
            const {
              horizontalAlign: ha,
              verticalAlign: Fi
            } = Uf(Fr);
            (function(ei, Ei, Bi, Oi, ia, Ea, zi, da, wi) {
              const Li = (Ei - Bi) * ia;
              let Di = 0;
              Di = Ea !== zi ? -da * Oi - -17 : -Oi * wi * zi + .5 * zi;
              for (const vi of ei)
                for (const Hn of vi.positionedGlyphs) Hn.x += Li, Hn.y += Di
            })(tt.positionedLines, bi, ha, Fi, wn, ni, er, Sr, Wt.length), tt.top += -Fi * Sr, tt.bottom = tt.top + Sr, tt.left += -ha * wn, tt.right = tt.left + wn
          })(Ce, t, r, a, ie, m, v, b, R, C, U, X), !(function(tt) {
            for (const dt of tt)
              if (dt.positionedGlyphs.length !== 0) return !1;
            return !0
          })(ye) && Ce
        }
        const op = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          ox = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          sx = {
            40: !0
          };

        function zg(n, t, r, a, c, p) {
          if (t.imageName) {
            const m = a[t.imageName];
            return m ? m.displaySize[0] * t.scale * ki / p + c : 0
          } {
            const m = r[t.fontStack],
              v = m && m[n];
            return v ? v.metrics.advance * t.scale + c : 0
          }
        }

        function Lg(n, t, r, a) {
          const c = Math.pow(n - t, 2);
          return a ? n < t ? c / 2 : 2 * c : c + Math.abs(r) * r
        }

        function lx(n, t, r) {
          let a = 0;
          return n === 10 && (a -= 1e4), r && (a += 150), n !== 40 && n !== 65288 || (a += 50), t !== 41 && t !== 65289 || (a += 50), a
        }

        function Dg(n, t, r, a, c, p) {
          let m = null,
            v = Lg(t, r, c, p);
          for (const b of a) {
            const C = Lg(t - b.x, r, c, p) + b.badness;
            C <= v && (m = b, v = C)
          }
          return {
            index: n,
            x: t,
            priorBreak: m,
            badness: v
          }
        }

        function Rg(n) {
          return n ? Rg(n.priorBreak).concat(n.index) : []
        }

        function qf(n, t, r, a, c, p) {
          if (!n) return [];
          const m = [],
            v = (function(R, U, Z, X, Q, ie) {
              let ue = 0;
              for (let Ne = 0; Ne < R.length(); Ne++) {
                const ye = R.getSection(Ne);
                ue += zg(R.getCharCode(Ne), ye, X, Q, U, ie)
              }
              return ue / Math.max(1, Math.ceil(ue / Z))
            })(n, t, r, a, c, p),
            b = n.text.indexOf("‚Äã") >= 0;
          let C = 0;
          for (let R = 0; R < n.length(); R++) {
            const U = n.getSection(R),
              Z = n.getCharCode(R);
            if (op[Z] || (C += zg(Z, U, a, c, t, p)), R < n.length() - 1) {
              const X = !((I = Z) < 11904) && (!!pn["CJK Compatibility Forms"](I) || !!pn["CJK Compatibility"](I) || !!pn["CJK Strokes"](I) || !!pn["CJK Symbols and Punctuation"](I) || !!pn["Enclosed CJK Letters and Months"](I) || !!pn["Halfwidth and Fullwidth Forms"](I) || !!pn["Ideographic Description Characters"](I) || !!pn["Vertical Forms"](I) || yu.test(String.fromCodePoint(I)));
              (ox[Z] || X || U.imageName || R !== n.length() - 2 && sx[n.getCharCode(R + 1)]) && m.push(Dg(R + 1, C, v, m, lx(Z, n.getCharCode(R + 1), X && b), !1))
            }
          }
          var I;
          return Rg(Dg(n.length(), C, v, m, 0, !0))
        }

        function Uf(n) {
          let t = .5,
            r = .5;
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (n) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          }
        }

        function cx(n, t, r) {
          const a = t.getMaxScale() * ki,
            {
              maxImageWidth: c,
              maxImageHeight: p
            } = t.getMaxImageSize(n),
            m = Math.max(a, p * r);
          return {
            verticalLineContentWidth: Math.max(a, c * r),
            horizontalLineContentHeight: m
          }
        }

        function Fg(n) {
          switch (n) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function ux(n, t, r) {
          return !(n === w.as.horizontal || !t && !Yl(r) || t && (op[r] || (a = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(a)))));
          var a
        }

        function hx(n, t, r, a, c, p) {
          const m = p[n.fontStack],
            v = (function(C, I, R, U) {
              if (C && C.rect) return C;
              const Z = I[R.fontStack],
                X = Z && Z[U];
              return X ? {
                rect: null,
                metrics: X.metrics
              } : null
            })(m && m[t], c, n, t);
          if (v === null) return null;
          let b;
          if (r) b = a.verticalLineContentWidth - n.scale * ki;
          else {
            const C = Fg(n.verticalAlign);
            b = (a.horizontalLineContentHeight - n.scale * ki) * C
          }
          return {
            rect: v.rect,
            metrics: v.metrics,
            baselineOffset: b
          }
        }

        function dx(n, t, r, a, c) {
          const p = c[n.imageName];
          if (!p) return null;
          const m = p.paddedRect,
            v = p.displaySize,
            b = {
              width: v[0],
              height: v[1],
              left: 1,
              top: -3,
              advance: t ? v[1] : v[0]
            };
          let C;
          if (t) C = a.verticalLineContentWidth - v[1] * n.scale;
          else {
            const I = Fg(n.verticalAlign);
            C = (a.horizontalLineContentHeight - v[1] * n.scale) * I
          }
          return {
            rect: m,
            metrics: b,
            baselineOffset: C,
            imageOffset: (t ? v[0] : v[1]) * n.scale - ki * r
          }
        }

        function px(n, t, r, a) {
          if (a === 0) return;
          const c = n[r],
            p = (n[r].x + c.metrics.advance * c.scale) * a;
          for (let m = t; m <= r; m++) n[m].x -= p
        }

        function fx(n, t, r) {
          const {
            horizontalAlign: a,
            verticalAlign: c
          } = Uf(r), p = t[0] - n.displaySize[0] * a, m = t[1] - n.displaySize[1] * c;
          return {
            image: n,
            top: m,
            bottom: m + n.displaySize[1],
            left: p,
            right: p + n.displaySize[0]
          }
        }

        function Bg(n) {
          var t, r;
          let a = n.left,
            c = n.top,
            p = n.right - a,
            m = n.bottom - c;
          const v = (t = n.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            b = (r = n.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink",
            C = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]);
          if (b === "proportional") {
            if (v === "stretchOnly" && p / m < C || v === "proportional") {
              const I = Math.ceil(m * C);
              a *= I / p, p = I
            }
          } else if (v === "proportional" && b === "stretchOnly" && C !== 0 && p / m > C) {
            const I = Math.ceil(p / C);
            c *= I / m, m = I
          }
          return {
            x1: a,
            y1: c,
            x2: a + p,
            y2: c + m
          }
        }

        function Og(n, t, r, a, c, p) {
          const m = n.image;
          let v;
          if (m.content) {
            const ie = m.content,
              ue = m.pixelRatio || 1;
            v = [ie[0] / ue, ie[1] / ue, m.displaySize[0] - ie[2] / ue, m.displaySize[1] - ie[3] / ue]
          }
          const b = t.left * p,
            C = t.right * p;
          let I, R, U, Z;
          r === "width" || r === "both" ? (Z = c[0] + b - a[3], R = c[0] + C + a[1]) : (Z = c[0] + (b + C - m.displaySize[0]) / 2, R = Z + m.displaySize[0]);
          const X = t.top * p,
            Q = t.bottom * p;
          return r === "height" || r === "both" ? (I = c[1] + X - a[0], U = c[1] + Q + a[2]) : (I = c[1] + (X + Q - m.displaySize[1]) / 2, U = I + m.displaySize[1]), {
            image: m,
            top: I,
            right: R,
            bottom: U,
            left: Z,
            collisionPadding: v
          }
        }
        const Qo = 128,
          Is = 32640;

        function Ng(n, t) {
          const {
            expression: r
          } = t;
          if (r.kind === "constant") return {
            kind: "constant",
            layoutSize: r.evaluate(new Bn(n + 1))
          };
          if (r.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: a,
              interpolationType: c
            } = r;
            let p = 0;
            for (; p < a.length && a[p] <= n;) p++;
            p = Math.max(0, p - 1);
            let m = p;
            for (; m < a.length && a[m] < n + 1;) m++;
            m = Math.min(a.length - 1, m);
            const v = a[p],
              b = a[m];
            return r.kind === "composite" ? {
              kind: "composite",
              minZoom: v,
              maxZoom: b,
              interpolationType: c
            } : {
              kind: "camera",
              minZoom: v,
              maxZoom: b,
              minSize: r.evaluate(new Bn(v)),
              maxSize: r.evaluate(new Bn(b)),
              interpolationType: c
            }
          }
        }

        function Zf(n, t, r) {
          let a = "never";
          const c = n.get(t);
          return c ? a = c : n.get(r) && (a = "always"), a
        }
        const mx = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function sp(n, t, r, a, c, p, m, v, b, C, I, R, U) {
          const Z = v ? Math.min(Is, Math.round(v[0])) : 0,
            X = v ? Math.min(Is, Math.round(v[1])) : 0;
          n.emplaceBack(t, r, Math.round(32 * a), Math.round(32 * c), p, m, (Z << 1) + (b ? 1 : 0), X, 16 * C, 16 * I, 256 * R, 256 * U)
        }

        function Gf(n, t, r) {
          n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r)
        }

        function _x(n) {
          for (const t of n.sections)
            if (xf(t.text)) return !0;
          return !1
        }
        class $f {
          constructor(t) {
            this.layoutVertexArray = new et, this.indexArray = new Pt, this.programConfigurations = t, this.segments = new on, this.dynamicLayoutVertexArray = new rt, this.opacityVertexArray = new at, this.hasVisibleVertices = !1, this.placedSymbolArray = new k
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, r, a, c) {
            this.isEmpty() || (a && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, U1.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Z1.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, mx, !0), this.opacityVertexBuffer.itemSize = 1), (a || c) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        sr("SymbolBuffers", $f);
        class Hf {
          constructor(t, r, a) {
            this.layoutVertexArray = new t, this.layoutAttributes = r, this.indexArray = new a, this.segments = new on, this.collisionVertexArray = new Ht
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, G1.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        sr("CollisionBuffers", Hf);
        class fc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = Ot(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((m => m.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Ng(this.zoom, r["text-size"]), this.iconSizeData = Ng(this.zoom, r["icon-size"]);
            const a = this.layers[0].layout,
              c = a.get("symbol-sort-key"),
              p = a.get("symbol-z-order");
            this.canOverlap = Zf(a, "text-overlap", "text-allow-overlap") !== "never" || Zf(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !c.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((m => w.as[m]))), this.stateDependentLayerIds = this.layers.filter((m => m.isStateDependent())).map((m => m.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new $f(new Ko(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new $f(new Ko(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new F, this.lineVertexArray = new $, this.symbolInstances = new V, this.textAnchorOffsets = new ae
          }
          calculateGlyphDependencies(t, r, a, c, p) {
            for (let m = 0; m < t.length; m++)
              if (r[t.charCodeAt(m)] = !0, (a || c) && p) {
                const v = ju[t.charAt(m)];
                v && (r[v.charCodeAt(0)] = !0)
              }
          }
          populate(t, r, a) {
            const c = this.layers[0],
              p = c.layout,
              m = p.get("text-font"),
              v = p.get("text-field"),
              b = p.get("icon-image"),
              C = (v.value.kind !== "constant" || v.value.value instanceof Sn && !v.value.value.isEmpty() || v.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0),
              I = b.value.kind !== "constant" || !!b.value.value || Object.keys(b.parameters).length > 0,
              R = p.get("symbol-sort-key");
            if (this.features = [], !C && !I) return;
            const U = r.iconDependencies,
              Z = r.glyphDependencies,
              X = r.availableImages,
              Q = new Bn(this.zoom);
            for (const {
                feature: ie,
                id: ue,
                index: Ne,
                sourceLayerIndex: ye
              }
              of t) {
              const Ce = c._featureFilter.needGeometry,
                tt = So(ie, Ce);
              if (!c._featureFilter.filter(Q, tt, a)) continue;
              let dt, Rt;
              if (Ce || (tt.geometry = so(ie)), C) {
                const Wt = c.getValueAndResolveTokens("text-field", tt, a, X),
                  er = Sn.factory(Wt),
                  Fr = this.hasRTLText = this.hasRTLText || _x(er);
                (!Fr || no.getRTLTextPluginStatus() === "unavailable" || Fr && no.isParsed()) && (dt = H1(er, c, tt))
              }
              if (I) {
                const Wt = c.getValueAndResolveTokens("icon-image", tt, a, X);
                Rt = Wt instanceof Vn ? Wt : Vn.fromString(Wt)
              }
              if (!dt && !Rt) continue;
              const ir = this.sortFeaturesByKey ? R.evaluate(tt, {}, a) : void 0;
              if (this.features.push({
                  id: ue,
                  text: dt,
                  icon: Rt,
                  index: Ne,
                  sourceLayerIndex: ye,
                  geometry: tt.geometry,
                  properties: ie.properties,
                  type: hc.types[ie.type],
                  sortKey: ir
                }), Rt && (U[Rt.name] = !0), dt) {
                const Wt = m.evaluate(tt, {}, a).join(","),
                  er = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(w.as.vertical) >= 0;
                for (const Fr of dt.sections)
                  if (Fr.image) U[Fr.image.name] = !0;
                  else {
                    const Qt = gu(dt.toString()),
                      tr = Fr.fontStack || Wt,
                      St = Z[tr] = Z[tr] || {};
                    this.calculateGlyphDependencies(Fr.text, St, er, this.allowVerticalPlacement, Qt)
                  }
              }
            }
            p.get("symbol-placement") === "line" && (this.features = (function(ie) {
              const ue = {},
                Ne = {},
                ye = [];
              let Ce = 0;

              function tt(Wt) {
                ye.push(ie[Wt]), Ce++
              }

              function dt(Wt, er, Fr) {
                const Qt = Ne[Wt];
                return delete Ne[Wt], Ne[er] = Qt, ye[Qt].geometry[0].pop(), ye[Qt].geometry[0] = ye[Qt].geometry[0].concat(Fr[0]), Qt
              }

              function Rt(Wt, er, Fr) {
                const Qt = ue[er];
                return delete ue[er], ue[Wt] = Qt, ye[Qt].geometry[0].shift(), ye[Qt].geometry[0] = Fr[0].concat(ye[Qt].geometry[0]), Qt
              }

              function ir(Wt, er, Fr) {
                const Qt = Fr ? er[0][er[0].length - 1] : er[0][0];
                return `${Wt}:${Qt.x}:${Qt.y}`
              }
              for (let Wt = 0; Wt < ie.length; Wt++) {
                const er = ie[Wt],
                  Fr = er.geometry,
                  Qt = er.text ? er.text.toString() : null;
                if (!Qt) {
                  tt(Wt);
                  continue
                }
                const tr = ir(Qt, Fr),
                  St = ir(Qt, Fr, !0);
                if (tr in Ne && St in ue && Ne[tr] !== ue[St]) {
                  const $r = Rt(tr, St, Fr),
                    Kr = dt(tr, St, ye[$r].geometry);
                  delete ue[tr], delete Ne[St], Ne[ir(Qt, ye[Kr].geometry, !0)] = Kr, ye[$r].geometry = null
                } else tr in Ne ? dt(tr, St, Fr) : St in ue ? Rt(tr, St, Fr) : (tt(Wt), ue[tr] = Ce - 1, Ne[St] = Ce - 1)
              }
              return ye.filter((Wt => Wt.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((ie, ue) => ie.sortKey - ue.sortKey))
          }
          update(t, r, a) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: a
            }), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: a
            }))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, r) {
            const a = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let c = t.dist(r[t.segment + 1]),
                p = t.dist(r[t.segment]);
              const m = {};
              for (let v = t.segment + 1; v < r.length; v++) m[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: c
              }, v < r.length - 1 && (c += r[v + 1].dist(r[v]));
              for (let v = t.segment || 0; v >= 0; v--) m[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: p
              }, v > 0 && (p += r[v - 1].dist(r[v]));
              for (let v = 0; v < r.length; v++) {
                const b = m[v];
                this.lineVertexArray.emplaceBack(b.x, b.y, b.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: a,
              lineLength: this.lineVertexArray.length - a
            }
          }
          addSymbols(t, r, a, c, p, m, v, b, C, I, R, U) {
            const Z = t.indexArray,
              X = t.layoutVertexArray,
              Q = t.segments.prepareSegment(4 * r.length, X, Z, this.canOverlap ? m.sortKey : void 0),
              ie = this.glyphOffsetArray.length,
              ue = Q.vertexLength,
              Ne = this.allowVerticalPlacement && v === w.as.vertical ? Math.PI / 2 : 0,
              ye = m.text && m.text.sections;
            for (let Ce = 0; Ce < r.length; Ce++) {
              const {
                tl: tt,
                tr: dt,
                bl: Rt,
                br: ir,
                tex: Wt,
                pixelOffsetTL: er,
                pixelOffsetBR: Fr,
                minFontScaleX: Qt,
                minFontScaleY: tr,
                glyphOffset: St,
                isSDF: $r,
                sectionIndex: Kr
              } = r[Ce], jr = Q.vertexLength, Sr = St[1];
              sp(X, b.x, b.y, tt.x, Sr + tt.y, Wt.x, Wt.y, a, $r, er.x, er.y, Qt, tr), sp(X, b.x, b.y, dt.x, Sr + dt.y, Wt.x + Wt.w, Wt.y, a, $r, Fr.x, er.y, Qt, tr), sp(X, b.x, b.y, Rt.x, Sr + Rt.y, Wt.x, Wt.y + Wt.h, a, $r, er.x, Fr.y, Qt, tr), sp(X, b.x, b.y, ir.x, Sr + ir.y, Wt.x + Wt.w, Wt.y + Wt.h, a, $r, Fr.x, Fr.y, Qt, tr), Gf(t.dynamicLayoutVertexArray, b, Ne), Z.emplaceBack(jr, jr + 2, jr + 1), Z.emplaceBack(jr + 1, jr + 2, jr + 3), Q.vertexLength += 4, Q.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(St[0]), Ce !== r.length - 1 && Kr === r[Ce + 1].sectionIndex || t.programConfigurations.populatePaintArrays(X.length, m, m.index, {
                imagePositions: {},
                canonical: U,
                formattedSection: ye && ye[Kr]
              })
            }
            t.placedSymbolArray.emplaceBack(b.x, b.y, ie, this.glyphOffsetArray.length - ie, ue, C, I, b.segment, a ? a[0] : 0, a ? a[1] : 0, c[0], c[1], v, 0, !1, 0, R)
          }
          _addCollisionDebugVertex(t, r, a, c, p, m) {
            return r.emplaceBack(0, 0), t.emplaceBack(a.x, a.y, c, p, Math.round(m.x), Math.round(m.y))
          }
          addCollisionDebugVertices(t, r, a, c, p, m, v) {
            const b = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray),
              C = b.vertexLength,
              I = p.layoutVertexArray,
              R = p.collisionVertexArray,
              U = v.anchorX,
              Z = v.anchorY;
            this._addCollisionDebugVertex(I, R, m, U, Z, new B(t, r)), this._addCollisionDebugVertex(I, R, m, U, Z, new B(a, r)), this._addCollisionDebugVertex(I, R, m, U, Z, new B(a, c)), this._addCollisionDebugVertex(I, R, m, U, Z, new B(t, c)), b.vertexLength += 4;
            const X = p.indexArray;
            X.emplaceBack(C, C + 1), X.emplaceBack(C + 1, C + 2), X.emplaceBack(C + 2, C + 3), X.emplaceBack(C + 3, C), b.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, r, a, c) {
            for (let p = t; p < r; p++) {
              const m = this.collisionBoxArray.get(p);
              this.addCollisionDebugVertices(m.x1, m.y1, m.x2, m.y2, c ? this.textCollisionBox : this.iconCollisionBox, m.anchorPoint, a)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Hf(Gt, Pg.members, gr), this.iconCollisionBox = new Hf(Gt, Pg.members, gr);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, a, c, p, m, v, b, C) {
            const I = {};
            for (let R = r; R < a; R++) {
              const U = t.get(R);
              I.textBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, I.textFeatureIndex = U.featureIndex;
              break
            }
            for (let R = c; R < p; R++) {
              const U = t.get(R);
              I.verticalTextBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, I.verticalTextFeatureIndex = U.featureIndex;
              break
            }
            for (let R = m; R < v; R++) {
              const U = t.get(R);
              I.iconBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, I.iconFeatureIndex = U.featureIndex;
              break
            }
            for (let R = b; R < C; R++) {
              const U = t.get(R);
              I.verticalIconBox = {
                x1: U.x1,
                y1: U.y1,
                x2: U.x2,
                y2: U.y2,
                anchorPointX: U.anchorPointX,
                anchorPointY: U.anchorPointY
              }, I.verticalIconFeatureIndex = U.featureIndex;
              break
            }
            return I
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const a = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, r) {
            const a = t.placedSymbolArray.get(r),
              c = a.vertexStartIndex + 4 * a.numGlyphs;
            for (let p = a.vertexStartIndex; p < c; p += 4) t.indexArray.emplaceBack(p, p + 2, p + 1), t.indexArray.emplaceBack(p + 1, p + 2, p + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t),
              a = Math.cos(t),
              c = [],
              p = [],
              m = [];
            for (let v = 0; v < this.symbolInstances.length; ++v) {
              m.push(v);
              const b = this.symbolInstances.get(v);
              c.push(0 | Math.round(r * b.anchorX + a * b.anchorY)), p.push(b.featureIndex)
            }
            return m.sort(((v, b) => c[v] - c[b] || p[b] - p[v])), m
          }
          addToSortKeyRanges(t, r) {
            const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            a && a.sortKey === r ? a.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: r,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const a = this.symbolInstances.get(r);
                this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(((c, p, m) => {
                  c >= 0 && m.indexOf(c) === p && this.addIndicesForPlacedSymbol(this.text, c)
                })), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let jg, Vg;
        sr("SymbolBucket", fc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), fc.MAX_GLYPHS = 65535, fc.addDynamicAttributes = Gf;
        var Wf = {
          get paint() {
            return Vg = Vg || new Zi({
              "icon-opacity": new Ur(_e.paint_symbol["icon-opacity"]),
              "icon-color": new Ur(_e.paint_symbol["icon-color"]),
              "icon-halo-color": new Ur(_e.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new Ur(_e.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new Ur(_e.paint_symbol["icon-halo-blur"]),
              "icon-translate": new Ar(_e.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new Ar(_e.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new Ur(_e.paint_symbol["text-opacity"]),
              "text-color": new Ur(_e.paint_symbol["text-color"], {
                runtimeType: ar,
                getOverride: n => n.textColor,
                hasOverride: n => !!n.textColor
              }),
              "text-halo-color": new Ur(_e.paint_symbol["text-halo-color"]),
              "text-halo-width": new Ur(_e.paint_symbol["text-halo-width"]),
              "text-halo-blur": new Ur(_e.paint_symbol["text-halo-blur"]),
              "text-translate": new Ar(_e.paint_symbol["text-translate"]),
              "text-translate-anchor": new Ar(_e.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return jg = jg || new Zi({
              "symbol-placement": new Ar(_e.layout_symbol["symbol-placement"]),
              "symbol-spacing": new Ar(_e.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new Ar(_e.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new Ur(_e.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new Ar(_e.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new Ar(_e.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new Ar(_e.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new Ar(_e.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new Ar(_e.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new Ar(_e.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new Ur(_e.layout_symbol["icon-size"]),
              "icon-text-fit": new Ar(_e.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new Ar(_e.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new Ur(_e.layout_symbol["icon-image"]),
              "icon-rotate": new Ur(_e.layout_symbol["icon-rotate"]),
              "icon-padding": new Ur(_e.layout_symbol["icon-padding"]),
              "icon-keep-upright": new Ar(_e.layout_symbol["icon-keep-upright"]),
              "icon-offset": new Ur(_e.layout_symbol["icon-offset"]),
              "icon-anchor": new Ur(_e.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new Ar(_e.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new Ar(_e.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new Ar(_e.layout_symbol["text-rotation-alignment"]),
              "text-field": new Ur(_e.layout_symbol["text-field"]),
              "text-font": new Ur(_e.layout_symbol["text-font"]),
              "text-size": new Ur(_e.layout_symbol["text-size"]),
              "text-max-width": new Ur(_e.layout_symbol["text-max-width"]),
              "text-line-height": new Ar(_e.layout_symbol["text-line-height"]),
              "text-letter-spacing": new Ur(_e.layout_symbol["text-letter-spacing"]),
              "text-justify": new Ur(_e.layout_symbol["text-justify"]),
              "text-radial-offset": new Ur(_e.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new Ar(_e.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new Ur(_e.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new Ur(_e.layout_symbol["text-anchor"]),
              "text-max-angle": new Ar(_e.layout_symbol["text-max-angle"]),
              "text-writing-mode": new Ar(_e.layout_symbol["text-writing-mode"]),
              "text-rotate": new Ur(_e.layout_symbol["text-rotate"]),
              "text-padding": new Ar(_e.layout_symbol["text-padding"]),
              "text-keep-upright": new Ar(_e.layout_symbol["text-keep-upright"]),
              "text-transform": new Ur(_e.layout_symbol["text-transform"]),
              "text-offset": new Ur(_e.layout_symbol["text-offset"]),
              "text-allow-overlap": new Ar(_e.layout_symbol["text-allow-overlap"]),
              "text-overlap": new Ar(_e.layout_symbol["text-overlap"]),
              "text-ignore-placement": new Ar(_e.layout_symbol["text-ignore-placement"]),
              "text-optional": new Ar(_e.layout_symbol["text-optional"])
            })
          }
        };
        class qg {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : st, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        sr("FormatSectionOverride", qg, {
          omit: ["defaultValue"]
        });
        class lp extends Ia {
          constructor(t, r) {
            super(t, Wf, r)
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const a = this.layout.get("text-writing-mode");
              if (a) {
                const c = [];
                for (const p of a) c.indexOf(p) < 0 && c.push(p);
                this.layout._values["text-writing-mode"] = c
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, r, a, c) {
            const p = this.layout.get(t).evaluate(r, {}, a, c),
              m = this._unevaluatedLayout._values[t];
            return m.isDataDriven() || jl(m.value) || !p ? p : (function(v, b) {
              return b.replace(/{([^{}]+)}/g, ((C, I) => v && I in v ? String(v[I]) : ""))
            })(r.properties, p)
          }
          createBucket(t) {
            return new fc(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Wf.paint.overridableProperties) {
              if (!lp.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t),
                a = new qg(r),
                c = new nu(a, r.property.specification);
              let p = null;
              p = r.value.kind === "constant" || r.value.kind === "source" ? new Xs("source", c) : new iu("composite", c, r.value.zoomStops), this.paint._values[t] = new Pa(r.property, p, r.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, a) {
            return !(!this.layout || r.isDataDriven() || a.isDataDriven()) && lp.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, r) {
            const a = t.get("text-field"),
              c = Wf.paint.properties[r];
            let p = !1;
            const m = v => {
              for (const b of v)
                if (c.overrides && c.overrides.hasOverride(b)) return void(p = !0)
            };
            if (a.value.kind === "constant" && a.value.value instanceof Sn) m(a.value.value.sections);
            else if (a.value.kind === "source" || a.value.kind === "composite") {
              const v = C => {
                  p || (C instanceof la && Fn(C.value) === Ir ? m(C.value.sections) : C instanceof Al ? m(C.sections) : C.eachChild(v))
                },
                b = a.value;
              b._styleExpression && v(b._styleExpression.expression)
            }
            return p
          }
        }
        let Ug;
        var gx = {
          get paint() {
            return Ug = Ug || new Zi({
              "background-color": new Ar(_e.paint_background["background-color"]),
              "background-pattern": new Gd(_e.paint_background["background-pattern"]),
              "background-opacity": new Ar(_e.paint_background["background-opacity"])
            })
          }
        };
        class vx extends Ia {
          constructor(t, r) {
            super(t, gx, r)
          }
        }
        class yx extends Ia {
          constructor(t, r) {
            super(t, {}, r), this.onAdd = a => {
              this.implementation.onAdd && this.implementation.onAdd(a, a.painter.context.gl)
            }, this.onRemove = a => {
              this.implementation.onRemove && this.implementation.onRemove(a, a.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class xx {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const bx = {
            once: !0
          },
          Xf = 63710088e-1;
        class Ms {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new Ms(Ke(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const r = Math.PI / 180,
              a = this.lat * r,
              c = t.lat * r,
              p = Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.cos(c) * Math.cos((t.lng - this.lng) * r);
            return Xf * Math.acos(Math.min(p, 1))
          }
          static convert(t) {
            if (t instanceof Ms) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Ms(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Ms(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const Zg = 2 * Math.PI * Xf;

        function Gg(n) {
          return Zg * Math.cos(n * Math.PI / 180)
        }

        function $g(n) {
          return (180 + n) / 360
        }

        function Hg(n) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
        }

        function Wg(n, t) {
          return n / Gg(t)
        }

        function Xg(n) {
          return 360 * n - 180
        }

        function cp(n) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
        }

        function Yg(n, t) {
          return n * Gg(cp(t))
        }
        class qu {
          constructor(t, r, a = 0) {
            this.x = +t, this.y = +r, this.z = +a
          }
          static fromLngLat(t, r = 0) {
            const a = Ms.convert(t);
            return new qu($g(a.lng), Hg(a.lat), Wg(r, a.lat))
          }
          toLngLat() {
            return new Ms(Xg(this.x), cp(this.y))
          }
          toAltitude() {
            return Yg(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Zg * (t = cp(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function Kg(n, t, r) {
          var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [n * a - 2 * Math.PI * 6378137 / 2, t * a - 2 * Math.PI * 6378137 / 2]
        }
        class Yf {
          constructor(t, r, a) {
            if (!(function(c, p, m) {
                return !(c < 0 || c > 25 || m < 0 || m >= Math.pow(2, c) || p < 0 || p >= Math.pow(2, c))
              })(t, r, a)) throw new Error(`x=${r}, y=${a}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = a, this.key = mc(0, t, t, r, a)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, r, a) {
            const c = (m = this.y, v = this.z, b = Kg(256 * (p = this.x), 256 * (m = Math.pow(2, v) - m - 1), v), C = Kg(256 * (p + 1), 256 * (m + 1), v), b[0] + "," + b[1] + "," + C[0] + "," + C[1]);
            var p, m, v, b, C;
            const I = (function(R, U, Z) {
              let X, Q = "";
              for (let ie = R; ie > 0; ie--) X = 1 << ie - 1, Q += (U & X ? 1 : 0) + (Z & X ? 2 : 0);
              return Q
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, c)
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new B((t.x * r - this.x) * Ve, (t.y * r - this.y) * Ve)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class Jg {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = mc(t, r.z, r.z, r.x, r.y)
          }
        }
        class Aa {
          constructor(t, r, a, c, p) {
            if (this.terrainRttPosMatrix32f = null, t < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${a}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new Yf(a, +c, +p), this.key = mc(r, t, a, c, p)
          }
          clone() {
            return new Aa(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new Aa(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Aa(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r)
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const a = this.canonical.z - t;
            return t > this.canonical.z ? mc(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : mc(this.wrap * +r, t, t, this.canonical.x >> a, this.canonical.y >> a)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return !1;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const r = this.canonical.z - t.canonical.z;
            return !(r < 0) && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Aa(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1,
              a = 2 * this.canonical.x,
              c = 2 * this.canonical.y;
            return [new Aa(r, this.wrap, r, a, c), new Aa(r, this.wrap, r, a + 1, c), new Aa(r, this.wrap, r, a, c + 1), new Aa(r, this.wrap, r, a + 1, c + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new Aa(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new Aa(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new Jg(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new qu(t.x - this.wrap, t.y))
          }
        }

        function mc(n, t, r, a, c) {
          (n *= 2) < 0 && (n = -1 * n - 1);
          const p = 1 << r;
          return (p * p * n + p * c + a).toString(36) + r.toString(36) + t.toString(36)
        }

        function Uu(n, t) {
          return t ? n.properties[t] : n.id
        }
        sr("CanonicalTileID", Yf), sr("OverscaledTileID", Aa, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class cl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const r = new cl;
            return r.extend(t(new B(this.minX, this.minY))), r.extend(t(new B(this.maxX, this.minY))), r.extend(t(new B(this.minX, this.maxY))), r.extend(t(new B(this.maxX, this.maxY))), r
          }
          static fromPoints(t) {
            const r = new cl;
            for (const a of t) r.extend(a);
            return r
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class Qg {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const a = t[r];
              this._stringToNumber[a] = r, this._numberToString[r] = a
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class ev {
          constructor(t, r, a, c, p) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = a, t._y = c, this.properties = t.properties, this.id = p
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t
          }
        }
        class tv {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Uo(Ve, 16, 0), this.grid3D = new Uo(Ve, 16, 0), this.featureIndexArray = new se, this.promoteId = r
          }
          insert(t, r, a, c, p, m) {
            const v = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(a, c, p);
            const b = m ? this.grid3D : this.grid;
            for (let C = 0; C < r.length; C++) {
              const I = r[C],
                R = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let U = 0; U < I.length; U++) {
                const Z = I[U];
                R[0] = Math.min(R[0], Z.x), R[1] = Math.min(R[1], Z.y), R[2] = Math.max(R[2], Z.x), R[3] = Math.max(R[3], Z.y)
              }
              R[0] < Ve && R[1] < Ve && R[2] >= 0 && R[3] >= 0 && b.insert(v, R[0], R[1], R[2], R[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new gg(new jf(this.rawTileData)).layers, this.sourceLayerCoder = new Qg(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, r, a, c) {
            this.loadVTLayers();
            const p = t.params,
              m = Ve / t.tileSize / t.scale,
              v = Ys(p.filter, p.globalState),
              b = t.queryGeometry,
              C = t.queryPadding * m,
              I = cl.fromPoints(b),
              R = this.grid.query(I.minX - C, I.minY - C, I.maxX + C, I.maxY + C),
              U = cl.fromPoints(t.cameraQueryGeometry).expandBy(C),
              Z = this.grid3D.query(U.minX, U.minY, U.maxX, U.maxY, ((ie, ue, Ne, ye) => (function(Ce, tt, dt, Rt, ir) {
                for (const er of Ce)
                  if (tt <= er.x && dt <= er.y && Rt >= er.x && ir >= er.y) return !0;
                const Wt = [new B(tt, dt), new B(tt, ir), new B(Rt, ir), new B(Rt, dt)];
                if (Ce.length > 2) {
                  for (const er of Wt)
                    if (oc(Ce, er)) return !0
                }
                for (let er = 0; er < Ce.length - 1; er++)
                  if (Ky(Ce[er], Ce[er + 1], Wt)) return !0;
                return !1
              })(t.cameraQueryGeometry, ie - C, ue - C, Ne + C, ye + C)));
            for (const ie of Z) R.push(ie);
            R.sort(wx);
            const X = {};
            let Q;
            for (let ie = 0; ie < R.length; ie++) {
              const ue = R[ie];
              if (ue === Q) continue;
              Q = ue;
              const Ne = this.featureIndexArray.get(ue);
              let ye = null;
              this.loadMatchingFeature(X, Ne.bucketIndex, Ne.sourceLayerIndex, Ne.featureIndex, v, p.layers, p.availableImages, r, a, c, ((Ce, tt, dt) => (ye || (ye = so(Ce)), tt.queryIntersectsFeature({
                queryGeometry: b,
                feature: Ce,
                featureState: dt,
                geometry: ye,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: m,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return X
          }
          loadMatchingFeature(t, r, a, c, p, m, v, b, C, I, R) {
            const U = this.bucketLayerIDs[r];
            if (m && !U.some((ie => m.has(ie)))) return;
            const Z = this.sourceLayerCoder.decode(a),
              X = this.vtLayers[Z].feature(c);
            if (p.needGeometry) {
              const ie = So(X, !0);
              if (!p.filter(new Bn(this.tileID.overscaledZ), ie, this.tileID.canonical)) return
            } else if (!p.filter(new Bn(this.tileID.overscaledZ), X)) return;
            const Q = this.getId(X, Z);
            for (let ie = 0; ie < U.length; ie++) {
              const ue = U[ie];
              if (m && !m.has(ue)) continue;
              const Ne = b[ue];
              if (!Ne) continue;
              let ye = {};
              Q && I && (ye = I.getState(Ne.sourceLayer || "_geojsonTileLayer", Q));
              const Ce = ot({}, C[ue]);
              Ce.paint = rv(Ce.paint, Ne.paint, X, ye, v), Ce.layout = rv(Ce.layout, Ne.layout, X, ye, v);
              const tt = !R || R(X, Ne, ye);
              if (!tt) continue;
              const dt = new ev(X, this.z, this.x, this.y, Q);
              dt.layer = Ce;
              let Rt = t[ue];
              Rt === void 0 && (Rt = t[ue] = []), Rt.push({
                featureIndex: c,
                feature: dt,
                intersectionZ: tt
              })
            }
          }
          lookupSymbolFeatures(t, r, a, c, p, m, v, b) {
            const C = {};
            this.loadVTLayers();
            const I = Ys(p.filterSpec, p.globalState);
            for (const R of t) this.loadMatchingFeature(C, a, c, R, I, m, v, b, r);
            return C
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs)
              for (const a of r)
                if (t === a) return !0;
            return !1
          }
          getId(t, r) {
            var a;
            let c = t.id;
            return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof c == "boolean" && (c = Number(c)), c === void 0 && (!((a = t.properties) === null || a === void 0) && a.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))), c
          }
        }

        function rv(n, t, r, a, c) {
          return Ct(n, ((p, m) => {
            const v = t instanceof Zo ? t.get(m) : null;
            return v && v.evaluate ? v.evaluate(r, a, c) : v
          }))
        }

        function wx(n, t) {
          return t - n
        }

        function nv(n, t, r, a, c) {
          const p = [];
          for (let m = 0; m < n.length; m++) {
            const v = n[m];
            let b;
            for (let C = 0; C < v.length - 1; C++) {
              let I = v[C],
                R = v[C + 1];
              I.x < t && R.x < t || (I.x < t ? I = new B(t, I.y + (t - I.x) / (R.x - I.x) * (R.y - I.y))._round() : R.x < t && (R = new B(t, I.y + (t - I.x) / (R.x - I.x) * (R.y - I.y))._round()), I.y < r && R.y < r || (I.y < r ? I = new B(I.x + (r - I.y) / (R.y - I.y) * (R.x - I.x), r)._round() : R.y < r && (R = new B(I.x + (r - I.y) / (R.y - I.y) * (R.x - I.x), r)._round()), I.x >= a && R.x >= a || (I.x >= a ? I = new B(a, I.y + (a - I.x) / (R.x - I.x) * (R.y - I.y))._round() : R.x >= a && (R = new B(a, I.y + (a - I.x) / (R.x - I.x) * (R.y - I.y))._round()), I.y >= c && R.y >= c || (I.y >= c ? I = new B(I.x + (c - I.y) / (R.y - I.y) * (R.x - I.x), c)._round() : R.y >= c && (R = new B(I.x + (c - I.y) / (R.y - I.y) * (R.x - I.x), c)._round()), b && I.equals(b[b.length - 1]) || (b = [I], p.push(b)), b.push(R)))))
            }
          }
          return p
        }
        sr("FeatureIndex", tv, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class As extends B {
          constructor(t, r, a, c) {
            super(t, r), this.angle = a, c !== void 0 && (this.segment = c)
          }
          clone() {
            return new As(this.x, this.y, this.angle, this.segment)
          }
        }

        function iv(n, t, r, a, c) {
          if (t.segment === void 0 || r === 0) return !0;
          let p = t,
            m = t.segment + 1,
            v = 0;
          for (; v > -r / 2;) {
            if (m--, m < 0) return !1;
            v -= n[m].dist(p), p = n[m]
          }
          v += n[m].dist(n[m + 1]), m++;
          const b = [];
          let C = 0;
          for (; v < r / 2;) {
            const I = n[m],
              R = n[m + 1];
            if (!R) return !1;
            let U = n[m - 1].angleTo(I) - I.angleTo(R);
            for (U = Math.abs((U + 3 * Math.PI) % (2 * Math.PI) - Math.PI), b.push({
                distance: v,
                angleDelta: U
              }), C += U; v - b[0].distance > a;) C -= b.shift().angleDelta;
            if (C > c) return !1;
            m++, v += I.dist(R)
          }
          return !0
        }

        function av(n) {
          let t = 0;
          for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
          return t
        }

        function ov(n, t, r) {
          return n ? .6 * t * r : 0
        }

        function sv(n, t) {
          return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0)
        }

        function Tx(n, t, r, a, c, p) {
          const m = ov(r, c, p),
            v = sv(r, a) * p;
          let b = 0;
          const C = av(n) / 2;
          for (let I = 0; I < n.length - 1; I++) {
            const R = n[I],
              U = n[I + 1],
              Z = R.dist(U);
            if (b + Z > C) {
              const X = (C - b) / Z,
                Q = ya.number(R.x, U.x, X),
                ie = ya.number(R.y, U.y, X),
                ue = new As(Q, ie, U.angleTo(R), I);
              return ue._round(), !m || iv(n, ue, v, m, t) ? ue : void 0
            }
            b += Z
          }
        }

        function Sx(n, t, r, a, c, p, m, v, b) {
          const C = ov(a, p, m),
            I = sv(a, c),
            R = I * m,
            U = n[0].x === 0 || n[0].x === b || n[0].y === 0 || n[0].y === b;
          return t - R < t / 4 && (t = R + t / 4), lv(n, U ? t / 2 * v % t : (I / 2 + 2 * p) * m * v % t, t, C, r, R, U, !1, b)
        }

        function lv(n, t, r, a, c, p, m, v, b) {
          const C = p / 2,
            I = av(n);
          let R = 0,
            U = t - r,
            Z = [];
          for (let X = 0; X < n.length - 1; X++) {
            const Q = n[X],
              ie = n[X + 1],
              ue = Q.dist(ie),
              Ne = ie.angleTo(Q);
            for (; U + r < R + ue;) {
              U += r;
              const ye = (U - R) / ue,
                Ce = ya.number(Q.x, ie.x, ye),
                tt = ya.number(Q.y, ie.y, ye);
              if (Ce >= 0 && Ce < b && tt >= 0 && tt < b && U - C >= 0 && U + C <= I) {
                const dt = new As(Ce, tt, Ne, X);
                dt._round(), a && !iv(n, dt, p, a, c) || Z.push(dt)
              }
            }
            R += ue
          }
          return v || Z.length || m || (Z = lv(n, R / 2, r, a, c, p, m, !0, b)), Z
        }

        function cv(n, t, r, a) {
          const c = [],
            p = n.image,
            m = p.pixelRatio,
            v = p.paddedRect.w - 2,
            b = p.paddedRect.h - 2;
          let C = {
            x1: n.left,
            y1: n.top,
            x2: n.right,
            y2: n.bottom
          };
          const I = p.stretchX || [
              [0, v]
            ],
            R = p.stretchY || [
              [0, b]
            ],
            U = (St, $r) => St + $r[1] - $r[0],
            Z = I.reduce(U, 0),
            X = R.reduce(U, 0),
            Q = v - Z,
            ie = b - X;
          let ue = 0,
            Ne = Z,
            ye = 0,
            Ce = X,
            tt = 0,
            dt = Q,
            Rt = 0,
            ir = ie;
          if (p.content && a) {
            const St = p.content,
              $r = St[2] - St[0],
              Kr = St[3] - St[1];
            (p.textFitWidth || p.textFitHeight) && (C = Bg(n)), ue = up(I, 0, St[0]), ye = up(R, 0, St[1]), Ne = up(I, St[0], St[2]), Ce = up(R, St[1], St[3]), tt = St[0] - ue, Rt = St[1] - ye, dt = $r - Ne, ir = Kr - Ce
          }
          const Wt = C.x1,
            er = C.y1,
            Fr = C.x2 - Wt,
            Qt = C.y2 - er,
            tr = (St, $r, Kr, jr) => {
              const Sr = hp(St.stretch - ue, Ne, Fr, Wt),
                wn = dp(St.fixed - tt, dt, St.stretch, Z),
                ni = hp($r.stretch - ye, Ce, Qt, er),
                bi = dp($r.fixed - Rt, ir, $r.stretch, X),
                $i = hp(Kr.stretch - ue, Ne, Fr, Wt),
                ka = dp(Kr.fixed - tt, dt, Kr.stretch, Z),
                ha = hp(jr.stretch - ye, Ce, Qt, er),
                Fi = dp(jr.fixed - Rt, ir, jr.stretch, X),
                ei = new B(Sr, ni),
                Ei = new B($i, ni),
                Bi = new B($i, ha),
                Oi = new B(Sr, ha),
                ia = new B(wn / m, bi / m),
                Ea = new B(ka / m, Fi / m),
                zi = t * Math.PI / 180;
              if (zi) {
                const Li = Math.sin(zi),
                  Di = Math.cos(zi),
                  vi = [Di, -Li, Li, Di];
                ei._matMult(vi), Ei._matMult(vi), Oi._matMult(vi), Bi._matMult(vi)
              }
              const da = St.stretch + St.fixed,
                wi = $r.stretch + $r.fixed;
              return {
                tl: ei,
                tr: Ei,
                bl: Oi,
                br: Bi,
                tex: {
                  x: p.paddedRect.x + 1 + da,
                  y: p.paddedRect.y + 1 + wi,
                  w: Kr.stretch + Kr.fixed - da,
                  h: jr.stretch + jr.fixed - wi
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: ia,
                pixelOffsetBR: Ea,
                minFontScaleX: dt / m / Fr,
                minFontScaleY: ir / m / Qt,
                isSDF: r
              }
            };
          if (a && (p.stretchX || p.stretchY)) {
            const St = uv(I, Q, Z),
              $r = uv(R, ie, X);
            for (let Kr = 0; Kr < St.length - 1; Kr++) {
              const jr = St[Kr],
                Sr = St[Kr + 1];
              for (let wn = 0; wn < $r.length - 1; wn++) c.push(tr(jr, $r[wn], Sr, $r[wn + 1]))
            }
          } else c.push(tr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: v + 1
          }, {
            fixed: 0,
            stretch: b + 1
          }));
          return c
        }

        function up(n, t, r) {
          let a = 0;
          for (const c of n) a += Math.max(t, Math.min(r, c[1])) - Math.max(t, Math.min(r, c[0]));
          return a
        }

        function uv(n, t, r) {
          const a = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [c, p] of n) {
            const m = a[a.length - 1];
            a.push({
              fixed: c - m.stretch,
              stretch: m.stretch
            }), a.push({
              fixed: c - m.stretch,
              stretch: m.stretch + (p - c)
            })
          }
          return a.push({
            fixed: t + 1,
            stretch: r
          }), a
        }

        function hp(n, t, r, a) {
          return n / t * r + a
        }

        function dp(n, t, r, a) {
          return n - t * r / a
        }
        sr("Anchor", As);
        class pp {
          constructor(t, r, a, c, p, m, v, b, C, I) {
            var R;
            if (this.boxStartIndex = t.length, C) {
              let U = m.top,
                Z = m.bottom;
              const X = m.collisionPadding;
              X && (U -= X[1], Z += X[3]);
              let Q = Z - U;
              Q > 0 && (Q = Math.max(10, Q), this.circleDiameter = Q)
            } else {
              const U = !((R = m.image) === null || R === void 0) && R.content && (m.image.textFitWidth || m.image.textFitHeight) ? Bg(m) : {
                x1: m.left,
                y1: m.top,
                x2: m.right,
                y2: m.bottom
              };
              U.y1 = U.y1 * v - b[0], U.y2 = U.y2 * v + b[2], U.x1 = U.x1 * v - b[3], U.x2 = U.x2 * v + b[1];
              const Z = m.collisionPadding;
              if (Z && (U.x1 -= Z[0] * v, U.y1 -= Z[1] * v, U.x2 += Z[2] * v, U.y2 += Z[3] * v), I) {
                const X = new B(U.x1, U.y1),
                  Q = new B(U.x2, U.y1),
                  ie = new B(U.x1, U.y2),
                  ue = new B(U.x2, U.y2),
                  Ne = I * Math.PI / 180;
                X._rotate(Ne), Q._rotate(Ne), ie._rotate(Ne), ue._rotate(Ne), U.x1 = Math.min(X.x, Q.x, ie.x, ue.x), U.x2 = Math.max(X.x, Q.x, ie.x, ue.x), U.y1 = Math.min(X.y, Q.y, ie.y, ue.y), U.y2 = Math.max(X.y, Q.y, ie.y, ue.y)
              }
              t.emplaceBack(r.x, r.y, U.x1, U.y1, U.x2, U.y2, a, c, p)
            }
            this.boxEndIndex = t.length
          }
        }
        class Cx {
          constructor(t = [], r = (a, c) => a < c ? -1 : a > c ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: r,
              compare: a
            } = this, c = r[t];
            for (; t > 0;) {
              const p = t - 1 >> 1,
                m = r[p];
              if (a(c, m) >= 0) break;
              r[t] = m, t = p
            }
            r[t] = c
          }
          _down(t) {
            const {
              data: r,
              compare: a
            } = this, c = this.length >> 1, p = r[t];
            for (; t < c;) {
              let m = 1 + (t << 1);
              const v = m + 1;
              if (v < this.length && a(r[v], r[m]) < 0 && (m = v), a(r[m], p) >= 0) break;
              r[t] = r[m], t = m
            }
            r[t] = p
          }
        }

        function Px(n, t = 1, r = !1) {
          const a = cl.fromPoints(n[0]),
            c = Math.min(a.width(), a.height());
          let p = c / 2;
          const m = new Cx([], Ix),
            {
              minX: v,
              minY: b,
              maxX: C,
              maxY: I
            } = a;
          if (c === 0) return new B(v, b);
          for (let Z = v; Z < C; Z += c)
            for (let X = b; X < I; X += c) m.push(new _c(Z + p, X + p, p, n));
          let R = (function(Z) {
              let X = 0,
                Q = 0,
                ie = 0;
              const ue = Z[0];
              for (let Ne = 0, ye = ue.length, Ce = ye - 1; Ne < ye; Ce = Ne++) {
                const tt = ue[Ne],
                  dt = ue[Ce],
                  Rt = tt.x * dt.y - dt.x * tt.y;
                Q += (tt.x + dt.x) * Rt, ie += (tt.y + dt.y) * Rt, X += 3 * Rt
              }
              return new _c(Q / X, ie / X, 0, Z)
            })(n),
            U = m.length;
          for (; m.length;) {
            const Z = m.pop();
            (Z.d > R.d || !R.d) && (R = Z, r && console.log("found best %d after %d probes", Math.round(1e4 * Z.d) / 1e4, U)), Z.max - R.d <= t || (p = Z.h / 2, m.push(new _c(Z.p.x - p, Z.p.y - p, p, n)), m.push(new _c(Z.p.x + p, Z.p.y - p, p, n)), m.push(new _c(Z.p.x - p, Z.p.y + p, p, n)), m.push(new _c(Z.p.x + p, Z.p.y + p, p, n)), U += 4)
          }
          return r && (console.log(`num probes: ${U}`), console.log(`best distance: ${R.d}`)), R.p
        }

        function Ix(n, t) {
          return t.max - n.max
        }

        function _c(n, t, r, a) {
          this.p = new B(n, t), this.h = r, this.d = (function(c, p) {
            let m = !1,
              v = 1 / 0;
            for (let b = 0; b < p.length; b++) {
              const C = p[b];
              for (let I = 0, R = C.length, U = R - 1; I < R; U = I++) {
                const Z = C[I],
                  X = C[U];
                Z.y > c.y != X.y > c.y && c.x < (X.x - Z.x) * (c.y - Z.y) / (X.y - Z.y) + Z.x && (m = !m), v = Math.min(v, W_(c, Z, X))
              }
            }
            return (m ? 1 : -1) * Math.sqrt(v)
          })(this.p, a), this.max = this.d + this.h * Math.SQRT2
        }
        var Gi;
        w.aI = void 0, (Gi = w.aI || (w.aI = {}))[Gi.center = 1] = "center", Gi[Gi.left = 2] = "left", Gi[Gi.right = 3] = "right", Gi[Gi.top = 4] = "top", Gi[Gi.bottom = 5] = "bottom", Gi[Gi["top-left"] = 6] = "top-left", Gi[Gi["top-right"] = 7] = "top-right", Gi[Gi["bottom-left"] = 8] = "bottom-left", Gi[Gi["bottom-right"] = 9] = "bottom-right";
        const Kf = Number.POSITIVE_INFINITY;

        function hv(n, t) {
          return t[1] !== Kf ? (function(r, a, c) {
            let p = 0,
              m = 0;
            switch (a = Math.abs(a), c = Math.abs(c), r) {
              case "top-right":
              case "top-left":
              case "top":
                m = c - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                m = 7 - c
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                p = -a;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                p = a
            }
            return [p, m]
          })(n, t[0], t[1]) : (function(r, a) {
            let c = 0,
              p = 0;
            a < 0 && (a = 0);
            const m = a / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                p = m - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                p = 7 - m;
                break;
              case "bottom":
                p = 7 - a;
                break;
              case "top":
                p = a - 7
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                c = -m;
                break;
              case "top-left":
              case "bottom-left":
                c = m;
                break;
              case "left":
                c = a;
                break;
              case "right":
                c = -a
            }
            return [c, p]
          })(n, t[0])
        }

        function dv(n, t, r) {
          var a;
          const c = n.layout,
            p = (a = c.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(t, {}, r);
          if (p) {
            const v = p.values,
              b = [];
            for (let C = 0; C < v.length; C += 2) {
              const I = b[C] = v[C],
                R = v[C + 1].map((U => U * ki));
              I.startsWith("top") ? R[1] -= 7 : I.startsWith("bottom") && (R[1] += 7), b[C + 1] = R
            }
            return new In(b)
          }
          const m = c.get("text-variable-anchor");
          if (m) {
            let v;
            v = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, r) * ki, Kf] : c.get("text-offset").evaluate(t, {}, r).map((C => C * ki));
            const b = [];
            for (const C of m) b.push(C, hv(C, v));
            return new In(b)
          }
          return null
        }

        function Jf(n) {
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function Mx(n, t, r, a, c, p, m, v, b, C, I, R) {
          let U = p.textMaxSize.evaluate(t, {});
          U === void 0 && (U = m);
          const Z = n.layers[0].layout,
            X = Z.get("icon-offset").evaluate(t, {}, I),
            Q = fv(r.horizontal),
            ie = m / 24,
            ue = n.tilePixelRatio * ie,
            Ne = n.tilePixelRatio * U / 24,
            ye = n.tilePixelRatio * v,
            Ce = n.tilePixelRatio * Z.get("symbol-spacing"),
            tt = Z.get("text-padding") * n.tilePixelRatio,
            dt = (function(Kr, jr, Sr, wn = 1) {
              const ni = Kr.get("icon-padding").evaluate(jr, {}, Sr),
                bi = ni && ni.values;
              return [bi[0] * wn, bi[1] * wn, bi[2] * wn, bi[3] * wn]
            })(Z, t, I, n.tilePixelRatio),
            Rt = Z.get("text-max-angle") / 180 * Math.PI,
            ir = Z.get("text-rotation-alignment") !== "viewport" && Z.get("symbol-placement") !== "point",
            Wt = Z.get("icon-rotation-alignment") === "map" && Z.get("symbol-placement") !== "point",
            er = Z.get("symbol-placement"),
            Fr = Ce / 2,
            Qt = Z.get("icon-text-fit");
          let tr;
          a && Qt !== "none" && (n.allowVerticalPlacement && r.vertical && (tr = Og(a, r.vertical, Qt, Z.get("icon-text-fit-padding"), X, ie)), Q && (a = Og(a, Q, Qt, Z.get("icon-text-fit-padding"), X, ie)));
          const St = I ? R.line.getGranularityForZoomLevel(I.z) : 1,
            $r = (Kr, jr) => {
              jr.x < 0 || jr.x >= Ve || jr.y < 0 || jr.y >= Ve || (function(Sr, wn, ni, bi, $i, ka, ha, Fi, ei, Ei, Bi, Oi, ia, Ea, zi, da, wi, Li, Di, vi, Hn, lo, gc, co, Ex) {
                const vc = Sr.addToLineVertexArray(wn, ni);
                let ul, yc, xc, bc, vv = 0,
                  yv = 0,
                  xv = 0,
                  bv = 0,
                  om = -1,
                  sm = -1;
                const es = {};
                let wv = ao("");
                if (Sr.allowVerticalPlacement && bi.vertical) {
                  const Qi = Fi.layout.get("text-rotate").evaluate(Hn, {}, co) + 90;
                  xc = new pp(ei, wn, Ei, Bi, Oi, bi.vertical, ia, Ea, zi, Qi), ha && (bc = new pp(ei, wn, Ei, Bi, Oi, ha, wi, Li, zi, Qi))
                }
                if ($i) {
                  const Qi = Fi.layout.get("icon-rotate").evaluate(Hn, {}),
                    za = Fi.layout.get("icon-text-fit") !== "none",
                    hl = cv($i, Qi, gc, za),
                    ho = ha ? cv(ha, Qi, gc, za) : void 0;
                  yc = new pp(ei, wn, Ei, Bi, Oi, $i, wi, Li, !1, Qi), vv = 4 * hl.length;
                  const dl = Sr.iconSizeData;
                  let Co = null;
                  dl.kind === "source" ? (Co = [Qo * Fi.layout.get("icon-size").evaluate(Hn, {})], Co[0] > Is && Nt(`${Sr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : dl.kind === "composite" && (Co = [Qo * lo.compositeIconSizes[0].evaluate(Hn, {}, co), Qo * lo.compositeIconSizes[1].evaluate(Hn, {}, co)], (Co[0] > Is || Co[1] > Is) && Nt(`${Sr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Sr.addSymbols(Sr.icon, hl, Co, vi, Di, Hn, w.as.none, wn, vc.lineStartIndex, vc.lineLength, -1, co), om = Sr.icon.placedSymbolArray.length - 1, ho && (yv = 4 * ho.length, Sr.addSymbols(Sr.icon, ho, Co, vi, Di, Hn, w.as.vertical, wn, vc.lineStartIndex, vc.lineLength, -1, co), sm = Sr.icon.placedSymbolArray.length - 1)
                }
                const Tv = Object.keys(bi.horizontal);
                for (const Qi of Tv) {
                  const za = bi.horizontal[Qi];
                  if (!ul) {
                    wv = ao(za.text);
                    const ho = Fi.layout.get("text-rotate").evaluate(Hn, {}, co);
                    ul = new pp(ei, wn, Ei, Bi, Oi, za, ia, Ea, zi, ho)
                  }
                  const hl = za.positionedLines.length === 1;
                  if (xv += pv(Sr, wn, za, ka, Fi, zi, Hn, da, vc, bi.vertical ? w.as.horizontal : w.as.horizontalOnly, hl ? Tv : [Qi], es, om, lo, co), hl) break
                }
                bi.vertical && (bv += pv(Sr, wn, bi.vertical, ka, Fi, zi, Hn, da, vc, w.as.vertical, ["vertical"], es, sm, lo, co));
                const zx = ul ? ul.boxStartIndex : Sr.collisionBoxArray.length,
                  Lx = ul ? ul.boxEndIndex : Sr.collisionBoxArray.length,
                  Dx = xc ? xc.boxStartIndex : Sr.collisionBoxArray.length,
                  Rx = xc ? xc.boxEndIndex : Sr.collisionBoxArray.length,
                  Fx = yc ? yc.boxStartIndex : Sr.collisionBoxArray.length,
                  Bx = yc ? yc.boxEndIndex : Sr.collisionBoxArray.length,
                  Ox = bc ? bc.boxStartIndex : Sr.collisionBoxArray.length,
                  Nx = bc ? bc.boxEndIndex : Sr.collisionBoxArray.length;
                let uo = -1;
                const mp = (Qi, za) => Qi && Qi.circleDiameter ? Math.max(Qi.circleDiameter, za) : za;
                uo = mp(ul, uo), uo = mp(xc, uo), uo = mp(yc, uo), uo = mp(bc, uo);
                const Sv = uo > -1 ? 1 : 0;
                Sv && (uo *= Ex / ki), Sr.glyphOffsetArray.length >= fc.MAX_GLYPHS && Nt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Hn.sortKey !== void 0 && Sr.addToSortKeyRanges(Sr.symbolInstances.length, Hn.sortKey);
                const jx = dv(Fi, Hn, co),
                  [Vx, qx] = (function(Qi, za) {
                    const hl = Qi.length,
                      ho = za == null ? void 0 : za.values;
                    if ((ho == null ? void 0 : ho.length) > 0)
                      for (let dl = 0; dl < ho.length; dl += 2) {
                        const Co = ho[dl + 1];
                        Qi.emplaceBack(w.aI[ho[dl]], Co[0], Co[1])
                      }
                    return [hl, Qi.length]
                  })(Sr.textAnchorOffsets, jx);
                Sr.symbolInstances.emplaceBack(wn.x, wn.y, es.right >= 0 ? es.right : -1, es.center >= 0 ? es.center : -1, es.left >= 0 ? es.left : -1, es.vertical || -1, om, sm, wv, zx, Lx, Dx, Rx, Fx, Bx, Ox, Nx, Ei, xv, bv, vv, yv, Sv, 0, ia, uo, Vx, qx)
              })(n, jr, Kr, r, a, c, tr, n.layers[0], n.collisionBoxArray, t.index, t.sourceLayerIndex, n.index, ue, [tt, tt, tt, tt], ir, b, ye, dt, Wt, X, t, p, C, I, m)
            };
          if (er === "line")
            for (const Kr of nv(t.geometry, 0, 0, Ve, Ve)) {
              const jr = ll(Kr, St),
                Sr = Sx(jr, Ce, Rt, r.vertical || Q, a, 24, Ne, n.overscaling, Ve);
              for (const wn of Sr) Q && Ax(n, Q.text, Fr, wn) || $r(jr, wn)
            } else if (er === "line-center") {
              for (const Kr of t.geometry)
                if (Kr.length > 1) {
                  const jr = ll(Kr, St),
                    Sr = Tx(jr, Rt, r.vertical || Q, a, 24, Ne);
                  Sr && $r(jr, Sr)
                }
            } else if (t.type === "Polygon")
            for (const Kr of kl(t.geometry, 0)) {
              const jr = Px(Kr, 16);
              $r(ll(Kr[0], St, !0), new As(jr.x, jr.y, 0))
            } else if (t.type === "LineString")
              for (const Kr of t.geometry) {
                const jr = ll(Kr, St);
                $r(jr, new As(jr[0].x, jr[0].y, 0))
              } else if (t.type === "Point")
                for (const Kr of t.geometry)
                  for (const jr of Kr) $r([jr], new As(jr.x, jr.y, 0))
        }

        function pv(n, t, r, a, c, p, m, v, b, C, I, R, U, Z, X) {
          const Q = (function(Ne, ye, Ce, tt, dt, Rt, ir, Wt) {
              const er = tt.layout.get("text-rotate").evaluate(Rt, {}) * Math.PI / 180,
                Fr = [];
              for (const Qt of ye.positionedLines)
                for (const tr of Qt.positionedGlyphs) {
                  if (!tr.rect) continue;
                  const St = tr.rect || {};
                  let $r = 4,
                    Kr = !0,
                    jr = 1,
                    Sr = 0;
                  const wn = (dt || Wt) && tr.vertical,
                    ni = tr.metrics.advance * tr.scale / 2;
                  if (Wt && ye.verticalizable && (Sr = Qt.lineOffset / 2 - (tr.imageName ? -(ki - tr.metrics.width * tr.scale) / 2 : (tr.scale - 1) * ki)), tr.imageName) {
                    const Li = ir[tr.imageName];
                    Kr = Li.sdf, jr = Li.pixelRatio, $r = 1 / jr
                  }
                  const bi = dt ? [tr.x + ni, tr.y] : [0, 0];
                  let $i = dt ? [0, 0] : [tr.x + ni + Ce[0], tr.y + Ce[1] - Sr],
                    ka = [0, 0];
                  wn && (ka = $i, $i = [0, 0]);
                  const ha = tr.metrics.isDoubleResolution ? 2 : 1,
                    Fi = (tr.metrics.left - $r) * tr.scale - ni + $i[0],
                    ei = (-tr.metrics.top - $r) * tr.scale + $i[1],
                    Ei = Fi + St.w / ha * tr.scale / jr,
                    Bi = ei + St.h / ha * tr.scale / jr,
                    Oi = new B(Fi, ei),
                    ia = new B(Ei, ei),
                    Ea = new B(Fi, Bi),
                    zi = new B(Ei, Bi);
                  if (wn) {
                    const Li = new B(-ni, ni - -17),
                      Di = -Math.PI / 2,
                      vi = 12 - ni,
                      Hn = new B(22 - vi, -(tr.imageName ? vi : 0)),
                      lo = new B(...ka);
                    Oi._rotateAround(Di, Li)._add(Hn)._add(lo), ia._rotateAround(Di, Li)._add(Hn)._add(lo), Ea._rotateAround(Di, Li)._add(Hn)._add(lo), zi._rotateAround(Di, Li)._add(Hn)._add(lo)
                  }
                  if (er) {
                    const Li = Math.sin(er),
                      Di = Math.cos(er),
                      vi = [Di, -Li, Li, Di];
                    Oi._matMult(vi), ia._matMult(vi), Ea._matMult(vi), zi._matMult(vi)
                  }
                  const da = new B(0, 0),
                    wi = new B(0, 0);
                  Fr.push({
                    tl: Oi,
                    tr: ia,
                    bl: Ea,
                    br: zi,
                    tex: St,
                    writingMode: ye.writingMode,
                    glyphOffset: bi,
                    sectionIndex: tr.sectionIndex,
                    isSDF: Kr,
                    pixelOffsetTL: da,
                    pixelOffsetBR: wi,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return Fr
            })(0, r, v, c, p, m, a, n.allowVerticalPlacement),
            ie = n.textSizeData;
          let ue = null;
          ie.kind === "source" ? (ue = [Qo * c.layout.get("text-size").evaluate(m, {})], ue[0] > Is && Nt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ie.kind === "composite" && (ue = [Qo * Z.compositeTextSizes[0].evaluate(m, {}, X), Qo * Z.compositeTextSizes[1].evaluate(m, {}, X)], (ue[0] > Is || ue[1] > Is) && Nt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), n.addSymbols(n.text, Q, ue, v, p, m, C, t, b.lineStartIndex, b.lineLength, U, X);
          for (const Ne of I) R[Ne] = n.text.placedSymbolArray.length - 1;
          return 4 * Q.length
        }

        function fv(n) {
          for (const t in n) return n[t];
          return null
        }

        function Ax(n, t, r, a) {
          const c = n.compareText;
          if (t in c) {
            const p = c[t];
            for (let m = p.length - 1; m >= 0; m--)
              if (a.dist(p[m]) < r) return !0
          } else c[t] = [];
          return c[t].push(a), !1
        }
        const mv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Qf {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, a] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = a >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const p = mv[15 & a];
            if (!p) throw new Error("Unrecognized array type.");
            const [m] = new Uint16Array(t, 2, 1), [v] = new Uint32Array(t, 4, 1);
            return new Qf(v, m, p, t)
          }
          constructor(t, r = 64, a = Float64Array, c) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = a, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const p = mv.indexOf(this.ArrayType),
              m = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              v = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              b = (8 - v % 8) % 8;
            if (p < 0) throw new Error(`Unexpected typed array class: ${a}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + b, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + v + b), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + b, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, r) {
            const a = this._pos >> 1;
            return this.ids[a] = a, this.coords[this._pos++] = t, this.coords[this._pos++] = r, a
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return em(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, r, a, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: p,
              coords: m,
              nodeSize: v
            } = this, b = [0, p.length - 1, 0], C = [];
            for (; b.length;) {
              const I = b.pop() || 0,
                R = b.pop() || 0,
                U = b.pop() || 0;
              if (R - U <= v) {
                for (let ie = U; ie <= R; ie++) {
                  const ue = m[2 * ie],
                    Ne = m[2 * ie + 1];
                  ue >= t && ue <= a && Ne >= r && Ne <= c && C.push(p[ie])
                }
                continue
              }
              const Z = U + R >> 1,
                X = m[2 * Z],
                Q = m[2 * Z + 1];
              X >= t && X <= a && Q >= r && Q <= c && C.push(p[Z]), (I === 0 ? t <= X : r <= Q) && (b.push(U), b.push(Z - 1), b.push(1 - I)), (I === 0 ? a >= X : c >= Q) && (b.push(Z + 1), b.push(R), b.push(1 - I))
            }
            return C
          }
          within(t, r, a) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: c,
              coords: p,
              nodeSize: m
            } = this, v = [0, c.length - 1, 0], b = [], C = a * a;
            for (; v.length;) {
              const I = v.pop() || 0,
                R = v.pop() || 0,
                U = v.pop() || 0;
              if (R - U <= m) {
                for (let ie = U; ie <= R; ie++) gv(p[2 * ie], p[2 * ie + 1], t, r) <= C && b.push(c[ie]);
                continue
              }
              const Z = U + R >> 1,
                X = p[2 * Z],
                Q = p[2 * Z + 1];
              gv(X, Q, t, r) <= C && b.push(c[Z]), (I === 0 ? t - a <= X : r - a <= Q) && (v.push(U), v.push(Z - 1), v.push(1 - I)), (I === 0 ? t + a >= X : r + a >= Q) && (v.push(Z + 1), v.push(R), v.push(1 - I))
            }
            return b
          }
        }

        function em(n, t, r, a, c, p) {
          if (c - a <= r) return;
          const m = a + c >> 1;
          _v(n, t, m, a, c, p), em(n, t, r, a, m - 1, 1 - p), em(n, t, r, m + 1, c, 1 - p)
        }

        function _v(n, t, r, a, c, p) {
          for (; c > a;) {
            if (c - a > 600) {
              const C = c - a + 1,
                I = r - a + 1,
                R = Math.log(C),
                U = .5 * Math.exp(2 * R / 3),
                Z = .5 * Math.sqrt(R * U * (C - U) / C) * (I - C / 2 < 0 ? -1 : 1);
              _v(n, t, r, Math.max(a, Math.floor(r - I * U / C + Z)), Math.min(c, Math.floor(r + (C - I) * U / C + Z)), p)
            }
            const m = t[2 * r + p];
            let v = a,
              b = c;
            for (Zu(n, t, a, r), t[2 * c + p] > m && Zu(n, t, a, c); v < b;) {
              for (Zu(n, t, v, b), v++, b--; t[2 * v + p] < m;) v++;
              for (; t[2 * b + p] > m;) b--
            }
            t[2 * a + p] === m ? Zu(n, t, a, b) : (b++, Zu(n, t, b, c)), b <= r && (a = b + 1), r <= b && (c = b - 1)
          }
        }

        function Zu(n, t, r, a) {
          tm(n, r, a), tm(t, 2 * r, 2 * a), tm(t, 2 * r + 1, 2 * a + 1)
        }

        function tm(n, t, r) {
          const a = n[t];
          n[t] = n[r], n[r] = a
        }

        function gv(n, t, r, a) {
          const c = n - r,
            p = t - a;
          return c * c + p * p
        }
        var rm;
        w.cA = void 0, (rm = w.cA || (w.cA = {})).create = "create", rm.load = "load", rm.fullLoad = "fullLoad";
        let fp = null,
          Gu = [];
        const nm = 1e3 / 60,
          im = "loadTime",
          am = "fullLoadTime",
          kx = {
            mark(n) {
              performance.mark(n)
            },
            frame(n) {
              const t = n;
              fp != null && Gu.push(t - fp), fp = t
            },
            clearMetrics() {
              fp = null, Gu = [], performance.clearMeasures(im), performance.clearMeasures(am);
              for (const n in w.cA) performance.clearMarks(w.cA[n])
            },
            getPerformanceMetrics() {
              performance.measure(im, w.cA.create, w.cA.load), performance.measure(am, w.cA.create, w.cA.fullLoad);
              const n = performance.getEntriesByName(im)[0].duration,
                t = performance.getEntriesByName(am)[0].duration,
                r = Gu.length,
                a = 1 / (Gu.reduce(((p, m) => p + m), 0) / r / 1e3),
                c = Gu.filter((p => p > nm)).reduce(((p, m) => p + (m - nm) / nm), 0);
              return {
                loadTime: n,
                fullLoadTime: t,
                fps: a,
                percentDroppedFrames: c / (r + c) * 100,
                totalFrames: r
              }
            }
          };
        w.$ = fr, w.A = Re, w.B = bs, w.C = function([n, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, {
            x: n * Math.cos(t) * Math.sin(r),
            y: n * Math.sin(t) * Math.sin(r),
            z: n * Math.cos(r)
          }
        }, w.D = Ar, w.E = Tt, w.F = ya, w.G = Bn, w.H = el, w.I = Vf, w.J = Ot, w.K = class {
          constructor(n, t) {
            this.target = n, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new xx((() => this.process())), this.subscription = rr(this.target, "message", (r => this.receive(r)), !1), this.globalScope = It(self) ? n : window
          }
          registerMessageHandler(n, t) {
            this.messageHandlers[n] = t
          }
          sendAsync(n, t) {
            return new Promise(((r, a) => {
              const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                p = t ? rr(t.signal, "abort", (() => {
                  p == null || p.unsubscribe(), delete this.resolveRejects[c];
                  const b = {
                    id: c,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: n.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(b)
                }), bx) : null;
              this.resolveRejects[c] = {
                resolve: b => {
                  p == null || p.unsubscribe(), r(b)
                },
                reject: b => {
                  p == null || p.unsubscribe(), a(b)
                }
              };
              const m = [],
                v = Object.assign(Object.assign({}, n), {
                  id: c,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: ro(n.data, m)
                });
              this.target.postMessage(v, {
                transfer: m
              })
            }))
          }
          receive(n) {
            const t = n.data,
              r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const a = this.abortControllers[r];
                return delete this.abortControllers[r], void(a && a.abort())
              }
              if (It(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const n = this.taskQueue.shift(),
              t = this.tasks[n];
            delete this.tasks[n], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(n, t)
          }
          processTask(n, t) {
            return s(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const c = this.resolveRejects[n];
                return delete this.resolveRejects[n], c ? void(t.error ? c.reject(tl(t.error)) : c.resolve(tl(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(n, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = tl(t.data),
                a = new AbortController;
              this.abortControllers[n] = a;
              try {
                const c = yield this.messageHandlers[t.type](t.sourceMapId, r, a);
                this.completeTask(n, null, c)
              } catch (c) {
                this.completeTask(n, c)
              }
            }))
          }
          completeTask(n, t, r) {
            const a = [];
            delete this.abortControllers[n];
            const c = {
              id: n,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? ro(t) : null,
              data: ro(r, a)
            };
            this.target.postMessage(c, {
              transfer: a
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, w.L = N, w.M = function() {
          var n = new Re(16);
          return Re != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n
        }, w.N = function(n, t, r) {
          var a, c, p, m, v, b, C, I, R, U, Z, X, Q = r[0],
            ie = r[1],
            ue = r[2];
          return t === n ? (n[12] = t[0] * Q + t[4] * ie + t[8] * ue + t[12], n[13] = t[1] * Q + t[5] * ie + t[9] * ue + t[13], n[14] = t[2] * Q + t[6] * ie + t[10] * ue + t[14], n[15] = t[3] * Q + t[7] * ie + t[11] * ue + t[15]) : (c = t[1], p = t[2], m = t[3], v = t[4], b = t[5], C = t[6], I = t[7], R = t[8], U = t[9], Z = t[10], X = t[11], n[0] = a = t[0], n[1] = c, n[2] = p, n[3] = m, n[4] = v, n[5] = b, n[6] = C, n[7] = I, n[8] = R, n[9] = U, n[10] = Z, n[11] = X, n[12] = a * Q + v * ie + R * ue + t[12], n[13] = c * Q + b * ie + U * ue + t[13], n[14] = p * Q + C * ie + Z * ue + t[14], n[15] = m * Q + I * ie + X * ue + t[15]), n
        }, w.O = function(n, t, r) {
          var a = r[0],
            c = r[1],
            p = r[2];
          return n[0] = t[0] * a, n[1] = t[1] * a, n[2] = t[2] * a, n[3] = t[3] * a, n[4] = t[4] * c, n[5] = t[5] * c, n[6] = t[6] * c, n[7] = t[7] * c, n[8] = t[8] * p, n[9] = t[9] * p, n[10] = t[10] * p, n[11] = t[11] * p, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, w.P = B, w.Q = function(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            m = t[3],
            v = t[4],
            b = t[5],
            C = t[6],
            I = t[7],
            R = t[8],
            U = t[9],
            Z = t[10],
            X = t[11],
            Q = t[12],
            ie = t[13],
            ue = t[14],
            Ne = t[15],
            ye = r[0],
            Ce = r[1],
            tt = r[2],
            dt = r[3];
          return n[0] = ye * a + Ce * v + tt * R + dt * Q, n[1] = ye * c + Ce * b + tt * U + dt * ie, n[2] = ye * p + Ce * C + tt * Z + dt * ue, n[3] = ye * m + Ce * I + tt * X + dt * Ne, n[4] = (ye = r[4]) * a + (Ce = r[5]) * v + (tt = r[6]) * R + (dt = r[7]) * Q, n[5] = ye * c + Ce * b + tt * U + dt * ie, n[6] = ye * p + Ce * C + tt * Z + dt * ue, n[7] = ye * m + Ce * I + tt * X + dt * Ne, n[8] = (ye = r[8]) * a + (Ce = r[9]) * v + (tt = r[10]) * R + (dt = r[11]) * Q, n[9] = ye * c + Ce * b + tt * U + dt * ie, n[10] = ye * p + Ce * C + tt * Z + dt * ue, n[11] = ye * m + Ce * I + tt * X + dt * Ne, n[12] = (ye = r[12]) * a + (Ce = r[13]) * v + (tt = r[14]) * R + (dt = r[15]) * Q, n[13] = ye * c + Ce * b + tt * U + dt * ie, n[14] = ye * p + Ce * C + tt * Z + dt * ue, n[15] = ye * m + Ce * I + tt * X + dt * Ne, n
        }, w.R = ua, w.S = function(n, t) {
          const r = {};
          for (let a = 0; a < t.length; a++) {
            const c = t[a];
            c in n && (r[c] = n[c])
          }
          return r
        }, w.T = Ef, w.U = Ms, w.V = Ke, w.W = Hg, w.X = $g, w.Y = we, w.Z = Ie, w._ = s, w.a = E, w.a$ = function(n, t, r) {
          return n[0] = t[0] * r[0], n[1] = t[1] * r[1], n[2] = t[2] * r[2], n[3] = t[3] * r[3], n
        }, w.a0 = Aa, w.a1 = Xg, w.a2 = cp, w.a3 = Ve, w.a4 = function(n, t) {
          var r, a, c, p, m;
          if (!n) return t ?? {};
          if (!t) return n;
          let v = Object.assign({}, n);
          if (t.removeAll && (v = {
              removeAll: !0
            }), t.remove) {
            const b = new Set(t.remove);
            v.add && (v.add = v.add.filter((I => !b.has(I.id)))), v.update && (v.update = v.update.filter((I => !b.has(I.id))));
            const C = new Set(((r = n.add) !== null && r !== void 0 ? r : []).map((I => I.id)));
            t.remove = t.remove.filter((I => !C.has(I)))
          }
          if (t.remove) {
            const b = new Set(v.remove ? v.remove.concat(t.remove) : t.remove);
            v.remove = Array.from(b.values())
          }
          if (t.add) {
            const b = v.add ? v.add.concat(t.add) : t.add,
              C = new Map(b.map((I => [I.id, I])));
            v.add = Array.from(C.values())
          }
          if (t.update) {
            const b = new Map((a = v.update) === null || a === void 0 ? void 0 : a.map((C => [C.id, C])));
            for (const C of t.update) {
              const I = (c = b.get(C.id)) !== null && c !== void 0 ? c : {
                id: C.id
              };
              C.newGeometry && (I.newGeometry = C.newGeometry), C.addOrUpdateProperties && (I.addOrUpdateProperties = ((p = I.addOrUpdateProperties) !== null && p !== void 0 ? p : []).concat(C.addOrUpdateProperties)), C.removeProperties && (I.removeProperties = ((m = I.removeProperties) !== null && m !== void 0 ? m : []).concat(C.removeProperties)), C.removeAllProperties && (I.removeAllProperties = !0), b.set(C.id, I)
            }
            v.update = Array.from(b.values())
          }
          return v.remove && v.add && (v.remove = v.remove.filter((b => v.add.findIndex((C => C.id === b)) === -1))), v
        }, w.a5 = qu, w.a6 = cl, w.a7 = 25, w.a8 = Yf, w.a9 = n => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((r => {
            t.onloadstart = () => {
              r(t)
            };
            for (const a of n) {
              const c = window.document.createElement("source");
              ve(a) || (t.crossOrigin = "Anonymous"), c.src = a, t.appendChild(c)
            }
          }))
        }, w.aA = Je, w.aB = function(n, t, r, a) {
          const c = t.y - n.y,
            p = t.x - n.x,
            m = a.y - r.y,
            v = a.x - r.x,
            b = m * p - v * c;
          if (b === 0) return null;
          const C = (v * (n.y - r.y) - m * (n.x - r.x)) / b;
          return new B(n.x + C * p, n.y + C * c)
        }, w.aC = nv, w.aD = $_, w.aE = function(n) {
          let t = 1 / 0,
            r = 1 / 0,
            a = -1 / 0,
            c = -1 / 0;
          for (const p of n) t = Math.min(t, p.x), r = Math.min(r, p.y), a = Math.max(a, p.x), c = Math.max(c, p.y);
          return [t, r, a, c]
        }, w.aF = ki, w.aG = mt, w.aH = function(n, t, r, a, c = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const p = c ? a === "map" ? -n.bearingInRadians : 0 : a === "viewport" ? n.bearingInRadians : 0;
          if (p) {
            const m = Math.sin(p),
              v = Math.cos(p);
            r = [r[0] * v - r[1] * m, r[0] * m + r[1] * v]
          }
          return [c ? r[0] : mt(t, r[0], n.zoom), c ? r[1] : mt(t, r[1], n.zoom)]
        }, w.aJ = Zf, w.aK = Jf, w.aL = Uf, w.aM = Qf, w.aN = si, w.aO = np, w.aP = fe, w.aQ = on, w.aR = Pt, w.aS = nr, w.aT = Yg, w.aU = Le, w.aV = He, w.aW = function(n) {
          var t = new Re(3);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t
        }, w.aX = function(n, t, r) {
          return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], n
        }, w.aY = function(n, t) {
          var r = t[0],
            a = t[1],
            c = t[2],
            p = r * r + a * a + c * c;
          return p > 0 && (p = 1 / Math.sqrt(p)), n[0] = t[0] * p, n[1] = t[1] * p, n[2] = t[2] * p, n
        }, w.aZ = it, w.a_ = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]
        }, w.aa = ht, w.ab = function() {
          return xt++
        }, w.ac = T, w.ad = fc, w.ae = Ys, w.af = So, w.ag = ev, w.ah = function(n) {
          const t = {};
          if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, a, c, p) => {
              const m = c || p;
              return t[a] = !m || m.toLowerCase(), ""
            })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r
          }
          return t
        }, w.ai = Lt, w.aj = 85.051129, w.ak = hr, w.al = function(n) {
          return Math.pow(2, n)
        }, w.am = qe, w.an = Wg, w.ao = function(n) {
          return Math.log(n) / Math.LN2
        }, w.ap = function(n) {
          var t = n[0],
            r = n[1];
          return t * t + r * r
        }, w.aq = function(n) {
          if (!n.length) return new Set;
          const t = Math.max(...n.map((b => b.canonical.z)));
          let r = 1 / 0,
            a = -1 / 0,
            c = 1 / 0,
            p = -1 / 0;
          const m = [];
          for (const b of n) {
            const {
              x: C,
              y: I,
              z: R
            } = b.canonical, U = Math.pow(2, t - R), Z = C * U, X = I * U;
            m.push({
              id: b,
              x: Z,
              y: X
            }), Z < r && (r = Z), Z > a && (a = Z), X < c && (c = X), X > p && (p = X)
          }
          const v = new Set;
          for (const b of m) b.x !== r && b.x !== a && b.y !== c && b.y !== p || v.add(b.id);
          return v
        }, w.ar = function(n, t) {
          let r = 0,
            a = 0;
          if (n.kind === "constant") a = n.layoutSize;
          else if (n.kind !== "source") {
            const {
              interpolationType: c,
              minZoom: p,
              maxZoom: m
            } = n, v = c ? Lt(kn.interpolationFactor(c, t, p, m), 0, 1) : 0;
            n.kind === "camera" ? a = ya.number(n.minSize, n.maxSize, v) : r = v
          }
          return {
            uSizeT: r,
            uSize: a
          }
        }, w.at = function(n, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: a,
          upperSize: c
        }) {
          return n.kind === "source" ? a / Qo : n.kind === "composite" ? ya.number(a / Qo, c / Qo, r) : t
        }, w.au = function(n, t) {
          var r = t[0],
            a = t[1],
            c = t[2],
            p = t[3],
            m = t[4],
            v = t[5],
            b = t[6],
            C = t[7],
            I = t[8],
            R = t[9],
            U = t[10],
            Z = t[11],
            X = t[12],
            Q = t[13],
            ie = t[14],
            ue = t[15],
            Ne = r * v - a * m,
            ye = r * b - c * m,
            Ce = r * C - p * m,
            tt = a * b - c * v,
            dt = a * C - p * v,
            Rt = c * C - p * b,
            ir = I * Q - R * X,
            Wt = I * ie - U * X,
            er = I * ue - Z * X,
            Fr = R * ie - U * Q,
            Qt = R * ue - Z * Q,
            tr = U * ue - Z * ie,
            St = Ne * tr - ye * Qt + Ce * Fr + tt * er - dt * Wt + Rt * ir;
          return St ? (n[0] = (v * tr - b * Qt + C * Fr) * (St = 1 / St), n[1] = (c * Qt - a * tr - p * Fr) * St, n[2] = (Q * Rt - ie * dt + ue * tt) * St, n[3] = (U * dt - R * Rt - Z * tt) * St, n[4] = (b * er - m * tr - C * Wt) * St, n[5] = (r * tr - c * er + p * Wt) * St, n[6] = (ie * Ce - X * Rt - ue * ye) * St, n[7] = (I * Rt - U * Ce + Z * ye) * St, n[8] = (m * Qt - v * er + C * ir) * St, n[9] = (a * er - r * Qt - p * ir) * St, n[10] = (X * dt - Q * Ce + ue * Ne) * St, n[11] = (R * Ce - I * dt - Z * Ne) * St, n[12] = (v * Wt - m * Fr - b * ir) * St, n[13] = (r * Fr - a * Wt + c * ir) * St, n[14] = (Q * ye - X * tt - ie * Ne) * St, n[15] = (I * tt - R * ye + U * Ne) * St, n) : null
        }, w.av = Ue, w.aw = function(n) {
          var t = n[0],
            r = n[1];
          return Math.sqrt(t * t + r * r)
        }, w.ax = function(n) {
          return n[0] = 0, n[1] = 0, n
        }, w.ay = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n
        }, w.az = Gf, w.b = jt, w.b$ = function(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2];
          return n[0] = a * r[0] + c * r[3] + p * r[6], n[1] = a * r[1] + c * r[4] + p * r[7], n[2] = a * r[2] + c * r[5] + p * r[8], n
        }, w.b0 = Be, w.b1 = function(n, t, r) {
          const a = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return a === 0 ? null : (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / a
        }, w.b2 = Oe, w.b3 = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[3] = t[3] * r, n
        }, w.b4 = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3]
        }, w.b5 = Jg, w.b6 = mc, w.b7 = function(n, t, r, a, c) {
          var p = 1 / Math.tan(t / 2);
          if (n[0] = p / r, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = p, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, c != null && c !== 1 / 0) {
            var m = 1 / (a - c);
            n[10] = (c + a) * m, n[14] = 2 * c * a * m
          } else n[10] = -1, n[14] = -2 * a;
          return n
        }, w.b8 = function(n) {
          var t = new Re(16);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
        }, w.b9 = function(n, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[0],
            m = t[1],
            v = t[2],
            b = t[3],
            C = t[4],
            I = t[5],
            R = t[6],
            U = t[7];
          return t !== n && (n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = p * c + C * a, n[1] = m * c + I * a, n[2] = v * c + R * a, n[3] = b * c + U * a, n[4] = C * c - p * a, n[5] = I * c - m * a, n[6] = R * c - v * a, n[7] = U * c - b * a, n
        }, w.bA = function(n, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[0], p[1] = c[1] * Math.cos(a) - c[2] * Math.sin(a), p[2] = c[1] * Math.sin(a) + c[2] * Math.cos(a), n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n
        }, w.bB = function(n, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[2] * Math.sin(a) + c[0] * Math.cos(a), p[1] = c[1], p[2] = c[2] * Math.cos(a) - c[0] * Math.sin(a), n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n
        }, w.bC = function(n, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[0],
            m = t[1],
            v = t[2],
            b = t[3],
            C = t[8],
            I = t[9],
            R = t[10],
            U = t[11];
          return t !== n && (n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = p * c - C * a, n[1] = m * c - I * a, n[2] = v * c - R * a, n[3] = b * c - U * a, n[8] = p * a + C * c, n[9] = m * a + I * c, n[10] = v * a + R * c, n[11] = b * a + U * c, n
        }, w.bD = function(n, t) {
          const r = lt(n, 360),
            a = lt(t, 360),
            c = a - r,
            p = a > r ? c - 360 : c + 360;
          return Math.abs(c) < Math.abs(p) ? c : p
        }, w.bE = function(n) {
          return n[0] = 0, n[1] = 0, n[2] = 0, n
        }, w.bF = function(n, t, r, a) {
          const c = Math.sqrt(n * n + t * t),
            p = Math.sqrt(r * r + a * a);
          n /= c, t /= c, r /= p, a /= p;
          const m = Math.acos(n * r + t * a);
          return -t * r + n * a > 0 ? m : -m
        }, w.bG = function(n, t) {
          const r = lt(n, 2 * Math.PI),
            a = lt(t, 2 * Math.PI);
          return Math.min(Math.abs(r - a), Math.abs(r - a + 2 * Math.PI), Math.abs(r - a - 2 * Math.PI))
        }, w.bH = function() {
          const n = {},
            t = _e.$version;
          for (const r in _e.$root) {
            const a = _e.$root[r];
            if (a.required) {
              let c = null;
              c = r === "version" ? t : a.type === "array" ? [] : {}, c != null && (n[r] = c)
            }
          }
          return n
        }, w.bI = _u, w.bJ = W, w.bK = function n(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let a = 0; a < t.length; a++)
              if (!n(t[a], r[a])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
            for (const a in t)
              if (!n(t[a], r[a])) return !1;
            return !0
          }
          return t === r
        }, w.bL = function(n) {
          n = n.slice();
          const t = Object.create(null);
          for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
          for (let r = 0; r < n.length; r++) "ref" in n[r] && (n[r] = ur(n[r], t[n[r].ref]));
          return n
        }, w.bM = function(n, t) {
          if (n.type === "custom") return new yx(n, t);
          switch (n.type) {
            case "background":
              return new vx(n, t);
            case "circle":
              return new n1(n, t);
            case "color-relief":
              return new c1(n, t);
            case "fill":
              return new S1(n, t);
            case "fill-extrusion":
              return new R1(n, t);
            case "heatmap":
              return new a1(n, t);
            case "hillshade":
              return new s1(n, t);
            case "line":
              return new q1(n, t);
            case "raster":
              return new wf(n, t);
            case "symbol":
              return new lp(n, t)
          }
        }, w.bN = n => n.type === "raster", w.bO = kt, w.bP = function(n, t) {
          if (!n) return [{
            command: "setStyle",
            args: [t]
          }];
          let r = [];
          try {
            if (!Ft(n.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            Ft(n.center, t.center) || r.push({
              command: "setCenter",
              args: [t.center]
            }), Ft(n.state, t.state) || r.push({
              command: "setGlobalState",
              args: [t.state]
            }), Ft(n.centerAltitude, t.centerAltitude) || r.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), Ft(n.zoom, t.zoom) || r.push({
              command: "setZoom",
              args: [t.zoom]
            }), Ft(n.bearing, t.bearing) || r.push({
              command: "setBearing",
              args: [t.bearing]
            }), Ft(n.pitch, t.pitch) || r.push({
              command: "setPitch",
              args: [t.pitch]
            }), Ft(n.roll, t.roll) || r.push({
              command: "setRoll",
              args: [t.roll]
            }), Ft(n.sprite, t.sprite) || r.push({
              command: "setSprite",
              args: [t.sprite]
            }), Ft(n.glyphs, t.glyphs) || r.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), Ft(n.transition, t.transition) || r.push({
              command: "setTransition",
              args: [t.transition]
            }), Ft(n.light, t.light) || r.push({
              command: "setLight",
              args: [t.light]
            }), Ft(n.terrain, t.terrain) || r.push({
              command: "setTerrain",
              args: [t.terrain]
            }), Ft(n.sky, t.sky) || r.push({
              command: "setSky",
              args: [t.sky]
            }), Ft(n.projection, t.projection) || r.push({
              command: "setProjection",
              args: [t.projection]
            });
            const a = {},
              c = [];
            (function(m, v, b, C) {
              let I;
              for (I in v = v || {}, m = m || {}) Object.prototype.hasOwnProperty.call(m, I) && (Object.prototype.hasOwnProperty.call(v, I) || qr(I, b, C));
              for (I in v) Object.prototype.hasOwnProperty.call(v, I) && (Object.prototype.hasOwnProperty.call(m, I) ? Ft(m[I], v[I]) || (m[I].type === "geojson" && v[I].type === "geojson" && rn(m, v, I) ? or(b, {
                command: "setGeoJSONSourceData",
                args: [I, v[I].data]
              }) : Wr(I, v, b, C)) : Vr(I, v, b))
            })(n.sources, t.sources, c, a);
            const p = [];
            n.layers && n.layers.forEach((m => {
              "source" in m && a[m.source] ? r.push({
                command: "removeLayer",
                args: [m.id]
              }) : p.push(m)
            })), r = r.concat(c), (function(m, v, b) {
              v = v || [];
              const C = (m = m || []).map(cn),
                I = v.map(cn),
                R = m.reduce(an, {}),
                U = v.reduce(an, {}),
                Z = C.slice(),
                X = Object.create(null);
              let Q, ie, ue, Ne, ye;
              for (let Ce = 0, tt = 0; Ce < C.length; Ce++) Q = C[Ce], Object.prototype.hasOwnProperty.call(U, Q) ? tt++ : (or(b, {
                command: "removeLayer",
                args: [Q]
              }), Z.splice(Z.indexOf(Q, tt), 1));
              for (let Ce = 0, tt = 0; Ce < I.length; Ce++) Q = I[I.length - 1 - Ce], Z[Z.length - 1 - Ce] !== Q && (Object.prototype.hasOwnProperty.call(R, Q) ? (or(b, {
                command: "removeLayer",
                args: [Q]
              }), Z.splice(Z.lastIndexOf(Q, Z.length - tt), 1)) : tt++, Ne = Z[Z.length - Ce], or(b, {
                command: "addLayer",
                args: [U[Q], Ne]
              }), Z.splice(Z.length - Ce, 0, Q), X[Q] = !0);
              for (let Ce = 0; Ce < I.length; Ce++)
                if (Q = I[Ce], ie = R[Q], ue = U[Q], !X[Q] && !Ft(ie, ue))
                  if (Ft(ie.source, ue.source) && Ft(ie["source-layer"], ue["source-layer"]) && Ft(ie.type, ue.type)) {
                    for (ye in hn(ie.layout, ue.layout, b, Q, null, "setLayoutProperty"), hn(ie.paint, ue.paint, b, Q, null, "setPaintProperty"), Ft(ie.filter, ue.filter) || or(b, {
                        command: "setFilter",
                        args: [Q, ue.filter]
                      }), Ft(ie.minzoom, ue.minzoom) && Ft(ie.maxzoom, ue.maxzoom) || or(b, {
                        command: "setLayerZoomRange",
                        args: [Q, ue.minzoom, ue.maxzoom]
                      }), ie) Object.prototype.hasOwnProperty.call(ie, ye) && ye !== "layout" && ye !== "paint" && ye !== "filter" && ye !== "metadata" && ye !== "minzoom" && ye !== "maxzoom" && (ye.indexOf("paint.") === 0 ? hn(ie[ye], ue[ye], b, Q, ye.slice(6), "setPaintProperty") : Ft(ie[ye], ue[ye]) || or(b, {
                      command: "setLayerProperty",
                      args: [Q, ye, ue[ye]]
                    }));
                    for (ye in ue) Object.prototype.hasOwnProperty.call(ue, ye) && !Object.prototype.hasOwnProperty.call(ie, ye) && ye !== "layout" && ye !== "paint" && ye !== "filter" && ye !== "metadata" && ye !== "minzoom" && ye !== "maxzoom" && (ye.indexOf("paint.") === 0 ? hn(ie[ye], ue[ye], b, Q, ye.slice(6), "setPaintProperty") : Ft(ie[ye], ue[ye]) || or(b, {
                      command: "setLayerProperty",
                      args: [Q, ye, ue[ye]]
                    }))
                  } else or(b, {
                    command: "removeLayer",
                    args: [Q]
                  }), Ne = Z[Z.lastIndexOf(Q) + 1], or(b, {
                    command: "addLayer",
                    args: [ue, Ne]
                  })
            })(p, t.layers, r)
          } catch (a) {
            console.warn("Unable to compute style diff:", a), r = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return r
        }, w.bQ = function(n) {
          const t = [],
            r = n.id;
          return r === void 0 && t.push({
            message: `layers.${r}: missing required property "id"`
          }), n.render === void 0 && t.push({
            message: `layers.${r}: missing required method "render"`
          }), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, w.bR = Ct, w.bS = wt, w.bT = class extends na {
          constructor(n, t) {
            super(n, t), this.current = 0
          }
          set(n) {
            this.current !== n && (this.current = n, this.gl.uniform1i(this.location, n))
          }
        }, w.bU = wo, w.bV = class extends na {
          constructor(n, t) {
            super(n, t), this.current = ol
          }
          set(n) {
            if (n[12] !== this.current[12] || n[0] !== this.current[0]) return this.current = n, void this.gl.uniformMatrix4fv(this.location, !1, n);
            for (let t = 1; t < 16; t++)
              if (n[t] !== this.current[t]) {
                this.current = n, this.gl.uniformMatrix4fv(this.location, !1, n);
                break
              }
          }
        }, w.bW = oo, w.bX = class extends na {
          constructor(n, t) {
            super(n, t), this.current = [0, 0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n, this.gl.uniform3f(this.location, n[0], n[1], n[2]))
          }
        }, w.bY = class extends na {
          constructor(n, t) {
            super(n, t), this.current = [0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n, this.gl.uniform2f(this.location, n[0], n[1]))
          }
        }, w.bZ = ke, w.b_ = function(n, t) {
          var r = Math.sin(t),
            a = Math.cos(t);
          return n[0] = a, n[1] = r, n[2] = 0, n[3] = -r, n[4] = a, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n
        }, w.ba = function(n, t, r) {
          var a = Math.sin(r),
            c = Math.cos(r),
            p = t[4],
            m = t[5],
            v = t[6],
            b = t[7],
            C = t[8],
            I = t[9],
            R = t[10],
            U = t[11];
          return t !== n && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[4] = p * c + C * a, n[5] = m * c + I * a, n[6] = v * c + R * a, n[7] = b * c + U * a, n[8] = C * c - p * a, n[9] = I * c - m * a, n[10] = R * c - v * a, n[11] = U * c - b * a, n
        }, w.bb = function() {
          const n = new Float32Array(16);
          return qe(n), n
        }, w.bc = function() {
          const n = new Float64Array(16);
          return qe(n), n
        }, w.bd = function() {
          return new Float64Array(16)
        }, w.be = function(n, t, r) {
          const a = new Float64Array(4);
          return We(a, n, t - 90, r), a
        }, w.bf = function(n, t, r, a) {
          var c, p, m, v, b, C = t[0],
            I = t[1],
            R = t[2],
            U = t[3],
            Z = r[0],
            X = r[1],
            Q = r[2],
            ie = r[3];
          return (p = C * Z + I * X + R * Q + U * ie) < 0 && (p = -p, Z = -Z, X = -X, Q = -Q, ie = -ie), 1 - p > ze ? (c = Math.acos(p), m = Math.sin(c), v = Math.sin((1 - a) * c) / m, b = Math.sin(a * c) / m) : (v = 1 - a, b = a), n[0] = v * C + b * Z, n[1] = v * I + b * X, n[2] = v * R + b * Q, n[3] = v * U + b * ie, n
        }, w.bg = function(n) {
          const t = new Float64Array(9);
          var r, a, c, p, m, v, b, C, I, R, U, Z, X, Q, ie, ue, Ne, ye;
          R = (c = (a = n)[0]) * (b = c + c), U = (p = a[1]) * b, X = (m = a[2]) * b, Q = m * (C = p + p), ue = (v = a[3]) * b, Ne = v * C, ye = v * (I = m + m), (r = t)[0] = 1 - (Z = p * C) - (ie = m * I), r[3] = U - ye, r[6] = X + Ne, r[1] = U + ye, r[4] = 1 - R - ie, r[7] = Q - ue, r[2] = X - Ne, r[5] = Q + ue, r[8] = 1 - R - Z;
          const Ce = nr(-Math.asin(Lt(t[2], -1, 1)));
          let tt, dt;
          return Math.hypot(t[5], t[8]) < .001 ? (tt = 0, dt = -nr(Math.atan2(t[3], t[4]))) : (tt = nr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), dt = nr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: tt,
            pitch: Ce + 90,
            bearing: dt
          }
        }, w.bh = function(n, t) {
          return n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing
        }, w.bi = pr, w.bj = Ji, w.bk = uc, w.bl = Fu, w.bm = cc, w.bn = yt, w.bo = _t, w.bp = _i, w.bq = function(n, t, r, a, c) {
          return yt(a, c, Lt((n - t) / (r - t), 0, 1))
        }, w.br = lt, w.bs = function() {
          return new Float64Array(3)
        }, w.bt = function(n, t, r, a) {
          return n[0] = t[0] + r[0] * a, n[1] = t[1] + r[1] * a, n[2] = t[2] + r[2] * a, n
        }, w.bu = We, w.bv = function(n, t, r) {
          var a = r[0],
            c = r[1],
            p = r[2],
            m = r[3],
            v = t[0],
            b = t[1],
            C = t[2],
            I = c * C - p * b,
            R = p * v - a * C,
            U = a * b - c * v;
          return n[0] = v + m * (I += I) + c * (U += U) - p * (R += R), n[1] = b + m * R + p * I - a * U, n[2] = C + m * U + a * R - c * I, n
        }, w.bw = function(n, t, r) {
          const a = (c = [n[0], n[1], n[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((I = c[8]) * (m = c[4]) - (v = c[5]) * (C = c[7])) + c[1] * (-I * (p = c[3]) + v * (b = c[6])) + c[2] * (C * p - m * b);
          var c, p, m, v, b, C, I;
          if (a === 0) return null;
          const R = it([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
            U = it([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]),
            Z = it([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]),
            X = Le([], R, -n[3]);
          return He(X, X, Le([], U, -t[3])), He(X, X, Le([], Z, -r[3])), Le(X, X, 1 / a), X
        }, w.bx = Xf, w.by = function() {
          return new Float64Array(4)
        }, w.bz = function(n, t, r, a) {
          var c = [],
            p = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], p[0] = c[0] * Math.cos(a) - c[1] * Math.sin(a), p[1] = c[0] * Math.sin(a) + c[1] * Math.cos(a), p[2] = c[2], n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n
        }, w.c = O, w.c0 = function(n, t, r, a, c, p, m) {
          var v = 1 / (t - r),
            b = 1 / (a - c),
            C = 1 / (p - m);
          return n[0] = -2 * v, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * b, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * C, n[11] = 0, n[12] = (t + r) * v, n[13] = (c + a) * b, n[14] = (m + p) * C, n[15] = 1, n
        }, w.c1 = class extends na {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(4 * n.length);
              for (let r = 0; r < n.length; r++) t[4 * r] = n[r].r, t[4 * r + 1] = n[r].g, t[4 * r + 2] = n[r].b, t[4 * r + 3] = n[r].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, w.c2 = class extends na {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(n);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, w.c3 = class extends Ho {}, w.c4 = $1, w.c5 = class extends rc {}, w.c6 = kf, w.c7 = function(n) {
          return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
        }, w.c8 = rg, w.c9 = function(n, t, r) {
          var a = t[0],
            c = t[1],
            p = t[2],
            m = r[3] * a + r[7] * c + r[11] * p + r[15];
          return n[0] = (r[0] * a + r[4] * c + r[8] * p + r[12]) / (m = m || 1), n[1] = (r[1] * a + r[5] * c + r[9] * p + r[13]) / m, n[2] = (r[2] * a + r[6] * c + r[10] * p + r[14]) / m, n
        }, w.cB = function(n) {
          return n.message === Te
        }, w.cC = H, w.cD = function(n, t) {
          E.REGISTERED_PROTOCOLS[n] = t
        }, w.cE = function(n) {
          delete E.REGISTERED_PROTOCOLS[n]
        }, w.cF = function(n, t) {
          const r = {};
          for (let c = 0; c < n.length; c++) {
            const p = t && t[n[c].id] || Td(n[c]);
            t && (t[n[c].id] = p);
            let m = r[p];
            m || (m = r[p] = []), m.push(n[c])
          }
          const a = [];
          for (const c in r) a.push(r[c]);
          return a
        }, w.cG = sr, w.cH = Qg, w.cI = tv, w.cJ = Eg, w.cK = function(n) {
          n.bucket.createArrays(), n.bucket.tilePixelRatio = Ve / (512 * n.bucket.overscaling), n.bucket.compareText = {}, n.bucket.iconsNeedLinear = !1;
          const t = n.bucket.layers[0],
            r = t.layout,
            a = t._unevaluatedLayout._values,
            c = {
              layoutIconSize: a["icon-size"].possiblyEvaluate(new Bn(n.bucket.zoom + 1), n.canonical),
              layoutTextSize: a["text-size"].possiblyEvaluate(new Bn(n.bucket.zoom + 1), n.canonical),
              textMaxSize: a["text-size"].possiblyEvaluate(new Bn(18))
            };
          if (n.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: C,
              maxZoom: I
            } = n.bucket.textSizeData;
            c.compositeTextSizes = [a["text-size"].possiblyEvaluate(new Bn(C), n.canonical), a["text-size"].possiblyEvaluate(new Bn(I), n.canonical)]
          }
          if (n.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: C,
              maxZoom: I
            } = n.bucket.iconSizeData;
            c.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new Bn(C), n.canonical), a["icon-size"].possiblyEvaluate(new Bn(I), n.canonical)]
          }
          const p = r.get("text-line-height") * ki,
            m = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point",
            v = r.get("text-keep-upright"),
            b = r.get("text-size");
          for (const C of n.bucket.features) {
            const I = r.get("text-font").evaluate(C, {}, n.canonical).join(","),
              R = b.evaluate(C, {}, n.canonical),
              U = c.layoutTextSize.evaluate(C, {}, n.canonical),
              Z = c.layoutIconSize.evaluate(C, {}, n.canonical),
              X = {
                horizontal: {},
                vertical: void 0
              },
              Q = C.text;
            let ie, ue = [0, 0];
            if (Q) {
              const Ce = Q.toString(),
                tt = r.get("text-letter-spacing").evaluate(C, {}, n.canonical) * ki,
                dt = vu(Ce) ? tt : 0,
                Rt = r.get("text-anchor").evaluate(C, {}, n.canonical),
                ir = dv(t, C, n.canonical);
              if (!ir) {
                const Qt = r.get("text-radial-offset").evaluate(C, {}, n.canonical);
                ue = Qt ? hv(Rt, [Qt * ki, Kf]) : r.get("text-offset").evaluate(C, {}, n.canonical).map((tr => tr * ki))
              }
              let Wt = m ? "center" : r.get("text-justify").evaluate(C, {}, n.canonical);
              const er = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(C, {}, n.canonical) * ki : 1 / 0,
                Fr = () => {
                  n.bucket.allowVerticalPlacement && gu(Ce) && (X.vertical = ap(Q, n.glyphMap, n.glyphPositions, n.imagePositions, I, er, p, Rt, "left", dt, ue, w.as.vertical, !0, U, R))
                };
              if (!m && ir) {
                const Qt = new Set;
                if (Wt === "auto")
                  for (let St = 0; St < ir.values.length; St += 2) Qt.add(Jf(ir.values[St]));
                else Qt.add(Wt);
                let tr = !1;
                for (const St of Qt)
                  if (!X.horizontal[St])
                    if (tr) X.horizontal[St] = X.horizontal[0];
                    else {
                      const $r = ap(Q, n.glyphMap, n.glyphPositions, n.imagePositions, I, er, p, "center", St, dt, ue, w.as.horizontal, !1, U, R);
                      $r && (X.horizontal[St] = $r, tr = $r.positionedLines.length === 1)
                    } Fr()
              } else {
                Wt === "auto" && (Wt = Jf(Rt));
                const Qt = ap(Q, n.glyphMap, n.glyphPositions, n.imagePositions, I, er, p, Rt, Wt, dt, ue, w.as.horizontal, !1, U, R);
                Qt && (X.horizontal[Wt] = Qt), Fr(), gu(Ce) && m && v && (X.vertical = ap(Q, n.glyphMap, n.glyphPositions, n.imagePositions, I, er, p, Rt, Wt, dt, ue, w.as.vertical, !1, U, R))
              }
            }
            let Ne = !1;
            if (C.icon && C.icon.name) {
              const Ce = n.imageMap[C.icon.name];
              Ce && (ie = fx(n.imagePositions[C.icon.name], r.get("icon-offset").evaluate(C, {}, n.canonical), r.get("icon-anchor").evaluate(C, {}, n.canonical)), Ne = !!Ce.sdf, n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = Ne : n.bucket.sdfIcons !== Ne && Nt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ce.pixelRatio !== n.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = !0))
            }
            const ye = fv(X.horizontal) || X.vertical;
            n.bucket.iconsInText = !!ye && ye.iconsInText, (ye || ie) && Mx(n.bucket, C, X, ie, n.imageMap, c, U, Z, ue, Ne, n.canonical, n.subdivisionGranularity)
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers()
        }, w.cL = Rf, w.cM = Bf, w.cN = Of, w.cO = gg, w.cP = jf, w.cQ = class {
          constructor(n) {
            this._marks = {
              start: [n.url, "start"].join("#"),
              end: [n.url, "end"].join("#"),
              measure: n.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let n = performance.getEntriesByName(this._marks.measure);
            return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), n = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), n
          }
        }, w.cR = function(n, t, r, a, c) {
          return s(this, void 0, void 0, (function*() {
            if (Ie()) try {
              return yield fr(n, t, r, a, c)
            } catch {}
            return (function(p, m, v, b, C) {
              const I = p.width,
                R = p.height;
              Kt && _r || (Kt = new OffscreenCanvas(I, R), _r = Kt.getContext("2d", {
                willReadFrequently: !0
              })), Kt.width = I, Kt.height = R, _r.drawImage(p, 0, 0, I, R);
              const U = _r.getImageData(m, v, b, C);
              return _r.clearRect(0, 0, I, R), U.data
            })(n, t, r, a, c)
          }))
        }, w.cS = ag, w.cT = j, w.cU = _g, w.cV = hc, w.cW = Vo, w.cX = function(n, t) {
          const r = new Map;
          if (n != null)
            if (n.type === "Feature") r.set(Uu(n, t), n);
            else
              for (const a of n.features) r.set(Uu(a, t), a);
          return r
        }, w.cY = function(n, t) {
          if (n == null) return !0;
          if (n.type === "Feature") return Uu(n, t) != null;
          if (n.type === "FeatureCollection") {
            const r = new Set;
            for (const a of n.features) {
              const c = Uu(a, t);
              if (c == null || r.has(c)) return !1;
              r.add(c)
            }
            return !0
          }
          return !1
        }, w.cZ = function(n, t, r) {
          var a, c, p, m;
          if (t.removeAll && n.clear(), t.remove)
            for (const v of t.remove) n.delete(v);
          if (t.add)
            for (const v of t.add) {
              const b = Uu(v, r);
              b != null && n.set(b, v)
            }
          if (t.update)
            for (const v of t.update) {
              let b = n.get(v.id);
              if (b == null) continue;
              const C = !v.removeAllProperties && (((a = v.removeProperties) === null || a === void 0 ? void 0 : a.length) > 0 || ((c = v.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
              if ((v.newGeometry || v.removeAllProperties || C) && (b = Object.assign({}, b), n.set(v.id, b), C && (b.properties = Object.assign({}, b.properties))), v.newGeometry && (b.geometry = v.newGeometry), v.removeAllProperties) b.properties = {};
              else if (((p = v.removeProperties) === null || p === void 0 ? void 0 : p.length) > 0)
                for (const I of v.removeProperties) Object.prototype.hasOwnProperty.call(b.properties, I) && delete b.properties[I];
              if (((m = v.addOrUpdateProperties) === null || m === void 0 ? void 0 : m.length) > 0)
                for (const {
                    key: I,
                    value: R
                  }
                  of v.addOrUpdateProperties) b.properties[I] = R
            }
        }, w.c_ = no, w.ca = class extends Su {}, w.cb = class extends u {}, w.cc = function(n, t) {
          return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15]
        }, w.cd = function(n, t) {
          var r = n[0],
            a = n[1],
            c = n[2],
            p = n[3],
            m = n[4],
            v = n[5],
            b = n[6],
            C = n[7],
            I = n[8],
            R = n[9],
            U = n[10],
            Z = n[11],
            X = n[12],
            Q = n[13],
            ie = n[14],
            ue = n[15],
            Ne = t[0],
            ye = t[1],
            Ce = t[2],
            tt = t[3],
            dt = t[4],
            Rt = t[5],
            ir = t[6],
            Wt = t[7],
            er = t[8],
            Fr = t[9],
            Qt = t[10],
            tr = t[11],
            St = t[12],
            $r = t[13],
            Kr = t[14],
            jr = t[15];
          return Math.abs(r - Ne) <= ze * Math.max(1, Math.abs(r), Math.abs(Ne)) && Math.abs(a - ye) <= ze * Math.max(1, Math.abs(a), Math.abs(ye)) && Math.abs(c - Ce) <= ze * Math.max(1, Math.abs(c), Math.abs(Ce)) && Math.abs(p - tt) <= ze * Math.max(1, Math.abs(p), Math.abs(tt)) && Math.abs(m - dt) <= ze * Math.max(1, Math.abs(m), Math.abs(dt)) && Math.abs(v - Rt) <= ze * Math.max(1, Math.abs(v), Math.abs(Rt)) && Math.abs(b - ir) <= ze * Math.max(1, Math.abs(b), Math.abs(ir)) && Math.abs(C - Wt) <= ze * Math.max(1, Math.abs(C), Math.abs(Wt)) && Math.abs(I - er) <= ze * Math.max(1, Math.abs(I), Math.abs(er)) && Math.abs(R - Fr) <= ze * Math.max(1, Math.abs(R), Math.abs(Fr)) && Math.abs(U - Qt) <= ze * Math.max(1, Math.abs(U), Math.abs(Qt)) && Math.abs(Z - tr) <= ze * Math.max(1, Math.abs(Z), Math.abs(tr)) && Math.abs(X - St) <= ze * Math.max(1, Math.abs(X), Math.abs(St)) && Math.abs(Q - $r) <= ze * Math.max(1, Math.abs(Q), Math.abs($r)) && Math.abs(ie - Kr) <= ze * Math.max(1, Math.abs(ie), Math.abs(Kr)) && Math.abs(ue - jr) <= ze * Math.max(1, Math.abs(ue), Math.abs(jr))
        }, w.ce = function(n, t) {
          return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, w.cf = n => n.type === "symbol", w.cg = n => n.type === "circle", w.ch = n => n.type === "heatmap", w.ci = n => n.type === "line", w.cj = n => n.type === "fill", w.ck = n => n.type === "fill-extrusion", w.cl = n => n.type === "hillshade", w.cm = n => n.type === "color-relief", w.cn = n => n.type === "background", w.co = n => n.type === "custom", w.cp = ut, w.cq = function(n, t, r) {
          const a = Ge(t.x - r.x, t.y - r.y),
            c = Ge(n.x - r.x, n.y - r.y);
          var p, m;
          return nr(Math.atan2(a[0] * c[1] - a[1] * c[0], (p = a)[0] * (m = c)[0] + p[1] * m[1]))
        }, w.cr = Ut, w.cs = function(n, t) {
          return kr[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
        }, w.ct = function(n, t) {
          return Et[t] && "touches" in n
        }, w.cu = function(n) {
          return Et[n] || kr[n]
        }, w.cv = function(n, t, r) {
          var a = t[0],
            c = t[1];
          return n[0] = r[0] * a + r[4] * c + r[12], n[1] = r[1] * a + r[5] * c + r[13], n
        }, w.cw = function(n, t) {
          const {
            x: r,
            y: a
          } = qu.fromLngLat(t);
          return !(n < 0 || n > 25 || a < 0 || a >= 1 || r < 0 || r >= 1)
        }, w.cx = function(n, t) {
          return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = t[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = t[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }, w.cy = class extends Jl {}, w.cz = kx, w.d = ve, w.e = ot, w.f = n => s(void 0, void 0, void 0, (function*() {
          if (n.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), w.g = D, w.h = n => new Promise(((t, r) => {
          const a = new Image;
          a.onload = () => {
            t(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame((() => {
              a.src = qt
            }))
          }, a.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const c = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          a.src = n.byteLength ? URL.createObjectURL(c) : qt
        })), w.i = It, w.j = (n, t) => ce(ot(n, {
          type: "json"
        }), t), w.k = Ze, w.l = Ye, w.m = ce, w.n = (n, t) => ce(ot(n, {
          type: "arrayBuffer"
        }), t), w.o = function(n) {
          return new jf(n).readFields(nx, [])
        }, w.p = kg, w.q = Eu, w.r = Zi, w.s = rr, w.t = _e, w.u = pn, w.v = zd, w.w = Nt, w.x = Ud, w.y = yf, w.z = Dd
      })), A("worker", ["./shared"], (function(w) {
        class s {
          constructor(E, D) {
            this.keyCache = {}, E && this.replace(E, D)
          }
          replace(E, D) {
            this._layerConfigs = {}, this._layers = {}, this.update(E, [], D)
          }
          update(E, D, N) {
            for (const W of E) {
              this._layerConfigs[W.id] = W;
              const ce = this._layers[W.id] = w.bM(W, N);
              ce._featureFilter = w.ae(ce.filter, N), this.keyCache[W.id] && delete this.keyCache[W.id]
            }
            for (const W of D) delete this.keyCache[W], delete this._layerConfigs[W], delete this._layers[W];
            this.familiesBySource = {};
            const H = w.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const W of H) {
              const ce = W.map((Tt => this._layers[Tt.id])),
                ve = ce[0];
              if (ve.visibility === "none") continue;
              const he = ve.source || "";
              let Se = this.familiesBySource[he];
              Se || (Se = this.familiesBySource[he] = {});
              const Ye = ve.sourceLayer || "_geojsonTileLayer";
              let Ze = Se[Ye];
              Ze || (Ze = Se[Ye] = []), Ze.push(ce)
            }
          }
        }
        class B {
          constructor(E) {
            const D = {},
              N = [];
            for (const ve in E) {
              const he = E[ve],
                Se = D[ve] = {};
              for (const Ye in he) {
                const Ze = he[+Ye];
                if (!Ze || Ze.bitmap.width === 0 || Ze.bitmap.height === 0) continue;
                const Tt = {
                  x: 0,
                  y: 0,
                  w: Ze.bitmap.width + 2,
                  h: Ze.bitmap.height + 2
                };
                N.push(Tt), Se[Ye] = {
                  rect: Tt,
                  metrics: Ze.metrics
                }
              }
            }
            const {
              w: H,
              h: W
            } = w.p(N), ce = new w.q({
              width: H || 1,
              height: W || 1
            });
            for (const ve in E) {
              const he = E[ve];
              for (const Se in he) {
                const Ye = he[+Se];
                if (!Ye || Ye.bitmap.width === 0 || Ye.bitmap.height === 0) continue;
                const Ze = D[ve][Se].rect;
                w.q.copy(Ye.bitmap, ce, {
                  x: 0,
                  y: 0
                }, {
                  x: Ze.x + 1,
                  y: Ze.y + 1
                }, Ye.bitmap)
              }
            }
            this.image = ce, this.positions = D
          }
        }
        w.cG("GlyphAtlas", B);
        class j {
          constructor(E) {
            this.tileID = new w.a0(E.tileID.overscaledZ, E.tileID.wrap, E.tileID.canonical.z, E.tileID.canonical.x, E.tileID.canonical.y), this.uid = E.uid, this.zoom = E.zoom, this.pixelRatio = E.pixelRatio, this.tileSize = E.tileSize, this.source = E.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = E.showCollisionBoxes, this.collectResourceTiming = !!E.collectResourceTiming, this.returnDependencies = !!E.returnDependencies, this.promoteId = E.promoteId, this.inFlightDependencies = []
          }
          parse(E, D, N, H, W) {
            return w._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = E, this.collisionBoxArray = new w.ac;
              const ce = new w.cH(Object.keys(E.layers).sort()),
                ve = new w.cI(this.tileID, this.promoteId);
              ve.bucketLayerIDs = [];
              const he = {},
                Se = {
                  featureIndex: ve,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: N,
                  subdivisionGranularity: W
                },
                Ye = D.familiesBySource[this.source];
              for (const ht in Ye) {
                const un = E.layers[ht];
                if (!un) continue;
                un.version === 1 && w.w(`Vector tile source "${this.source}" layer "${ht}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Pn = ce.encode(ht),
                  Bt = [];
                for (let st = 0; st < un.length; st++) {
                  const Me = un.feature(st),
                    ft = ve.getId(Me, ht);
                  Bt.push({
                    feature: Me,
                    id: ft,
                    index: st,
                    sourceLayerIndex: Pn
                  })
                }
                for (const st of Ye[ht]) {
                  const Me = st[0];
                  Me.source !== this.source && w.w(`layer.source = ${Me.source} does not equal this.source = ${this.source}`), Me.isHidden(this.zoom, !0) || (K(st, this.zoom, N), (he[Me.id] = Me.createBucket({
                    index: ve.bucketLayerIDs.length,
                    layers: st,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: Pn,
                    sourceID: this.source
                  })).populate(Bt, Se, this.tileID.canonical), ve.bucketLayerIDs.push(st.map((ft => ft.id))))
                }
              }
              const Ze = w.bR(Se.glyphDependencies, (ht => Object.keys(ht).map(Number)));
              this.inFlightDependencies.forEach((ht => ht == null ? void 0 : ht.abort())), this.inFlightDependencies = [];
              let Tt = Promise.resolve({});
              if (Object.keys(Ze).length) {
                const ht = new AbortController;
                this.inFlightDependencies.push(ht), Tt = H.sendAsync({
                  type: "GG",
                  data: {
                    stacks: Ze,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, ht)
              }
              const _e = Object.keys(Se.iconDependencies);
              let Vt = Promise.resolve({});
              if (_e.length) {
                const ht = new AbortController;
                this.inFlightDependencies.push(ht), Vt = H.sendAsync({
                  type: "GI",
                  data: {
                    icons: _e,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, ht)
              }
              const ur = Object.keys(Se.patternDependencies);
              let Ft = Promise.resolve({});
              if (ur.length) {
                const ht = new AbortController;
                this.inFlightDependencies.push(ht), Ft = H.sendAsync({
                  type: "GI",
                  data: {
                    icons: ur,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, ht)
              }
              const or = Se.dashDependencies;
              let Vr = Promise.resolve({});
              if (Object.keys(or).length) {
                const ht = new AbortController;
                this.inFlightDependencies.push(ht), Vr = H.sendAsync({
                  type: "GDA",
                  data: {
                    dashes: or
                  }
                }, ht)
              }
              const [qr, Wr, rn, hn] = yield Promise.all([Tt, Vt, Ft, Vr]), cn = new B(qr), an = new w.cJ(Wr, rn);
              for (const ht in he) {
                const un = he[ht];
                un instanceof w.ad ? (K(un.layers, this.zoom, N), w.cK({
                  bucket: un,
                  glyphMap: qr,
                  glyphPositions: cn.positions,
                  imageMap: Wr,
                  imagePositions: an.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Se.subdivisionGranularity
                })) : un.hasDependencies && (un instanceof w.cL || un instanceof w.cM || un instanceof w.cN) && (K(un.layers, this.zoom, N), un.addFeatures(Se, this.tileID.canonical, an.patternPositions, hn))
              }
              return this.status = "done", {
                buckets: Object.values(he).filter((ht => !ht.isEmpty())),
                featureIndex: ve,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: cn.image,
                imageAtlas: an,
                dashPositions: hn,
                glyphMap: this.returnDependencies ? qr : null,
                iconMap: this.returnDependencies ? Wr : null,
                glyphPositions: this.returnDependencies ? cn.positions : null
              }
            }))
          }
        }

        function K(O, E, D) {
          const N = new w.G(E);
          for (const H of O) H.recalculate(N, D)
        }
        class ee {
          constructor(E, D, N) {
            this.actor = E, this.layerIndex = D, this.availableImages = N, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(E, D) {
            return w._(this, void 0, void 0, (function*() {
              const N = yield w.n(E.request, D);
              try {
                return {
                  vectorTile: new w.cO(new w.cP(N.data)),
                  rawData: N.data,
                  cacheControl: N.cacheControl,
                  expires: N.expires
                }
              } catch (H) {
                const W = new Uint8Array(N.data);
                let ce = `Unable to parse the tile at ${E.request.url}, `;
                throw ce += W[0] === 31 && W[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${H.message}`, new Error(ce)
              }
            }))
          }
          loadTile(E) {
            return w._(this, void 0, void 0, (function*() {
              const D = E.uid,
                N = !!(E && E.request && E.request.collectResourceTiming) && new w.cQ(E.request),
                H = new j(E);
              this.loading[D] = H;
              const W = new AbortController;
              H.abort = W;
              try {
                const ce = yield this.loadVectorTile(E, W);
                if (delete this.loading[D], !ce) return null;
                const ve = ce.rawData,
                  he = {};
                ce.expires && (he.expires = ce.expires), ce.cacheControl && (he.cacheControl = ce.cacheControl);
                const Se = {};
                if (N) {
                  const Ze = N.finish();
                  Ze && (Se.resourceTiming = JSON.parse(JSON.stringify(Ze)))
                }
                H.vectorTile = ce.vectorTile;
                const Ye = H.parse(ce.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                this.loaded[D] = H, this.fetching[D] = {
                  rawTileData: ve,
                  cacheControl: he,
                  resourceTiming: Se
                };
                try {
                  const Ze = yield Ye;
                  return w.e({
                    rawTileData: ve.slice(0)
                  }, Ze, he, Se)
                } finally {
                  delete this.fetching[D]
                }
              } catch (ce) {
                throw delete this.loading[D], H.status = "done", this.loaded[D] = H, ce
              }
            }))
          }
          reloadTile(E) {
            return w._(this, void 0, void 0, (function*() {
              const D = E.uid;
              if (!this.loaded || !this.loaded[D]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const N = this.loaded[D];
              if (N.showCollisionBoxes = E.showCollisionBoxes, N.status === "parsing") {
                const H = yield N.parse(N.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                let W;
                if (this.fetching[D]) {
                  const {
                    rawTileData: ce,
                    cacheControl: ve,
                    resourceTiming: he
                  } = this.fetching[D];
                  delete this.fetching[D], W = w.e({
                    rawTileData: ce.slice(0)
                  }, H, ve, he)
                } else W = H;
                return W
              }
              if (N.status === "done" && N.vectorTile) return N.parse(N.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity)
            }))
          }
          abortTile(E) {
            return w._(this, void 0, void 0, (function*() {
              const D = this.loading,
                N = E.uid;
              D && D[N] && D[N].abort && (D[N].abort.abort(), delete D[N])
            }))
          }
          removeTile(E) {
            return w._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[E.uid] && delete this.loaded[E.uid]
            }))
          }
        }
        class re {
          constructor() {
            this.loaded = {}
          }
          loadTile(E) {
            return w._(this, void 0, void 0, (function*() {
              const {
                uid: D,
                encoding: N,
                rawImageData: H,
                redFactor: W,
                greenFactor: ce,
                blueFactor: ve,
                baseShift: he
              } = E, Se = H.width + 2, Ye = H.height + 2, Ze = w.b(H) ? new w.R({
                width: Se,
                height: Ye
              }, yield w.cR(H, -1, -1, Se, Ye)) : H, Tt = new w.cS(D, Ze, N, W, ce, ve, he);
              return this.loaded = this.loaded || {}, this.loaded[D] = Tt, Tt
            }))
          }
          removeTile(E) {
            const D = this.loaded,
              N = E.uid;
            D && D[N] && delete D[N]
          }
        }
        var de, ne, Y = (function() {
            if (ne) return de;

            function O(D, N) {
              if (D.length !== 0) {
                E(D[0], N);
                for (var H = 1; H < D.length; H++) E(D[H], !N)
              }
            }

            function E(D, N) {
              for (var H = 0, W = 0, ce = 0, ve = D.length, he = ve - 1; ce < ve; he = ce++) {
                var Se = (D[ce][0] - D[he][0]) * (D[he][1] + D[ce][1]),
                  Ye = H + Se;
                W += Math.abs(H) >= Math.abs(Se) ? H - Ye + Se : Se - Ye + H, H = Ye
              }
              H + W >= 0 != !!N && D.reverse()
            }
            return ne = 1, de = function D(N, H) {
              var W, ce = N && N.type;
              if (ce === "FeatureCollection")
                for (W = 0; W < N.features.length; W++) D(N.features[W], H);
              else if (ce === "GeometryCollection")
                for (W = 0; W < N.geometries.length; W++) D(N.geometries[W], H);
              else if (ce === "Feature") D(N.geometry, H);
              else if (ce === "Polygon") O(N.coordinates, H);
              else if (ce === "MultiPolygon")
                for (W = 0; W < N.coordinates.length; W++) O(N.coordinates[W], H);
              return N
            }
          })(),
          we = w.cT(Y);
        class Ie extends w.cV {
          constructor(E, D) {
            super(new w.cP, 0, D, [], []), this.feature = E, this.type = E.type, this.properties = E.tags ? E.tags : {}, "id" in E && (typeof E.id == "string" ? this.id = parseInt(E.id, 10) : typeof E.id != "number" || isNaN(E.id) || (this.id = E.id))
          }
          loadGeometry() {
            const E = [],
              D = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const N of D) {
              const H = [];
              for (const W of N) H.push(new w.P(W[0], W[1]));
              E.push(H)
            }
            return E
          }
        }
        class ze extends w.cU {
          constructor(E, D) {
            super(new w.cP), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = D ? D.version : 1, this.extent = D ? D.extent : 4096, this.length = E.length, this.features = E
          }
          feature(E) {
            return new Ie(this.features[E], this.extent)
          }
        }

        function Re(O, E) {
          E.writeVarintField(15, O.version || 1), E.writeStringField(1, O.name || ""), E.writeVarintField(5, O.extent || 4096);
          const D = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let W = 0; W < O.length; W++) D.feature = O.feature(W), E.writeMessage(2, ke, D);
          const N = D.keys;
          for (const W of N) E.writeStringField(3, W);
          const H = D.values;
          for (const W of H) E.writeMessage(4, He, W)
        }

        function ke(O, E) {
          if (!O.feature) return;
          const D = O.feature;
          D.id !== void 0 && E.writeVarintField(1, D.id), E.writeMessage(2, qe, O), E.writeVarintField(3, D.type), E.writeMessage(4, Ee, D)
        }

        function qe(O, E) {
          var D;
          for (const N in (D = O.feature) == null ? void 0 : D.properties) {
            let H = O.feature.properties[N],
              W = O.keycache[N];
            if (H === null) continue;
            W === void 0 && (O.keys.push(N), W = O.keys.length - 1, O.keycache[N] = W), E.writeVarint(W), typeof H != "string" && typeof H != "boolean" && typeof H != "number" && (H = JSON.stringify(H));
            const ce = typeof H + ":" + H;
            let ve = O.valuecache[ce];
            ve === void 0 && (O.values.push(H), ve = O.values.length - 1, O.valuecache[ce] = ve), E.writeVarint(ve)
          }
        }

        function $e(O, E) {
          return (E << 3) + (7 & O)
        }

        function Be(O) {
          return O << 1 ^ O >> 31
        }

        function Ee(O, E) {
          const D = O.loadGeometry(),
            N = O.type;
          let H = 0,
            W = 0;
          for (const ce of D) {
            let ve = 1;
            N === 1 && (ve = ce.length), E.writeVarint($e(1, ve));
            const he = N === 3 ? ce.length - 1 : ce.length;
            for (let Se = 0; Se < he; Se++) {
              Se === 1 && N !== 1 && E.writeVarint($e(2, he - 1));
              const Ye = ce[Se].x - H,
                Ze = ce[Se].y - W;
              E.writeVarint(Be(Ye)), E.writeVarint(Be(Ze)), H += Ye, W += Ze
            }
            O.type === 3 && E.writeVarint($e(7, 1))
          }
        }

        function He(O, E) {
          const D = typeof O;
          D === "string" ? E.writeStringField(1, O) : D === "boolean" ? E.writeBooleanField(7, O) : D === "number" && (O % 1 != 0 ? E.writeDoubleField(3, O) : O < 0 ? E.writeSVarintField(6, O) : E.writeVarintField(5, O))
        }
        const Le = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: O => O
          },
          it = Math.fround || (pt = new Float32Array(1), O => (pt[0] = +O, pt[0]));
        var pt;
        class Oe {
          constructor(E) {
            this.options = Object.assign(Object.create(Le), E), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(E) {
            const {
              log: D,
              minZoom: N,
              maxZoom: H
            } = this.options;
            D && console.time("total time");
            const W = `prepare ${E.length} points`;
            D && console.time(W), this.points = E;
            const ce = [];
            for (let he = 0; he < E.length; he++) {
              const Se = E[he];
              if (!Se.geometry) continue;
              const [Ye, Ze] = Se.geometry.coordinates, Tt = it(We(Ye)), _e = it(Ue(Ze));
              ce.push(Tt, _e, 1 / 0, he, -1, 1), this.options.reduce && ce.push(0)
            }
            let ve = this.trees[H + 1] = this._createTree(ce);
            D && console.timeEnd(W);
            for (let he = H; he >= N; he--) {
              const Se = +Date.now();
              ve = this.trees[he] = this._createTree(this._cluster(ve, he)), D && console.log("z%d: %d clusters in %dms", he, ve.numItems, +Date.now() - Se)
            }
            return D && console.timeEnd("total time"), this
          }
          getClusters(E, D) {
            let N = ((E[0] + 180) % 360 + 360) % 360 - 180;
            const H = Math.max(-90, Math.min(90, E[1]));
            let W = E[2] === 180 ? 180 : ((E[2] + 180) % 360 + 360) % 360 - 180;
            const ce = Math.max(-90, Math.min(90, E[3]));
            if (E[2] - E[0] >= 360) N = -180, W = 180;
            else if (N > W) {
              const Ze = this.getClusters([N, H, 180, ce], D),
                Tt = this.getClusters([-180, H, W, ce], D);
              return Ze.concat(Tt)
            }
            const ve = this.trees[this._limitZoom(D)],
              he = ve.range(We(N), Ue(ce), We(W), Ue(H)),
              Se = ve.data,
              Ye = [];
            for (const Ze of he) {
              const Tt = this.stride * Ze;
              Ye.push(Se[Tt + 5] > 1 ? Je(Se, Tt, this.clusterProps) : this.points[Se[Tt + 3]])
            }
            return Ye
          }
          getChildren(E) {
            const D = this._getOriginId(E),
              N = this._getOriginZoom(E),
              H = "No cluster with the specified id.",
              W = this.trees[N];
            if (!W) throw new Error(H);
            const ce = W.data;
            if (D * this.stride >= ce.length) throw new Error(H);
            const ve = this.options.radius / (this.options.extent * Math.pow(2, N - 1)),
              he = W.within(ce[D * this.stride], ce[D * this.stride + 1], ve),
              Se = [];
            for (const Ye of he) {
              const Ze = Ye * this.stride;
              ce[Ze + 4] === E && Se.push(ce[Ze + 5] > 1 ? Je(ce, Ze, this.clusterProps) : this.points[ce[Ze + 3]])
            }
            if (Se.length === 0) throw new Error(H);
            return Se
          }
          getLeaves(E, D, N) {
            const H = [];
            return this._appendLeaves(H, E, D = D || 10, N = N || 0, 0), H
          }
          getTile(E, D, N) {
            const H = this.trees[this._limitZoom(E)],
              W = Math.pow(2, E),
              {
                extent: ce,
                radius: ve
              } = this.options,
              he = ve / ce,
              Se = (N - he) / W,
              Ye = (N + 1 + he) / W,
              Ze = {
                features: []
              };
            return this._addTileFeatures(H.range((D - he) / W, Se, (D + 1 + he) / W, Ye), H.data, D, N, W, Ze), D === 0 && this._addTileFeatures(H.range(1 - he / W, Se, 1, Ye), H.data, W, N, W, Ze), D === W - 1 && this._addTileFeatures(H.range(0, Se, he / W, Ye), H.data, -1, N, W, Ze), Ze.features.length ? Ze : null
          }
          getClusterExpansionZoom(E) {
            let D = this._getOriginZoom(E) - 1;
            for (; D <= this.options.maxZoom;) {
              const N = this.getChildren(E);
              if (D++, N.length !== 1) break;
              E = N[0].properties.cluster_id
            }
            return D
          }
          _appendLeaves(E, D, N, H, W) {
            const ce = this.getChildren(D);
            for (const ve of ce) {
              const he = ve.properties;
              if (he && he.cluster ? W + he.point_count <= H ? W += he.point_count : W = this._appendLeaves(E, he.cluster_id, N, H, W) : W < H ? W++ : E.push(ve), E.length === N) break
            }
            return W
          }
          _createTree(E) {
            const D = new w.aM(E.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let N = 0; N < E.length; N += this.stride) D.add(E[N], E[N + 1]);
            return D.finish(), D.data = E, D
          }
          _addTileFeatures(E, D, N, H, W, ce) {
            for (const ve of E) {
              const he = ve * this.stride,
                Se = D[he + 5] > 1;
              let Ye, Ze, Tt;
              if (Se) Ye = bt(D, he, this.clusterProps), Ze = D[he], Tt = D[he + 1];
              else {
                const ur = this.points[D[he + 3]];
                Ye = ur.properties;
                const [Ft, or] = ur.geometry.coordinates;
                Ze = We(Ft), Tt = Ue(or)
              }
              const _e = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (Ze * W - N)), Math.round(this.options.extent * (Tt * W - H))]
                ],
                tags: Ye
              };
              let Vt;
              Vt = Se || this.options.generateId ? D[he + 3] : this.points[D[he + 3]].id, Vt !== void 0 && (_e.id = Vt), ce.features.push(_e)
            }
          }
          _limitZoom(E) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+E), this.options.maxZoom + 1))
          }
          _cluster(E, D) {
            const {
              radius: N,
              extent: H,
              reduce: W,
              minPoints: ce
            } = this.options, ve = N / (H * Math.pow(2, D)), he = E.data, Se = [], Ye = this.stride;
            for (let Ze = 0; Ze < he.length; Ze += Ye) {
              if (he[Ze + 2] <= D) continue;
              he[Ze + 2] = D;
              const Tt = he[Ze],
                _e = he[Ze + 1],
                Vt = E.within(he[Ze], he[Ze + 1], ve),
                ur = he[Ze + 5];
              let Ft = ur;
              for (const or of Vt) {
                const Vr = or * Ye;
                he[Vr + 2] > D && (Ft += he[Vr + 5])
              }
              if (Ft > ur && Ft >= ce) {
                let or, Vr = Tt * ur,
                  qr = _e * ur,
                  Wr = -1;
                const rn = (Ze / Ye << 5) + (D + 1) + this.points.length;
                for (const hn of Vt) {
                  const cn = hn * Ye;
                  if (he[cn + 2] <= D) continue;
                  he[cn + 2] = D;
                  const an = he[cn + 5];
                  Vr += he[cn] * an, qr += he[cn + 1] * an, he[cn + 4] = rn, W && (or || (or = this._map(he, Ze, !0), Wr = this.clusterProps.length, this.clusterProps.push(or)), W(or, this._map(he, cn)))
                }
                he[Ze + 4] = rn, Se.push(Vr / Ft, qr / Ft, 1 / 0, rn, -1, Ft), W && Se.push(Wr)
              } else {
                for (let or = 0; or < Ye; or++) Se.push(he[Ze + or]);
                if (Ft > 1)
                  for (const or of Vt) {
                    const Vr = or * Ye;
                    if (!(he[Vr + 2] <= D)) {
                      he[Vr + 2] = D;
                      for (let qr = 0; qr < Ye; qr++) Se.push(he[Vr + qr])
                    }
                  }
              }
            }
            return Se
          }
          _getOriginId(E) {
            return E - this.points.length >> 5
          }
          _getOriginZoom(E) {
            return (E - this.points.length) % 32
          }
          _map(E, D, N) {
            if (E[D + 5] > 1) {
              const ce = this.clusterProps[E[D + 6]];
              return N ? Object.assign({}, ce) : ce
            }
            const H = this.points[E[D + 3]].properties,
              W = this.options.map(H);
            return N && W === H ? Object.assign({}, W) : W
          }
        }

        function Je(O, E, D) {
          return {
            type: "Feature",
            id: O[E + 3],
            properties: bt(O, E, D),
            geometry: {
              type: "Point",
              coordinates: [(N = O[E], 360 * (N - .5)), Ge(O[E + 1])]
            }
          };
          var N
        }

        function bt(O, E, D) {
          const N = O[E + 5],
            H = N >= 1e4 ? `${Math.round(N/1e3)}k` : N >= 1e3 ? Math.round(N / 100) / 10 + "k" : N,
            W = O[E + 6],
            ce = W === -1 ? {} : Object.assign({}, D[W]);
          return Object.assign(ce, {
            cluster: !0,
            cluster_id: O[E + 3],
            point_count: N,
            point_count_abbreviated: H
          })
        }

        function We(O) {
          return O / 360 + .5
        }

        function Ue(O) {
          const E = Math.sin(O * Math.PI / 180),
            D = .5 - .25 * Math.log((1 + E) / (1 - E)) / Math.PI;
          return D < 0 ? 0 : D > 1 ? 1 : D
        }

        function Ge(O) {
          const E = (180 - 360 * O) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(E)) / Math.PI - 90
        }

        function Ve(O, E, D, N) {
          let H = N;
          const W = E + (D - E >> 1);
          let ce, ve = D - E;
          const he = O[E],
            Se = O[E + 1],
            Ye = O[D],
            Ze = O[D + 1];
          for (let Tt = E + 3; Tt < D; Tt += 3) {
            const _e = mt(O[Tt], O[Tt + 1], he, Se, Ye, Ze);
            if (_e > H) ce = Tt, H = _e;
            else if (_e === H) {
              const Vt = Math.abs(Tt - W);
              Vt < ve && (ce = Tt, ve = Vt)
            }
          }
          H > N && (ce - E > 3 && Ve(O, E, ce, N), O[ce + 2] = H, D - ce > 3 && Ve(O, ce, D, N))
        }

        function mt(O, E, D, N, H, W) {
          let ce = H - D,
            ve = W - N;
          if (ce !== 0 || ve !== 0) {
            const he = ((O - D) * ce + (E - N) * ve) / (ce * ce + ve * ve);
            he > 1 ? (D = H, N = W) : he > 0 && (D += ce * he, N += ve * he)
          }
          return ce = O - D, ve = E - N, ce * ce + ve * ve
        }

        function lt(O, E, D, N) {
          const H = {
            id: O ?? null,
            type: E,
            geometry: D,
            tags: N,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (E === "Point" || E === "MultiPoint" || E === "LineString") yt(H, D);
          else if (E === "Polygon") yt(H, D[0]);
          else if (E === "MultiLineString")
            for (const W of D) yt(H, W);
          else if (E === "MultiPolygon")
            for (const W of D) yt(H, W[0]);
          return H
        }

        function yt(O, E) {
          for (let D = 0; D < E.length; D += 3) O.minX = Math.min(O.minX, E[D]), O.minY = Math.min(O.minY, E[D + 1]), O.maxX = Math.max(O.maxX, E[D]), O.maxY = Math.max(O.maxY, E[D + 1])
        }

        function _t(O, E, D, N) {
          if (!E.geometry) return;
          const H = E.geometry.coordinates;
          if (H && H.length === 0) return;
          const W = E.geometry.type,
            ce = Math.pow(D.tolerance / ((1 << D.maxZoom) * D.extent), 2);
          let ve = [],
            he = E.id;
          if (D.promoteId ? he = E.properties[D.promoteId] : D.generateId && (he = N || 0), W === "Point") ut(H, ve);
          else if (W === "MultiPoint")
            for (const Se of H) ut(Se, ve);
          else if (W === "LineString") Ut(H, ve, ce, !1);
          else if (W === "MultiLineString") {
            if (D.lineMetrics) {
              for (const Se of H) ve = [], Ut(Se, ve, ce, !1), O.push(lt(he, "LineString", ve, E.properties));
              return
            }
            Lt(H, ve, ce, !1)
          } else if (W === "Polygon") Lt(H, ve, ce, !0);
          else {
            if (W !== "MultiPolygon") {
              if (W === "GeometryCollection") {
                for (const Se of E.geometry.geometries) _t(O, {
                  id: he,
                  geometry: Se,
                  properties: E.properties
                }, D, N);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Se of H) {
              const Ye = [];
              Lt(Se, Ye, ce, !0), ve.push(Ye)
            }
          }
          O.push(lt(he, W, ve, E.properties))
        }

        function ut(O, E) {
          E.push(Ke(O[0]), ot(O[1]), 0)
        }

        function Ut(O, E, D, N) {
          let H, W, ce = 0;
          for (let he = 0; he < O.length; he++) {
            const Se = Ke(O[he][0]),
              Ye = ot(O[he][1]);
            E.push(Se, Ye, 0), he > 0 && (ce += N ? (H * Ye - Se * W) / 2 : Math.sqrt(Math.pow(Se - H, 2) + Math.pow(Ye - W, 2))), H = Se, W = Ye
          }
          const ve = E.length - 3;
          E[2] = 1, Ve(E, 0, ve, D), E[ve + 2] = 1, E.size = Math.abs(ce), E.start = 0, E.end = E.size
        }

        function Lt(O, E, D, N) {
          for (let H = 0; H < O.length; H++) {
            const W = [];
            Ut(O[H], W, D, N), E.push(W)
          }
        }

        function Ke(O) {
          return O / 360 + .5
        }

        function ot(O) {
          const E = Math.sin(O * Math.PI / 180),
            D = .5 - .25 * Math.log((1 + E) / (1 - E)) / Math.PI;
          return D < 0 ? 0 : D > 1 ? 1 : D
        }

        function xt(O, E, D, N, H, W, ce, ve) {
          if (N /= E, W >= (D /= E) && ce < N) return O;
          if (ce < D || W >= N) return null;
          const he = [];
          for (const Se of O) {
            const Ye = Se.geometry;
            let Ze = Se.type;
            const Tt = H === 0 ? Se.minX : Se.minY,
              _e = H === 0 ? Se.maxX : Se.maxY;
            if (Tt >= D && _e < N) {
              he.push(Se);
              continue
            }
            if (_e < D || Tt >= N) continue;
            let Vt = [];
            if (Ze === "Point" || Ze === "MultiPoint") Ct(Ye, Vt, D, N, H);
            else if (Ze === "LineString") wt(Ye, Vt, D, N, H, !1, ve.lineMetrics);
            else if (Ze === "MultiLineString") Zt(Ye, Vt, D, N, H, !1);
            else if (Ze === "Polygon") Zt(Ye, Vt, D, N, H, !0);
            else if (Ze === "MultiPolygon")
              for (const ur of Ye) {
                const Ft = [];
                Zt(ur, Ft, D, N, H, !0), Ft.length && Vt.push(Ft)
              }
            if (Vt.length) {
              if (ve.lineMetrics && Ze === "LineString") {
                for (const ur of Vt) he.push(lt(Se.id, Ze, ur, Se.tags));
                continue
              }
              Ze !== "LineString" && Ze !== "MultiLineString" || (Vt.length === 1 ? (Ze = "LineString", Vt = Vt[0]) : Ze = "MultiLineString"), Ze !== "Point" && Ze !== "MultiPoint" || (Ze = Vt.length === 3 ? "Point" : "MultiPoint"), he.push(lt(Se.id, Ze, Vt, Se.tags))
            }
          }
          return he.length ? he : null
        }

        function Ct(O, E, D, N, H) {
          for (let W = 0; W < O.length; W += 3) {
            const ce = O[W + H];
            ce >= D && ce <= N && Nt(E, O[W], O[W + 1], O[W + 2])
          }
        }

        function wt(O, E, D, N, H, W, ce) {
          let ve = kt(O);
          const he = H === 0 ? $t : It;
          let Se, Ye, Ze = O.start;
          for (let Ft = 0; Ft < O.length - 3; Ft += 3) {
            const or = O[Ft],
              Vr = O[Ft + 1],
              qr = O[Ft + 2],
              Wr = O[Ft + 3],
              rn = O[Ft + 4],
              hn = H === 0 ? or : Vr,
              cn = H === 0 ? Wr : rn;
            let an = !1;
            ce && (Se = Math.sqrt(Math.pow(or - Wr, 2) + Math.pow(Vr - rn, 2))), hn < D ? cn > D && (Ye = he(ve, or, Vr, Wr, rn, D), ce && (ve.start = Ze + Se * Ye)) : hn > N ? cn < N && (Ye = he(ve, or, Vr, Wr, rn, N), ce && (ve.start = Ze + Se * Ye)) : Nt(ve, or, Vr, qr), cn < D && hn >= D && (Ye = he(ve, or, Vr, Wr, rn, D), an = !0), cn > N && hn <= N && (Ye = he(ve, or, Vr, Wr, rn, N), an = !0), !W && an && (ce && (ve.end = Ze + Se * Ye), E.push(ve), ve = kt(O)), ce && (Ze += Se)
          }
          let Tt = O.length - 3;
          const _e = O[Tt],
            Vt = O[Tt + 1],
            ur = H === 0 ? _e : Vt;
          ur >= D && ur <= N && Nt(ve, _e, Vt, O[Tt + 2]), Tt = ve.length - 3, W && Tt >= 3 && (ve[Tt] !== ve[0] || ve[Tt + 1] !== ve[1]) && Nt(ve, ve[0], ve[1], ve[2]), ve.length && E.push(ve)
        }

        function kt(O) {
          const E = [];
          return E.size = O.size, E.start = O.start, E.end = O.end, E
        }

        function Zt(O, E, D, N, H, W) {
          for (const ce of O) wt(ce, E, D, N, H, W, !1)
        }

        function Nt(O, E, D, N) {
          O.push(E, D, N)
        }

        function $t(O, E, D, N, H, W) {
          const ce = (W - E) / (N - E);
          return Nt(O, W, D + (H - D) * ce, 1), ce
        }

        function It(O, E, D, N, H, W) {
          const ce = (W - D) / (H - D);
          return Nt(O, E + (N - E) * ce, W, 1), ce
        }

        function Xt(O, E) {
          const D = [];
          for (let N = 0; N < O.length; N++) {
            const H = O[N],
              W = H.type;
            let ce;
            if (W === "Point" || W === "MultiPoint" || W === "LineString") ce = Ot(H.geometry, E);
            else if (W === "MultiLineString" || W === "Polygon") {
              ce = [];
              for (const ve of H.geometry) ce.push(Ot(ve, E))
            } else if (W === "MultiPolygon") {
              ce = [];
              for (const ve of H.geometry) {
                const he = [];
                for (const Se of ve) he.push(Ot(Se, E));
                ce.push(he)
              }
            }
            D.push(lt(H.id, W, ce, H.tags))
          }
          return D
        }

        function Ot(O, E) {
          const D = [];
          D.size = O.size, O.start !== void 0 && (D.start = O.start, D.end = O.end);
          for (let N = 0; N < O.length; N += 3) D.push(O[N] + E, O[N + 1], O[N + 2]);
          return D
        }

        function jt(O, E) {
          if (O.transformed) return O;
          const D = 1 << O.z,
            N = O.x,
            H = O.y;
          for (const W of O.features) {
            const ce = W.geometry,
              ve = W.type;
            if (W.geometry = [], ve === 1)
              for (let he = 0; he < ce.length; he += 2) W.geometry.push(qt(ce[he], ce[he + 1], E, D, N, H));
            else
              for (let he = 0; he < ce.length; he++) {
                const Se = [];
                for (let Ye = 0; Ye < ce[he].length; Ye += 2) Se.push(qt(ce[he][Ye], ce[he][Ye + 1], E, D, N, H));
                W.geometry.push(Se)
              }
          }
          return O.transformed = !0, O
        }

        function qt(O, E, D, N, H, W) {
          return [Math.round(D * (O * N - H)), Math.round(D * (E * N - W))]
        }

        function fr(O, E, D, N, H) {
          const W = E === H.maxZoom ? 0 : H.tolerance / ((1 << E) * H.extent),
            ce = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: O.length,
              source: null,
              x: D,
              y: N,
              z: E,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const ve of O) Kt(ce, ve, W, H);
          return ce
        }

        function Kt(O, E, D, N) {
          const H = E.geometry,
            W = E.type,
            ce = [];
          if (O.minX = Math.min(O.minX, E.minX), O.minY = Math.min(O.minY, E.minY), O.maxX = Math.max(O.maxX, E.maxX), O.maxY = Math.max(O.maxY, E.maxY), W === "Point" || W === "MultiPoint")
            for (let ve = 0; ve < H.length; ve += 3) ce.push(H[ve], H[ve + 1]), O.numPoints++, O.numSimplified++;
          else if (W === "LineString") _r(ce, H, O, D, !1, !1);
          else if (W === "MultiLineString" || W === "Polygon")
            for (let ve = 0; ve < H.length; ve++) _r(ce, H[ve], O, D, W === "Polygon", ve === 0);
          else if (W === "MultiPolygon")
            for (let ve = 0; ve < H.length; ve++) {
              const he = H[ve];
              for (let Se = 0; Se < he.length; Se++) _r(ce, he[Se], O, D, !0, Se === 0)
            }
          if (ce.length) {
            let ve = E.tags || null;
            if (W === "LineString" && N.lineMetrics) {
              ve = {};
              for (const Se in E.tags) ve[Se] = E.tags[Se];
              ve.mapbox_clip_start = H.start / H.size, ve.mapbox_clip_end = H.end / H.size
            }
            const he = {
              geometry: ce,
              type: W === "Polygon" || W === "MultiPolygon" ? 3 : W === "LineString" || W === "MultiLineString" ? 2 : 1,
              tags: ve
            };
            E.id !== null && (he.id = E.id), O.features.push(he)
          }
        }

        function _r(O, E, D, N, H, W) {
          const ce = N * N;
          if (N > 0 && E.size < (H ? ce : N)) return void(D.numPoints += E.length / 3);
          const ve = [];
          for (let he = 0; he < E.length; he += 3)(N === 0 || E[he + 2] > ce) && (D.numSimplified++, ve.push(E[he], E[he + 1])), D.numPoints++;
          H && (function(he, Se) {
            let Ye = 0;
            for (let Ze = 0, Tt = he.length, _e = Tt - 2; Ze < Tt; _e = Ze, Ze += 2) Ye += (he[Ze] - he[_e]) * (he[Ze + 1] + he[_e + 1]);
            if (Ye > 0 === Se)
              for (let Ze = 0, Tt = he.length; Ze < Tt / 2; Ze += 2) {
                const _e = he[Ze],
                  Vt = he[Ze + 1];
                he[Ze] = he[Tt - 2 - Ze], he[Ze + 1] = he[Tt - 1 - Ze], he[Tt - 2 - Ze] = _e, he[Tt - 1 - Ze] = Vt
              }
          })(ve, W), O.push(ve)
        }
        const rr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class hr {
          constructor(E, D) {
            const N = (D = this.options = (function(W, ce) {
              for (const ve in ce) W[ve] = ce[ve];
              return W
            })(Object.create(rr), D)).debug;
            if (N && console.time("preprocess data"), D.maxZoom < 0 || D.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (D.promoteId && D.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let H = (function(W, ce) {
              const ve = [];
              if (W.type === "FeatureCollection")
                for (let he = 0; he < W.features.length; he++) _t(ve, W.features[he], ce, he);
              else _t(ve, W.type === "Feature" ? W : {
                geometry: W
              }, ce);
              return ve
            })(E, D);
            this.tiles = {}, this.tileCoords = [], N && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", D.indexMaxZoom, D.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), H = (function(W, ce) {
              const ve = ce.buffer / ce.extent;
              let he = W;
              const Se = xt(W, 1, -1 - ve, ve, 0, -1, 2, ce),
                Ye = xt(W, 1, 1 - ve, 2 + ve, 0, -1, 2, ce);
              return (Se || Ye) && (he = xt(W, 1, -ve, 1 + ve, 0, -1, 2, ce) || [], Se && (he = Xt(Se, 1).concat(he)), Ye && (he = he.concat(Xt(Ye, -1)))), he
            })(H, D), H.length && this.splitTile(H, 0, 0, 0), N && (H.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(E, D, N, H, W, ce, ve) {
            const he = [E, D, N, H],
              Se = this.options,
              Ye = Se.debug;
            for (; he.length;) {
              H = he.pop(), N = he.pop(), D = he.pop(), E = he.pop();
              const Ze = 1 << D,
                Tt = nr(D, N, H);
              let _e = this.tiles[Tt];
              if (!_e && (Ye > 1 && console.time("creation"), _e = this.tiles[Tt] = fr(E, D, N, H, Se), this.tileCoords.push({
                  z: D,
                  x: N,
                  y: H
                }), Ye)) {
                Ye > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", D, N, H, _e.numFeatures, _e.numPoints, _e.numSimplified), console.timeEnd("creation"));
                const an = `z${D}`;
                this.stats[an] = (this.stats[an] || 0) + 1, this.total++
              }
              if (_e.source = E, W == null) {
                if (D === Se.indexMaxZoom || _e.numPoints <= Se.indexMaxPoints) continue
              } else {
                if (D === Se.maxZoom || D === W) continue;
                if (W != null) {
                  const an = W - D;
                  if (N !== ce >> an || H !== ve >> an) continue
                }
              }
              if (_e.source = null, E.length === 0) continue;
              Ye > 1 && console.time("clipping");
              const Vt = .5 * Se.buffer / Se.extent,
                ur = .5 - Vt,
                Ft = .5 + Vt,
                or = 1 + Vt;
              let Vr = null,
                qr = null,
                Wr = null,
                rn = null,
                hn = xt(E, Ze, N - Vt, N + Ft, 0, _e.minX, _e.maxX, Se),
                cn = xt(E, Ze, N + ur, N + or, 0, _e.minX, _e.maxX, Se);
              E = null, hn && (Vr = xt(hn, Ze, H - Vt, H + Ft, 1, _e.minY, _e.maxY, Se), qr = xt(hn, Ze, H + ur, H + or, 1, _e.minY, _e.maxY, Se), hn = null), cn && (Wr = xt(cn, Ze, H - Vt, H + Ft, 1, _e.minY, _e.maxY, Se), rn = xt(cn, Ze, H + ur, H + or, 1, _e.minY, _e.maxY, Se), cn = null), Ye > 1 && console.timeEnd("clipping"), he.push(Vr || [], D + 1, 2 * N, 2 * H), he.push(qr || [], D + 1, 2 * N, 2 * H + 1), he.push(Wr || [], D + 1, 2 * N + 1, 2 * H), he.push(rn || [], D + 1, 2 * N + 1, 2 * H + 1)
            }
          }
          getTile(E, D, N) {
            E = +E, D = +D, N = +N;
            const H = this.options,
              {
                extent: W,
                debug: ce
              } = H;
            if (E < 0 || E > 24) return null;
            const ve = 1 << E,
              he = nr(E, D = D + ve & ve - 1, N);
            if (this.tiles[he]) return jt(this.tiles[he], W);
            ce > 1 && console.log("drilling down to z%d-%d-%d", E, D, N);
            let Se, Ye = E,
              Ze = D,
              Tt = N;
            for (; !Se && Ye > 0;) Ye--, Ze >>= 1, Tt >>= 1, Se = this.tiles[nr(Ye, Ze, Tt)];
            return Se && Se.source ? (ce > 1 && (console.log("found parent tile z%d-%d-%d", Ye, Ze, Tt), console.time("drilling down")), this.splitTile(Se.source, Ye, Ze, Tt, E, D, N), ce > 1 && console.timeEnd("drilling down"), this.tiles[he] ? jt(this.tiles[he], W) : null) : null
          }
        }

        function nr(O, E, D) {
          return 32 * ((1 << O) * D + E) + O
        }
        class Et extends ee {
          constructor(E, D, N, H = kr) {
            super(E, D, N), this._dataUpdateable = new Map, this._createGeoJSONIndex = H
          }
          loadVectorTile(E, D) {
            return w._(this, void 0, void 0, (function*() {
              const N = E.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const H = this._geoJSONIndex.getTile(N.z, N.x, N.y);
              if (!H) return null;
              const W = new ze(H.features, {
                version: 2,
                extent: w.a3
              });
              let ce = (function(ve) {
                const he = new w.cP;
                return (function(Se, Ye) {
                  for (const Ze in Se.layers) Ye.writeMessage(3, Re, Se.layers[Ze])
                })(ve, he), he.finish()
              })(W);
              return ce.byteOffset === 0 && ce.byteLength === ce.buffer.byteLength || (ce = new Uint8Array(ce)), {
                vectorTile: W,
                rawData: ce.buffer
              }
            }))
          }
          loadData(E) {
            return w._(this, void 0, void 0, (function*() {
              var D;
              (D = this._pendingRequest) === null || D === void 0 || D.abort();
              const N = !!(E && E.request && E.request.collectResourceTiming) && new w.cQ(E.request);
              this._pendingRequest = new AbortController;
              try {
                (!this._pendingData || E.request || E.data || E.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(E, this._pendingRequest));
                const H = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(H, E), this.loaded = {};
                const W = {
                  data: H
                };
                if (N) {
                  const ce = N.finish();
                  ce && (W.resourceTiming = {}, W.resourceTiming[E.source] = JSON.parse(JSON.stringify(ce)))
                }
                return W
              } catch (H) {
                if (delete this._pendingRequest, w.cB(H)) return {
                  abandoned: !0
                };
                throw H
              }
            }))
          }
          getData() {
            return w._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(E) {
            const D = this.loaded;
            return D && D[E.uid] ? super.reloadTile(E) : this.loadTile(E)
          }
          loadAndProcessGeoJSON(E, D) {
            return w._(this, void 0, void 0, (function*() {
              let N = yield this.loadGeoJSON(E, D);
              if (delete this._pendingRequest, typeof N != "object") throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`);
              if (we(N, !0), E.filter) {
                const H = w.cW(E.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (H.result === "error") throw new Error(H.value.map((ce => `${ce.key}: ${ce.message}`)).join(", "));
                N = {
                  type: "FeatureCollection",
                  features: N.features.filter((ce => H.value.evaluate({
                    zoom: 0
                  }, ce)))
                }
              }
              return N
            }))
          }
          loadGeoJSON(E, D) {
            return w._(this, void 0, void 0, (function*() {
              const {
                promoteId: N
              } = E;
              if (E.request) {
                const H = yield w.j(E.request, D);
                return this._dataUpdateable = w.cY(H.data, N) ? w.cX(H.data, N) : void 0, H.data
              }
              if (typeof E.data == "string") try {
                const H = JSON.parse(E.data);
                return this._dataUpdateable = w.cY(H, N) ? w.cX(H, N) : void 0, H
              } catch {
                throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`)
              }
              if (!E.dataDiff) throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${E.source}`);
              return w.cZ(this._dataUpdateable, E.dataDiff, N), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(E) {
            return w._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(E) {
            return this._geoJSONIndex.getClusterExpansionZoom(E.clusterId)
          }
          getClusterChildren(E) {
            return this._geoJSONIndex.getChildren(E.clusterId)
          }
          getClusterLeaves(E) {
            return this._geoJSONIndex.getLeaves(E.clusterId, E.limit, E.offset)
          }
        }

        function kr(O, E) {
          return E.cluster ? new Oe((function({
            superclusterOptions: D,
            clusterProperties: N
          }) {
            if (!N || !D) return D;
            const H = {},
              W = {},
              ce = {
                accumulated: null,
                zoom: 0
              },
              ve = {
                properties: null
              },
              he = Object.keys(N);
            for (const Se of he) {
              const [Ye, Ze] = N[Se], Tt = w.cW(Ze), _e = w.cW(typeof Ye == "string" ? [Ye, ["accumulated"],
                ["get", Se]
              ] : Ye);
              H[Se] = Tt.value, W[Se] = _e.value
            }
            return D.map = Se => {
              ve.properties = Se;
              const Ye = {};
              for (const Ze of he) Ye[Ze] = H[Ze].evaluate(ce, ve);
              return Ye
            }, D.reduce = (Se, Ye) => {
              ve.properties = Ye;
              for (const Ze of he) ce.accumulated = Se[Ze], Se[Ze] = W[Ze].evaluate(ce, ve)
            }, D
          })(E)).load(O.features) : (function(D, N) {
            return new hr(D, N)
          })(O, E.geojsonVtOptions)
        }
        class Te {
          constructor(E) {
            this.self = E, this.actor = new w.K(E), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (D, N) => {
              if (this.externalWorkerSourceTypes[D]) throw new Error(`Worker source with name "${D}" already registered.`);
              this.externalWorkerSourceTypes[D] = N
            }, this.self.addProtocol = w.cD, this.self.removeProtocol = w.cE, this.self.registerRTLTextPlugin = D => {
              w.c_.setMethods(D)
            }, this.actor.registerMessageHandler("LDT", ((D, N) => this._getDEMWorkerSource(D, N.source).loadTile(N))), this.actor.registerMessageHandler("RDT", ((D, N) => w._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(D, N.source).removeTile(N)
            })))), this.actor.registerMessageHandler("GCEZ", ((D, N) => w._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(D, N.type, N.source).getClusterExpansionZoom(N)
            })))), this.actor.registerMessageHandler("GCC", ((D, N) => w._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(D, N.type, N.source).getClusterChildren(N)
            })))), this.actor.registerMessageHandler("GCL", ((D, N) => w._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(D, N.type, N.source).getClusterLeaves(N)
            })))), this.actor.registerMessageHandler("LD", ((D, N) => this._getWorkerSource(D, N.type, N.source).loadData(N))), this.actor.registerMessageHandler("GD", ((D, N) => this._getWorkerSource(D, N.type, N.source).getData())), this.actor.registerMessageHandler("LT", ((D, N) => this._getWorkerSource(D, N.type, N.source).loadTile(N))), this.actor.registerMessageHandler("RT", ((D, N) => this._getWorkerSource(D, N.type, N.source).reloadTile(N))), this.actor.registerMessageHandler("AT", ((D, N) => this._getWorkerSource(D, N.type, N.source).abortTile(N))), this.actor.registerMessageHandler("RMT", ((D, N) => this._getWorkerSource(D, N.type, N.source).removeTile(N))), this.actor.registerMessageHandler("RS", ((D, N) => w._(this, void 0, void 0, (function*() {
              if (!this.workerSources[D] || !this.workerSources[D][N.type] || !this.workerSources[D][N.type][N.source]) return;
              const H = this.workerSources[D][N.type][N.source];
              delete this.workerSources[D][N.type][N.source], H.removeSource !== void 0 && H.removeSource(N)
            })))), this.actor.registerMessageHandler("RM", (D => w._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[D], delete this.availableImages[D], delete this.workerSources[D], delete this.demWorkerSources[D], this.globalStates.delete(D)
            })))), this.actor.registerMessageHandler("SR", ((D, N) => w._(this, void 0, void 0, (function*() {
              this.referrer = N
            })))), this.actor.registerMessageHandler("SRPS", ((D, N) => this._syncRTLPluginState(D, N))), this.actor.registerMessageHandler("IS", ((D, N) => w._(this, void 0, void 0, (function*() {
              this.self.importScripts(N)
            })))), this.actor.registerMessageHandler("SI", ((D, N) => this._setImages(D, N))), this.actor.registerMessageHandler("UL", ((D, N) => w._(this, void 0, void 0, (function*() {
              this._getLayerIndex(D).update(N.layers, N.removedIds, this._getGlobalState(D))
            })))), this.actor.registerMessageHandler("UGS", ((D, N) => w._(this, void 0, void 0, (function*() {
              const H = this._getGlobalState(D);
              for (const W in N) H[W] = N[W]
            })))), this.actor.registerMessageHandler("SL", ((D, N) => w._(this, void 0, void 0, (function*() {
              this._getLayerIndex(D).replace(N, this._getGlobalState(D))
            }))))
          }
          _getGlobalState(E) {
            let D = this.globalStates.get(E);
            return D || (D = {}, this.globalStates.set(E, D)), D
          }
          _setImages(E, D) {
            return w._(this, void 0, void 0, (function*() {
              this.availableImages[E] = D;
              for (const N in this.workerSources[E]) {
                const H = this.workerSources[E][N];
                for (const W in H) H[W].availableImages = D
              }
            }))
          }
          _syncRTLPluginState(E, D) {
            return w._(this, void 0, void 0, (function*() {
              return yield w.c_.syncState(D, this.self.importScripts)
            }))
          }
          _getAvailableImages(E) {
            let D = this.availableImages[E];
            return D || (D = []), D
          }
          _getLayerIndex(E) {
            let D = this.layerIndexes[E];
            return D || (D = this.layerIndexes[E] = new s), D
          }
          _getWorkerSource(E, D, N) {
            if (this.workerSources[E] || (this.workerSources[E] = {}), this.workerSources[E][D] || (this.workerSources[E][D] = {}), !this.workerSources[E][D][N]) {
              const H = {
                sendAsync: (W, ce) => (W.targetMapId = E, this.actor.sendAsync(W, ce))
              };
              switch (D) {
                case "vector":
                  this.workerSources[E][D][N] = new ee(H, this._getLayerIndex(E), this._getAvailableImages(E));
                  break;
                case "geojson":
                  this.workerSources[E][D][N] = new Et(H, this._getLayerIndex(E), this._getAvailableImages(E));
                  break;
                default:
                  this.workerSources[E][D][N] = new this.externalWorkerSourceTypes[D](H, this._getLayerIndex(E), this._getAvailableImages(E))
              }
            }
            return this.workerSources[E][D][N]
          }
          _getDEMWorkerSource(E, D) {
            return this.demWorkerSources[E] || (this.demWorkerSources[E] = {}), this.demWorkerSources[E][D] || (this.demWorkerSources[E][D] = new re), this.demWorkerSources[E][D]
          }
        }
        return w.i(self) && (self.worker = new Te(self)), Te
      })), A("index", ["exports", "./shared"], (function(w, s) {
        var B = "5.11.0";

        function j() {
          var h = new s.A(4);
          return s.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h
        }
        let K, ee;
        const re = {
            frame(h, e, i) {
              const l = requestAnimationFrame((d => {
                  u(), e(d)
                })),
                {
                  unsubscribe: u
                } = s.s(h.signal, "abort", (() => {
                  u(), cancelAnimationFrame(l), i(s.c())
                }), !1)
            },
            frameAsync(h) {
              return new Promise(((e, i) => {
                this.frame(h, e, i)
              }))
            },
            getImageData(h, e = 0) {
              return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
            },
            getImageCanvasContext(h) {
              const e = window.document.createElement("canvas"),
                i = e.getContext("2d", {
                  willReadFrequently: !0
                });
              if (!i) throw new Error("failed to create canvas 2d context");
              return e.width = h.width, e.height = h.height, i.drawImage(h, 0, 0, h.width, h.height), i
            },
            resolveURL: h => (K || (K = document.createElement("a")), K.href = h, K.href),
            hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && (ee == null && (ee = matchMedia("(prefers-reduced-motion: reduce)")), ee.matches)
            }
          },
          de = new class {
            constructor() {
              this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null
            }
            getCurrentTime() {
              return this._frozenAt !== null ? this._frozenAt : this._realTime()
            }
            setNow(h) {
              this._frozenAt = h
            }
            restoreNow() {
              this._frozenAt = null
            }
            isFrozen() {
              return this._frozenAt !== null
            }
          };

        function ne() {
          return de.getCurrentTime()
        }
        class Y {
          static testProp(e) {
            if (!Y.docStyle) return e[0];
            for (let i = 0; i < e.length; i++)
              if (e[i] in Y.docStyle) return e[i];
            return e[0]
          }
          static create(e, i, l) {
            const u = window.document.createElement(e);
            return i !== void 0 && (u.className = i), l && l.appendChild(u), u
          }
          static createNS(e, i) {
            return window.document.createElementNS(e, i)
          }
          static disableDrag() {
            Y.docStyle && Y.selectProp && (Y.userSelect = Y.docStyle[Y.selectProp], Y.docStyle[Y.selectProp] = "none")
          }
          static enableDrag() {
            Y.docStyle && Y.selectProp && (Y.docStyle[Y.selectProp] = Y.userSelect)
          }
          static setTransform(e, i) {
            e.style[Y.transformProp] = i
          }
          static addEventListener(e, i, l, u = {}) {
            e.addEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static removeEventListener(e, i, l, u = {}) {
            e.removeEventListener(i, l, "passive" in u ? u : u.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Y.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", Y.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", Y.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const i = e.getBoundingClientRect();
            return {
              x: i.width / e.offsetWidth || 1,
              y: i.height / e.offsetHeight || 1,
              boundingClientRect: i
            }
          }
          static getPoint(e, i, l) {
            const u = i.boundingClientRect;
            return new s.P((l.clientX - u.left) / i.x - e.clientLeft, (l.clientY - u.top) / i.y - e.clientTop)
          }
          static mousePos(e, i) {
            const l = Y.getScale(e);
            return Y.getPoint(e, l, i)
          }
          static touchPos(e, i) {
            const l = [],
              u = Y.getScale(e);
            for (let d = 0; d < i.length; d++) l.push(Y.getPoint(e, u, i[d]));
            return l
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              l = i.querySelectorAll("script");
            for (const u of l) u.remove();
            return Y.clean(i), i.innerHTML
          }
          static isPossiblyDangerous(e, i) {
            const l = i.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !l.includes("javascript:") && !l.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const i = e.children;
            for (const l of i) Y.removeAttributes(l), Y.clean(l)
          }
          static removeAttributes(e) {
            for (const {
                name: i,
                value: l
              }
              of e.attributes) Y.isPossiblyDangerous(i, l) && e.removeAttribute(i)
          }
        }
        Y.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Y.selectProp = Y.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Y.transformProp = Y.testProp(["transform", "WebkitTransform"]);
        const we = {
          supported: !1,
          testSupport: function(h) {
            !Re && ze && (ke ? qe(h) : Ie = h)
          }
        };
        let Ie, ze, Re = !1,
          ke = !1;

        function qe(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, ze), h.isContextLost()) return;
            we.supported = !0
          } catch {}
          h.deleteTexture(e), Re = !0
        }
        var $e;
        typeof document < "u" && (ze = document.createElement("img"), ze.onload = () => {
          Ie && qe(Ie), Ie = null, ke = !0
        }, ze.onerror = () => {
          Re = !0, Ie = null
        }, ze.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(h) {
          let e, i, l, u;
          h.resetRequestQueue = () => {
            e = [], i = 0, l = 0, u = {}
          }, h.addThrottleControl = S => {
            const k = l++;
            return u[k] = S, k
          }, h.removeThrottleControl = S => {
            delete u[S], g()
          }, h.getImage = (S, k, z = !0) => new Promise(((V, F) => {
            we.supported && (S.headers || (S.headers = {}), S.headers.accept = "image/webp,*/*"), s.e(S, {
              type: "image"
            }), e.push({
              abortController: k,
              requestParameters: S,
              supportImageRefresh: z,
              state: "queued",
              onError: $ => {
                F($)
              },
              onSuccess: $ => {
                V($)
              }
            }), g()
          }));
          const d = S => s._(this, void 0, void 0, (function*() {
              S.state = "running";
              const {
                requestParameters: k,
                supportImageRefresh: z,
                onError: V,
                onSuccess: F,
                abortController: $
              } = S, J = z === !1 && !s.i(self) && !s.g(k.url) && (!k.headers || Object.keys(k.headers).reduce(((se, fe) => se && fe === "accept"), !0));
              i++;
              const ae = J ? T(k, $) : s.m(k, $);
              try {
                const se = yield ae;
                delete S.abortController, S.state = "completed", se.data instanceof HTMLImageElement || s.b(se.data) ? F(se) : se.data && F({
                  data: yield(oe = se.data, typeof createImageBitmap == "function" ? s.f(oe) : s.h(oe)),
                  cacheControl: se.cacheControl,
                  expires: se.expires
                })
              } catch (se) {
                delete S.abortController, V(se)
              } finally {
                i--, g()
              }
              var oe
            })),
            g = () => {
              const S = (() => {
                for (const k of Object.keys(u))
                  if (u[k]()) return !0;
                return !1
              })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let k = i; k < S && e.length > 0; k++) {
                const z = e.shift();
                z.abortController.signal.aborted ? k-- : d(z)
              }
            },
            T = (S, k) => new Promise(((z, V) => {
              const F = new Image,
                $ = S.url,
                J = S.credentials;
              J && J === "include" ? F.crossOrigin = "use-credentials" : (J && J === "same-origin" || !s.d($)) && (F.crossOrigin = "anonymous"), k.signal.addEventListener("abort", (() => {
                F.src = "", V(s.c())
              })), F.fetchPriority = "high", F.onload = () => {
                F.onerror = F.onload = null, z({
                  data: F
                })
              }, F.onerror = () => {
                F.onerror = F.onload = null, k.signal.aborted || V(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, F.src = $
            }))
        })($e || ($e = {})), $e.resetRequestQueue();
        class Be {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, i) {
            return this._transformRequestFn && this._transformRequestFn(e, i) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function Ee(h) {
          const e = [];
          if (typeof h == "string") e.push({
            id: "default",
            url: h
          });
          else if (h && h.length > 0) {
            const i = [];
            for (const {
                id: l,
                url: u
              }
              of h) {
              const d = `${l}${u}`;
              i.indexOf(d) === -1 && (i.push(d), e.push({
                id: l,
                url: u
              }))
            }
          }
          return e
        }

        function He(h, e, i) {
          try {
            const l = new URL(h);
            return l.pathname += `${e}${i}`, l.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function Le(h) {
          const {
            userImage: e
          } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class it extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: i,
                  promiseResolve: l
                }
                of this.requestors) l(this._getImagesForIds(i));
              this.requestors = []
            }
          }
          getImage(e) {
            const i = this.images[e];
            if (i && !i.data && i.spriteData) {
              const l = i.spriteData;
              i.data = new s.R({
                width: l.width,
                height: l.height
              }, l.context.getImageData(l.x, l.y, l.width, l.height).data), i.spriteData = null
            }
            return i
          }
          addImage(e, i) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, i) && (this.images[e] = i)
          }
          _validate(e, i) {
            let l = !0;
            const u = i.data || i.spriteData;
            return this._validateStretch(i.stretchX, u && u.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), l = !1), this._validateStretch(i.stretchY, u && u.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), l = !1), this._validateContent(i.content, i) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), l = !1), l
          }
          _validateStretch(e, i) {
            if (!e) return !0;
            let l = 0;
            for (const u of e) {
              if (u[0] < l || u[1] < u[0] || i < u[1]) return !1;
              l = u[1]
            }
            return !0
          }
          _validateContent(e, i) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const l = i.spriteData,
              u = l && l.width || i.data.width,
              d = l && l.height || i.data.height;
            return !(e[0] < 0 || u < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || u < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, i, l = !0) {
            const u = this.getImage(e);
            if (l && (u.data.width !== i.data.width || u.data.height !== i.data.height)) throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${i.data.width}x${i.data.height}).`);
            i.version = u.version + 1, this.images[e] = i, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const i = this.images[e];
            delete this.images[e], delete this.patterns[e], i.userImage && i.userImage.onRemove && i.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((i, l) => {
              let u = !0;
              if (!this.isLoaded())
                for (const d of e) this.images[d] || (u = !1);
              this.isLoaded() || u ? i(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: i
              })
            }))
          }
          _getImagesForIds(e) {
            const i = {};
            for (const l of e) {
              let u = this.getImage(l);
              u || (this.fire(new s.l("styleimagemissing", {
                id: l
              })), u = this.getImage(l)), u ? i[l] = {
                data: u.data.clone(),
                pixelRatio: u.pixelRatio,
                sdf: u.sdf,
                version: u.version,
                stretchX: u.stretchX,
                stretchY: u.stretchY,
                content: u.content,
                textFitWidth: u.textFitWidth,
                textFitHeight: u.textFitHeight,
                hasRenderCallback: !!(u.userImage && u.userImage.render)
              } : s.w(`Image "${l}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return i
          }
          getPixelSize() {
            const {
              width: e,
              height: i
            } = this.atlasImage;
            return {
              width: e,
              height: i
            }
          }
          getPattern(e) {
            const i = this.patterns[e],
              l = this.getImage(e);
            if (!l) return null;
            if (i && i.position.version === l.version) return i.position;
            if (i) i.position.version = l.version;
            else {
              const u = {
                  w: l.data.width + 2,
                  h: l.data.height + 2,
                  x: 0,
                  y: 0
                },
                d = new s.I(u, l);
              this.patterns[e] = {
                bin: u,
                position: d
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const i = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new s.T(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const d in this.patterns) e.push(this.patterns[d].bin);
            const {
              w: i,
              h: l
            } = s.p(e), u = this.atlasImage;
            u.resize({
              width: i || 1,
              height: l || 1
            });
            for (const d in this.patterns) {
              const {
                bin: g
              } = this.patterns[d], T = g.x + 1, S = g.y + 1, k = this.getImage(d).data, z = k.width, V = k.height;
              s.R.copy(k, u, {
                x: 0,
                y: 0
              }, {
                x: T,
                y: S
              }, {
                width: z,
                height: V
              }), s.R.copy(k, u, {
                x: 0,
                y: V - 1
              }, {
                x: T,
                y: S - 1
              }, {
                width: z,
                height: 1
              }), s.R.copy(k, u, {
                x: 0,
                y: 0
              }, {
                x: T,
                y: S + V
              }, {
                width: z,
                height: 1
              }), s.R.copy(k, u, {
                x: z - 1,
                y: 0
              }, {
                x: T - 1,
                y: S
              }, {
                width: 1,
                height: V
              }), s.R.copy(k, u, {
                x: 0,
                y: 0
              }, {
                x: T + z,
                y: S
              }, {
                width: 1,
                height: V
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const i of e) {
              if (this.callbackDispatchedThisFrame[i]) continue;
              this.callbackDispatchedThisFrame[i] = !0;
              const l = this.getImage(i);
              l || s.w(`Image with ID: "${i}" was not found`), Le(l) && this.updateImage(i, l)
            }
          }
        }
        const pt = 1e20;

        function Oe(h, e, i, l, u, d, g, T, S) {
          for (let k = e; k < e + l; k++) Je(h, i * d + k, d, u, g, T, S);
          for (let k = i; k < i + u; k++) Je(h, k * d + e, 1, l, g, T, S)
        }

        function Je(h, e, i, l, u, d, g) {
          d[0] = 0, g[0] = -pt, g[1] = pt, u[0] = h[e];
          for (let T = 1, S = 0, k = 0; T < l; T++) {
            u[T] = h[e + T * i];
            const z = T * T;
            do {
              const V = d[S];
              k = (u[T] - u[V] + z - V * V) / (T - V) / 2
            } while (k <= g[S] && --S > -1);
            S++, d[S] = T, g[S] = k, g[S + 1] = pt
          }
          for (let T = 0, S = 0; T < l; T++) {
            for (; g[S + 1] < T;) S++;
            const k = d[S],
              z = T - k;
            h[e + T * i] = u[k] + z * z
          }
        }
        const bt = s.v.layout_symbol["text-font"].default.join(",");
        class We {
          constructor(e, i, l) {
            this.requestManager = e, this.localIdeographFontFamily = i, this.entries = {}, this.lang = l
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = [];
              for (const d in e)
                for (const g of e[d]) i.push(this._getAndCacheGlyphsPromise(d, g));
              const l = yield Promise.all(i), u = {};
              for (const {
                  stack: d,
                  id: g,
                  glyph: T
                }
                of l) u[d] || (u[d] = {}), u[d][g] = T && {
                id: T.id,
                bitmap: T.bitmap.clone(),
                metrics: T.metrics
              };
              return u
            }))
          }
          _getAndCacheGlyphsPromise(e, i) {
            return s._(this, void 0, void 0, (function*() {
              let l = this.entries[e];
              l || (l = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let u = l.glyphs[i];
              return u !== void 0 ? {
                stack: e,
                id: i,
                glyph: u
              } : !this.url || this._charUsesLocalIdeographFontFamily(i) ? (u = l.glyphs[i] = this._drawGlyph(l, e, i), {
                stack: e,
                id: i,
                glyph: u
              }) : yield this._downloadAndCacheRangePromise(e, i)
            }))
          }
          _downloadAndCacheRangePromise(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = Math.floor(i / 256);
              if (256 * l > 65535) throw new Error("glyphs > 65535 not supported");
              const u = this.entries[e];
              if (u.ranges[l]) return {
                stack: e,
                id: i,
                glyph: null
              };
              if (!u.requests[l]) {
                const d = We.loadGlyphRange(e, l, this.url, this.requestManager);
                u.requests[l] = d
              }
              try {
                const d = yield u.requests[l];
                for (const g in d) u.glyphs[+g] = d[+g];
                return u.ranges[l] = !0, {
                  stack: e,
                  id: i,
                  glyph: d[i] || null
                }
              } catch (d) {
                const g = u.glyphs[i] = this._drawGlyph(u, e, i);
                return this._warnOnMissingGlyphRange(g, l, i, d), {
                  stack: e,
                  id: i,
                  glyph: g
                }
              }
            }))
          }
          _warnOnMissingGlyphRange(e, i, l, u) {
            const d = 256 * i,
              g = d + 255,
              T = l.toString(16).padStart(4, "0").toUpperCase();
            s.w(`Unable to load glyph range ${i}, ${d}-${g}. Rendering codepoint U+${T} locally instead. ${u}`)
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e))
          }
          _drawGlyph(e, i, l) {
            const u = i === bt && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(l),
              d = u ? "ideographTinySDF" : "tinySDF";
            e[d] || (e[d] = this._createTinySDF(u ? this.localIdeographFontFamily : i));
            const g = e[d].draw(String.fromCharCode(l));
            return {
              id: l,
              bitmap: new s.q({
                width: g.width || 60,
                height: g.height || 60
              }, g.data),
              metrics: {
                width: g.glyphWidth / 2 || 24,
                height: g.glyphHeight / 2 || 24,
                left: g.glyphLeft / 2 + .5 || 0,
                top: g.glyphTop / 2 - 27.5 || -8,
                advance: g.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
          _createTinySDF(e) {
            const i = e ? e.split(",") : [];
            i.push("sans-serif");
            const l = i.map((u => /[-\w]+/.test(u) ? u : `'${CSS.escape(u)}'`)).join(",");
            return new We.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: .25,
              fontFamily: l,
              fontWeight: this._fontWeight(i[0]),
              fontStyle: this._fontStyle(i[0]),
              lang: this.lang
            })
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal"
          }
          _fontWeight(e) {
            const i = {
              thin: 100,
              hairline: 100,
              "extra light": 200,
              "ultra light": 200,
              light: 300,
              normal: 400,
              regular: 400,
              medium: 500,
              semibold: 600,
              demibold: 600,
              bold: 700,
              "extra bold": 800,
              "ultra bold": 800,
              black: 900,
              heavy: 900,
              "extra black": 950,
              "ultra black": 950
            };
            let l;
            for (const [u, d] of Object.entries(i)) new RegExp(`\\b${u}\\b`, "i").test(e) && (l = `${d}`);
            return l
          }
        }
        We.loadGlyphRange = function(h, e, i, l) {
          return s._(this, void 0, void 0, (function*() {
            const u = 256 * e,
              d = u + 255,
              g = l.transformRequest(i.replace("{fontstack}", h).replace("{range}", `${u}-${d}`), "Glyphs"),
              T = yield s.n(g, new AbortController);
            if (!T || !T.data) throw new Error(`Could not load glyph range. range: ${e}, ${u}-${d}`);
            const S = {};
            for (const k of s.o(T.data)) S[k.id] = k;
            return S
          }))
        }, We.TinySDF = class {
          constructor({
            fontSize: h = 24,
            buffer: e = 3,
            radius: i = 8,
            cutoff: l = .25,
            fontFamily: u = "sans-serif",
            fontWeight: d = "normal",
            fontStyle: g = "normal",
            lang: T = null
          } = {}) {
            this.buffer = e, this.cutoff = l, this.radius = i, this.lang = T;
            const S = this.size = h + 4 * e,
              k = this._createCanvas(S),
              z = this.ctx = k.getContext("2d", {
                willReadFrequently: !0
              });
            z.font = `${g} ${d} ${h}px ${u}`, z.textBaseline = "alphabetic", z.textAlign = "left", z.fillStyle = "black", this.gridOuter = new Float64Array(S * S), this.gridInner = new Float64Array(S * S), this.f = new Float64Array(S), this.z = new Float64Array(S + 1), this.v = new Uint16Array(S)
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e
          }
          draw(h) {
            const {
              width: e,
              actualBoundingBoxAscent: i,
              actualBoundingBoxDescent: l,
              actualBoundingBoxLeft: u,
              actualBoundingBoxRight: d
            } = this.ctx.measureText(h), g = Math.ceil(i), T = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - u))), S = Math.min(this.size - this.buffer, g + Math.ceil(l)), k = T + 2 * this.buffer, z = S + 2 * this.buffer, V = Math.max(k * z, 0), F = new Uint8ClampedArray(V), $ = {
              data: F,
              width: k,
              height: z,
              glyphWidth: T,
              glyphHeight: S,
              glyphTop: g,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (T === 0 || S === 0) return $;
            const {
              ctx: J,
              buffer: ae,
              gridInner: oe,
              gridOuter: se
            } = this;
            this.lang && (J.lang = this.lang), J.clearRect(ae, ae, T, S), J.fillText(h, ae, ae + g);
            const fe = J.getImageData(ae, ae, T, S);
            se.fill(pt, 0, V), oe.fill(0, 0, V);
            for (let xe = 0; xe < S; xe++)
              for (let pe = 0; pe < T; pe++) {
                const be = fe.data[4 * (xe * T + pe) + 3] / 255;
                if (be === 0) continue;
                const Pe = (xe + ae) * k + pe + ae;
                if (be === 1) se[Pe] = 0, oe[Pe] = pt;
                else {
                  const ge = .5 - be;
                  se[Pe] = ge > 0 ? ge * ge : 0, oe[Pe] = ge < 0 ? ge * ge : 0
                }
              }
            Oe(se, 0, 0, k, z, k, this.f, this.v, this.z), Oe(oe, ae, ae, T, S, k, this.f, this.v, this.z);
            for (let xe = 0; xe < V; xe++) {
              const pe = Math.sqrt(se[xe]) - Math.sqrt(oe[xe]);
              F[xe] = Math.round(255 - 255 * (pe / this.radius + this.cutoff))
            }
            return $
          }
        };
        class Ue {
          constructor() {
            this.specification = s.t.light.position
          }
          possiblyEvaluate(e, i) {
            return s.C(e.expression.evaluate(i))
          }
          interpolate(e, i, l) {
            return {
              x: s.F.number(e.x, i.x, l),
              y: s.F.number(e.y, i.y, l),
              z: s.F.number(e.z, i.z, l)
            }
          }
        }
        let Ge;
        class Ve extends s.E {
          constructor(e) {
            super(), Ge = Ge || new s.r({
              anchor: new s.D(s.t.light.anchor),
              position: new Ue,
              color: new s.D(s.t.light.color),
              intensity: new s.D(s.t.light.intensity)
            }), this._transitionable = new s.x(Ge, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, i = {}) {
            if (!this._validate(s.y, e, i))
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l) {
            return (!l || l.validate !== !1) && s.z(this, e.call(s.B, {
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            }))
          }
        }
        const mt = new s.r({
          "sky-color": new s.D(s.t.sky["sky-color"]),
          "horizon-color": new s.D(s.t.sky["horizon-color"]),
          "fog-color": new s.D(s.t.sky["fog-color"]),
          "fog-ground-blend": new s.D(s.t.sky["fog-ground-blend"]),
          "horizon-fog-blend": new s.D(s.t.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new s.D(s.t.sky["sky-horizon-blend"]),
          "atmosphere-blend": new s.D(s.t.sky["atmosphere-blend"])
        });
        class lt extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(mt, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0))
          }
          setSky(e, i = {}) {
            if (!this._validate(s.H, e, i)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const l in e) {
                const u = e[l];
                l.endsWith("-transition") ? this._transitionable.setTransition(l.slice(0, -11), u) : this._transitionable.setValue(l, u)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, i, l = {}) {
            return (l == null ? void 0 : l.validate) !== !1 && s.z(this, e.call(s.B, s.e({
              value: i,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class yt {
          constructor(e, i) {
            this.width = e, this.height = i, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, i) {
            const l = e.join(",") + String(i);
            return this.dashEntry[l] || (this.dashEntry[l] = this.addDash(e, i)), this.dashEntry[l]
          }
          getDashRanges(e, i, l) {
            const u = [];
            let d = e.length % 2 == 1 ? -e[e.length - 1] * l : 0,
              g = e[0] * l,
              T = !0;
            u.push({
              left: d,
              right: g,
              isDash: T,
              zeroLength: e[0] === 0
            });
            let S = e[0];
            for (let k = 1; k < e.length; k++) {
              T = !T;
              const z = e[k];
              d = S * l, S += z, g = S * l, u.push({
                left: d,
                right: g,
                isDash: T,
                zeroLength: z === 0
              })
            }
            return u
          }
          addRoundDash(e, i, l) {
            const u = i / 2;
            for (let d = -l; d <= l; d++) {
              const g = this.width * (this.nextRow + l + d);
              let T = 0,
                S = e[T];
              for (let k = 0; k < this.width; k++) {
                k / S.right > 1 && (S = e[++T]);
                const z = Math.abs(k - S.left),
                  V = Math.abs(k - S.right),
                  F = Math.min(z, V);
                let $;
                const J = d / l * (u + 1);
                if (S.isDash) {
                  const ae = u - Math.abs(J);
                  $ = Math.sqrt(F * F + ae * ae)
                } else $ = u - Math.sqrt(F * F + J * J);
                this.data[g + k] = Math.max(0, Math.min(255, $ + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let T = e.length - 1; T >= 0; --T) {
              const S = e[T],
                k = e[T + 1];
              S.zeroLength ? e.splice(T, 1) : k && k.isDash === S.isDash && (k.left = S.left, e.splice(T, 1))
            }
            const i = e[0],
              l = e[e.length - 1];
            i.isDash === l.isDash && (i.left = l.left - this.width, l.right = i.right + this.width);
            const u = this.width * this.nextRow;
            let d = 0,
              g = e[d];
            for (let T = 0; T < this.width; T++) {
              T / g.right > 1 && (g = e[++d]);
              const S = Math.abs(T - g.left),
                k = Math.abs(T - g.right),
                z = Math.min(S, k);
              this.data[u + T] = Math.max(0, Math.min(255, (g.isDash ? z : -z) + 128))
            }
          }
          addDash(e, i) {
            const l = i ? 7 : 0,
              u = 2 * l + 1;
            if (this.nextRow + u > this.height) return s.w("LineAtlas out of space"), null;
            let d = 0;
            for (let T = 0; T < e.length; T++) d += e[T];
            if (d !== 0) {
              const T = this.width / d,
                S = this.getDashRanges(e, this.width, T);
              i ? this.addRoundDash(S, T, l) : this.addRegularDash(S)
            }
            const g = {
              y: this.nextRow + l,
              height: 2 * l,
              width: d
            };
            return this.nextRow += u, this.dirty = !0, g
          }
          bind(e) {
            const i = e.gl;
            this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data))
          }
        }
        const _t = "maplibre_preloaded_worker_pool";
        class ut {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < ut.workerCount;) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((i => {
              i.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[_t]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const Ut = Math.floor(re.hardwareConcurrency / 2);
        let Lt, Ke;

        function ot() {
          return Lt || (Lt = new ut), Lt
        }
        ut.workerCount = s.J(globalThis) ? Math.max(Math.min(Ut, 3), 1) : 1;
        class xt {
          constructor(e, i) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i;
            const l = this.workerPool.acquire(i);
            for (let u = 0; u < l.length; u++) {
              const d = new s.K(l[u], i);
              d.name = `Worker ${u}`, this.actors.push(d)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, i) {
            const l = [];
            for (const u of this.actors) l.push(u.sendAsync({
              type: e,
              data: i
            }));
            return Promise.all(l)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((i => {
              i.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, i) {
            for (const l of this.actors) l.registerMessageHandler(e, i)
          }
        }

        function Ct() {
          return Ke || (Ke = new xt(ot(), s.L), Ke.registerMessageHandler("GR", ((h, e, i) => s.m(e, i)))), Ke
        }

        function wt(h, e) {
          const i = s.M();
          return s.N(i, i, [1, 1, 0]), s.O(i, i, [.5 * h.width, .5 * h.height, 1]), h.calculatePosMatrix ? s.Q(i, i, h.calculatePosMatrix(e.toUnwrapped())) : i
        }

        function kt(h, e, i, l, u, d, g) {
          var T;
          const S = (function(F, $, J) {
              if (F)
                for (const ae of F) {
                  const oe = $[ae];
                  if (oe && oe.source === J && oe.type === "fill-extrusion") return !0
                } else
                  for (const ae in $) {
                    const oe = $[ae];
                    if (oe.source === J && oe.type === "fill-extrusion") return !0
                  }
              return !1
            })((T = u == null ? void 0 : u.layers) !== null && T !== void 0 ? T : null, e, h.id),
            k = d.maxPitchScaleFactor(),
            z = h.tilesIn(l, k, S);
          z.sort(Zt);
          const V = [];
          for (const F of z) V.push({
            wrappedTileID: F.tileID.wrapped().key,
            queryResults: F.tile.queryRenderedFeatures(e, i, h.getState(), F.queryGeometry, F.cameraQueryGeometry, F.scale, u, d, k, wt(d, F.tileID), g ? ($, J) => g(F.tileID, $, J) : void 0)
          });
          return (function(F, $) {
            for (const J in F)
              for (const ae of F[J]) Nt(ae, $);
            return F
          })((function(F) {
            const $ = {},
              J = {};
            for (const ae of F) {
              const oe = ae.queryResults,
                se = ae.wrappedTileID,
                fe = J[se] = J[se] || {};
              for (const xe in oe) {
                const pe = oe[xe],
                  be = fe[xe] = fe[xe] || {},
                  Pe = $[xe] = $[xe] || [];
                for (const ge of pe) be[ge.featureIndex] || (be[ge.featureIndex] = !0, Pe.push(ge))
              }
            }
            return $
          })(V), h)
        }

        function Zt(h, e) {
          const i = h.tileID,
            l = e.tileID;
          return i.overscaledZ - l.overscaledZ || i.canonical.y - l.canonical.y || i.wrap - l.wrap || i.canonical.x - l.canonical.x
        }

        function Nt(h, e) {
          const i = h.feature,
            l = e.getFeatureState(i.layer["source-layer"], i.id);
          i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = l
        }

        function $t(h, e, i) {
          return s._(this, void 0, void 0, (function*() {
            let l = h;
            if (h.url ? l = (yield s.j(e.transformRequest(h.url, "Source"), i)).data : yield re.frameAsync(i), !l) return null;
            const u = s.S(s.e(l, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in l && l.vector_layers && (u.vectorLayerIds = l.vector_layers.map((d => d.id))), u
          }))
        }
        class It {
          constructor(e, i) {
            e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          extend(e) {
            const i = this._sw,
              l = this._ne;
            let u, d;
            if (e instanceof s.U) u = e, d = e;
            else {
              if (!(e instanceof It)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(It.convert(e)) : this.extend(s.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.U.convert(e)) : this;
              if (u = e._sw, d = e._ne, !u || !d) return this
            }
            return i || l ? (i.lng = Math.min(u.lng, i.lng), i.lat = Math.min(u.lat, i.lat), l.lng = Math.max(d.lng, l.lng), l.lat = Math.max(d.lat, l.lat)) : (this._sw = new s.U(u.lng, u.lat), this._ne = new s.U(d.lng, d.lat)), this
          }
          getCenter() {
            return new s.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new s.U(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new s.U(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: i,
              lat: l
            } = s.U.convert(e);
            let u = this._sw.lng <= i && i <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (u = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= l && l <= this._ne.lat && u
          }
          intersects(e) {
            if ((e = It.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const i = s.V(this.getWest(), -180, 180),
              l = s.V(this.getEast(), -180, 180),
              u = s.V(e.getWest(), -180, 180),
              d = s.V(e.getEast(), -180, 180),
              g = i > l,
              T = u > d;
            return !(!g || !T) || (g ? d >= i || u <= l : T ? l >= u || i <= d : !(u > l || d < i))
          }
          static convert(e) {
            return e instanceof It ? e : e && new It(e)
          }
          static fromLngLat(e, i = 0) {
            const l = 360 * i / 40075017,
              u = l / Math.cos(Math.PI / 180 * e.lat);
            return new It(new s.U(e.lng - u, e.lat - l), new s.U(e.lng + u, e.lat + l))
          }
          adjustAntiMeridian() {
            const e = new s.U(this._sw.lng, this._sw.lat),
              i = new s.U(this._ne.lng, this._ne.lat);
            return new It(e, e.lng > i.lng ? new s.U(i.lng + 360, i.lat) : i)
          }
        }
        class Xt {
          constructor(e, i, l) {
            this.bounds = It.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = l || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const i = Math.pow(2, e.z),
              l = Math.floor(s.X(this.bounds.getWest()) * i),
              u = Math.floor(s.W(this.bounds.getNorth()) * i),
              d = Math.ceil(s.X(this.bounds.getEast()) * i),
              g = Math.ceil(s.W(this.bounds.getSouth()) * i);
            return e.x >= l && e.x < d && e.y >= u && e.y < g
          }
        }
        class Ot extends s.E {
          constructor(e, i, l, u) {
            if (super(), this.id = e, this.dispatcher = l, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.e(this, s.S(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({
                type: "vector"
              }, i), this._collectResourceTiming = i.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(u)
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield $t(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new Xt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return s.e({}, this._options)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = {
                  request: this.map._requestManager.transformRequest(i, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                };
              l.request.collectResourceTiming = this._collectResourceTiming;
              let u = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((d, g) => {
                  e.reloadPromise = {
                    resolve: d,
                    reject: g
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), u = "LT";
              e.abortController = new AbortController;
              try {
                const d = yield e.actor.sendAsync({
                  type: u,
                  data: l
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, d)
              } catch (d) {
                if (delete e.abortController, e.aborted) return;
                if (d && d.status !== 404) throw d;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, i) {
            if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), i && this.map._refreshExpiredTiles && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), e.reloadPromise) {
              const l = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(l.resolve).catch(l.reject)
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class jt extends s.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.dispatcher = l, this.setEventedParent(u), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.e({
              type: "raster"
            }, i), s.e(this, s.S(i, ["url", "scheme", "tileSize"]))
          }
          load() {
            return s._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const i = yield $t(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, i && (s.e(this, i), i.bounds && (this.tileBounds = new Xt(i.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (i) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return s.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const l = yield $e.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (l && l.data) {
                  this.map._refreshExpiredTiles && (l.cacheControl || l.expires) && e.setExpiryData({
                    cacheControl: l.cacheControl,
                    expires: l.expires
                  });
                  const u = this.map.painter.context,
                    d = u.gl,
                    g = l.data;
                  e.texture = this.map.painter.getTileTexture(g.width), e.texture ? e.texture.update(g, {
                    useMipmap: !0
                  }) : (e.texture = new s.T(u, g, d.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (l) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (l) throw e.state = "errored", l
              }
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class qt extends jt {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({
              type: "raster-dem"
            }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                l = this.map._requestManager.transformRequest(i, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const u = yield $e.getImage(l, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (u && u.data) {
                  const d = u.data;
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                    cacheControl: u.cacheControl,
                    expires: u.expires
                  });
                  const g = s.b(d) && s.Y() ? d : yield this.readImageNow(d), T = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: g,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const S = yield e.actor.sendAsync({
                      type: "LDT",
                      data: T
                    });
                    e.dem = S, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u
              }
            }))
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && s.Z()) {
                const i = e.width + 2,
                  l = e.height + 2;
                try {
                  return new s.R({
                    width: i,
                    height: l
                  }, yield s.$(e, -1, -1, i, l))
                } catch {}
              }
              return re.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const i = e.canonical,
              l = Math.pow(2, i.z),
              u = (i.x - 1 + l) % l,
              d = i.x === 0 ? e.wrap - 1 : e.wrap,
              g = (i.x + 1 + l) % l,
              T = i.x + 1 === l ? e.wrap + 1 : e.wrap,
              S = {};
            return S[new s.a0(e.overscaledZ, d, i.z, u, i.y).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, T, i.z, g, i.y).key] = {
              backfilled: !1
            }, i.y > 0 && (S[new s.a0(e.overscaledZ, d, i.z, u, i.y - 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, T, i.z, g, i.y - 1).key] = {
              backfilled: !1
            }), i.y + 1 < l && (S[new s.a0(e.overscaledZ, d, i.z, u, i.y + 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, T, i.z, g, i.y + 1).key] = {
              backfilled: !1
            }), S
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }

        function fr(h) {
          return h.type === "GeometryCollection" ? h.geometries.map((e => e.coordinates)).flat(1 / 0) : h.coordinates.flat(1 / 0)
        }

        function Kt(h) {
          const e = new It;
          let i;
          switch (h.type) {
            case "FeatureCollection":
              i = h.features.map((l => fr(l.geometry))).flat(1 / 0);
              break;
            case "Feature":
              i = fr(h.geometry);
              break;
            default:
              i = fr(h)
          }
          if (i.length == 0) return e;
          for (let l = 0; l < i.length - 1; l += 2) e.extend([i[l], i[l + 1]]);
          return e
        }
        class _r extends s.E {
          constructor(e, i, l, u) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: i.data
            }, this.actor = l.getActor(), this.setEventedParent(u), this._data = i.data, this._options = s.e({}, i), this._collectResourceTiming = i.collectResourceTiming, i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = s.e({
              source: this.id,
              cluster: i.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128),
                tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : .375),
                extent: s.a3,
                maxZoom: this.maxzoom,
                lineMetrics: i.lineMetrics || !1,
                generateId: i.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
                minPoints: Math.max(2, i.clusterMinPoints || 2),
                extent: s.a3,
                radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                log: !1,
                generateId: i.generateId || !1
              },
              clusterProperties: i.clusterProperties,
              filter: i.filter
            }, i.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged
          }
          _pixelsToTileUnits(e) {
            return e * (s.a3 / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const i = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${i}"`), i
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return s._(this, void 0, void 0, (function*() {
              const e = s.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getBounds() {
            return s._(this, void 0, void 0, (function*() {
              return Kt(yield this.getData())
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, i, l) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: i,
                offset: l
              }
            })
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void s.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const {
                data: e,
                diff: i
              } = this._pendingWorkerUpdate, l = s.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (l.request = this.map._requestManager.transformRequest(re.resolveURL(e), "Source"), l.request.collectResourceTiming = this._collectResourceTiming) : l.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : i && (l.dataDiff = i, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new s.l("dataloading", {
                dataType: "source"
              }));
              try {
                const u = yield this.actor.sendAsync({
                  type: "LD",
                  data: l
                });
                if (this._isUpdatingWorker = !1, this._removed || u.abandoned) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this._data = u.data;
                let d = null;
                u.resourceTiming && u.resourceTiming[this.id] && (d = u.resourceTiming[this.id].slice(0));
                const g = {
                  dataType: "source"
                };
                this._collectResourceTiming && d && d.length > 0 && s.e(g, {
                  resourceTiming: d
                }), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "metadata"
                }))), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "content",
                  shouldReloadTileOptions: this._getShouldReloadTileOptions(i)
                })))
              } catch (u) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new s.k(u))
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData()
              }
            }))
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const {
              add: i = [],
              update: l = [],
              remove: u = []
            } = e || {}, d = new Set([...l.map((g => g.id)), ...u]);
            return {
              nextBounds: [...l.map((g => g.newGeometry)), ...i.map((g => g.geometry))].map((g => Kt(g))),
              prevIds: d
            }
          }
          shouldReloadTile(e, {
            nextBounds: i,
            prevIds: l
          }) {
            const u = e.latestFeatureIndex.loadVTLayers();
            for (let S = 0; S < e.latestFeatureIndex.featureIndexArray.length; S++) {
              const k = e.latestFeatureIndex.featureIndexArray.get(S),
                z = u._geojsonTileLayer.feature(k.featureIndex);
              if (l.has(z.id)) return !0
            }
            const {
              buffer: d,
              extent: g
            } = this.workerOptions.geojsonVtOptions, T = (function({
              x: S,
              y: k,
              z
            }, V = 0) {
              const F = s.a1((S - V) / Math.pow(2, z)),
                $ = s.a2((k + 1 + V) / Math.pow(2, z)),
                J = s.a1((S + 1 + V) / Math.pow(2, z)),
                ae = s.a2((k - V) / Math.pow(2, z));
              return new It([F, $], [J, ae])
            })(e.tileID.canonical, d / g);
            for (const S of i)
              if (T.intersects(S)) return !0;
            return !1
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const i = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const l = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
              };
              e.abortController = new AbortController;
              const u = yield this.actor.sendAsync({
                type: i,
                data: l
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(u, this.map.painter, i === "RT")
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return s.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class rr extends s.E {
          constructor(e, i, l, u) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = l, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(u), this.options = i
          }
          load(e) {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const i = yield $e.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, i && i.data && (this.image = i.data, e && (this.coordinates = e), this._finishLoading())
              } catch (i) {
                this._request = null, this._loaded = !0, this.fire(new s.k(i))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const i = e.map(s.a5.fromLngLat);
            var l;
            return this.tileID = (function(u) {
              const d = s.a6.fromPoints(u),
                g = d.width(),
                T = d.height(),
                S = Math.max(g, T),
                k = Math.max(0, Math.floor(-Math.log(S) / Math.LN2)),
                z = Math.pow(2, k);
              return new s.a8(k, Math.floor((d.minX + d.maxX) / 2 * z), Math.floor((d.minY + d.maxY) / 2 * z))
            })(i), this.terrainTileRanges = this._getOverlappingTileRanges(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map((u => this.tileID.getTilePoint(u)._round())), this.flippedWindingOrder = ((l = this.tileCoords)[1].x - l[0].x) * (l[2].y - l[0].y) - (l[1].y - l[0].y) * (l[2].x - l[0].x) < 0, this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const d = this.tiles[u];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, l = !0)
            }
            l && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: i,
              minY: l,
              maxX: u,
              maxY: d
            } = s.a6.fromPoints(e), g = {};
            for (let T = 0; T <= s.a7; T++) {
              const S = Math.pow(2, T),
                k = Math.floor(i * S),
                z = Math.floor(l * S),
                V = Math.floor(u * S),
                F = Math.floor(d * S);
              g[T] = {
                minTileX: k,
                minTileY: z,
                maxTileX: V,
                maxTileY: F
              }
            }
            return g
          }
        }
        class hr extends rr {
          constructor(e, i, l, u) {
            super(e, i, l, u), this.roundZoom = !0, this.type = "video", this.options = i
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, "Source").url);
              try {
                const i = yield s.a9(this.urls);
                if (this._loaded = !0, !i) return;
                this.video = i, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (i) {
                this.fire(new s.k(i))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const i = this.video.seekable;
              e < i.start(0) || e > i.end(0) ? this.fire(new s.k(new s.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              i = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let l = !1;
            for (const u in this.tiles) {
              const d = this.tiles[u];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, l = !0)
            }
            l && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class nr extends rr {
          constructor(e, i, l, u) {
            super(e, i, l, u), i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some((d => !Array.isArray(d) || d.length !== 2 || d.some((g => typeof g != "number")))) || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && typeof i.animate != "boolean" && this.fire(new s.k(new s.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = i.animate === void 0 || i.animate
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const i = this.map.painter.context,
              l = i.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new s.T(i, this.canvas, l.RGBA, {
              premultiply: !0
            });
            let u = !1;
            for (const d in this.tiles) {
              const g = this.tiles[d];
              g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, u = !0)
            }
            u && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const Et = {},
          kr = h => {
            switch (h) {
              case "geojson":
                return _r;
              case "image":
                return rr;
              case "raster":
                return jt;
              case "raster-dem":
                return qt;
              case "vector":
                return Ot;
              case "video":
                return hr;
              case "canvas":
                return nr
            }
            return Et[h]
          },
          Te = "RTLPluginLoaded";
        class O extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Ct()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((i => {
              throw this.status = "error", i
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function*(i, l = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = re.resolveURL(i), !this.url) throw new Error(`requested url ${i} is invalid`);
              if (this.status === "unavailable") {
                if (!l) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(Te))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let E = null;

        function D() {
          return E || (E = new O), E
        }
        var N, H;
        (function(h) {
          h[h.Base = 0] = "Base", h[h.Parent = 1] = "Parent"
        })(N || (N = {})), (function(h) {
          h[h.Departing = 0] = "Departing", h[h.Incoming = 1] = "Incoming"
        })(H || (H = {}));
        class W {
          constructor(e, i) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = s.ab(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade())
          }
          setCrossFadeLogic({
            fadingRole: e,
            fadingDirection: i,
            fadingParentID: l,
            fadeEndTime: u
          }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = i, this.fadingParentID = l, this.fadeEndTime = u
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = ne(), this.fadeEndTime = 0, this.fadeOpacity = 1
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, i, l) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(u, d) {
                const g = {};
                if (!d) return g;
                for (const T of u) {
                  const S = T.layerIds.map((k => d.getLayer(k))).filter(Boolean);
                  if (S.length !== 0) {
                    T.layers = S, T.stateDependentLayerIds && (T.stateDependentLayers = T.stateDependentLayerIds.map((k => S.filter((z => z.id === k))[0])));
                    for (const k of S) g[k.id] = T
                  }
                }
                return g
              })(e.buckets, i == null ? void 0 : i.style), this.hasSymbolBuckets = !1;
              for (const u in this.buckets) {
                const d = this.buckets[u];
                if (d instanceof s.ad) {
                  if (this.hasSymbolBuckets = !0, !l) break;
                  d.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const u in this.buckets) {
                  const d = this.buckets[u];
                  if (d instanceof s.ad && d.hasRTLText) {
                    this.hasRTLText = !0, D().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const u in this.buckets) {
                const d = this.buckets[u];
                this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(u).queryRadius(d))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions
            } else this.collisionBoxArray = new s.ac
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const l in this.buckets) {
              const u = this.buckets[l];
              u.uploadPending() && u.upload(e)
            }
            const i = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, i, l, u, d, g, T, S, k, z, V) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: u,
              cameraQueryGeometry: d,
              scale: g,
              tileSize: this.tileSize,
              pixelPosMatrix: z,
              transform: S,
              params: T,
              queryPadding: this.queryPadding * k,
              getElevation: V
            }, e, i, l) : {}
          }
          querySourceFeatures(e, i) {
            const l = this.latestFeatureIndex;
            if (!l || !l.rawTileData) return;
            const u = l.loadVTLayers(),
              d = i && i.sourceLayer ? i.sourceLayer : "",
              g = u._geojsonTileLayer || u[d];
            if (!g) return;
            const T = s.ae(i == null ? void 0 : i.filter, i == null ? void 0 : i.globalState),
              {
                z: S,
                x: k,
                y: z
              } = this.tileID.canonical,
              V = {
                z: S,
                x: k,
                y: z
              };
            for (let F = 0; F < g.length; F++) {
              const $ = g.feature(F);
              if (T.needGeometry) {
                const oe = s.af($, !0);
                if (!T.filter(new s.G(this.tileID.overscaledZ), oe, this.tileID.canonical)) continue
              } else if (!T.filter(new s.G(this.tileID.overscaledZ), $)) continue;
              const J = l.getId($, d),
                ae = new s.ag($, S, k, z, J);
              ae.tile = V, e.push(ae)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const i = this.expirationTime;
            if (e.cacheControl) {
              const l = s.ah(e.cacheControl);
              l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const l = Date.now();
              let u = !1;
              if (this.expirationTime > l) u = !1;
              else if (i)
                if (this.expirationTime < i) u = !0;
                else {
                  const d = this.expirationTime - i;
                  d ? this.expirationTime = l + Math.max(d, 3e4) : u = !0
                }
              else u = !0;
              u ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, i) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const l = this.latestFeatureIndex.loadVTLayers();
            for (const u in this.buckets) {
              if (!i.style.hasLayer(u)) continue;
              const d = this.buckets[u],
                g = d.layers[0].sourceLayer || "_geojsonTileLayer",
                T = l[g],
                S = e[g];
              if (!T || !S || Object.keys(S).length === 0) continue;
              d.update(S, T, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const k = i && i.style && i.style.getLayer(u);
              k && (this.queryPadding = Math.max(this.queryPadding, k.queryRadius(d)))
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < ne()
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = ne() + e
          }
          setDependencies(e, i) {
            const l = {};
            for (const u of i) l[u] = !0;
            this.dependencies[e] = l
          }
          hasDependency(e, i) {
            for (const l of e) {
              const u = this.dependencies[l];
              if (u) {
                for (const d of i)
                  if (u[d]) return !0
              }
            }
            return !1
          }
        }
        class ce {
          constructor(e, i) {
            this.max = e, this.onRemove = i, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
            return this.data = {}, this.order = [], this
          }
          add(e, i, l) {
            const u = e.wrapped().key;
            this.data[u] === void 0 && (this.data[u] = []);
            const d = {
              value: i,
              timeout: void 0
            };
            if (l !== void 0 && (d.timeout = setTimeout((() => {
                this.remove(e, d)
              }), l)), this.data[u].push(d), this.order.push(u), this.order.length > this.max) {
              const g = this._getAndRemoveByKey(this.order[0]);
              g && this.onRemove(g)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const i = this.data[e].shift();
            return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value
          }
          getByKey(e) {
            const i = this.data[e];
            return i ? i[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, i) {
            if (!this.has(e)) return this;
            const l = e.wrapped().key,
              u = i === void 0 ? 0 : this.data[l].indexOf(i),
              d = this.data[l][u];
            return this.data[l].splice(u, 1), d.timeout && clearTimeout(d.timeout), this.data[l].length === 0 && delete this.data[l], this.onRemove(d.value), this.order.splice(this.order.indexOf(l), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const i = this._getAndRemoveByKey(this.order[0]);
              i && this.onRemove(i)
            }
            return this
          }
          filter(e) {
            const i = [];
            for (const l in this.data)
              for (const u of this.data[l]) e(u.value) || i.push(u);
            for (const l of i) this.remove(l.value.tileID, l)
          }
        }
        class ve {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, i, l) {
            const u = String(i);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][u] = this.stateChanges[e][u] || {}, s.e(this.stateChanges[e][u], l), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const d in this.state[e]) d !== u && (this.deletedStates[e][d] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][u] === null) {
              this.deletedStates[e][u] = {};
              for (const d in this.state[e][u]) l[d] || (this.deletedStates[e][u][d] = null)
            } else
              for (const d in l) this.deletedStates[e] && this.deletedStates[e][u] && this.deletedStates[e][u][d] === null && delete this.deletedStates[e][u][d]
          }
          removeFeatureState(e, i, l) {
            if (this.deletedStates[e] === null) return;
            const u = String(i);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, l && i !== void 0) this.deletedStates[e][u] !== null && (this.deletedStates[e][u] = this.deletedStates[e][u] || {}, this.deletedStates[e][u][l] = null);
            else if (i !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][u])
                for (l in this.deletedStates[e][u] = {}, this.stateChanges[e][u]) this.deletedStates[e][u][l] = null;
              else this.deletedStates[e][u] = null;
            else this.deletedStates[e] = null
          }
          getState(e, i) {
            const l = String(i),
              u = s.e({}, (this.state[e] || {})[l], (this.stateChanges[e] || {})[l]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const d = this.deletedStates[e][i];
              if (d === null) return {};
              for (const g in d) delete u[g]
            }
            return u
          }
          initializeTileState(e, i) {
            e.setFeatureState(this.state, i)
          }
          coalesceChanges(e, i) {
            const l = {};
            for (const u in this.stateChanges) {
              this.state[u] = this.state[u] || {};
              const d = {};
              for (const g in this.stateChanges[u]) this.state[u][g] || (this.state[u][g] = {}), s.e(this.state[u][g], this.stateChanges[u][g]), d[g] = this.state[u][g];
              l[u] = d
            }
            for (const u in this.deletedStates) {
              this.state[u] = this.state[u] || {};
              const d = {};
              if (this.deletedStates[u] === null)
                for (const g in this.state[u]) d[g] = {}, this.state[u][g] = {};
              else
                for (const g in this.deletedStates[u]) {
                  if (this.deletedStates[u][g] === null) this.state[u][g] = {};
                  else
                    for (const T of Object.keys(this.deletedStates[u][g])) delete this.state[u][g][T];
                  d[g] = this.state[u][g]
                }
              l[u] = l[u] || {}, s.e(l[u], d)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
              for (const u in e) e[u].setFeatureState(l, i)
          }
        }
        const he = 89.25;

        function Se(h, e) {
          const i = s.ai(e.lat, -s.aj, s.aj);
          return new s.P(s.X(e.lng) * h, s.W(i) * h)
        }

        function Ye(h, e) {
          return new s.a5(e.x / h, e.y / h).toLngLat()
        }

        function Ze(h) {
          return h.cameraToCenterDistance * Math.min(.85 * Math.tan(s.ak(90 - h.pitch)), Math.tan(s.ak(he - h.pitch)))
        }

        function Tt(h, e) {
          const i = h.canonical,
            l = e / s.al(i.z),
            u = i.x + Math.pow(2, i.z) * h.wrap,
            d = s.am(new Float64Array(16));
          return s.N(d, d, [u * l, i.y * l, 0]), s.O(d, d, [l / s.a3, l / s.a3, 1]), d
        }

        function _e(h, e, i, l, u) {
          const d = s.a5.fromLngLat(h, e),
            g = u * s.an(1, h.lat),
            T = g * Math.cos(s.ak(i)),
            S = Math.sqrt(g * g - T * T),
            k = S * Math.sin(s.ak(-l)),
            z = S * Math.cos(s.ak(-l));
          return new s.a5(d.x + k, d.y + z, d.z + T)
        }

        function Vt(h, e, i) {
          const l = e.intersectsFrustum(h);
          if (!i || l === 0) return l;
          const u = e.intersectsPlane(i);
          return u === 0 ? 0 : l === 2 && u === 2 ? 2 : 1
        }

        function ur(h, e, i) {
          let l = 0;
          const u = (i - e) / 10;
          for (let d = 0; d < 10; d++) l += u * Math.pow(Math.cos(e + (d + .5) / 10 * (i - e)), h);
          return l
        }

        function Ft(h, e) {
          return function(i, l, u, d, g) {
            const T = 2 * ((h - 1) / s.ao(Math.cos(s.ak(he - g)) / Math.cos(s.ak(he))) - 1),
              S = Math.acos(u / d),
              k = 2 * ur(T - 1, 0, s.ak(g / 2)),
              z = Math.min(s.ak(he), S + s.ak(g / 2)),
              V = ur(T - 1, Math.min(z, S - s.ak(g / 2)), z),
              F = Math.atan(l / u),
              $ = Math.hypot(l, u);
            let J = i;
            return J += s.ao(d / $ / Math.max(.5, Math.cos(s.ak(g / 2)))), J += T * s.ao(Math.cos(F)) / 2, J -= s.ao(Math.max(1, V / k / e)) / 2, J
          }
        }
        const or = Ft(9.314, 3);

        function Vr(h, e) {
          const i = (e.roundZoom ? Math.round : Math.floor)(h.zoom + s.ao(h.tileSize / e.tileSize));
          return Math.max(0, i)
        }

        function qr(h, e) {
          const i = h.getCameraFrustum(),
            l = h.getClippingPlane(),
            u = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
            d = s.a5.fromLngLat(h.center, h.elevation);
          u.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const g = h.getCoveringTilesDetailsProvider(),
            T = g.allowVariableZoom(h, e),
            S = Vr(h, e),
            k = e.minzoom || 0,
            z = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
            V = Math.min(Math.max(0, S), z),
            F = Math.pow(2, V),
            $ = [F * u.x, F * u.y, 0],
            J = [F * d.x, F * d.y, 0],
            ae = Math.hypot(d.x - u.x, d.y - u.y),
            oe = Math.abs(d.z - u.z),
            se = Math.hypot(ae, oe),
            fe = be => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: be,
              fullyVisible: !1
            }),
            xe = [],
            pe = [];
          if (h.renderWorldCopies && g.allowWorldCopies())
            for (let be = 1; be <= 3; be++) xe.push(fe(-be)), xe.push(fe(be));
          for (xe.push(fe(0)); xe.length > 0;) {
            const be = xe.pop(),
              Pe = be.x,
              ge = be.y;
            let Fe = be.fullyVisible;
            const nt = {
                x: Pe,
                y: ge,
                z: be.zoom
              },
              et = g.getTileBoundingVolume(nt, be.wrap, h.elevation, e);
            if (!Fe) {
              const Ht = Vt(i, et, l);
              if (Ht === 0) continue;
              Fe = Ht === 2
            }
            const rt = g.distanceToTile2d(u.x, u.y, nt, et);
            let at = S;
            T && (at = (e.calculateTileZoom || or)(h.zoom + s.ao(h.tileSize / e.tileSize), rt, oe, se, h.fov)), at = (e.roundZoom ? Math.round : Math.floor)(at), at = Math.max(0, at);
            const Gt = Math.min(at, z);
            if (be.wrap = g.getWrap(d, nt, be.wrap), be.zoom >= Gt) {
              if (be.zoom < k) continue;
              const Ht = V - be.zoom,
                Pt = $[0] - .5 - (Pe << Ht),
                gr = $[1] - .5 - (ge << Ht),
                Qr = e.reparseOverscaled ? Math.max(be.zoom, at) : be.zoom;
              pe.push({
                tileID: new s.a0(be.zoom === z ? Qr : be.zoom, be.wrap, be.zoom, Pe, ge),
                distanceSq: s.ap([J[0] - .5 - Pe, J[1] - .5 - ge]),
                tileDistanceToCamera: Math.sqrt(Pt * Pt + gr * gr)
              })
            } else
              for (let Ht = 0; Ht < 4; Ht++) xe.push({
                zoom: be.zoom + 1,
                x: (Pe << 1) + Ht % 2,
                y: (ge << 1) + (Ht >> 1),
                wrap: be.wrap,
                fullyVisible: Fe
              })
          }
          return pe.sort(((be, Pe) => be.distanceSq - Pe.distanceSq)).map((be => be.tileID))
        }
        const Wr = s.a6.fromPoints([new s.P(0, 0), new s.P(s.a3, s.a3)]);
        class rn extends s.E {
          constructor(e, i, l) {
            super(), this.id = e, this.dispatcher = l, this.on("data", (u => this._dataHandler(u))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((u, d, g, T) => {
              const S = new(kr(d.type))(u, d, g, T);
              if (S.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${S.id}`);
              return S
            })(e, i, l, this), this._tiles = {}, this._cache = new ce(0, (u => this._unloadTile(u))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new ve, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const i = this._tiles[e];
              if (i.state !== "loaded" && i.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          getState() {
            return this._state
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, i, l) {
            return s._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, i, l)
              } catch (u) {
                e.state = "errored", u.status !== 404 ? this._source.fire(new s.k(u, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const i in this._tiles) {
              const l = this._tiles[i];
              l.upload(e), l.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(hn).map((e => e.key))
          }
          getRenderableIds(e) {
            const i = [];
            for (const l in this._tiles) this._isIdRenderable(l, e) && i.push(this._tiles[l]);
            return e ? i.sort(((l, u) => {
              const d = l.tileID,
                g = u.tileID,
                T = new s.P(d.canonical.x, d.canonical.y)._rotate(-this.transform.bearingInRadians),
                S = new s.P(g.canonical.x, g.canonical.y)._rotate(-this.transform.bearingInRadians);
              return d.overscaledZ - g.overscaledZ || S.y - T.y || S.x - T.x
            })).map((l => l.tileID.key)) : i.map((l => l.tileID)).sort(hn).map((l => l.key))
          }
          hasRenderableParent(e) {
            const i = e.overscaledZ - 1;
            if (i >= this._source.minzoom) {
              const l = this.getLoadedTile(e.scaledTo(i));
              if (l) return this._isIdRenderable(l.tileID.key)
            }
            return !1
          }
          _isIdRenderable(e, i = !1) {
            var l;
            return (l = this._tiles[e]) === null || l === void 0 ? void 0 : l.isRenderable(i)
          }
          reload(e, i = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const l in this._tiles) i && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[l], i) || (e ? this._reloadTile(l, "expired") : this._tiles[l].state !== "errored" && this._reloadTile(l, "reloading"))
            }
          }
          _reloadTile(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = this._tiles[e];
              l && (l.state !== "loading" && (l.state = i), yield this._loadTile(l, e, i))
            }))
          }
          _tileLoaded(e, i, l) {
            e.timeAdded = ne(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), l === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const i = this.getRenderableIds();
            for (let u = 0; u < i.length; u++) {
              const d = i[u];
              if (e.neighboringTiles && e.neighboringTiles[d]) {
                const g = this.getTileByID(d);
                l(e, g), l(g, e)
              }
            }

            function l(u, d) {
              u.needsHillshadePrepare = !0, u.needsTerrainPrepare = !0;
              let g = d.tileID.canonical.x - u.tileID.canonical.x;
              const T = d.tileID.canonical.y - u.tileID.canonical.y,
                S = Math.pow(2, u.tileID.canonical.z),
                k = d.tileID.key;
              g === 0 && T === 0 || Math.abs(T) > 1 || (Math.abs(g) > 1 && (Math.abs(g + S) === 1 ? g += S : Math.abs(g - S) === 1 && (g -= S)), d.dem && u.dem && (u.dem.backfillBorder(d.dem, g, T), u.neighboringTiles && u.neighboringTiles[k] && (u.neighboringTiles[k].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, i) {
            const l = Object.values(e),
              u = this._getLoadedDescendents(l),
              d = {};
            for (const g of l) {
              const T = u[g.key];
              if (!(T != null && T.length)) {
                d[g.key] = g;
                continue
              }
              const S = g.overscaledZ + rn.maxUnderzooming,
                k = T.filter((F => F.tileID.overscaledZ <= S));
              if (!k.length) {
                d[g.key] = g;
                continue
              }
              const z = Math.min(...k.map((F => F.tileID.overscaledZ))),
                V = k.filter((F => F.tileID.overscaledZ === z)).map((F => F.tileID));
              for (const F of V) i[F.key] = F;
              this._areDescendentsComplete(V, z, g.overscaledZ) || (d[g.key] = g)
            }
            return d
          }
          _getLoadedDescendents(e) {
            var i;
            const l = {};
            for (const u in this._tiles) {
              const d = this._tiles[u];
              if (d.hasData())
                for (const g of e) d.tileID.isChildOf(g) && (l[i = g.key] || (l[i] = [])).push(d)
            }
            return l
          }
          _areDescendentsComplete(e, i, l) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === i : Math.pow(4, i - l) === e.length
          }
          getLoadedTile(e) {
            const i = this._tiles[e.key];
            return i != null && i.hasData() ? i : null
          }
          updateCacheSize(e) {
            const i = Math.ceil(e.width / this._source.tileSize) + 1,
              l = Math.ceil(e.height / this._source.tileSize) + 1,
              u = Math.floor(i * l * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
            this._cache.setMaxSize(d)
          }
          handleWrapJump(e) {
            const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, i) {
              const l = {};
              for (const u in this._tiles) {
                const d = this._tiles[u];
                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + i), l[d.tileID.key] = d
              }
              this._tiles = l, this._resetTileReloadTimers()
            }
          }
          update(e, i) {
            if (!this._sourceLoaded || this._paused) return;
            let l;
            this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? l = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((S => new s.a0(S.canonical.z, S.wrap, S.canonical.z, S.canonical.x, S.canonical.y))) : (l = qr(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: i,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (l = l.filter((S => this._source.hasTile(S))))) : l = [], this.usedForTerrain && (l = this._addTerrainIdealTiles(l));
            const u = l.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, u && this.fire(new s.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const d = Vr(e, this._source),
              g = this._updateRetainedTiles(l, d),
              T = cn(this._source.type);
            T && this._rasterFadeDuration > 0 && !i && this._updateFadingTiles(l, g), T ? this._cleanUpRasterTiles(g) : this._cleanUpVectorTiles(g)
          }
          _cleanUpRasterTiles(e) {
            for (const i in this._tiles) e[i] || this._removeTile(i)
          }
          _cleanUpVectorTiles(e) {
            for (const i in this._tiles) {
              const l = this._tiles[i];
              e[i] ? l.clearSymbolFadeHold() : l.hasSymbolBuckets ? l.holdingForSymbolFade() ? l.symbolFadeFinished() && this._removeTile(i) : l.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(i)
            }
          }
          _addTerrainIdealTiles(e) {
            const i = [];
            for (const l of e)
              if (l.canonical.z > this._source.minzoom) {
                const u = l.scaledTo(l.canonical.z - 1);
                i.push(u);
                const d = l.scaledTo(Math.max(this._source.minzoom, Math.min(l.canonical.z, 5)));
                i.push(d)
              } return e.concat(i)
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, i) {
            var l;
            const u = {},
              d = {},
              g = Math.max(i - rn.maxOverzooming, this._source.minzoom);
            let T = {};
            for (const S of e) {
              const k = this._addTile(S);
              u[S.key] = S, k.hasData() || (T[S.key] = S)
            }
            T = this._retainLoadedChildren(T, u);
            for (const S in T) {
              const k = T[S];
              let z = this._tiles[S],
                V = z == null ? void 0 : z.wasRequested();
              for (let F = k.overscaledZ - 1; F >= g; --F) {
                const $ = k.scaledTo(F);
                if (d[$.key]) break;
                if (d[$.key] = !0, z = this.getTile($), !z && V && (z = this._addTile($)), z) {
                  const J = z.hasData();
                  if ((J || !(!((l = this.map) === null || l === void 0) && l.cancelPendingTileRequestsWhileZooming) || V) && (u[$.key] = $), V = z.wasRequested(), J) break
                }
              }
            }
            return u
          }
          _updateFadingTiles(e, i) {
            const l = ne(),
              u = s.aq(e);
            for (const d of e) {
              const g = this._tiles[d.key];
              g.fadingDirection !== H.Departing && g.fadeOpacity !== 0 || g.resetFadeLogic(), this._updateFadingAncestor(g, i, l) || this._updateFadingDescendents(g, i, l) || this._updateFadingEdge(g, u, l) || g.resetFadeLogic()
            }
          }
          _updateFadingAncestor(e, i, l) {
            if (!e.hasData()) return !1;
            const {
              tileID: u,
              fadingRole: d,
              fadingDirection: g,
              fadingParentID: T
            } = e;
            if (d === N.Base && g === H.Incoming && T) return i[T.key] = T, !0;
            const S = Math.max(u.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let k = u.overscaledZ - 1; k >= S; k--) {
              const z = u.scaledTo(k),
                V = this.getLoadedTile(z);
              if (V) return e.setCrossFadeLogic({
                fadingRole: N.Base,
                fadingDirection: H.Incoming,
                fadingParentID: V.tileID,
                fadeEndTime: l + this._rasterFadeDuration
              }), V.setCrossFadeLogic({
                fadingRole: N.Parent,
                fadingDirection: H.Departing,
                fadeEndTime: l + this._rasterFadeDuration
              }), i[z.key] = z, !0
            }
            return !1
          }
          _updateFadingDescendents(e, i, l) {
            if (!e.hasData()) return !1;
            const u = e.tileID.children(this._source.maxzoom);
            let d = this._updateFadingChildren(e, u, i, l);
            if (d) return !0;
            for (const g of u) {
              const T = g.children(this._source.maxzoom);
              this._updateFadingChildren(e, T, i, l) && (d = !0)
            }
            return d
          }
          _updateFadingChildren(e, i, l, u) {
            if (i[0].overscaledZ >= this._source.maxzoom) return !1;
            let d = !1;
            for (const g of i) {
              const T = this.getLoadedTile(g);
              if (!T) continue;
              const {
                fadingRole: S,
                fadingDirection: k,
                fadingParentID: z
              } = T;
              S === N.Base && k === H.Departing && z || (T.setCrossFadeLogic({
                fadingRole: N.Base,
                fadingDirection: H.Departing,
                fadingParentID: e.tileID,
                fadeEndTime: u + this._rasterFadeDuration
              }), e.setCrossFadeLogic({
                fadingRole: N.Parent,
                fadingDirection: H.Incoming,
                fadeEndTime: u + this._rasterFadeDuration
              })), l[g.key] = g, d = !0
            }
            return d
          }
          _updateFadingEdge(e, i, l) {
            const u = e.tileID;
            return !!e.selfFading || !e.hasData() && !!i.has(u) && (e.setSelfFadeLogic(l + this._rasterFadeDuration), !0)
          }
          _addTile(e) {
            let i = this._tiles[e.key];
            if (i) return i;
            i = this._cache.getAndRemove(e), i && (i.resetFadeLogic(), this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null));
            const l = i;
            return i || (i = new W(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, l || this._source.fire(new s.l("dataloading", {
              tile: i,
              coord: i.tileID,
              dataType: "source"
            })), i
          }
          _setTileReloadTimer(e, i) {
            this._clearTileReloadTimer(e);
            const l = i.getExpiryTimeout();
            l && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), l))
          }
          _clearTileReloadTimer(e) {
            const i = this._timers[e];
            i && (clearTimeout(i), delete this._timers[e])
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e])
          }
          refreshTiles(e) {
            for (const i in this._tiles)(this._isIdRenderable(i) || this._tiles[i].state == "errored") && e.some((l => l.equals(this._tiles[i].tileID.canonical))) && this._reloadTile(i, "expired")
          }
          _removeTile(e) {
            const i = this._tiles[e];
            i && (i.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i))))
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, i, l) {
            const u = [],
              d = this.transform;
            if (!d) return u;
            const g = d.getCoveringTilesDetailsProvider().allowWorldCopies(),
              T = l ? d.getCameraQueryGeometry(e) : e,
              S = $ => d.screenPointToMercatorCoordinate($, this.terrain),
              k = this.transformBbox(e, S, !g),
              z = this.transformBbox(T, S, !g),
              V = this.getIds(),
              F = s.a6.fromPoints(z);
            for (let $ = 0; $ < V.length; $++) {
              const J = this._tiles[V[$]];
              if (J.holdingForSymbolFade()) continue;
              const ae = g ? [J.tileID] : [J.tileID.unwrapTo(-1), J.tileID.unwrapTo(0)],
                oe = Math.pow(2, d.zoom - J.tileID.overscaledZ),
                se = i * J.queryPadding * s.a3 / J.tileSize / oe;
              for (const fe of ae) {
                const xe = F.map((pe => fe.getTilePoint(new s.a5(pe.x, pe.y))));
                if (xe.expandBy(se), xe.intersects(Wr)) {
                  const pe = k.map((Pe => fe.getTilePoint(Pe))),
                    be = z.map((Pe => fe.getTilePoint(Pe)));
                  u.push({
                    tile: J,
                    tileID: g ? fe : fe.unwrapTo(0),
                    queryGeometry: pe,
                    cameraQueryGeometry: be,
                    scale: oe
                  })
                }
              }
            }
            return u
          }
          transformBbox(e, i, l) {
            let u = e.map(i);
            if (l) {
              const d = s.a6.fromPoints(e);
              d.shrinkBy(.001 * Math.min(d.width(), d.height()));
              const g = d.map(i);
              s.a6.fromPoints(u).covers(g) || (u = u.map((T => T.x > .5 ? new s.a5(T.x - 1, T.y, T.z) : T)))
            }
            return u
          }
          getVisibleCoordinates(e) {
            const i = this.getRenderableIds(e).map((l => this._tiles[l].tileID));
            return this.transform && this.transform.populateCache(i), i
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (cn(this._source.type) && this._rasterFadeDuration > 0) {
              const e = ne();
              for (const i in this._tiles)
                if (this._tiles[i].fadeEndTime >= e) return !0
            }
            return !1
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e
          }
          setFeatureState(e, i, l) {
            this._state.updateState(e = e || "_geojsonTileLayer", i, l)
          }
          removeFeatureState(e, i, l) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, l)
          }
          getFeatureState(e, i) {
            return this._state.getState(e = e || "_geojsonTileLayer", i)
          }
          setDependencies(e, i, l) {
            const u = this._tiles[e];
            u && u.setDependencies(i, l)
          }
          reloadTilesForDependencies(e, i) {
            for (const l in this._tiles) this._tiles[l].hasDependency(e, i) && this._reloadTile(l, "reloading");
            this._cache.filter((l => !l.hasDependency(e, i)))
          }
        }

        function hn(h, e) {
          const i = Math.abs(2 * h.wrap) - +(h.wrap < 0),
            l = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || l - i || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
        }

        function cn(h) {
          return h === "raster" || h === "image" || h === "video"
        }
        rn.maxOverzooming = 10, rn.maxUnderzooming = 3;
        class an {
          constructor(e, i) {
            this.reset(e, i)
          }
          reset(e, i) {
            this.points = e || [], this._distances = [0];
            for (let l = 1; l < this.points.length; l++) this._distances[l] = this._distances[l - 1] + this.points[l].dist(this.points[l - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(i || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ai(e, 0, 1);
            let i = 1,
              l = this._distances[i];
            const u = e * this.paddedLength + this.padding;
            for (; l < u && i < this._distances.length;) l = this._distances[++i];
            const d = i - 1,
              g = this._distances[d],
              T = l - g,
              S = T > 0 ? (u - g) / T : 0;
            return this.points[d].mult(1 - S).add(this.points[i].mult(S))
          }
        }

        function ht(h, e) {
          let i = !0;
          return h === "always" || h !== "never" && e !== "never" || (i = !1), i
        }
        class un {
          constructor(e, i, l) {
            const u = this.boxCells = [],
              d = this.circleCells = [];
            this.xCellCount = Math.ceil(e / l), this.yCellCount = Math.ceil(i / l);
            for (let g = 0; g < this.xCellCount * this.yCellCount; g++) u.push([]), d.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = i, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / i, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, i, l, u, d) {
            this._forEachCell(i, l, u, d, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(u), this.bboxes.push(d)
          }
          insertCircle(e, i, l, u) {
            this._forEachCell(i - u, l - u, i + u, l + u, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(i), this.circles.push(l), this.circles.push(u)
          }
          _insertBoxCell(e, i, l, u, d, g) {
            this.boxCells[d].push(g)
          }
          _insertCircleCell(e, i, l, u, d, g) {
            this.circleCells[d].push(g)
          }
          _query(e, i, l, u, d, g, T) {
            if (l < 0 || e > this.width || u < 0 || i > this.height) return [];
            const S = [];
            if (e <= 0 && i <= 0 && this.width <= l && this.height <= u) {
              if (d) return [{
                key: null,
                x1: e,
                y1: i,
                x2: l,
                y2: u
              }];
              for (let k = 0; k < this.boxKeys.length; k++) S.push({
                key: this.boxKeys[k],
                x1: this.bboxes[4 * k],
                y1: this.bboxes[4 * k + 1],
                x2: this.bboxes[4 * k + 2],
                y2: this.bboxes[4 * k + 3]
              });
              for (let k = 0; k < this.circleKeys.length; k++) {
                const z = this.circles[3 * k],
                  V = this.circles[3 * k + 1],
                  F = this.circles[3 * k + 2];
                S.push({
                  key: this.circleKeys[k],
                  x1: z - F,
                  y1: V - F,
                  x2: z + F,
                  y2: V + F
                })
              }
            } else this._forEachCell(e, i, l, u, this._queryCell, S, {
              hitTest: d,
              overlapMode: g,
              seenUids: {
                box: {},
                circle: {}
              }
            }, T);
            return S
          }
          query(e, i, l, u) {
            return this._query(e, i, l, u, !1, null)
          }
          hitTest(e, i, l, u, d, g) {
            return this._query(e, i, l, u, !0, d, g).length > 0
          }
          hitTestCircle(e, i, l, u, d) {
            const g = e - l,
              T = e + l,
              S = i - l,
              k = i + l;
            if (T < 0 || g > this.width || k < 0 || S > this.height) return !1;
            const z = [];
            return this._forEachCell(g, S, T, k, this._queryCellCircle, z, {
              hitTest: !0,
              overlapMode: u,
              circle: {
                x: e,
                y: i,
                radius: l
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, d), z.length > 0
          }
          _queryCell(e, i, l, u, d, g, T, S) {
            const {
              seenUids: k,
              hitTest: z,
              overlapMode: V
            } = T, F = this.boxCells[d];
            if (F !== null) {
              const J = this.bboxes;
              for (const ae of F)
                if (!k.box[ae]) {
                  k.box[ae] = !0;
                  const oe = 4 * ae,
                    se = this.boxKeys[ae];
                  if (e <= J[oe + 2] && i <= J[oe + 3] && l >= J[oe + 0] && u >= J[oe + 1] && (!S || S(se)) && (!z || !ht(V, se.overlapMode)) && (g.push({
                      key: se,
                      x1: J[oe],
                      y1: J[oe + 1],
                      x2: J[oe + 2],
                      y2: J[oe + 3]
                    }), z)) return !0
                }
            }
            const $ = this.circleCells[d];
            if ($ !== null) {
              const J = this.circles;
              for (const ae of $)
                if (!k.circle[ae]) {
                  k.circle[ae] = !0;
                  const oe = 3 * ae,
                    se = this.circleKeys[ae];
                  if (this._circleAndRectCollide(J[oe], J[oe + 1], J[oe + 2], e, i, l, u) && (!S || S(se)) && (!z || !ht(V, se.overlapMode))) {
                    const fe = J[oe],
                      xe = J[oe + 1],
                      pe = J[oe + 2];
                    if (g.push({
                        key: se,
                        x1: fe - pe,
                        y1: xe - pe,
                        x2: fe + pe,
                        y2: xe + pe
                      }), z) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, i, l, u, d, g, T, S) {
            const {
              circle: k,
              seenUids: z,
              overlapMode: V
            } = T, F = this.boxCells[d];
            if (F !== null) {
              const J = this.bboxes;
              for (const ae of F)
                if (!z.box[ae]) {
                  z.box[ae] = !0;
                  const oe = 4 * ae,
                    se = this.boxKeys[ae];
                  if (this._circleAndRectCollide(k.x, k.y, k.radius, J[oe + 0], J[oe + 1], J[oe + 2], J[oe + 3]) && (!S || S(se)) && !ht(V, se.overlapMode)) return g.push(!0), !0
                }
            }
            const $ = this.circleCells[d];
            if ($ !== null) {
              const J = this.circles;
              for (const ae of $)
                if (!z.circle[ae]) {
                  z.circle[ae] = !0;
                  const oe = 3 * ae,
                    se = this.circleKeys[ae];
                  if (this._circlesCollide(J[oe], J[oe + 1], J[oe + 2], k.x, k.y, k.radius) && (!S || S(se)) && !ht(V, se.overlapMode)) return g.push(!0), !0
                }
            }
          }
          _forEachCell(e, i, l, u, d, g, T, S) {
            const k = this._convertToXCellCoord(e),
              z = this._convertToYCellCoord(i),
              V = this._convertToXCellCoord(l),
              F = this._convertToYCellCoord(u);
            for (let $ = k; $ <= V; $++)
              for (let J = z; J <= F; J++)
                if (d.call(this, e, i, l, u, this.xCellCount * J + $, g, T, S)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, i, l, u, d, g) {
            const T = u - e,
              S = d - i,
              k = l + g;
            return k * k > T * T + S * S
          }
          _circleAndRectCollide(e, i, l, u, d, g, T) {
            const S = (g - u) / 2,
              k = Math.abs(e - (u + S));
            if (k > S + l) return !1;
            const z = (T - d) / 2,
              V = Math.abs(i - (d + z));
            if (V > z + l) return !1;
            if (k <= S || V <= z) return !0;
            const F = k - S,
              $ = V - z;
            return F * F + $ * $ <= l * l
          }
        }

        function Pn(h, e, i) {
          const l = s.M();
          if (!h) {
            const {
              vecSouth: V,
              vecEast: F
            } = st(e), $ = j();
            $[0] = F[0], $[1] = F[1], $[2] = V[0], $[3] = V[1], u = $, (z = (g = (d = $)[0]) * (k = d[3]) - (S = d[2]) * (T = d[1])) && (u[0] = k * (z = 1 / z), u[1] = -T * z, u[2] = -S * z, u[3] = g * z), l[0] = $[0], l[1] = $[1], l[4] = $[2], l[5] = $[3]
          }
          var u, d, g, T, S, k, z;
          return s.O(l, l, [1 / i, 1 / i, 1]), l
        }

        function Bt(h, e, i, l) {
          if (h) {
            const u = s.M();
            if (!e) {
              const {
                vecSouth: d,
                vecEast: g
              } = st(i);
              u[0] = g[0], u[1] = g[1], u[4] = d[0], u[5] = d[1]
            }
            return s.O(u, u, [l, l, 1]), u
          }
          return i.pixelsToClipSpaceMatrix
        }

        function st(h) {
          const e = Math.cos(h.rollInRadians),
            i = Math.sin(h.rollInRadians),
            l = Math.cos(h.pitchInRadians),
            u = Math.cos(h.bearingInRadians),
            d = Math.sin(h.bearingInRadians),
            g = s.av();
          g[0] = -u * l * i - d * e, g[1] = -d * l * i + u * e;
          const T = s.aw(g);
          T < 1e-9 ? s.ax(g) : s.ay(g, g, 1 / T);
          const S = s.av();
          S[0] = u * l * e - d * i, S[1] = d * l * e + u * i;
          const k = s.aw(S);
          return k < 1e-9 ? s.ax(S) : s.ay(S, S, 1 / k), {
            vecEast: S,
            vecSouth: g
          }
        }

        function Me(h, e, i, l) {
          let u;
          l ? (u = [h, e, l(h, e), 1], s.aA(u, u, i)) : (u = [h, e, 0, 1], fi(u, u, i));
          const d = u[3];
          return {
            point: new s.P(u[0] / d, u[1] / d),
            signedDistanceFromCamera: d,
            isOccluded: !1
          }
        }

        function ft(h, e) {
          return .5 + h / e * .5
        }

        function zt(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
        }

        function ar(h, e, i, l, u, d, g, T, S, k, z, V, F) {
          const $ = i ? h.textSizeData : h.iconSizeData,
            J = s.ar($, e.transform.zoom),
            ae = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            oe = i ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          oe.clear();
          const se = h.lineVertexArray,
            fe = i ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
            xe = e.transform.width / e.transform.height;
          let pe = !1;
          for (let be = 0; be < fe.length; be++) {
            const Pe = fe.get(be);
            if (Pe.hidden || Pe.writingMode === s.as.vertical && !pe) {
              Yn(Pe.numGlyphs, oe);
              continue
            }
            pe = !1;
            const ge = new s.P(Pe.anchorX, Pe.anchorY),
              Fe = {
                getElevation: F,
                pitchedLabelPlaneMatrix: l,
                lineVertexArray: se,
                pitchWithMap: d,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: ge,
                unwrappedTileID: S,
                width: k,
                height: z,
                translation: V
              },
              nt = Mr(Pe.anchorX, Pe.anchorY, Fe);
            if (!zt(nt.point, ae)) {
              Yn(Pe.numGlyphs, oe);
              continue
            }
            const et = ft(e.transform.cameraToCenterDistance, nt.signedDistanceFromCamera),
              rt = s.at($, J, Pe),
              at = d ? rt * e.transform.getPitchedTextCorrection(Pe.anchorX, Pe.anchorY, S) / et : rt * et,
              Gt = Dt({
                projectionContext: Fe,
                pitchedLabelPlaneMatrixInverse: u,
                symbol: Pe,
                fontSize: at,
                flip: !1,
                keepUpright: g,
                glyphOffsetArray: h.glyphOffsetArray,
                dynamicLayoutVertexArray: oe,
                aspectRatio: xe,
                rotateToLine: T
              });
            pe = Gt.useVertical, (Gt.notEnoughRoom || pe || Gt.needsFlipping && Dt({
              projectionContext: Fe,
              pitchedLabelPlaneMatrixInverse: u,
              symbol: Pe,
              fontSize: at,
              flip: !0,
              keepUpright: g,
              glyphOffsetArray: h.glyphOffsetArray,
              dynamicLayoutVertexArray: oe,
              aspectRatio: xe,
              rotateToLine: T
            }).notEnoughRoom) && Yn(Pe.numGlyphs, oe)
          }
          i ? h.text.dynamicLayoutVertexBuffer.updateData(oe) : h.icon.dynamicLayoutVertexBuffer.updateData(oe)
        }

        function br(h, e, i, l, u, d, g, T) {
          const S = d.glyphStartIndex + d.numGlyphs,
            k = d.lineStartIndex,
            z = d.lineStartIndex + d.lineLength,
            V = e.getoffsetX(d.glyphStartIndex),
            F = e.getoffsetX(S - 1),
            $ = dn(h * V, i, l, u, d.segment, k, z, T, g);
          if (!$) return null;
          const J = dn(h * F, i, l, u, d.segment, k, z, T, g);
          return J ? T.projectionCache.anyProjectionOccluded ? null : {
            first: $,
            last: J
          } : null
        }

        function Tr(h, e, i, l) {
          return h === s.as.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * l ? {
            useVertical: !0
          } : (h === s.as.vertical ? e.y < i.y : e.x > i.x) ? {
            needsFlipping: !0
          } : null
        }

        function Dt(h) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: i,
            symbol: l,
            fontSize: u,
            flip: d,
            keepUpright: g,
            glyphOffsetArray: T,
            dynamicLayoutVertexArray: S,
            aspectRatio: k,
            rotateToLine: z
          } = h, V = u / 24, F = l.lineOffsetX * V, $ = l.lineOffsetY * V;
          let J;
          if (l.numGlyphs > 1) {
            const ae = l.glyphStartIndex + l.numGlyphs,
              oe = l.lineStartIndex,
              se = l.lineStartIndex + l.lineLength,
              fe = br(V, T, F, $, d, l, z, e);
            if (!fe) return {
              notEnoughRoom: !0
            };
            const xe = Xr(fe.first.point.x, fe.first.point.y, e, i),
              pe = Xr(fe.last.point.x, fe.last.point.y, e, i);
            if (g && !d) {
              const be = Tr(l.writingMode, xe, pe, k);
              if (be) return be
            }
            J = [fe.first];
            for (let be = l.glyphStartIndex + 1; be < ae - 1; be++) {
              const Pe = dn(V * T.getoffsetX(be), F, $, d, l.segment, oe, se, e, z);
              if (!Pe) return {
                notEnoughRoom: !0
              };
              J.push(Pe)
            }
            J.push(fe.last)
          } else {
            if (g && !d) {
              const oe = wr(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                se = l.lineStartIndex + l.segment + 1,
                fe = new s.P(e.lineVertexArray.getx(se), e.lineVertexArray.gety(se)),
                xe = wr(fe.x, fe.y, e),
                pe = xe.signedDistanceFromCamera > 0 ? xe.point : Br(e.tileAnchorPoint, fe, oe, 1, e),
                be = Xr(oe.x, oe.y, e, i),
                Pe = Xr(pe.x, pe.y, e, i),
                ge = Tr(l.writingMode, be, Pe, k);
              if (ge) return ge
            }
            const ae = dn(V * T.getoffsetX(l.glyphStartIndex), F, $, d, l.segment, l.lineStartIndex, l.lineStartIndex + l.lineLength, e, z);
            if (!ae || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            J = [ae]
          }
          for (const ae of J) s.az(S, ae.point, ae.angle);
          return {}
        }

        function Br(h, e, i, l, u) {
          const d = h.add(h.sub(e)._unit()),
            g = wr(d.x, d.y, u).point,
            T = i.sub(g);
          return i.add(T._mult(l / T.mag()))
        }

        function Ir(h, e, i) {
          const l = e.projectionCache;
          if (l.projections[h]) return l.projections[h];
          const u = new s.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)),
            d = wr(u.x, u.y, e);
          if (d.signedDistanceFromCamera > 0) return l.projections[h] = d.point, l.anyProjectionOccluded = l.anyProjectionOccluded || d.isOccluded, d.point;
          const g = h - i.direction;
          return Br(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), u, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e)
        }

        function wr(h, e, i) {
          const l = h + i.translation[0],
            u = e + i.translation[1];
          let d;
          return i.pitchWithMap ? (d = Me(l, u, i.pitchedLabelPlaneMatrix, i.getElevation), d.isOccluded = !1) : (d = i.transform.projectTileCoordinates(l, u, i.unwrappedTileID, i.getElevation), d.point.x = (.5 * d.point.x + .5) * i.width, d.point.y = (.5 * -d.point.y + .5) * i.height), d
        }

        function Xr(h, e, i, l) {
          if (i.pitchWithMap) {
            const u = [h, e, 0, 1];
            return s.aA(u, u, l), i.transform.projectTileCoordinates(u[0] / u[3], u[1] / u[3], i.unwrappedTileID, i.getElevation).point
          }
          return {
            x: h / i.width * 2 - 1,
            y: 1 - e / i.height * 2
          }
        }

        function Mr(h, e, i) {
          return i.transform.projectTileCoordinates(h, e, i.unwrappedTileID, i.getElevation)
        }

        function nn(h, e, i) {
          return h._unit()._perp()._mult(e * i)
        }

        function sn(h, e, i, l, u, d, g, T, S) {
          if (T.projectionCache.offsets[h]) return T.projectionCache.offsets[h];
          const k = i.add(e);
          if (h + S.direction < l || h + S.direction >= u) return T.projectionCache.offsets[h] = k, k;
          const z = Ir(h + S.direction, T, S),
            V = nn(z.sub(i), g, S.direction),
            F = i.add(V),
            $ = z.add(V);
          return T.projectionCache.offsets[h] = s.aB(d, k, F, $) || k, T.projectionCache.offsets[h]
        }

        function dn(h, e, i, l, u, d, g, T, S) {
          const k = l ? h - e : h + e;
          let z = k > 0 ? 1 : -1,
            V = 0;
          l && (z *= -1, V = Math.PI), z < 0 && (V += Math.PI);
          let F, $ = z > 0 ? d + u : d + u + 1;
          T.projectionCache.cachedAnchorPoint ? F = T.projectionCache.cachedAnchorPoint : (F = wr(T.tileAnchorPoint.x, T.tileAnchorPoint.y, T).point, T.projectionCache.cachedAnchorPoint = F);
          let J, ae, oe = F,
            se = F,
            fe = 0,
            xe = 0;
          const pe = Math.abs(k),
            be = [];
          let Pe;
          for (; fe + xe <= pe;) {
            if ($ += z, $ < d || $ >= g) return null;
            fe += xe, se = oe, ae = J;
            const nt = {
              absOffsetX: pe,
              direction: z,
              distanceFromAnchor: fe,
              previousVertex: se
            };
            if (oe = Ir($, T, nt), i === 0) be.push(se), Pe = oe.sub(se);
            else {
              let et;
              const rt = oe.sub(se);
              et = rt.mag() === 0 ? nn(Ir($ + z, T, nt).sub(oe), i, z) : nn(rt, i, z), ae || (ae = se.add(et)), J = sn($, et, oe, d, g, ae, i, T, nt), be.push(ae), Pe = J.sub(ae)
            }
            xe = Pe.mag()
          }
          const ge = Pe._mult((pe - fe) / xe)._add(ae || se),
            Fe = V + Math.atan2(oe.y - se.y, oe.x - se.x);
          return be.push(ge), {
            point: ge,
            angle: S ? Fe : 0,
            path: be
          }
        }
        const _n = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function Yn(h, e) {
          for (let i = 0; i < h; i++) {
            const l = e.length;
            e.resize(l + 4), e.float32.set(_n, 3 * l)
          }
        }

        function fi(h, e, i) {
          const l = e[0],
            u = e[1];
          return h[0] = i[0] * l + i[4] * u + i[12], h[1] = i[1] * l + i[5] * u + i[13], h[3] = i[3] * l + i[7] * u + i[15], h
        }
        const fn = 100;
        class oi {
          constructor(e, i = new un(e.width + 200, e.height + 200, 25), l = new un(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = i, this.ignoredGrid = l, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + fn, this.screenBottomBoundary = e.height + fn, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, i, l, u, d, g, T, S, k, z, V, F) {
            const $ = this.projectAndGetPerspectiveRatio(e.anchorPointX + S[0], e.anchorPointY + S[1], d, z, F),
              J = l * $.perspectiveRatio;
            let ae;
            if (g || T) ae = this._projectCollisionBox(e, J, u, d, g, T, S, $, z, V, F);
            else {
              const Pe = $.x + (V ? V.x * J : 0),
                ge = $.y + (V ? V.y * J : 0);
              ae = {
                allPointsOccluded: !1,
                box: [Pe + e.x1 * J, ge + e.y1 * J, Pe + e.x2 * J, ge + e.y2 * J]
              }
            }
            const [oe, se, fe, xe] = ae.box, pe = g ? ae.allPointsOccluded : $.isOccluded;
            let be = pe;
            return be || (be = $.perspectiveRatio < this.perspectiveRatioCutoff), be || (be = !this.isInsideGrid(oe, se, fe, xe)), be || i !== "always" && this.grid.hitTest(oe, se, fe, xe, i, k) ? {
              box: [oe, se, fe, xe],
              placeable: !1,
              offscreen: !1,
              occluded: pe
            } : {
              box: [oe, se, fe, xe],
              placeable: !0,
              offscreen: this.isOffscreen(oe, se, fe, xe),
              occluded: pe
            }
          }
          placeCollisionCircles(e, i, l, u, d, g, T, S, k, z, V, F, $, J) {
            const ae = [],
              oe = new s.P(i.anchorX, i.anchorY),
              se = this.getPerspectiveRatio(oe.x, oe.y, g, J),
              fe = (k ? d * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, g) / se : d * se) / s.aF,
              xe = {
                getElevation: J,
                pitchedLabelPlaneMatrix: T,
                lineVertexArray: l,
                pitchWithMap: k,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: oe,
                unwrappedTileID: g,
                width: this.transform.width,
                height: this.transform.height,
                translation: $
              },
              pe = br(fe, u, i.lineOffsetX * fe, i.lineOffsetY * fe, !1, i, !1, xe);
            let be = !1,
              Pe = !1,
              ge = !0;
            if (pe) {
              const Fe = .5 * V * se + F,
                nt = new s.P(-100, -100),
                et = new s.P(this.screenRightBoundary, this.screenBottomBoundary),
                rt = new an,
                at = pe.first,
                Gt = pe.last;
              let Ht = [];
              for (let Qr = at.path.length - 1; Qr >= 1; Qr--) Ht.push(at.path[Qr]);
              for (let Qr = 1; Qr < Gt.path.length; Qr++) Ht.push(Gt.path[Qr]);
              const Pt = 2.5 * Fe;
              if (k) {
                const Qr = this.projectPathToScreenSpace(Ht, xe);
                Ht = Qr.some((En => En.signedDistanceFromCamera <= 0)) ? [] : Qr.map((En => En.point))
              }
              let gr = [];
              if (Ht.length > 0) {
                const Qr = Ht[0].clone(),
                  En = Ht[0].clone();
                for (let on = 1; on < Ht.length; on++) Qr.x = Math.min(Qr.x, Ht[on].x), Qr.y = Math.min(Qr.y, Ht[on].y), En.x = Math.max(En.x, Ht[on].x), En.y = Math.max(En.y, Ht[on].y);
                gr = Qr.x >= nt.x && En.x <= et.x && Qr.y >= nt.y && En.y <= et.y ? [Ht] : En.x < nt.x || Qr.x > et.x || En.y < nt.y || Qr.y > et.y ? [] : s.aC([Ht], nt.x, nt.y, et.x, et.y)
              }
              for (const Qr of gr) {
                rt.reset(Qr, .25 * Fe);
                let En = 0;
                En = rt.length <= .5 * Fe ? 1 : Math.ceil(rt.paddedLength / Pt) + 1;
                for (let on = 0; on < En; on++) {
                  const On = on / Math.max(En - 1, 1),
                    Qn = rt.lerp(On),
                    qn = Qn.x + fn,
                    gi = Qn.y + fn;
                  ae.push(qn, gi, Fe, 0);
                  const Wn = qn - Fe,
                    Mi = gi - Fe,
                    Xn = qn + Fe,
                    hi = gi + Fe;
                  if (ge = ge && this.isOffscreen(Wn, Mi, Xn, hi), Pe = Pe || this.isInsideGrid(Wn, Mi, Xn, hi), e !== "always" && this.grid.hitTestCircle(qn, gi, Fe, e, z) && (be = !0, !S)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: be
                  }
                }
              }
            }
            return {
              circles: !S && be || !Pe || se < this.perspectiveRatioCutoff ? [] : ae,
              offscreen: ge,
              collisionDetected: be
            }
          }
          projectPathToScreenSpace(e, i) {
            const l = (function(u, d) {
              const g = s.M();
              return s.au(g, d.pitchedLabelPlaneMatrix), u.map((T => {
                const S = Me(T.x, T.y, g, d.getElevation),
                  k = d.transform.projectTileCoordinates(S.point.x, S.point.y, d.unwrappedTileID, d.getElevation);
                return k.point.x = (.5 * k.point.x + .5) * d.width, k.point.y = (.5 * -k.point.y + .5) * d.height, k
              }))
            })(e, i);
            return (function(u) {
              let d = 0,
                g = 0,
                T = 0,
                S = 0;
              for (let k = 0; k < u.length; k++) u[k].isOccluded ? (T = k + 1, S = 0) : (S++, S > g && (g = S, d = T));
              return u.slice(d, d + g)
            })(l)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const i = [],
              l = new s.a6;
            for (const V of e) {
              const F = new s.P(V.x + fn, V.y + fn);
              l.extend(F), i.push(F)
            }
            const {
              minX: u,
              minY: d,
              maxX: g,
              maxY: T
            } = l, S = this.grid.query(u, d, g, T).concat(this.ignoredGrid.query(u, d, g, T)), k = {}, z = {};
            for (const V of S) {
              const F = V.key;
              if (k[F.bucketInstanceId] === void 0 && (k[F.bucketInstanceId] = {}), k[F.bucketInstanceId][F.featureIndex]) continue;
              const $ = [new s.P(V.x1, V.y1), new s.P(V.x2, V.y1), new s.P(V.x2, V.y2), new s.P(V.x1, V.y2)];
              s.aD(i, $) && (k[F.bucketInstanceId][F.featureIndex] = !0, z[F.bucketInstanceId] === void 0 && (z[F.bucketInstanceId] = []), z[F.bucketInstanceId].push(F.featureIndex))
            }
            return z
          }
          insertCollisionBox(e, i, l, u, d, g) {
            (l ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: u,
              featureIndex: d,
              collisionGroupID: g,
              overlapMode: i
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, i, l, u, d, g) {
            const T = l ? this.ignoredGrid : this.grid,
              S = {
                bucketInstanceId: u,
                featureIndex: d,
                collisionGroupID: g,
                overlapMode: i
              };
            for (let k = 0; k < e.length; k += 4) T.insertCircle(S, e[k], e[k + 1], e[k + 2])
          }
          projectAndGetPerspectiveRatio(e, i, l, u, d) {
            if (d) {
              let g;
              u ? (g = [e, i, u(e, i), 1], s.aA(g, g, d)) : (g = [e, i, 0, 1], fi(g, g, d));
              const T = g[3];
              return {
                x: (g[0] / T + 1) / 2 * this.transform.width + fn,
                y: (-g[1] / T + 1) / 2 * this.transform.height + fn,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / T * .5,
                isOccluded: !1,
                signedDistanceFromCamera: T
              }
            } {
              const g = this.transform.projectTileCoordinates(e, i, l, u);
              return {
                x: (g.point.x + 1) / 2 * this.transform.width + fn,
                y: (1 - g.point.y) / 2 * this.transform.height + fn,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * .5,
                isOccluded: g.isOccluded,
                signedDistanceFromCamera: g.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, i, l, u) {
            const d = this.transform.projectTileCoordinates(e, i, l, u);
            return .5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * .5
          }
          isOffscreen(e, i, l, u) {
            return l < fn || e >= this.screenRightBoundary || u < fn || i > this.screenBottomBoundary
          }
          isInsideGrid(e, i, l, u) {
            return l >= 0 && e < this.gridRightBoundary && u >= 0 && i < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = s.am([]);
            return s.N(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, i, l, u, d, g, T, S, k, z, V) {
            let F = 1,
              $ = 0,
              J = 0,
              ae = 1;
            const oe = e.anchorPointX + T[0],
              se = e.anchorPointY + T[1];
            if (g && !d) {
              const Ht = this.projectAndGetPerspectiveRatio(oe + 1, se, u, k, V),
                Pt = Ht.x - S.x,
                gr = Math.atan((Ht.y - S.y) / Pt) + (Pt < 0 ? Math.PI : 0),
                Qr = Math.sin(gr),
                En = Math.cos(gr);
              F = En, $ = Qr, J = -Qr, ae = En
            } else if (!g && d) {
              const Ht = st(this.transform);
              F = Ht.vecEast[0], $ = Ht.vecEast[1], J = Ht.vecSouth[0], ae = Ht.vecSouth[1]
            }
            let fe = S.x,
              xe = S.y,
              pe = i;
            d && (fe = oe, xe = se, pe = Math.pow(2, -(this.transform.zoom - l.overscaledZ)), pe *= this.transform.getPitchedTextCorrection(oe, se, u), z || (pe *= s.ai(.5 + S.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), z && (fe += F * z.x * pe + J * z.y * pe, xe += $ * z.x * pe + ae * z.y * pe);
            const be = e.x1 * pe,
              Pe = e.x2 * pe,
              ge = (be + Pe) / 2,
              Fe = e.y1 * pe,
              nt = e.y2 * pe,
              et = (Fe + nt) / 2,
              rt = [{
                offsetX: be,
                offsetY: Fe
              }, {
                offsetX: ge,
                offsetY: Fe
              }, {
                offsetX: Pe,
                offsetY: Fe
              }, {
                offsetX: Pe,
                offsetY: et
              }, {
                offsetX: Pe,
                offsetY: nt
              }, {
                offsetX: ge,
                offsetY: nt
              }, {
                offsetX: be,
                offsetY: nt
              }, {
                offsetX: be,
                offsetY: et
              }];
            let at = [];
            for (const {
                offsetX: Ht,
                offsetY: Pt
              }
              of rt) at.push(new s.P(fe + F * Ht + J * Pt, xe + $ * Ht + ae * Pt));
            let Gt = !1;
            if (d) {
              const Ht = at.map((Pt => this.projectAndGetPerspectiveRatio(Pt.x, Pt.y, u, k, V)));
              Gt = Ht.some((Pt => !Pt.isOccluded)), at = Ht.map((Pt => new s.P(Pt.x, Pt.y)))
            } else Gt = !0;
            return {
              box: s.aE(at),
              allPointsOccluded: !Gt
            }
          }
        }
        class ti {
          constructor(e, i, l, u) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : u && l ? 1 : 0, this.placed = l
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class xi {
          constructor(e, i, l, u, d) {
            this.text = new ti(e ? e.text : null, i, l, d), this.icon = new ti(e ? e.icon : null, i, u, d)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class Ri {
          constructor(e, i, l) {
            this.text = e, this.icon = i, this.skipFade = l
          }
        }
        class sa {
          constructor(e, i, l, u, d) {
            this.bucketInstanceId = e, this.featureIndex = i, this.sourceLayerIndex = l, this.bucketIndex = u, this.tileID = d
          }
        }
        class Ci {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const i = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: i,
                predicate: l => l.collisionGroupID === i
              }
            }
            return this.collisionGroups[e]
          }
        }

        function Vi(h, e, i, l, u) {
          const {
            horizontalAlign: d,
            verticalAlign: g
          } = s.aL(h);
          return new s.P(-(d - .5) * e + l[0] * u, -(g - .5) * i + l[1] * u)
        }
        class wa {
          constructor(e, i, l, u, d) {
            this.transform = e.clone(), this.terrain = i, this.collisionIndex = new oi(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new Ci(u), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const i = this.terrain;
            return i ? (l, u) => i.getElevation(e, l, u) : null
          }
          getBucketParts(e, i, l, u) {
            const d = l.getBucket(i),
              g = l.latestFeatureIndex;
            if (!d || !g || i.id !== d.layerIds[0]) return;
            const T = l.collisionBoxArray,
              S = d.layers[0].layout,
              k = d.layers[0].paint,
              z = Math.pow(2, this.transform.zoom - l.tileID.overscaledZ),
              V = l.tileSize / s.a3,
              F = l.tileID.toUnwrapped(),
              $ = S.get("text-rotation-alignment") === "map",
              J = s.aG(l, 1, this.transform.zoom),
              ae = s.aH(this.collisionIndex.transform, l, k.get("text-translate"), k.get("text-translate-anchor")),
              oe = s.aH(this.collisionIndex.transform, l, k.get("icon-translate"), k.get("icon-translate-anchor")),
              se = Pn($, this.transform, J);
            this.retainedQueryData[d.bucketInstanceId] = new sa(d.bucketInstanceId, g, d.sourceLayerIndex, d.index, l.tileID);
            const fe = {
              bucket: d,
              layout: S,
              translationText: ae,
              translationIcon: oe,
              unwrappedTileID: F,
              pitchedLabelPlaneMatrix: se,
              scale: z,
              textPixelRatio: V,
              holdingForFade: l.holdingForSymbolFade(),
              collisionBoxArray: T,
              partiallyEvaluatedTextSize: s.ar(d.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(d.sourceID)
            };
            if (u)
              for (const xe of d.sortKeyRanges) {
                const {
                  sortKey: pe,
                  symbolInstanceStart: be,
                  symbolInstanceEnd: Pe
                } = xe;
                e.push({
                  sortKey: pe,
                  symbolInstanceStart: be,
                  symbolInstanceEnd: Pe,
                  parameters: fe
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: d.symbolInstances.length,
                parameters: fe
              })
          }
          attemptAnchorPlacement(e, i, l, u, d, g, T, S, k, z, V, F, $, J, ae, oe, se, fe, xe, pe) {
            const be = s.aI[e.textAnchor],
              Pe = [e.textOffset0, e.textOffset1],
              ge = Vi(be, l, u, Pe, d),
              Fe = this.collisionIndex.placeCollisionBox(i, F, S, k, z, T, g, oe, V.predicate, xe, ge, pe);
            if ((!fe || this.collisionIndex.placeCollisionBox(fe, F, S, k, z, T, g, se, V.predicate, xe, ge, pe).placeable) && Fe.placeable) {
              let nt;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[$.crossTileID] && this.prevPlacement.placements[$.crossTileID] && this.prevPlacement.placements[$.crossTileID].text && (nt = this.prevPlacement.variableOffsets[$.crossTileID].anchor), $.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[$.crossTileID] = {
                textOffset: Pe,
                width: l,
                height: u,
                anchor: be,
                textBoxScale: d,
                prevAnchor: nt
              }, this.markUsedJustification(J, be, $, ae), J.allowVerticalPlacement && (this.markUsedOrientation(J, ae, $), this.placedOrientations[$.crossTileID] = ae), {
                shift: ge,
                placedGlyphBoxes: Fe
              }
            }
          }
          placeLayerBucketPart(e, i, l) {
            const {
              bucket: u,
              layout: d,
              translationText: g,
              translationIcon: T,
              unwrappedTileID: S,
              pitchedLabelPlaneMatrix: k,
              textPixelRatio: z,
              holdingForFade: V,
              collisionBoxArray: F,
              partiallyEvaluatedTextSize: $,
              collisionGroup: J
            } = e.parameters, ae = d.get("text-optional"), oe = d.get("icon-optional"), se = s.aJ(d, "text-overlap", "text-allow-overlap"), fe = se === "always", xe = s.aJ(d, "icon-overlap", "icon-allow-overlap"), pe = xe === "always", be = d.get("text-rotation-alignment") === "map", Pe = d.get("text-pitch-alignment") === "map", ge = d.get("icon-text-fit") !== "none", Fe = d.get("symbol-z-order") === "viewport-y", nt = fe && (pe || !u.hasIconData() || oe), et = pe && (fe || !u.hasTextData() || ae);
            !u.collisionArrays && F && u.deserializeCollisionBoxes(F);
            const rt = this.retainedQueryData[u.bucketInstanceId].tileID,
              at = this._getTerrainElevationFunc(rt),
              Gt = this.transform.getFastPathSimpleProjectionMatrix(rt),
              Ht = (Pt, gr, Qr) => {
                var En, on;
                if (i[Pt.crossTileID]) return;
                if (V) return void(this.placements[Pt.crossTileID] = new Ri(!1, !1, !1));
                let On = !1,
                  Qn = !1,
                  qn = !0,
                  gi = null,
                  Wn = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Mi = {
                    placeable: !1
                  },
                  Xn = null,
                  hi = null,
                  Ki = null,
                  Wo = 0,
                  ao = 0,
                  Za = 0;
                gr.textFeatureIndex ? Wo = gr.textFeatureIndex : Pt.useRuntimeCollisionCircles && (Wo = Pt.featureIndex), gr.verticalTextFeatureIndex && (ao = gr.verticalTextFeatureIndex);
                const Xo = gr.textBox;
                if (Xo) {
                  const Ji = di => {
                      let li = s.as.horizontal;
                      if (u.allowVerticalPlacement && !di && this.prevPlacement) {
                        const Ai = this.prevPlacement.placedOrientations[Pt.crossTileID];
                        Ai && (this.placedOrientations[Pt.crossTileID] = Ai, li = Ai, this.markUsedOrientation(u, li, Pt))
                      }
                      return li
                    },
                    oo = (di, li) => {
                      if (u.allowVerticalPlacement && Pt.numVerticalGlyphVertices > 0 && gr.verticalTextBox) {
                        for (const Ai of u.writingModes)
                          if (Ai === s.as.vertical ? (Wn = li(), Mi = Wn) : Wn = di(), Wn && Wn.placeable) break
                      } else Wn = di()
                    },
                    wo = Pt.textAnchorOffsetStartIndex,
                    ol = Pt.textAnchorOffsetEndIndex;
                  if (ol === wo) {
                    const di = (li, Ai) => {
                      const $n = this.collisionIndex.placeCollisionBox(li, se, z, rt, S, Pe, be, g, J.predicate, at, void 0, Gt);
                      return $n && $n.placeable && (this.markUsedOrientation(u, Ai, Pt), this.placedOrientations[Pt.crossTileID] = Ai), $n
                    };
                    oo((() => di(Xo, s.as.horizontal)), (() => {
                      const li = gr.verticalTextBox;
                      return u.allowVerticalPlacement && Pt.numVerticalGlyphVertices > 0 && li ? di(li, s.as.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), Ji(Wn && Wn.placeable)
                  } else {
                    let di = s.aI[(on = (En = this.prevPlacement) === null || En === void 0 ? void 0 : En.variableOffsets[Pt.crossTileID]) === null || on === void 0 ? void 0 : on.anchor];
                    const li = ($n, Ma, To) => {
                      const Wd = $n.x2 - $n.x1,
                        Xd = $n.y2 - $n.y1,
                        Yd = Pt.textBoxScale,
                        Ko = ge && xe === "never" ? Ma : null;
                      let Jo = null,
                        Au = se === "never" ? 1 : 2,
                        ic = "never";
                      di && Au++;
                      for (let ku = 0; ku < Au; ku++) {
                        for (let so = wo; so < ol; so++) {
                          const So = u.textAnchorOffsets.get(so);
                          if (di && So.textAnchor !== di) continue;
                          const ac = this.attemptAnchorPlacement(So, $n, Wd, Xd, Yd, be, Pe, z, rt, S, J, ic, Pt, u, To, g, T, Ko, at);
                          if (ac && (Jo = ac.placedGlyphBoxes, Jo && Jo.placeable)) return On = !0, gi = ac.shift, Jo
                        }
                        di ? di = null : ic = se
                      }
                      return l && !Jo && (Jo = {
                        box: this.collisionIndex.placeCollisionBox(Xo, "always", z, rt, S, Pe, be, g, J.predicate, at, void 0, Gt).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), Jo
                    };
                    oo((() => li(Xo, gr.iconBox, s.as.horizontal)), (() => {
                      const $n = gr.verticalTextBox;
                      return u.allowVerticalPlacement && (!Wn || !Wn.placeable) && Pt.numVerticalGlyphVertices > 0 && $n ? li($n, gr.verticalIconBox, s.as.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), Wn && (On = Wn.placeable, qn = Wn.offscreen);
                    const Ai = Ji(Wn && Wn.placeable);
                    if (!On && this.prevPlacement) {
                      const $n = this.prevPlacement.variableOffsets[Pt.crossTileID];
                      $n && (this.variableOffsets[Pt.crossTileID] = $n, this.markUsedJustification(u, $n.anchor, Pt, Ai))
                    }
                  }
                }
                if (Xn = Wn, On = Xn && Xn.placeable, qn = Xn && Xn.offscreen, Pt.useRuntimeCollisionCircles && Pt.centerJustifiedTextSymbolIndex >= 0) {
                  const Ji = u.text.placedSymbolArray.get(Pt.centerJustifiedTextSymbolIndex),
                    oo = s.at(u.textSizeData, $, Ji),
                    wo = d.get("text-padding");
                  hi = this.collisionIndex.placeCollisionCircles(se, Ji, u.lineVertexArray, u.glyphOffsetArray, oo, S, k, l, Pe, J.predicate, Pt.collisionCircleDiameter, wo, g, at), hi.circles.length && hi.collisionDetected && !l && s.w("Collisions detected, but collision boxes are not shown"), On = fe || hi.circles.length > 0 && !hi.collisionDetected, qn = qn && hi.offscreen
                }
                if (gr.iconFeatureIndex && (Za = gr.iconFeatureIndex), gr.iconBox) {
                  const Ji = oo => this.collisionIndex.placeCollisionBox(oo, xe, z, rt, S, Pe, be, T, J.predicate, at, ge && gi ? gi : void 0, Gt);
                  Mi && Mi.placeable && gr.verticalIconBox ? (Ki = Ji(gr.verticalIconBox), Qn = Ki.placeable) : (Ki = Ji(gr.iconBox), Qn = Ki.placeable), qn = qn && Ki.offscreen
                }
                const Cs = ae || Pt.numHorizontalGlyphVertices === 0 && Pt.numVerticalGlyphVertices === 0,
                  Yo = oe || Pt.numIconVertices === 0;
                Cs || Yo ? Yo ? Cs || (Qn = Qn && On) : On = Qn && On : Qn = On = Qn && On;
                const na = Qn && Ki.placeable;
                if (On && Xn.placeable && this.collisionIndex.insertCollisionBox(Xn.box, se, d.get("text-ignore-placement"), u.bucketInstanceId, Mi && Mi.placeable && ao ? ao : Wo, J.ID), na && this.collisionIndex.insertCollisionBox(Ki.box, xe, d.get("icon-ignore-placement"), u.bucketInstanceId, Za, J.ID), hi && On && this.collisionIndex.insertCollisionCircles(hi.circles, se, d.get("text-ignore-placement"), u.bucketInstanceId, Wo, J.ID), l && this.storeCollisionData(u.bucketInstanceId, Qr, gr, Xn, Ki, hi), Pt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (u.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[Pt.crossTileID] = new Ri((On || nt) && !(Xn != null && Xn.occluded), (Qn || et) && !(Ki != null && Ki.occluded), qn || u.justReloaded), i[Pt.crossTileID] = !0
              };
            if (Fe) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Pt = u.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let gr = Pt.length - 1; gr >= 0; --gr) {
                const Qr = Pt[gr];
                Ht(u.symbolInstances.get(Qr), u.collisionArrays[Qr], Qr)
              }
            } else
              for (let Pt = e.symbolInstanceStart; Pt < e.symbolInstanceEnd; Pt++) Ht(u.symbolInstances.get(Pt), u.collisionArrays[Pt], Pt);
            u.justReloaded = !1
          }
          storeCollisionData(e, i, l, u, d, g) {
            if (l.textBox || l.iconBox) {
              let T, S;
              this.collisionBoxArrays.has(e) ? T = this.collisionBoxArrays.get(e) : (T = new Map, this.collisionBoxArrays.set(e, T)), T.has(i) ? S = T.get(i) : (S = {
                text: null,
                icon: null
              }, T.set(i, S)), l.textBox && (S.text = u.box), l.iconBox && (S.icon = d.box)
            }
            if (g) {
              let T = this.collisionCircleArrays[e];
              T === void 0 && (T = this.collisionCircleArrays[e] = []);
              for (let S = 0; S < g.circles.length; S += 4) T.push(g.circles[S + 0] - fn), T.push(g.circles[S + 1] - fn), T.push(g.circles[S + 2]), T.push(g.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, i, l, u) {
            let d;
            d = u === s.as.vertical ? l.verticalPlacedTextSymbolIndex : {
              left: l.leftJustifiedTextSymbolIndex,
              center: l.centerJustifiedTextSymbolIndex,
              right: l.rightJustifiedTextSymbolIndex
            } [s.aK(i)];
            const g = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex, l.verticalPlacedTextSymbolIndex];
            for (const T of g) T >= 0 && (e.text.placedSymbolArray.get(T).crossTileID = d >= 0 && T !== d ? 0 : l.crossTileID)
          }
          markUsedOrientation(e, i, l) {
            const u = i === s.as.horizontal || i === s.as.horizontalOnly ? i : 0,
              d = i === s.as.vertical ? i : 0,
              g = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex];
            for (const T of g) e.text.placedSymbolArray.get(T).placedOrientation = u;
            l.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(l.verticalPlacedTextSymbolIndex).placedOrientation = d)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const i = this.prevPlacement;
            let l = !1;
            this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
            const u = i ? i.symbolFadeChange(e) : 1,
              d = i ? i.opacities : {},
              g = i ? i.variableOffsets : {},
              T = i ? i.placedOrientations : {};
            for (const S in this.placements) {
              const k = this.placements[S],
                z = d[S];
              z ? (this.opacities[S] = new xi(z, u, k.text, k.icon), l = l || k.text !== z.text.placed || k.icon !== z.icon.placed) : (this.opacities[S] = new xi(null, u, k.text, k.icon, k.skipFade), l = l || k.text || k.icon)
            }
            for (const S in d) {
              const k = d[S];
              if (!this.opacities[S]) {
                const z = new xi(k, u, !1, !1);
                z.isHidden() || (this.opacities[S] = z, l = l || k.text.placed || k.icon.placed)
              }
            }
            for (const S in g) this.variableOffsets[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.variableOffsets[S] = g[S]);
            for (const S in T) this.placedOrientations[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.placedOrientations[S] = T[S]);
            if (i && i.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            l ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, i) {
            const l = {};
            for (const u of i) {
              const d = u.getBucket(e);
              d && u.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, u.tileID, l, u.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, i, l, u) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const d = e.layers[0],
              g = d.layout,
              T = new xi(null, 0, !1, !1, !0),
              S = g.get("text-allow-overlap"),
              k = g.get("icon-allow-overlap"),
              z = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              V = g.get("text-rotation-alignment") === "map",
              F = g.get("text-pitch-alignment") === "map",
              $ = g.get("icon-text-fit") !== "none",
              J = new xi(null, 0, S && (k || !e.hasIconData() || g.get("icon-optional")), k && (S || !e.hasTextData() || g.get("text-optional")), !0);
            !e.collisionArrays && u && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(u);
            const ae = (se, fe, xe) => {
                for (let pe = 0; pe < fe / 4; pe++) se.opacityVertexArray.emplaceBack(xe);
                se.hasVisibleVertices = se.hasVisibleVertices || xe !== mi
              },
              oe = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let se = 0; se < e.symbolInstances.length; se++) {
              const fe = e.symbolInstances.get(se),
                {
                  numHorizontalGlyphVertices: xe,
                  numVerticalGlyphVertices: pe,
                  crossTileID: be
                } = fe;
              let Pe = this.opacities[be];
              l[be] ? Pe = T : Pe || (Pe = J, this.opacities[be] = Pe), l[be] = !0;
              const ge = fe.numIconVertices > 0,
                Fe = this.placedOrientations[fe.crossTileID],
                nt = Fe === s.as.vertical,
                et = Fe === s.as.horizontal || Fe === s.as.horizontalOnly;
              if (xe > 0 || pe > 0) {
                const at = Zn(Pe.text);
                ae(e.text, xe, nt ? mi : at), ae(e.text, pe, et ? mi : at);
                const Gt = Pe.text.isHidden();
                [fe.rightJustifiedTextSymbolIndex, fe.centerJustifiedTextSymbolIndex, fe.leftJustifiedTextSymbolIndex].forEach((gr => {
                  gr >= 0 && (e.text.placedSymbolArray.get(gr).hidden = Gt || nt ? 1 : 0)
                })), fe.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(fe.verticalPlacedTextSymbolIndex).hidden = Gt || et ? 1 : 0);
                const Ht = this.variableOffsets[fe.crossTileID];
                Ht && this.markUsedJustification(e, Ht.anchor, fe, Fe);
                const Pt = this.placedOrientations[fe.crossTileID];
                Pt && (this.markUsedJustification(e, "left", fe, Pt), this.markUsedOrientation(e, Pt, fe))
              }
              if (ge) {
                const at = Zn(Pe.icon),
                  Gt = !($ && fe.verticalPlacedIconSymbolIndex && nt);
                fe.placedIconSymbolIndex >= 0 && (ae(e.icon, fe.numIconVertices, Gt ? at : mi), e.icon.placedSymbolArray.get(fe.placedIconSymbolIndex).hidden = Pe.icon.isHidden()), fe.verticalPlacedIconSymbolIndex >= 0 && (ae(e.icon, fe.numVerticalIconVertices, Gt ? mi : at), e.icon.placedSymbolArray.get(fe.verticalPlacedIconSymbolIndex).hidden = Pe.icon.isHidden())
              }
              const rt = oe && oe.has(se) ? oe.get(se) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const at = e.collisionArrays[se];
                if (at) {
                  let Gt = new s.P(0, 0);
                  if (at.textBox || at.verticalTextBox) {
                    let Ht = !0;
                    if (z) {
                      const Pt = this.variableOffsets[be];
                      Pt ? (Gt = Vi(Pt.anchor, Pt.width, Pt.height, Pt.textOffset, Pt.textBoxScale), V && Gt._rotate(F ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Ht = !1
                    }
                    if (at.textBox || at.verticalTextBox) {
                      let Pt;
                      at.textBox && (Pt = nt), at.verticalTextBox && (Pt = et), ga(e.textCollisionBox.collisionVertexArray, Pe.text.placed, !Ht || Pt, rt.text, Gt.x, Gt.y)
                    }
                  }
                  if (at.iconBox || at.verticalIconBox) {
                    const Ht = !!(!et && at.verticalIconBox);
                    let Pt;
                    at.iconBox && (Pt = Ht), at.verticalIconBox && (Pt = !Ht), ga(e.iconCollisionBox.collisionVertexArray, Pe.icon.placed, Pt, rt.icon, $ ? Gt.x : 0, $ ? Gt.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, i) {
            const l = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
            return this.zoomAtLastRecencyCheck = i, this.commitTime + this.fadeDuration * l > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function ga(h, e, i, l, u, d) {
          l && l.length !== 0 || (l = [0, 0, 0, 0]);
          const g = l[0] - fn,
            T = l[1] - fn,
            S = l[2] - fn,
            k = l[3] - fn;
          h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, T), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, S, T), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, S, k), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, k)
        }
        const Oa = Math.pow(2, 25),
          hs = Math.pow(2, 24),
          Ta = Math.pow(2, 17),
          vt = Math.pow(2, 16),
          Yt = Math.pow(2, 9),
          Gr = Math.pow(2, 8),
          Cn = Math.pow(2, 1);

        function Zn(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0,
            i = Math.floor(127 * h.opacity);
          return i * Oa + e * hs + i * Ta + e * vt + i * Yt + e * Gr + i * Cn + e
        }
        const mi = 0;
        class Gn {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, i, l, u, d) {
            const g = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (i.getBucketParts(g, u, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, d()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort(((T, S) => T.sortKey - S.sortKey))); this._currentPartIndex < g.length;)
              if (i.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, l), this._currentPartIndex++, d()) return !0;
            return !1
          }
        }
        class An {
          constructor(e, i, l, u, d, g, T, S) {
            this.placement = new wa(e, i, g, T, S), this._currentPlacementIndex = l.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = d, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, i, l) {
            const u = ne(),
              d = () => !this._forceFullPlacement && ne() - u > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const g = i[e[this._currentPlacementIndex]],
                T = this.placement.collisionIndex.transform.zoom;
              if (g.type === "symbol" && (!g.minzoom || g.minzoom <= T) && (!g.maxzoom || g.maxzoom > T)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Gn(g)), this._inProgressLayer.continuePlacement(l[g.source], this.placement, this._showCollisionBoxes, g, d)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const qi = 512 / s.a3 / 2;
        class yr {
          constructor(e, i, l) {
            this.tileID = e, this.bucketInstanceId = l, this._symbolsByKey = {};
            const u = new Map;
            for (let d = 0; d < i.length; d++) {
              const g = i.get(d),
                T = g.key,
                S = u.get(T);
              S ? S.push(g) : u.set(T, [g])
            }
            for (const [d, g] of u) {
              const T = {
                positions: g.map((S => ({
                  x: Math.floor(S.anchorX * qi),
                  y: Math.floor(S.anchorY * qi)
                }))),
                crossTileIDs: g.map((S => S.crossTileID))
              };
              if (T.positions.length > 128) {
                const S = new s.aM(T.positions.length, 16, Uint16Array);
                for (const {
                    x: k,
                    y: z
                  }
                  of T.positions) S.add(k, z);
                S.finish(), delete T.positions, T.index = S
              }
              this._symbolsByKey[d] = T
            }
          }
          getScaledCoordinates(e, i) {
            const {
              x: l,
              y: u,
              z: d
            } = this.tileID.canonical, {
              x: g,
              y: T,
              z: S
            } = i.canonical, k = qi / Math.pow(2, S - d), z = (T * s.a3 + e.anchorY) * k, V = u * s.a3 * qi;
            return {
              x: Math.floor((g * s.a3 + e.anchorX) * k - l * s.a3 * qi),
              y: Math.floor(z - V)
            }
          }
          findMatches(e, i, l) {
            const u = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
            for (let d = 0; d < e.length; d++) {
              const g = e.get(d);
              if (g.crossTileID) continue;
              const T = this._symbolsByKey[g.key];
              if (!T) continue;
              const S = this.getScaledCoordinates(g, i);
              if (T.index) {
                const k = T.index.range(S.x - u, S.y - u, S.x + u, S.y + u).sort();
                for (const z of k) {
                  const V = T.crossTileIDs[z];
                  if (!l[V]) {
                    l[V] = !0, g.crossTileID = V;
                    break
                  }
                }
              } else if (T.positions)
                for (let k = 0; k < T.positions.length; k++) {
                  const z = T.positions[k],
                    V = T.crossTileIDs[k];
                  if (Math.abs(z.x - S.x) <= u && Math.abs(z.y - S.y) <= u && !l[V]) {
                    l[V] = !0, g.crossTileID = V;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class dr {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class Tn {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const i = Math.round((e - this.lng) / 360);
            if (i !== 0)
              for (const l in this.indexes) {
                const u = this.indexes[l],
                  d = {};
                for (const g in u) {
                  const T = u[g];
                  T.tileID = T.tileID.unwrapTo(T.tileID.wrap + i), d[T.tileID.key] = T
                }
                this.indexes[l] = d
              }
            this.lng = e
          }
          addBucket(e, i, l) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let d = 0; d < i.symbolInstances.length; d++) i.symbolInstances.get(d).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const u = this.usedCrossTileIDs[e.overscaledZ];
            for (const d in this.indexes) {
              const g = this.indexes[d];
              if (Number(d) > e.overscaledZ)
                for (const T in g) {
                  const S = g[T];
                  S.tileID.isChildOf(e) && S.findMatches(i.symbolInstances, e, u)
                } else {
                  const T = g[e.scaledTo(Number(d)).key];
                  T && T.findMatches(i.symbolInstances, e, u)
                }
            }
            for (let d = 0; d < i.symbolInstances.length; d++) {
              const g = i.symbolInstances.get(d);
              g.crossTileID || (g.crossTileID = l.generate(), u[g.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new yr(e, i.symbolInstances, i.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, i) {
            for (const l of i.getCrossTileIDsLists())
              for (const u of l) delete this.usedCrossTileIDs[e][u]
          }
          removeStaleBuckets(e) {
            let i = !1;
            for (const l in this.indexes) {
              const u = this.indexes[l];
              for (const d in u) e[u[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(l, u[d]), delete u[d], i = !0)
            }
            return i
          }
        }
        class gn {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new dr, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, i, l) {
            let u = this.layerIndexes[e.id];
            u === void 0 && (u = this.layerIndexes[e.id] = new Tn);
            let d = !1;
            const g = {};
            u.handleWrapJump(l);
            for (const T of i) {
              const S = T.getBucket(e);
              S && e.id === S.layerIds[0] && (S.bucketInstanceId || (S.bucketInstanceId = ++this.maxBucketInstanceId), u.addBucket(T.tileID, S, this.crossTileIDs) && (d = !0), g[S.bucketInstanceId] = !0)
            }
            return u.removeStaleBuckets(g) && (d = !0), d
          }
          pruneUnusedLayers(e) {
            const i = {};
            e.forEach((l => {
              i[l] = !0
            }));
            for (const l in this.layerIndexes) i[l] || delete this.layerIndexes[l]
          }
        }
        var zn = "void main() {fragColor=vec4(1.0);}";
        const pr = {
          prelude: Er(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: Er("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: Er("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: Er(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: Er(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: Er(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: Er(zn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: Er(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: Er(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: Er("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: Er("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: Er("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: Er(zn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: Er(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: Er(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: Er(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: Er(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: Er(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: Er(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: Er(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: Er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: Er(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          lineGradientSDF: Er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          raster: Er(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: Er(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: Er(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: Er(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: Er("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: Er("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: Er("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: Er("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: Er(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: Er("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function Er(h, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            l = e.match(/in ([\w]+) ([\w]+)/g),
            u = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            g = d ? d.concat(u) : u,
            T = {};
          return {
            fragmentSource: h = h.replace(i, ((S, k, z, V, F) => (T[F] = !0, k === "define" ? `
#ifndef HAS_UNIFORM_u_${F}
in ${z} ${V} ${F};
#else
uniform ${z} ${V} u_${F};
#endif
` : `
#ifdef HAS_UNIFORM_u_${F}
    ${z} ${V} ${F} = u_${F};
#endif
`))),
            vertexSource: e = e.replace(i, ((S, k, z, V, F) => {
              const $ = V === "float" ? "vec2" : "vec4",
                J = F.match(/color/) ? "color" : $;
              return T[F] ? k === "define" ? `
#ifndef HAS_UNIFORM_u_${F}
uniform lowp float u_${F}_t;
in ${z} ${$} a_${F};
out ${z} ${V} ${F};
#else
uniform ${z} ${V} u_${F};
#endif
` : J === "vec4" ? `
#ifndef HAS_UNIFORM_u_${F}
    ${F} = a_${F};
#else
    ${z} ${V} ${F} = u_${F};
#endif
` : `
#ifndef HAS_UNIFORM_u_${F}
    ${F} = unpack_mix_${J}(a_${F}, u_${F}_t);
#else
    ${z} ${V} ${F} = u_${F};
#endif
` : k === "define" ? `
#ifndef HAS_UNIFORM_u_${F}
uniform lowp float u_${F}_t;
in ${z} ${$} a_${F};
#else
uniform ${z} ${V} u_${F};
#endif
` : J === "vec4" ? `
#ifndef HAS_UNIFORM_u_${F}
    ${z} ${V} ${F} = a_${F};
#else
    ${z} ${V} ${F} = u_${F};
#endif
` : `
#ifndef HAS_UNIFORM_u_${F}
    ${z} ${V} ${F} = unpack_mix_${J}(a_${F}, u_${F}_t);
#else
    ${z} ${V} ${F} = u_${F};
#endif
`
            })),
            staticAttributes: l,
            staticUniforms: g
          }
        }
        class ri {
          constructor(e, i, l) {
            this.vertexBuffer = e, this.indexBuffer = i, this.segments = l
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var jn = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const Sn = "#define PROJECTION_MERCATOR",
          en = "mercator";
        class Rr {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return en
          }
          get shaderDefine() {
            return Sn
          }
          get shaderPreludeCode() {
            return pr.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return pr.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return s.aO.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, i, l, u, d) {
            if (this._cachedMesh) return this._cachedMesh;
            const g = new s.aP;
            g.emplaceBack(0, 0), g.emplaceBack(s.a3, 0), g.emplaceBack(0, s.a3), g.emplaceBack(s.a3, s.a3);
            const T = e.createVertexBuffer(g, jn.members),
              S = s.aQ.simpleSegment(0, 0, 4, 2),
              k = new s.aR;
            k.emplaceBack(1, 0, 2), k.emplaceBack(1, 2, 3);
            const z = e.createIndexBuffer(k);
            return this._cachedMesh = new ri(T, z, S), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class vn {
          constructor(e = 0, i = 0, l = 0, u = 0) {
            if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(l) || l < 0 || isNaN(u) || u < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = i, this.left = l, this.right = u
          }
          interpolate(e, i, l) {
            return i.top != null && e.top != null && (this.top = s.F.number(e.top, i.top, l)), i.bottom != null && e.bottom != null && (this.bottom = s.F.number(e.bottom, i.bottom, l)), i.left != null && e.left != null && (this.left = s.F.number(e.left, i.left, l)), i.right != null && e.right != null && (this.right = s.F.number(e.right, i.right, l)), this
          }
          getCenter(e, i) {
            const l = s.ai((this.left + e - this.right) / 2, 0, e),
              u = s.ai((this.top + i - this.bottom) / 2, 0, i);
            return new s.P(l, u)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new vn(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function Yr(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const i = e.lng - h.center.lng;
          e.lng += i > 180 ? -360 : i < -180 ? 360 : 0
        }

        function Ln(h) {
          return Math.max(0, Math.floor(h))
        }
        class In {
          constructor(e, i) {
            var l;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (i == null ? void 0 : i.renderWorldCopies) === void 0 || !!(i != null && i.renderWorldCopies), this._minZoom = (i == null ? void 0 : i.minZoom) || 0, this._maxZoom = (i == null ? void 0 : i.maxZoom) || 22, this._minPitch = (i == null ? void 0 : i.minPitch) == null ? 0 : i == null ? void 0 : i.minPitch, this._maxPitch = (i == null ? void 0 : i.maxPitch) == null ? 60 : i == null ? void 0 : i.maxPitch, this._constrain = (l = i == null ? void 0 : i.constrain) !== null && l !== void 0 ? l : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ln(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new vn, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, i, l) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Ln(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new vn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !l && e.autoCalculateNearFarZ, i && this.constrainInternal(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get constrain() {
            return this._constrain
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices()
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new s.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const i = s.V(e, -180, 180) * Math.PI / 180;
            var l, u, d, g, T, S, k, z, V;
            this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = j(), l = this._rotationMatrix, d = -this._bearingInRadians, g = (u = this._rotationMatrix)[0], T = u[1], S = u[2], k = u[3], z = Math.sin(d), V = Math.cos(d), l[0] = g * V + S * z, l[1] = T * V + k * z, l[2] = g * -z + S * V, l[3] = T * -z + k * V)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const i = s.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const i = e / 180 * Math.PI;
            this._rollInRadians !== i && (this._unmodified = !1, this._rollInRadians = i, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return s.aS(this._fovInRadians)
          }
          setFov(e) {
            e = s.ai(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = s.ak(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const i = this.constrain(this._center, e).zoom;
            this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = s.al(i), this.constrainInternal(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, i) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = i, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, i, l) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, i, l), this.constrainInternal(), this._calcMatrices()
          }
          resize(e, i, l = !0) {
            this._width = e, this._height = i, l && this.constrainInternal(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new It([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-s.aj, s.aj])
          }
          getCameraQueryGeometry(e, i) {
            if (i.length === 1) return [i[0], e];
            {
              const {
                minX: l,
                minY: u,
                maxX: d,
                maxY: g
              } = s.a6.fromPoints(i).extend(e);
              return [new s.P(l, u), new s.P(d, u), new s.P(d, g), new s.P(l, g), new s.P(l, u)]
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: i,
                zoom: l
              } = this.constrain(this.center, this.zoom);
            this.setCenter(i), this.setZoom(l), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.am(new Float64Array(16));
              s.O(e, e, [this._width / 2, -this._height / 2, 1]), s.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.am(new Float64Array(16)), s.O(e, e, [1, -1, 1]), s.N(e, e, [-1, -1, 0]), s.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            const d = l !== void 0 ? l : this.bearing,
              g = u = u !== void 0 ? u : this.pitch,
              T = s.a5.fromLngLat(e, i),
              S = -Math.cos(s.ak(g)),
              k = Math.sin(s.ak(g)),
              z = k * Math.sin(s.ak(d)),
              V = -k * Math.cos(s.ak(d));
            let F = this.elevation;
            const $ = i - F;
            let J;
            S * $ >= 0 || Math.abs(S) < .1 ? (J = 1e4, F = i + J * S) : J = -$ / S;
            let ae, oe, se = s.aT(1, T.y),
              fe = 0;
            do {
              if (fe += 1, fe > 10) break;
              oe = J / se, ae = new s.a5(T.x + z * oe, T.y + V * oe), se = 1 / ae.meterInMercatorCoordinateUnits()
            } while (Math.abs(J - oe * se) > 1e-12);
            return {
              center: ae.toLngLat(),
              elevation: F,
              zoom: s.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / oe / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const i = s.an(1, this.center.lat) * this.worldSize,
              l = this.cameraToCenterDistance / i,
              u = s.a5.fromLngLat(this.center, this.elevation),
              d = _e(this.center, this.elevation, this.pitch, this.bearing, l);
            this._elevation = e;
            const g = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), s.aT(d.z, u.y), this.bearing, this.pitch);
            this._elevation = g.elevation, this._center = g.center, this.setZoom(g.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return _e(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / i, e.canonical.y / i, 1 / i / s.a3, 1 / i / s.a3]
          }
        }
        class Vn {
          constructor(e, i) {
            this.min = e, this.max = i, this.center = s.aU([], s.aV([], this.min, this.max), .5)
          }
          quadrant(e) {
            const i = [e % 2 == 0, e < 2],
              l = s.aW(this.min),
              u = s.aW(this.max);
            for (let d = 0; d < i.length; d++) l[d] = i[d] ? this.min[d] : this.center[d], u[d] = i[d] ? this.center[d] : this.max[d];
            return u[2] = this.max[2], new Vn(l, u)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let i = !0;
            for (let l = 0; l < e.planes.length; l++) {
              const u = this.intersectsPlane(e.planes[l]);
              if (u === 0) return 0;
              u === 1 && (i = !1)
            }
            return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let i = e[3],
              l = e[3];
            for (let u = 0; u < 3; u++) e[u] > 0 ? (i += e[u] * this.min[u], l += e[u] * this.max[u]) : (l += e[u] * this.min[u], i += e[u] * this.max[u]);
            return i >= 0 ? 2 : l < 0 ? 0 : 1
          }
        }
        class _i {
          distanceToTile2d(e, i, l, u) {
            const d = u.distanceX([e, i]),
              g = u.distanceY([e, i]);
            return Math.hypot(d, g)
          }
          getWrap(e, i, l) {
            return l
          }
          getTileBoundingVolume(e, i, l, u) {
            var d, g;
            let T = 0,
              S = 0;
            if (u != null && u.terrain) {
              const z = new s.a0(e.z, i, e.z, e.x, e.y),
                V = u.terrain.getMinMaxElevation(z);
              T = (d = V.minElevation) !== null && d !== void 0 ? d : Math.min(0, l), S = (g = V.maxElevation) !== null && g !== void 0 ? g : Math.max(0, l)
            }
            const k = 1 << e.z;
            return new Vn([i + e.x / k, e.y / k, T], [i + (e.x + 1) / k, (e.y + 1) / k, S])
          }
          allowVariableZoom(e, i) {
            const l = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              u = s.ai(78.5 - l / 2, 0, 60);
            return !!i.terrain || e.pitch > u
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class Ka {
          constructor(e, i, l) {
            this.points = e, this.planes = i, this.aabb = l
          }
          static fromInvProjectionMatrix(e, i = 1, l = 0, u, d) {
            const g = d ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              T = Math.pow(2, l),
              S = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((F => (function($, J, ae, oe) {
                const se = s.aA([], $, J),
                  fe = 1 / se[3] / ae * oe;
                return s.a$(se, se, [fe, fe, 1 / se[3], fe])
              })(F, e, i, T)));
            u && (function(F, $, J, ae) {
              const oe = ae ? 4 : 0,
                se = ae ? 0 : 4;
              let fe = 0;
              const xe = [],
                pe = [];
              for (let ge = 0; ge < 4; ge++) {
                const Fe = s.aX([], F[ge + se], F[ge + oe]),
                  nt = s.b0(Fe);
                s.aU(Fe, Fe, 1 / nt), xe.push(nt), pe.push(Fe)
              }
              for (let ge = 0; ge < 4; ge++) {
                const Fe = s.b1(F[ge + oe], pe[ge], J);
                fe = Fe !== null && Fe >= 0 ? Math.max(fe, Fe) : Math.max(fe, xe[ge])
              }
              const be = (function(ge, Fe) {
                  const nt = s.aX([], ge[Fe[0]], ge[Fe[1]]),
                    et = s.aX([], ge[Fe[2]], ge[Fe[1]]),
                    rt = [0, 0, 0, 0];
                  return s.aY(rt, s.aZ([], nt, et)), rt[3] = -s.a_(rt, ge[Fe[0]]), rt
                })(F, $),
                Pe = (function(ge, Fe) {
                  const nt = s.b2(ge),
                    et = s.b3([], ge, 1 / nt),
                    rt = s.aX([], Fe, s.aU([], et, s.a_(Fe, et))),
                    at = s.b2(rt);
                  if (at > 0) {
                    const Gt = Math.sqrt(1 - et[3] * et[3]),
                      Ht = s.aU([], et, -et[3]),
                      Pt = s.aV([], Ht, s.aU([], rt, Gt / at));
                    return s.b4(Fe, Pt)
                  }
                  return null
                })(J, be);
              if (Pe !== null) {
                const ge = Pe / s.a_(pe[0], be);
                fe = Math.min(fe, ge)
              }
              for (let ge = 0; ge < 4; ge++) {
                const Fe = Math.min(fe, xe[ge]);
                F[ge + se] = [F[ge + oe][0] + pe[ge][0] * Fe, F[ge + oe][1] + pe[ge][1] * Fe, F[ge + oe][2] + pe[ge][2] * Fe, 1]
              }
            })(S, g[0], u, d);
            const k = g.map((F => {
                const $ = s.aX([], S[F[0]], S[F[1]]),
                  J = s.aX([], S[F[2]], S[F[1]]),
                  ae = s.aY([], s.aZ([], $, J)),
                  oe = -s.a_(ae, S[F[1]]);
                return ae.concat(oe)
              })),
              z = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              V = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const F of S)
              for (let $ = 0; $ < 3; $++) z[$] = Math.min(z[$], F[$]), V[$] = Math.max(V[$], F[$]);
            return new Ka(S, k, new Vn(z, V))
          }
        }
        class Pi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, i) {}
          constructor(e) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (i, l) => {
              l = s.ai(+l, this.minZoom, this.maxZoom);
              const u = {
                center: new s.U(i.lng, i.lat),
                zoom: l
              };
              let d = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && d === null) {
                const pe = 179.9999999999;
                d = [-pe, pe]
              }
              const g = this.tileSize * s.al(u.zoom);
              let T = 0,
                S = g,
                k = 0,
                z = g,
                V = 0,
                F = 0;
              const {
                x: $,
                y: J
              } = this.size;
              if (this._helper._latRange) {
                const pe = this._helper._latRange;
                T = s.W(pe[1]) * g, S = s.W(pe[0]) * g, S - T < J && (V = J / (S - T))
              }
              d && (k = s.V(s.X(d[0]) * g, 0, g), z = s.V(s.X(d[1]) * g, 0, g), z < k && (z += g), z - k < $ && (F = $ / (z - k)));
              const {
                x: ae,
                y: oe
              } = Se(g, i);
              let se, fe;
              const xe = Math.max(F || 0, V || 0);
              if (xe) {
                const pe = new s.P(F ? (z + k) / 2 : ae, V ? (S + T) / 2 : oe);
                return u.center = Ye(g, pe).wrap(), u.zoom += s.ao(xe), u
              }
              if (this._helper._latRange) {
                const pe = J / 2;
                oe - pe < T && (fe = T + pe), oe + pe > S && (fe = S - pe)
              }
              if (d) {
                const pe = (k + z) / 2;
                let be = ae;
                this._helper._renderWorldCopies && (be = s.V(ae, pe - g / 2, pe + g / 2));
                const Pe = $ / 2;
                be - Pe < k && (se = k + Pe), be + Pe > z && (se = z - Pe)
              }
              if (se !== void 0 || fe !== void 0) {
                const pe = new s.P(se ?? ae, fe ?? oe);
                u.center = Ye(g, pe).wrap()
              }
              return u
            }, this._helper = new In({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (i, l) => this.defaultConstrain(i, l)
            }, e), this._coveringTilesDetailsProvider = new _i
          }
          clone() {
            const e = new Pi;
            return e.apply(this), e
          }
          apply(e, i, l) {
            this._helper.apply(e, i, l)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const i = [new s.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const l = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
                u = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)),
                d = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)),
                g = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)),
                T = Math.floor(Math.min(l.x, u.x, d.x, g.x)),
                S = Math.floor(Math.max(l.x, u.x, d.x, g.x)),
                k = 1;
              for (let z = T - k; z <= S + k; z++) z !== 0 && i.push(new s.b5(z, e))
            }
            return i
          }
          getCameraFrustum() {
            return Ka.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const i = this.screenPointToLocation(this.centerPoint, e),
              l = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(l)
          }
          setLocationAtPoint(e, i) {
            const l = s.an(this.elevation, this.center.lat),
              u = this.screenPointToMercatorCoordinateAtZ(i, l),
              d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, l),
              g = s.a5.fromLngLat(e),
              T = new s.a5(g.x - (u.x - d.x), g.y - (u.y - d.y));
            this.setCenter(T == null ? void 0 : T.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, i) {
            return i ? this.coordinatePoint(s.a5.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a5.fromLngLat(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l != null) return l
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, i) {
            const l = i || 0,
              u = [e.x, e.y, 0, 1],
              d = [e.x, e.y, 1, 1];
            s.aA(u, u, this._pixelMatrixInverse), s.aA(d, d, this._pixelMatrixInverse);
            const g = u[3],
              T = d[3],
              S = u[1] / g,
              k = d[1] / T,
              z = u[2] / g,
              V = d[2] / T,
              F = z === V ? 0 : (l - z) / (V - z);
            return new s.a5(s.F.number(u[0] / g, d[0] / T, F) / this.worldSize, s.F.number(S, k, F) / this.worldSize, l)
          }
          coordinatePoint(e, i = 0, l = this._pixelMatrix) {
            const u = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
            return s.aA(u, u, l), new s.P(u[0] / u[3], u[1] / u[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Ze(this));
            return new It().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, i) {
            return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - Ze(this)
          }
          calculatePosMatrix(e, i = !1, l) {
            var u;
            const d = (u = e.key) !== null && u !== void 0 ? u : s.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              g = i ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (g.has(d)) {
              const k = g.get(d);
              return l ? k.f32 : k.f64
            }
            const T = Tt(e, this.worldSize);
            s.Q(T, i ? this._alignedProjMatrix : this._viewProjMatrix, T);
            const S = {
              f64: T,
              f32: new Float32Array(T)
            };
            return g.set(d, S), l ? S.f32 : S.f64
          }
          calculateFogMatrix(e) {
            const i = e.key,
              l = this._fogMatrixCacheF32;
            if (l.has(i)) return l.get(i);
            const u = Tt(e, this.worldSize);
            return s.Q(u, this._fogMatrix, u), l.set(i, new Float32Array(u)), l.get(i)
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          _calculateNearFarZIfNeeded(e, i, l) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const u = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              d = e - u * this._helper._pixelPerMeter / Math.cos(i),
              g = u < 0 ? d : e,
              T = Math.PI / 2 + this.pitchInRadians,
              S = s.ak(this.fov) * (Math.abs(Math.cos(s.ak(this.roll))) * this.height + Math.abs(Math.sin(s.ak(this.roll))) * this.width) / this.height * (.5 + l.y / this.height),
              k = Math.sin(S) * g / Math.sin(s.ai(Math.PI - T - S, .01, Math.PI - .01)),
              z = Ze(this),
              V = Math.atan(z / this._helper.cameraToCenterDistance),
              F = s.ak(.75),
              $ = V > F ? 2 * V * (.5 + l.y / (2 * z)) : F,
              J = Math.sin($) * g / Math.sin(s.ai(Math.PI - T - $, .01, Math.PI - .01)),
              ae = Math.min(k, J);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * ae + g), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              i = Se(this.worldSize, this.center),
              l = i.x,
              u = i.y;
            this._helper._pixelPerMeter = s.an(1, this.center.lat) * this.worldSize;
            const d = s.ak(Math.min(this.pitch, he)),
              g = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
            let T;
            this._calculateNearFarZIfNeeded(g, d, e), T = new Float64Array(16), s.b7(T, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.au(this._invProjMatrix, T), T[8] = 2 * -e.x / this._helper._width, T[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b8(T), s.O(T, T, [1, -1, 1]), s.N(T, T, [0, 0, -this._helper.cameraToCenterDistance]), s.b9(T, T, -this.rollInRadians), s.ba(T, T, this.pitchInRadians), s.b9(T, T, -this.bearingInRadians), s.N(T, T, [-l, -u, 0]), this._mercatorMatrix = s.O([], T, [this.worldSize, this.worldSize, this.worldSize]), s.O(T, T, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, T), s.N(T, T, [0, 0, -this.elevation]), this._viewProjMatrix = T, this._invViewProjMatrix = s.au([], T);
            const S = [0, 0, -1, 1];
            s.aA(S, S, this._invViewProjMatrix), this._cameraPosition = [S[0] / S[3], S[1] / S[3], S[2] / S[3]], this._fogMatrix = new Float64Array(16), s.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, g, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.N(this._fogMatrix, this._fogMatrix, [-l, -u, 0]), s.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, T);
            const k = this._helper._width % 2 / 2,
              z = this._helper._height % 2 / 2,
              V = Math.cos(this.bearingInRadians),
              F = Math.sin(-this.bearingInRadians),
              $ = l - Math.round(l) + V * k + F * z,
              J = u - Math.round(u) + V * z + F * k,
              ae = new Float64Array(T);
            if (s.N(ae, ae, [$ > .5 ? $ - 1 : $, J > .5 ? J - 1 : J, 0]), this._alignedProjMatrix = ae, T = s.au(new Float64Array(16), this._pixelMatrix), !T) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = T, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
              i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aA(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return _e(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, i) {
            const l = s.a5.fromLngLat(e),
              u = [l.x * this.worldSize, l.y * this.worldSize, i, 1];
            return s.aA(u, u, this._viewProjMatrix), u[2] / u[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              aligned: l,
              applyTerrainMatrix: u
            } = e, d = this._helper.getMercatorTileCoordinates(i), g = i ? this.calculatePosMatrix(i, l, !0) : null;
            let T;
            return T = i && i.terrainRttPosMatrix32f && u ? i.terrainRttPosMatrix32f : g || s.bb(), {
              mainMatrix: T,
              tileMercatorCoords: d,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: T
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, i, l) {
            return 1
          }
          transformLightDirection(e) {
            return s.aW(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, i, l, u) {
            const d = this.calculatePosMatrix(l);
            let g;
            u ? (g = [e, i, u(e, i), 1], s.aA(g, g, d)) : (g = [e, i, 0, 1], fi(g, g, d));
            const T = g[3];
            return {
              point: new s.P(g[0] / T, g[1] / T),
              signedDistanceFromCamera: T,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const i of e) this.calculatePosMatrix(i)
          }
          getMatrixForModel(e, i) {
            const l = s.a5.fromLngLat(e, i),
              u = l.meterInMercatorCoordinateUnits(),
              d = s.bc();
            return s.N(d, d, [l.x, l.y, l.z]), s.b9(d, d, Math.PI), s.ba(d, d, Math.PI / 2), s.O(d, d, [-u, u, u]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = new s.a0(0, 0, 0, 0, 0),
              l = this.getProjectionData({
                overscaledTileID: i,
                applyGlobeMatrix: e
              }),
              u = Tt(i, this.worldSize);
            s.Q(u, this._viewProjMatrix, u), l.tileMercatorCoords = [0, 0, 1, 1];
            const d = [s.a3, s.a3, this.worldSize / this._helper.pixelsPerMeter],
              g = s.bd();
            return s.O(g, u, d), l.fallbackMatrix = g, l.mainMatrix = g, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function Fn() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function va(h) {
          if (h.useSlerp)
            if (h.k < 1) {
              const e = s.be(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing),
                i = s.be(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing),
                l = new Float64Array(4);
              s.bf(l, e, i, h.k);
              const u = s.bg(l);
              h.tr.setRoll(u.roll), h.tr.setPitch(u.pitch), h.tr.setBearing(u.bearing)
            } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(s.F.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(s.F.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(s.F.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
        }

        function la(h, e, i, l, u) {
          const d = u.padding,
            g = Se(u.worldSize, i.getNorthWest()),
            T = Se(u.worldSize, i.getNorthEast()),
            S = Se(u.worldSize, i.getSouthEast()),
            k = Se(u.worldSize, i.getSouthWest()),
            z = s.ak(-l),
            V = g.rotate(z),
            F = T.rotate(z),
            $ = S.rotate(z),
            J = k.rotate(z),
            ae = new s.P(Math.max(V.x, F.x, J.x, $.x), Math.max(V.y, F.y, J.y, $.y)),
            oe = new s.P(Math.min(V.x, F.x, J.x, $.x), Math.min(V.y, F.y, J.y, $.y)),
            se = ae.sub(oe),
            fe = (u.width - (d.left + d.right + e.left + e.right)) / se.x,
            xe = (u.height - (d.top + d.bottom + e.top + e.bottom)) / se.y;
          if (xe < 0 || fe < 0) return void Fn();
          const pe = Math.min(s.ao(u.scale * Math.min(fe, xe)), h.maxZoom),
            be = s.P.convert(h.offset),
            Pe = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ak(l)),
            ge = be.add(Pe).mult(u.scale / s.al(pe));
          return {
            center: Ye(u.worldSize, g.add(S).div(2).sub(ge)),
            zoom: pe,
            bearing: l
          }
        }
        class ca {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, i) {
            const l = e.mag(),
              u = Math.abs(Ze(i));
            return {
              easingOffset: e.mult(Math.min(.75 * u / l, 1)),
              easingCenter: i.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta), e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, i, l) {
            e.around.distSqr(i.centerPoint) < .01 || i.setLocationAtPoint(l, e.around)
          }
          cameraForBoxAndBearing(e, i, l, u, d) {
            return la(e, i, l, u, d)
          }
          handleJumpToCenterZoom(e, i) {
            e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), i.center !== void 0 && e.setCenter(s.U.convert(i.center))
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.padding,
              d = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              g = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              T = i.zoom !== void 0,
              S = !e.isPaddingEqual(i.padding);
            let k = !1;
            const z = T ? +i.zoom : e.zoom;
            let V = e.centerPoint.add(i.offsetAsPoint);
            const F = e.screenPointToLocation(V),
              {
                center: $,
                zoom: J
              } = e.constrain(s.U.convert(i.center || F), z ?? l);
            Yr(e, $);
            const ae = Se(e.worldSize, F),
              oe = Se(e.worldSize, $).sub(ae),
              se = s.al(J - l);
            return k = J !== l, {
              easeFunc: fe => {
                if (k && e.setZoom(s.F.number(l, J, fe)), s.bh(d, g) || va({
                    startEulerAngles: d,
                    endEulerAngles: g,
                    tr: e,
                    k: fe,
                    useSlerp: d.roll != g.roll
                  }), S && (e.interpolatePadding(u, i.padding, fe), V = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const xe = s.al(e.zoom - l),
                    pe = J > l ? Math.min(2, se) : Math.max(.5, se),
                    be = Math.pow(pe, 1 - fe),
                    Pe = Ye(e.worldSize, ae.add(oe.mult(fe * be)).mult(xe));
                  e.setLocationAtPoint(e.renderWorldCopies ? Pe.wrap() : Pe, V)
                }
              },
              isZooming: k,
              elevationCenter: $
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.zoom,
              d = e.constrain(s.U.convert(i.center || i.locationAtOffset), l ? +i.zoom : u),
              g = d.center,
              T = d.zoom;
            Yr(e, g);
            const S = Se(e.worldSize, i.locationAtOffset),
              k = Se(e.worldSize, g).sub(S),
              z = k.mag(),
              V = s.al(T - u);
            let F;
            if (i.minZoom !== void 0) {
              const $ = Math.min(+i.minZoom, u, T),
                J = e.constrain(g, $).zoom;
              F = s.al(J - u)
            }
            return {
              easeFunc: ($, J, ae, oe) => {
                e.setZoom($ === 1 ? T : u + s.ao(J));
                const se = $ === 1 ? g : Ye(e.worldSize, S.add(k.mult(ae)).mult(J));
                e.setLocationAtPoint(e.renderWorldCopies ? se.wrap() : se, oe)
              },
              scaleOfZoom: V,
              targetCenter: g,
              scaleOfMinZoom: F,
              pixelPathLength: z
            }
          }
        }
        class mn {
          constructor(e, i, l) {
            this.blendFunction = e, this.blendColor = i, this.mask = l
          }
        }
        mn.Replace = [1, 0], mn.disabled = new mn(mn.Replace, s.bi.transparent, [!1, !1, !1, !1]), mn.unblended = new mn(mn.Replace, s.bi.transparent, [!0, !0, !0, !0]), mn.alphaBlended = new mn([1, 771], s.bi.transparent, [!0, !0, !0, !0]);
        const Na = 2305;
        class ln {
          constructor(e, i, l) {
            this.enable = e, this.mode = i, this.frontFace = l
          }
        }
        ln.disabled = new ln(!1, 1029, Na), ln.backCCW = new ln(!0, 1029, Na), ln.frontCCW = new ln(!0, 1028, Na);
        class tn {
          constructor(e, i, l) {
            this.func = e, this.mask = i, this.range = l
          }
        }
        tn.ReadOnly = !1, tn.ReadWrite = !0, tn.disabled = new tn(519, tn.ReadOnly, [0, 1]);
        const ds = 7680;
        class yn {
          constructor(e, i, l, u, d, g) {
            this.test = e, this.ref = i, this.mask = l, this.fail = u, this.depthFail = d, this.pass = g
          }
        }
        yn.disabled = new yn({
          func: 519,
          mask: 0
        }, 0, 0, ds, ds, ds);
        const Sa = new WeakMap;

        function ea(h) {
          var e;
          if (Sa.has(h)) return Sa.get(h);
          {
            const i = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Sa.set(h, i), i
          }
        }
        class ja {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const i = e.context,
              l = i.gl;
            this._texFormat = l.RGBA, this._texType = l.UNSIGNED_BYTE;
            const u = new s.aP;
            u.emplaceBack(-1, -1), u.emplaceBack(2, -1), u.emplaceBack(-1, 2);
            const d = new s.aR;
            d.emplaceBack(0, 1, 2), this._fullscreenTriangle = new ri(i.createVertexBuffer(u, jn.members), i.createIndexBuffer(d), s.aQ.simpleSegment(0, 0, u.length, d.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(l.TEXTURE1);
            const g = l.createTexture();
            l.bindTexture(l.TEXTURE_2D, g), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST), l.texImage2D(l.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(g), ea(l) && (this._pbo = l.createBuffer(), l.bindBuffer(l.PIXEL_PACK_BUFFER, this._pbo), l.bufferData(l.PIXEL_PACK_BUFFER, 4, l.STREAM_READ), l.bindBuffer(l.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, i) {
            const l = this._updateCount;
            return this._readbackQueue ? l >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : l >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              i = e.gl;
            e.activeTexture.set(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, i) {
            const l = this._cachedRenderContext.context,
              u = l.gl;
            if (this._bindFramebuffer(), l.viewport.set([0, 0, this._texWidth, this._texHeight]), l.clear({
                color: s.bi.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(l, u.TRIANGLES, tn.disabled, yn.disabled, mn.unblended, ln.disabled, ((d, g) => ({
                u_input: d,
                u_output_expected: g
              }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ea(u)) {
              u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.readBuffer(u.COLOR_ATTACHMENT0), u.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
              const d = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
              u.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: d
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && ea(e)) {
              const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (i === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = ja._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let i = 0;
            return i += e[0] / 256, i += e[1] / 65536, i += e[2] / 16777216, e[3] < 127 && (i = -i), i / 128
          }
        }
        const Va = s.a3 / 128;

        function Lo(h, e) {
          const i = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
            l = i + (h.generateBorders ? 2 : 0),
            u = i + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0),
            d = l + 1,
            g = u + 1,
            T = h.generateBorders ? -1 : 0,
            S = h.generateBorders || h.extendToNorthPole ? -1 : 0,
            k = i + (h.generateBorders ? 1 : 0),
            z = i + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
            V = d * g,
            F = l * u * 6,
            $ = d * g > 65536;
          if ($ && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const J = $ || e === "32bit",
            ae = new Int16Array(2 * V);
          let oe = 0;
          for (let xe = S; xe <= z; xe++)
            for (let pe = T; pe <= k; pe++) {
              let be = pe / i * s.a3;
              pe === -1 && (be = -Va), pe === i + 1 && (be = s.a3 + Va);
              let Pe = xe / i * s.a3;
              xe === -1 && (Pe = h.extendToNorthPole ? s.bk : -Va), xe === i + 1 && (Pe = h.extendToSouthPole ? s.bl : s.a3 + Va), ae[oe++] = be, ae[oe++] = Pe
            }
          const se = J ? new Uint32Array(F) : new Uint16Array(F);
          let fe = 0;
          for (let xe = 0; xe < u; xe++)
            for (let pe = 0; pe < l; pe++) {
              const be = pe + 1 + xe * d,
                Pe = pe + (xe + 1) * d,
                ge = pe + 1 + (xe + 1) * d;
              se[fe++] = pe + xe * d, se[fe++] = Pe, se[fe++] = be, se[fe++] = be, se[fe++] = Pe, se[fe++] = ge
            }
          return {
            vertices: ae.buffer.slice(0),
            indices: se.buffer.slice(0),
            uses32bitIndices: J
          }
        }
        const Os = new s.aO({
          fill: new s.bm(128, 2),
          line: new s.bm(512, 0),
          tile: new s.bm(128, 32),
          stencil: new s.bm(128, 1),
          circle: 3
        });
        class Tl {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return pr.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return pr.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return Os
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new ja(e));
            const i = s.W(this._errorQueryLatitudeDegrees),
              l = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - .5 * Math.PI,
              u = this._errorMeasurement.updateErrorLoop(i, l),
              d = ne();
            u !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = u, this._errorMeasurementLastChangeTime = d);
            const g = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = s.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bo(g))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, i, l, u, d) {
            const g = (d === "stencil" ? Os.stencil : Os.tile).getGranularityForZoomLevel(i.z);
            return this._getMesh(e, {
              granularity: g,
              generateBorders: l,
              extendToNorthPole: i.y === 0 && u,
              extendToSouthPole: i.y === (1 << i.z) - 1 && u
            })
          }
          _getMesh(e, i) {
            const l = this._getMeshKey(i);
            if (l in this._tileMeshCache) return this._tileMeshCache[l];
            const u = (function(d, g) {
              const T = Lo(g, "16bit"),
                S = s.aP.deserialize({
                  arrayBuffer: T.vertices,
                  length: T.vertices.byteLength / 2 / 2
                }),
                k = s.aR.deserialize({
                  arrayBuffer: T.indices,
                  length: T.indices.byteLength / 2 / 3
                });
              return new ri(d.createVertexBuffer(S, jn.members), d.createIndexBuffer(k), s.aQ.simpleSegment(0, 0, S.length, k.length))
            })(e, i);
            return this._tileMeshCache[l] = u, u
          }
          recalculate(e) {}
          hasTransition() {
            const e = ne();
            let i = !1;
            return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery, i
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const Sl = new s.r({
          type: new s.D(s.t.projection.type)
        });
        class Ns extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(Sl, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0)), this._mercatorProjection = new Rr, this._verticalPerspectiveProjection = new Tl
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, i, l, u, d) {
            return this.currentProjection.getMeshFromTileID(e, i, l, u, d)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function ps(h) {
          const e = js(h.worldSize, h.center.lat);
          return 2 * Math.PI * e
        }

        function vo(h, e, i, l, u) {
          const d = 1 / (1 << u),
            g = e / s.a3 * d + l * d,
            T = s.br((h / s.a3 * d + i * d) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            S = 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI,
            k = Math.cos(S),
            z = new Float64Array(3);
          return z[0] = Math.sin(T) * k, z[1] = Math.sin(S), z[2] = Math.cos(T) * k, z
        }

        function Ii(h) {
          return (function(e, i) {
            const l = Math.cos(i),
              u = new Float64Array(3);
            return u[0] = Math.sin(e) * l, u[1] = Math.sin(i), u[2] = Math.cos(e) * l, u
          })(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
        }

        function js(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function Qh(h) {
          const e = Math.asin(h[1]) / Math.PI * 180,
            i = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (i > 1e-6) {
            const l = h[0] / i,
              u = Math.acos(h[2] / i),
              d = (l > 0 ? u : -u) / Math.PI * 180;
            return new s.U(s.V(d, -180, 180), e)
          }
          return new s.U(0, e)
        }

        function Cl(h) {
          return Math.cos(h * Math.PI / 180)
        }

        function kn(h, e) {
          const i = Cl(h),
            l = Cl(e);
          return s.ao(l / i)
        }

        function Pl(h, e) {
          const i = h.rotate(e.bearingInRadians),
            l = e.zoom + kn(e.center.lat, 0),
            u = s.bn(1 / Cl(e.center.lat), 1 / Cl(Math.min(Math.abs(e.center.lat), 60)), s.bq(l, 7, 3, 0, 1)),
            d = 360 / ps({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new s.U(e.center.lng - i.x * d * u, s.ai(e.center.lat + i.y * d, -s.aj, s.aj))
        }

        function ya(h) {
          const e = .5 * h,
            i = Math.sin(e),
            l = Math.cos(e);
          return Math.log(i + l) - Math.log(l - i)
        }

        function Vs(h, e, i, l) {
          const u = h.lat + i * l;
          if (Math.abs(i) > 1) {
            const d = (Math.sign(h.lat + i) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180,
              g = Math.abs(h.lat + i) * Math.PI / 180,
              T = ya(d + l * (g - d)),
              S = ya(d),
              k = ya(g);
            return new s.U(h.lng + e * ((T - S) / (k - S)), u)
          }
          return new s.U(h.lng + e * l, u)
        }
        class ed {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, i, l, u) {
            const d = `${e.z}_${e.x}_${e.y}_${u!=null&&u.terrain?"t":""}`,
              g = this._cache.get(d);
            if (g) return g;
            const T = this._cachePrevious.get(d);
            if (T) return this._cache.set(d, T), T;
            const S = this._boundingVolumeFactory(e, i, l, u);
            return this._cache.set(d, S), this._hadAnyChanges = !0, S
          }
        }
        class Do {
          constructor(e, i, l, u) {
            this.min = l, this.max = u, this.points = e, this.planes = i
          }
          static fromAabb(e, i) {
            const l = [];
            for (let u = 0; u < 8; u++) l.push([1 & ~u ? e[0] : i[0], (u >> 1 & 1) == 1 ? i[1] : e[1], (u >> 2 & 1) == 1 ? i[2] : e[2]]);
            return new Do(l, [
              [-1, 0, 0, i[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, i[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, i[2]],
              [0, 0, 1, -e[2]]
            ], e, i)
          }
          static fromCenterSizeAngles(e, i, l) {
            const u = s.bu([], l[0], l[1], l[2]),
              d = s.bv([], [i[0], 0, 0], u),
              g = s.bv([], [0, i[1], 0], u),
              T = s.bv([], [0, 0, i[2]], u),
              S = [...e],
              k = [...e];
            for (let V = 0; V < 8; V++)
              for (let F = 0; F < 3; F++) {
                const $ = e[F] + d[F] * (1 & ~V ? -1 : 1) + g[F] * ((V >> 1 & 1) == 1 ? 1 : -1) + T[F] * ((V >> 2 & 1) == 1 ? 1 : -1);
                S[F] = Math.min(S[F], $), k[F] = Math.max(k[F], $)
              }
            const z = [];
            for (let V = 0; V < 8; V++) {
              const F = [...e];
              s.aV(F, F, s.aU([], d, 1 & ~V ? -1 : 1)), s.aV(F, F, s.aU([], g, (V >> 1 & 1) == 1 ? 1 : -1)), s.aV(F, F, s.aU([], T, (V >> 2 & 1) == 1 ? 1 : -1)), z.push(F)
            }
            return new Do(z, [
              [...d, -s.a_(d, z[0])],
              [...g, -s.a_(g, z[0])],
              [...T, -s.a_(T, z[0])],
              [-d[0], -d[1], -d[2], -s.a_(d, z[7])],
              [-g[0], -g[1], -g[2], -s.a_(g, z[7])],
              [-T[0], -T[1], -T[2], -s.a_(T, z[7])]
            ], S, k)
          }
          intersectsFrustum(e) {
            let i = !0;
            const l = this.points.length,
              u = this.planes.length,
              d = e.planes.length,
              g = e.points.length;
            for (let T = 0; T < d; T++) {
              const S = e.planes[T];
              let k = 0;
              for (let z = 0; z < l; z++) {
                const V = this.points[z];
                S[0] * V[0] + S[1] * V[1] + S[2] * V[2] + S[3] >= 0 && k++
              }
              if (k === 0) return 0;
              k < l && (i = !1)
            }
            if (i) return 2;
            for (let T = 0; T < u; T++) {
              const S = this.planes[T];
              let k = 0;
              for (let z = 0; z < g; z++) {
                const V = e.points[z];
                S[0] * V[0] + S[1] * V[1] + S[2] * V[2] + S[3] >= 0 && k++
              }
              if (k === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const i = this.points.length;
            let l = 0;
            for (let u = 0; u < i; u++) {
              const d = this.points[u];
              e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && l++
            }
            return l === i ? 2 : l === 0 ? 0 : 1
          }
        }

        function Ja(h, e, i) {
          const l = h - e;
          return l < 0 ? -l : Math.max(0, l - i)
        }

        function jc(h, e, i, l, u) {
          const d = h - i;
          let g;
          return g = d < 0 ? Math.min(-d, 1 + d - u) : d > 1 ? Math.min(Math.max(d - u, 0), 1 - d) : 0, Math.max(g, Ja(e, l, u))
        }
        class rf {
          constructor() {
            this._boundingVolumeCache = new ed(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, i, l, u) {
            const d = 1 << l.z,
              g = 1 / d,
              T = l.x / d,
              S = l.y / d;
            let k = 2;
            return k = Math.min(k, jc(e, i, T, S, g)), k = Math.min(k, jc(e, i, T + .5, -S - g, g)), k = Math.min(k, jc(e, i, T + .5, 2 - S - g, g)), k
          }
          getWrap(e, i, l) {
            const u = 1 << i.z,
              d = 1 / u,
              g = i.x / u,
              T = Ja(e.x, g, d),
              S = Ja(e.x, g - 1, d),
              k = Ja(e.x, g + 1, d),
              z = Math.min(T, S, k);
            return z === k ? 1 : z === S ? -1 : 0
          }
          allowVariableZoom(e, i) {
            return Vr(e, i) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, i, l, u) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, i, l, u)
          }
          _computeTileBoundingVolume(e, i, l, u) {
            var d, g;
            let T = 0,
              S = 0;
            if (u != null && u.terrain) {
              const k = new s.a0(e.z, i, e.z, e.x, e.y),
                z = u.terrain.getMinMaxElevation(k);
              T = (d = z.minElevation) !== null && d !== void 0 ? d : Math.min(0, l), S = (g = z.maxElevation) !== null && g !== void 0 ? g : Math.max(0, l)
            }
            if (T /= s.bx, S /= s.bx, T += 1, S += 1, e.z <= 0) return Do.fromAabb([-S, -S, -S], [S, S, S]);
            if (e.z === 1) return Do.fromAabb([e.x === 0 ? -S : 0, e.y === 0 ? 0 : -S, -S], [e.x === 0 ? 0 : S, e.y === 0 ? S : 0, S]);
            {
              const k = [vo(0, 0, e.x, e.y, e.z), vo(s.a3, 0, e.x, e.y, e.z), vo(s.a3, s.a3, e.x, e.y, e.z), vo(0, s.a3, e.x, e.y, e.z)],
                z = [];
              for (const rt of k) z.push(s.aU([], rt, S));
              if (S !== T)
                for (const rt of k) z.push(s.aU([], rt, T));
              e.y === 0 && z.push([0, 1, 0]), e.y === (1 << e.z) - 1 && z.push([0, -1, 0]);
              const V = [1, 1, 1],
                F = [-1, -1, -1];
              for (const rt of z)
                for (let at = 0; at < 3; at++) V[at] = Math.min(V[at], rt[at]), F[at] = Math.max(F[at], rt[at]);
              const $ = vo(s.a3 / 2, s.a3 / 2, e.x, e.y, e.z),
                J = s.aZ([], [0, 1, 0], $);
              s.aY(J, J);
              const ae = s.aZ([], $, J);
              s.aY(ae, ae);
              const oe = s.aZ([], k[2], k[1]);
              s.aY(oe, oe);
              const se = s.aZ([], k[0], k[3]);
              s.aY(se, se), z.push(s.aU([], $, S)), e.y >= (1 << e.z) / 2 && z.push(s.aU([], vo(s.a3 / 2, 0, e.x, e.y, e.z), S)), e.y < (1 << e.z) / 2 && z.push(s.aU([], vo(s.a3 / 2, s.a3, e.x, e.y, e.z), S));
              const fe = td($, z),
                xe = td(ae, z),
                pe = [-$[0], -$[1], -$[2], fe.max],
                be = [$[0], $[1], $[2], -fe.min],
                Pe = [-ae[0], -ae[1], -ae[2], xe.max],
                ge = [ae[0], ae[1], ae[2], -xe.min],
                Fe = [...oe, 0],
                nt = [...se, 0],
                et = [];
              return e.y === 0 ? et.push(s.bw(nt, Fe, pe), s.bw(nt, Fe, be)) : et.push(s.bw(Pe, Fe, pe), s.bw(Pe, Fe, be), s.bw(Pe, nt, pe), s.bw(Pe, nt, be)), e.y === (1 << e.z) - 1 ? et.push(s.bw(nt, Fe, pe), s.bw(nt, Fe, be)) : et.push(s.bw(ge, Fe, pe), s.bw(ge, Fe, be), s.bw(ge, nt, pe), s.bw(ge, nt, be)), new Do(et, [pe, be, Pe, ge, Fe, nt], V, F)
            }
          }
        }

        function td(h, e) {
          let i = 1 / 0,
            l = -1 / 0;
          for (const u of e) {
            const d = s.a_(h, u);
            i = Math.min(i, d), l = Math.max(l, d)
          }
          return {
            min: i,
            max: l
          }
        }
        class Il {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i) {
            this._helper.resize(e, i)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor(e) {
            this._cachedClippingPlane = s.by(), this._projectionMatrix = s.bc(), this._globeViewProjMatrix32f = s.bb(), this._globeViewProjMatrixNoCorrection = s.bc(), this._globeViewProjMatrixNoCorrectionInverted = s.bc(), this._globeProjMatrixInverted = s.bc(), this._cameraPosition = s.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (i, l) => {
              const u = s.ai(i.lat, -s.aj, s.aj),
                d = s.ai(+l, this.minZoom + kn(0, u), this.maxZoom);
              return {
                center: new s.U(i.lng, u),
                zoom: d
              }
            }, this._helper = new In({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (i, l) => this.defaultConstrain(i, l)
            }, e), this._coveringTilesDetailsProvider = new rf
          }
          clone() {
            const e = new Il;
            return e.apply(this), e
          }
          apply(e, i) {
            this._globeLatitudeErrorCorrectionRadians = i || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = s.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: i,
              applyGlobeMatrix: l
            } = e, u = this._helper.getMercatorTileCoordinates(i);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: u,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: l ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const i = this.pitchInRadians,
              l = this.cameraToCenterDistance / e,
              u = Math.sin(i) * l,
              d = Math.cos(i) * l + 1,
              g = 1 / Math.sqrt(u * u + d * d) * 1;
            let T = -u,
              S = d;
            const k = Math.sqrt(T * T + S * S);
            T /= k, S /= k;
            const z = [0, T, S];
            s.bz(z, z, [0, 0, 0], -this.bearingInRadians), s.bA(z, z, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.bB(z, z, [0, 0, 0], this.center.lng * Math.PI / 180);
            const V = 1 / s.b0(z);
            return s.aU(z, z, V), [...z, -g * V]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Ii(e))
          }
          transformLightDirection(e) {
            const i = this._helper._center.lng * Math.PI / 180,
              l = this._helper._center.lat * Math.PI / 180,
              u = Math.cos(l),
              d = [Math.sin(i) * u, Math.sin(l), Math.cos(i) * u],
              g = [d[2], 0, -d[0]],
              T = [0, 0, 0];
            s.aZ(T, g, d), s.aY(g, g), s.aY(T, T);
            const S = [0, 0, 0];
            return s.aY(S, [g[0] * e[0] + T[0] * e[1] + d[0] * e[2], g[1] * e[0] + T[1] * e[1] + d[1] * e[2], g[2] * e[0] + T[2] * e[1] + d[2] * e[2]]), S
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = (function(T, S, k) {
                const z = 1 / (1 << k.z);
                return new s.a5(T / s.a3 * z + k.x * z, S / s.a3 * z + k.y * z)
              })(e, i, l.canonical),
              d = (g = u.y, [s.br(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI]);
            var g;
            return this.getCircleRadiusCorrection() / Math.cos(d[1])
          }
          projectTileCoordinates(e, i, l, u) {
            const d = l.canonical,
              g = vo(e, i, d.x, d.y, d.z),
              T = 1 + (u ? u(e, i) : 0) / s.bx,
              S = [g[0] * T, g[1] * T, g[2] * T, 1];
            s.aA(S, S, this._globeViewProjMatrixNoCorrection);
            const k = this._cachedClippingPlane,
              z = k[0] * g[0] + k[1] * g[1] + k[2] * g[2] + k[3] < 0;
            return {
              point: new s.P(S[0] / S[3], S[1] / S[3]),
              signedDistanceFromCamera: S[3],
              isOccluded: z
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = js(this.worldSize, this.center.lat),
              i = s.bd(),
              l = s.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b7(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const u = this.centerOffset;
            i[8] = 2 * -u.x / this._helper._width, i[9] = 2 * u.y / this._helper._height, this._projectionMatrix = s.b8(i), this._globeProjMatrixInverted = s.bd(), s.au(this._globeProjMatrixInverted, i), s.N(i, i, [0, 0, -this.cameraToCenterDistance]), s.b9(i, i, this.rollInRadians), s.ba(i, i, -this.pitchInRadians), s.b9(i, i, this.bearingInRadians), s.N(i, i, [0, 0, -e]);
            const d = s.bs();
            d[0] = e, d[1] = e, d[2] = e, s.ba(l, i, this.center.lat * Math.PI / 180), s.bC(l, l, -this.center.lng * Math.PI / 180), s.O(l, l, d), this._globeViewProjMatrixNoCorrection = l, s.ba(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bC(i, i, -this.center.lng * Math.PI / 180), s.O(i, i, d), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = s.bd(), s.au(this._globeViewProjMatrixNoCorrectionInverted, l);
            const g = s.bs();
            this._cameraPosition = s.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bz(this._cameraPosition, this._cameraPosition, g, -this.rollInRadians), s.bA(this._cameraPosition, this._cameraPosition, g, this.pitchInRadians), s.bz(this._cameraPosition, this._cameraPosition, g, -this.bearingInRadians), s.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bA(this._cameraPosition, this._cameraPosition, g, -this.center.lat * Math.PI / 180), s.bB(this._cameraPosition, this._cameraPosition, g, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const T = s.b8(this._globeViewProjMatrixNoCorrectionInverted);
            s.O(T, T, [1, 1, -1]), this._cachedFrustum = Ka.fromInvProjectionMatrix(T, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const i = s.bd();
            return s.am(i), i
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b5(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const l = Ii(e);
            s.aU(l, l, 1 + i / s.bx);
            const u = s.by();
            return s.aA(u, [l[0], l[1], l[2], 1], this._globeViewProjMatrixNoCorrection), u[2] / u[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              i = .5 * this.height,
              l = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, i), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, i)],
              u = [];
            for (const V of l) u.push(this.unprojectScreenPoint(V));
            let d = 0,
              g = 0,
              T = 0,
              S = 0;
            const k = this.center;
            for (const V of u) {
              const F = s.bD(k.lng, V.lng),
                $ = s.bD(k.lat, V.lat);
              F < g && (g = F), F > d && (d = F), $ < S && (S = $), $ > T && (T = $)
            }
            const z = [k.lng + g, k.lat + S, k.lng + d, k.lat + T];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (z[3] = 90, z[0] = -180, z[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (z[1] = -90, z[0] = -180, z[2] = 180), new It(z)
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            const l = Ii(this.unprojectScreenPoint(i)),
              u = Ii(e),
              d = s.bs();
            s.bE(d);
            const g = s.bs();
            s.bB(g, l, d, -this.center.lng * Math.PI / 180), s.bA(g, g, d, this.center.lat * Math.PI / 180);
            const T = u[0] * u[0] + u[2] * u[2],
              S = g[0] * g[0];
            if (T < S) return;
            const k = Math.sqrt(T - S),
              z = -k,
              V = s.bF(u[0], u[2], g[0], k),
              F = s.bF(u[0], u[2], g[0], z),
              $ = s.bs();
            s.bB($, u, d, -V);
            const J = s.bF($[1], $[2], g[1], g[2]),
              ae = s.bs();
            s.bB(ae, u, d, -F);
            const oe = s.bF(ae[1], ae[2], g[1], g[2]),
              se = .5 * Math.PI,
              fe = J >= -se && J <= se,
              xe = oe >= -se && oe <= se;
            let pe, be;
            if (fe && xe) {
              const nt = this.center.lng * Math.PI / 180,
                et = this.center.lat * Math.PI / 180;
              s.bG(V, nt) + s.bG(J, et) < s.bG(F, nt) + s.bG(oe, et) ? (pe = V, be = J) : (pe = F, be = oe)
            } else if (fe) pe = V, be = J;
            else {
              if (!xe) return;
              pe = F, be = oe
            }
            const Pe = pe / Math.PI * 180,
              ge = be / Math.PI * 180,
              Fe = this.center.lat;
            this.setCenter(new s.U(Pe, s.ai(ge, -90, 90))), this.setZoom(this.zoom + kn(Fe, this.center.lat))
          }
          locationToScreenPoint(e, i) {
            const l = Ii(e);
            if (i) {
              const u = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aU(l, l, 1 + u / s.bx)
            }
            return this._projectSurfacePointToScreen(l)
          }
          _projectSurfacePointToScreen(e) {
            const i = s.by();
            return s.aA(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new s.P((.5 * i[0] + .5) * this.width, (.5 * -i[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const l = i.pointCoordinate(e);
              if (l) return l
            }
            return s.a5.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, i) {
            var l;
            return (l = this.screenPointToMercatorCoordinate(e, i)) === null || l === void 0 ? void 0 : l.toLngLat()
          }
          isPointOnMapSurface(e, i) {
            const l = this._cameraPosition,
              u = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(l, u)
          }
          getRayDirectionFromPixel(e) {
            const i = s.by();
            i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, s.aA(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3];
            const l = s.bs();
            l[0] = i[0] - this._cameraPosition[0], l[1] = i[1] - this._cameraPosition[1], l[2] = i[2] - this._cameraPosition[2];
            const u = s.bs();
            return s.aY(u, l), u
          }
          isSurfacePointVisible(e) {
            const i = this._cachedClippingPlane;
            return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const i = s.by();
            return s.aA(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1
          }
          rayPlanetIntersection(e, i) {
            const l = s.a_(e, i),
              u = s.bs(),
              d = s.bs();
            s.aU(d, i, l), s.aX(u, e, d);
            const g = 1 - s.a_(u, u);
            if (g < 0) return null;
            const T = s.a_(e, e) - 1,
              S = -l + (l < 0 ? 1 : -1) * Math.sqrt(g),
              k = T / S,
              z = S;
            return {
              tMin: Math.min(k, z),
              tMax: Math.max(k, z)
            }
          }
          unprojectScreenPoint(e) {
            const i = this._cameraPosition,
              l = this.getRayDirectionFromPixel(e),
              u = this.rayPlanetIntersection(i, l);
            if (u) {
              const z = s.bs();
              s.aV(z, i, [l[0] * u.tMin, l[1] * u.tMin, l[2] * u.tMin]);
              const V = s.bs();
              return s.aY(V, z), Qh(V)
            }
            const d = this._cachedClippingPlane,
              g = d[0] * l[0] + d[1] * l[1] + d[2] * l[2],
              T = -s.b4(d, i) / g,
              S = s.bs();
            if (T > 0) s.aV(S, i, [l[0] * T, l[1] * T, l[2] * T]);
            else {
              const z = s.bs();
              s.aV(z, i, [2 * l[0], 2 * l[1], 2 * l[2]]);
              const V = s.b4(this._cachedClippingPlane, z);
              s.aX(S, z, [this._cachedClippingPlane[0] * V, this._cachedClippingPlane[1] * V, this._cachedClippingPlane[2] * V])
            }
            const k = (function(z) {
              const V = s.bs();
              return V[0] = z[0] * -z[3], V[1] = z[1] * -z[3], V[2] = z[2] * -z[3], {
                center: V,
                radius: Math.sqrt(1 - z[3] * z[3])
              }
            })(d);
            return Qh((function(z, V, F) {
              const $ = s.bs();
              s.aX($, F, z);
              const J = s.bs();
              return s.bt(J, z, $, V / s.b2($)), J
            })(k.center, k.radius, S))
          }
          getMatrixForModel(e, i) {
            const l = s.U.convert(e),
              u = 1 / s.bx,
              d = s.bc();
            return s.bC(d, d, l.lng / 180 * Math.PI), s.ba(d, d, -l.lat / 180 * Math.PI), s.N(d, d, [0, 0, 1 + i / s.bx]), s.ba(d, d, .5 * Math.PI), s.O(d, d, [u, u, u]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this.getProjectionData({
              overscaledTileID: new s.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return i.tileMercatorCoords = [0, 0, 1, 1], i
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class Ml {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, i, l) {
            return this._helper.interpolatePadding(e, i, l)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, i, l = !0) {
            this._helper.resize(e, i, l)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, i) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = i, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (i, l) => this.currentTransform.defaultConstrain(i, l), this._helper = new In({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (i, l) => this.defaultConstrain(i, l)
            }, e), this._globeness = 1, this._mercatorTransform = new Pi, this._verticalPerspectiveTransform = new Il
          }
          clone() {
            const e = new Ml;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const i = this._mercatorTransform.getProjectionData(e),
              l = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? l.mainMatrix : i.mainMatrix,
              clippingPlane: l.clippingPlane,
              tileMercatorCoords: l.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: i.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return s.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return s.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, i, l) {
            const u = this._mercatorTransform.getPitchedTextCorrection(e, i, l),
              d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, l);
            return s.bn(u, d, this._globeness)
          }
          projectTileCoordinates(e, i, l, u) {
            return this.currentTransform.projectTileCoordinates(e, i, l, u)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, i) {
            return this.currentTransform.lngLatToCameraDepth(e, i)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          calculateCenterFromCameraLngLatAlt(e, i, l, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, l, u)
          }
          setLocationAtPoint(e, i) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, i), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, i), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, i) {
            return this.currentTransform.locationToScreenPoint(e, i)
          }
          screenPointToMercatorCoordinate(e, i) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, i)
          }
          screenPointToLocation(e, i) {
            return this.currentTransform.screenPointToLocation(e, i)
          }
          isPointOnMapSurface(e, i) {
            return this.currentTransform.isPointOnMapSurface(e, i)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, i) {
            return this.currentTransform.getMatrixForModel(e, i)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return i;
            const l = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return l.fallbackMatrix = i.mainMatrix, l
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Ca {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, i) {
            const l = Pl(e, i);
            return Math.abs(l.lng - i.center.lng) > 180 && (l.lng = i.center.lng + 179.5 * Math.sign(l.lng - i.center.lng)), {
              easingCenter: l,
              easingOffset: new s.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            const l = e.around,
              u = i.screenPointToLocation(l);
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta);
            const d = i.zoom;
            e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
            const g = i.zoom - d;
            if (g === 0) return;
            const T = s.bD(i.center.lng, u.lng),
              S = T / (Math.abs(T / 180) + 1),
              k = s.bD(i.center.lat, u.lat),
              z = i.getRayDirectionFromPixel(l),
              V = i.cameraPosition,
              F = -1 * s.a_(V, z),
              $ = s.bs();
            s.aV($, V, [z[0] * F, z[1] * F, z[2] * F]);
            const J = s.b0($) - 1,
              ae = Math.exp(.5 * -Math.max(J - .3, 0)),
              oe = js(i.worldSize, i.center.lat) / Math.min(i.width, i.height),
              se = s.bq(oe, .9, .5, 1, .25),
              fe = (1 - s.al(-g)) * Math.min(ae, se),
              xe = i.center.lat,
              pe = i.zoom,
              be = new s.U(i.center.lng + S * fe, s.ai(i.center.lat + k * fe, -s.aj, s.aj));
            i.setLocationAtPoint(u, l);
            const Pe = i.center,
              ge = s.bq(Math.abs(T), 45, 85, 0, 1),
              Fe = s.bq(oe, .75, .35, 0, 1),
              nt = Math.pow(Math.max(ge, Fe), .25),
              et = s.bD(Pe.lng, be.lng),
              rt = s.bD(Pe.lat, be.lat);
            i.setCenter(new s.U(Pe.lng + et * nt, Pe.lat + rt * nt).wrap()), i.setZoom(pe + kn(xe, i.center.lat))
          }
          handleMapControlsPan(e, i, l) {
            if (!e.panDelta) return;
            const u = i.center.lat,
              d = i.zoom;
            i.setCenter(Pl(e.panDelta, i).wrap()), i.setZoom(d + kn(u, i.center.lat))
          }
          cameraForBoxAndBearing(e, i, l, u, d) {
            const g = la(e, i, l, u, d),
              T = i.left / d.width * 2 - 1,
              S = (d.width - i.right) / d.width * 2 - 1,
              k = i.top / d.height * -2 + 1,
              z = (d.height - i.bottom) / d.height * -2 + 1,
              V = s.bD(l.getWest(), l.getEast()) < 0,
              F = V ? l.getEast() : l.getWest(),
              $ = V ? l.getWest() : l.getEast(),
              J = Math.max(l.getNorth(), l.getSouth()),
              ae = Math.min(l.getNorth(), l.getSouth()),
              oe = F + .5 * s.bD(F, $),
              se = J + .5 * s.bD(J, ae),
              fe = d.clone();
            fe.setCenter(g.center), fe.setBearing(g.bearing), fe.setPitch(0), fe.setRoll(0), fe.setZoom(g.zoom);
            const xe = fe.modelViewProjectionMatrix,
              pe = [Ii(l.getNorthWest()), Ii(l.getNorthEast()), Ii(l.getSouthWest()), Ii(l.getSouthEast()), Ii(new s.U($, se)), Ii(new s.U(F, se)), Ii(new s.U(oe, J)), Ii(new s.U(oe, ae))],
              be = Ii(g.center);
            let Pe = Number.POSITIVE_INFINITY;
            for (const ge of pe) T < 0 && (Pe = Ca.getLesserNonNegativeNonNull(Pe, Ca.solveVectorScale(ge, be, xe, "x", T))), S > 0 && (Pe = Ca.getLesserNonNegativeNonNull(Pe, Ca.solveVectorScale(ge, be, xe, "x", S))), k > 0 && (Pe = Ca.getLesserNonNegativeNonNull(Pe, Ca.solveVectorScale(ge, be, xe, "y", k))), z < 0 && (Pe = Ca.getLesserNonNegativeNonNull(Pe, Ca.solveVectorScale(ge, be, xe, "y", z)));
            if (Number.isFinite(Pe) && Pe !== 0) return g.zoom = fe.zoom + s.ao(Pe), g;
            Fn()
          }
          handleJumpToCenterZoom(e, i) {
            const l = e.center.lat,
              u = e.constrain(i.center ? s.U.convert(i.center) : e.center, e.zoom).center;
            e.setCenter(u.wrap());
            const d = i.zoom !== void 0 ? +i.zoom : e.zoom + kn(l, u.lat);
            e.zoom !== d && e.setZoom(d)
          }
          handleEaseTo(e, i) {
            const l = e.zoom,
              u = e.center,
              d = e.padding,
              g = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              T = {
                roll: i.roll === void 0 ? e.roll : i.roll,
                pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                bearing: i.bearing === void 0 ? e.bearing : i.bearing
              },
              S = i.zoom !== void 0,
              k = !e.isPaddingEqual(i.padding);
            let z = !1;
            const V = i.center ? s.U.convert(i.center) : u,
              F = e.constrain(V, l).center;
            Yr(e, F);
            const $ = e.clone();
            $.setCenter(F), $.setZoom(S ? +i.zoom : l + kn(u.lat, V.lat)), $.setBearing(i.bearing);
            const J = new s.P(s.ai(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            $.setLocationAtPoint(F, J);
            const ae = (i.offset && i.offsetAsPoint.mag()) > 0 ? $.center : F,
              oe = S ? +i.zoom : l + kn(u.lat, ae.lat),
              se = l + kn(u.lat, 0),
              fe = oe + kn(ae.lat, 0),
              xe = s.bD(u.lng, ae.lng),
              pe = s.bD(u.lat, ae.lat),
              be = s.al(fe - se);
            return z = oe !== l, {
              easeFunc: Pe => {
                if (s.bh(g, T) || va({
                    startEulerAngles: g,
                    endEulerAngles: T,
                    tr: e,
                    k: Pe,
                    useSlerp: g.roll != T.roll
                  }), k && e.interpolatePadding(d, i.padding, Pe), i.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const ge = fe > se ? Math.min(2, be) : Math.max(.5, be),
                    Fe = Math.pow(ge, 1 - Pe),
                    nt = Vs(u, xe, pe, Pe * Fe);
                  e.setCenter(nt.wrap())
                }
                if (z) {
                  const ge = s.F.number(se, fe, Pe) + kn(0, e.center.lat);
                  e.setZoom(ge)
                }
              },
              isZooming: z,
              elevationCenter: ae
            }
          }
          handleFlyTo(e, i) {
            const l = i.zoom !== void 0,
              u = e.center,
              d = e.zoom,
              g = e.padding,
              T = !e.isPaddingEqual(i.padding),
              S = e.constrain(s.U.convert(i.center || i.locationAtOffset), d).center,
              k = l ? +i.zoom : e.zoom + kn(e.center.lat, S.lat),
              z = e.clone();
            z.setCenter(S), z.setZoom(k), z.setBearing(i.bearing);
            const V = new s.P(s.ai(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            z.setLocationAtPoint(S, V);
            const F = z.center;
            Yr(e, F);
            const $ = (function(pe, be, Pe) {
                const ge = Ii(be),
                  Fe = Ii(Pe),
                  nt = s.a_(ge, Fe),
                  et = Math.acos(nt),
                  rt = ps(pe);
                return et / (2 * Math.PI) * rt
              })(e, u, F),
              J = d + kn(u.lat, 0),
              ae = k + kn(F.lat, 0),
              oe = s.al(ae - J);
            let se;
            if (typeof i.minZoom == "number") {
              const pe = +i.minZoom + kn(F.lat, 0),
                be = Math.min(pe, J, ae) + kn(0, F.lat),
                Pe = e.constrain(F, be).zoom + kn(F.lat, 0);
              se = s.al(Pe - J)
            }
            const fe = s.bD(u.lng, F.lng),
              xe = s.bD(u.lat, F.lat);
            return {
              easeFunc: (pe, be, Pe, ge) => {
                const Fe = Vs(u, fe, xe, Pe);
                T && e.interpolatePadding(g, i.padding, pe);
                const nt = pe === 1 ? F : Fe;
                e.setCenter(nt.wrap());
                const et = J + s.ao(be);
                e.setZoom(pe === 1 ? k : et + kn(0, nt.lat))
              },
              scaleOfZoom: oe,
              targetCenter: F,
              scaleOfMinZoom: se,
              pixelPathLength: $
            }
          }
          static solveVectorScale(e, i, l, u, d) {
            const g = u === "x" ? [l[0], l[4], l[8], l[12]] : [l[1], l[5], l[9], l[13]],
              T = [l[3], l[7], l[11], l[15]],
              S = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
              k = e[0] * T[0] + e[1] * T[1] + e[2] * T[2],
              z = i[0] * g[0] + i[1] * g[1] + i[2] * g[2],
              V = i[0] * T[0] + i[1] * T[1] + i[2] * T[2];
            return z + d * k === S + d * V || T[3] * (S - z) + g[3] * (V - k) + S * V == z * k ? null : (z + g[3] - d * V - d * T[3]) / (z - S - d * V + d * k)
          }
          static getLesserNonNegativeNonNull(e, i) {
            return i !== null && i >= 0 && i < e ? i : e
          }
        }
        class qs {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new ca, this._verticalPerspectiveCameraHelper = new Ca
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, i) {
            return this.currentHelper.handlePanInertia(e, i)
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i)
          }
          handleMapControlsPan(e, i, l) {
            this.currentHelper.handleMapControlsPan(e, i, l)
          }
          cameraForBoxAndBearing(e, i, l, u, d) {
            return this.currentHelper.cameraForBoxAndBearing(e, i, l, u, d)
          }
          handleJumpToCenterZoom(e, i) {
            this.currentHelper.handleJumpToCenterZoom(e, i)
          }
          handleEaseTo(e, i) {
            return this.currentHelper.handleEaseTo(e, i)
          }
          handleFlyTo(e, i) {
            return this.currentHelper.handleFlyTo(e, i)
          }
        }
        const fs = (h, e) => s.z(h, e && e.filter((i => i.identifier !== "source.canvas"))),
          Al = s.bH();
        class Us extends s.E {
          constructor(e, i = {}) {
            var l, u;
            super(), this._rtlPluginLoaded = () => {
              for (const g in this.tileManagers) {
                const T = this.tileManagers[g].getSource().type;
                T !== "vector" && T !== "geojson" || this.tileManagers[g].reload()
              }
            }, this.map = e, this.dispatcher = new xt(ot(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((g, T) => this.getGlyphs(g, T))), this.dispatcher.registerMessageHandler("GI", ((g, T) => this.getImages(g, T))), this.dispatcher.registerMessageHandler("GDA", ((g, T) => this.getDashes(g, T))), this.imageManager = new it, this.imageManager.setEventedParent(this);
            const d = ((l = e._container) === null || l === void 0 ? void 0 : l.lang) || typeof document < "u" && ((u = document.documentElement) === null || u === void 0 ? void 0 : u.lang) || void 0;
            this.glyphManager = new We(e._requestManager, i.localIdeographFontFamily, d), this.lineAtlas = new yt(256, 512), this.crossTileSymbolIndex = new gn, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new s.bI, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bJ()), D().on(Te, this._rtlPluginLoaded), this.on("data", (g => {
              if (g.dataType !== "source" || g.sourceDataType !== "metadata") return;
              const T = this.tileManagers[g.sourceId];
              if (!T) return;
              const S = T.getSource();
              if (S && S.vectorLayerIds)
                for (const k in this._layers) {
                  const z = this._layers[k];
                  z.source === S.id && this._validateLayer(z)
                }
            }))
          }
          setGlobalStateProperty(e, i) {
            var l, u, d;
            this._checkLoaded();
            const g = i === null ? (d = (u = (l = this.stylesheet.state) === null || l === void 0 ? void 0 : l[e]) === null || u === void 0 ? void 0 : u.default) !== null && d !== void 0 ? d : null : i;
            if (s.bK(g, this._globalState[e])) return this;
            this._globalState[e] = g, this._applyGlobalStateChanges([e])
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const i = [];
            for (const l in e) !s.bK(this._globalState[l], e[l].default) && (i.push(l), this._globalState[l] = e[l].default);
            this._applyGlobalStateChanges(i)
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const i = new Set,
              l = {};
            for (const u of e) {
              l[u] = this._globalState[u];
              for (const d in this._layers) {
                const g = this._layers[d],
                  T = g.getLayoutAffectingGlobalStateRefs(),
                  S = g.getPaintAffectingGlobalStateRefs();
                if (T.has(u) && i.add(g.source), S.has(u))
                  for (const {
                      name: k,
                      value: z
                    }
                    of S.get(u)) this._updatePaintProperty(g, k, z)
              }
            }
            this.dispatcher.broadcast("UGS", l);
            for (const u in this.tileManagers) i.has(u) && (this._reloadSource(u), this._changed = !0)
          }
          loadURL(e, i = {}, l) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), i.validate = typeof i.validate != "boolean" || i.validate;
            const u = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const d = this._loadStyleRequest;
            s.j(u, this._loadStyleRequest).then((g => {
              this._loadStyleRequest = null, this._load(g.data, i, l)
            })).catch((g => {
              this._loadStyleRequest = null, g && !d.signal.aborted && this.fire(new s.k(g))
            }))
          }
          loadJSON(e, i = {}, l) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, re.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, i.validate = i.validate !== !1, this._load(e, i, l)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._load(Al, {
              validate: !1
            })
          }
          _load(e, i, l) {
            var u, d;
            let g = i.transformStyle ? i.transformStyle(l, e) : e;
            if (!i.validate || !fs(this, s.B(g))) {
              g = Object.assign({}, g), this._loaded = !0, this.stylesheet = g;
              for (const T in g.sources) this.addSource(T, g.sources[T], {
                validate: !1
              });
              g.sprite ? this._loadSprite(g.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(g.glyphs), this._createLayers(), this.light = new Ve(this.stylesheet.light), this._setProjectionInternal(((u = this.stylesheet.projection) === null || u === void 0 ? void 0 : u.type) || "mercator"), this.sky = new lt(this.stylesheet.sky), this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null), this.fire(new s.l("data", {
                dataType: "style"
              })), this.fire(new s.l("style.load"))
            }
          }
          _createLayers() {
            var e, i, l;
            const u = s.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", u), this._order = u.map((d => d.id)), this._layers = {}, this._serializedLayers = null;
            for (const d of u) {
              const g = s.bM(d, this._globalState);
              if (g.setEventedParent(this, {
                  layer: {
                    id: d.id
                  }
                }), this._layers[d.id] = g, s.bN(g) && this.tileManagers[g.source]) {
                const T = (l = (i = d.paint) === null || i === void 0 ? void 0 : i["raster-fade-duration"]) !== null && l !== void 0 ? l : g.paint.get("raster-fade-duration");
                this.tileManagers[g.source].setRasterFadeDuration(T)
              }
            }
          }
          _loadSprite(e, i = !1, l = void 0) {
            let u;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(d, g, T, S) {
              return s._(this, void 0, void 0, (function*() {
                const k = Ee(d),
                  z = T > 1 ? "@2x" : "",
                  V = {},
                  F = {};
                for (const {
                    id: $,
                    url: J
                  }
                  of k) {
                  const ae = g.transformRequest(He(J, z, ".json"), "SpriteJSON");
                  V[$] = s.j(ae, S);
                  const oe = g.transformRequest(He(J, z, ".png"), "SpriteImage");
                  F[$] = $e.getImage(oe, S)
                }
                return yield Promise.all([...Object.values(V), ...Object.values(F)]), (function($, J) {
                  return s._(this, void 0, void 0, (function*() {
                    const ae = {};
                    for (const oe in $) {
                      ae[oe] = {};
                      const se = re.getImageCanvasContext((yield J[oe]).data),
                        fe = (yield $[oe]).data;
                      for (const xe in fe) {
                        const {
                          width: pe,
                          height: be,
                          x: Pe,
                          y: ge,
                          sdf: Fe,
                          pixelRatio: nt,
                          stretchX: et,
                          stretchY: rt,
                          content: at,
                          textFitWidth: Gt,
                          textFitHeight: Ht
                        } = fe[xe];
                        ae[oe][xe] = {
                          data: null,
                          pixelRatio: nt,
                          sdf: Fe,
                          stretchX: et,
                          stretchY: rt,
                          content: at,
                          textFitWidth: Gt,
                          textFitHeight: Ht,
                          spriteData: {
                            width: pe,
                            height: be,
                            x: Pe,
                            y: ge,
                            context: se
                          }
                        }
                      }
                    }
                    return ae
                  }))
                })(V, F)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((d => {
              if (this._spriteRequest = null, d)
                for (const g in d) {
                  this._spritesImagesIds[g] = [];
                  const T = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((S => !(S in d))) : [];
                  for (const S of T) this.imageManager.removeImage(S), this._changedImages[S] = !0;
                  for (const S in d[g]) {
                    const k = g === "default" ? S : `${g}:${S}`;
                    this._spritesImagesIds[g].push(k), k in this.imageManager.images ? this.imageManager.updateImage(k, d[g][S], !1) : this.imageManager.addImage(k, d[g][S]), i && (this._changedImages[k] = !0)
                  }
                }
            })).catch((d => {
              this._spriteRequest = null, u = d, this.fire(new s.k(u))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              })), l && l(u)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const i = this.tileManagers[e.source];
            if (!i) return;
            const l = e.sourceLayer;
            if (!l) return;
            const u = i.getSource();
            (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(l) === -1) && this.fire(new s.k(new Error(`Source layer "${l}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers)
              if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, i = !1) {
            const l = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(i ? s.bO(l) : l);
            const u = [];
            for (const d of e)
              if (l[d]) {
                const g = i ? s.bO(l[d]) : l[d];
                u.push(g)
              } return u
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const i = Object.keys(this._layers);
            for (const l of i) {
              const u = this._layers[l];
              u.type !== "custom" && (e[l] = u.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, i, l;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((l = this.projection) === null || l === void 0) && l.hasTransition()) return !0;
            for (const u in this.tileManagers)
              if (this.tileManagers[u].hasTransition()) return !0;
            for (const u in this._layers)
              if (this._layers[u].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const i = this._changed;
            if (i) {
              const u = Object.keys(this._updatedLayers),
                d = Object.keys(this._removedLayers);
              (u.length || d.length) && this._updateWorkerLayers(u, d);
              for (const g in this._updatedSources) {
                const T = this._updatedSources[g];
                if (T === "reload") this._reloadSource(g);
                else {
                  if (T !== "clear") throw new Error(`Invalid action ${T}`);
                  this._clearSource(g)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const l = {};
            for (const u in this.tileManagers) {
              const d = this.tileManagers[u];
              l[u] = d.used, d.used = !1
            }
            for (const u of this._order) {
              const d = this._layers[u];
              d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.tileManagers[d.source].used = !0)
            }
            for (const u in l) {
              const d = this.tileManagers[u];
              !!l[u] != !!d.used && d.fire(new s.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: u
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const i in this.tileManagers) this.tileManagers[i].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, i) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: i
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, i = {}) {
            var l;
            this._checkLoaded();
            const u = this.serialize();
            if (e = i.transformStyle ? i.transformStyle(u, e) : e, ((l = i.validate) === null || l === void 0 || l) && fs(this, s.B(e))) return !1;
            (e = s.bO(e)).layers = s.bL(e.layers);
            const d = s.bP(u, e),
              g = this._getOperationsToPerform(d);
            if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
            if (g.operations.length === 0) return !1;
            for (const T of g.operations) T();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const i = [],
              l = [];
            for (const u of e) switch (u.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                i.push((() => this.addLayer.apply(this, u.args)));
                break;
              case "removeLayer":
                i.push((() => this.removeLayer.apply(this, u.args)));
                break;
              case "setPaintProperty":
                i.push((() => this.setPaintProperty.apply(this, u.args)));
                break;
              case "setLayoutProperty":
                i.push((() => this.setLayoutProperty.apply(this, u.args)));
                break;
              case "setFilter":
                i.push((() => this.setFilter.apply(this, u.args)));
                break;
              case "addSource":
                i.push((() => this.addSource.apply(this, u.args)));
                break;
              case "removeSource":
                i.push((() => this.removeSource.apply(this, u.args)));
                break;
              case "setLayerZoomRange":
                i.push((() => this.setLayerZoomRange.apply(this, u.args)));
                break;
              case "setLight":
                i.push((() => this.setLight.apply(this, u.args)));
                break;
              case "setGeoJSONSourceData":
                i.push((() => this.setGeoJSONSourceData.apply(this, u.args)));
                break;
              case "setGlyphs":
                i.push((() => this.setGlyphs.apply(this, u.args)));
                break;
              case "setSprite":
                i.push((() => this.setSprite.apply(this, u.args)));
                break;
              case "setTerrain":
                i.push((() => this.map.setTerrain.apply(this, u.args)));
                break;
              case "setSky":
                i.push((() => this.setSky.apply(this, u.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, u.args);
                break;
              case "setGlobalState":
                i.push((() => this.setGlobalState.apply(this, u.args)));
                break;
              case "setTransition":
                i.push((() => {}));
                break;
              default:
                l.push(u.command)
            }
            return {
              operations: i,
              unimplemented: l
            }
          }
          addImage(e, i) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, i), this._afterImageUpdated(e)
          }
          updateImage(e, i) {
            this.imageManager.updateImage(e, i)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, i, l = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(s.B.source, `sources.${e}`, i, null, l)) return;
            this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
            const u = this.tileManagers[e] = new rn(e, i, this.dispatcher);
            u.style = this, u.setEventedParent(this, (() => ({
              isSourceLoaded: u.loaded(),
              source: u.serialize(),
              sourceId: e
            }))), u.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const l in this._layers)
              if (this._layers[l].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${l}" is using it.`)));
            const i = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], i.fire(new s.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, i) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const l = this.tileManagers[e].getSource();
            if (l.type !== "geojson") throw new Error(`geojsonSource.type is ${l.type}, which is !== 'geojson`);
            l.setData(i), this._changed = !0
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource()
          }
          addLayer(e, i, l = {}) {
            this._checkLoaded();
            const u = e.id;
            if (this.getLayer(u)) return void this.fire(new s.k(new Error(`Layer "${u}" already exists on this map.`)));
            let d;
            if (e.type === "custom") {
              if (fs(this, s.bQ(e))) return;
              d = s.bM(e, this._globalState)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(u, e.source), e = s.bO(e), e = s.e(e, {
                  source: u
                })), this._validate(s.B.layer, `layers.${u}`, e, {
                  arrayIndex: -1
                }, l)) return;
              d = s.bM(e, this._globalState), this._validateLayer(d), d.setEventedParent(this, {
                layer: {
                  id: u
                }
              })
            }
            const g = i ? this._order.indexOf(i) : this._order.length;
            if (i && g === -1) this.fire(new s.k(new Error(`Cannot add layer "${u}" before non-existing layer "${i}".`)));
            else {
              if (this._order.splice(g, 0, u), this._layerOrderChanged = !0, this._layers[u] = d, this._removedLayers[u] && d.source && d.type !== "custom") {
                const T = this._removedLayers[u];
                delete this._removedLayers[u], T.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload", this.tileManagers[d.source].pause())
              }
              this._updateLayer(d), d.onAdd && d.onAdd(this.map)
            }
          }
          moveLayer(e, i) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === i) return;
            const l = this._order.indexOf(e);
            this._order.splice(l, 1);
            const u = i ? this._order.indexOf(i) : this._order.length;
            i && u === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(u, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const i = this._layers[e];
            if (!i) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            i.setEventedParent(null);
            const l = this._order.indexOf(e);
            this._order.splice(l, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, i, l) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? u.minzoom === i && u.maxzoom === l || (i != null && (u.minzoom = i), l != null && (u.maxzoom = l), this._updateLayer(u)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, i, l = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            if (u) {
              if (!s.bK(u.filter, i)) return i == null ? (u.setFilter(void 0), void this._updateLayer(u)) : void(this._validate(s.B.filter, `layers.${u.id}.filter`, i, null, l) || (u.setFilter(s.bO(i)), this._updateLayer(u)))
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return s.bO(this.getLayer(e).filter)
          }
          setLayoutProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? s.bK(d.getLayoutProperty(i), l) || (d.setLayoutProperty(i, l, u), this._updateLayer(d)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, i) {
            const l = this.getLayer(e);
            if (l) return l.getLayoutProperty(i);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, i, l, u = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? s.bK(d.getPaintProperty(i), l) || this._updatePaintProperty(d, i, l, u) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          _updatePaintProperty(e, i, l, u = {}) {
            e.setPaintProperty(i, l, u) && this._updateLayer(e), s.bN(e) && i === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(l), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null
          }
          getPaintProperty(e, i) {
            return this.getLayer(e).getPaintProperty(i)
          }
          setFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = e.sourceLayer,
              d = this.tileManagers[l];
            if (d === void 0) return void this.fire(new s.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const g = d.getSource().type;
            g === "geojson" && u ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || u ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), d.setFeatureState(u, e.id, i)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, i) {
            this._checkLoaded();
            const l = e.source,
              u = this.tileManagers[l];
            if (u === void 0) return void this.fire(new s.k(new Error(`The source '${l}' does not exist in the map's style.`)));
            const d = u.getSource().type,
              g = d === "vector" ? e.sourceLayer : void 0;
            d !== "vector" || g ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(g, e.id, i) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const i = e.source,
              l = e.sourceLayer,
              u = this.tileManagers[i];
            if (u !== void 0) return u.getSource().type !== "vector" || l ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), u.getFeatureState(l, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${i}' does not exist in the map's style.`)))
          }
          getTransition() {
            return s.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bR(this.tileManagers, (d => d.serialize())),
              i = this._serializeByIds(this._order, !0),
              l = this.map.getTerrain() || void 0,
              u = this.stylesheet;
            return s.bS({
              version: u.version,
              name: u.name,
              metadata: u.metadata,
              light: u.light,
              sky: u.sky,
              center: u.center,
              zoom: u.zoom,
              bearing: u.bearing,
              pitch: u.pitch,
              sprite: u.sprite,
              glyphs: u.glyphs,
              transition: u.transition,
              projection: u.projection,
              sources: e,
              layers: i,
              terrain: l
            }, (d => d !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const i = g => this._layers[g].type === "fill-extrusion",
              l = {},
              u = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const T = this._order[g];
              if (i(T)) {
                l[T] = g;
                for (const S of e) {
                  const k = S[T];
                  if (k)
                    for (const z of k) u.push(z)
                }
              }
            }
            u.sort(((g, T) => T.intersectionZ - g.intersectionZ));
            const d = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const T = this._order[g];
              if (i(T))
                for (let S = u.length - 1; S >= 0; S--) {
                  const k = u[S].feature;
                  if (l[k.layer.id] < g) break;
                  d.push(k), u.pop()
                } else
                  for (const S of e) {
                    const k = S[T];
                    if (k)
                      for (const z of k) d.push(z.feature)
                  }
            }
            return d
          }
          queryRenderedFeatures(e, i, l) {
            i && i.filter && this._validate(s.B.filter, "queryRenderedFeatures.filter", i.filter, null, i);
            const u = {};
            if (i && i.layers) {
              if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const k of i.layers) {
                const z = this._layers[k];
                if (!z) return this.fire(new s.k(new Error(`The layer '${k}' does not exist in the map's style and cannot be queried for features.`))), [];
                u[z.source] = !0
              }
            }
            const d = [];
            i.availableImages = this._availableImages;
            const g = this._serializedAllLayers(),
              T = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null,
              S = Object.assign(Object.assign({}, i), {
                layers: T,
                globalState: this._globalState
              });
            for (const k in this.tileManagers) i.layers && !u[k] || d.push(kt(this.tileManagers[k], this._layers, g, e, S, l, this.map.terrain ? (z, V, F) => this.map.terrain.getElevation(z, V, F) : void 0));
            return this.placement && d.push((function(k, z, V, F, $, J, ae) {
              const oe = {},
                se = J.queryRenderedSymbols(F),
                fe = [];
              for (const xe of Object.keys(se).map(Number)) fe.push(ae[xe]);
              fe.sort(Zt);
              for (const xe of fe) {
                const pe = xe.featureIndex.lookupSymbolFeatures(se[xe.bucketInstanceId], z, xe.bucketIndex, xe.sourceLayerIndex, {
                  filterSpec: $.filter,
                  globalState: $.globalState
                }, $.layers, $.availableImages, k);
                for (const be in pe) {
                  const Pe = oe[be] = oe[be] || [],
                    ge = pe[be];
                  ge.sort(((Fe, nt) => {
                    const et = xe.featureSortOrder;
                    if (et) {
                      const rt = et.indexOf(Fe.featureIndex);
                      return et.indexOf(nt.featureIndex) - rt
                    }
                    return nt.featureIndex - Fe.featureIndex
                  }));
                  for (const Fe of ge) Pe.push(Fe)
                }
              }
              return (function(xe, pe, be) {
                for (const Pe in xe)
                  for (const ge of xe[Pe]) Nt(ge, be[pe[Pe].source]);
                return xe
              })(oe, k, V)
            })(this._layers, g, this.tileManagers, e, S, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(d)
          }
          querySourceFeatures(e, i) {
            i != null && i.filter && this._validate(s.B.filter, "querySourceFeatures.filter", i.filter, null, i);
            const l = this.tileManagers[e];
            return l ? (function(u, d) {
              const g = u.getRenderableIds().map((k => u.getTileByID(k))),
                T = [],
                S = {};
              for (let k = 0; k < g.length; k++) {
                const z = g[k],
                  V = z.tileID.canonical.key;
                S[V] || (S[V] = !0, z.querySourceFeatures(T, d))
              }
              return T
            })(l, i ? Object.assign(Object.assign({}, i), {
              globalState: this._globalState
            }) : {
              globalState: this._globalState
            }) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, i = {}) {
            this._checkLoaded();
            const l = this.light.getLight();
            let u = !1;
            for (const g in e)
              if (!s.bK(e[g], l[g])) {
                u = !0;
                break
              } if (!u) return;
            const d = {
              now: ne(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, i), this.light.updateTransitions(d)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, i = {}) {
            this._checkLoaded();
            const l = this.getSky();
            let u = !1;
            if (!e && !l) return;
            if (e && !l) u = !0;
            else if (!e && l) u = !0;
            else
              for (const g in e)
                if (!s.bK(e[g], l[g])) {
                  u = !0;
                  break
                } if (!u) return;
            const d = {
              now: ne(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(d)
          }
          _setProjectionInternal(e) {
            const i = (function(l, u) {
              const d = {
                constrain: u
              };
              if (Array.isArray(l)) {
                const g = new Ns({
                  type: l
                });
                return {
                  projection: g,
                  transform: new Ml(d),
                  cameraHelper: new qs(g)
                }
              }
              switch (l) {
                case "mercator":
                  return {
                    projection: new Rr, transform: new Pi(d), cameraHelper: new ca
                  };
                case "globe": {
                  const g = new Ns({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: g,
                    transform: new Ml(d),
                    cameraHelper: new qs(g)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new Tl, transform: new Il(d), cameraHelper: new Ca
                  };
                default:
                  return s.w(`Unknown projection name: ${l}. Falling back to mercator projection.`), {
                    projection: new Rr,
                    transform: new Pi(d),
                    cameraHelper: new ca
                  }
              }
            })(e, this.map.transformConstrain);
            this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper);
            for (const l in this.tileManagers) this.tileManagers[l].reload()
          }
          _validate(e, i, l, u, d = {}) {
            return (!d || d.validate !== !1) && fs(this, e.call(s.B, s.e({
              key: i,
              style: this.serialize(),
              value: l,
              styleSpec: s.t
            }, u)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), D().off(Te, this._rtlPluginLoaded);
            for (const i in this._layers) this._layers[i].setEventedParent(null);
            for (const i in this.tileManagers) {
              const l = this.tileManagers[i];
              l.setEventedParent(null), l.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles()
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload()
          }
          _updateSources(e) {
            for (const i in this.tileManagers) this.tileManagers[i].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e)
          }
          _updatePlacement(e, i, l, u, d = !1) {
            let g = !1,
              T = !1;
            const S = {};
            for (const k of this._order) {
              const z = this._layers[k];
              if (z.type !== "symbol") continue;
              if (!S[z.source]) {
                const F = this.tileManagers[z.source];
                S[z.source] = F.getRenderableIds(!0).map(($ => F.getTileByID($))).sort((($, J) => J.tileID.overscaledZ - $.tileID.overscaledZ || ($.tileID.isLessThan(J.tileID) ? -1 : 1)))
              }
              const V = this.crossTileSymbolIndex.addLayer(z, S[z.source], e.center.lng);
              g = g || V
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((d = d || this._layerOrderChanged || l === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(ne(), e.zoom)) && (this.pauseablePlacement = new An(e, this.map.terrain, this._order, d, i, l, u, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, S), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(ne()), T = !0), g && this.pauseablePlacement.placement.setStale()), T || g)
              for (const k of this._order) {
                const z = this._layers[k];
                z.type === "symbol" && this.placement.updateLayerOpacities(z, S[z.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(ne())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles()
          }
          getImages(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = yield this.imageManager.getImages(i.icons);
              this._updateTilesForChangedImages();
              const u = this.tileManagers[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, i.icons), l
            }))
          }
          getGlyphs(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = yield this.glyphManager.getGlyphs(i.stacks), u = this.tileManagers[i.source];
              return u && u.setDependencies(i.tileID.key, i.type, [""]), l
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, i = {}) {
            this._checkLoaded(), e && this._validate(s.B.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          getDashes(e, i) {
            return s._(this, void 0, void 0, (function*() {
              const l = {};
              for (const [u, d] of Object.entries(i.dashes)) l[u] = this.lineAtlas.getDash(d.dasharray, d.round);
              return l
            }))
          }
          addSprite(e, i, l = {}, u) {
            this._checkLoaded();
            const d = [{
                id: e,
                url: i
              }],
              g = [...Ee(this.stylesheet.sprite), ...d];
            this._validate(s.B.sprite, "sprite", g, null, l) || (this.stylesheet.sprite = g, this._loadSprite(d, !0, u))
          }
          removeSprite(e) {
            this._checkLoaded();
            const i = Ee(this.stylesheet.sprite);
            if (i.find((l => l.id === e))) {
              if (this._spritesImagesIds[e])
                for (const l of this._spritesImagesIds[e]) this.imageManager.removeImage(l), this._changedImages[l] = !0;
              i.splice(i.findIndex((l => l.id === e)), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              }))
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return Ee(this.stylesheet.sprite)
          }
          setSprite(e, i = {}, l) {
            this._checkLoaded(), e && this._validate(s.B.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, l) : (this._unloadSprite(), l && l(null)))
          }
        }
        var Vc = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class qa {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, i, l, u, d, g, T, S, k) {
            this.context = e;
            let z = this.boundPaintVertexBuffers.length !== u.length;
            for (let V = 0; !z && V < u.length; V++) this.boundPaintVertexBuffers[V] !== u[V] && (z = !0);
            !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== l || z || this.boundIndexBuffer !== d || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== T || this.boundDynamicVertexBuffer2 !== S || this.boundDynamicVertexBuffer3 !== k ? this.freshBind(i, l, u, d, g, T, S, k) : (e.bindVertexArray.set(this.vao), T && T.bind(), d && d.dynamicDraw && d.bind(), S && S.bind(), k && k.bind())
          }
          freshBind(e, i, l, u, d, g, T, S) {
            const k = e.numAttributes,
              z = this.context,
              V = z.gl;
            this.vao && this.destroy(), this.vao = z.createVertexArray(), z.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = i, this.boundPaintVertexBuffers = l, this.boundIndexBuffer = u, this.boundVertexOffset = d, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = T, this.boundDynamicVertexBuffer3 = S, i.enableAttributes(V, e);
            for (const F of l) F.enableAttributes(V, e);
            g && g.enableAttributes(V, e), T && T.enableAttributes(V, e), S && S.enableAttributes(V, e), i.bind(), i.setVertexAttribPointers(V, e, d);
            for (const F of l) F.bind(), F.setVertexAttribPointers(V, e, d);
            g && (g.bind(), g.setVertexAttribPointers(V, e, d)), u && u.bind(), T && (T.bind(), T.setVertexAttribPointers(V, e, d)), S && (S.bind(), S.setVertexAttribPointers(V, e, d)), z.currentNumAttributes = k
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const nf = (h, e, i, l, u) => ({
            u_texture: 0,
            u_ele_delta: h,
            u_fog_matrix: e,
            u_fog_color: i ? i.properties.get("fog-color") : s.bi.white,
            u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: u ? 0 : i ? i.calculateFogBlendOpacity(l) : 0,
            u_horizon_color: i ? i.properties.get("horizon-color") : s.bi.white,
            u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: u ? 1 : 0
          }),
          qc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function yo(h) {
          const e = [];
          for (let i = 0; i < h.length; i++) {
            if (h[i] === null) continue;
            const l = h[i].split(" ");
            e.push(l.pop())
          }
          return e
        }
        class Zs {
          constructor(e, i, l, u, d, g, T, S, k = []) {
            const z = e.gl;
            this.program = z.createProgram();
            const V = yo(i.staticAttributes),
              F = l ? l.getBinderAttributes() : [],
              $ = V.concat(F),
              J = pr.prelude.staticUniforms ? yo(pr.prelude.staticUniforms) : [],
              ae = T.staticUniforms ? yo(T.staticUniforms) : [],
              oe = i.staticUniforms ? yo(i.staticUniforms) : [],
              se = l ? l.getBinderUniforms() : [],
              fe = J.concat(ae).concat(oe).concat(se),
              xe = [];
            for (const et of fe) xe.indexOf(et) < 0 && xe.push(et);
            const pe = l ? l.defines() : [];
            ea(z) && pe.unshift("#version 300 es"), d && pe.push("#define OVERDRAW_INSPECTOR;"), g && pe.push("#define TERRAIN3D;"), S && pe.push(S), k && pe.push(...k);
            let be = pe.concat(pr.prelude.fragmentSource, T.fragmentSource, i.fragmentSource).join(`
`),
              Pe = pe.concat(pr.prelude.vertexSource, T.vertexSource, i.vertexSource).join(`
`);
            ea(z) || (be = (function(et) {
              return et.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(be), Pe = (function(et) {
              return et.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Pe));
            const ge = z.createShader(z.FRAGMENT_SHADER);
            if (z.isContextLost()) return void(this.failedToCreate = !0);
            if (z.shaderSource(ge, be), z.compileShader(ge), !z.getShaderParameter(ge, z.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${z.getShaderInfoLog(ge)}`);
            z.attachShader(this.program, ge);
            const Fe = z.createShader(z.VERTEX_SHADER);
            if (z.isContextLost()) return void(this.failedToCreate = !0);
            if (z.shaderSource(Fe, Pe), z.compileShader(Fe), !z.getShaderParameter(Fe, z.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${z.getShaderInfoLog(Fe)}`);
            z.attachShader(this.program, Fe), this.attributes = {};
            const nt = {};
            this.numAttributes = $.length;
            for (let et = 0; et < this.numAttributes; et++) $[et] && (z.bindAttribLocation(this.program, et, $[et]), this.attributes[$[et]] = et);
            if (z.linkProgram(this.program), !z.getProgramParameter(this.program, z.LINK_STATUS)) throw new Error(`Program failed to link: ${z.getProgramInfoLog(this.program)}`);
            z.deleteShader(Fe), z.deleteShader(ge);
            for (let et = 0; et < xe.length; et++) {
              const rt = xe[et];
              if (rt && !nt[rt]) {
                const at = z.getUniformLocation(this.program, rt);
                at && (nt[rt] = at)
              }
            }
            this.fixedUniforms = u(e, nt), this.terrainUniforms = ((et, rt) => ({
              u_depth: new s.bT(et, rt.u_depth),
              u_terrain: new s.bT(et, rt.u_terrain),
              u_terrain_dim: new s.bj(et, rt.u_terrain_dim),
              u_terrain_matrix: new s.bV(et, rt.u_terrain_matrix),
              u_terrain_unpack: new s.bW(et, rt.u_terrain_unpack),
              u_terrain_exaggeration: new s.bj(et, rt.u_terrain_exaggeration)
            }))(e, nt), this.projectionUniforms = ((et, rt) => ({
              u_projection_matrix: new s.bV(et, rt.u_projection_matrix),
              u_projection_tile_mercator_coords: new s.bW(et, rt.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new s.bW(et, rt.u_projection_clipping_plane),
              u_projection_transition: new s.bj(et, rt.u_projection_transition),
              u_projection_fallback_matrix: new s.bV(et, rt.u_projection_fallback_matrix)
            }))(e, nt), this.binderUniforms = l ? l.getUniforms(e, nt) : []
          }
          draw(e, i, l, u, d, g, T, S, k, z, V, F, $, J, ae, oe, se, fe, xe) {
            const pe = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(l), e.setStencilMode(u), e.setColorMode(d), e.setCullFace(g), S) {
              e.activeTexture.set(pe.TEXTURE2), pe.bindTexture(pe.TEXTURE_2D, S.depthTexture), e.activeTexture.set(pe.TEXTURE3), pe.bindTexture(pe.TEXTURE_2D, S.texture);
              for (const Pe in this.terrainUniforms) this.terrainUniforms[Pe].set(S[Pe])
            }
            if (k)
              for (const Pe in k) this.projectionUniforms[qc[Pe]].set(k[Pe]);
            if (T)
              for (const Pe in this.fixedUniforms) this.fixedUniforms[Pe].set(T[Pe]);
            oe && oe.setUniforms(e, this.binderUniforms, J, {
              zoom: ae
            });
            let be = 0;
            switch (i) {
              case pe.LINES:
                be = 2;
                break;
              case pe.TRIANGLES:
                be = 3;
                break;
              case pe.LINE_STRIP:
                be = 1
            }
            for (const Pe of $.get()) {
              const ge = Pe.vaos || (Pe.vaos = {});
              (ge[z] || (ge[z] = new qa)).bind(e, this, V, oe ? oe.getPaintVertexBuffers() : [], F, Pe.vertexOffset, se, fe, xe), pe.drawElements(i, Pe.primitiveLength * be, pe.UNSIGNED_SHORT, Pe.primitiveOffset * be * 2)
            }
          }
        }

        function rd(h, e, i) {
          const l = 1 / s.aG(i, 1, e.transform.tileZoom),
            u = Math.pow(2, i.tileID.overscaledZ),
            d = i.tileSize * Math.pow(2, e.transform.tileZoom) / u,
            g = d * (i.tileID.canonical.x + i.tileID.wrap * u),
            T = d * i.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: i.imageAtlasTexture.size,
            u_scale: [l, h.fromScale, h.toScale],
            u_fade: h.t,
            u_pixel_coord_upper: [g >> 16, T >> 16],
            u_pixel_coord_lower: [65535 & g, 65535 & T]
          }
        }
        const Gs = (h, e, i, l) => {
            const u = h.style.light,
              d = u.properties.get("position"),
              g = [d.x, d.y, d.z],
              T = s.bZ();
            u.properties.get("anchor") === "viewport" && s.b_(T, h.transform.bearingInRadians), s.b$(g, g, T);
            const S = h.transform.transformLightDirection(g),
              k = u.properties.get("color");
            return {
              u_lightpos: g,
              u_lightpos_globe: S,
              u_lightintensity: u.properties.get("intensity"),
              u_lightcolor: [k.r, k.g, k.b],
              u_vertical_gradient: +e,
              u_opacity: i,
              u_fill_translate: l
            }
          },
          af = (h, e, i, l, u, d, g) => s.e(Gs(h, e, i, l), rd(d, h, g), {
            u_height_factor: -Math.pow(2, u.overscaledZ) / g.tileSize / 8
          }),
          Ro = (h, e, i, l) => s.e(rd(e, h, i), {
            u_fill_translate: l
          }),
          of = (h, e) => ({
            u_world: h,
            u_fill_translate: e
          }),
          nd = (h, e, i, l, u) => s.e(Ro(h, e, i, u), {
            u_world: l
          }),
          sf = (h, e, i, l, u) => {
            const d = h.transform;
            let g, T, S = 0;
            if (i.paint.get("circle-pitch-alignment") === "map") {
              const k = s.aG(e, 1, d.zoom);
              g = !0, T = [k, k], S = k / (s.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * u
            } else g = !1, T = d.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: d.cameraToCenterDistance,
              u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +g,
              u_device_pixel_ratio: h.pixelRatio,
              u_extrude_scale: T,
              u_globe_extrude_scale: S,
              u_translate: l
            }
          },
          id = h => ({
            u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
          }),
          Uc = h => ({
            u_viewport_size: [h.width, h.height]
          }),
          Zc = (h, e = 1) => ({
            u_color: h,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Gc = (h, e, i, l) => {
            const u = s.aG(h, 1, e) / (s.a3 * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * l;
            return {
              u_extrude_scale: s.aG(h, 1, e),
              u_intensity: i,
              u_globe_extrude_scale: u
            }
          },
          $c = (h, e, i, l) => {
            const u = s.M();
            s.c0(u, 0, h.width, h.height, 0, 0, 1);
            const d = h.context.gl;
            return {
              u_matrix: u,
              u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
              u_image: i,
              u_color_ramp: l,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          ad = (h, e, i) => {
            const l = i.paint.get("hillshade-accent-color");
            let u;
            switch (i.paint.get("hillshade-method")) {
              case "basic":
                u = 4;
                break;
              case "combined":
                u = 1;
                break;
              case "igor":
                u = 2;
                break;
              case "multidirectional":
                u = 3;
                break;
              default:
                u = 0
            }
            const d = i.getIlluminationProperties();
            for (let g = 0; g < d.directionRadians.length; g++) i.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[g] += h.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: od(0, e.tileID),
              u_exaggeration: i.paint.get("hillshade-exaggeration"),
              u_altitudes: d.altitudeRadians,
              u_azimuths: d.directionRadians,
              u_accent: l,
              u_method: u,
              u_highlights: d.highlightColor,
              u_shadows: d.shadowColor
            }
          },
          Fo = (h, e) => {
            const i = e.stride,
              l = s.M();
            return s.c0(l, 0, s.a3, -s.a3, 0, 0, 1), s.N(l, l, [0, -s.a3, 0]), {
              u_matrix: l,
              u_image: 1,
              u_dimension: [i, i],
              u_zoom: h.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function od(h, e) {
          const i = Math.pow(2, e.canonical.z),
            l = e.canonical.y;
          return [new s.a5(0, l / i).toLngLat().lat, new s.a5(0, (l + 1) / i).toLngLat().lat]
        }
        const sd = (h, e, i = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: i,
            u_opacity: h.paint.get("color-relief-opacity")
          }),
          xo = (h, e, i, l) => {
            const u = h.transform;
            return {
              u_translation: Hc(h, e, i),
              u_ratio: l / s.aG(e, 1, u.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]]
            }
          },
          lf = (h, e, i, l, u) => s.e(xo(h, e, i, l), {
            u_image: 0,
            u_image_height: u
          }),
          kl = (h, e, i, l, u) => {
            const d = h.transform,
              g = El(e, d);
            return {
              u_translation: Hc(h, e, i),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: l / s.aG(e, 1, d.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_image: 0,
              u_scale: [g, u.fromScale, u.toScale],
              u_fade: u.t,
              u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]]
            }
          },
          cf = (h, e, i, l, u) => {
            const d = El(e, h.transform);
            return s.e(xo(h, e, i, l), {
              u_tileratio: d,
              u_crossfade_from: u.fromScale,
              u_crossfade_to: u.toScale,
              u_image: 0,
              u_mix: u.t,
              u_lineatlas_width: h.lineAtlas.width,
              u_lineatlas_height: h.lineAtlas.height
            })
          },
          uf = (h, e, i, l, u, d) => {
            const g = El(e, h.transform);
            return s.e(xo(h, e, i, l), {
              u_image: 0,
              u_image_height: d,
              u_tileratio: g,
              u_crossfade_from: u.fromScale,
              u_crossfade_to: u.toScale,
              u_image_dash: 1,
              u_mix: u.t,
              u_lineatlas_width: h.lineAtlas.width,
              u_lineatlas_height: h.lineAtlas.height
            })
          };

        function El(h, e) {
          return 1 / s.aG(h, 1, e.tileZoom)
        }

        function Hc(h, e, i) {
          return s.aH(h.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
        }
        const ld = (h, e, i, l, u) => {
          return {
            u_tl_parent: h,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: i.mix,
            u_opacity: i.opacity * l.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: l.paint.get("raster-brightness-min"),
            u_brightness_high: l.paint.get("raster-brightness-max"),
            u_saturation_factor: (g = l.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g),
            u_contrast_factor: (d = l.paint.get("raster-contrast"), d > 0 ? 1 / (1 - d) : 1 + d),
            u_spin_weights: Wc(l.paint.get("raster-hue-rotate")),
            u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
            u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y]
          };
          var d, g
        };

        function Wc(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h),
            i = Math.cos(h);
          return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
        }
        const Xc = (h, e, i, l, u, d, g, T, S, k, z, V, F) => {
            const $ = g.transform;
            return {
              u_is_size_zoom_constant: +(h === "constant" || h === "source"),
              u_is_size_feature_constant: +(h === "constant" || h === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: $.cameraToCenterDistance,
              u_pitch: $.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +i,
              u_aspect_ratio: $.width / $.height,
              u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1,
              u_label_plane_matrix: T,
              u_coord_matrix: S,
              u_is_text: +z,
              u_pitch_with_map: +l,
              u_is_along_line: u,
              u_is_variable_anchor: d,
              u_texsize: V,
              u_texture: 0,
              u_translation: k,
              u_pitched_scale: F
            }
          },
          $s = (h, e, i, l, u, d, g, T, S, k, z, V, F, $) => {
            const J = g.transform;
            return s.e(Xc(h, e, i, l, u, d, g, T, S, k, z, V, $), {
              u_gamma_scale: l ? Math.cos(J.pitch * Math.PI / 180) * J.cameraToCenterDistance : 1,
              u_device_pixel_ratio: g.pixelRatio,
              u_is_halo: 1
            })
          },
          Qa = (h, e, i, l, u, d, g, T, S, k, z, V, F) => s.e($s(h, e, i, l, u, d, g, T, S, k, !0, z, 0, F), {
            u_texsize_icon: V,
            u_texture_icon: 1
          }),
          Yc = (h, e) => ({
            u_opacity: h,
            u_color: e
          }),
          Kc = (h, e, i, l, u) => s.e((function(d, g, T, S) {
            const k = T.imageManager.getPattern(d.from.toString()),
              z = T.imageManager.getPattern(d.to.toString()),
              {
                width: V,
                height: F
              } = T.imageManager.getPixelSize(),
              $ = Math.pow(2, S.tileID.overscaledZ),
              J = S.tileSize * Math.pow(2, T.transform.tileZoom) / $,
              ae = J * (S.tileID.canonical.x + S.tileID.wrap * $),
              oe = J * S.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: k.tl,
              u_pattern_br_a: k.br,
              u_pattern_tl_b: z.tl,
              u_pattern_br_b: z.br,
              u_texsize: [V, F],
              u_mix: g.t,
              u_pattern_size_a: k.displaySize,
              u_pattern_size_b: z.displaySize,
              u_scale_a: g.fromScale,
              u_scale_b: g.toScale,
              u_tile_units_to_pixels: 1 / s.aG(S, 1, T.transform.tileZoom),
              u_pixel_coord_upper: [ae >> 16, oe >> 16],
              u_pixel_coord_lower: [65535 & ae, 65535 & oe]
            }
          })(i, u, e, l), {
            u_opacity: h
          }),
          zl = (h, e) => {},
          cd = {
            fillExtrusion: (h, e) => ({
              u_lightpos: new s.bX(h, e.u_lightpos),
              u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
              u_lightintensity: new s.bj(h, e.u_lightintensity),
              u_lightcolor: new s.bX(h, e.u_lightcolor),
              u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
              u_opacity: new s.bj(h, e.u_opacity),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillExtrusionPattern: (h, e) => ({
              u_lightpos: new s.bX(h, e.u_lightpos),
              u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
              u_lightintensity: new s.bj(h, e.u_lightintensity),
              u_lightcolor: new s.bX(h, e.u_lightcolor),
              u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
              u_height_factor: new s.bj(h, e.u_height_factor),
              u_opacity: new s.bj(h, e.u_opacity),
              u_fill_translate: new s.bY(h, e.u_fill_translate),
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade)
            }),
            fill: (h, e) => ({
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillPattern: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillOutline: (h, e) => ({
              u_world: new s.bY(h, e.u_world),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillOutlinePattern: (h, e) => ({
              u_world: new s.bY(h, e.u_world),
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            circle: (h, e) => ({
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_scale_with_map: new s.bT(h, e.u_scale_with_map),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_extrude_scale: new s.bY(h, e.u_extrude_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale),
              u_translate: new s.bY(h, e.u_translate)
            }),
            collisionBox: (h, e) => ({
              u_pixel_extrude_scale: new s.bY(h, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (h, e) => ({
              u_viewport_size: new s.bY(h, e.u_viewport_size)
            }),
            debug: (h, e) => ({
              u_color: new s.bU(h, e.u_color),
              u_overlay: new s.bT(h, e.u_overlay),
              u_overlay_scale: new s.bj(h, e.u_overlay_scale)
            }),
            depth: zl,
            clippingMask: zl,
            heatmap: (h, e) => ({
              u_extrude_scale: new s.bj(h, e.u_extrude_scale),
              u_intensity: new s.bj(h, e.u_intensity),
              u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (h, e) => ({
              u_matrix: new s.bV(h, e.u_matrix),
              u_world: new s.bY(h, e.u_world),
              u_image: new s.bT(h, e.u_image),
              u_color_ramp: new s.bT(h, e.u_color_ramp),
              u_opacity: new s.bj(h, e.u_opacity)
            }),
            hillshade: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_latrange: new s.bY(h, e.u_latrange),
              u_exaggeration: new s.bj(h, e.u_exaggeration),
              u_altitudes: new s.c2(h, e.u_altitudes),
              u_azimuths: new s.c2(h, e.u_azimuths),
              u_accent: new s.bU(h, e.u_accent),
              u_method: new s.bT(h, e.u_method),
              u_shadows: new s.c1(h, e.u_shadows),
              u_highlights: new s.c1(h, e.u_highlights)
            }),
            hillshadePrepare: (h, e) => ({
              u_matrix: new s.bV(h, e.u_matrix),
              u_image: new s.bT(h, e.u_image),
              u_dimension: new s.bY(h, e.u_dimension),
              u_zoom: new s.bj(h, e.u_zoom),
              u_unpack: new s.bW(h, e.u_unpack)
            }),
            colorRelief: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_unpack: new s.bW(h, e.u_unpack),
              u_dimension: new s.bY(h, e.u_dimension),
              u_elevation_stops: new s.bT(h, e.u_elevation_stops),
              u_color_stops: new s.bT(h, e.u_color_stops),
              u_color_ramp_size: new s.bT(h, e.u_color_ramp_size),
              u_opacity: new s.bj(h, e.u_opacity)
            }),
            line: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels)
            }),
            lineGradient: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_image_height: new s.bj(h, e.u_image_height)
            }),
            linePattern: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_texsize: new s.bY(h, e.u_texsize),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_image: new s.bT(h, e.u_image),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade)
            }),
            lineSDF: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_mix: new s.bj(h, e.u_mix),
              u_tileratio: new s.bj(h, e.u_tileratio),
              u_crossfade_from: new s.bj(h, e.u_crossfade_from),
              u_crossfade_to: new s.bj(h, e.u_crossfade_to),
              u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(h, e.u_lineatlas_height)
            }),
            lineGradientSDF: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_image_height: new s.bj(h, e.u_image_height),
              u_tileratio: new s.bj(h, e.u_tileratio),
              u_crossfade_from: new s.bj(h, e.u_crossfade_from),
              u_crossfade_to: new s.bj(h, e.u_crossfade_to),
              u_image_dash: new s.bT(h, e.u_image_dash),
              u_mix: new s.bj(h, e.u_mix),
              u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(h, e.u_lineatlas_height)
            }),
            raster: (h, e) => ({
              u_tl_parent: new s.bY(h, e.u_tl_parent),
              u_scale_parent: new s.bj(h, e.u_scale_parent),
              u_buffer_scale: new s.bj(h, e.u_buffer_scale),
              u_fade_t: new s.bj(h, e.u_fade_t),
              u_opacity: new s.bj(h, e.u_opacity),
              u_image0: new s.bT(h, e.u_image0),
              u_image1: new s.bT(h, e.u_image1),
              u_brightness_low: new s.bj(h, e.u_brightness_low),
              u_brightness_high: new s.bj(h, e.u_brightness_high),
              u_saturation_factor: new s.bj(h, e.u_saturation_factor),
              u_contrast_factor: new s.bj(h, e.u_contrast_factor),
              u_spin_weights: new s.bX(h, e.u_spin_weights),
              u_coords_top: new s.bW(h, e.u_coords_top),
              u_coords_bottom: new s.bW(h, e.u_coords_bottom)
            }),
            symbolIcon: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texture: new s.bT(h, e.u_texture),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            symbolSDF: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texture: new s.bT(h, e.u_texture),
              u_gamma_scale: new s.bj(h, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(h, e.u_is_halo),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texsize_icon: new s.bY(h, e.u_texsize_icon),
              u_texture: new s.bT(h, e.u_texture),
              u_texture_icon: new s.bT(h, e.u_texture_icon),
              u_gamma_scale: new s.bj(h, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(h, e.u_is_halo),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            background: (h, e) => ({
              u_opacity: new s.bj(h, e.u_opacity),
              u_color: new s.bU(h, e.u_color)
            }),
            backgroundPattern: (h, e) => ({
              u_opacity: new s.bj(h, e.u_opacity),
              u_image: new s.bT(h, e.u_image),
              u_pattern_tl_a: new s.bY(h, e.u_pattern_tl_a),
              u_pattern_br_a: new s.bY(h, e.u_pattern_br_a),
              u_pattern_tl_b: new s.bY(h, e.u_pattern_tl_b),
              u_pattern_br_b: new s.bY(h, e.u_pattern_br_b),
              u_texsize: new s.bY(h, e.u_texsize),
              u_mix: new s.bj(h, e.u_mix),
              u_pattern_size_a: new s.bY(h, e.u_pattern_size_a),
              u_pattern_size_b: new s.bY(h, e.u_pattern_size_b),
              u_scale_a: new s.bj(h, e.u_scale_a),
              u_scale_b: new s.bj(h, e.u_scale_b),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new s.bj(h, e.u_tile_units_to_pixels)
            }),
            terrain: (h, e) => ({
              u_texture: new s.bT(h, e.u_texture),
              u_ele_delta: new s.bj(h, e.u_ele_delta),
              u_fog_matrix: new s.bV(h, e.u_fog_matrix),
              u_fog_color: new s.bU(h, e.u_fog_color),
              u_fog_ground_blend: new s.bj(h, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new s.bj(h, e.u_fog_ground_blend_opacity),
              u_horizon_color: new s.bU(h, e.u_horizon_color),
              u_horizon_fog_blend: new s.bj(h, e.u_horizon_fog_blend),
              u_is_globe_mode: new s.bj(h, e.u_is_globe_mode)
            }),
            terrainDepth: (h, e) => ({
              u_ele_delta: new s.bj(h, e.u_ele_delta)
            }),
            terrainCoords: (h, e) => ({
              u_texture: new s.bT(h, e.u_texture),
              u_terrain_coords_id: new s.bj(h, e.u_terrain_coords_id),
              u_ele_delta: new s.bj(h, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (h, e) => ({
              u_input: new s.bj(h, e.u_input),
              u_output_expected: new s.bj(h, e.u_output_expected)
            }),
            atmosphere: (h, e) => ({
              u_sun_pos: new s.bX(h, e.u_sun_pos),
              u_atmosphere_blend: new s.bj(h, e.u_atmosphere_blend),
              u_globe_position: new s.bX(h, e.u_globe_position),
              u_globe_radius: new s.bj(h, e.u_globe_radius),
              u_inv_proj_matrix: new s.bV(h, e.u_inv_proj_matrix)
            }),
            sky: (h, e) => ({
              u_sky_color: new s.bU(h, e.u_sky_color),
              u_horizon_color: new s.bU(h, e.u_horizon_color),
              u_horizon: new s.bY(h, e.u_horizon),
              u_horizon_normal: new s.bY(h, e.u_horizon_normal),
              u_sky_horizon_blend: new s.bj(h, e.u_sky_horizon_blend),
              u_sky_blend: new s.bj(h, e.u_sky_blend)
            })
          };
        class Jc {
          constructor(e, i, l) {
            this.context = e;
            const u = e.gl;
            this.buffer = u.createBuffer(), this.dynamicDraw = !!l, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), u.bufferData(u.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const i = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const Bo = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Qc {
          constructor(e, i, l, u) {
            this.length = i.length, this.attributes = l, this.itemSize = i.bytesPerElement, this.dynamicDraw = u, this.context = e;
            const d = e.gl;
            this.buffer = d.createBuffer(), e.bindVertexBuffer.set(this.buffer), d.bufferData(d.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const i = this.context.gl;
            this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, i) {
            for (let l = 0; l < this.attributes.length; l++) {
              const u = i.attributes[this.attributes[l].name];
              u !== void 0 && e.enableVertexAttribArray(u)
            }
          }
          setVertexAttribPointers(e, i, l) {
            for (let u = 0; u < this.attributes.length; u++) {
              const d = this.attributes[u],
                g = i.attributes[d.name];
              g !== void 0 && e.vertexAttribPointer(g, d.components, e[Bo[d.type]], !1, this.itemSize, d.offset + this.itemSize * (l || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class Mn {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class hf extends Mn {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class df extends Mn {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class pf extends Mn {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class ud extends Mn {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class ff extends Mn {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class hd extends Mn {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Ll extends Mn {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const i = this.current;
            (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Dl extends Mn {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class Rl extends Mn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class eu extends Mn {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Oo extends Mn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Hs extends Mn {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class ms extends Mn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.BLEND) : i.disable(i.BLEND), this.current = e, this.dirty = !1
          }
        }
        class xa extends Mn {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class dd extends Mn {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class pd extends Mn {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class tu extends Mn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class No extends Mn {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Fl extends Mn {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Bl extends Mn {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class Ws extends Mn {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Ol extends Mn {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class fd extends Mn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindFramebuffer(i.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class _s extends Mn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindRenderbuffer(i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class gs extends Mn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindTexture(i.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class md extends Mn {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindBuffer(i.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ru extends Mn {
          getDefault() {
            return null
          }
          set(e) {
            const i = this.gl;
            i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class xn extends Mn {
          getDefault() {
            return null
          }
          set(e) {
            var i;
            if (e === this.current && !this.dirty) return;
            const l = this.gl;
            ea(l) ? l.bindVertexArray(e) : (i = l.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class Nl extends Mn {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class mf extends Mn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class _d extends Mn {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class jo extends Mn {
          constructor(e, i) {
            super(e), this.context = e, this.parent = i
          }
          getDefault() {
            return null
          }
        }
        class _f extends jo {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class gf extends jo {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class gd extends jo {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const vd = "Framebuffer is not complete";
        class nu {
          constructor(e, i, l, u, d) {
            this.context = e, this.width = i, this.height = l;
            const g = e.gl,
              T = this.framebuffer = g.createFramebuffer();
            if (this.colorAttachment = new _f(e, T), u) this.depthAttachment = d ? new gd(e, T) : new gf(e, T);
            else if (d) throw new Error("Stencil cannot be set without depth");
            if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error(vd)
          }
          destroy() {
            const e = this.context.gl,
              i = this.colorAttachment.get();
            if (i && e.deleteTexture(i), this.depthAttachment) {
              const l = this.depthAttachment.get();
              l && e.deleteRenderbuffer(l)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class jl {
          constructor(e) {
            var i, l;
            if (this.gl = e, this.clearColor = new hf(this), this.clearDepth = new df(this), this.clearStencil = new pf(this), this.colorMask = new ud(this), this.depthMask = new ff(this), this.stencilMask = new hd(this), this.stencilFunc = new Ll(this), this.stencilOp = new Dl(this), this.stencilTest = new Rl(this), this.depthRange = new eu(this), this.depthTest = new Oo(this), this.depthFunc = new Hs(this), this.blend = new ms(this), this.blendFunc = new xa(this), this.blendColor = new dd(this), this.blendEquation = new pd(this), this.cullFace = new tu(this), this.cullFaceSide = new No(this), this.frontFace = new Fl(this), this.program = new Bl(this), this.activeTexture = new Ws(this), this.viewport = new Ol(this), this.bindFramebuffer = new fd(this), this.bindRenderbuffer = new _s(this), this.bindTexture = new gs(this), this.bindVertexBuffer = new md(this), this.bindElementBuffer = new ru(this), this.bindVertexArray = new xn(this), this.pixelStoreUnpack = new Nl(this), this.pixelStoreUnpackPremultiplyAlpha = new mf(this), this.pixelStoreUnpackFlipY = new _d(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), ea(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const u = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : u == null ? void 0 : u.RGBA16F_EXT, this.RGB16F = (l = e.RGB16F) !== null && l !== void 0 ? l : u == null ? void 0 : u.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const u = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, i) {
            return new Jc(this, e, i)
          }
          createVertexBuffer(e, i, l) {
            return new Qc(this, e, i, l)
          }
          createRenderbuffer(e, i, l) {
            const u = this.gl,
              d = u.createRenderbuffer();
            return this.bindRenderbuffer.set(d), u.renderbufferStorage(u.RENDERBUFFER, e, i, l), this.bindRenderbuffer.set(null), d
          }
          createFramebuffer(e, i, l, u) {
            return new nu(this, e, i, l, u)
          }
          clear({
            color: e,
            depth: i,
            stencil: l
          }) {
            const u = this.gl;
            let d = 0;
            e && (d |= u.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), i !== void 0 && (d |= u.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), l !== void 0 && (d |= u.STENCIL_BUFFER_BIT, this.clearStencil.set(l), this.stencilMask.set(255)), u.clear(d)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            s.bK(e.blendFunction, mn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return ea(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var i;
            return ea(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let Vo;

        function Xs(h, e, i, l, u) {
          const d = h.context,
            g = h.transform,
            T = d.gl,
            S = h.useProgram("collisionBox"),
            k = [];
          let z = 0,
            V = 0;
          for (let se = 0; se < l.length; se++) {
            const fe = l[se],
              xe = e.getTile(fe).getBucket(i);
            if (!xe) continue;
            const pe = u ? xe.textCollisionBox : xe.iconCollisionBox,
              be = xe.collisionCircleArray;
            be.length > 0 && (k.push({
              circleArray: be,
              circleOffset: V,
              coord: fe
            }), z += be.length / 4, V = z), pe && S.draw(d, T.LINES, tn.disabled, yn.disabled, h.colorModeForRenderPass(), ln.disabled, id(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(fe), g.getProjectionData({
              overscaledTileID: fe,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), i.id, pe.layoutVertexBuffer, pe.indexBuffer, pe.segments, null, h.transform.zoom, null, null, pe.collisionVertexBuffer)
          }
          if (!u || !k.length) return;
          const F = h.useProgram("collisionCircle"),
            $ = new s.c3;
          $.resize(4 * z), $._trim();
          let J = 0;
          for (const se of k)
            for (let fe = 0; fe < se.circleArray.length / 4; fe++) {
              const xe = 4 * fe,
                pe = se.circleArray[xe + 0],
                be = se.circleArray[xe + 1],
                Pe = se.circleArray[xe + 2],
                ge = se.circleArray[xe + 3];
              $.emplace(J++, pe, be, Pe, ge, 0), $.emplace(J++, pe, be, Pe, ge, 1), $.emplace(J++, pe, be, Pe, ge, 2), $.emplace(J++, pe, be, Pe, ge, 3)
            }(!Vo || Vo.length < 2 * z) && (Vo = (function(se) {
              const fe = 2 * se,
                xe = new s.c5;
              xe.resize(fe), xe._trim();
              for (let pe = 0; pe < fe; pe++) {
                const be = 6 * pe;
                xe.uint16[be + 0] = 4 * pe + 0, xe.uint16[be + 1] = 4 * pe + 1, xe.uint16[be + 2] = 4 * pe + 2, xe.uint16[be + 3] = 4 * pe + 2, xe.uint16[be + 4] = 4 * pe + 3, xe.uint16[be + 5] = 4 * pe + 0
              }
              return xe
            })(z));
          const ae = d.createIndexBuffer(Vo, !0),
            oe = d.createVertexBuffer($, s.c4.members, !0);
          for (const se of k) {
            const fe = Uc(h.transform);
            F.draw(d, T.TRIANGLES, tn.disabled, yn.disabled, h.colorModeForRenderPass(), ln.disabled, fe, h.style.map.terrain && h.style.map.terrain.getTerrainData(se.coord), null, i.id, oe, ae, s.aQ.simpleSegment(0, 2 * se.circleOffset, se.circleArray.length, se.circleArray.length / 2), null, h.transform.zoom, null, null, null)
          }
          oe.destroy(), ae.destroy()
        }
        const iu = s.am(new Float32Array(16));

        function yd(h, e, i, l, u, d) {
          const {
            horizontalAlign: g,
            verticalAlign: T
          } = s.aL(h);
          return new s.P((-(g - .5) * e / u + l[0]) * d, (-(T - .5) * i / u + l[1]) * d)
        }

        function Vl(h, e, i, l, u, d) {
          const g = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let T = l.mult(d);
            i || (T = T.rotate(-u));
            const S = g.add(T);
            return Me(S.x, S.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (i) {
            const T = wr(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h),
              S = Math.atan(T.y / T.x) + (T.x < 0 ? Math.PI : 0);
            return h.add(l.rotate(S))
          }
          return h.add(l)
        }

        function ql(h, e, i, l, u, d, g, T, S, k, z, V) {
          const F = h.text.placedSymbolArray,
            $ = h.text.dynamicLayoutVertexArray,
            J = h.icon.dynamicLayoutVertexArray,
            ae = {};
          $.clear();
          for (let oe = 0; oe < F.length; oe++) {
            const se = F.get(oe),
              fe = se.hidden || !se.crossTileID || h.allowVerticalPlacement && !se.placedOrientation ? null : l[se.crossTileID];
            if (fe) {
              const xe = new s.P(se.anchorX, se.anchorY),
                pe = {
                  getElevation: V,
                  width: u.width,
                  height: u.height,
                  pitchedLabelPlaneMatrix: d,
                  pitchWithMap: i,
                  transform: u,
                  tileAnchorPoint: xe,
                  translation: k,
                  unwrappedTileID: z
                },
                be = i ? Mr(xe.x, xe.y, pe) : wr(xe.x, xe.y, pe),
                Pe = ft(u.cameraToCenterDistance, be.signedDistanceFromCamera);
              let ge = s.at(h.textSizeData, T, se) * Pe / s.aF;
              i && (ge *= h.tilePixelRatio / g);
              const {
                width: Fe,
                height: nt,
                anchor: et,
                textOffset: rt,
                textBoxScale: at
              } = fe, Gt = yd(et, Fe, nt, rt, at, ge), Ht = u.getPitchedTextCorrection(xe.x + k[0], xe.y + k[1], z), Pt = Vl(be.point, pe, e, Gt, -u.bearingInRadians, Ht), gr = h.allowVerticalPlacement && se.placedOrientation === s.as.vertical ? Math.PI / 2 : 0;
              for (let Qr = 0; Qr < se.numGlyphs; Qr++) s.az($, Pt, gr);
              S && se.associatedIconIndex >= 0 && (ae[se.associatedIconIndex] = {
                shiftedAnchor: Pt,
                angle: gr
              })
            } else Yn(se.numGlyphs, $)
          }
          if (S) {
            J.clear();
            const oe = h.icon.placedSymbolArray;
            for (let se = 0; se < oe.length; se++) {
              const fe = oe.get(se);
              if (fe.hidden) Yn(fe.numGlyphs, J);
              else {
                const xe = ae[se];
                if (xe)
                  for (let pe = 0; pe < fe.numGlyphs; pe++) s.az(J, xe.shiftedAnchor, xe.angle);
                else Yn(fe.numGlyphs, J)
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData(J)
          }
          h.text.dynamicLayoutVertexBuffer.updateData($)
        }

        function Ul(h, e, i) {
          return i.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
        }

        function qo(h, e, i, l, u, d, g, T, S, k, z, V, F) {
          const $ = h.context,
            J = $.gl,
            ae = h.transform,
            oe = T === "map",
            se = S === "map",
            fe = T !== "viewport" && i.layout.get("symbol-placement") !== "point",
            xe = oe && !se && !fe,
            pe = !i.layout.get("symbol-sort-key").isConstant();
          let be = !1;
          const Pe = h.getDepthModeForSublayer(0, tn.ReadOnly),
            ge = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Fe = [],
            nt = ae.getCircleRadiusCorrection();
          for (const et of l) {
            const rt = e.getTile(et),
              at = rt.getBucket(i);
            if (!at) continue;
            const Gt = u ? at.text : at.icon;
            if (!Gt || !Gt.segments.get().length || !Gt.hasVisibleVertices) continue;
            const Ht = Gt.programConfigurations.get(i.id),
              Pt = u || at.sdfIcons,
              gr = u ? at.textSizeData : at.iconSizeData,
              Qr = se || ae.pitch !== 0,
              En = h.useProgram(Ul(Pt, u, at), Ht),
              on = s.ar(gr, ae.zoom),
              On = h.style.map.terrain && h.style.map.terrain.getTerrainData(et);
            let Qn, qn, gi, Wn, Mi = [0, 0],
              Xn = null;
            if (u) qn = rt.glyphAtlasTexture, gi = J.LINEAR, Qn = rt.glyphAtlasTexture.size, at.iconsInText && (Mi = rt.imageAtlasTexture.size, Xn = rt.imageAtlasTexture, Wn = Qr || h.options.rotating || h.options.zooming || gr.kind === "composite" || gr.kind === "camera" ? J.LINEAR : J.NEAREST);
            else {
              const di = i.layout.get("icon-size").constantOr(0) !== 1 || at.iconsNeedLinear;
              qn = rt.imageAtlasTexture, gi = Pt || h.options.rotating || h.options.zooming || di || Qr ? J.LINEAR : J.NEAREST, Qn = rt.imageAtlasTexture.size
            }
            const hi = s.aG(rt, 1, h.transform.zoom),
              Ki = Pn(oe, h.transform, hi),
              Wo = s.M();
            s.au(Wo, Ki);
            const ao = Bt(se, oe, h.transform, hi),
              Za = s.aH(ae, rt, d, g),
              Xo = ae.getProjectionData({
                overscaledTileID: et,
                applyGlobeMatrix: !F,
                applyTerrainMatrix: !0
              }),
              Cs = ge && at.hasTextData(),
              Yo = i.layout.get("icon-text-fit") !== "none" && Cs && at.hasIconData();
            if (fe) {
              const di = h.style.map.terrain ? (Ai, $n) => h.style.map.terrain.getElevation(et, Ai, $n) : null,
                li = i.layout.get("text-rotation-alignment") === "map";
              ar(at, h, u, Ki, Wo, se, k, li, et.toUnwrapped(), ae.width, ae.height, Za, di)
            }
            const na = u && ge || Yo,
              Ji = fe || na ? iu : se ? Ki : h.transform.clipSpaceToPixelsMatrix,
              oo = Pt && i.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let wo;
            wo = Pt ? at.iconsInText ? Qa(gr.kind, on, xe, se, fe, na, h, Ji, ao, Za, Qn, Mi, nt) : $s(gr.kind, on, xe, se, fe, na, h, Ji, ao, Za, u, Qn, 0, nt) : Xc(gr.kind, on, xe, se, fe, na, h, Ji, ao, Za, u, Qn, nt);
            const ol = {
              program: En,
              buffers: Gt,
              uniformValues: wo,
              projectionData: Xo,
              atlasTexture: qn,
              atlasTextureIcon: Xn,
              atlasInterpolation: gi,
              atlasInterpolationIcon: Wn,
              isSDF: Pt,
              hasHalo: oo
            };
            if (pe && at.canOverlap) {
              be = !0;
              const di = Gt.segments.get();
              for (const li of di) Fe.push({
                segments: new s.aQ([li]),
                sortKey: li.sortKey,
                state: ol,
                terrainData: On
              })
            } else Fe.push({
              segments: Gt.segments,
              sortKey: 0,
              state: ol,
              terrainData: On
            })
          }
          be && Fe.sort(((et, rt) => et.sortKey - rt.sortKey));
          for (const et of Fe) {
            const rt = et.state;
            if ($.activeTexture.set(J.TEXTURE0), rt.atlasTexture.bind(rt.atlasInterpolation, J.CLAMP_TO_EDGE), rt.atlasTextureIcon && ($.activeTexture.set(J.TEXTURE1), rt.atlasTextureIcon && rt.atlasTextureIcon.bind(rt.atlasInterpolationIcon, J.CLAMP_TO_EDGE)), rt.isSDF) {
              const at = rt.uniformValues;
              rt.hasHalo && (at.u_is_halo = 1, Zl(rt.buffers, et.segments, i, h, rt.program, Pe, z, V, at, rt.projectionData, et.terrainData)), at.u_is_halo = 0
            }
            Zl(rt.buffers, et.segments, i, h, rt.program, Pe, z, V, rt.uniformValues, rt.projectionData, et.terrainData)
          }
        }

        function Zl(h, e, i, l, u, d, g, T, S, k, z) {
          const V = l.context;
          u.draw(V, V.gl.TRIANGLES, d, g, T, ln.backCCW, S, z, k, i.id, h.layoutVertexBuffer, h.indexBuffer, e, i.paint, l.transform.zoom, h.programConfigurations.get(i.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
        }

        function vf(h, e, i, l, u) {
          const d = h.context,
            g = d.gl,
            T = yn.disabled,
            S = new mn([g.ONE, g.ONE], s.bi.transparent, [!0, !0, !0, !0]),
            k = e.getBucket(i);
          if (!k) return;
          const z = l.key;
          let V = i.heatmapFbos.get(z);
          V || (V = xd(d, e.tileSize, e.tileSize), i.heatmapFbos.set(z, V)), d.bindFramebuffer.set(V.framebuffer), d.viewport.set([0, 0, e.tileSize, e.tileSize]), d.clear({
            color: s.bi.transparent
          });
          const F = k.programConfigurations.get(i.id),
            $ = h.useProgram("heatmap", F, !u),
            J = h.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            ae = h.style.map.terrain.getTerrainData(l);
          $.draw(d, g.TRIANGLES, tn.disabled, T, S, ln.disabled, Gc(e, h.transform.zoom, i.paint.get("heatmap-intensity"), 1), ae, J, i.id, k.layoutVertexBuffer, k.indexBuffer, k.segments, i.paint, h.transform.zoom, F)
        }

        function Ys(h, e, i, l, u) {
          const d = h.context,
            g = d.gl,
            T = h.transform;
          d.setColorMode(h.colorModeForRenderPass());
          const S = au(d, e),
            k = i.key,
            z = e.heatmapFbos.get(k);
          if (!z) return;
          d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, z.colorAttachment.get()), d.activeTexture.set(g.TEXTURE1), S.bind(g.LINEAR, g.CLAMP_TO_EDGE);
          const V = T.getProjectionData({
            overscaledTileID: i,
            applyTerrainMatrix: u,
            applyGlobeMatrix: !l
          });
          h.useProgram("heatmapTexture").draw(d, g.TRIANGLES, tn.disabled, yn.disabled, h.colorModeForRenderPass(), ln.disabled, $c(h, e, 0, 1), null, V, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, T.zoom), z.destroy(), e.heatmapFbos.delete(k)
        }

        function xd(h, e, i) {
          var l, u;
          const d = h.gl,
            g = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, g), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
          const T = (l = h.HALF_FLOAT) !== null && l !== void 0 ? l : d.UNSIGNED_BYTE,
            S = (u = h.RGBA16F) !== null && u !== void 0 ? u : d.RGBA;
          d.texImage2D(d.TEXTURE_2D, 0, S, e, i, 0, d.RGBA, T, null);
          const k = h.createFramebuffer(e, i, !1, !1);
          return k.colorAttachment.set(g), k
        }

        function au(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture
        }

        function Ks(h, e, i, l, u, d, g, T) {
          let S = 256;
          if (u.stepInterpolant) {
            const k = e.getSource().maxzoom,
              z = g.canonical.z === k ? Math.ceil(1 << h.transform.maxZoom - g.canonical.z) : 1;
            S = s.ai(s.c7(d.maxLineLength / s.a3 * 1024 * z), 256, i.maxTextureSize)
          }
          return T.gradient = s.c8({
            expression: u.gradientExpression(),
            evaluationKey: "lineProgress",
            resolution: S,
            image: T.gradient || void 0,
            clips: d.lineClipsArray
          }), T.texture ? T.texture.update(T.gradient) : T.texture = new s.T(i, T.gradient, l.RGBA), T.version = u.gradientVersion, T.texture
        }

        function ou(h, e, i, l, u) {
          h.activeTexture.set(e.TEXTURE0), i.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), l.updatePaintBuffers(u)
        }

        function bd(h, e, i, l, u, d) {
          (u || h.lineAtlas.dirty) && (e.activeTexture.set(i.TEXTURE0), h.lineAtlas.bind(e)), l.updatePaintBuffers(d)
        }

        function wd(h, e, i, l, u, d, g) {
          const T = d.gradients[u.id];
          let S = T.texture;
          u.gradientVersion !== T.version && (S = Ks(h, e, i, l, u, d, g, T)), i.activeTexture.set(l.TEXTURE0), S.bind(u.stepInterpolant ? l.NEAREST : l.LINEAR, l.CLAMP_TO_EDGE)
        }

        function Gl(h, e, i, l, u, d, g, T, S) {
          const k = d.gradients[u.id];
          let z = k.texture;
          u.gradientVersion !== k.version && (z = Ks(h, e, i, l, u, d, g, k)), i.activeTexture.set(l.TEXTURE0), z.bind(u.stepInterpolant ? l.NEAREST : l.LINEAR, l.CLAMP_TO_EDGE), i.activeTexture.set(l.TEXTURE1), h.lineAtlas.bind(i), T.updatePaintBuffers(S)
        }

        function $l(h, e, i, l, u) {
          if (!i || !l || !l.imageAtlas) return;
          const d = l.imageAtlas.patternPositions;
          let g = d[i.to.toString()],
            T = d[i.from.toString()];
          if (!g && T && (g = T), !T && g && (T = g), !g || !T) {
            const S = u.getPaintProperty(e);
            g = d[S], T = d[S]
          }
          g && T && h.setConstantPatternPositions(g, T)
        }

        function Td(h, e, i, l, u, d, g, T) {
          const S = h.context.gl,
            k = "fill-pattern",
            z = i.paint.get(k),
            V = z && z.constantOr(1),
            F = i.getCrossfadeParameters();
          let $, J, ae, oe, se;
          const fe = h.transform,
            xe = i.paint.get("fill-translate"),
            pe = i.paint.get("fill-translate-anchor");
          g ? (J = V && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", $ = S.LINES) : (J = V ? "fillPattern" : "fill", $ = S.TRIANGLES);
          const be = z.constantOr(null);
          for (const Pe of l) {
            const ge = e.getTile(Pe);
            if (V && !ge.patternsLoaded()) continue;
            const Fe = ge.getBucket(i);
            if (!Fe) continue;
            const nt = Fe.programConfigurations.get(i.id),
              et = h.useProgram(J, nt),
              rt = h.style.map.terrain && h.style.map.terrain.getTerrainData(Pe);
            V && (h.context.activeTexture.set(S.TEXTURE0), ge.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE), nt.updatePaintBuffers(F)), $l(nt, k, be, ge, i);
            const at = fe.getProjectionData({
                overscaledTileID: Pe,
                applyGlobeMatrix: !T,
                applyTerrainMatrix: !0
              }),
              Gt = s.aH(fe, ge, xe, pe);
            if (g) {
              oe = Fe.indexBuffer2, se = Fe.segments2;
              const Pt = [S.drawingBufferWidth, S.drawingBufferHeight];
              ae = J === "fillOutlinePattern" && V ? nd(h, F, ge, Pt, Gt) : of(Pt, Gt)
            } else oe = Fe.indexBuffer, se = Fe.segments, ae = V ? Ro(h, F, ge, Gt) : {
              u_fill_translate: Gt
            };
            const Ht = h.stencilModeForClipping(Pe);
            et.draw(h.context, $, u, Ht, d, ln.backCCW, ae, rt, at, i.id, Fe.layoutVertexBuffer, oe, se, i.paint, h.transform.zoom, nt)
          }
        }

        function Hl(h, e, i, l, u, d, g, T) {
          const S = h.context,
            k = S.gl,
            z = "fill-extrusion-pattern",
            V = i.paint.get(z),
            F = V.constantOr(1),
            $ = i.getCrossfadeParameters(),
            J = i.paint.get("fill-extrusion-opacity"),
            ae = V.constantOr(null),
            oe = h.transform;
          for (const se of l) {
            const fe = e.getTile(se),
              xe = fe.getBucket(i);
            if (!xe) continue;
            const pe = h.style.map.terrain && h.style.map.terrain.getTerrainData(se),
              be = xe.programConfigurations.get(i.id),
              Pe = h.useProgram(F ? "fillExtrusionPattern" : "fillExtrusion", be);
            F && (h.context.activeTexture.set(k.TEXTURE0), fe.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), be.updatePaintBuffers($));
            const ge = oe.getProjectionData({
              overscaledTileID: se,
              applyGlobeMatrix: !T,
              applyTerrainMatrix: !0
            });
            $l(be, z, ae, fe, i);
            const Fe = s.aH(oe, fe, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),
              nt = i.paint.get("fill-extrusion-vertical-gradient"),
              et = F ? af(h, nt, J, Fe, se, $, fe) : Gs(h, nt, J, Fe);
            Pe.draw(S, S.gl.TRIANGLES, u, d, g, ln.backCCW, et, pe, ge, i.id, xe.layoutVertexBuffer, xe.indexBuffer, xe.segments, i.paint, h.transform.zoom, be, h.style.map.terrain && xe.centroidVertexBuffer)
          }
        }

        function Kn(h, e, i, l, u, d, g, T, S) {
          var k;
          const z = h.style.projection,
            V = h.context,
            F = h.transform,
            $ = V.gl,
            J = [`#define NUM_ILLUMINATION_SOURCES ${i.paint.get("hillshade-highlight-color").values.length}`],
            ae = h.useProgram("hillshade", null, !1, J),
            oe = !h.options.moving;
          for (const se of l) {
            const fe = e.getTile(se),
              xe = fe.fbo;
            if (!xe) continue;
            const pe = z.getMeshFromTileID(V, se.canonical, T, !0, "raster"),
              be = (k = h.style.map.terrain) === null || k === void 0 ? void 0 : k.getTerrainData(se);
            V.activeTexture.set($.TEXTURE0), $.bindTexture($.TEXTURE_2D, xe.colorAttachment.get());
            const Pe = F.getProjectionData({
              overscaledTileID: se,
              aligned: oe,
              applyGlobeMatrix: !S,
              applyTerrainMatrix: !0
            });
            ae.draw(V, $.TRIANGLES, d, u[se.overscaledZ], g, ln.backCCW, ad(h, fe, i), be, Pe, i.id, pe.vertexBuffer, pe.indexBuffer, pe.segments)
          }
        }

        function eo(h, e, i, l, u, d, g, T, S) {
          var k;
          const z = h.style.projection,
            V = h.context,
            F = h.transform,
            $ = V.gl,
            J = h.useProgram("colorRelief"),
            ae = !h.options.moving;
          let oe = !0,
            se = 0;
          for (const fe of l) {
            const xe = e.getTile(fe),
              pe = xe.dem;
            if (oe) {
              const et = $.getParameter($.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: rt,
                  colorTexture: at
                } = i.getColorRampTextures(V, et, pe.getUnpackVector());
              V.activeTexture.set($.TEXTURE1), rt.bind($.NEAREST, $.CLAMP_TO_EDGE), V.activeTexture.set($.TEXTURE4), at.bind($.LINEAR, $.CLAMP_TO_EDGE), oe = !1, se = rt.size[0]
            }
            if (!pe || !pe.data) continue;
            const be = pe.stride,
              Pe = pe.getPixels();
            if (V.activeTexture.set($.TEXTURE0), V.pixelStoreUnpackPremultiplyAlpha.set(!1), xe.demTexture = xe.demTexture || h.getTileTexture(be), xe.demTexture) {
              const et = xe.demTexture;
              et.update(Pe, {
                premultiply: !1
              }), et.bind($.LINEAR, $.CLAMP_TO_EDGE)
            } else xe.demTexture = new s.T(V, Pe, $.RGBA, {
              premultiply: !1
            }), xe.demTexture.bind($.LINEAR, $.CLAMP_TO_EDGE);
            const ge = z.getMeshFromTileID(V, fe.canonical, T, !0, "raster"),
              Fe = (k = h.style.map.terrain) === null || k === void 0 ? void 0 : k.getTerrainData(fe),
              nt = F.getProjectionData({
                overscaledTileID: fe,
                aligned: ae,
                applyGlobeMatrix: !S,
                applyTerrainMatrix: !0
              });
            J.draw(V, $.TRIANGLES, d, u[fe.overscaledZ], g, ln.backCCW, sd(i, xe.dem, se), Fe, nt, i.id, ge.vertexBuffer, ge.indexBuffer, ge.segments)
          }
        }
        const ta = [new s.P(0, 0), new s.P(s.a3, 0), new s.P(s.a3, s.a3), new s.P(0, s.a3)];

        function vs(h, e, i, l, u, d, g, T, S = !1, k = !1) {
          const z = l[l.length - 1].overscaledZ,
            V = h.context,
            F = V.gl,
            $ = h.useProgram("raster"),
            J = h.transform,
            ae = h.style.projection,
            oe = h.colorModeForRenderPass(),
            se = !h.options.moving,
            fe = i.paint.get("raster-opacity"),
            xe = i.paint.get("raster-resampling"),
            pe = i.paint.get("raster-fade-duration"),
            be = !!h.style.map.terrain;
          for (const Pe of l) {
            const ge = h.getDepthModeForSublayer(Pe.overscaledZ - z, fe === 1 ? tn.ReadWrite : tn.ReadOnly, F.LESS),
              Fe = e.getTile(Pe),
              nt = xe === "nearest" ? F.NEAREST : F.LINEAR;
            V.activeTexture.set(F.TEXTURE0), Fe.texture.bind(nt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), V.activeTexture.set(F.TEXTURE1);
            const {
              parentTile: et,
              parentScaleBy: rt,
              parentTopLeft: at,
              fadeValues: Gt
            } = Wl(Fe, e, pe, be);
            Fe.fadeOpacity = Gt.tileOpacity, et ? (et.fadeOpacity = Gt.parentTileOpacity, et.texture.bind(nt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST)) : Fe.texture.bind(nt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), Fe.texture.useMipmap && V.extTextureFilterAnisotropic && h.transform.pitch > 20 && F.texParameterf(F.TEXTURE_2D, V.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, V.extTextureFilterAnisotropicMax);
            const Ht = h.style.map.terrain && h.style.map.terrain.getTerrainData(Pe),
              Pt = J.getProjectionData({
                overscaledTileID: Pe,
                aligned: se,
                applyGlobeMatrix: !k,
                applyTerrainMatrix: !0
              }),
              gr = ld(at, rt, Gt.fadeMix, i, T),
              Qr = ae.getMeshFromTileID(V, Pe.canonical, d, g, "raster");
            $.draw(V, F.TRIANGLES, ge, u ? u[Pe.overscaledZ] : yn.disabled, oe, S ? ln.frontCCW : ln.backCCW, gr, Ht, Pt, i.id, Qr.vertexBuffer, Qr.indexBuffer, Qr.segments)
          }
        }

        function Wl(h, e, i, l) {
          const u = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: {
                opacity: 1,
                mix: 0
              }
            }
          };
          if (i === 0 || l) return u;
          if (h.fadingParentID) {
            const d = e.getLoadedTile(h.fadingParentID);
            if (!d) return u;
            const g = Math.pow(2, d.tileID.overscaledZ - h.tileID.overscaledZ),
              T = [h.tileID.canonical.x * g % 1, h.tileID.canonical.y * g % 1],
              S = (function(k, z, V) {
                const F = ne(),
                  $ = (F - z.timeAdded) / V,
                  J = k.fadingDirection === H.Incoming,
                  ae = s.ai((F - k.timeAdded) / V, 0, 1),
                  oe = s.ai(1 - $, 0, 1),
                  se = J ? ae : oe;
                return {
                  tileOpacity: se,
                  parentTileOpacity: J ? oe : ae,
                  fadeMix: {
                    opacity: 1,
                    mix: 1 - se
                  }
                }
              })(h, d, i);
            return {
              parentTile: d,
              parentScaleBy: g,
              parentTopLeft: T,
              fadeValues: S
            }
          }
          if (h.selfFading) {
            const d = (function(g, T) {
              const S = (ne() - g.timeAdded) / T,
                k = s.ai(S, 0, 1);
              return {
                tileOpacity: k,
                fadeMix: {
                  opacity: k,
                  mix: 0
                }
              }
            })(h, i);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: d
            }
          }
          return u
        }
        const Sd = new s.bi(1, 0, 0, 1),
          ys = new s.bi(0, 1, 0, 1),
          su = new s.bi(0, 0, 1, 1),
          Js = new s.bi(1, 0, 1, 1),
          lu = new s.bi(0, 1, 1, 1);

        function cu(h, e, i, l) {
          Qs(h, 0, e + i / 2, h.transform.width, i, l)
        }

        function uu(h, e, i, l) {
          Qs(h, e - i / 2, 0, i, h.transform.height, l)
        }

        function Qs(h, e, i, l, u, d) {
          const g = h.context,
            T = g.gl;
          T.enable(T.SCISSOR_TEST), T.scissor(e * h.pixelRatio, i * h.pixelRatio, l * h.pixelRatio, u * h.pixelRatio), g.clear({
            color: d
          }), T.disable(T.SCISSOR_TEST)
        }

        function Cd(h, e, i) {
          const l = h.context,
            u = l.gl,
            d = h.useProgram("debug"),
            g = tn.disabled,
            T = yn.disabled,
            S = h.colorModeForRenderPass(),
            k = "$debug",
            z = h.style.map.terrain && h.style.map.terrain.getTerrainData(i);
          l.activeTexture.set(u.TEXTURE0);
          const V = e.getTileByID(i.key).latestRawTileData,
            F = Math.floor((V && V.byteLength || 0) / 1024),
            $ = e.getTile(i).tileSize,
            J = 512 / Math.min($, 512) * (i.overscaledZ / h.transform.zoom) * .5;
          let ae = i.canonical.toString();
          i.overscaledZ !== i.canonical.z && (ae += ` => ${i.overscaledZ}`), (function(se, fe) {
            se.initDebugOverlayCanvas();
            const xe = se.debugOverlayCanvas,
              pe = se.context.gl,
              be = se.debugOverlayCanvas.getContext("2d");
            be.clearRect(0, 0, xe.width, xe.height), be.shadowColor = "white", be.shadowBlur = 2, be.lineWidth = 1.5, be.strokeStyle = "white", be.textBaseline = "top", be.font = "bold 36px Open Sans, sans-serif", be.fillText(fe, 5, 5), be.strokeText(fe, 5, 5), se.debugOverlayTexture.update(xe), se.debugOverlayTexture.bind(pe.LINEAR, pe.CLAMP_TO_EDGE)
          })(h, `${ae} ${F}kB`);
          const oe = h.transform.getProjectionData({
            overscaledTileID: i,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          d.draw(l, u.TRIANGLES, g, T, mn.alphaBlended, ln.disabled, Zc(s.bi.transparent, J), null, oe, k, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), d.draw(l, u.LINE_STRIP, g, T, S, ln.disabled, Zc(s.bi.red), z, oe, k, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
        }

        function hu(h, e, i, l) {
          const {
            isRenderingGlobe: u
          } = l, d = h.context, g = d.gl, T = h.transform, S = h.colorModeForRenderPass(), k = h.getDepthModeFor3D(), z = h.useProgram("terrain");
          d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
          for (const V of i) {
            const F = e.getTerrainMesh(V.tileID),
              $ = h.renderToTexture.getTexture(V),
              J = e.getTerrainData(V.tileID);
            d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, $.texture);
            const ae = e.getMeshFrameDelta(T.zoom),
              oe = T.calculateFogMatrix(V.tileID.toUnwrapped()),
              se = nf(ae, oe, h.style.sky, T.pitch, u),
              fe = T.getProjectionData({
                overscaledTileID: V.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            z.draw(d, g.TRIANGLES, k, yn.disabled, S, ln.backCCW, se, J, fe, "terrain", F.vertexBuffer, F.indexBuffer, F.segments)
          }
        }

        function bo(h, e) {
          if (!e.mesh) {
            const i = new s.aP;
            i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1);
            const l = new s.aR;
            l.emplaceBack(0, 1, 2), l.emplaceBack(0, 2, 3), e.mesh = new ri(h.createVertexBuffer(i, jn.members), h.createIndexBuffer(l), s.aQ.simpleSegment(0, 0, i.length, l.length))
          }
          return e.mesh
        }
        class Pd {
          constructor(e, i) {
            this.context = new jl(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: s.am(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = rn.maxUnderzooming + rn.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new gn
          }
          resize(e, i, l) {
            if (this.width = Math.floor(e * l), this.height = Math.floor(i * l), this.pixelRatio = l, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const u of this.style._order) this.style._layers[u].resize()
          }
          setup() {
            const e = this.context,
              i = new s.aP;
            i.emplaceBack(0, 0), i.emplaceBack(s.a3, 0), i.emplaceBack(0, s.a3), i.emplaceBack(s.a3, s.a3), this.tileExtentBuffer = e.createVertexBuffer(i, jn.members), this.tileExtentSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const l = new s.aP;
            l.emplaceBack(0, 0), l.emplaceBack(s.a3, 0), l.emplaceBack(0, s.a3), l.emplaceBack(s.a3, s.a3), this.debugBuffer = e.createVertexBuffer(l, jn.members), this.debugSegments = s.aQ.simpleSegment(0, 0, 4, 5);
            const u = new s.ca;
            u.emplaceBack(0, 0, 0, 0), u.emplaceBack(s.a3, 0, s.a3, 0), u.emplaceBack(0, s.a3, 0, s.a3), u.emplaceBack(s.a3, s.a3, s.a3, s.a3), this.rasterBoundsBuffer = e.createVertexBuffer(u, Vc.members), this.rasterBoundsSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const d = new s.aP;
            d.emplaceBack(0, 0), d.emplaceBack(s.a3, 0), d.emplaceBack(0, s.a3), d.emplaceBack(s.a3, s.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, jn.members), this.rasterBoundsSegmentsPosOnly = s.aQ.simpleSegment(0, 0, 4, 5);
            const g = new s.aP;
            g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(g, jn.members), this.viewportSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const T = new s.cb;
            T.emplaceBack(0), T.emplaceBack(1), T.emplaceBack(3), T.emplaceBack(2), T.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(T);
            const S = new s.aR;
            S.emplaceBack(1, 0, 2), S.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(S);
            const k = this.context.gl;
            this.stencilClearMode = new yn({
              func: k.ALWAYS,
              mask: 0
            }, 0, 255, k.ZERO, k.ZERO, k.ZERO), this.tileExtentMesh = new ri(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              i = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const l = s.M();
            s.c0(l, 0, this.width, this.height, 0, 0, 1), s.O(l, l, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
            const u = {
              mainMatrix: l,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: l
            };
            this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, tn.disabled, this.stencilClearMode, mn.disabled, ln.disabled, null, null, u, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, i, l) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + i.length > 256 && this.clearStencil();
            const u = this.context;
            u.setColorMode(mn.disabled), u.setDepthMode(tn.disabled);
            const d = {};
            for (const g of i) d[g.key] = this.nextStencilID++;
            this._renderTileMasks(d, i, l, !0), this._renderTileMasks(d, i, l, !1), this._tileClippingMaskIDs = d
          }
          _renderTileMasks(e, i, l, u) {
            const d = this.context,
              g = d.gl,
              T = this.style.projection,
              S = this.transform,
              k = this.useProgram("clippingMask");
            for (const z of i) {
              const V = e[z.key],
                F = this.style.map.terrain && this.style.map.terrain.getTerrainData(z),
                $ = T.getMeshFromTileID(this.context, z.canonical, u, !0, "stencil"),
                J = S.getProjectionData({
                  overscaledTileID: z,
                  applyGlobeMatrix: !l,
                  applyTerrainMatrix: !0
                });
              k.draw(d, g.TRIANGLES, tn.disabled, new yn({
                func: g.ALWAYS,
                mask: 0
              }, V, 255, g.KEEP, g.KEEP, g.REPLACE), mn.disabled, l ? ln.disabled : ln.backCCW, null, F, J, "$clipping", $.vertexBuffer, $.indexBuffer, $.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              i = e.gl,
              l = this.style.projection,
              u = this.transform,
              d = this.useProgram("depth"),
              g = this.getDepthModeFor3D(),
              T = qr(u, {
                tileSize: u.tileSize
              });
            for (const S of T) {
              const k = this.style.map.terrain && this.style.map.terrain.getTerrainData(S),
                z = l.getMeshFromTileID(this.context, S.canonical, !0, !0, "raster"),
                V = u.getProjectionData({
                  overscaledTileID: S,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              d.draw(e, i.TRIANGLES, g, yn.disabled, mn.disabled, ln.backCCW, null, k, V, "$clipping", z.vertexBuffer, z.indexBuffer, z.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              i = this.context.gl;
            return new yn({
              func: i.NOTEQUAL,
              mask: 255
            }, e, 255, i.KEEP, i.KEEP, i.REPLACE)
          }
          stencilModeForClipping(e) {
            const i = this.context.gl;
            return new yn({
              func: i.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, i.KEEP, i.KEEP, i.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const i = this.context.gl,
              l = e.sort(((g, T) => T.overscaledZ - g.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              d = l[0].overscaledZ - u + 1;
            if (d > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + d > 256 && this.clearStencil();
              const g = {};
              for (let T = 0; T < d; T++) g[T + u] = new yn({
                func: i.GEQUAL,
                mask: 255
              }, T + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID += d, [g, l]
            }
            return [{
              [u]: yn.disabled
            }, l]
          }
          stencilConfigForOverlapTwoPass(e) {
            const i = this.context.gl,
              l = e.sort(((g, T) => T.overscaledZ - g.overscaledZ)),
              u = l[l.length - 1].overscaledZ,
              d = l[0].overscaledZ - u + 1;
            if (this.clearStencil(), d > 1) {
              const g = {},
                T = {};
              for (let S = 0; S < d; S++) g[S + u] = new yn({
                func: i.GREATER,
                mask: 255
              }, d + 1 + S, 255, i.KEEP, i.KEEP, i.REPLACE), T[S + u] = new yn({
                func: i.GREATER,
                mask: 255
              }, 1 + S, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID = 2 * d + 1, [g, T, l]
            }
            return this.nextStencilID = 3, [{
              [u]: new yn({
                func: i.GREATER,
                mask: 255
              }, 2, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, {
              [u]: new yn({
                func: i.GREATER,
                mask: 255
              }, 1, 255, i.KEEP, i.KEEP, i.REPLACE)
            }, l]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new mn([e.CONSTANT_COLOR, e.ONE], new s.bi(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? mn.unblended : mn.alphaBlended
          }
          getDepthModeForSublayer(e, i, l) {
            if (!this.opaquePassEnabledForLayer()) return tn.disabled;
            const u = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new tn(l || this.context.gl.LEQUAL, i, [u, u])
          }
          getDepthModeFor3D() {
            return new tn(this.context.gl.LEQUAL, tn.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, i) {
            var l, u;
            this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(ne()), this.imageManager.beginFrame();
            const d = this.style._order,
              g = this.style.tileManagers,
              T = {},
              S = {},
              k = {},
              z = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((l = e.projection) === null || l === void 0 ? void 0 : l.transitionState) > 0
              };
            for (const F in g) {
              const $ = g[F];
              $.used && $.prepare(this.context), T[F] = $.getVisibleCoordinates(!1), S[F] = T[F].slice().reverse(), k[F] = $.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let F = 0; F < d.length; F++)
              if (this.style._layers[d[F]].is3D()) {
                this.opaquePassCutoff = F;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const F of d) {
              const $ = this.style._layers[F];
              if (!$.hasOffscreenPass() || $.isHidden(this.transform.zoom)) continue;
              const J = S[$.source];
              ($.type === "custom" || J.length) && this.renderLayer(this, g[$.source], $, J, z)
            }
            if ((u = this.style.projection) === null || u === void 0 || u.updateGPUdependent({
                context: this.context,
                useProgram: F => this.useProgram(F)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: i.showOverdrawInspector ? s.bi.black : s.bi.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(F, $) {
                const J = F.context,
                  ae = J.gl,
                  oe = ((Pe, ge, Fe) => {
                    const nt = Math.cos(ge.rollInRadians),
                      et = Math.sin(ge.rollInRadians),
                      rt = Ze(ge),
                      at = ge.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Pe.properties.get("sky-color"),
                      u_horizon_color: Pe.properties.get("horizon-color"),
                      u_horizon: [(ge.width / 2 - rt * et) * Fe, (ge.height / 2 + rt * nt) * Fe],
                      u_horizon_normal: [-et, nt],
                      u_sky_horizon_blend: Pe.properties.get("sky-horizon-blend") * ge.height / 2 * Fe,
                      u_sky_blend: at
                    }
                  })($, F.style.map.transform, F.pixelRatio),
                  se = new tn(ae.LEQUAL, tn.ReadWrite, [0, 1]),
                  fe = yn.disabled,
                  xe = F.colorModeForRenderPass(),
                  pe = F.useProgram("sky"),
                  be = bo(J, $);
                pe.draw(J, ae.TRIANGLES, se, fe, xe, ln.disabled, oe, null, void 0, "sky", be.vertexBuffer, be.indexBuffer, be.segments)
              })(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const F = this.style._layers[d[this.currentLayer]],
                  $ = g[F.source],
                  J = T[F.source];
                this._renderTileClippingMasks(F, J, !1), this.renderLayer(this, $, F, J, z)
              }
            this.renderPass = "translucent";
            let V = !1;
            for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
              const F = this.style._layers[d[this.currentLayer]],
                $ = g[F.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(F, z)) continue;
              this.opaquePassEnabledForLayer() || V || (V = !0, z.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const J = (F.type === "symbol" ? k : S)[F.source];
              this._renderTileClippingMasks(F, T[F.source], !!this.renderToTexture), this.renderLayer(this, $, F, J, z)
            }
            if (z.isRenderingGlobe && (function(F, $, J) {
                const ae = F.context,
                  oe = ae.gl,
                  se = F.useProgram("atmosphere"),
                  fe = new tn(oe.LEQUAL, tn.ReadOnly, [0, 1]),
                  xe = F.transform,
                  pe = (function(at, Gt) {
                    const Ht = at.properties.get("position"),
                      Pt = [-Ht.x, -Ht.y, -Ht.z],
                      gr = s.am(new Float64Array(16));
                    return at.properties.get("anchor") === "map" && (s.b9(gr, gr, Gt.rollInRadians), s.ba(gr, gr, -Gt.pitchInRadians), s.b9(gr, gr, Gt.bearingInRadians), s.ba(gr, gr, Gt.center.lat * Math.PI / 180), s.bC(gr, gr, -Gt.center.lng * Math.PI / 180)), s.c9(Pt, Pt, gr), Pt
                  })(J, F.transform),
                  be = xe.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Pe = $.properties.get("atmosphere-blend") * be.projectionTransition;
                if (Pe === 0) return;
                const ge = js(xe.worldSize, xe.center.lat),
                  Fe = xe.inverseProjectionMatrix,
                  nt = new Float64Array(4);
                nt[3] = 1, s.aA(nt, nt, xe.modelViewProjectionMatrix), nt[0] /= nt[3], nt[1] /= nt[3], nt[2] /= nt[3], nt[3] = 1, s.aA(nt, nt, Fe), nt[0] /= nt[3], nt[1] /= nt[3], nt[2] /= nt[3], nt[3] = 1;
                const et = ((at, Gt, Ht, Pt, gr) => ({
                    u_sun_pos: at,
                    u_atmosphere_blend: Gt,
                    u_globe_position: Ht,
                    u_globe_radius: Pt,
                    u_inv_proj_matrix: gr
                  }))(pe, Pe, [nt[0], nt[1], nt[2]], ge, Fe),
                  rt = bo(ae, $);
                se.draw(ae, oe.TRIANGLES, fe, yn.disabled, mn.alphaBlended, ln.disabled, et, null, null, "atmosphere", rt.vertexBuffer, rt.indexBuffer, rt.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const F = (function($, J) {
                let ae = null;
                const oe = Object.values($._layers).flatMap((pe => pe.source && !pe.isHidden(J) ? [$.tileManagers[pe.source]] : [])),
                  se = oe.filter((pe => pe.getSource().type === "vector")),
                  fe = oe.filter((pe => pe.getSource().type !== "vector")),
                  xe = pe => {
                    (!ae || ae.getSource().maxzoom < pe.getSource().maxzoom) && (ae = pe)
                  };
                return se.forEach((pe => xe(pe))), ae || fe.forEach((pe => xe(pe))), ae
              })(this.style, this.transform.zoom);
              F && (function($, J, ae) {
                for (let oe = 0; oe < ae.length; oe++) Cd($, J, ae[oe])
              })(this, F, F.getVisibleCoordinates())
            }
            this.options.showPadding && (function(F) {
              const $ = F.transform.padding;
              cu(F, F.transform.height - ($.top || 0), 3, Sd), cu(F, $.bottom || 0, 3, ys), uu(F, $.left || 0, 3, su), uu(F, F.transform.width - ($.right || 0), 3, Js);
              const J = F.transform.centerPoint;
              (function(ae, oe, se, fe) {
                Qs(ae, oe - 1, se - 10, 2, 20, fe), Qs(ae, oe - 10, se - 1, 20, 2, fe)
              })(F, J.x, F.transform.height - J.y, lu)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i = this.terrainFacilitator.matrix,
              l = this.transform.modelViewProjectionMatrix;
            let u = this.terrainFacilitator.dirty;
            u || (u = e ? !s.cc(i, l) : !s.cd(i, l)), u || (u = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), u && (s.ce(i, l), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(d, g) {
              const T = d.context,
                S = T.gl,
                k = d.transform,
                z = mn.unblended,
                V = new tn(S.LEQUAL, tn.ReadWrite, [0, 1]),
                F = g.tileManager.getRenderableTiles(),
                $ = d.useProgram("terrainDepth");
              T.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), T.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), T.clear({
                color: s.bi.transparent,
                depth: 1
              });
              for (const J of F) {
                const ae = g.getTerrainMesh(J.tileID),
                  oe = g.getTerrainData(J.tileID),
                  se = k.getProjectionData({
                    overscaledTileID: J.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  fe = {
                    u_ele_delta: g.getMeshFrameDelta(k.zoom)
                  };
                $.draw(T, S.TRIANGLES, V, yn.disabled, z, ln.backCCW, fe, oe, se, "terrain", ae.vertexBuffer, ae.indexBuffer, ae.segments)
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain), (function(d, g) {
              const T = d.context,
                S = T.gl,
                k = d.transform,
                z = mn.unblended,
                V = new tn(S.LEQUAL, tn.ReadWrite, [0, 1]),
                F = g.getCoordsTexture(),
                $ = g.tileManager.getRenderableTiles(),
                J = d.useProgram("terrainCoords");
              T.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), T.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), T.clear({
                color: s.bi.transparent,
                depth: 1
              }), g.coordsIndex = [];
              for (const ae of $) {
                const oe = g.getTerrainMesh(ae.tileID),
                  se = g.getTerrainData(ae.tileID);
                T.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, F.texture);
                const fe = {
                    u_terrain_coords_id: (255 - g.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: g.getMeshFrameDelta(k.zoom)
                  },
                  xe = k.getProjectionData({
                    overscaledTileID: ae.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                J.draw(T, S.TRIANGLES, V, yn.disabled, z, ln.backCCW, fe, se, xe, "terrain", oe.vertexBuffer, oe.indexBuffer, oe.segments), g.coordsIndex.push(ae.tileID.key)
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, i, l, u, d) {
            l.isHidden(this.transform.zoom) || (l.type === "background" || l.type === "custom" || (u || []).length) && (this.id = l.id, s.cf(l) ? (function(g, T, S, k, z, V) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = V, $ = yn.disabled, J = g.colorModeForRenderPass();
              (S._unevaluatedLayout.hasValue("text-variable-anchor") || S._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(ae, oe, se, fe, xe, pe, be, Pe, ge) {
                const Fe = oe.transform,
                  nt = oe.style.map.terrain,
                  et = xe === "map",
                  rt = pe === "map";
                for (const at of ae) {
                  const Gt = fe.getTile(at),
                    Ht = Gt.getBucket(se);
                  if (!Ht || !Ht.text || !Ht.text.segments.get().length) continue;
                  const Pt = s.ar(Ht.textSizeData, Fe.zoom),
                    gr = s.aG(Gt, 1, oe.transform.zoom),
                    Qr = Pn(et, oe.transform, gr),
                    En = se.layout.get("icon-text-fit") !== "none" && Ht.hasIconData();
                  if (Pt) {
                    const on = Math.pow(2, Fe.zoom - Gt.tileID.overscaledZ),
                      On = nt ? (Qn, qn) => nt.getElevation(at, Qn, qn) : null;
                    ql(Ht, et, rt, ge, Fe, Qr, on, Pt, En, s.aH(Fe, Gt, be, Pe), at.toUnwrapped(), On)
                  }
                }
              })(k, g, S, T, S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), z), S.paint.get("icon-opacity").constantOr(1) !== 0 && qo(g, T, S, k, !1, S.paint.get("icon-translate"), S.paint.get("icon-translate-anchor"), S.layout.get("icon-rotation-alignment"), S.layout.get("icon-pitch-alignment"), S.layout.get("icon-keep-upright"), $, J, F), S.paint.get("text-opacity").constantOr(1) !== 0 && qo(g, T, S, k, !0, S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.layout.get("text-keep-upright"), $, J, F), T.map.showCollisionBoxes && (Xs(g, T, S, k, !0), Xs(g, T, S, k, !1))
            })(e, i, l, u, this.style.placement.variableOffsets, d) : s.cg(l) ? (function(g, T, S, k, z) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: V
              } = z, F = S.paint.get("circle-opacity"), $ = S.paint.get("circle-stroke-width"), J = S.paint.get("circle-stroke-opacity"), ae = !S.layout.get("circle-sort-key").isConstant();
              if (F.constantOr(1) === 0 && ($.constantOr(1) === 0 || J.constantOr(1) === 0)) return;
              const oe = g.context,
                se = oe.gl,
                fe = g.transform,
                xe = g.getDepthModeForSublayer(0, tn.ReadOnly),
                pe = yn.disabled,
                be = g.colorModeForRenderPass(),
                Pe = [],
                ge = fe.getCircleRadiusCorrection();
              for (let Fe = 0; Fe < k.length; Fe++) {
                const nt = k[Fe],
                  et = T.getTile(nt),
                  rt = et.getBucket(S);
                if (!rt) continue;
                const at = S.paint.get("circle-translate"),
                  Gt = S.paint.get("circle-translate-anchor"),
                  Ht = s.aH(fe, et, at, Gt),
                  Pt = rt.programConfigurations.get(S.id),
                  gr = g.useProgram("circle", Pt),
                  Qr = rt.layoutVertexBuffer,
                  En = rt.indexBuffer,
                  on = g.style.map.terrain && g.style.map.terrain.getTerrainData(nt),
                  On = {
                    programConfiguration: Pt,
                    program: gr,
                    layoutVertexBuffer: Qr,
                    indexBuffer: En,
                    uniformValues: sf(g, et, S, Ht, ge),
                    terrainData: on,
                    projectionData: fe.getProjectionData({
                      overscaledTileID: nt,
                      applyGlobeMatrix: !V,
                      applyTerrainMatrix: !0
                    })
                  };
                if (ae) {
                  const Qn = rt.segments.get();
                  for (const qn of Qn) Pe.push({
                    segments: new s.aQ([qn]),
                    sortKey: qn.sortKey,
                    state: On
                  })
                } else Pe.push({
                  segments: rt.segments,
                  sortKey: 0,
                  state: On
                })
              }
              ae && Pe.sort(((Fe, nt) => Fe.sortKey - nt.sortKey));
              for (const Fe of Pe) {
                const {
                  programConfiguration: nt,
                  program: et,
                  layoutVertexBuffer: rt,
                  indexBuffer: at,
                  uniformValues: Gt,
                  terrainData: Ht,
                  projectionData: Pt
                } = Fe.state;
                et.draw(oe, se.TRIANGLES, xe, pe, be, ln.backCCW, Gt, Ht, Pt, S.id, rt, at, Fe.segments, S.paint, g.transform.zoom, nt)
              }
            })(e, i, l, u, d) : s.ch(l) ? (function(g, T, S, k, z) {
              if (S.paint.get("heatmap-opacity") === 0) return;
              const V = g.context,
                {
                  isRenderingToTexture: F,
                  isRenderingGlobe: $
                } = z;
              if (g.style.map.terrain) {
                for (const J of k) {
                  const ae = T.getTile(J);
                  T.hasRenderableParent(J) || (g.renderPass === "offscreen" ? vf(g, ae, S, J, $) : g.renderPass === "translucent" && Ys(g, S, J, F, $))
                }
                V.viewport.set([0, 0, g.width, g.height])
              } else g.renderPass === "offscreen" ? (function(J, ae, oe, se) {
                const fe = J.context,
                  xe = fe.gl,
                  pe = J.transform,
                  be = yn.disabled,
                  Pe = new mn([xe.ONE, xe.ONE], s.bi.transparent, [!0, !0, !0, !0]);
                (function(ge, Fe, nt) {
                  const et = ge.gl;
                  ge.activeTexture.set(et.TEXTURE1), ge.viewport.set([0, 0, Fe.width / 4, Fe.height / 4]);
                  let rt = nt.heatmapFbos.get(s.c6);
                  rt ? (et.bindTexture(et.TEXTURE_2D, rt.colorAttachment.get()), ge.bindFramebuffer.set(rt.framebuffer)) : (rt = xd(ge, Fe.width / 4, Fe.height / 4), nt.heatmapFbos.set(s.c6, rt))
                })(fe, J, oe), fe.clear({
                  color: s.bi.transparent
                });
                for (let ge = 0; ge < se.length; ge++) {
                  const Fe = se[ge];
                  if (ae.hasRenderableParent(Fe)) continue;
                  const nt = ae.getTile(Fe),
                    et = nt.getBucket(oe);
                  if (!et) continue;
                  const rt = et.programConfigurations.get(oe.id),
                    at = J.useProgram("heatmap", rt),
                    Gt = pe.getProjectionData({
                      overscaledTileID: Fe,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    Ht = pe.getCircleRadiusCorrection();
                  at.draw(fe, xe.TRIANGLES, tn.disabled, be, Pe, ln.backCCW, Gc(nt, pe.zoom, oe.paint.get("heatmap-intensity"), Ht), null, Gt, oe.id, et.layoutVertexBuffer, et.indexBuffer, et.segments, oe.paint, pe.zoom, rt)
                }
                fe.viewport.set([0, 0, J.width, J.height])
              })(g, T, S, k) : g.renderPass === "translucent" && (function(J, ae) {
                const oe = J.context,
                  se = oe.gl;
                oe.setColorMode(J.colorModeForRenderPass());
                const fe = ae.heatmapFbos.get(s.c6);
                fe && (oe.activeTexture.set(se.TEXTURE0), se.bindTexture(se.TEXTURE_2D, fe.colorAttachment.get()), oe.activeTexture.set(se.TEXTURE1), au(oe, ae).bind(se.LINEAR, se.CLAMP_TO_EDGE), J.useProgram("heatmapTexture").draw(oe, se.TRIANGLES, tn.disabled, yn.disabled, J.colorModeForRenderPass(), ln.disabled, $c(J, ae, 0, 1), null, null, ae.id, J.viewportBuffer, J.quadTriangleIndexBuffer, J.viewportSegments, ae.paint, J.transform.zoom))
              })(g, S)
            })(e, i, l, u, d) : s.ci(l) ? (function(g, T, S, k, z) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: V
              } = z, F = S.paint.get("line-opacity"), $ = S.paint.get("line-width");
              if (F.constantOr(1) === 0 || $.constantOr(1) === 0) return;
              const J = g.getDepthModeForSublayer(0, tn.ReadOnly),
                ae = g.colorModeForRenderPass(),
                oe = S.paint.get("line-dasharray"),
                se = oe.constantOr(1),
                fe = S.paint.get("line-pattern"),
                xe = fe.constantOr(1),
                pe = S.paint.get("line-gradient"),
                be = S.getCrossfadeParameters();
              let Pe;
              Pe = xe ? "linePattern" : se && pe ? "lineGradientSDF" : se ? "lineSDF" : pe ? "lineGradient" : "line";
              const ge = g.context,
                Fe = ge.gl,
                nt = g.transform;
              let et = !0;
              for (const rt of k) {
                const at = T.getTile(rt);
                if (xe && !at.patternsLoaded()) continue;
                const Gt = at.getBucket(S);
                if (!Gt) continue;
                const Ht = Gt.programConfigurations.get(S.id),
                  Pt = g.context.program.get(),
                  gr = g.useProgram(Pe, Ht),
                  Qr = et || gr.program !== Pt,
                  En = g.style.map.terrain && g.style.map.terrain.getTerrainData(rt),
                  on = fe.constantOr(null),
                  On = oe && oe.constantOr(null);
                if (on && at.imageAtlas) {
                  const Mi = at.imageAtlas,
                    Xn = Mi.patternPositions[on.to.toString()],
                    hi = Mi.patternPositions[on.from.toString()];
                  Xn && hi && Ht.setConstantPatternPositions(Xn, hi)
                } else if (On) {
                  const Mi = S.layout.get("line-cap") === "round",
                    Xn = g.lineAtlas.getDash(On.to, Mi),
                    hi = g.lineAtlas.getDash(On.from, Mi);
                  Ht.setConstantDashPositions(Xn, hi)
                }
                const Qn = nt.getProjectionData({
                    overscaledTileID: rt,
                    applyGlobeMatrix: !V,
                    applyTerrainMatrix: !0
                  }),
                  qn = nt.getPixelScale();
                let gi;
                xe ? (gi = kl(g, at, S, qn, be), ou(ge, Fe, at, Ht, be)) : se && pe ? (gi = uf(g, at, S, qn, be, Gt.lineClipsArray.length), Gl(g, T, ge, Fe, S, Gt, rt, Ht, be)) : se ? (gi = cf(g, at, S, qn, be), bd(g, ge, Fe, Ht, Qr, be)) : pe ? (gi = lf(g, at, S, qn, Gt.lineClipsArray.length), wd(g, T, ge, Fe, S, Gt, rt)) : gi = xo(g, at, S, qn);
                const Wn = g.stencilModeForClipping(rt);
                gr.draw(ge, Fe.TRIANGLES, J, Wn, ae, ln.disabled, gi, En, Qn, S.id, Gt.layoutVertexBuffer, Gt.indexBuffer, Gt.segments, S.paint, g.transform.zoom, Ht, Gt.layoutVertexBuffer2), et = !1
              }
            })(e, i, l, u, d) : s.cj(l) ? (function(g, T, S, k, z) {
              const V = S.paint.get("fill-color"),
                F = S.paint.get("fill-opacity");
              if (F.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: $
              } = z, J = g.colorModeForRenderPass(), ae = S.paint.get("fill-pattern"), oe = g.opaquePassEnabledForLayer() && !ae.constantOr(1) && V.constantOr(s.bi.transparent).a === 1 && F.constantOr(0) === 1 ? "opaque" : "translucent";
              if (g.renderPass === oe) {
                const se = g.getDepthModeForSublayer(1, g.renderPass === "opaque" ? tn.ReadWrite : tn.ReadOnly);
                Td(g, T, S, k, se, J, !1, $)
              }
              if (g.renderPass === "translucent" && S.paint.get("fill-antialias")) {
                const se = g.getDepthModeForSublayer(S.getPaintProperty("fill-outline-color") ? 2 : 0, tn.ReadOnly);
                Td(g, T, S, k, se, J, !0, $)
              }
            })(e, i, l, u, d) : s.ck(l) ? (function(g, T, S, k, z) {
              const V = S.paint.get("fill-extrusion-opacity");
              if (V === 0) return;
              const {
                isRenderingToTexture: F
              } = z;
              if (g.renderPass === "translucent") {
                const $ = new tn(g.context.gl.LEQUAL, tn.ReadWrite, g.depthRangeFor3D);
                if (V !== 1 || S.paint.get("fill-extrusion-pattern").constantOr(1)) Hl(g, T, S, k, $, yn.disabled, mn.disabled, F), Hl(g, T, S, k, $, g.stencilModeFor3D(), g.colorModeForRenderPass(), F);
                else {
                  const J = g.colorModeForRenderPass();
                  Hl(g, T, S, k, $, yn.disabled, J, F)
                }
              }
            })(e, i, l, u, d) : s.cl(l) ? (function(g, T, S, k, z) {
              if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: V
              } = z, F = g.context, $ = g.style.projection.useSubdivision, J = g.getDepthModeForSublayer(0, tn.ReadOnly), ae = g.colorModeForRenderPass();
              if (g.renderPass === "offscreen")(function(oe, se, fe, xe, pe, be, Pe) {
                const ge = oe.context,
                  Fe = ge.gl;
                for (const nt of fe) {
                  const et = se.getTile(nt),
                    rt = et.dem;
                  if (!rt || !rt.data || !et.needsHillshadePrepare) continue;
                  const at = rt.dim,
                    Gt = rt.stride,
                    Ht = rt.getPixels();
                  if (ge.activeTexture.set(Fe.TEXTURE1), ge.pixelStoreUnpackPremultiplyAlpha.set(!1), et.demTexture = et.demTexture || oe.getTileTexture(Gt), et.demTexture) {
                    const gr = et.demTexture;
                    gr.update(Ht, {
                      premultiply: !1
                    }), gr.bind(Fe.NEAREST, Fe.CLAMP_TO_EDGE)
                  } else et.demTexture = new s.T(ge, Ht, Fe.RGBA, {
                    premultiply: !1
                  }), et.demTexture.bind(Fe.NEAREST, Fe.CLAMP_TO_EDGE);
                  ge.activeTexture.set(Fe.TEXTURE0);
                  let Pt = et.fbo;
                  if (!Pt) {
                    const gr = new s.T(ge, {
                      width: at,
                      height: at,
                      data: null
                    }, Fe.RGBA);
                    gr.bind(Fe.LINEAR, Fe.CLAMP_TO_EDGE), Pt = et.fbo = ge.createFramebuffer(at, at, !0, !1), Pt.colorAttachment.set(gr.texture)
                  }
                  ge.bindFramebuffer.set(Pt.framebuffer), ge.viewport.set([0, 0, at, at]), oe.useProgram("hillshadePrepare").draw(ge, Fe.TRIANGLES, pe, be, Pe, ln.disabled, Fo(et.tileID, rt), null, null, xe.id, oe.rasterBoundsBuffer, oe.quadTriangleIndexBuffer, oe.rasterBoundsSegments), et.needsHillshadePrepare = !1
                }
              })(g, T, k, S, J, yn.disabled, ae), F.viewport.set([0, 0, g.width, g.height]);
              else if (g.renderPass === "translucent")
                if ($) {
                  const [oe, se, fe] = g.stencilConfigForOverlapTwoPass(k);
                  Kn(g, T, S, fe, oe, J, ae, !1, V), Kn(g, T, S, fe, se, J, ae, !0, V)
                } else {
                  const [oe, se] = g.getStencilConfigForOverlapAndUpdateStencilID(k);
                  Kn(g, T, S, se, oe, J, ae, !1, V)
                }
            })(e, i, l, u, d) : s.cm(l) ? (function(g, T, S, k, z) {
              if (g.renderPass !== "translucent" || !k.length) return;
              const {
                isRenderingToTexture: V
              } = z, F = g.style.projection.useSubdivision, $ = g.getDepthModeForSublayer(0, tn.ReadOnly), J = g.colorModeForRenderPass();
              if (F) {
                const [ae, oe, se] = g.stencilConfigForOverlapTwoPass(k);
                eo(g, T, S, se, ae, $, J, !1, V), eo(g, T, S, se, oe, $, J, !0, V)
              } else {
                const [ae, oe] = g.getStencilConfigForOverlapAndUpdateStencilID(k);
                eo(g, T, S, oe, ae, $, J, !1, V)
              }
            })(e, i, l, u, d) : s.bN(l) ? (function(g, T, S, k, z) {
              if (g.renderPass !== "translucent" || S.paint.get("raster-opacity") === 0 || !k.length) return;
              const {
                isRenderingToTexture: V
              } = z, F = T.getSource(), $ = g.style.projection.useSubdivision;
              if (F instanceof rr) vs(g, T, S, k, null, !1, !1, F.tileCoords, F.flippedWindingOrder, V);
              else if ($) {
                const [J, ae, oe] = g.stencilConfigForOverlapTwoPass(k);
                vs(g, T, S, oe, J, !1, !0, ta, !1, V), vs(g, T, S, oe, ae, !0, !0, ta, !1, V)
              } else {
                const [J, ae] = g.getStencilConfigForOverlapAndUpdateStencilID(k);
                vs(g, T, S, ae, J, !1, !0, ta, !1, V)
              }
            })(e, i, l, u, d) : s.cn(l) ? (function(g, T, S, k, z) {
              const V = S.paint.get("background-color"),
                F = S.paint.get("background-opacity");
              if (F === 0) return;
              const {
                isRenderingToTexture: $
              } = z, J = g.context, ae = J.gl, oe = g.style.projection, se = g.transform, fe = se.tileSize, xe = S.paint.get("background-pattern");
              if (g.isPatternMissing(xe)) return;
              const pe = !xe && V.a === 1 && F === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass !== pe) return;
              const be = yn.disabled,
                Pe = g.getDepthModeForSublayer(0, pe === "opaque" ? tn.ReadWrite : tn.ReadOnly),
                ge = g.colorModeForRenderPass(),
                Fe = g.useProgram(xe ? "backgroundPattern" : "background"),
                nt = k || qr(se, {
                  tileSize: fe,
                  terrain: g.style.map.terrain
                });
              xe && (J.activeTexture.set(ae.TEXTURE0), g.imageManager.bind(g.context));
              const et = S.getCrossfadeParameters();
              for (const rt of nt) {
                const at = se.getProjectionData({
                    overscaledTileID: rt,
                    applyGlobeMatrix: !$,
                    applyTerrainMatrix: !0
                  }),
                  Gt = xe ? Kc(F, g, xe, {
                    tileID: rt,
                    tileSize: fe
                  }, et) : Yc(F, V),
                  Ht = g.style.map.terrain && g.style.map.terrain.getTerrainData(rt),
                  Pt = oe.getMeshFromTileID(J, rt.canonical, !1, !0, "raster");
                Fe.draw(J, ae.TRIANGLES, Pe, be, ge, ln.backCCW, Gt, Ht, at, S.id, Pt.vertexBuffer, Pt.indexBuffer, Pt.segments)
              }
            })(e, 0, l, u, d) : s.co(l) && (function(g, T, S, k) {
              const {
                isRenderingGlobe: z
              } = k, V = g.context, F = S.implementation, $ = g.style.projection, J = g.transform, ae = J.getProjectionDataForCustomLayer(z), oe = {
                farZ: J.farZ,
                nearZ: J.nearZ,
                fov: J.fov * Math.PI / 180,
                modelViewProjectionMatrix: J.modelViewProjectionMatrix,
                projectionMatrix: J.projectionMatrix,
                shaderData: {
                  variantName: $.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${$.shaderPreludeCode.vertexSource}`,
                  define: $.shaderDefine
                },
                defaultProjectionData: ae
              }, se = F.renderingMode ? F.renderingMode : "2d";
              if (g.renderPass === "offscreen") {
                const fe = F.prerender;
                fe && (g.setCustomLayerDefaults(), V.setColorMode(g.colorModeForRenderPass()), fe.call(F, V.gl, oe), V.setDirty(), g.setBaseState())
              } else if (g.renderPass === "translucent") {
                g.setCustomLayerDefaults(), V.setColorMode(g.colorModeForRenderPass()), V.setStencilMode(yn.disabled);
                const fe = se === "3d" ? g.getDepthModeFor3D() : g.getDepthModeForSublayer(0, tn.ReadOnly);
                V.setDepthMode(fe), F.render(V.gl, oe), V.setDirty(), g.setBaseState(), V.bindFramebuffer.set(null)
              }
            })(e, 0, l, d))
          }
          saveTileTexture(e) {
            const i = this._tileTextures[e.size[0]];
            i ? i.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const i = this._tileTextures[e];
            return i && i.length > 0 ? i.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const i = this.imageManager.getPattern(e.from.toString()),
              l = this.imageManager.getPattern(e.to.toString());
            return !i || !l
          }
          useProgram(e, i, l = !1, u = []) {
            this.cache = this.cache || {};
            const d = !!this.style.map.terrain,
              g = this.style.projection,
              T = l ? pr.projectionMercator : g.shaderPreludeCode,
              S = l ? Sn : g.shaderDefine,
              k = e + (i ? i.cacheKey : "") + `/${l?en:g.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (u ? `/${u.join("/")}` : "");
            return this.cache[k] || (this.cache[k] = new Zs(this.context, pr[e], i, cd[e], this._showOverdrawInspector, d, T, S, u)), this.cache[k]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: i
            } = this.context.gl;
            return this.width !== e || this.height !== i
          }
        }

        function du(h, e) {
          let i, l = !1,
            u = null,
            d = null;
          const g = () => {
            u = null, l && (h.apply(d, i), u = setTimeout(g, e), l = !1)
          };
          return (...T) => (l = !0, d = this, i = T, u || g(), u)
        }
        class pu {
          constructor(e) {
            this._getCurrentHash = () => {
              const i = window.location.hash.replace("#", "");
              if (this._hashName) {
                let l;
                return i.split("&").map((u => u.split("="))).forEach((u => {
                  u[0] === this._hashName && (l = u)
                })), (l && l[1] || "").split("/")
              }
              return i.split("/")
            }, this._onHashChange = () => {
              const i = this._getCurrentHash();
              if (!this._isValidHash(i)) return !1;
              const l = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+i[2], +i[1]],
                zoom: +i[0],
                bearing: l,
                pitch: +(i[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const i = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, i)
            }, this._removeHash = () => {
              const i = this._getCurrentHash();
              if (i.length === 0) return;
              const l = i.join("/");
              let u = l;
              u.split("&").length > 0 && (u = u.split("&")[0]), this._hashName && (u = `${this._hashName}=${l}`);
              let d = window.location.hash.replace(u, "");
              d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
              let g = window.location.href.replace(/(#.+)?$/, d);
              g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g)
            }, this._updateHash = du(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const i = this._map.getCenter(),
              l = Math.round(100 * this._map.getZoom()) / 100,
              u = Math.ceil((l * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              d = Math.pow(10, u),
              g = Math.round(i.lng * d) / d,
              T = Math.round(i.lat * d) / d,
              S = this._map.getBearing(),
              k = this._map.getPitch();
            let z = "";
            if (z += e ? `/${g}/${T}/${l}` : `${l}/${T}/${g}`, (S || k) && (z += "/" + Math.round(10 * S) / 10), k && (z += `/${Math.round(k)}`), this._hashName) {
              const V = this._hashName;
              let F = !1;
              const $ = window.location.hash.slice(1).split("&").map((J => {
                const ae = J.split("=")[0];
                return ae === V ? (F = !0, `${ae}=${z}`) : J
              })).filter((J => J));
              return F || $.push(`${V}=${z}`), `#${$.join("&")}`
            }
            return `#${z}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new s.U(+e[2], +e[1])
            } catch {
              return !1
            }
            const i = +e[0],
              l = +(e[3] || 0),
              u = +(e[4] || 0);
            return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && l >= -180 && l <= 180 && u >= this._map.getMinPitch() && u <= this._map.getMaxPitch()
          }
        }
        const xs = {
            linearity: .3,
            easing: s.cp(0, 0, .3, 1)
          },
          Id = s.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, xs),
          Md = s.e({
            deceleration: 20,
            maxSpeed: 1400
          }, xs),
          Ad = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, xs),
          kd = s.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, xs),
          Xl = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, xs);
        class Ed {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: ne(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              i = ne();
            for (; e.length > 0 && i - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new s.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: d
              }
              of this._inertiaBuffer) i.zoom += d.zoomDelta || 0, i.bearing += d.bearingDelta || 0, i.pitch += d.pitchDelta || 0, i.roll += d.rollDelta || 0, d.panDelta && i.pan._add(d.panDelta), d.around && (i.around = d.around), d.pinchAround && (i.pinchAround = d.pinchAround);
            const l = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              u = {};
            if (i.pan.mag()) {
              const d = Xi(i.pan.mag(), l, s.e({}, Id, e || {})),
                g = i.pan.mult(d.amount / i.pan.mag()),
                T = this._map.cameraHelper.handlePanInertia(g, this._map.transform);
              u.center = T.easingCenter, u.offset = T.easingOffset, Ui(u, d)
            }
            if (i.zoom) {
              const d = Xi(i.zoom, l, Md);
              u.zoom = this._map.transform.zoom + d.amount, Ui(u, d)
            }
            if (i.bearing) {
              const d = Xi(i.bearing, l, Ad);
              u.bearing = this._map.transform.bearing + s.ai(d.amount, -179, 179), Ui(u, d)
            }
            if (i.pitch) {
              const d = Xi(i.pitch, l, kd);
              u.pitch = this._map.transform.pitch + d.amount, Ui(u, d)
            }
            if (i.roll) {
              const d = Xi(i.roll, l, Xl);
              u.roll = this._map.transform.roll + s.ai(d.amount, -179, 179), Ui(u, d)
            }
            if (u.zoom || u.bearing) {
              const d = i.pinchAround === void 0 ? i.around : i.pinchAround;
              u.around = d ? this._map.unproject(d) : this._map.getCenter()
            }
            return this.clear(), s.e(u, {
              noMoveStart: !0
            })
          }
        }

        function Ui(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing)
        }

        function Xi(h, e, i) {
          const {
            maxSpeed: l,
            linearity: u,
            deceleration: d
          } = i, g = s.ai(h * u / (e / 1e3), -l, l), T = Math.abs(g) / (d * u);
          return {
            easing: i.easing,
            duration: 1e3 * T,
            amount: g * (T / 2)
          }
        }
        class ra extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l, u = {}) {
            l = l instanceof MouseEvent ? l : new MouseEvent(e, l);
            const d = Y.mousePos(i.getCanvas(), l),
              g = i.unproject(d);
            super(e, s.e({
              point: d,
              lngLat: g,
              originalEvent: l
            }, u)), this._defaultPrevented = !1, this.target = i
          }
        }
        class Yi extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            const u = e === "touchend" ? l.changedTouches : l.touches,
              d = Y.touchPos(i.getCanvasContainer(), u),
              g = d.map((S => i.unproject(S))),
              T = d.reduce(((S, k, z, V) => S.add(k.div(V.length))), new s.P(0, 0));
            super(e, {
              points: d,
              point: T,
              lngLats: g,
              lngLat: i.unproject(T),
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class zd extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, i, l) {
            super(e, {
              originalEvent: l
            }), this._defaultPrevented = !1
          }
        }
        class bs {
          constructor(e, i) {
            this._map = e, this._clickTolerance = i.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new zd(e.type, this._map, e))
          }
          mousedown(e, i) {
            return this._mousedownPos = i, this._firePreventable(new ra(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new ra(e.type, this._map, e))
          }
          click(e, i) {
            this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new ra(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new ra(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new ra(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new ra(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new Yi(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new Yi(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new Yi(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new Yi(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class yf {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new ra(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ra("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new ra(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class el {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain)
          }
        }
        class Ld {
          constructor(e, i) {
            this._map = e, this._tr = new el(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = i.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, i) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (Y.disableDrag(), this._startPos = this._lastPos = i, this._active = !0)
          }
          mousemoveWindow(e, i) {
            if (!this._active) return;
            const l = i;
            if (this._lastPos.equals(l) || !this._box && l.dist(this._startPos) < this._clickTolerance) return;
            const u = this._startPos;
            this._lastPos = l, this._box || (this._box = Y.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const d = Math.min(u.x, l.x),
              g = Math.max(u.x, l.x),
              T = Math.min(u.y, l.y),
              S = Math.max(u.y, l.y);
            Y.setTransform(this._box, `translate(${d}px,${T}px)`), this._box.style.width = g - d + "px", this._box.style.height = S - T + "px"
          }
          mouseupWindow(e, i) {
            if (!this._active || e.button !== 0) return;
            const l = this._startPos,
              u = i;
            if (this.reset(), Y.suppressClick(), l.x !== u.x || l.y !== u.y) return this._map.fire(new s.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: d => d.fitScreenCoordinates(l, u, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (Y.remove(this._box), this._box = null), Y.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, i) {
            return this._map.fire(new s.l(e, {
              originalEvent: i
            }))
          }
        }

        function fu(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const i = {};
          for (let l = 0; l < h.length; l++) i[h[l].identifier] = e[l];
          return i
        }
        class Dd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, i, l) {
            (this.centroid || l.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), l.length === this.numTouches && (this.centroid = (function(u) {
              const d = new s.P(0, 0);
              for (const g of u) d._add(g);
              return d.div(u.length)
            })(i), this.touches = fu(l, i)))
          }
          touchmove(e, i, l) {
            if (this.aborted || !this.centroid) return;
            const u = fu(l, i);
            for (const d in this.touches) {
              const g = u[d];
              (!g || g.dist(this.touches[d]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, i, l) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), l.length === 0) {
              const u = !this.aborted && this.centroid;
              if (this.reset(), u) return u
            }
          }
        }
        class Uo {
          constructor(e) {
            this.singleTap = new Dd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, i, l) {
            this.singleTap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this.singleTap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this.singleTap.touchend(e, i, l);
            if (u) {
              const d = e.timeStamp - this.lastTime < 500,
                g = !this.lastTap || this.lastTap.dist(u) < 30;
              if (d && g || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = u, this.count === this.numTaps) return this.reset(), u
            }
          }
        }
        class to {
          constructor(e) {
            this._tr = new el(e), this._zoomIn = new Uo({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Uo({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, i, l) {
            this._zoomIn.touchstart(e, i, l), this._zoomOut.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            this._zoomIn.touchmove(e, i, l), this._zoomOut.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            const u = this._zoomIn.touchend(e, i, l),
              d = this._zoomOut.touchend(e, i, l),
              g = this._tr;
            return u ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: T => T.easeTo({
                duration: 300,
                zoom: g.zoom + 1,
                around: g.unproject(u)
              }, {
                originalEvent: e
              })
            }) : d ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: T => T.easeTo({
                duration: 300,
                zoom: g.zoom - 1,
                around: g.unproject(d)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class sr {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const i = this._moveFunction(...e);
            if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta) return this._active = !0, i
          }
          dragStart(e, i) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(i) ? i[0] : i, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, i) {
            if (!this.isEnabled()) return;
            const l = this._lastPoint;
            if (!l) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const u = Array.isArray(i) ? i[0] : i;
            return !this._moved && u.dist(l) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = u, this._move(l, u))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && Y.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const Rd = 0,
          mu = 2,
          Fd = {
            [Rd]: 1,
            [mu]: 2
          };
        class ro {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const i = Y.mouseButton(e);
            this._eventButton = i
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(i, l) {
              const u = Fd[l];
              return i.buttons === void 0 || (i.buttons & u) !== u
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return Y.mouseButton(e) === this._eventButton
          }
        }
        class tl {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class _u {
          constructor(e = new ro({
            checkCorrectEvent: () => !0
          }), i = new tl) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = i
          }
          _executeRelevantHandler(e, i, l) {
            return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? l(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.startMove(i)), (i => this.oneFingerTouchMoveStateManager.startMove(i)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.endMove(i)), (i => this.oneFingerTouchMoveStateManager.endMove(i)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidStartEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidStartEvent(i)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidMoveEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (i => this.mouseMoveStateManager.isValidEndEvent(i)), (i => this.oneFingerTouchMoveStateManager.isValidEndEvent(i)))
          }
        }
        const pn = h => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = e => {
            e.preventDefault()
          }
        };
        class gu {
          constructor(e, i) {
            this._clickTolerance = e.clickTolerance || 1, this._map = i, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new s.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, i, l) {
            return this._calculateTransform(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._active) {
              if (!this._shouldBePrevented(l.length)) return e.preventDefault(), this._calculateTransform(e, i, l);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, i, l) {
            this._calculateTransform(e, i, l), this._active && this._shouldBePrevented(l.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, i, l) {
            l.length > 0 && (this._active = !0);
            const u = fu(l, i),
              d = new s.P(0, 0),
              g = new s.P(0, 0);
            let T = 0;
            for (const k in u) {
              const z = u[k],
                V = this._touches[k];
              V && (d._add(z), g._add(z.sub(V)), T++, u[k] = z)
            }
            if (this._touches = u, this._shouldBePrevented(T) || !g.mag()) return;
            const S = g.div(T);
            return this._sum._add(S), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: d.div(T),
              panDelta: S
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class vu {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, i, l) {
            this._firstTwoTouches || l.length < 2 || (this._firstTwoTouches = [l[0].identifier, l[1].identifier], this._start([i[0], i[1]]))
          }
          touchmove(e, i, l) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [u, d] = this._firstTwoTouches, g = ws(l, i, u), T = ws(l, i, d);
            if (!g || !T) return;
            const S = this._aroundCenter ? null : g.add(T).div(2);
            return this._move([g, T], S, e)
          }
          touchend(e, i, l) {
            if (!this._firstTwoTouches) return;
            const [u, d] = this._firstTwoTouches, g = ws(l, i, u), T = ws(l, i, d);
            g && T || (this._active && Y.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function ws(h, e, i) {
          for (let l = 0; l < h.length; l++)
            if (h[l].identifier === i) return e[l]
        }

        function Bd(h, e) {
          return Math.log(h / e) / Math.LN2
        }
        class Od extends vu {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, i) {
            const l = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Bd(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: Bd(this._distance, l),
              pinchAround: i
            }
          }
        }

        function yu(h, e) {
          return 180 * h.angleWith(e) / Math.PI
        }
        class Yl extends vu {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, i, l) {
            const u = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: yu(this._vector, u),
              pinchAround: i
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const i = 25 / (Math.PI * this._minDiameter) * 360,
              l = yu(e, this._startVector);
            return Math.abs(l) < i
          }
        }

        function Kl(h) {
          return Math.abs(h.y) > Math.abs(h.x)
        }
        class Nd extends vu {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, i, l) {
            super.touchstart(e, i, l), this._currentTouchCount = l.length
          }
          _start(e) {
            this._lastPoints = e, Kl(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, i, l) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const u = e[0].sub(this._lastPoints[0]),
              d = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(u, d, l.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (u.y + d.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, i, l) {
            if (this._valid !== void 0) return this._valid;
            const u = e.mag() >= 2,
              d = i.mag() >= 2;
            if (!u && !d) return;
            if (!u || !d) return this._firstMove === void 0 && (this._firstMove = l), l - this._firstMove < 100 && void 0;
            const g = e.y > 0 == i.y > 0;
            return Kl(e) && Kl(i) && g
          }
        }
        const jd = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class Vd {
          constructor(e) {
            this._tr = new el(e);
            const i = jd;
            this._panStep = i.panStep, this._bearingStep = i.bearingStep, this._pitchStep = i.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let i = 0,
              l = 0,
              u = 0,
              d = 0,
              g = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                i = 1;
                break;
              case 189:
              case 109:
              case 173:
                i = -1;
                break;
              case 37:
                e.shiftKey ? l = -1 : (e.preventDefault(), d = -1);
                break;
              case 39:
                e.shiftKey ? l = 1 : (e.preventDefault(), d = 1);
                break;
              case 38:
                e.shiftKey ? u = 1 : (e.preventDefault(), g = -1);
                break;
              case 40:
                e.shiftKey ? u = -1 : (e.preventDefault(), g = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (l = 0, u = 0), {
              cameraAnimation: T => {
                const S = this._tr;
                T.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: xf,
                  zoom: i ? Math.round(S.zoom) + i * (e.shiftKey ? 2 : 1) : S.zoom,
                  bearing: S.bearing + l * this._bearingStep,
                  pitch: S.pitch + u * this._pitchStep,
                  offset: [-d * this._panStep, -g * this._panStep],
                  center: S.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function xf(h) {
          return h * (2 - h)
        }
        const no = 4.000244140625,
          Bn = 1 / 450;
        class qd {
          constructor(e, i) {
            this._onTimeout = l => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(l)
            }, this._map = e, this._tr = new el(e), this._triggerRenderFrame = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Bn
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const l = ne(),
              u = l - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = l, i !== 0 && i % no == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(u * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i = Y.mousePos(this._map.getCanvas(), e),
              l = this._tr;
            this._aroundPoint = this._aroundCenter ? l.transform.locationToScreenPoint(s.U.convert(l.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const T = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += T), typeof this._targetZoom == "number" && (this._targetZoom += T)
            }
            if (this._delta !== 0) {
              const T = this._type === "wheel" && Math.abs(this._delta) > no ? this._wheelZoomRate : this._defaultZoomRate;
              let S = 2 / (1 + Math.exp(-Math.abs(this._delta * T)));
              this._delta < 0 && S !== 0 && (S = 1 / S);
              const k = typeof this._targetZoom != "number" ? e.scale : s.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), s.ao(k * S)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              l = this._startZoom,
              u = this._easing;
            let d, g = !1;
            if (this._type === "wheel" && l && u) {
              const T = ne() - this._lastWheelEventTime,
                S = Math.min((T + 5) / 200, 1),
                k = u(S);
              d = s.F.number(l, i, k), S < 1 ? this._frameId || (this._frameId = !0) : g = !0
            } else d = i, g = !0;
            return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = d, {
              noInertia: !0,
              needsRenderFrame: !g,
              zoomDelta: d - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let i = s.cr;
            if (this._prevEase) {
              const l = this._prevEase,
                u = (ne() - l.start) / l.duration,
                d = l.easing(u + .01) - l.easing(u),
                g = .27 / Math.sqrt(d * d + 1e-4) * .01,
                T = Math.sqrt(.0729 - g * g);
              i = s.cp(g, T, .25, 1)
            }
            return this._prevEase = {
              start: ne(),
              duration: e,
              easing: i
            }, i
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class rl {
          constructor(e, i) {
            this._clickZoom = e, this._tapZoom = i
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class xu {
          constructor(e) {
            this._tr = new el(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, i) {
            return e.preventDefault(), {
              cameraAnimation: l => {
                l.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(i)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Ud {
          constructor() {
            this._tap = new Uo({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, i, l) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const u = i[0],
                  d = e.timeStamp - this._tapTime < 500,
                  g = this._tapPoint.dist(u) < 30;
                d && g ? l.length > 0 && (this._swipePoint = u, this._swipeTouch = l[0].identifier) : this.reset()
              } else this._tap.touchstart(e, i, l)
          }
          touchmove(e, i, l) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (l[0].identifier !== this._swipeTouch) return;
                const u = i[0],
                  d = u.y - this._swipePoint.y;
                return this._swipePoint = u, e.preventDefault(), this._active = !0, {
                  zoomDelta: d / 128
                }
              }
            } else this._tap.touchmove(e, i, l)
          }
          touchend(e, i, l) {
            if (this._tapTime) this._swipePoint && l.length === 0 && this.reset();
            else {
              const u = this._tap.touchend(e, i, l);
              u && (this._tapTime = e.timeStamp, this._tapPoint = u)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class bu {
          constructor(e, i, l) {
            this._el = e, this._mousePan = i, this._touchPan = l
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class wu {
          constructor(e, i, l, u) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = i, this._mousePitch = l, this._mouseRoll = u
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Zd {
          constructor(e, i, l, u) {
            this._el = e, this._touchZoom = i, this._touchRotate = l, this._tapDragZoom = u, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Pa {
          constructor(e, i) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = i, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = Y.create("div", "maplibregl-cooperative-gesture-screen", e);
            let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const l = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              u = document.createElement("div");
            u.className = "maplibregl-desktop-message", u.textContent = i, this._container.appendChild(u);
            const d = document.createElement("div");
            d.className = "maplibregl-mobile-message", d.textContent = l, this._container.appendChild(d), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (Y.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, i) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: i
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Zo = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class Ar extends s.l {}

        function Ur(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
        }
        class nl {
          constructor(e, i) {
            this.handleWindowEvent = u => {
              this.handleEvent(u, `${u.type}Window`)
            }, this.handleEvent = (u, d) => {
              if (u.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const g = u.type === "renderFrame" ? void 0 : u,
                T = {
                  needsRenderFrame: !1
                },
                S = {},
                k = {};
              for (const {
                  handlerName: F,
                  handler: $,
                  allowed: J
                }
                of this._handlers) {
                if (!$.isEnabled()) continue;
                let ae;
                if (this._blockedByActive(k, J, F)) $.reset();
                else if ($[d || u.type]) {
                  if (s.cs(u, d || u.type)) {
                    const oe = Y.mousePos(this._map.getCanvas(), u);
                    ae = $[d || u.type](u, oe)
                  } else if (s.ct(u, d || u.type)) {
                    const oe = this._getMapTouches(u.touches),
                      se = Y.touchPos(this._map.getCanvas(), oe);
                    ae = $[d || u.type](u, se, oe)
                  } else s.cu(d || u.type) || (ae = $[d || u.type](u));
                  this.mergeHandlerResult(T, S, ae, F, g), ae && ae.needsRenderFrame && this._triggerRenderFrame()
                }(ae || $.isActive()) && (k[F] = $)
              }
              const z = {};
              for (const F in this._previousActiveHandlers) k[F] || (z[F] = g);
              this._previousActiveHandlers = k, (Object.keys(z).length || Ur(T)) && (this._changes.push([T, S, z]), this._triggerRenderFrame()), (Object.keys(k).length || Ur(T)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: V
              } = T;
              V && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], V(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ed(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i);
            const l = this._el;
            this._listeners = [
              [l, "touchstart", {
                passive: !0
              }],
              [l, "touchmove", {
                passive: !1
              }],
              [l, "touchend", void 0],
              [l, "touchcancel", void 0],
              [l, "mousedown", void 0],
              [l, "mousemove", void 0],
              [l, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [l, "mouseover", void 0],
              [l, "mouseout", void 0],
              [l, "dblclick", void 0],
              [l, "click", void 0],
              [l, "keydown", {
                capture: !1
              }],
              [l, "keyup", void 0],
              [l, "wheel", {
                passive: !1
              }],
              [l, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [u, d, g] of this._listeners) Y.addEventListener(u, d, u === document ? this.handleWindowEvent : this.handleEvent, g)
          }
          destroy() {
            for (const [e, i, l] of this._listeners) Y.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, l)
          }
          _addDefaultHandlers(e) {
            const i = this._map,
              l = i.getCanvasContainer();
            this._add("mapEvent", new bs(i, e));
            const u = i.boxZoom = new Ld(i, e);
            this._add("boxZoom", u), e.interactive && e.boxZoom && u.enable();
            const d = i.cooperativeGestures = new Pa(i, e.cooperativeGestures);
            this._add("cooperativeGestures", d), e.cooperativeGestures && d.enable();
            const g = new to(i),
              T = new xu(i);
            i.doubleClickZoom = new rl(T, g), this._add("tapZoom", g), this._add("clickZoom", T), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable();
            const S = new Ud;
            this._add("tapDragZoom", S);
            const k = i.touchPitch = new Nd(i);
            this._add("touchPitch", k), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch);
            const z = () => i.project(i.getCenter()),
              V = (function({
                enable: pe,
                clickTolerance: be,
                aroundCenter: Pe = !0,
                minPixelCenterThreshold: ge = 100,
                rotateDegreesPerPixelMoved: Fe = .8
              }, nt) {
                const et = new ro({
                  checkCorrectEvent: rt => Y.mouseButton(rt) === 0 && rt.ctrlKey || Y.mouseButton(rt) === 2 && !rt.ctrlKey
                });
                return new sr({
                  clickTolerance: be,
                  move: (rt, at) => {
                    const Gt = nt();
                    if (Pe && Math.abs(Gt.y - rt.y) > ge) return {
                      bearingDelta: s.cq(new s.P(rt.x, at.y), at, Gt)
                    };
                    let Ht = (at.x - rt.x) * Fe;
                    return Pe && at.y < Gt.y && (Ht = -Ht), {
                      bearingDelta: Ht
                    }
                  },
                  moveStateManager: et,
                  enable: pe,
                  assignEvents: pn
                })
              })(e, z),
              F = (function({
                enable: pe,
                clickTolerance: be,
                pitchDegreesPerPixelMoved: Pe = -.5
              }) {
                const ge = new ro({
                  checkCorrectEvent: Fe => Y.mouseButton(Fe) === 0 && Fe.ctrlKey || Y.mouseButton(Fe) === 2
                });
                return new sr({
                  clickTolerance: be,
                  move: (Fe, nt) => ({
                    pitchDelta: (nt.y - Fe.y) * Pe
                  }),
                  moveStateManager: ge,
                  enable: pe,
                  assignEvents: pn
                })
              })(e),
              $ = (function({
                enable: pe,
                clickTolerance: be,
                rollDegreesPerPixelMoved: Pe = .3
              }, ge) {
                const Fe = new ro({
                  checkCorrectEvent: nt => Y.mouseButton(nt) === 2 && nt.ctrlKey
                });
                return new sr({
                  clickTolerance: be,
                  move: (nt, et) => {
                    const rt = ge();
                    let at = (et.x - nt.x) * Pe;
                    return et.y < rt.y && (at = -at), {
                      rollDelta: at
                    }
                  },
                  moveStateManager: Fe,
                  enable: pe,
                  assignEvents: pn
                })
              })(e, z);
            i.dragRotate = new wu(e, V, F, $), this._add("mouseRotate", V, ["mousePitch"]), this._add("mousePitch", F, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", $, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable();
            const J = (function({
                enable: pe,
                clickTolerance: be
              }) {
                const Pe = new ro({
                  checkCorrectEvent: ge => Y.mouseButton(ge) === 0 && !ge.ctrlKey
                });
                return new sr({
                  clickTolerance: be,
                  move: (ge, Fe) => ({
                    around: Fe,
                    panDelta: Fe.sub(ge)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Pe,
                  enable: pe,
                  assignEvents: pn
                })
              })(e),
              ae = new gu(e, i);
            i.dragPan = new bu(l, J, ae), this._add("mousePan", J), this._add("touchPan", ae, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
            const oe = new Yl,
              se = new Od;
            i.touchZoomRotate = new Zd(l, se, oe, S), this._add("touchRotate", oe, ["touchPan", "touchZoom"]), this._add("touchZoom", se, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new yf(i));
            const fe = i.scrollZoom = new qd(i, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", fe, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom);
            const xe = i.keyboard = new Vd(i);
            this._add("keyboard", xe), e.interactive && e.keyboard && i.keyboard.enable()
          }
          _add(e, i, l) {
            this._handlers.push({
              handlerName: e,
              handler: i,
              allowed: l
            }), this._handlersById[e] = i
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: i
                }
                of this._handlers) i.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Zo(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, i, l) {
            for (const u in e)
              if (u !== l && (!i || i.indexOf(u) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const i = [];
            for (const l of e) this._el.contains(l.target) && i.push(l);
            return i
          }
          mergeHandlerResult(e, i, l, u, d) {
            if (!l) return;
            s.e(e, l);
            const g = {
              handlerName: u,
              originalEvent: l.originalEvent || d
            };
            l.zoomDelta !== void 0 && (i.zoom = g), l.panDelta !== void 0 && (i.drag = g), l.rollDelta !== void 0 && (i.roll = g), l.pitchDelta !== void 0 && (i.pitch = g), l.bearingDelta !== void 0 && (i.rotate = g)
          }
          _applyChanges() {
            const e = {},
              i = {},
              l = {};
            for (const [u, d, g] of this._changes) u.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(u.panDelta)), u.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta), u.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + u.bearingDelta), u.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta), u.rollDelta && (e.rollDelta = (e.rollDelta || 0) + u.rollDelta), u.around !== void 0 && (e.around = u.around), u.pinchAround !== void 0 && (e.pinchAround = u.pinchAround), u.noInertia && (e.noInertia = u.noInertia), s.e(i, d), s.e(l, g);
            this._updateMapTransform(e, i, l), this._changes = []
          }
          _updateMapTransform(e, i, l) {
            const u = this._map,
              d = u._getTransformForUpdate(),
              g = u.terrain;
            if (!(Ur(e) || g && this._terrainMovement)) return this._fireEvents(i, l, !0);
            u._stop(!0);
            let {
              panDelta: T,
              zoomDelta: S,
              bearingDelta: k,
              pitchDelta: z,
              rollDelta: V,
              around: F,
              pinchAround: $
            } = e;
            $ !== void 0 && (F = $), F = F || u.transform.centerPoint, g && !d.isPointOnMapSurface(F) && (F = d.centerPoint);
            const J = {
              panDelta: T,
              zoomDelta: S,
              rollDelta: V,
              pitchDelta: z,
              bearingDelta: k,
              around: F
            };
            this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(F) && (F = d.centerPoint);
            const ae = F.distSqr(d.centerPoint) < .01 ? d.center : d.screenPointToLocation(T ? F.sub(T) : F);
            this._handleMapControls({
              terrain: g,
              tr: d,
              deltasForHelper: J,
              preZoomAroundLoc: ae,
              combinedEventsInProgress: i,
              panDelta: T
            }), u._applyUpdatedTransform(d), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(i, l, !0)
          }
          _handleMapControls({
            terrain: e,
            tr: i,
            deltasForHelper: l,
            preZoomAroundLoc: u,
            combinedEventsInProgress: d,
            panDelta: g
          }) {
            const T = this._map.cameraHelper;
            if (T.handleMapControlsRollPitchBearingZoom(l, i), e) return T.useGlobeControls ? (this._terrainMovement || !d.drag && !d.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void T.handleMapControlsPan(l, i, u)) : this._terrainMovement || !d.drag && !d.zoom ? void(d.drag && this._terrainMovement && g ? i.setCenter(i.screenPointToLocation(i.centerPoint.sub(g))) : T.handleMapControlsPan(l, i, u)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void T.handleMapControlsPan(l, i, u));
            T.handleMapControlsPan(l, i, u)
          }
          _fireEvents(e, i, l) {
            const u = Zo(this._eventsInProgress),
              d = Zo(e),
              g = {};
            for (const V in e) {
              const {
                originalEvent: F
              } = e[V];
              this._eventsInProgress[V] || (g[`${V}start`] = F), this._eventsInProgress[V] = e[V]
            }!u && d && this._fireEvent("movestart", d.originalEvent);
            for (const V in g) this._fireEvent(V, g[V]);
            d && this._fireEvent("move", d.originalEvent);
            for (const V in e) {
              const {
                originalEvent: F
              } = e[V];
              this._fireEvent(V, F)
            }
            const T = {};
            let S;
            for (const V in this._eventsInProgress) {
              const {
                handlerName: F,
                originalEvent: $
              } = this._eventsInProgress[V];
              this._handlersById[F].isActive() || (delete this._eventsInProgress[V], S = i[F] || $, T[`${V}end`] = S)
            }
            for (const V in T) this._fireEvent(V, T[V]);
            const k = Zo(this._eventsInProgress),
              z = (u || d) && !k;
            if (z && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const V = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && V.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(V)
            }
            if (l && z) {
              this._updatingCamera = !0;
              const V = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                F = $ => $ !== 0 && -this._bearingSnap < $ && $ < this._bearingSnap;
              !V || !V.essential && re.prefersReducedMotion ? (this._map.fire(new s.l("moveend", {
                originalEvent: S
              })), F(this._map.getBearing()) && this._map.resetNorth()) : (F(V.bearing || this._map.getBearing()) && (V.bearing = 0), V.freezeElevation = !0, this._map.easeTo(V, {
                originalEvent: S
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, i) {
            this._map.fire(new s.l(e, i ? {
              originalEvent: i
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new Ar("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Gd extends s.E {
          constructor(e, i, l) {
            super(), this._renderFrameCallback = () => {
              const u = Math.min((ne() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(u)), u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = l.bearingSnap, this.cameraHelper = i, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, i) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = i
          }
          getCenter() {
            return new s.U(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, i) {
            return this.jumpTo({
              center: e
            }, i)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, i) {
            return this.jumpTo({
              elevation: e
            }, i), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, i, l) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({
              offset: e
            }, i), l)
          }
          panTo(e, i, l) {
            return this.easeTo(s.e({
              center: e
            }, i), l)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, i) {
            return this.jumpTo({
              zoom: e
            }, i), this
          }
          zoomTo(e, i, l) {
            return this.easeTo(s.e({
              zoom: e
            }, i), l)
          }
          zoomIn(e, i) {
            return this.zoomTo(this.getZoom() + 1, e, i), this
          }
          zoomOut(e, i) {
            return this.zoomTo(this.getZoom() - 1, e, i), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, i) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", i)).fire(new s.l("move", i)).fire(new s.l("moveend", i))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, i) {
            return this.jumpTo({
              bearing: e
            }, i), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, i) {
            return this.jumpTo({
              padding: e
            }, i), this
          }
          rotateTo(e, i, l) {
            return this.easeTo(s.e({
              bearing: e
            }, i), l)
          }
          resetNorth(e, i) {
            return this.rotateTo(0, s.e({
              duration: 1e3
            }, e), i), this
          }
          resetNorthPitch(e, i) {
            return this.easeTo(s.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), i), this
          }
          snapToNorth(e, i) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, i) {
            return this.jumpTo({
              pitch: e
            }, i), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, i) {
            return this.jumpTo({
              roll: e
            }, i), this
          }
          cameraForBounds(e, i) {
            e = It.convert(e).adjustAntiMeridian();
            const l = i && i.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), l, i)
          }
          _cameraForBoxAndBearing(e, i, l, u) {
            const d = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(u = s.e({
                padding: d,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, u)).padding == "number") {
              const k = u.padding;
              u.padding = {
                top: k,
                bottom: k,
                right: k,
                left: k
              }
            }
            const g = s.e(d, u.padding);
            u.padding = g;
            const T = this.transform,
              S = new It(e, i);
            return this.cameraHelper.cameraForBoxAndBearing(u, g, S, l, T)
          }
          fitBounds(e, i, l) {
            return this._fitInternal(this.cameraForBounds(e, i), i, l)
          }
          fitScreenCoordinates(e, i, l, u, d) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(i)), l, u), u, d)
          }
          _fitInternal(e, i, l) {
            return e ? (delete(i = s.e(e, i)).padding, i.linear ? this.easeTo(i, l) : this.flyTo(i, l)) : this
          }
          jumpTo(e, i) {
            this.stop();
            const l = this._getTransformForUpdate();
            let u = !1,
              d = !1,
              g = !1;
            const T = l.zoom;
            this.cameraHelper.handleJumpToCenterZoom(l, e);
            const S = l.zoom !== T;
            return "elevation" in e && l.elevation !== +e.elevation && l.setElevation(+e.elevation), "bearing" in e && l.bearing !== +e.bearing && (u = !0, l.setBearing(+e.bearing)), "pitch" in e && l.pitch !== +e.pitch && (d = !0, l.setPitch(+e.pitch)), "roll" in e && l.roll !== +e.roll && (g = !0, l.setRoll(+e.roll)), e.padding == null || l.isPaddingEqual(e.padding) || l.setPadding(e.padding), this._applyUpdatedTransform(l), this.fire(new s.l("movestart", i)).fire(new s.l("move", i)), S && this.fire(new s.l("zoomstart", i)).fire(new s.l("zoom", i)).fire(new s.l("zoomend", i)), u && this.fire(new s.l("rotatestart", i)).fire(new s.l("rotate", i)).fire(new s.l("rotateend", i)), d && this.fire(new s.l("pitchstart", i)).fire(new s.l("pitch", i)).fire(new s.l("pitchend", i)), g && this.fire(new s.l("rollstart", i)).fire(new s.l("roll", i)).fire(new s.l("rollend", i)), this.fire(new s.l("moveend", i))
          }
          calculateCameraOptionsFromTo(e, i, l, u = 0) {
            const d = s.a5.fromLngLat(e, i),
              g = s.a5.fromLngLat(l, u),
              T = g.x - d.x,
              S = g.y - d.y,
              k = g.z - d.z,
              z = Math.hypot(T, S, k);
            if (z === 0) throw new Error("Can't calculate camera options with same From and To");
            const V = Math.hypot(T, S),
              F = s.ao(this.transform.cameraToCenterDistance / z / this.transform.tileSize),
              $ = 180 * Math.atan2(T, -S) / Math.PI;
            let J = 180 * Math.acos(V / z) / Math.PI;
            return J = k < 0 ? 90 - J : 90 + J, {
              center: g.toLngLat(),
              elevation: u,
              zoom: F,
              pitch: J,
              bearing: $
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, i, l, u, d) {
            const g = this.transform.calculateCenterFromCameraLngLatAlt(e, i, l, u);
            return {
              center: g.center,
              elevation: g.elevation,
              zoom: g.zoom,
              bearing: l,
              pitch: u,
              roll: d
            }
          }
          easeTo(e, i) {
            this._stop(!1, e.easeId), ((e = s.e({
              offset: [0, 0],
              duration: 500,
              easing: s.cr
            }, e)).animate === !1 || !e.essential && re.prefersReducedMotion) && (e.duration = 0);
            const l = this._getTransformForUpdate(),
              u = this.getBearing(),
              d = l.pitch,
              g = l.roll,
              T = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              S = "pitch" in e ? +e.pitch : d,
              k = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              z = "padding" in e ? e.padding : l.padding,
              V = s.P.convert(e.offset);
            let F, $;
            e.around && (F = s.U.convert(e.around), $ = l.locationToScreenPoint(F));
            const J = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              ae = this.cameraHelper.handleEaseTo(l, {
                bearing: T,
                pitch: S,
                roll: k,
                padding: z,
                around: F,
                aroundPoint: $,
                offsetAsPoint: V,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || u !== T, this._pitching = this._pitching || S !== d, this._rolling = this._rolling || k !== g, this._padding = !l.isPaddingEqual(z), this._zooming = this._zooming || ae.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, J), this.terrain && this._prepareElevation(ae.elevationCenter), this._ease((oe => {
              ae.easeFunc(oe), this.terrain && !e.freezeElevation && this._updateElevation(oe), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (oe => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, oe)
            }), e), this
          }
          _prepareEase(e, i, l = {}) {
            this._moving = !0, i || l.moving || this.fire(new s.l("movestart", e)), this._zooming && !l.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !l.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !l.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !l.rolling && this.fire(new s.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && i !== this._elevationTarget) {
              const l = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (l - (i - (l * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i
            }
            this.transform.setElevation(s.F.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const i = e.getCameraLngLat(),
              l = e.getCameraAltitude(),
              u = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0;
            if (l < u) {
              const d = this.calculateCameraOptionsFromTo(i, u, e.center, e.elevation);
              return {
                pitch: d.pitch,
                zoom: d.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const i = [];
            if (i.push((u => this._elevateCameraIfInsideTerrain(u))), this.transformCameraUpdate && i.push((u => this.transformCameraUpdate(u))), !i.length) return;
            const l = e.clone();
            for (const u of i) {
              const d = l.clone(),
                {
                  center: g,
                  zoom: T,
                  roll: S,
                  pitch: k,
                  bearing: z,
                  elevation: V
                } = u(d);
              g && d.setCenter(g), V !== void 0 && d.setElevation(V), T !== void 0 && d.setZoom(T), S !== void 0 && d.setRoll(S), k !== void 0 && d.setPitch(k), z !== void 0 && d.setBearing(z), l.apply(d)
            }
            this.transform.apply(l)
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e))
          }
          _afterEase(e, i) {
            if (this._easeId && i && this._easeId === i) return;
            delete this._easeId;
            const l = this._zooming,
              u = this._rotating,
              d = this._pitching,
              g = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, l && this.fire(new s.l("zoomend", e)), u && this.fire(new s.l("rotateend", e)), d && this.fire(new s.l("pitchend", e)), g && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e))
          }
          flyTo(e, i) {
            if (!e.essential && re.prefersReducedMotion) {
              const at = s.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(at, i)
            }
            this.stop(), e = s.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: s.cr
            }, e);
            const l = this._getTransformForUpdate(),
              u = l.bearing,
              d = l.pitch,
              g = l.roll,
              T = l.padding,
              S = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              k = "pitch" in e ? +e.pitch : d,
              z = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              V = "padding" in e ? e.padding : l.padding,
              F = s.P.convert(e.offset);
            let $ = l.centerPoint.add(F);
            const J = l.screenPointToLocation($),
              ae = this.cameraHelper.handleFlyTo(l, {
                bearing: S,
                pitch: k,
                roll: z,
                padding: V,
                locationAtOffset: J,
                offsetAsPoint: F,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let oe = e.curve;
            const se = Math.max(l.width, l.height),
              fe = se / ae.scaleOfZoom,
              xe = ae.pixelPathLength;
            typeof ae.scaleOfMinZoom == "number" && (oe = Math.sqrt(se / ae.scaleOfMinZoom / xe * 2));
            const pe = oe * oe;

            function be(at) {
              const Gt = (fe * fe - se * se + (at ? -1 : 1) * pe * pe * xe * xe) / (2 * (at ? fe : se) * pe * xe);
              return Math.log(Math.sqrt(Gt * Gt + 1) - Gt)
            }

            function Pe(at) {
              return (Math.exp(at) - Math.exp(-at)) / 2
            }

            function ge(at) {
              return (Math.exp(at) + Math.exp(-at)) / 2
            }
            const Fe = be(!1);
            let nt = function(at) {
                return ge(Fe) / ge(Fe + oe * at)
              },
              et = function(at) {
                return se * ((ge(Fe) * (Pe(Gt = Fe + oe * at) / ge(Gt)) - Pe(Fe)) / pe) / xe;
                var Gt
              },
              rt = (be(!0) - Fe) / oe;
            if (Math.abs(xe) < 2e-6 || !isFinite(rt)) {
              if (Math.abs(se - fe) < 1e-6) return this.easeTo(e, i);
              const at = fe < se ? -1 : 1;
              rt = Math.abs(Math.log(fe / se)) / oe, et = () => 0, nt = Gt => Math.exp(at * oe * Gt)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * rt / ("screenSpeed" in e ? +e.screenSpeed / oe : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = u !== S, this._pitching = k !== d, this._rolling = z !== g, this._padding = !l.isPaddingEqual(V), this._prepareEase(i, !1), this.terrain && this._prepareElevation(ae.targetCenter), this._ease((at => {
              const Gt = at * rt,
                Ht = 1 / nt(Gt),
                Pt = et(Gt);
              this._rotating && l.setBearing(s.F.number(u, S, at)), this._pitching && l.setPitch(s.F.number(d, k, at)), this._rolling && l.setRoll(s.F.number(g, z, at)), this._padding && (l.interpolatePadding(T, V, at), $ = l.centerPoint.add(F)), ae.easeFunc(at, Ht, Pt, $), this.terrain && !e.freezeElevation && this._updateElevation(at), this._applyUpdatedTransform(l), this._fireMoveEvents(i)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, i) {
            var l;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const u = this._onEaseEnd;
              delete this._onEaseEnd, u.call(this, i)
            }
            return e || (l = this.handlers) === null || l === void 0 || l.stop(!1), this
          }
          _ease(e, i, l) {
            l.animate === !1 || l.duration === 0 ? (e(1), i()) : (this._easeStart = ne(), this._easeOptions = l, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, i) {
            e = s.V(e, -180, 180);
            const l = Math.abs(e - i);
            return Math.abs(e - 360 - i) < l && (e -= 360), Math.abs(e + 360 - i) < l && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.U.convert(e), this.transform.tileZoom) : null
          }
        }
        const il = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class Zi {
          constructor(e = il) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = i => {
              !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = Y.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = Y.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = Y.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            Y.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, i) {
            const l = this._map._getUIString(`AttributionControl.${i}`);
            e.title = l, e.setAttribute("aria-label", l)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((u => typeof u != "string" ? "" : u))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const u = this._map.style.stylesheet;
              this.styleOwner = u.owner, this.styleId = u.id
            }
            const i = this._map.style.tileManagers;
            for (const u in i) {
              const d = i[u];
              if (d.used || d.usedForTerrain) {
                const g = d.getSource();
                g.attribution && e.indexOf(g.attribution) < 0 && e.push(g.attribution)
              }
            }
            e = e.filter((u => String(u).trim())), e.sort(((u, d) => u.length - d.length)), e = e.filter(((u, d) => {
              for (let g = d + 1; g < e.length; g++)
                if (e[g].indexOf(u) >= 0) return !1;
              return !0
            }));
            const l = e.join(" | ");
            l !== this._attribHTML && (this._attribHTML = l, e.length ? (this._innerContainer.innerHTML = Y.sanitize(l), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class Tu {
          constructor(e = {}) {
            this._updateCompact = () => {
              const i = this._container.children;
              if (i.length) {
                const l = i[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && l.classList.add("maplibregl-compact") : l.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = Y.create("div", "maplibregl-ctrl");
            const i = Y.create("a", "maplibregl-ctrl-logo");
            return i.target = "_blank", i.rel = "noopener nofollow", i.href = "https://maplibre.org/", i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), i.setAttribute("rel", "noopener nofollow"), this._container.appendChild(i), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            Y.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Ia {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const i = ++this._id;
            return this._queue.push({
              callback: e,
              id: i,
              cancelled: !1
            }), i
          }
          remove(e) {
            const i = this._currentlyRunning,
              l = i ? this._queue.concat(i) : this._queue;
            for (const u of l)
              if (u.id === e) return void(u.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const i = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const l of i)
              if (!l.cancelled && (l.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var $d = s.aN([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class bf extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = ne(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null
          }
          getSource() {
            return this.tileManager._source
          }
          update(e, i) {
            this.tileManager.update(e, i), this._renderableTilesKeys = [];
            const l = {};
            for (const u of qr(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: i,
                calculateTileZoom: this.tileManager._source.calculateTileZoom
              })) l[u.key] = !0, this._renderableTilesKeys.push(u.key), this._tiles[u.key] || (u.terrainRttPosMatrix32f = new Float64Array(16), s.c0(u.terrainRttPosMatrix32f, 0, s.a3, s.a3, 0, 0, 1), this._tiles[u.key] = new W(u, this.tileSize), this._lastTilesetChange = ne());
            for (const u in this._tiles) l[u] || delete this._tiles[u]
          }
          freeRtt(e) {
            for (const i in this._tiles) {
              const l = this._tiles[i];
              (!e || l.tileID.equals(e) || l.tileID.isChildOf(e) || e.isChildOf(l.tileID)) && (l.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, i) {
            return i ? this._getTerrainCoordsForTileRanges(e, i) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const i = {};
            for (const l of this._renderableTilesKeys) {
              const u = this._tiles[l].tileID,
                d = e.clone(),
                g = s.bd();
              if (u.canonical.equals(e.canonical)) s.c0(g, 0, s.a3, s.a3, 0, 0, 1);
              else if (u.canonical.isChildOf(e.canonical)) {
                const T = u.canonical.z - e.canonical.z,
                  S = u.canonical.x - (u.canonical.x >> T << T),
                  k = u.canonical.y - (u.canonical.y >> T << T),
                  z = s.a3 >> T;
                s.c0(g, 0, z, z, 0, 0, 1), s.N(g, g, [-S * z, -k * z, 0])
              } else {
                if (!e.canonical.isChildOf(u.canonical)) continue;
                {
                  const T = e.canonical.z - u.canonical.z,
                    S = e.canonical.x - (e.canonical.x >> T << T),
                    k = e.canonical.y - (e.canonical.y >> T << T),
                    z = s.a3 >> T;
                  s.c0(g, 0, s.a3, s.a3, 0, 0, 1), s.N(g, g, [S * z, k * z, 0]), s.O(g, g, [1 / 2 ** T, 1 / 2 ** T, 0])
                }
              }
              d.terrainRttPosMatrix32f = new Float32Array(g), i[l] = d
            }
            return i
          }
          _getTerrainCoordsForTileRanges(e, i) {
            const l = {};
            for (const u of this._renderableTilesKeys) {
              const d = this._tiles[u].tileID;
              if (!this._isWithinTileRanges(d, i)) continue;
              const g = e.clone(),
                T = s.bd();
              if (d.canonical.z === e.canonical.z) {
                const S = e.canonical.x - d.canonical.x,
                  k = e.canonical.y - d.canonical.y;
                s.c0(T, 0, s.a3, s.a3, 0, 0, 1), s.N(T, T, [S * s.a3, k * s.a3, 0])
              } else if (d.canonical.z > e.canonical.z) {
                const S = d.canonical.z - e.canonical.z,
                  k = d.canonical.x - (d.canonical.x >> S << S),
                  z = d.canonical.y - (d.canonical.y >> S << S),
                  V = e.canonical.x - (d.canonical.x >> S),
                  F = e.canonical.y - (d.canonical.y >> S),
                  $ = s.a3 >> S;
                s.c0(T, 0, $, $, 0, 0, 1), s.N(T, T, [-k * $ + V * s.a3, -z * $ + F * s.a3, 0])
              } else {
                const S = e.canonical.z - d.canonical.z,
                  k = e.canonical.x - (e.canonical.x >> S << S),
                  z = e.canonical.y - (e.canonical.y >> S << S),
                  V = (e.canonical.x >> S) - d.canonical.x,
                  F = (e.canonical.y >> S) - d.canonical.y,
                  $ = s.a3 << S;
                s.c0(T, 0, $, $, 0, 0, 1), s.N(T, T, [k * s.a3 + V * $, z * s.a3 + F * $, 0])
              }
              g.terrainRttPosMatrix32f = new Float32Array(T), l[u] = g
            }
            return l
          }
          getSourceTile(e, i) {
            const l = this.tileManager._source;
            let u = e.overscaledZ - this.deltaZoom;
            if (u > l.maxzoom && (u = l.maxzoom), u < l.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(u).key);
            let d = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!d || !d.dem) && i)
              for (; u >= l.minzoom && (!d || !d.dem);) d = this.tileManager.getTileByID(e.scaledTo(u--).key);
            return d
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, i) {
            return i[e.canonical.z] && e.canonical.x >= i[e.canonical.z].minTileX && e.canonical.x <= i[e.canonical.z].maxTileX && e.canonical.y >= i[e.canonical.z].minTileY && e.canonical.y <= i[e.canonical.z].maxTileY
          }
        }
        class wf {
          constructor(e, i, l) {
            this._meshCache = {}, this.painter = e, this.tileManager = new bf(i), this.options = l, this.exaggeration = typeof l.exaggeration == "number" ? l.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, i, l, u = s.a3) {
            var d;
            if (!(i >= 0 && i < u && l >= 0 && l < u)) return 0;
            const g = this.getTerrainData(e),
              T = (d = g.tile) === null || d === void 0 ? void 0 : d.dem;
            if (!T) return 0;
            const S = s.cv([], [i / u * s.a3, l / u * s.a3], g.u_terrain_matrix),
              k = [S[0] * T.dim, S[1] * T.dim],
              z = Math.floor(k[0]),
              V = Math.floor(k[1]),
              F = k[0] - z,
              $ = k[1] - V;
            return T.get(z, V) * (1 - F) * (1 - $) + T.get(z + 1, V) * F * (1 - $) + T.get(z, V + 1) * (1 - F) * $ + T.get(z + 1, V + 1) * F * $
          }
          getElevationForLngLatZoom(e, i) {
            if (!s.cw(i, e.wrap())) return 0;
            const {
              tileID: l,
              mercatorX: u,
              mercatorY: d
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return this.getElevation(l, u % s.a3, d % s.a3, s.a3)
          }
          getElevation(e, i, l, u = s.a3) {
            return this.getDEMElevation(e, i, l, u) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const u = this.painter.context,
                d = new s.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(u, d, u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(u, new s.R({
                width: 1,
                height: 1
              }), u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.am([])
            }
            const i = this.tileManager.getSourceTile(e, !0);
            if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
              const u = this.painter.context;
              i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), {
                premultiply: !1
              }) : i.demTexture = new s.T(u, i.dem.getPixels(), u.gl.RGBA, {
                premultiply: !1
              }), i.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1
            }
            const l = i && i + i.tileID.key + e.key;
            if (l && !this._demMatrixCache[l]) {
              const u = this.tileManager.getSource().maxzoom;
              let d = e.canonical.z - i.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= u ? d = e.canonical.z - u : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const g = e.canonical.x - (e.canonical.x >> d << d),
                T = e.canonical.y - (e.canonical.y >> d << d),
                S = s.cx(new Float64Array(16), [1 / (s.a3 << d), 1 / (s.a3 << d), 0]);
              s.N(S, S, [g * s.a3, T * s.a3, 0]), this._demMatrixCache[e.key] = {
                matrix: S,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: i && i.dem && i.dem.dim || 1,
              u_terrain_matrix: l ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (i && i.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: i
            }
          }
          getFramebuffer(e) {
            const i = this.painter,
              l = i.width / devicePixelRatio,
              u = i.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === l && this._fbo.height === u || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(i.context, {
              width: l,
              height: u,
              data: null
            }, i.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i.context.createFramebuffer(l, u, !0, !1), this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, l, u))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let d = 0, g = 0; d < this._coordsTextureSize; d++)
              for (let T = 0; T < this._coordsTextureSize; T++, g += 4) i[g + 0] = 255 & T, i[g + 1] = 255 & d, i[g + 2] = T >> 8 << 4 | d >> 8, i[g + 3] = 0;
            const l = new s.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(i.buffer)),
              u = new s.T(e, l, e.gl.RGBA, {
                premultiply: !1
              });
            return u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = u, u
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl,
              d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              g = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              T = Math.round(this.painter.height / devicePixelRatio);
            l.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), u.readPixels(d, T - g - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null);
            const S = i[0] + (i[2] >> 4 << 8),
              k = i[1] + ((15 & i[2]) << 8),
              z = this.coordsIndex[255 - i[3]],
              V = z && this.tileManager.getTileByID(z);
            if (!V) return null;
            const F = this._coordsTextureSize,
              $ = (1 << V.tileID.canonical.z) * F;
            return new s.a5((V.tileID.canonical.x * F + S) / $ + V.tileID.wrap, (V.tileID.canonical.y * F + k) / $, this.getElevation(V.tileID, S, k, F))
          }
          depthAtPoint(e) {
            const i = new Uint8Array(4),
              l = this.painter.context,
              u = l.gl;
            return l.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), u.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, i), l.bindFramebuffer.set(null), (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
          }
          getTerrainMesh(e) {
            var i;
            const l = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0,
              u = l && e.canonical.y === 0,
              d = l && e.canonical.y === (1 << e.canonical.z) - 1,
              g = `m_${u?"n":""}_${d?"s":""}`;
            if (this._meshCache[g]) return this._meshCache[g];
            const T = this.painter.context,
              S = new s.cy,
              k = new s.aR,
              z = this.meshSize,
              V = s.a3 / z,
              F = z * z;
            for (let ge = 0; ge <= z; ge++)
              for (let Fe = 0; Fe <= z; Fe++) S.emplaceBack(Fe * V, ge * V, 0);
            for (let ge = 0; ge < F; ge += z + 1)
              for (let Fe = 0; Fe < z; Fe++) k.emplaceBack(Fe + ge, z + Fe + ge + 1, z + Fe + ge + 2), k.emplaceBack(Fe + ge, z + Fe + ge + 2, Fe + ge + 1);
            const $ = S.length,
              J = $ + (z + 1),
              ae = (z + 1) * z,
              oe = u ? s.bk : 0,
              se = u ? 0 : 1,
              fe = d ? s.bl : s.a3,
              xe = d ? 0 : 1;
            for (let ge = 0; ge <= z; ge++) S.emplaceBack(ge * V, oe, se);
            for (let ge = 0; ge <= z; ge++) S.emplaceBack(ge * V, fe, xe);
            for (let ge = 0; ge < z; ge++) k.emplaceBack(ae + ge, J + ge, J + ge + 1), k.emplaceBack(ae + ge, J + ge + 1, ae + ge + 1), k.emplaceBack(0 + ge, $ + ge + 1, $ + ge), k.emplaceBack(0 + ge, 0 + ge + 1, $ + ge + 1);
            const pe = S.length,
              be = pe + 2 * (z + 1);
            for (const ge of [0, 1])
              for (let Fe = 0; Fe <= z; Fe++)
                for (const nt of [0, 1]) S.emplaceBack(ge * s.a3, Fe * V, nt);
            for (let ge = 0; ge < 2 * z; ge += 2) k.emplaceBack(pe + ge, pe + ge + 1, pe + ge + 3), k.emplaceBack(pe + ge, pe + ge + 3, pe + ge + 2), k.emplaceBack(be + ge, be + ge + 3, be + ge + 1), k.emplaceBack(be + ge, be + ge + 2, be + ge + 3);
            const Pe = new ri(T.createVertexBuffer(S, $d.members), T.createIndexBuffer(k), s.aQ.simpleSegment(0, 0, S.length, k.length));
            return this._meshCache[g] = Pe, Pe
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bx / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, i) {
            var l;
            const {
              tileID: u
            } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return (l = this.getMinMaxElevation(u).minElevation) !== null && l !== void 0 ? l : 0
          }
          getMinMaxElevation(e) {
            const i = this.getTerrainData(e).tile,
              l = {
                minElevation: null,
                maxElevation: null
              };
            return i && i.dem && (l.minElevation = i.dem.min * this.exaggeration, l.maxElevation = i.dem.max * this.exaggeration), l
          }
          _getOverscaledTileIDFromLngLatZoom(e, i) {
            const l = s.a5.fromLngLat(e.wrap()),
              u = (1 << i) * s.a3,
              d = l.x * u,
              g = l.y * u,
              T = Math.floor(d / s.a3),
              S = Math.floor(g / s.a3);
            return {
              tileID: new s.a0(i, 0, i, T, S),
              mercatorX: d,
              mercatorY: g
            }
          }
        }
        class Tf {
          constructor(e, i, l) {
            this._context = e, this._size = i, this._tileSize = l, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              l = new s.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return l.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i.colorAttachment.set(l.texture), {
              id: e,
              fbo: i,
              texture: l,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((i => e.id !== i)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const i of this._recentlyUsed)
              if (!this._objects[i].inUse) return this._objects[i];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const Ua = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class Jn {
          constructor(e, i) {
            this.painter = e, this.terrain = i, this.pool = new Tf(e.context, 30, i.tileManager.tileSize * i.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, i) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter((l => !e._layers[l].isHidden(i))), this._coordsAscending = {};
            for (const l in e.tileManagers) {
              this._coordsAscending[l] = {};
              const u = e.tileManagers[l].getVisibleCoordinates(),
                d = e.tileManagers[l].getSource(),
                g = d instanceof rr ? d.terrainTileRanges : null;
              for (const T of u) {
                const S = this.terrain.tileManager.getTerrainCoords(T, g);
                for (const k in S) this._coordsAscending[l][k] || (this._coordsAscending[l][k] = []), this._coordsAscending[l][k].push(S[k])
              }
            }
            this._coordsAscendingStr = {};
            for (const l of e._order) {
              const u = e._layers[l],
                d = u.source;
              if (Ua[u.type] && !this._coordsAscendingStr[d]) {
                this._coordsAscendingStr[d] = {};
                for (const g in this._coordsAscending[d]) this._coordsAscendingStr[d][g] = this._coordsAscending[d][g].map((T => T.key)).sort().join()
              }
            }
            for (const l of this._renderableTiles)
              for (const u in this._coordsAscendingStr) {
                const d = this._coordsAscendingStr[u][l.tileID.key];
                d && d !== l.rttCoords[u] && (l.rtt = [])
              }
          }
          renderLayer(e, i) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const l = Object.assign(Object.assign({}, i), {
                isRenderingToTexture: !0
              }),
              u = e.type,
              d = this.painter,
              g = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (Ua[u] && (this._prevType && Ua[this._prevType] || this._stacks.push([]), this._prevType = u, this._stacks[this._stacks.length - 1].push(e.id), !g)) return !0;
            if (Ua[this._prevType] || Ua[u] && g) {
              this._prevType = u;
              const T = this._stacks.length - 1,
                S = this._stacks[T] || [];
              for (const k of this._renderableTiles) {
                if (this.pool.isFull() && (hu(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(k), k.rtt[T]) {
                  const V = this.pool.getObjectForId(k.rtt[T].id);
                  if (V.stamp === k.rtt[T].stamp) {
                    this.pool.useObject(V);
                    continue
                  }
                }
                const z = this.pool.getOrCreateFreeObject();
                this.pool.useObject(z), this.pool.stampObject(z), k.rtt[T] = {
                  id: z.id,
                  stamp: z.stamp
                }, d.context.bindFramebuffer.set(z.fbo.framebuffer), d.context.clear({
                  color: s.bi.transparent,
                  stencil: 0
                }), d.currentStencilSource = void 0;
                for (let V = 0; V < S.length; V++) {
                  const F = d.style._layers[S[V]],
                    $ = F.source ? this._coordsAscending[F.source][k.tileID.key] : [k.tileID];
                  d.context.viewport.set([0, 0, z.fbo.width, z.fbo.height]), d._renderTileClippingMasks(F, $, !0), d.renderLayer(d, d.style.tileManagers[F.source], F, $, l), F.source && (k.rttCoords[F.source] = this._coordsAscendingStr[F.source][k.tileID.key])
                }
              }
              return hu(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects(), Ua[u]
            }
            return !1
          }
        }
        const si = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use ‚åò + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Hd = B,
          Ts = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: il,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          Jl = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class Su {
          constructor(e, i, l = !1) {
            this.mousedown = d => {
              this.startMove(d, Y.mousePos(this.element, d)), Y.addEventListener(window, "mousemove", this.mousemove), Y.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = d => {
              this.move(d, Y.mousePos(this.element, d))
            }, this.mouseup = d => {
              this._rotatePitchHandler.dragEnd(d), this.offTemp()
            }, this.touchstart = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Y.touchPos(this.element, d.targetTouches)[0], this.startMove(d, this._startPos), Y.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), Y.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Y.touchPos(this.element, d.targetTouches)[0], this.move(d, this._lastPos))
            }, this.touchend = d => {
              d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = i;
            const u = new _u;
            this._rotatePitchHandler = new sr({
              clickTolerance: 3,
              move: (d, g) => {
                const T = i.getBoundingClientRect(),
                  S = new s.P((T.bottom - T.top) / 2, (T.right - T.left) / 2);
                return {
                  bearingDelta: s.cq(new s.P(d.x, g.y), g, S),
                  pitchDelta: l ? -.5 * (g.y - d.y) : void 0
                }
              },
              moveStateManager: u,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, Y.addEventListener(i, "mousedown", this.mousedown), Y.addEventListener(i, "touchstart", this.touchstart, {
              passive: !1
            }), Y.addEventListener(i, "touchcancel", this.reset)
          }
          startMove(e, i) {
            this._rotatePitchHandler.dragStart(e, i), Y.disableDrag()
          }
          move(e, i) {
            const l = this.map,
              {
                bearingDelta: u,
                pitchDelta: d
              } = this._rotatePitchHandler.dragMove(e, i) || {};
            u && l.setBearing(l.getBearing() + u), d && l.setPitch(l.getPitch() + d)
          }
          off() {
            const e = this.element;
            Y.removeEventListener(e, "mousedown", this.mousedown), Y.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), Y.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), Y.removeEventListener(window, "touchend", this.touchend), Y.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            Y.enableDrag(), Y.removeEventListener(window, "mousemove", this.mousemove), Y.removeEventListener(window, "mouseup", this.mouseup), Y.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), Y.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let io;

        function Ql(h, e, i, l = !1) {
          if (l || !i.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
          const u = new s.U(h.lng, h.lat);
          if (h = new s.U(h.lng, h.lat), e) {
            const d = new s.U(h.lng - 360, h.lat),
              g = new s.U(h.lng + 360, h.lat),
              T = i.locationToScreenPoint(h).distSqr(e);
            i.locationToScreenPoint(d).distSqr(e) < T ? h = d : i.locationToScreenPoint(g).distSqr(e) < T && (h = g)
          }
          for (; Math.abs(h.lng - i.center.lng) > 180;) {
            const d = i.locationToScreenPoint(h);
            if (d.x >= 0 && d.y >= 0 && d.x <= i.width && d.y <= i.height) break;
            h.lng > i.center.lng ? h.lng -= 360 : h.lng += 360
          }
          return h.lng !== u.lng && i.isPointOnMapSurface(i.locationToScreenPoint(h)) ? h : u
        }
        const Go = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function ec(h, e, i) {
          const l = h.classList;
          for (const u in Go) l.remove(`maplibregl-${i}-anchor-${u}`);
          l.add(`maplibregl-${i}-anchor-${e}`)
        }
        class al extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = i => {
                const l = i.code,
                  u = i.charCode || i.keyCode;
                l !== "Space" && l !== "Enter" && u !== 32 && u !== 13 || this.togglePopup()
              }, this._onMapClick = i => {
                const l = i.originalEvent.target,
                  u = this._element;
                this._popup && (l === u || u.contains(l)) && this.togglePopup()
              }, this._update = i => {
                if (!this._map) return;
                const l = this._map.loaded() && !this._map.isMoving();
                ((i == null ? void 0 : i.type) === "terrain" || (i == null ? void 0 : i.type) === "render" && !l) && this._map.once("render", this._update), this._lngLat = Ql(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let u = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let d = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()), Y.setTransform(this._element, `${Go[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${u}`), re.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(i && i.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = i => {
                if (!this._isDragging) {
                  const l = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = i.point.dist(this._pointerdownPos) >= l
                }
                this._isDragging && (this._pos = i.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = i => {
                this._element.contains(i.originalEvent.target) && (i.preventDefault(), this._positionDelta = i.point.sub(this._pos).add(this._offset), this._pointerdownPos = i.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = Y.create("div");
              const i = Y.createNS("http://www.w3.org/2000/svg", "svg"),
                l = 41,
                u = 27;
              i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${l}px`), i.setAttributeNS(null, "width", `${u}px`), i.setAttributeNS(null, "viewBox", `0 0 ${u} ${l}`);
              const d = Y.createNS("http://www.w3.org/2000/svg", "g");
              d.setAttributeNS(null, "stroke", "none"), d.setAttributeNS(null, "stroke-width", "1"), d.setAttributeNS(null, "fill", "none"), d.setAttributeNS(null, "fill-rule", "evenodd");
              const g = Y.createNS("http://www.w3.org/2000/svg", "g");
              g.setAttributeNS(null, "fill-rule", "nonzero");
              const T = Y.createNS("http://www.w3.org/2000/svg", "g");
              T.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), T.setAttributeNS(null, "fill", "#000000");
              const S = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const se of S) {
                const fe = Y.createNS("http://www.w3.org/2000/svg", "ellipse");
                fe.setAttributeNS(null, "opacity", "0.04"), fe.setAttributeNS(null, "cx", "10.5"), fe.setAttributeNS(null, "cy", "5.80029008"), fe.setAttributeNS(null, "rx", se.rx), fe.setAttributeNS(null, "ry", se.ry), T.appendChild(fe)
              }
              const k = Y.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "fill", this._color);
              const z = Y.createNS("http://www.w3.org/2000/svg", "path");
              z.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), k.appendChild(z);
              const V = Y.createNS("http://www.w3.org/2000/svg", "g");
              V.setAttributeNS(null, "opacity", "0.25"), V.setAttributeNS(null, "fill", "#000000");
              const F = Y.createNS("http://www.w3.org/2000/svg", "path");
              F.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), V.appendChild(F);
              const $ = Y.createNS("http://www.w3.org/2000/svg", "g");
              $.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), $.setAttributeNS(null, "fill", "#FFFFFF");
              const J = Y.createNS("http://www.w3.org/2000/svg", "g");
              J.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const ae = Y.createNS("http://www.w3.org/2000/svg", "circle");
              ae.setAttributeNS(null, "fill", "#000000"), ae.setAttributeNS(null, "opacity", "0.25"), ae.setAttributeNS(null, "cx", "5.5"), ae.setAttributeNS(null, "cy", "5.5"), ae.setAttributeNS(null, "r", "5.4999962");
              const oe = Y.createNS("http://www.w3.org/2000/svg", "circle");
              oe.setAttributeNS(null, "fill", "#FFFFFF"), oe.setAttributeNS(null, "cx", "5.5"), oe.setAttributeNS(null, "cy", "5.5"), oe.setAttributeNS(null, "r", "5.4999962"), J.appendChild(ae), J.appendChild(oe), g.appendChild(T), g.appendChild(k), g.appendChild(V), g.appendChild($), g.appendChild(J), i.appendChild(g), i.setAttributeNS(null, "height", l * this._scale + "px"), i.setAttributeNS(null, "width", u * this._scale + "px"), this._element.appendChild(i), this._offset = s.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i => {
                i.preventDefault()
              })), this._element.addEventListener("mousedown", (i => {
                i.preventDefault()
              })), ec(this._element, this._anchor, "marker"), e && e.className)
              for (const i of e.className.split(" ")) this._element.classList.add(i);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), Y.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = s.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const u = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                  "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var i, l;
            const u = (i = this._map) === null || i === void 0 ? void 0 : i.terrain,
              d = this._map.transform.isLocationOccluded(this._lngLat);
            if (!u || d) {
              const $ = d ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== $ && (this._element.style.opacity = $))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const g = this._map,
              T = g.terrain.depthAtPoint(this._pos),
              S = g.terrain.getElevationForLngLatZoom(this._lngLat, g.transform.tileZoom);
            if (g.transform.lngLatToCameraDepth(this._lngLat, S) - T < .006) return void(this._element.style.opacity = this._opacity);
            const k = -this._offset.y / g.transform.pixelsPerMeter,
              z = Math.sin(g.getPitch() * Math.PI / 180) * k,
              V = g.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)),
              F = g.transform.lngLatToCameraDepth(this._lngLat, S + z) - V > .006;
            !((l = this._popup) === null || l === void 0) && l.isOpen() && F && this._popup.remove(), this._element.style.opacity = F ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, i) {
            return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(!0), this
          }
        }
        const Cu = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let Ss = 0,
          $o = !1;
        const Pu = {
          maxWidth: 100,
          unit: "metric"
        };

        function tc(h, e, i) {
          const l = i && i.maxWidth || 100,
            u = h._container.clientHeight / 2,
            d = h._container.clientWidth / 2,
            g = h.unproject([d - l / 2, u]),
            T = h.unproject([d + l / 2, u]),
            S = Math.round(h.project(T).x - h.project(g).x),
            k = Math.min(l, S, h._container.clientWidth),
            z = g.distanceTo(T);
          if (i && i.unit === "imperial") {
            const V = 3.2808 * z;
            V > 5280 ? Ho(e, k, V / 5280, h._getUIString("ScaleControl.Miles")) : Ho(e, k, V, h._getUIString("ScaleControl.Feet"))
          } else i && i.unit === "nautical" ? Ho(e, k, z / 1852, h._getUIString("ScaleControl.NauticalMiles")) : z >= 1e3 ? Ho(e, k, z / 1e3, h._getUIString("ScaleControl.Kilometers")) : Ho(e, k, z, h._getUIString("ScaleControl.Meters"))
        }

        function Ho(h, e, i, l) {
          const u = (function(d) {
            const g = Math.pow(10, `${Math.floor(d)}`.length - 1);
            let T = d / g;
            return T = T >= 10 ? 10 : T >= 5 ? 5 : T >= 3 ? 3 : T >= 2 ? 2 : T >= 1 ? 1 : (function(S) {
              const k = Math.pow(10, Math.ceil(-Math.log(S) / Math.LN10));
              return Math.round(S * k) / k
            })(T), g * T
          })(i);
          h.style.width = e * (u / i) + "px", h.innerHTML = `${u}&nbsp;${l}`
        }
        const Iu = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          rc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function nc(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return {
                center: new s.P(0, 0),
                top: new s.P(0, h),
                "top-left": new s.P(e, e),
                "top-right": new s.P(-e, e),
                bottom: new s.P(0, -h),
                "bottom-left": new s.P(e, -e),
                "bottom-right": new s.P(-e, -e),
                left: new s.P(h, 0),
                right: new s.P(-h, 0)
              }
            }
            if (h instanceof s.P || Array.isArray(h)) {
              const e = s.P.convert(h);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: s.P.convert(h.center || [0, 0]),
              top: s.P.convert(h.top || [0, 0]),
              "top-left": s.P.convert(h["top-left"] || [0, 0]),
              "top-right": s.P.convert(h["top-right"] || [0, 0]),
              bottom: s.P.convert(h.bottom || [0, 0]),
              "bottom-left": s.P.convert(h["bottom-left"] || [0, 0]),
              "bottom-right": s.P.convert(h["bottom-right"] || [0, 0]),
              left: s.P.convert(h.left || [0, 0]),
              right: s.P.convert(h.right || [0, 0])
            }
          }
          return nc(new s.P(0, 0))
        }
        const Mu = B;
        w.AJAXError = s.cC, w.Event = s.l, w.Evented = s.E, w.LngLat = s.U, w.MercatorCoordinate = s.a5, w.Point = s.P, w.addProtocol = s.cD, w.config = s.a, w.removeProtocol = s.cE, w.AttributionControl = Zi, w.BoxZoomHandler = Ld, w.CanvasSource = nr, w.CooperativeGesturesHandler = Pa, w.DoubleClickZoomHandler = rl, w.DragPanHandler = bu, w.DragRotateHandler = wu, w.EdgeInsets = vn, w.FullscreenControl = class extends s.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = i == null ? void 0 : i.shadowRoot) === null || e === void 0) && e.fullscreenElement;) i = i.shadowRoot.fullscreenElement;
              i === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            Y.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const h = this._fullscreenButton = Y.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            Y.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, w.GeoJSONSource = _r, w.GeolocateControl = class extends s.E {
          constructor(h) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const i = new s.U(e.coords.longitude, e.coords.latitude),
                l = e.coords.accuracy,
                u = this._map.getBearing(),
                d = s.e({
                  bearing: u
                }, this.options.fitBoundsOptions),
                g = It.fromLngLat(i, l);
              this._map.fitBounds(g, d, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const i = new s.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && $o) return;
                  this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = Y.create("button", "maplibregl-ctrl-geolocate", this._container), Y.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                } else {
                  const i = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Y.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new al({
                  element: this._dotElement
                }), this._circleElement = Y.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new al({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (i => {
                  const l = (i == null ? void 0 : i[0]) instanceof ResizeObserverEntry;
                  i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || l || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")))
                }))
              }
            }, this.options = s.e({}, Cu, h)
          }
          onAdd(h) {
            return this._map = h, this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function*(e = !1) {
                if (io !== void 0 && !e) return io;
                if (window.navigator.permissions === void 0) return io = !!window.navigator.geolocation, io;
                try {
                  io = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  io = !!window.navigator.geolocation
                }
                return io
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), Y.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Ss = 0, $o = !1
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(),
              i = h.coords;
            return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadiusIfNeeded() {
            const h = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && h)) return;
            const e = this._map.project(h),
              i = this._map.unproject([e.x + 100, e.y]),
              l = h.distanceTo(i) / 100,
              u = 2 * this._accuracy / l;
            this._circleElement.style.width = `${u.toFixed(2)}px`, this._circleElement.style.height = `${u.toFixed(2)}px`
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ss--, $o = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ss++, Ss > 1 ? (h = {
                  maximumAge: 6e5,
                  timeout: 0
                }, $o = !0) : (h = this.options.positionOptions, $o = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, w.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(h) {
            return this._map = h, this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = Y.create("button", "maplibregl-ctrl-globe", this._container), Y.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            Y.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, w.Hash = pu, w.ImageSource = rr, w.KeyboardHandler = Vd, w.LngLatBounds = It, w.LogoControl = Tu, w.Map = class extends Gd {
          constructor(h) {
            var e, i;
            s.cz.mark(s.cA.create);
            const l = Object.assign(Object.assign(Object.assign({}, Ts), h), {
              canvasContextAttributes: Object.assign(Object.assign({}, Ts.canvasContextAttributes), h.canvasContextAttributes)
            });
            if (l.minZoom != null && l.maxZoom != null && l.minZoom > l.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (l.minPitch != null && l.maxPitch != null && l.minPitch > l.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (l.minPitch != null && l.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (l.maxPitch != null && l.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const u = new Pi,
              d = new ca;
            if (l.minZoom !== void 0 && u.setMinZoom(l.minZoom), l.maxZoom !== void 0 && u.setMaxZoom(l.maxZoom), l.minPitch !== void 0 && u.setMinPitch(l.minPitch), l.maxPitch !== void 0 && u.setMaxPitch(l.maxPitch), l.renderWorldCopies !== void 0 && u.setRenderWorldCopies(l.renderWorldCopies), l.transformConstrain !== null && u.setConstrain(l.transformConstrain), super(u, d, {
                bearingSnap: l.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Ia, this._controls = [], this._mapId = s.ab(), this._contextLost = T => {
                T.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", {
                  originalEvent: T
                }))
              }, this._contextRestored = T => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", {
                  originalEvent: T
                }))
              }, this._onMapScroll = T => {
                if (T.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = l.interactive, this._maxTileCacheSize = l.maxTileCacheSize, this._maxTileCacheZoomLevels = l.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, l.canvasContextAttributes), this._trackResize = l.trackResize === !0, this._bearingSnap = l.bearingSnap, this._centerClampedToGround = l.centerClampedToGround, this._refreshExpiredTiles = l.refreshExpiredTiles === !0, this._fadeDuration = l.fadeDuration, this._crossSourceCollisions = l.crossSourceCollisions === !0, this._collectResourceTiming = l.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, si), l.locale), this._clickTolerance = l.clickTolerance, this._overridePixelRatio = l.pixelRatio, this._maxCanvasSize = l.maxCanvasSize, this.transformCameraUpdate = l.transformCameraUpdate, this.transformConstrain = l.transformConstrain, this.cancelPendingTileRequestsWhileZooming = l.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = $e.addThrottleControl((() => this.isMoving())), this._requestManager = new Be(l.transformRequest), typeof l.container == "string") {
              if (this._container = document.getElementById(l.container), !this._container) throw new Error(`Container '${l.container}' not found.`)
            } else {
              if (!(l.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = l.container
            }
            if (l.maxBounds && this.setMaxBounds(l.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let T = !1;
              const S = du((k => {
                this._trackResize && !this._removed && (this.resize(k), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((k => {
                T ? S(k) : T = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new nl(this, l), this._hash = l.hash && new pu(typeof l.hash == "string" && l.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: l.center,
              elevation: l.elevation,
              zoom: l.zoom,
              bearing: l.bearing,
              pitch: l.pitch,
              roll: l.roll
            }), l.bounds && (this.resize(), this.fitBounds(l.bounds, s.e({}, l.fitBoundsOptions, {
              duration: 0
            }))));
            const g = typeof l.style == "string" || ((i = (e = l.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe";
            this.resize(null, g), this._localIdeographFontFamily = l.localIdeographFontFamily, this._validateStyle = l.validateStyle, l.style && this.setStyle(l.style, {
              localIdeographFontFamily: l.localIdeographFontFamily
            }), l.attributionControl && this.addControl(new Zi(typeof l.attributionControl == "boolean" ? void 0 : l.attributionControl)), l.maplibreLogo && this.addControl(new Tu, l.logoPosition), this.on("style.load", (() => {
              if (g || this._resizeTransform(), this.transform.unmodified) {
                const T = s.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(T)
              }
            })), this.on("data", (T => {
              this._update(T.dataType === "style"), this.fire(new s.l(`${T.dataType}data`, T))
            })), this.on("dataloading", (T => {
              this.fire(new s.l(`${T.dataType}dataloading`, T))
            })), this.on("dataabort", (T => {
              this.fire(new s.l("sourcedataabort", T))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(h, e) {
            return this.style.setGlobalStateProperty(h, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i = h.onAdd(this);
            this._controls.push(h);
            const l = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? l.insertBefore(i, l.firstChild) : l.appendChild(i), this
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1
          }
          coveringTiles(h) {
            return qr(this.transform, h)
          }
          calculateCameraOptionsFromTo(h, e, i, l) {
            return l == null && this.terrain && (l = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, i, l)
          }
          resize(h, e = !0) {
            const [i, l] = this._containerDimensions(), u = this._getClampedPixelRatio(i, l);
            if (this._resizeCanvas(i, l, u), this.painter.resize(i, l, u), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const T = this._getClampedPixelRatio(i, l);
              this._resizeCanvas(i, l, T), this.painter.resize(i, l, T)
            }
            this._resizeTransform(e);
            const d = !this._moving;
            return d && (this.stop(), this.fire(new s.l("movestart", h)).fire(new s.l("move", h))), this.fire(new s.l("resize", h)), d && this.fire(new s.l("moveend", h)), this
          }
          _resizeTransform(h = !0) {
            var e;
            const [i, l] = this._containerDimensions();
            this.transform.resize(i, l, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, l, h)
          }
          _getClampedPixelRatio(h, e) {
            const {
              0: i,
              1: l
            } = this._maxCanvasSize, u = this.getPixelRatio(), d = h * u, g = e * u;
            return Math.min(d > i ? i / d : 1, g > l ? l / g : 1) * u
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(It.convert(h)), this._update()
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update()
          }
          setTransformConstrain(h) {
            return this.transform.setConstrain(h), this._update()
          }
          project(h) {
            return this.transform.locationToScreenPoint(s.U.convert(h), this.style && this.terrain)
          }
          unproject(h) {
            return this.transform.screenPointToLocation(s.P.convert(h), this.terrain)
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
          }
          _createDelegatedListener(h, e, i) {
            if (h === "mouseenter" || h === "mouseover") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: d => {
                    const g = e.filter((S => this.getLayer(S))),
                      T = g.length !== 0 ? this.queryRenderedFeatures(d.point, {
                        layers: g
                      }) : [];
                    T.length ? l || (l = !0, i.call(this, new ra(h, this, d.originalEvent, {
                      features: T
                    }))) : l = !1
                  },
                  mouseout: () => {
                    l = !1
                  }
                }
              }
            }
            if (h === "mouseleave" || h === "mouseout") {
              let l = !1;
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: g => {
                    const T = e.filter((S => this.getLayer(S)));
                    (T.length !== 0 ? this.queryRenderedFeatures(g.point, {
                      layers: T
                    }) : []).length ? l = !0 : l && (l = !1, i.call(this, new ra(h, this, g.originalEvent)))
                  },
                  mouseout: g => {
                    l && (l = !1, i.call(this, new ra(h, this, g.originalEvent)))
                  }
                }
              }
            } {
              const l = u => {
                const d = e.filter((T => this.getLayer(T))),
                  g = d.length !== 0 ? this.queryRenderedFeatures(u.point, {
                    layers: d
                  }) : [];
                g.length && (u.features = g, i.call(this, u), delete u.features)
              };
              return {
                layers: e,
                listener: i,
                delegates: {
                  [h]: l
                }
              }
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e)
          }
          _removeDelegatedListener(h, e, i) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const l = this._delegatedListeners[h];
            for (let u = 0; u < l.length; u++) {
              const d = l[u];
              if (d.listener === i && d.layers.length === e.length && d.layers.every((g => e.includes(g)))) {
                for (const g in d.delegates) this.off(g, d.delegates[g]);
                return void l.splice(u, 1)
              }
            }
          }
          on(h, e, i) {
            if (i === void 0) return super.on(h, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, l, i);
            this._saveDelegatedListener(h, u);
            for (const d in u.delegates) this.on(d, u.delegates[d]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(h, l, i)
              }
            }
          }
          once(h, e, i) {
            if (i === void 0) return super.once(h, e);
            const l = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(h, l, i);
            for (const d in u.delegates) {
              const g = u.delegates[d];
              u.delegates[d] = (...T) => {
                this._removeDelegatedListener(h, l, i), g(...T)
              }
            }
            this._saveDelegatedListener(h, u);
            for (const d in u.delegates) this.once(d, u.delegates[d]);
            return this
          }
          off(h, e, i) {
            return i === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, i), this)
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let i;
            const l = h instanceof s.P || Array.isArray(h),
              u = l ? h : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (l ? {} : h) || {}, u instanceof s.P || typeof u[0] == "number") i = [s.P.convert(u)];
            else {
              const d = s.P.convert(u[0]),
                g = s.P.convert(u[1]);
              i = [d, new s.P(g.x, d.y), g, new s.P(d.x, g.y), d]
            }
            return this.style.queryRenderedFeatures(i, e, this.transform)
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e)
          }
          setStyle(h, e) {
            return (e = s.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e))
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e
          }
          _updateStyle(h, e) {
            var i, l;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(h, e)));
            const u = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new Us(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof h == "string" ? this.style.loadURL(h, e, u) : this.style.loadJSON(h, e, u), this) : ((l = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || l === void 0 || l.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Us(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const i = this._requestManager.transformRequest(h, "Style");
              s.j(i, new AbortController).then((l => {
                this._updateDiff(l.data, e)
              })).catch((l => {
                l && this.fire(new s.k(l))
              }))
            } else typeof h == "object" && this._updateDiff(h, e)
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0)
            } catch (i) {
              s.w(`Unable to perform style diff: ${i.message||i.error||i}.  Rebuilding the style from scratch.`), this._updateStyle(h, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.")
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0)
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.tileManagers[h];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no tile manager with ID '${h}'`)))
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.tileManagers[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const i in this.style._layers) {
                const l = this.style._layers[i];
                l.type === "hillshade" && l.source === h.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), l.type === "color-relief" && l.source === h.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new wf(this.painter, e, h), this.painter.renderToTexture = new Jn(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = i => {
                var l;
                i.dataType === "style" ? this.terrain.tileManager.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((l = i.source) === null || l === void 0 ? void 0 : l.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(i.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", {
              terrain: h
            })), this
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const h = this.style && this.style.tileManagers;
            for (const e in h) {
              const i = h[e]._tiles;
              for (const l in i) {
                const u = i[l];
                if (u.state !== "loaded" && u.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0)
          }
          getSource(h) {
            return this.style.getSource(h)
          }
          setSourceTileLodParams(h, e, i) {
            if (i) {
              const l = this.getSource(i);
              if (!l) throw new Error(`There is no source with ID "${i}", cannot set LOD parameters`);
              l.calculateTileZoom = Ft(Math.max(1, h), Math.max(1, e))
            } else
              for (const l in this.style.tileManagers) this.style.tileManagers[l].getSource().calculateTileZoom = Ft(Math.max(1, h), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(h, e) {
            const i = this.style.tileManagers[h];
            if (!i) throw new Error(`There is no tile manager with ID "${h}", cannot refresh tile`);
            e === void 0 ? i.reload(!0) : i.refreshTiles(e.map((l => new s.a8(l.z, l.x, l.y))))
          }
          addImage(h, e, i = {}) {
            const {
              pixelRatio: l = 1,
              sdf: u = !1,
              stretchX: d,
              stretchY: g,
              content: T,
              textFitWidth: S,
              textFitHeight: k
            } = i;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: z,
                  height: V,
                  data: F
                } = e, $ = e;
                return this.style.addImage(h, {
                  data: new s.R({
                    width: z,
                    height: V
                  }, new Uint8Array(F)),
                  pixelRatio: l,
                  stretchX: d,
                  stretchY: g,
                  content: T,
                  textFitWidth: S,
                  textFitHeight: k,
                  sdf: u,
                  version: 0,
                  userImage: $
                }), $.onAdd && $.onAdd(this, h), this
              }
            } {
              const {
                width: z,
                height: V,
                data: F
              } = re.getImageData(e);
              this.style.addImage(h, {
                data: new s.R({
                  width: z,
                  height: V
                }, F),
                pixelRatio: l,
                stretchX: d,
                stretchY: g,
                content: T,
                textFitWidth: S,
                textFitHeight: k,
                sdf: u,
                version: 0
              })
            }
          }
          updateImage(h, e) {
            const i = this.style.getImage(h);
            if (!i) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const l = e instanceof HTMLImageElement || s.b(e) ? re.getImageData(e) : e,
              {
                width: u,
                height: d,
                data: g
              } = l;
            if (u === void 0 || d === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (u !== i.data.width || d !== i.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const T = !(e instanceof HTMLImageElement || s.b(e));
            return i.data.replace(g, T), this.style.updateImage(h, i), this
          }
          getImage(h) {
            return this.style.getImage(h)
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new s.k(new Error("Missing required image id"))), !1)
          }
          removeImage(h) {
            this.style.removeImage(h)
          }
          loadImage(h) {
            return $e.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0)
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0)
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0)
          }
          getLayer(h) {
            return this.style.getLayer(h)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(h, e, i) {
            return this.style.setLayerZoomRange(h, e, i), this._update(!0)
          }
          setFilter(h, e, i = {}) {
            return this.style.setFilter(h, e, i), this._update(!0)
          }
          getFilter(h) {
            return this.style.getFilter(h)
          }
          setPaintProperty(h, e, i, l = {}) {
            return this.style.setPaintProperty(h, e, i, l), this._update(!0)
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e)
          }
          setLayoutProperty(h, e, i, l = {}) {
            return this.style.setLayoutProperty(h, e, i, l), this._update(!0)
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e)
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(h, e, i = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, i, (l => {
              l || this._update(!0)
            })), this
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (i => {
              i || this._update(!0)
            })), this
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update()
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update()
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let h = 0,
              e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e]
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = Y.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = Y.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i = this._containerDimensions(),
              l = this._getClampedPixelRatio(i[0], i[1]);
            this._resizeCanvas(i[0], i[1], l);
            const u = this._controlContainer = Y.create("div", "maplibregl-control-container", h),
              d = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g => {
              d[g] = Y.create("div", `maplibregl-ctrl-${g} `, u)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(h, e, i) {
            this._canvas.width = Math.floor(i * h), this._canvas.height = Math.floor(i * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (l => {
              e = {
                requestedAttributes: h
              }, l && (e.statusMessage = l.statusMessage, e.type = l.type)
            }), {
              once: !0
            });
            let i = null;
            if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !i) {
              const l = "Failed to initialize WebGL";
              throw e ? (e.message = l, new Error(JSON.stringify(e))) : new Error(l)
            }
            this.painter = new Pd(i, this.transform), we.testSupport(i)
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new s.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h)
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h)
          }
          _render(h) {
            var e, i, l, u, d;
            const g = this._idleTriggered ? this._fadeDuration : 0,
              T = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let S = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const V = this.transform.zoom,
                F = ne();
              this.style.zoomHistory.update(V, F);
              const $ = new s.G(V, {
                  now: F,
                  fadeDuration: g,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition()
                }),
                J = $.crossFadingFactor();
              J === 1 && J === this._crossFadingFactor || (S = !0, this._crossFadingFactor = J), this.style.update($)
            }
            const k = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== T;
            (l = this.style.projection) === null || l === void 0 || l.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || k) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, k), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: g,
              showPadding: this.showPadding
            }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, s.cz.mark(s.cA.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || S) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const z = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return z || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || z || (this._fullyLoaded = !0, s.cz.mark(s.cA.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const i of this._controls) i.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), $e.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), Y.remove(this._canvasContainer), Y.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), s.cz.clearMetrics(), this._removed = !0, this.fire(new s.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, re.frame(this._frameRequest, (h => {
              s.cz.frame(h), this._frameRequest = null;
              try {
                this._render(h)
              } catch (e) {
                if (!s.cB(e) && !(function(i) {
                    return i.message === vd
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(h) {
            this._vertices = h, this._update()
          }
          get version() {
            return Hd
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0)
          }
        }, w.MapMouseEvent = ra, w.MapTouchEvent = Yi, w.MapWheelEvent = zd, w.Marker = al, w.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                i = e === this._map.getMaxZoom(),
                l = e === this._map.getMinZoom();
              this._zoomInButton.disabled = i, this._zoomOutButton.disabled = l, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", l.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, i) => {
              const l = this._map._getUIString(`NavigationControl.${i}`);
              e.title = l, e.setAttribute("aria-label", l)
            }, this.options = s.e({}, Jl, h), this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), Y.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), Y.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = Y.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Su(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            Y.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(h, e) {
            const i = Y.create("button", h, this._container);
            return i.type = "button", i.addEventListener("click", e), i
          }
        }, w.Popup = class extends s.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && Y.remove(this._content), this._container && (Y.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = Y.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = Y.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const g of this.options.className.split(" ")) this._container.classList.add(g);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Ql(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const i = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let l = this.options.anchor;
              const u = nc(this.options.offset);
              if (!l) {
                const g = this._container.offsetWidth,
                  T = this._container.offsetHeight;
                let S;
                S = i.y + u.bottom.y < T ? ["top"] : i.y > this._map.transform.height - T ? ["bottom"] : [], i.x < g / 2 ? S.push("left") : i.x > this._map.transform.width - g / 2 && S.push("right"), l = S.length === 0 ? "bottom" : S.join("-")
              }
              let d = i.add(u[l]);
              this.options.subpixelPositioning || (d = d.round()), Y.setTransform(this._container, `${Go[l]} translate(${d.x}px,${d.y}px)`), ec(this._container, l, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = s.e(Object.create(Iu), h)
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(h) {
            return this._lngLat = s.U.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h))
          }
          setHTML(h) {
            const e = document.createDocumentFragment(),
              i = document.createElement("body");
            let l;
            for (i.innerHTML = h; l = i.firstChild, l;) e.appendChild(l);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this
          }
          setDOMContent(h) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = Y.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h)
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = Y.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(rc);
            h && h.focus()
          }
        }, w.RasterDEMTileSource = qt, w.RasterTileSource = jt, w.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              tc(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, tc(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Pu), h)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(h) {
            return this._map = h, this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            Y.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, w.ScrollZoomHandler = qd, w.Style = Us, w.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = h
          }
          onAdd(h) {
            return this._map = h, this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Y.create("button", "maplibregl-ctrl-terrain", this._container), Y.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            Y.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, w.TwoFingersTouchPitchHandler = Nd, w.TwoFingersTouchRotateHandler = Yl, w.TwoFingersTouchZoomHandler = Od, w.TwoFingersTouchZoomRotateHandler = Zd, w.VectorTileSource = Ot, w.VideoSource = hr, w.addSourceType = (h, e) => s._(void 0, void 0, void 0, (function*() {
          if (kr(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((i, l) => {
            Et[i] = l
          })(h, e)
        })), w.clearPrewarmedResources = function() {
          const h = Lt;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(_t), Lt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, w.createTileMesh = Lo, w.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, w.getRTLTextPluginStatus = function() {
          return D().getRTLTextPluginStatus()
        }, w.getVersion = function() {
          return Mu
        }, w.getWorkerCount = function() {
          return ut.workerCount
        }, w.getWorkerUrl = function() {
          return s.a.WORKER_URL
        }, w.importScriptInWorkers = function(h) {
          return Ct().broadcast("IS", h)
        }, w.isTimeFrozen = function() {
          return de.isFrozen()
        }, w.now = ne, w.prewarm = function() {
          ot().acquire(_t)
        }, w.restoreNow = function() {
          de.restoreNow()
        }, w.setMaxParallelImageRequests = function(h) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = h
        }, w.setNow = function(h) {
          de.setNow(h)
        }, w.setRTLTextPlugin = function(h, e) {
          return D().setRTLTextPlugin(h, e)
        }, w.setWorkerCount = function(h) {
          ut.workerCount = h
        }, w.setWorkerUrl = function(h) {
          s.a.WORKER_URL = h
        }
      }));
      var L = f;
      return L
    }))
  })(Sp)), Sp.exports
}
var M6 = I6();
const _p = K0(M6);
class jv {
  constructor(o) {
    Cr(this, "gm");
    Cr(this, "markers", new Map);
    Cr(this, "canvases", new Map);
    Cr(this, "canvasSize");
    Cr(this, "canvasOpacity", .8);
    this.input = o, this.gm = new us(this.input.tileSize);
    const f = Q0(o.img);
    this.canvasSize = Math.ceil(2e3 / f)
  }
  place([o, f]) {
    const x = this.gm.latLonToPixelsFloor(o, f, this.input.zoom),
      A = this.getMarkerId(x),
      L = this.gm.latLonToPixelBoundsLatLon(o, f, this.input.zoom),
      w = this.input.map;
    if (this.input.markerFn && !this.markers.has(A)) {
      const ee = this.input.markerFn();
      ee.setLngLat({
        lat: L.min[0],
        lng: (L.max[1] + L.min[1]) / 2
      }).addTo(w), this.markers.set(A, ee)
    }
    const {
      key: s,
      pos: B,
      innerPos: j
    } = this.getCanvasPos(x);
    let K = this.canvases.get(s);
    if (!K) {
      const ee = this.canvasSize,
        re = B.x * ee,
        de = B.y * ee,
        ne = re + ee - 1,
        Y = de + ee - 1,
        we = this.gm.pixelsToLatLon(re, Y + 1, this.input.zoom),
        Ie = this.gm.pixelsToLatLon(ne + 1, de, this.input.zoom);
      K = new A6({
        id: `${this.input.id}-${s}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: b_({
          min: we,
          max: Ie
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), K.addTo(this.input.map), this.canvases.set(s, K)
    }
    K.place(j.x, j.y)
  }
  clear() {
    const o = this.input.map;
    for (const f of this.canvases.values()) f.removeFrom(o), f.removeDOM();
    this.canvases.clear();
    for (const f of this.markers.values()) f.remove();
    this.markers.clear()
  }
  clearAndPlace(o) {
    this.clear(), this.place(o)
  }
  remove([o, f]) {
    let x = !1;
    const A = this.gm.latLonToPixelsFloor(o, f, this.input.zoom),
      {
        key: L,
        innerPos: w
      } = this.getCanvasPos(A),
      s = this.canvases.get(L);
    s && (x = s.remove(w.x, w.y), s.annotationsCount() === 0 && (this.canvases.delete(L), s.removeFrom(this.input.map), s.removeDOM()));
    const B = this.getMarkerId(A),
      j = this.markers.get(B);
    return j == null || j.remove(), this.markers.delete(B), x
  }
  setCanvasOpacity(o) {
    this.canvasOpacity = o;
    for (const f of this.canvases.values()) f.setOpacity(o)
  }
  getMarkerId([o, f]) {
    return `${this.input.id}:${o},${f}`
  }
  getCanvasPos([o, f]) {
    const x = {
        x: Math.floor(o / this.canvasSize),
        y: Math.floor(f / this.canvasSize)
      },
      A = {
        x: o % this.canvasSize,
        y: f % this.canvasSize
      },
      L = `${x.x},${x.y}`;
    return {
      pos: x,
      innerPos: A,
      key: L
    }
  }
}
class A6 {
  constructor(o) {
    Cr(this, "annotations", new Set);
    Cr(this, "canvas");
    Cr(this, "imgSize");
    Cr(this, "maps", new Set);
    this.input = o, this.imgSize = Q0(o.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(o, f) {
    const x = this.getPixelKey(o, f);
    if (this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const L = o * this.imgSize,
        w = f * this.imgSize;
      A.drawImage(this.input.img, L, w)
    }
    return this.annotations.add(x), !0
  }
  remove(o, f) {
    const x = this.getPixelKey(o, f);
    if (!this.annotations.has(x)) return !1;
    const A = this.canvas.getContext("2d");
    if (A) {
      const L = o * this.imgSize,
        w = f * this.imgSize;
      A.clearRect(L, w, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(x), !0
  }
  addTo(o) {
    const f = this.input.id;
    o.getSource(f) || o.addSource(f, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), o.getLayer(f) || o.addLayer({
      id: f,
      type: "raster",
      source: f,
      paint: this.input.layerPaint
    }), this.maps.add(o)
  }
  removeFrom(o) {
    const {
      id: f
    } = this.input;
    o.getLayer(f) && o.removeLayer(f), o.getSource(f) && o.removeSource(f), this.maps.delete(o)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(o) {
    for (const f of this.maps.values()) f.setPaintProperty(this.input.id, "raster-opacity", o)
  }
  getPixelKey(o, f) {
    return `${o},${f}`
  }
}

function Q0(_) {
  return Math.max(_.naturalWidth, _.naturalHeight)
}

function k6() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function E6(_) {
  const o = {
      opaque: !0
    },
    f = _.searchParams.get("lat"),
    x = _.searchParams.get("lng");
  f && x && (o.pos = {
    lat: parseFloat(f),
    lng: parseFloat(x)
  });
  const A = _.searchParams.get("zoom");
  A && (o.zoom = parseFloat(A));
  const L = _.searchParams.get("season");
  L && (o.season = parseInt(L));
  const w = _.searchParams.get("opaque");
  return w && (o.opaque = w !== "0"), _.searchParams.get("select") && (o.select = !0), _.searchParams.get("twitch-migration") && (o.twitchMigration = !0), o.newUser = !!_.searchParams.get("new-user"), o.discordLinked = !!_.searchParams.get("discord-linked"), o.alliance = !!_.searchParams.get("alliance"), o
}

function z6(_, o) {
  return _ = new URL(_), o.pos !== void 0 && (_.searchParams.set("lat", o.pos.lat.toString()), _.searchParams.set("lng", o.pos.lng.toString())), o.zoom !== void 0 && _.searchParams.set("zoom", o.zoom.toString()), o.season !== void 0 && _.searchParams.set("season", o.season.toString()), o.opaque !== void 0 && _.searchParams.set("opaque", o.opaque ? "1" : "0"), o.newUser !== void 0 && _.searchParams.set("new-user", o.newUser ? "1" : "0"), o.alliance !== void 0 && _.searchParams.set("alliance", o.alliance ? "1" : "0"), o.select && _.searchParams.set("alliance", "1"), _
}
const Cp = Si({
  shouldReload: !0
});
var L6 = me('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function D6(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15),
    x = Qe(!1),
    A = Qe(Si(o.description)),
    L = Qe(void 0);
  Dn(() => {
    const ze = Re => {
      var ke;
      Re.key === "Escape" && ((ke = f()) == null || ke.close())
    };
    return document.addEventListener("keydown", ze), () => document.removeEventListener("keydown", ze)
  });
  var w = L6(),
    s = M(w),
    B = M(s),
    j = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K),
    re = M(ee);
  {
    let ze = ct(() => V0());
    T0(re, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return y(ze)
      },
      max: 512,
      get value() {
        return y(A)
      },
      set value(Re) {
        te(A, Re, !0)
      },
      get validate() {
        return y(L)
      },
      set validate(Re) {
        te(L, Re, !0)
      }
    })
  }
  P(ee);
  var de = q(ee, 2),
    ne = M(de);
  ne.__click = () => {
    var ze;
    (ze = f()) == null || ze.close()
  };
  var Y = M(ne, !0);
  P(ne);
  var we = q(ne, 2),
    Ie = M(we, !0);
  P(we), P(de), P(K), P(s), bn(2), P(w), ko(w, ze => f(ze), () => f()), je((ze, Re, ke) => {
    le(j, ze), ne.disabled = y(x), le(Y, Re), we.disabled = y(x), le(Ie, ke)
  }, [() => bb(), () => Gh(), () => AS()]), Un("submit", K, async () => {
    var ze, Re, ke;
    try {
      if (!((ze = y(L)) != null && ze())) return;
      te(x, !0), o.description !== y(A) && await Jr.updateAllianceDescription(y(A)), await ((Re = o.onsuccess) == null ? void 0 : Re.call(o, y(A))), (ke = f()) == null || ke.close()
    } catch (qe) {
      vr.error(qe.message)
    } finally {
      te(x, !1)
    }
  }), G(_, w), Lr()
}
Rn(["click"]);
var R6 = me('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  F6 = me('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function B6(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(""),
    A = Qe(!1);
  const L = ct(() => ui.url.origin + `/join?id=${y(x)}`);
  Zr(() => {
    f() && Jr.getAllianceInvites().then($e => {
      te(x, $e[0], !0)
    }).catch($e => {
      vr.error($e.message)
    })
  }), Dn(() => {
    const $e = Be => {
      Be.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", $e), () => document.removeEventListener("keydown", $e)
  });
  var w = F6(),
    s = M(w),
    B = q(M(s), 2),
    j = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K, !0);
  P(K);
  var re = q(K, 2),
    de = M(re);
  let ne;
  var Y = M(de);
  Ba(Y);
  var we = q(Y, 2),
    Ie = M(we);
  let ze;
  Ie.__click = () => {
    navigator.clipboard.writeText(y(L).toString()), te(A, !0), setTimeout(() => {
      te(A, !1)
    }, 1e3)
  };
  var Re = M(Ie, !0);
  P(Ie), P(we), P(de);
  var ke = q(de, 2);
  {
    var qe = $e => {
      var Be = R6();
      G($e, Be)
    };
    Ae(ke, $e => {
      y(x) || $e(qe)
    })
  }
  P(re), P(s), bn(2), P(w), yi(w, () => $e => {
    Zr(() => {
      f() ? $e.show() : $e.close()
    })
  }), je(($e, Be, Ee, He) => {
    le(j, $e), le(ee, Be), ne = Or(de, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, ne, {
      invisible: !y(x)
    }), x0(Y, Ee), ze = Or(Ie, 1, "btn btn-primary", null, ze, {
      "btn-success": y(A)
    }), le(Re, He)
  }, [() => kT(), () => LT(), () => y(L).toString(), () => y(A) ? g_() : Sm()]), Un("close", w, () => f(!1)), G(_, w), Lr()
}
Rn(["click"]);
var O6 = Dr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function km(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = O6();
  cr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...f
  })), G(_, x)
}
var N6 = me('<span class="text-success">(Verified)</span>'),
  j6 = me('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  V6 = me("<button><!></button>"),
  q6 = me('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function Hh(_, o) {
  zr(o, !0);
  const f = !!o.id;
  var x = q6(),
    A = M(x),
    L = M(A),
    w = M(L);
  P(L);
  var s = q(L, 2);
  {
    var B = re => {
      var de = N6();
      G(re, de)
    };
    Ae(s, re => {
      f && re(B)
    })
  }
  P(A);
  var j = q(A, 2);
  {
    var K = re => {
        var de = j6(),
          ne = M(de);
        km(ne, {
          class: "size-4 opacity-70"
        }), P(de), je(Y => mr(de, "href", Y), [() => `https://discord.com/users/${encodeURIComponent(o.id)}`]), G(re, de)
      },
      ee = re => {
        var de = V6();
        de.__click = async () => {
          await navigator.clipboard.writeText(o.username), vr.info(DC())
        };
        var ne = M(de);
        km(ne, {
          class: "size-4 opacity-70"
        }), P(de), G(re, de)
      };
    Ae(j, re => {
      f ? re(K) : re(ee, !1)
    })
  }
  P(x), je(() => le(w, `Discord: ${o.username??""}`)), G(_, x), Lr()
}
Rn(["click"]);
var U6 = me('<input type="radio" class="tab max-[380px]:px-3"/>'),
  Z6 = me('<div class="tabs tabs-border w-max font-medium"></div>');

function T_(_, o) {
  zr(o, !0);
  const f = [];
  let x = At(o, "value", 15, "today"),
    A = [{
      value: "today",
      label: Qp()
    }, {
      value: "week",
      label: HT()
    }, {
      value: "month",
      label: YT()
    }, {
      value: "all-time",
      label: QT()
    }];
  var L = Z6();
  ii(L, 21, () => A, w => w.value, (w, s) => {
    var B = U6();
    Ba(B);
    var j;
    je(() => {
      mr(B, "aria-label", y(s).label), j !== (j = y(s).value) && (B.value = (B.__value = y(s).value) ?? "")
    }), h_(f, [], B, () => (y(s).value, x()), x), G(w, B)
  }), P(L), G(_, L), Lr()
}
const G6 = typeof window < "u" ? window : void 0;

function $6(_) {
  let o = _.activeElement;
  for (; o != null && o.shadowRoot;) {
    const f = o.shadowRoot.activeElement;
    if (f === o) break;
    o = f
  }
  return o
}
var kc, uh, _0;
let H6 = (_0 = class {
  constructor(o = {}) {
    Pr(this, kc);
    Pr(this, uh);
    const {
      window: f = G6,
      document: x = f == null ? void 0 : f.document
    } = o;
    f !== void 0 && (Hi(this, kc, x), Hi(this, uh, y0(A => {
      const L = eh(f, "focusin", A),
        w = eh(f, "focusout", A);
      return () => {
        L(), w()
      }
    })))
  }
  get current() {
    var o;
    return (o = Xe(this, uh)) == null || o.call(this), Xe(this, kc) ? $6(Xe(this, kc)) : null
  }
}, kc = new WeakMap, uh = new WeakMap, _0);
new H6;

function W6(_) {
  return typeof _ == "function"
}

function X6(_, o) {
  if (W6(_)) {
    const x = _();
    return x === void 0 ? o : x
  }
  return _ === void 0 ? o : _
}

function Y6(_, o) {
  let f = Qe(null);
  const x = ct(() => X6(o, 250));

  function A(...L) {
    if (y(f)) y(f).timeout && clearTimeout(y(f).timeout);
    else {
      let w, s;
      const B = new Promise((j, K) => {
        w = j, s = K
      });
      te(f, {
        timeout: null,
        runner: null,
        promise: B,
        resolve: w,
        reject: s
      }, !0)
    }
    return y(f).runner = async () => {
      if (!y(f)) return;
      const w = y(f);
      te(f, null);
      try {
        w.resolve(await _.apply(this, L))
      } catch (s) {
        w.reject(s)
      }
    }, y(f).timeout = setTimeout(y(f).runner, y(x)), y(f).promise
  }
  return A.cancel = async () => {
    (!y(f) || y(f).timeout === null) && (await new Promise(L => setTimeout(L, 0)), !y(f) || y(f).timeout === null) || (clearTimeout(y(f).timeout), y(f).reject("Cancelled"), te(f, null))
  }, A.runScheduledNow = async () => {
    var L, w;
    (!y(f) || !y(f).timeout) && (await new Promise(s => setTimeout(s, 0)), !y(f) || !y(f).timeout) || (clearTimeout(y(f).timeout), y(f).timeout = null, await ((w = (L = y(f)).runner) == null ? void 0 : w.call(L)))
  }, Object.defineProperty(A, "pending", {
    enumerable: !0,
    get() {
      var L;
      return !!((L = y(f)) != null && L.timeout)
    }
  }), A
}

function K6(_, o) {
  switch (_) {
    case "post":
      Zr(o);
      break;
    case "pre":
      s_(o);
      break
  }
}

function ey(_, o, f, x = {}) {
  const {
    lazy: A = !1
  } = x;
  let L = !A,
    w = Array.isArray(_) ? [] : void 0;
  K6(o, () => {
    const s = Array.isArray(_) ? _.map(j => j()) : _();
    if (!L) {
      L = !0, w = s;
      return
    }
    const B = yl(() => f(s, w));
    return w = s, B
  })
}

function Rs(_, o, f) {
  ey(_, "post", o, f)
}

function J6(_, o, f) {
  ey(_, "pre", o, f)
}
Rs.pre = J6;

function Q6() {}
var vl, zs;
class eA {
  constructor(o, f = 250) {
    Pr(this, vl, Qe());
    Pr(this, zs);
    te(Xe(this, vl), o(), !0), this.cancel = this.cancel.bind(this), this.setImmediately = this.setImmediately.bind(this), this.updateImmediately = this.updateImmediately.bind(this), Hi(this, zs, Y6(() => {
      te(Xe(this, vl), o(), !0)
    }, f)), Rs(o, () => {
      Xe(this, zs).call(this).catch(Q6)
    })
  }
  get current() {
    return y(Xe(this, vl))
  }
  get pending() {
    return Xe(this, zs).pending
  }
  cancel() {
    Xe(this, zs).cancel()
  }
  updateImmediately() {
    return Xe(this, zs).runScheduledNow()
  }
  setImmediately(o) {
    this.cancel(), te(Xe(this, vl), o, !0)
  }
}
vl = new WeakMap, zs = new WeakMap;
var tA = me('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  rA = me('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  nA = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  iA = me("<button><!></button>"),
  aA = me('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  oA = me('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  sA = me('<div><!> <div class="mt-4"><!></div></div>');

function lA(_, o) {
  zr(o, !0);
  let f = At(o, "reload", 15),
    x = Qe(!0),
    A = Qe([]),
    L = Qe(0),
    w = Qe("today"),
    s = {};
  f(B);

  function B() {
    const Y = y(w);
    Jr.allianceLeaderboard(Y).then(we => {
      te(A, we), s = {
        [Y]: we
      }, te(x, !1)
    }).catch(we => {
      vr.error(we.message)
    })
  }
  Rs(() => [y(w)], () => {
    const Y = y(w),
      we = s[Y];
    if (we) {
      te(A, we), te(x, !1);
      return
    }
    te(x, !0), Jr.allianceLeaderboard(Y).then(Ie => {
      te(A, Ie), s[Y] = Ie, te(x, !1)
    }).catch(Ie => {
      vr.error(Ie.message)
    })
  });
  var j = sA(),
    K = M(j);
  T_(K, {
    get value() {
      return y(w)
    },
    set value(Y) {
      te(w, Y, !0)
    }
  });
  var ee = q(K, 2),
    re = M(ee);
  {
    var de = Y => {
        var we = tA();
        G(Y, we)
      },
      ne = Y => {
        var we = Jt(),
          Ie = gt(we);
        {
          var ze = ke => {
              var qe = rA(),
                $e = M(qe),
                Be = q($e);
              {
                var Ee = Le => {
                    var it = ji();
                    je(pt => le(it, pt), [() => Qp().toLowerCase()]), G(Le, it)
                  },
                  He = Le => {
                    var it = Jt(),
                      pt = gt(it);
                    {
                      var Oe = bt => {
                          var We = ji();
                          je(Ue => le(We, Ue), [() => y_()]), G(bt, We)
                        },
                        Je = bt => {
                          var We = Jt(),
                            Ue = gt(We);
                          {
                            var Ge = Ve => {
                              var mt = ji();
                              je(lt => le(mt, lt), [() => x_()]), G(Ve, mt)
                            };
                            Ae(Ue, Ve => {
                              y(w) === "month" && Ve(Ge)
                            }, !0)
                          }
                          G(bt, We)
                        };
                      Ae(pt, bt => {
                        y(w) === "week" ? bt(Oe) : bt(Je, !1)
                      }, !0)
                    }
                    G(Le, it)
                  };
                Ae(Be, Le => {
                  y(w) === "today" ? Le(Ee) : Le(He, !1)
                })
              }
              P(qe), je(Le => le($e, `${Le??""} `), [() => v_()]), G(ke, qe)
            },
            Re = ke => {
              var qe = oA(),
                $e = M(qe),
                Be = M($e),
                Ee = q(M(Be)),
                He = M(Ee, !0);
              P(Ee);
              var Le = q(Ee),
                it = M(Le, !0);
              P(Le), P(Be), P($e);
              var pt = q($e);
              ii(pt, 31, () => y(A), Oe => Oe.userId, (Oe, Je, bt) => {
                const We = ct(() => {
                  var It;
                  return ((It = Mt.data) == null ? void 0 : It.id) === y(Je).userId
                });
                var Ue = aA();
                let Ge;
                var Ve = M(Ue),
                  mt = M(Ve, !0);
                P(Ve);
                var lt = q(Ve),
                  yt = M(lt),
                  _t = M(yt);
                mo(_t, {
                  class: "size-10 border",
                  get userId() {
                    return y(Je).userId
                  },
                  get pictureUrl() {
                    return y(Je).picture
                  }
                });
                var ut = q(_t, 2),
                  Ut = M(ut),
                  Lt = q(Ut),
                  Ke = M(Lt);
                P(Lt), P(ut);
                var ot = q(ut, 2);
                {
                  var xt = It => {
                    const Xt = ct(() => Ao(y(Je).equippedFlag));
                    var Ot = nA(),
                      jt = M(Ot, !0);
                    P(Ot), je(() => {
                      mr(Ot, "data-tip", y(Xt).name), le(jt, y(Xt).flag)
                    }), G(It, Ot)
                  };
                  Ae(ot, It => {
                    y(Je).equippedFlag && It(xt)
                  })
                }
                var Ct = q(ot, 2);
                {
                  var wt = It => {
                    Hh(It, {
                      get username() {
                        return y(Je).discord
                      },
                      get id() {
                        return y(Je).discordId
                      }
                    })
                  };
                  Ae(Ct, It => {
                    y(Je).discord && It(wt)
                  })
                }
                P(yt), P(lt);
                var kt = q(lt),
                  Zt = M(kt),
                  Nt = q(Zt);
                {
                  var $t = It => {
                    var Xt = iA();
                    let Ot;
                    Xt.__click = () => {
                      o.onlastpixelclick({
                        lat: y(Je).lastLatitude ?? 0,
                        lng: y(Je).lastLongitude ?? 0
                      })
                    };
                    var jt = M(Xt);
                    $p(jt, {
                      class: "size-4"
                    }), P(Xt), je(qt => {
                      Ot = Or(Xt, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, Ot, {
                        tooltip: y(L) > 640
                      }), mr(Xt, "data-tip", qt)
                    }, [() => zb()]), G(It, Xt)
                  };
                  Ae(Nt, It => {
                    y(Je).lastLatitude && y(Je).lastLongitude && It($t)
                  })
                }
                P(kt), P(Ue), je((It, Xt) => {
                  var Ot;
                  Ge = Or(Ue, 1, "", null, Ge, {
                    "bg-base-200": y(We)
                  }), le(mt, y(bt) + 1), Or(ut, 1, `font-semibold ${It??""} flex gap-1`), le(Ut, `${(y(We)?((Ot=Mt.data)==null?void 0:Ot.name)??y(Je).name:y(Je).name)??""} `), le(Ke, `#${y(Je).userId??""}`), le(Zt, `${Xt??""} `)
                }, [() => Ni(y(Je).userId), () => y(Je).pixelsPainted.toLocaleString("en-US")]), _l(Ue, () => gl, () => ({
                  duration: 200
                })), G(Oe, Ue)
              }), P(pt), P(qe), je((Oe, Je) => {
                le(He, Oe), le(it, Je)
              }, [() => d_(), () => c_()]), G(ke, qe)
            };
          Ae(Ie, ke => {
            y(A).length === 0 ? ke(ze) : ke(Re, !1)
          }, !0)
        }
        G(Y, we)
      };
    Ae(re, Y => {
      y(x) ? Y(de) : Y(ne, !1)
    })
  }
  P(ee), P(j), Yp("innerWidth", Y => te(L, Y, !0)), G(_, j), Lr()
}
Rn(["click"]);
var cA = Dr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function S_(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = cA();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var uA = me('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  hA = me('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1),
  dA = me('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'),
  pA = me('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'),
  fA = me('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  mA = me('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'),
  _A = me('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  gA = me('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  vA = me('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function yA(_, o) {
  zr(o, !0);
  let f = Si({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    x = Si({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var A = vA(),
    L = M(A),
    w = M(L);
  w.__click = () => o.onclickback();
  var s = M(w);
  A0(s, {
    class: "size-5"
  }), P(w);
  var B = q(w, 2),
    j = M(B, !0);
  P(B), P(L);
  var K = q(L, 2),
    ee = M(K);
  Ba(ee);
  var re = q(ee, 2),
    de = M(re),
    ne = M(de);
  ii(ne, 21, () => f.data, He => He.id, (He, Le, it) => {
    const pt = ct(() => {
      var xt;
      return ((xt = Mt.data) == null ? void 0 : xt.id) === y(Le).id
    });
    var Oe = pA(),
      Je = M(Oe),
      bt = M(Je),
      We = M(bt);
    mo(We, {
      class: "size-10 border",
      get userId() {
        return y(Le).id
      },
      get pictureUrl() {
        return y(Le).picture
      }
    });
    var Ue = q(We, 2),
      Ge = M(Ue);
    P(Ue);
    var Ve = q(Ue, 2);
    {
      var mt = xt => {
        var Ct = uA();
        G(xt, Ct)
      };
      Ae(Ve, xt => {
        y(Le).role === "admin" && xt(mt)
      })
    }
    P(bt), P(Je);
    var lt = q(Je),
      yt = M(lt),
      _t = M(yt),
      ut = M(_t);
    S_(ut, {
      class: "size-4"
    }), P(_t);
    var Ut = q(_t, 2),
      Lt = M(Ut);
    {
      var Ke = xt => {
          var Ct = hA(),
            wt = gt(Ct),
            kt = M(wt);
          kt.__click = async () => {
            try {
              y(Le).loading = !0, await Jr.giveAllianceAdmin(y(Le).id), y(Le).role = "admin"
            } catch {
              vr.error(iP())
            } finally {
              y(Le).loading = !1
            }
          };
          var Zt = M(kt, !0);
          P(kt), P(wt);
          var Nt = q(wt, 2),
            $t = M(Nt);
          $t.__click = async () => {
            try {
              y(Le).loading = !0, await Jr.banAllianceUser(y(Le).id), f.data = f.data.filter(Xt => Xt.id !== y(Le).id)
            } catch {
              vr.error(zS())
            } finally {
              y(Le).loading = !1
            }
          };
          var It = M($t, !0);
          P($t), P(Nt), je((Xt, Ot) => {
            kt.disabled = y(Le).loading, le(Zt, Xt), $t.disabled = y(Le).loading, le(It, Ot)
          }, [() => mS(), () => q0()]), G(xt, Ct)
        },
        ot = xt => {
          var Ct = dA(),
            wt = M(Ct);
          wt.disabled = !0;
          var kt = M(wt, !0);
          P(wt), P(Ct), je(Zt => le(kt, Zt), [() => xS()]), G(xt, Ct)
        };
      Ae(Lt, xt => {
        y(Le).role === "member" ? xt(Ke) : xt(ot, !1)
      })
    }
    P(Ut), P(yt), P(lt), P(Oe), je(xt => {
      var Ct;
      Or(Ue, 1, `font-semibold ${xt??""}`), le(Ge, `${(y(pt)?((Ct=Mt.data)==null?void 0:Ct.name)??y(Le).name:y(Le).name)??""} #${y(Le).id??""}`)
    }, [() => Ni(y(Le).id)]), G(He, Oe)
  }), P(ne), P(de);
  var Y = q(de, 2);
  {
    var we = He => {
      var Le = Jt(),
        it = gt(Le);
      th(it, () => f.page, pt => {
        var Oe = fA();
        yi(Oe, () => Je => {
          const bt = new IntersectionObserver(We => {
            We[0].isIntersecting && !f.loading && (f.loading = !0, Jr.getAllianceMembers(f.page).then(Ue => {
              f.data = [...f.data, ...Ue.data], f.hasNextPage = Ue.hasNext, f.page++
            }).catch(Ue => {
              vr.error(Ue.message)
            }).finally(() => {
              f.loading = !1
            }))
          });
          return bt.observe(Je), () => {
            bt.disconnect()
          }
        }), G(pt, Oe)
      }), G(He, Le)
    };
    Ae(Y, He => {
      f.hasNextPage && He(we)
    })
  }
  P(re);
  var Ie = q(re, 2),
    ze = q(Ie, 2),
    Re = M(ze),
    ke = M(Re);
  ii(ke, 21, () => x.data, He => He.id, (He, Le, it) => {
    var pt = mA(),
      Oe = M(pt),
      Je = M(Oe),
      bt = M(Je);
    mo(bt, {
      class: "size-10 border",
      get userId() {
        return y(Le).id
      },
      get pictureUrl() {
        return y(Le).picture
      }
    });
    var We = q(bt, 2),
      Ue = M(We);
    P(We), P(Je), P(Oe);
    var Ge = q(Oe),
      Ve = M(Ge);
    Ve.__click = () => {
      Jr.unbanAllianceUser(y(Le).id).then(() => {
        x.data = x.data.filter(lt => lt.id !== y(Le).id)
      }).catch(lt => vr.error(lt.message)).finally(() => {
        y(Le).loading = !1
      })
    };
    var mt = M(Ve, !0);
    P(Ve), P(Ge), P(pt), je((lt, yt) => {
      Or(We, 1, `font-semibold ${lt??""}`), le(Ue, `${y(Le).name??""} #${y(Le).id??""}`), Ve.disabled = y(Le).loading, le(mt, yt)
    }, [() => Ni(y(Le).id), () => TS()]), G(He, pt)
  }), P(ke), P(Re);
  var qe = q(Re, 2);
  {
    var $e = He => {
      var Le = _A(),
        it = M(Le, !0);
      P(Le), je(pt => le(it, pt), [() => PS()]), G(He, Le)
    };
    Ae(qe, He => {
      !x.hasNextPage && x.data.length === 0 && He($e)
    })
  }
  var Be = q(qe, 2);
  {
    var Ee = He => {
      var Le = Jt(),
        it = gt(Le);
      th(it, () => x.page, pt => {
        var Oe = gA();
        yi(Oe, () => Je => {
          const bt = new IntersectionObserver(We => {
            We[0].isIntersecting && !x.loading && (x.loading = !0, Jr.getAllianceBannedMembers(x.page).then(Ue => {
              x.data = [...x.data, ...Ue.data], x.hasNextPage = Ue.hasNext, x.page++
            }).catch(Ue => {
              vr.error(Ue.message)
            }).finally(() => {
              x.loading = !1
            }))
          });
          return bt.observe(Je), () => {
            bt.disconnect()
          }
        }), G(pt, Oe)
      }), G(He, Le)
    };
    Ae(Be, He => {
      x.hasNextPage && He(Ee)
    })
  }
  P(ze), P(K), P(A), je((He, Le, it) => {
    le(j, He), mr(ee, "aria-label", Le), mr(Ie, "aria-label", it)
  }, [() => I0(), () => RS(), () => u_()]), G(_, A), Lr()
}
Rn(["click"]);
var xA = me('<span class="label"> </span>'),
  bA = me('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  wA = me('<p class="text-error ml-3 text-sm"> </p>'),
  TA = me('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function Em(_, o) {
  zr(o, !0);
  let f = At(o, "value", 15),
    x = At(o, "validate", 15),
    A = Qe("");
  const L = ct(() => {
    var Ie;
    return ((Ie = f()) == null ? void 0 : Ie.length) ?? 0
  });
  x(w);

  function w() {
    return o.min !== void 0 && y(L) < o.min ? (te(A, y(L) === 0 ? "Required" : `Min. characters: ${o.min}`, !0), !1) : o.max !== void 0 && y(L) > o.max ? (te(A, `Max. characters: ${o.max}`), !1) : !0
  }
  Zr(() => {
    var Ie;
    o.max !== void 0 && y(L) > o.max && f((Ie = f()) == null ? void 0 : Ie.substring(0, o.max))
  });
  var s = TA(),
    B = M(s);
  let j;
  var K = M(B);
  {
    var ee = Ie => {
      var ze = xA(),
        Re = M(ze, !0);
      P(ze), je(() => le(Re, o.label)), G(Ie, ze)
    };
    Ae(K, Ie => {
      o.label && Ie(ee)
    })
  }
  var re = q(K, 2);
  Ba(re);
  var de = q(re, 2);
  {
    var ne = Ie => {
      var ze = bA(),
        Re = M(ze, !0);
      P(ze), je(() => le(Re, o.max - y(L))), G(Ie, ze)
    };
    Ae(de, Ie => {
      o.max !== void 0 && Ie(ne)
    })
  }
  P(B);
  var Y = q(B, 2);
  {
    var we = Ie => {
      var ze = wA(),
        Re = M(ze, !0);
      P(ze), je(() => le(Re, y(A))), G(Ie, ze)
    };
    Ae(Y, Ie => {
      y(A) && Ie(we)
    })
  }
  P(s), je(() => {
    j = Or(B, 1, "input w-full", null, j, {
      "input-error": !!y(A)
    }), mr(re, "placeholder", o.placeholder), mr(re, "maxlength", o.max)
  }), $h(re, f), G(_, s), Lr()
}
var SA = me('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function CA(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15),
    x = Qe(!1),
    A = Qe(""),
    L = Qe(void 0);
  Dn(() => {
    const ze = Re => {
      var ke;
      Re.key === "Escape" && ((ke = f()) == null || ke.close())
    };
    return document.addEventListener("keydown", ze), () => document.removeEventListener("keydown", ze)
  });
  var w = SA(),
    s = M(w),
    B = M(s),
    j = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K),
    re = M(ee);
  {
    let ze = ct(() => Mm()),
      Re = ct(() => cS());
    Em(re, {
      get label() {
        return y(ze)
      },
      get placeholder() {
        return y(Re)
      },
      min: 1,
      max: 16,
      get value() {
        return y(A)
      },
      set value(ke) {
        te(A, ke, !0)
      },
      get validate() {
        return y(L)
      },
      set validate(ke) {
        te(L, ke, !0)
      }
    })
  }
  P(ee);
  var de = q(ee, 2),
    ne = M(de);
  ne.__click = () => {
    var ze;
    (ze = f()) == null || ze.close()
  };
  var Y = M(ne, !0);
  P(ne);
  var we = q(ne, 2),
    Ie = M(we, !0);
  P(we), P(de), P(K), P(s), bn(2), P(w), ko(w, ze => f(ze), () => f()), je((ze, Re, ke) => {
    le(j, ze), ne.disabled = y(x), le(Y, Re), we.disabled = y(x), le(Ie, ke)
  }, [() => oS(), () => Gh(), () => dS()]), Un("submit", K, async () => {
    var ze, Re;
    try {
      if (!((ze = y(L)) != null && ze())) return;
      te(x, !0);
      const {
        id: ke
      } = await Jr.createAlliance(y(A));
      await o.onsuccess(ke), (Re = f()) == null || Re.close()
    } catch (ke) {
      vr.error(ke.message)
    } finally {
      te(x, !1)
    }
  }), G(_, w), Lr()
}
Rn(["click"]);
var PA = Dr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function Wh(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = PA();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var IA = Dr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'),
  MA = Dr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');

function zm(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = gt(x);
  {
    var L = s => {
        var B = IA();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      },
      w = s => {
        var B = MA();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      };
    Ae(A, s => {
      o.filled ? s(L) : s(w, !1)
    })
  }
  G(_, x)
}
var AA = Dr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function kA(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = AA();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var EA = Dr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function zA(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = EA();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var LA = Dr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function DA(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = LA();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var RA = Dr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function ef(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = RA();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}

function FA(_, o = "_blank") {
  return _.replaceAll(/https?:\/\/[^\s]+/g, f => `<a href="${f}"${o?` target="${o}"`:""}>${f}</a>`)
}
var BA = me('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  OA = me('<div class="tooltip"><button class="btn"><!></button></div>'),
  NA = me('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'),
  jA = me('<section class="text-base-content/80 highlight-link"><!> <!></section>'),
  VA = me('<span class="font-semibold"> </span>'),
  qA = me('<button class="text-primary font-semibold underline"> </button>'),
  UA = me('<span class="text-primary underline"> </span>'),
  ZA = me('<span class="text-primary underline"> </span>'),
  GA = me('<button class="text-base-content/80 p-1"><!></button>'),
  $A = me('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'),
  HA = me('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1),
  WA = me('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1),
  XA = me('<div class="h-full"><!></div>');

function YA(_, o) {
  zr(o, !0);
  let f = Qe(void 0),
    x = Qe(!0),
    A = Qe(void 0),
    L = Qe(!1),
    w = Qe(void 0),
    s = Qe(!1),
    B = Qe(!1),
    j = Qe(() => {});
  Rs(() => o.open, () => {
    o.open && Cp.shouldReload && K()
  }), Dn(() => {
    const Y = setInterval(() => {
      Cp.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(Y)
    }
  });
  async function K() {
    try {
      te(f, await Jr.getAlliance(), !0), y(f) && y(j)(), te(x, !1), Cp.shouldReload = !1
    } catch (Y) {
      vr.error(Y.message)
    }
  }
  var ee = XA(),
    re = M(ee);
  {
    var de = Y => {
        var we = BA();
        G(Y, we)
      },
      ne = Y => {
        var we = Jt(),
          Ie = gt(we);
        {
          var ze = ke => {
              yA(ke, {
                onclickback: () => te(B, !1)
              })
            },
            Re = ke => {
              var qe = Jt(),
                $e = gt(qe);
              {
                var Be = He => {
                    var Le = HA(),
                      it = gt(Le),
                      pt = M(it),
                      Oe = M(pt, !0);
                    P(pt);
                    var Je = q(pt, 2),
                      bt = M(Je),
                      We = M(bt),
                      Ue = M(We);
                    S_(Ue, {
                      class: "size-4"
                    }), P(We);
                    var Ge = q(We, 2),
                      Ve = M(Ge),
                      mt = M(Ve);
                    mt.__click = async () => {
                      try {
                        te(L, !0), await Jr.leaveAlliance(), te(x, !0), await K()
                      } catch (Te) {
                        vr.error(Te.message)
                      } finally {
                        te(L, !1)
                      }
                    };
                    var lt = M(mt, !0);
                    P(mt), P(Ve), P(Ge), P(bt);
                    var yt = q(bt, 2);
                    {
                      var _t = Te => {
                        var O = OA(),
                          E = M(O);
                        E.__click = () => {
                          te(s, !0)
                        };
                        var D = M(E);
                        DA(D, {
                          class: "size-4"
                        }), P(E), P(O), je(N => mr(O, "data-tip", N), [() => jT()]), G(Te, O)
                      };
                      Ae(yt, Te => {
                        y(f).role == "admin" && Te(_t)
                      })
                    }
                    P(Je), P(it);
                    var ut = q(it, 2);
                    {
                      var Ut = Te => {
                        var O = jA(),
                          E = M(O);
                        Gp(E, () => FA(y(f).description || V0()));
                        var D = q(E, 2);
                        {
                          var N = H => {
                            var W = NA();
                            W.__click = () => {
                              var ve;
                              (ve = y(w)) == null || ve.show()
                            };
                            var ce = M(W);
                            zm(ce, {
                              class: "size-4"
                            }), P(W), G(H, W)
                          };
                          Ae(D, H => {
                            y(f).role === "admin" && H(N)
                          })
                        }
                        P(O), G(Te, O)
                      };
                      Ae(ut, Te => {
                        (y(f).description || y(f).role === "admin") && Te(Ut)
                      })
                    }
                    var Lt = q(ut, 2),
                      Ke = M(Lt),
                      ot = M(Ke);
                    Wh(ot, {
                      class: "inline size-4"
                    });
                    var xt = q(ot, 2),
                      Ct = M(xt),
                      wt = q(Ct),
                      kt = M(wt, !0);
                    P(wt), P(xt), P(Ke);
                    var Zt = q(Ke, 2),
                      Nt = M(Zt);
                    ef(Nt, {
                      class: "inline size-4"
                    });
                    var $t = q(Nt, 2),
                      It = M($t),
                      Xt = q(It);
                    {
                      var Ot = Te => {
                          var O = VA(),
                            E = M(O, !0);
                          P(O), je(D => le(E, D), [() => y(f).members.toLocaleString("en-US")]), G(Te, O)
                        },
                        jt = Te => {
                          var O = qA();
                          O.__click = () => te(B, !0);
                          var E = M(O, !0);
                          P(O), je(D => le(E, D), [() => y(f).members.toLocaleString("en-US")]), G(Te, O)
                        };
                      Ae(Xt, Te => {
                        y(f).role === "member" ? Te(Ot) : Te(jt, !1)
                      })
                    }
                    P($t), P(Zt);
                    var qt = q(Zt, 2);
                    {
                      var fr = Te => {
                        var O = $A(),
                          E = M(O);
                        kA(E, {
                          class: "inline size-4"
                        });
                        var D = q(E, 2),
                          N = M(D),
                          H = q(N);
                        H.__click = () => {
                          var Ye;
                          (Ye = y(f)) != null && Ye.hq ? o.onhqclick({
                            lat: y(f).hq.latitude,
                            lng: y(f).hq.longitude
                          }) : o.onhqchange()
                        };
                        var W = M(H);
                        {
                          var ce = Ye => {
                              var Ze = UA(),
                                Tt = M(Ze);
                              P(Ze), je((_e, Vt) => le(Tt, `${_e??""}, ${Vt??""}`), [() => y(f).hq.latitude.toFixed(3), () => y(f).hq.longitude.toFixed(3)]), G(Ye, Ze)
                            },
                            ve = Ye => {
                              var Ze = ZA(),
                                Tt = M(Ze, !0);
                              P(Ze), je(_e => le(Tt, _e), [() => mT()]), G(Ye, Ze)
                            };
                          Ae(W, Ye => {
                            y(f).hq ? Ye(ce) : Ye(ve, !1)
                          })
                        }
                        P(H), P(D);
                        var he = q(D, 2);
                        {
                          var Se = Ye => {
                            var Ze = GA();
                            Ze.__click = function(..._e) {
                              var Vt;
                              (Vt = o.onhqchange) == null || Vt.apply(this, _e)
                            };
                            var Tt = M(Ze);
                            zm(Tt, {
                              class: "text-base-content/50 size-4"
                            }), P(Ze), G(Ye, Ze)
                          };
                          Ae(he, Ye => {
                            y(f).role === "admin" && Ye(Se)
                          })
                        }
                        P(O), je(Ye => le(N, `${Ye??""}: `), [() => dT()]), G(Te, O)
                      };
                      Ae(qt, Te => {
                        (y(f).hq || y(f).role === "admin") && Te(fr)
                      })
                    }
                    P(Lt);
                    var Kt = q(Lt, 2),
                      _r = M(Kt),
                      rr = M(_r, !0);
                    P(_r);
                    var hr = q(_r, 2),
                      nr = M(hr);
                    lA(nr, {
                      get allianceId() {
                        return y(f).id
                      },
                      get onlastpixelclick() {
                        return o.onlastpixelclick
                      },
                      get reload() {
                        return y(j)
                      },
                      set reload(Te) {
                        te(j, Te, !0)
                      }
                    }), P(hr), P(Kt);
                    var Et = q(Kt, 2);
                    D6(Et, {
                      get description() {
                        return y(f).description
                      },
                      onsuccess: async Te => {
                        y(f) && (y(f).description = Te)
                      },
                      get ref() {
                        return y(w)
                      },
                      set ref(Te) {
                        te(w, Te, !0)
                      }
                    });
                    var kr = q(Et, 2);
                    B6(kr, {
                      get open() {
                        return y(s)
                      },
                      set open(Te) {
                        te(s, Te, !0)
                      }
                    }), je((Te, O, E, D, N) => {
                      le(Oe, y(f).name), mt.disabled = y(L), le(lt, Te), le(Ct, `${O??""}: `), le(kt, E), le(It, `${D??""}: `), le(rr, N)
                    }, [() => cT(), () => c_(), () => y(f).pixelsPainted.toLocaleString("en-US"), () => I0(), () => m_()]), G(He, Le)
                  },
                  Ee = He => {
                    var Le = WA(),
                      it = gt(Le),
                      pt = M(it),
                      Oe = M(pt);
                    P(pt);
                    var Je = q(pt, 2),
                      bt = M(Je);
                    zA(bt, {
                      class: "size-5"
                    });
                    var We = q(bt, 1, !0);
                    P(Je);
                    var Ue = q(Je, 2),
                      Ge = M(Ue),
                      Ve = M(Ge, !0);
                    P(Ge), P(Ue);
                    var mt = q(Ue, 2);
                    mt.__click = () => {
                      var ut;
                      (ut = y(A)) == null || ut.show()
                    };
                    var lt = M(mt);
                    k0(lt, {
                      class: "size-6"
                    });
                    var yt = q(lt);
                    P(mt), P(it);
                    var _t = q(it, 2);
                    CA(_t, {
                      onsuccess: K,
                      get ref() {
                        return y(A)
                      },
                      set ref(ut) {
                        te(A, ut, !0)
                      }
                    }), je((ut, Ut, Lt, Ke) => {
                      le(Oe, `${ut??""}:`), le(We, Ut), le(Ve, Lt), le(yt, ` ${Ke??""}`)
                    }, [() => vT(), () => bT(), () => ST(), () => IT()]), G(He, Le)
                  };
                Ae($e, He => {
                  y(f) ? He(Be) : He(Ee, !1)
                }, !0)
              }
              G(ke, qe)
            };
          Ae(Ie, ke => {
            y(B) ? ke(ze) : ke(Re, !1)
          }, !0)
        }
        G(Y, we)
      };
    Ae(re, Y => {
      y(x) ? Y(de) : Y(ne, !1)
    })
  }
  P(ee), G(_, ee), Lr()
}
Rn(["click"]);
var KA = Dr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function tf(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = KA();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var JA = me('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function QA(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  Dn(() => {
    const ee = re => {
      re.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", ee), () => document.removeEventListener("keydown", ee)
  });
  var x = JA(),
    A = M(x),
    L = q(M(A), 2),
    w = M(L);
  tf(w, {
    class: "size-5 max-sm:size-6"
  });
  var s = q(w, 2),
    B = M(s, !0);
  P(s), P(L);
  var j = q(L, 2),
    K = M(j);
  YA(K, {
    get open() {
      return f()
    },
    get onhqchange() {
      return o.onhqchange
    },
    get onhqclick() {
      return o.onhqclick
    },
    get onlastpixelclick() {
      return o.onlastpixelclick
    }
  }), P(j), P(A), bn(2), P(x), yi(x, () => ee => {
    Zr(() => {
      f() ? (ee.show(), ui.url.searchParams.get("alliance") && (ui.url.searchParams.delete("alliance"), Ep(ui.url.toString()))) : ee.close()
    })
  }), je(ee => le(B, ee), [() => Kp()]), Un("close", x, () => f(!1)), aa(2, j, () => Wa, () => ({
    duration: 300
  })), G(_, x), Lr()
}

function ek(_, o, f) {
  return new Promise((x, A) => {
    _.once("render", () => {
      const L = _.getCanvas().toDataURL(),
        w = document.createElement("img");
      w.src = L, w.onload = () => {
        const s = document.createElement("canvas");
        s.width = w.width, s.height = w.height;
        const B = s.getContext("2d");
        if (B) {
          B.drawImage(w, 0, 0);
          const [j, K, ee, re] = B.getImageData(o, f, 1, 1).data;
          x([j, K, ee, re])
        } else A(new Error("Could not get 2d context from canvas"));
        w.remove(), s.remove()
      }
    }), _.triggerRepaint()
  })
}

function C_(_, o) {
  return new Promise((f, x) => {
    _.once("render", () => {
      const A = _.getCanvas();
      let L = A;
      if (o != null && o.maxWidth || o != null && o.maxHeight) {
        const w = A.width,
          s = A.height,
          B = (o == null ? void 0 : o.maxWidth) ?? w,
          j = (o == null ? void 0 : o.maxHeight) ?? s;
        L = document.createElement("canvas");
        const K = Math.min(B / w, j / s);
        L.width = Math.floor(w * K), L.height = Math.floor(s * K);
        const ee = L.getContext("2d");
        ee && ee.drawImage(A, 0, 0, L.width, L.height)
      }
      try {
        L.toBlob(w => {
          w && f(w)
        }, (o == null ? void 0 : o.type) ?? "image/png", (o == null ? void 0 : o.quality) ?? 1)
      } catch (w) {
        x(w)
      } finally {
        L !== A && L.remove()
      }
    })
  })
}
var tk = Dr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function rk(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = tk();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var nk = Dr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function ty(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = nk();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
const Ic = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function Lp(_) {
  const o = Math.floor(_ / Ic.hour);
  _ -= o * Ic.hour;
  const f = Math.floor(_ / Ic.min);
  _ -= f * Ic.min;
  const A = Math.floor(_ / Ic.sec).toString().padStart(2, "0");
  return o > 0 ? `${o}:${f.toString().padStart(2,"0")}:${A}` : `${f}:${A}`
}

function ik(_) {
  const o = _.getFullYear(),
    f = String(_.getMonth() + 1).padStart(2, "0"),
    x = String(_.getDate()).padStart(2, "0"),
    A = String(_.getHours()).padStart(2, "0"),
    L = String(_.getMinutes()).padStart(2, "0"),
    w = String(_.getSeconds()).padStart(2, "0");
  return `${o}-${f}-${x} ${A}:${L}:${w}`
}
var ak = me('<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'),
  ok = me('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  sk = me('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  lk = me('<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'),
  ck = me('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function uk(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(!1);
  Dn(() => {
    const $e = Be => {
      Be.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", $e), () => document.removeEventListener("keydown", $e)
  });
  let A = Qe(null),
    L = Qe("");
  const w = ct(() => {
    const $e = new URL(o.url.toString()),
      Be = $e.searchParams.get("lat"),
      Ee = $e.searchParams.get("lng");
    if (Be && Ee) return {
      lat: parseFloat(Be),
      lng: parseFloat(Ee)
    }
  });
  Zr(() => {
    f() ? (o.hideHover(), setTimeout(async () => {
      C_(o.map).then($e => {
        te(A, $e, !0), te(L, URL.createObjectURL(y(A)), !0)
      }).finally(() => {
        o.showHover()
      })
    }, 500)) : y(L) && (URL.revokeObjectURL(y(L)), te(A, null), te(L, ""))
  });
  var s = ck(),
    B = M(s),
    j = q(M(B), 2),
    K = M(j);
  ty(K, {
    class: "size-5"
  });
  var ee = q(K);
  P(j);
  var re = q(j, 2),
    de = M(re);
  Ba(de);
  var ne = q(de, 2),
    Y = M(ne);
  let we;
  Y.__click = () => {
    navigator.clipboard.writeText(o.url.toString()), te(x, !0), setTimeout(() => {
      te(x, !1)
    }, 1e3)
  };
  var Ie = M(Y, !0);
  P(Y), P(ne), P(re);
  var ze = q(re, 2);
  {
    var Re = $e => {
      var Be = ak(),
        Ee = M(Be),
        He = M(Ee);
      P(Ee);
      var Le = q(Ee);
      P(Be), je(it => {
        le(He, `${it??""}:`), le(Le, ` ${y(w).lat??""}, ${y(w).lng??""}`)
      }, [() => X0()]), G($e, Be)
    };
    Ae(ze, $e => {
      y(w) && $e(Re)
    })
  }
  var ke = q(ze, 2);
  {
    var qe = $e => {
      const Be = ct(() => {
        var yt;
        return (yt = o.map) == null ? void 0 : yt.getCanvas()
      });
      var Ee = lk(),
        He = M(Ee),
        Le = M(He);
      rk(Le, {
        class: "inline size-5"
      });
      var it = q(Le);
      P(He);
      var pt = q(He, 2);
      {
        var Oe = yt => {
            var _t = ok();
            je(() => {
              mr(_t, "src", y(L)), mr(_t, "width", y(Be).width), mr(_t, "height", y(Be).height)
            }), G(yt, _t)
          },
          Je = yt => {
            var _t = sk();
            je(() => Oc(_t, `aspect-ratio: ${y(Be).width/y(Be).height}`)), G(yt, _t)
          };
        Ae(pt, yt => {
          y(L) ? yt(Oe) : yt(Je, !1)
        })
      }
      var bt = q(pt, 2),
        We = M(bt);
      We.__click = async () => {
        y(A) && (await navigator.clipboard.write([new ClipboardItem({
          "image/png": y(A)
        })]), vr.info(uI()))
      };
      var Ue = M(We);
      p_(Ue, {
        class: "size-5"
      });
      var Ge = q(Ue);
      P(We);
      var Ve = q(We, 2),
        mt = M(Ve);
      S0(mt, {
        class: "size-5"
      });
      var lt = q(mt);
      P(Ve), P(bt), P(Ee), je((yt, _t, ut, Ut) => {
        le(it, ` ${yt??""}`), le(Ge, ` ${_t??""}`), mr(Ve, "href", y(L)), mr(Ve, "download", `wplace_${ut??""}.png`), le(lt, ` ${Ut??""}`)
      }, [() => iI(), () => Sm(), () => ik(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => sI()]), aa(2, Ee, () => Wa, () => ({
        duration: 300
      })), G($e, Ee)
    };
    Ae(ke, $e => {
      f() && $e(qe)
    })
  }
  P(B), bn(2), P(s), yi(s, () => $e => {
    Zr(() => {
      f() ? $e.show() : $e.close()
    })
  }), je(($e, Be, Ee) => {
    le(ee, ` ${$e??""}`), x0(de, Be), we = Or(Y, 1, "btn btn-primary", null, we, {
      "btn-success": y(x)
    }), le(Ie, Ee)
  }, [() => yC(), () => o.url.toString(), () => y(x) ? g_() : Sm()]), Un("close", s, () => f(!1)), G(_, s), Lr()
}
Rn(["click"]);
var hk = Dr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function dk(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = hk();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var pk = me('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  fk = me('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function P_(_, o) {
  zr(o, !1);
  const f = [U5(), j5(), $5(), X5(), J5(), t3(), i3()];
  D0();
  var x = fk(),
    A = M(x),
    L = M(A);
  dk(L, {
    class: "size-5"
  });
  var w = q(L, 2),
    s = M(w),
    B = q(s),
    j = M(B, !0);
  P(B), P(w), P(A);
  var K = q(A, 2),
    ee = M(K);
  ii(ee, 5, () => f, Hp, (ze, Re) => {
    var ke = pk(),
      qe = M(ke, !0);
    P(ke), je(() => le(qe, y(Re))), G(ze, ke)
  }), P(ee);
  var re = q(ee, 2),
    de = M(re, !0);
  P(re);
  var ne = q(re, 2),
    Y = M(ne),
    we = q(Y),
    Ie = M(we, !0);
  P(we), bn(), P(ne), P(K), P(x), je((ze, Re, ke, qe, $e) => {
    le(s, `${ze??""} `), le(j, Re), le(de, ke), le(Y, `${qe??""} `), le(Ie, $e)
  }, [() => D5(), () => B5(), () => s3(), () => O4(), () => V4()]), G(_, x), Lr()
}
var mk = me('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">üìë Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function _k(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  Dn(() => {
    const j = K => {
      K.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", j), () => document.removeEventListener("keydown", j)
  });
  var x = mk(),
    A = M(x),
    L = q(M(A), 2),
    w = q(M(L), 2),
    s = M(w);
  P_(s, {}), P(w);
  var B = q(w, 2);
  B.__click = () => {
    f(!1)
  }, P(L), P(A), bn(2), P(x), yi(x, () => j => {
    Zr(() => {
      f() ? j.show() : j.close()
    })
  }), Un("close", x, () => f(!1)), G(_, x), Lr()
}
Rn(["click"]);
var gk = me('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function vk(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  Dn(() => {
    const Y = we => {
      we.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", Y), () => document.removeEventListener("keydown", Y)
  });
  var x = gk(),
    A = M(x),
    L = M(A),
    w = M(L),
    s = M(w),
    B = M(s, !0);
  P(s);
  var j = q(s, 2);
  f_(j, {
    hasText: !0,
    size: "medium"
  }), P(w), P(L);
  var K = q(L, 2),
    ee = M(K);
  P_(ee, {}), P(K);
  var re = q(K, 2),
    de = M(re);
  de.__click = () => {
    ui.url.searchParams.delete("new-user"), Ep(ui.url.toString())
  };
  var ne = M(de, !0);
  P(de), P(re), P(A), P(x), yi(x, () => Y => {
    Zr(() => {
      f() ? Y.show() : Y.close()
    })
  }), je((Y, we) => {
    le(B, Y), le(ne, we)
  }, [() => E5(), () => u3()]), Un("close", x, () => f(!1)), G(_, x), Lr()
}
Rn(["click"]);

function yk() {
  const _ = navigator.userAgent,
    o = navigator.vendor;
  return /Chrome/.test(_) && /Google Inc/.test(o) ? "Chrome" : /Safari/.test(_) && /Apple Computer/.test(o) ? "Safari" : /Firefox/.test(_) ? "Firefox" : /Edge/.test(_) ? "Edge" : /Opera|OPR/.test(_) ? "Opera" : "Unknown"
}
var xk = Dr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function bk(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = xk();
  cr(x, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...f
  })), G(_, x)
}
var wk = Dr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function Lm(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = wk();
  cr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var Tk = Dr('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function Sk(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Tk();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...f
  })), G(_, x)
}
var Ck = Dr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function Dp(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Ck();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var Pk = Dr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function Ik(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Pk();
  cr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...f
  })), G(_, x)
}
var Mk = Dr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function Ak(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Mk();
  cr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...f
  })), G(_, x)
}
var kk = me(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  Ek = me('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  zk = me('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  Lk = me(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
  Dk = me('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/tpDWwewuK5i9C52s8" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> ¬∑ <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  Rk = me('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function Fk(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  Dn(() => {
    const ee = re => {
      re.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", ee), () => document.removeEventListener("keydown", ee)
  });
  const x = yk();
  var A = Rk(),
    L = M(A),
    w = q(M(L), 2);
  {
    var s = ee => {
      var re = Dk(),
        de = M(re),
        ne = M(de);
      f_(ne, {
        hasText: !0,
        size: "medium"
      });
      var Y = q(ne, 2),
        we = M(Y),
        Ie = q(we, 4);
      bn(), P(Y);
      var ze = q(Y, 2),
        Re = M(ze),
        ke = M(Re),
        qe = M(ke);
      Lm(qe, {
        class: "text-base-content mr-0.5 inline size-4"
      }), bn(2), P(ke);
      var $e = q(ke, 4),
        Be = M($e);
      bk(Be, {
        class: "size-4.5 mr-0.5 inline"
      }), bn(2), P($e);
      var Ee = q($e, 4),
        He = M(Ee);
      Sk(He, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), P(Ee);
      var Le = q(Ee, 4),
        it = M(Le);
      Ak(it, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), P(Le);
      var pt = q(Le, 4),
        Oe = M(pt);
      Ik(Oe, {
        class: "mr-0.5 inline size-3.5"
      }), bn(2), P(pt), P(Re), P(ze), P(de);
      var Je = q(de, 2),
        bt = M(Je),
        We = M(bt, !0);
      P(bt);
      var Ue = q(bt, 2);
      P(Je);
      var Ge = q(Je, 2),
        Ve = M(Ge),
        mt = M(Ve, !0);
      P(Ve);
      var lt = q(Ve, 2),
        yt = M(lt),
        _t = q(yt),
        ut = M(_t);
      Dp(ut, {
        class: "size-5"
      }), P(_t);
      var Ut = q(_t);
      P(lt);
      var Lt = q(lt, 2),
        Ke = M(Lt),
        ot = q(Ke),
        xt = M(ot, !0);
      P(ot);
      var Ct = q(ot);
      P(Lt), P(Ge);
      var wt = q(Ge, 2),
        kt = M(wt),
        Zt = M(kt, !0);
      P(kt);
      var Nt = q(kt, 2),
        $t = M(Nt);
      {
        var It = N => {
            var H = kk(),
              W = gt(H);
            bn(), je(ce => le(W, `${ce??""}: `), [() => CI()]), G(N, H)
          },
          Xt = N => {
            var H = Lk(),
              W = gt(H),
              ce = q(W),
              ve = M(ce, !0);
            P(ce);
            var he = q(ce),
              Se = q(he);
            {
              var Ye = Tt => {
                  var _e = Ek();
                  bn(), G(Tt, _e)
                },
                Ze = Tt => {
                  var _e = Jt(),
                    Vt = gt(_e);
                  {
                    var ur = Ft => {
                      var or = zk();
                      bn(), G(Ft, or)
                    };
                    Ae(Vt, Ft => {
                      x === "Edge" && Ft(ur)
                    }, !0)
                  }
                  G(Tt, _e)
                };
              Ae(Se, Tt => {
                x === "Chrome" ? Tt(Ye) : Tt(Ze, !1)
              })
            }
            je((Tt, _e, Vt) => {
              le(W, `${Tt??""} `), le(ve, _e), le(he, ` ${Vt??""} `)
            }, [() => _I(), () => yI(), () => wI()]), G(N, H)
          };
        Ae($t, N => {
          x !== "Chrome" && x !== "Edge" ? N(It) : N(Xt, !1)
        })
      }
      P(Nt), P(wt);
      var Ot = q(wt, 2),
        jt = M(Ot);
      P_(jt, {}), P(Ot);
      var qt = q(Ot, 4),
        fr = q(M(qt), 2),
        Kt = M(fr, !0);
      P(fr);
      var _r = q(fr, 2),
        rr = M(_r, !0);
      P(_r);
      var hr = q(_r, 2),
        nr = M(hr, !0);
      P(hr);
      var Et = q(hr, 2),
        kr = M(Et, !0);
      P(Et);
      var Te = q(Et, 2),
        O = M(Te, !0);
      P(Te);
      var E = q(Te, 2),
        D = M(E, !0);
      P(E), P(qt), P(re), je((N, H, W, ce, ve, he, Se, Ye, Ze, Tt, _e, Vt, ur, Ft, or, Vr, qr) => {
        le(we, `${N??""} `), le(Ie, ` ¬©
						${H??""} `), le(We, W), mr(Ue, "src", fa.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), le(mt, ce), le(yt, `${ve??""} `), le(Ut, ` ${he??""}`), le(Ke, `${Se??""} `), le(xt, Ye), le(Ct, ` ${Ze??""}`), le(Zt, Tt), mr(fr, "href", `${ui.url.origin??""}/terms/terms-of-service`), le(Kt, _e), mr(_r, "href", `${ui.url.origin??""}/terms/privacy`), le(rr, Vt), mr(hr, "href", ur), le(nr, Ft), le(kr, or), le(O, Vr), le(D, qr)
      }, [() => B2(), () => j2(), () => U2(), () => $2(), () => X2(), () => J2(), () => tw(), () => iw(), () => sw(), () => pI(), () => EI(), () => DI(), () => E0(ui.url.origin), () => G0(), () => W0(), () => z4(), () => R4()]), aa(2, re, () => Wa, () => ({
        duration: 300
      })), G(ee, re)
    };
    Ae(w, ee => {
      f() && ee(s)
    })
  }
  P(L);
  var B = q(L, 2),
    j = M(B),
    K = M(j, !0);
  P(j), P(B), P(A), yi(A, () => ee => {
    Zr(() => {
      f() ? ee.show() : ee.close()
    })
  }), je(ee => le(K, ee), [() => cs()]), Un("close", A, () => f(!1)), G(_, A), Lr()
}

function Xh(_) {
  return _ !== null && typeof _ == "object"
}
const Bk = ["string", "number", "bigint", "boolean"];

function Dm(_) {
  return _ == null || Bk.includes(typeof _) ? !0 : Array.isArray(_) ? _.every(o => Dm(o)) : typeof _ == "object" ? Object.getPrototypeOf(_) === Object.prototype : !1
}
const Rp = Symbol("box"),
  ry = Symbol("is-writable");

function Hr(_, o) {
  const f = ct(_);
  return o ? {
    [Rp]: !0,
    [ry]: !0,
    get current() {
      return y(f)
    },
    set current(x) {
      o(x)
    }
  } : {
    [Rp]: !0,
    get current() {
      return _()
    }
  }
}

function Ok(_) {
  return Xh(_) && Rp in _
}

function Vv(_) {
  let o = Qe(Si(_));
  return {
    [Rp]: !0,
    [ry]: !0,
    get current() {
      return y(o)
    },
    set current(f) {
      te(o, f, !0)
    }
  }
}

function Nk(..._) {
  return function(o) {
    var f;
    for (const x of _)
      if (x) {
        if (o.defaultPrevented) return;
        typeof x == "function" ? x.call(this, o) : (f = x.current) == null || f.call(this, o)
      }
  }
}
var qv = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  jk = /\n/g,
  Vk = /^\s*/,
  qk = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  Uk = /^:\s*/,
  Zk = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  Gk = /^[;\s]*/,
  $k = /^\s+|\s+$/g,
  Hk = `
`,
  Uv = "/",
  Zv = "*",
  fl = "",
  Wk = "comment",
  Xk = "declaration";

function Yk(_, o) {
  if (typeof _ != "string") throw new TypeError("First argument must be a string");
  if (!_) return [];
  o = o || {};
  var f = 1,
    x = 1;

  function A(ne) {
    var Y = ne.match(jk);
    Y && (f += Y.length);
    var we = ne.lastIndexOf(Hk);
    x = ~we ? ne.length - we : x + ne.length
  }

  function L() {
    var ne = {
      line: f,
      column: x
    };
    return function(Y) {
      return Y.position = new w(ne), j(), Y
    }
  }

  function w(ne) {
    this.start = ne, this.end = {
      line: f,
      column: x
    }, this.source = o.source
  }
  w.prototype.content = _;

  function s(ne) {
    var Y = new Error(o.source + ":" + f + ":" + x + ": " + ne);
    if (Y.reason = ne, Y.filename = o.source, Y.line = f, Y.column = x, Y.source = _, !o.silent) throw Y
  }

  function B(ne) {
    var Y = ne.exec(_);
    if (Y) {
      var we = Y[0];
      return A(we), _ = _.slice(we.length), Y
    }
  }

  function j() {
    B(Vk)
  }

  function K(ne) {
    var Y;
    for (ne = ne || []; Y = ee();) Y !== !1 && ne.push(Y);
    return ne
  }

  function ee() {
    var ne = L();
    if (!(Uv != _.charAt(0) || Zv != _.charAt(1))) {
      for (var Y = 2; fl != _.charAt(Y) && (Zv != _.charAt(Y) || Uv != _.charAt(Y + 1));) ++Y;
      if (Y += 2, fl === _.charAt(Y - 1)) return s("End of comment missing");
      var we = _.slice(2, Y - 2);
      return x += 2, A(we), _ = _.slice(Y), x += 2, ne({
        type: Wk,
        comment: we
      })
    }
  }

  function re() {
    var ne = L(),
      Y = B(qk);
    if (Y) {
      if (ee(), !B(Uk)) return s("property missing ':'");
      var we = B(Zk),
        Ie = ne({
          type: Xk,
          property: Gv(Y[0].replace(qv, fl)),
          value: we ? Gv(we[0].replace(qv, fl)) : fl
        });
      return B(Gk), Ie
    }
  }

  function de() {
    var ne = [];
    K(ne);
    for (var Y; Y = re();) Y !== !1 && (ne.push(Y), K(ne));
    return ne
  }
  return j(), de()
}

function Gv(_) {
  return _ ? _.replace($k, fl) : fl
}

function Kk(_, o) {
  let f = null;
  if (!_ || typeof _ != "string") return f;
  const x = Yk(_),
    A = typeof o == "function";
  return x.forEach(L => {
    if (L.type !== "declaration") return;
    const {
      property: w,
      value: s
    } = L;
    A ? o(w, s, L) : s && (f = f || {}, f[w] = s)
  }), f
}
const Jk = /\d/,
  Qk = ["-", "_", "/", "."];

function eE(_ = "") {
  if (!Jk.test(_)) return _ !== _.toLowerCase()
}

function tE(_) {
  const o = [];
  let f = "",
    x, A;
  for (const L of _) {
    const w = Qk.includes(L);
    if (w === !0) {
      o.push(f), f = "", x = void 0;
      continue
    }
    const s = eE(L);
    if (A === !1) {
      if (x === !1 && s === !0) {
        o.push(f), f = L, x = s;
        continue
      }
      if (x === !0 && s === !1 && f.length > 1) {
        const B = f.at(-1);
        o.push(f.slice(0, Math.max(0, f.length - 1))), f = B + L, x = s;
        continue
      }
    }
    f += L, x = s, A = w
  }
  return o.push(f), o
}

function ny(_) {
  return _ ? tE(_).map(o => nE(o)).join("") : ""
}

function rE(_) {
  return iE(ny(_ || ""))
}

function nE(_) {
  return _ ? _[0].toUpperCase() + _.slice(1) : ""
}

function iE(_) {
  return _ ? _[0].toLowerCase() + _.slice(1) : ""
}

function gp(_) {
  if (!_) return {};
  const o = {};

  function f(x, A) {
    if (x.startsWith("-moz-") || x.startsWith("-webkit-") || x.startsWith("-ms-") || x.startsWith("-o-")) {
      o[ny(x)] = A;
      return
    }
    if (x.startsWith("--")) {
      o[x] = A;
      return
    }
    o[rE(x)] = A
  }
  return Kk(_, f), o
}

function aE(..._) {
  return (...o) => {
    for (const f of _) typeof f == "function" && f(...o)
  }
}

function oE(_, o) {
  const f = RegExp(_, "g");
  return x => {
    if (typeof x != "string") throw new TypeError(`expected an argument of type string, but got ${typeof x}`);
    return x.match(f) ? x.replace(f, o) : x
  }
}
const sE = oE(/[A-Z]/, _ => `-${_.toLowerCase()}`);

function lE(_) {
  if (!_ || typeof _ != "object" || Array.isArray(_)) throw new TypeError(`expected an argument of type object, but got ${typeof _}`);
  return Object.keys(_).map(o => `${sE(o)}: ${_[o]};`).join(`
`)
}

function iy(_ = {}) {
  return lE(_).replace(`
`, " ")
}
const cE = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  uE = new Set(cE);

function hE(_) {
  return uE.has(_)
}

function Fa(..._) {
  const o = {
    ..._[0]
  };
  for (let f = 1; f < _.length; f++) {
    const x = _[f];
    if (x) {
      for (const A of Object.keys(x)) {
        const L = o[A],
          w = x[A],
          s = typeof L == "function",
          B = typeof w == "function";
        if (s && hE(A)) {
          const j = L,
            K = w;
          o[A] = Nk(j, K)
        } else if (s && B) o[A] = aE(L, w);
        else if (A === "class") {
          const j = Dm(L),
            K = Dm(w);
          j && K ? o[A] = Qu(L, w) : j ? o[A] = Qu(L) : K && (o[A] = Qu(w))
        } else if (A === "style") {
          const j = typeof L == "object",
            K = typeof w == "object",
            ee = typeof L == "string",
            re = typeof w == "string";
          if (j && K) o[A] = {
            ...L,
            ...w
          };
          else if (j && re) {
            const de = gp(w);
            o[A] = {
              ...L,
              ...de
            }
          } else if (ee && K) {
            const de = gp(L);
            o[A] = {
              ...de,
              ...w
            }
          } else if (ee && re) {
            const de = gp(L),
              ne = gp(w);
            o[A] = {
              ...de,
              ...ne
            }
          } else j ? o[A] = L : K ? o[A] = w : ee ? o[A] = L : re && (o[A] = w)
        } else o[A] = w !== void 0 ? w : L
      }
      for (const A of Object.getOwnPropertySymbols(x)) {
        const L = o[A],
          w = x[A];
        o[A] = w !== void 0 ? w : L
      }
    }
  }
  return typeof o.style == "object" && (o.style = iy(o.style).replaceAll(`
`, " ")), o.hidden === !1 && (o.hidden = void 0, delete o.hidden), o.disabled === !1 && (o.disabled = void 0, delete o.disabled), o
}
const ay = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
iy(ay);
const dE = typeof window < "u" ? window : void 0;

function pE(_) {
  let o = _.activeElement;
  for (; o != null && o.shadowRoot;) {
    const f = o.shadowRoot.activeElement;
    if (f === o) break;
    o = f
  }
  return o
}
var Ec, hh;
class fE {
  constructor(o = {}) {
    Pr(this, Ec);
    Pr(this, hh);
    const {
      window: f = dE,
      document: x = f == null ? void 0 : f.document
    } = o;
    f !== void 0 && (Hi(this, Ec, x), Hi(this, hh, y0(A => {
      const L = eh(f, "focusin", A),
        w = eh(f, "focusout", A);
      return () => {
        L(), w()
      }
    })))
  }
  get current() {
    var o;
    return (o = Xe(this, hh)) == null || o.call(this), Xe(this, Ec) ? pE(Xe(this, Ec)) : null
  }
}
Ec = new WeakMap, hh = new WeakMap;
new fE;
var dh, as;
class I_ {
  constructor(o) {
    Pr(this, dh);
    Pr(this, as);
    Hi(this, dh, o), Hi(this, as, Symbol(o))
  }
  get key() {
    return Xe(this, as)
  }
  exists() {
    return tb(Xe(this, as))
  }
  get() {
    const o = Mv(Xe(this, as));
    if (o === void 0) throw new Error(`Context "${Xe(this,dh)}" not found`);
    return o
  }
  getOr(o) {
    const f = Mv(Xe(this, as));
    return f === void 0 ? o : f
  }
  set(o) {
    return rb(Xe(this, as), o)
  }
}
dh = new WeakMap, as = new WeakMap;

function mE(_, o) {
  switch (_) {
    case "post":
      Zr(o);
      break;
    case "pre":
      s_(o);
      break
  }
}

function oy(_, o, f, x = {}) {
  const {
    lazy: A = !1
  } = x;
  let L = !A,
    w = Array.isArray(_) ? [] : void 0;
  mE(o, () => {
    const s = Array.isArray(_) ? _.map(j => j()) : _();
    if (!L) {
      L = !0, w = s;
      return
    }
    const B = yl(() => f(s, w));
    return w = s, B
  })
}

function xl(_, o, f) {
  oy(_, "post", o, f)
}

function _E(_, o, f) {
  oy(_, "pre", o, f)
}
xl.pre = _E;
var ph, Op;
class gE {
  constructor(o, f) {
    Pr(this, ph, () => {});
    Pr(this, Op, ct(() => Xe(this, ph).call(this)));
    let x;
    f !== void 0 && (x = f), Hi(this, ph, () => {
      try {
        return x
      } finally {
        x = o()
      }
    })
  }
  get current() {
    return y(Xe(this, Op))
  }
}
ph = new WeakMap, Op = new WeakMap;

function vE(_, o) {
  return setTimeout(o, _)
}

function wc(_) {
  g0().then(_)
}
const yE = 1,
  xE = 9,
  bE = 11;

function wE(_) {
  return Xh(_) && _.nodeType === yE && typeof _.nodeName == "string"
}

function sy(_) {
  return Xh(_) && _.nodeType === xE
}

function TE(_) {
  var o;
  return Xh(_) && ((o = _.constructor) == null ? void 0 : o.name) === "VisualViewport"
}

function SE(_) {
  return Xh(_) && _.nodeType !== void 0
}

function CE(_) {
  return SE(_) && _.nodeType === bE && "host" in _
}

function PE(_) {
  return sy(_) ? _ : TE(_) ? _.document : (_ == null ? void 0 : _.ownerDocument) ?? document
}

function ly(_) {
  var o;
  return CE(_) ? ly(_.host) : sy(_) ? _.defaultView ?? window : wE(_) ? ((o = _.ownerDocument) == null ? void 0 : o.defaultView) ?? window : window
}

function IE(_) {
  let o = _.activeElement;
  for (; o != null && o.shadowRoot;) {
    const f = o.shadowRoot.activeElement;
    if (f === o) break;
    o = f
  }
  return o
}
var fh;
class ME {
  constructor(o) {
    Cr(this, "element");
    Pr(this, fh, ct(() => this.element.current ? this.element.current.getRootNode() ?? document : document));
    Cr(this, "getDocument", () => PE(this.root));
    Cr(this, "getWindow", () => this.getDocument().defaultView ?? window);
    Cr(this, "getActiveElement", () => IE(this.root));
    Cr(this, "isActiveElement", o => o === this.getActiveElement());
    Cr(this, "querySelector", o => this.root ? this.root.querySelector(o) : null);
    Cr(this, "querySelectorAll", o => this.root ? this.root.querySelectorAll(o) : []);
    Cr(this, "setTimeout", (o, f) => this.getWindow().setTimeout(o, f));
    Cr(this, "clearTimeout", o => this.getWindow().clearTimeout(o));
    typeof o == "function" ? this.element = Hr(o) : this.element = o
  }
  get root() {
    return y(Xe(this, fh))
  }
  set root(o) {
    te(Xe(this, fh), o)
  }
  getElementById(o) {
    return this.root.getElementById(o)
  }
}
fh = new WeakMap;

function Xa(_, o) {
  return {
    [Xb()]: f => Ok(_) ? (_.current = f, yl(() => o == null ? void 0 : o(f)), () => {
      "isConnected" in f && f.isConnected || (_.current = null, o == null || o(null))
    }) : (_(f), yl(() => o == null ? void 0 : o(f)), () => {
      "isConnected" in f && f.isConnected || (_(null), o == null || o(null))
    })
  }
}

function Rm(_) {
  return _ ? "true" : "false"
}

function $v(_) {
  return _ ? "" : void 0
}

function AE(_) {
  return _ ? !0 : void 0
}
var zc, mh;
class kE {
  constructor(o) {
    Pr(this, zc);
    Pr(this, mh);
    Cr(this, "attrs");
    Hi(this, zc, o.getVariant ? o.getVariant() : null), Hi(this, mh, Xe(this, zc) ? `data-${Xe(this,zc)}-` : `data-${o.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(o.parts.map(f => [f, this.getAttr(f)]))
  }
  getAttr(o, f) {
    return f ? `data-${f}-${o}` : `${Xe(this,mh)}${o}`
  }
  selector(o, f) {
    return `[${this.getAttr(o,f)}]`
  }
}
zc = new WeakMap, mh = new WeakMap;

function cy(_) {
  const o = new kE(_);
  return {
    ...o.attrs,
    selector: o.selector,
    getAttr: o.getAttr
  }
}
const EE = "ArrowDown",
  zE = "ArrowLeft",
  LE = "ArrowRight",
  DE = "ArrowUp",
  RE = "End",
  FE = "Enter",
  BE = "Home",
  OE = "p",
  NE = "n",
  jE = "j",
  VE = "k",
  qE = "h",
  UE = "l";

function nh() {}

function Ya(_, o) {
  return `bits-${_}`
}

function ZE(_) {
  if (!_) return null;
  for (const o of _.childNodes)
    if (o.nodeType !== Node.COMMENT_NODE) return o;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function GE(_ = "bits") {
  return globalThis.bitsIdCounter.current++, `${_}-${globalThis.bitsIdCounter.current}`
}

function $E(_, o) {
  let f = _.nextElementSibling;
  for (; f;) {
    if (f.matches(o)) return f;
    f = f.nextElementSibling
  }
}

function HE(_, o) {
  let f = _.previousElementSibling;
  for (; f;) {
    if (f.matches(o)) return f;
    f = f.previousElementSibling
  }
}

function uy(_) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(_);
  const o = _.length;
  let f = -1,
    x, A = "";
  const L = _.charCodeAt(0);
  if (o === 1 && L === 45) return "\\" + _;
  for (; ++f < o;) {
    if (x = _.charCodeAt(f), x === 0) {
      A += "ÔøΩ";
      continue
    }
    if (x >= 1 && x <= 31 || x === 127 || f === 0 && x >= 48 && x <= 57 || f === 1 && x >= 48 && x <= 57 && L === 45) {
      A += "\\" + x.toString(16) + " ";
      continue
    }
    if (x >= 128 || x === 45 || x === 95 || x >= 48 && x <= 57 || x >= 65 && x <= 90 || x >= 97 && x <= 122) {
      A += _.charAt(f);
      continue
    }
    A += "\\" + _.charAt(f)
  }
  return A
}
const ml = "data-value",
  ba = cy({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  Tc = ba.selector("group"),
  hm = ba.selector("group-items"),
  Hv = ba.selector("group-heading"),
  hy = ba.selector("item"),
  dm = `${ba.selector("item")}:not([aria-disabled="true"])`,
  wl = new I_("Command.Root"),
  WE = new I_("Command.List"),
  ih = new I_("Command.Group"),
  Wv = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var Lc, Dc, _h, gh, vh, yh, xh, bh, xr, dy, Pp, Bm, Ip, Mp, Ap, Es, py, fy, Om, Xu, Nm, jm, my, Yu, Vm, qm, _y, Ku, Ju, wh;
const R_ = class R_ {
  constructor(o) {
    Pr(this, xr);
    Cr(this, "opts");
    Cr(this, "attachment");
    Pr(this, Lc, !1);
    Pr(this, Dc, !0);
    Cr(this, "sortAfterTick", !1);
    Cr(this, "sortAndFilterAfterTick", !1);
    Cr(this, "allItems", new Set);
    Cr(this, "allGroups", new Map);
    Cr(this, "allIds", new Map);
    Pr(this, _h, Qe(0));
    Pr(this, gh, Qe(null));
    Pr(this, vh, Qe(null));
    Pr(this, yh, Qe(null));
    Pr(this, xh, Qe(Wv));
    Pr(this, bh, Qe(Si(Wv)));
    Pr(this, wh, ct(() => ({
      id: this.opts.id.current,
      role: "application",
      [ba.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = o, this.attachment = Xa(this.opts.ref);
    const f = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = f, this.commandState = f, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(o) {
    return wl.set(new R_(o))
  }
  get key() {
    return y(Xe(this, _h))
  }
  set key(o) {
    te(Xe(this, _h), o, !0)
  }
  get viewportNode() {
    return y(Xe(this, gh))
  }
  set viewportNode(o) {
    te(Xe(this, gh), o, !0)
  }
  get inputNode() {
    return y(Xe(this, vh))
  }
  set inputNode(o) {
    te(Xe(this, vh), o, !0)
  }
  get labelNode() {
    return y(Xe(this, yh))
  }
  set labelNode(o) {
    te(Xe(this, yh), o, !0)
  }
  get commandState() {
    return y(Xe(this, xh))
  }
  set commandState(o) {
    te(Xe(this, xh), o)
  }
  get _commandState() {
    return y(Xe(this, bh))
  }
  set _commandState(o) {
    te(Xe(this, bh), o, !0)
  }
  setState(o, f, x) {
    Object.is(this._commandState[o], f) || (this._commandState[o] = f, o === "search" ? (Nr(this, xr, Ap).call(this), Nr(this, xr, Ip).call(this)) : o === "value" && (x || Nr(this, xr, py).call(this)), Nr(this, xr, Pp).call(this))
  }
  setValue(o, f) {
    o !== this.opts.value.current && o === "" && wc(() => {
      this.key++
    }), this.setState("value", o, f), this.opts.value.current = o
  }
  getValidItems() {
    const o = this.opts.ref.current;
    return o ? Array.from(o.querySelectorAll(dm)).filter(x => !!x) : []
  }
  getVisibleItems() {
    const o = this.opts.ref.current;
    return o ? Array.from(o.querySelectorAll(hy)).filter(x => !!x) : []
  }
  get itemsGrid() {
    var s, B, j, K;
    if (!this.isGrid) return [];
    const o = this.opts.columns.current ?? 1,
      f = this.getVisibleItems(),
      x = [
        []
      ];
    let A = (s = f[0]) == null ? void 0 : s.getAttribute("data-group"),
      L = 0,
      w = 0;
    for (let ee = 0; ee < f.length; ee++) {
      const re = f[ee],
        de = re == null ? void 0 : re.getAttribute("data-group");
      A !== de ? (A = de, L = 1, w++, x.push([{
        index: ee,
        firstRowOfGroup: !0,
        ref: re
      }])) : (L++, L > o && (w++, L = 1, x.push([])), (K = x[w]) == null || K.push({
        index: ee,
        firstRowOfGroup: ((j = (B = x[w]) == null ? void 0 : B[0]) == null ? void 0 : j.firstRowOfGroup) ?? ee === 0,
        ref: re
      }))
    }
    return x
  }
  updateSelectedToIndex(o) {
    const f = this.getValidItems()[o];
    f && this.setValue(f.getAttribute(ml) ?? "")
  }
  updateSelectedByItem(o) {
    const f = Nr(this, xr, Es).call(this),
      x = this.getValidItems(),
      A = x.findIndex(w => w === f);
    let L = x[A + o];
    this.opts.loop.current && (L = A + o < 0 ? x[x.length - 1] : A + o === x.length ? x[0] : x[A + o]), L && this.setValue(L.getAttribute(ml) ?? "")
  }
  updateSelectedByGroup(o) {
    const f = Nr(this, xr, Es).call(this);
    let x = f == null ? void 0 : f.closest(Tc),
      A;
    for (; x && !A;) x = o > 0 ? $E(x, Tc) : HE(x, Tc), A = x == null ? void 0 : x.querySelector(dm);
    A ? this.setValue(A.getAttribute(ml) ?? "") : this.updateSelectedByItem(o)
  }
  registerValue(o, f) {
    var x;
    return o && o === ((x = this.allIds.get(o)) == null ? void 0 : x.value) || this.allIds.set(o, {
      value: o,
      keywords: f
    }), this._commandState.filtered.items.set(o, Nr(this, xr, Bm).call(this, o, f)), this.sortAfterTick || (this.sortAfterTick = !0, wc(() => {
      Nr(this, xr, Ip).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(o)
    }
  }
  registerItem(o, f) {
    return this.allItems.add(o), f && (this.allGroups.has(f) ? this.allGroups.get(f).add(o) : this.allGroups.set(f, new Set([o]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, wc(() => {
      Nr(this, xr, Ap).call(this), Nr(this, xr, Ip).call(this), this.sortAndFilterAfterTick = !1
    })), Nr(this, xr, Pp).call(this), () => {
      const x = Nr(this, xr, Es).call(this);
      this.allItems.delete(o), this.commandState.filtered.items.delete(o), Nr(this, xr, Ap).call(this), (x == null ? void 0 : x.getAttribute("id")) === o && Nr(this, xr, Mp).call(this), Nr(this, xr, Pp).call(this)
    }
  }
  registerGroup(o) {
    return this.allGroups.has(o) || this.allGroups.set(o, new Set), () => {
      this.allIds.delete(o), this.allGroups.delete(o)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(o) {
    const f = this.opts.vimBindings.current && o.ctrlKey;
    switch (o.key) {
      case NE:
      case jE: {
        f && (this.isGrid ? Nr(this, xr, Nm).call(this, o) : Nr(this, xr, Xu).call(this, o));
        break
      }
      case UE: {
        f && this.isGrid && Nr(this, xr, Xu).call(this, o);
        break
      }
      case EE:
        this.isGrid ? Nr(this, xr, Nm).call(this, o) : Nr(this, xr, Xu).call(this, o);
        break;
      case LE:
        if (!this.isGrid) break;
        Nr(this, xr, Xu).call(this, o);
        break;
      case OE:
      case VE: {
        f && (this.isGrid ? Nr(this, xr, qm).call(this, o) : Nr(this, xr, Ju).call(this, o));
        break
      }
      case qE: {
        f && this.isGrid && Nr(this, xr, Ju).call(this, o);
        break
      }
      case DE:
        this.isGrid ? Nr(this, xr, qm).call(this, o) : Nr(this, xr, Ju).call(this, o);
        break;
      case zE:
        if (!this.isGrid) break;
        Nr(this, xr, Ju).call(this, o);
        break;
      case BE:
        o.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case RE:
        o.preventDefault(), Nr(this, xr, Om).call(this);
        break;
      case FE:
        if (!o.isComposing && o.keyCode !== 229) {
          o.preventDefault();
          const x = Nr(this, xr, Es).call(this);
          x && (x == null || x.click())
        }
    }
  }
  get props() {
    return y(Xe(this, wh))
  }
  set props(o) {
    te(Xe(this, wh), o)
  }
};
Lc = new WeakMap, Dc = new WeakMap, _h = new WeakMap, gh = new WeakMap, vh = new WeakMap, yh = new WeakMap, xh = new WeakMap, bh = new WeakMap, xr = new WeakSet, dy = function() {
  return Wb(this._commandState)
}, Pp = function() {
  Xe(this, Lc) || (Hi(this, Lc, !0), wc(() => {
    var x, A;
    Hi(this, Lc, !1);
    const o = Nr(this, xr, dy).call(this);
    !Object.is(this.commandState, o) && (this.commandState = o, (A = (x = this.opts.onStateChange) == null ? void 0 : x.current) == null || A.call(x, o))
  }))
}, Bm = function(o, f) {
  const x = this.opts.filter.current ?? yy;
  return o ? x(o, this._commandState.search, f) : 0
}, Ip = function() {
  var w;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    (!this._commandState.value || !Xe(this, Dc)) && Nr(this, xr, Mp).call(this);
    return
  }
  const o = this._commandState.filtered.items,
    f = [];
  for (const s of this._commandState.filtered.groups) {
    const B = this.allGroups.get(s);
    let j = 0;
    if (!B) {
      f.push([s, j]);
      continue
    }
    for (const K of B) {
      const ee = o.get(K);
      j = Math.max(ee ?? 0, j)
    }
    f.push([s, j])
  }
  const x = this.viewportNode,
    A = this.getValidItems().sort((s, B) => {
      const j = s.getAttribute("data-value"),
        K = B.getAttribute("data-value"),
        ee = o.get(j) ?? 0;
      return (o.get(K) ?? 0) - ee
    });
  for (const s of A) {
    const B = s.closest(hm);
    if (B) {
      const j = s.parentElement === B ? s : s.closest(`${hm} > *`);
      j && B.appendChild(j)
    } else {
      const j = s.parentElement === x ? s : s.closest(`${hm} > *`);
      j && (x == null || x.appendChild(j))
    }
  }
  const L = f.sort((s, B) => B[1] - s[1]);
  for (const s of L) {
    const B = x == null ? void 0 : x.querySelector(`${Tc}[${ml}="${uy(s[0])}"]`);
    (w = B == null ? void 0 : B.parentElement) == null || w.appendChild(B)
  }
  Nr(this, xr, Mp).call(this)
}, Mp = function() {
  wc(() => {
    const o = this.getValidItems().find(A => A.getAttribute("aria-disabled") !== "true"),
      f = o == null ? void 0 : o.getAttribute(ml),
      x = Xe(this, Dc) && this.opts.disableInitialScroll.current;
    this.setValue(f ?? "", x), Hi(this, Dc, !1)
  })
}, Ap = function() {
  var f, x;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let o = 0;
  for (const A of this.allItems) {
    const L = ((f = this.allIds.get(A)) == null ? void 0 : f.value) ?? "",
      w = ((x = this.allIds.get(A)) == null ? void 0 : x.keywords) ?? [],
      s = Nr(this, xr, Bm).call(this, L, w);
    this._commandState.filtered.items.set(A, s), s > 0 && o++
  }
  for (const [A, L] of this.allGroups)
    for (const w of L) {
      const s = this._commandState.filtered.items.get(w);
      if (s && s > 0) {
        this._commandState.filtered.groups.add(A);
        break
      }
    }
  this._commandState.filtered.count = o
}, Es = function() {
  const o = this.opts.ref.current;
  if (!o) return;
  const f = o.querySelector(`${dm}[data-selected]`);
  if (f) return f
}, py = function() {
  wc(() => {
    var x, A, L, w, s;
    const o = Nr(this, xr, Es).call(this);
    if (!o) return;
    const f = (x = o.parentElement) == null ? void 0 : x.parentElement;
    if (f) {
      if (this.isGrid) {
        const B = Nr(this, xr, fy).call(this, o);
        if (o.scrollIntoView({
            block: "nearest"
          }), B) {
          const j = (A = o == null ? void 0 : o.closest(Tc)) == null ? void 0 : A.querySelector(Hv);
          j == null || j.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const B = ZE(f);
        if (B && ((L = B.dataset) == null ? void 0 : L.value) === ((w = o.dataset) == null ? void 0 : w.value)) {
          const j = (s = o == null ? void 0 : o.closest(Tc)) == null ? void 0 : s.querySelector(Hv);
          j == null || j.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      o.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, fy = function(o) {
  const f = this.itemsGrid;
  if (f.length === 0) return !1;
  for (let x = 0; x < f.length; x++) {
    const A = f[x];
    if (A !== void 0)
      for (let L = 0; L < A.length; L++) {
        const w = A[L];
        if (!(w === void 0 || w.ref !== o)) return w.firstRowOfGroup
      }
  }
  return !1
}, Om = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Xu = function(o) {
  o.preventDefault(), o.metaKey ? Nr(this, xr, Om).call(this) : o.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, Nm = function(o) {
  this.opts.columns.current !== null && (o.preventDefault(), o.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(Nr(this, xr, my).call(this, o)))
}, jm = function(o, f) {
  if (f.length === 0) return null;
  for (let x = 0; x < f.length; x++) {
    const A = f[x];
    if (A !== void 0)
      for (let L = 0; L < A.length; L++) {
        const w = A[L];
        if (!(w === void 0 || w.ref !== o)) return {
          columnIndex: L,
          rowIndex: x
        }
      }
  }
  return null
}, my = function(o) {
  const f = this.itemsGrid,
    x = Nr(this, xr, Es).call(this);
  if (!x) return 0;
  const A = Nr(this, xr, jm).call(this, x, f);
  if (!A) return 0;
  let L = null;
  const w = o.altKey ? 1 : 0;
  if (o.altKey && A.rowIndex === f.length - 2 && !this.opts.loop.current) L = Nr(this, xr, Yu).call(this, {
    start: f.length - 1,
    end: f.length,
    expectedColumnIndex: A.columnIndex,
    grid: f
  });
  else if (A.rowIndex === f.length - 1) {
    if (!this.opts.loop.current) return 0;
    L = Nr(this, xr, Yu).call(this, {
      start: 0 + w,
      end: A.rowIndex,
      expectedColumnIndex: A.columnIndex,
      grid: f
    })
  } else L = Nr(this, xr, Yu).call(this, {
    start: A.rowIndex + 1 + w,
    end: f.length,
    expectedColumnIndex: A.columnIndex,
    grid: f
  }), L === null && this.opts.loop.current && (L = Nr(this, xr, Yu).call(this, {
    start: 0,
    end: A.rowIndex,
    expectedColumnIndex: A.columnIndex,
    grid: f
  }));
  return Nr(this, xr, Vm).call(this, x, L)
}, Yu = function({
  start: o,
  end: f,
  grid: x,
  expectedColumnIndex: A
}) {
  var w;
  let L = null;
  for (let s = o; s < f; s++) {
    const B = x[s];
    if (L = ((w = B[A]) == null ? void 0 : w.ref) ?? null, L !== null && vp(L)) {
      L = null;
      continue
    }
    if (L === null)
      for (let j = B.length - 1; j >= 0; j--) {
        const K = B[B.length - 1];
        if (!(K === void 0 || vp(K.ref))) {
          L = K.ref;
          break
        }
      }
    break
  }
  return L
}, Vm = function(o, f) {
  if (f === null) return 0;
  const x = this.getValidItems(),
    A = x.findIndex(w => w === o);
  return x.findIndex(w => w === f) - A
}, qm = function(o) {
  this.opts.columns.current !== null && (o.preventDefault(), o.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(Nr(this, xr, _y).call(this, o)))
}, _y = function(o) {
  const f = this.itemsGrid,
    x = Nr(this, xr, Es).call(this);
  if (x === void 0) return 0;
  const A = Nr(this, xr, jm).call(this, x, f);
  if (A === null) return 0;
  let L = null;
  const w = o.altKey ? 1 : 0;
  if (o.altKey && A.rowIndex === 1 && this.opts.loop.current === !1) L = Nr(this, xr, Ku).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: A.columnIndex,
    grid: f
  });
  else if (A.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    L = Nr(this, xr, Ku).call(this, {
      start: f.length - 1 - w,
      end: A.rowIndex + 1,
      expectedColumnIndex: A.columnIndex,
      grid: f
    })
  } else L = Nr(this, xr, Ku).call(this, {
    start: A.rowIndex - 1 - w,
    end: 0,
    expectedColumnIndex: A.columnIndex,
    grid: f
  }), L === null && this.opts.loop.current && (L = Nr(this, xr, Ku).call(this, {
    start: f.length - 1,
    end: A.rowIndex + 1,
    expectedColumnIndex: A.columnIndex,
    grid: f
  }));
  return Nr(this, xr, Vm).call(this, x, L)
}, Ku = function({
  start: o,
  end: f,
  grid: x,
  expectedColumnIndex: A
}) {
  var w;
  let L = null;
  for (let s = o; s >= f; s--) {
    const B = x[s];
    if (B !== void 0) {
      if (L = ((w = B[A]) == null ? void 0 : w.ref) ?? null, L !== null && vp(L)) {
        L = null;
        continue
      }
      if (L === null)
        for (let j = B.length - 1; j >= 0; j--) {
          const K = B[B.length - 1];
          if (!(K === void 0 || vp(K.ref))) {
            L = K.ref;
            break
          }
        }
      break
    }
  }
  return L
}, Ju = function(o) {
  o.preventDefault(), o.metaKey ? this.updateSelectedToIndex(0) : o.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, wh = new WeakMap;
let Fm = R_;

function vp(_) {
  return _.getAttribute("aria-disabled") === "true"
}
var Th, Sh, Ch;
const F_ = class F_ {
  constructor(o, f) {
    Cr(this, "opts");
    Cr(this, "root");
    Cr(this, "attachment");
    Pr(this, Th, ct(() => this.root._commandState.filtered.count === 0 && Xe(this, Sh) === !1 || this.opts.forceMount.current));
    Pr(this, Sh, !0);
    Pr(this, Ch, ct(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [ba.empty]: "",
      ...this.attachment
    })));
    this.opts = o, this.root = f, this.attachment = Xa(this.opts.ref), s_(() => {
      Hi(this, Sh, !1)
    })
  }
  static create(o) {
    return new F_(o, wl.get())
  }
  get shouldRender() {
    return y(Xe(this, Th))
  }
  set shouldRender(o) {
    te(Xe(this, Th), o)
  }
  get props() {
    return y(Xe(this, Ch))
  }
  set props(o) {
    te(Xe(this, Ch), o)
  }
};
Th = new WeakMap, Sh = new WeakMap, Ch = new WeakMap;
let Um = F_;
var Ph, Ih, Mh, Ah;
const B_ = class B_ {
  constructor(o, f) {
    Cr(this, "opts");
    Cr(this, "root");
    Cr(this, "attachment");
    Pr(this, Ph, ct(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    Pr(this, Ih, Qe(null));
    Pr(this, Mh, Qe(""));
    Pr(this, Ah, ct(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [ba.group]: "",
      ...this.attachment
    })));
    this.opts = o, this.root = f, this.attachment = Xa(this.opts.ref), this.trueValue = o.value.current ?? o.id.current, xl(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Zr(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(o) {
    return ih.set(new B_(o, wl.get()))
  }
  get shouldRender() {
    return y(Xe(this, Ph))
  }
  set shouldRender(o) {
    te(Xe(this, Ph), o)
  }
  get headingNode() {
    return y(Xe(this, Ih))
  }
  set headingNode(o) {
    te(Xe(this, Ih), o, !0)
  }
  get trueValue() {
    return y(Xe(this, Mh))
  }
  set trueValue(o) {
    te(Xe(this, Mh), o, !0)
  }
  get props() {
    return y(Xe(this, Ah))
  }
  set props(o) {
    te(Xe(this, Ah), o)
  }
};
Ph = new WeakMap, Ih = new WeakMap, Mh = new WeakMap, Ah = new WeakMap;
let Zm = B_;
var kh;
const O_ = class O_ {
  constructor(o, f) {
    Cr(this, "opts");
    Cr(this, "group");
    Cr(this, "attachment");
    Pr(this, kh, ct(() => ({
      id: this.opts.id.current,
      [ba["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = o, this.group = f, this.attachment = Xa(this.opts.ref, x => this.group.headingNode = x)
  }
  static create(o) {
    return new O_(o, ih.get())
  }
  get props() {
    return y(Xe(this, kh))
  }
  set props(o) {
    te(Xe(this, kh), o)
  }
};
kh = new WeakMap;
let Gm = O_;
var Eh;
const N_ = class N_ {
  constructor(o, f) {
    Cr(this, "opts");
    Cr(this, "group");
    Cr(this, "attachment");
    Pr(this, Eh, ct(() => {
      var o;
      return {
        id: this.opts.id.current,
        role: "group",
        [ba["group-items"]]: "",
        "aria-labelledby": ((o = this.group.headingNode) == null ? void 0 : o.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = o, this.group = f, this.attachment = Xa(this.opts.ref)
  }
  static create(o) {
    return new N_(o, ih.get())
  }
  get props() {
    return y(Xe(this, Eh))
  }
  set props(o) {
    te(Xe(this, Eh), o)
  }
};
Eh = new WeakMap;
let $m = N_;
var Np, zh;
const j_ = class j_ {
  constructor(o, f) {
    Cr(this, "opts");
    Cr(this, "root");
    Cr(this, "attachment");
    Pr(this, Np, ct(() => {
      var f;
      const o = (f = this.root.viewportNode) == null ? void 0 : f.querySelector(`${hy}[${ml}="${uy(this.root.opts.value.current)}"]`);
      if (o != null) return o.getAttribute("id") ?? void 0
    }));
    Pr(this, zh, ct(() => {
      var o, f;
      return {
        id: this.opts.id.current,
        type: "text",
        [ba.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": Rm(!0),
        "aria-controls": ((o = this.root.viewportNode) == null ? void 0 : o.id) ?? void 0,
        "aria-labelledby": ((f = this.root.labelNode) == null ? void 0 : f.id) ?? void 0,
        "aria-activedescendant": y(Xe(this, Np)),
        ...this.attachment
      }
    }));
    this.opts = o, this.root = f, this.attachment = Xa(this.opts.ref, x => this.root.inputNode = x), xl(() => this.opts.ref.current, () => {
      const x = this.opts.ref.current;
      x && this.opts.autofocus.current && vE(10, () => x.focus())
    }), xl(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(o) {
    return new j_(o, wl.get())
  }
  get props() {
    return y(Xe(this, zh))
  }
  set props(o) {
    te(Xe(this, zh), o)
  }
};
Np = new WeakMap, zh = new WeakMap;
let Hm = j_;
var Ls, jp, Lh, Dh, Rh, bl, gy, Xm, Fh;
const V_ = class V_ {
  constructor(o, f) {
    Pr(this, bl);
    Cr(this, "opts");
    Cr(this, "root");
    Cr(this, "attachment");
    Pr(this, Ls, null);
    Pr(this, jp, ct(() => {
      var o;
      return this.opts.forceMount.current || ((o = Xe(this, Ls)) == null ? void 0 : o.opts.forceMount.current) === !0
    }));
    Pr(this, Lh, ct(() => {
      if (this.opts.ref.current, y(Xe(this, jp)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const o = this.root.commandState.filtered.items.get(this.trueValue);
      return o === void 0 ? !1 : o > 0
    }));
    Pr(this, Dh, ct(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    Pr(this, Rh, Qe(""));
    Pr(this, Fh, ct(() => {
      var o;
      return {
        id: this.opts.id.current,
        "aria-disabled": Rm(this.opts.disabled.current),
        "aria-selected": Rm(this.isSelected),
        "data-disabled": $v(this.opts.disabled.current),
        "data-selected": $v(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (o = Xe(this, Ls)) == null ? void 0 : o.trueValue,
        [ba.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = o, this.root = f, Hi(this, Ls, ih.getOr(null)), this.trueValue = o.value.current, this.attachment = Xa(this.opts.ref), xl([() => this.trueValue, () => {
      var x;
      return (x = Xe(this, Ls)) == null ? void 0 : x.trueValue
    }, () => this.opts.forceMount.current], () => {
      var x;
      if (!(this.opts.forceMount.current || !this.trueValue)) return this.root.registerItem(this.trueValue, (x = Xe(this, Ls)) == null ? void 0 : x.trueValue)
    }), xl([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var x, A;
      this.opts.value.current ? this.trueValue = this.opts.value.current : (x = this.opts.ref.current) != null && x.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, o.keywords.current.map(L => L.trim())), (A = this.opts.ref.current) == null || A.setAttribute(ml, this.trueValue))
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(o) {
    const f = ih.getOr(null);
    return new V_({
      ...o,
      group: f
    }, wl.get())
  }
  get shouldRender() {
    return y(Xe(this, Lh))
  }
  set shouldRender(o) {
    te(Xe(this, Lh), o)
  }
  get isSelected() {
    return y(Xe(this, Dh))
  }
  set isSelected(o) {
    te(Xe(this, Dh), o)
  }
  get trueValue() {
    return y(Xe(this, Rh))
  }
  set trueValue(o) {
    te(Xe(this, Rh), o, !0)
  }
  onpointermove(o) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || Nr(this, bl, Xm).call(this)
  }
  onclick(o) {
    this.opts.disabled.current || Nr(this, bl, gy).call(this)
  }
  get props() {
    return y(Xe(this, Fh))
  }
  set props(o) {
    te(Xe(this, Fh), o)
  }
};
Ls = new WeakMap, jp = new WeakMap, Lh = new WeakMap, Dh = new WeakMap, Rh = new WeakMap, bl = new WeakSet, gy = function() {
  var o;
  this.opts.disabled.current || (Nr(this, bl, Xm).call(this), (o = this.opts.onSelect) == null || o.current())
}, Xm = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, Fh = new WeakMap;
let Wm = V_;
var Bh;
const q_ = class q_ {
  constructor(o, f) {
    Cr(this, "opts");
    Cr(this, "root");
    Cr(this, "attachment");
    Pr(this, Bh, ct(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [ba.list]: "",
      ...this.attachment
    })));
    this.opts = o, this.root = f, this.attachment = Xa(this.opts.ref)
  }
  static create(o) {
    return WE.set(new q_(o, wl.get()))
  }
  get props() {
    return y(Xe(this, Bh))
  }
  set props(o) {
    te(Xe(this, Bh), o)
  }
};
Bh = new WeakMap;
let Ym = q_;
var Oh;
const U_ = class U_ {
  constructor(o, f) {
    Cr(this, "opts");
    Cr(this, "root");
    Cr(this, "attachment");
    Pr(this, Oh, ct(() => {
      var o;
      return {
        id: this.opts.id.current,
        [ba["input-label"]]: "",
        for: (o = this.opts.for) == null ? void 0 : o.current,
        style: ay,
        ...this.attachment
      }
    }));
    this.opts = o, this.root = f, this.attachment = Xa(this.opts.ref, x => this.root.labelNode = x)
  }
  static create(o) {
    return new U_(o, wl.get())
  }
  get props() {
    return y(Xe(this, Oh))
  }
  set props(o) {
    te(Xe(this, Oh), o)
  }
};
Oh = new WeakMap;
let Km = U_;
var XE = me("<label><!></label>");

function YE(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const w = Km.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), K => A(K))
    }),
    s = ct(() => Fa(L, w.props));
  var B = XE();
  cr(B, () => ({
    ...y(s)
  }));
  var j = M(B);
  ai(j, () => o.children ?? oa), P(B), G(_, B), Lr()
}
var KE = me("<!> <!>", 1),
  JE = me("<div><!> <!></div>");

function QE(_, o) {
  const f = _o();
  zr(o, !0);
  const x = Oe => {
    YE(Oe, {
      children: (Je, bt) => {
        bn();
        var We = ji();
        je(() => le(We, re())), G(Je, We)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let A = At(o, "id", 19, () => Ya(f)),
    L = At(o, "ref", 15, null),
    w = At(o, "value", 15, ""),
    s = At(o, "onValueChange", 3, nh),
    B = At(o, "onStateChange", 3, nh),
    j = At(o, "loop", 3, !1),
    K = At(o, "shouldFilter", 3, !0),
    ee = At(o, "filter", 3, yy),
    re = At(o, "label", 3, ""),
    de = At(o, "vimBindings", 3, !0),
    ne = At(o, "disablePointerSelection", 3, !1),
    Y = At(o, "disableInitialScroll", 3, !1),
    we = At(o, "columns", 3, null),
    Ie = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const ze = Fm.create({
      id: Hr(() => A()),
      ref: Hr(() => L(), Oe => L(Oe)),
      filter: Hr(() => ee()),
      shouldFilter: Hr(() => K()),
      loop: Hr(() => j()),
      value: Hr(() => w(), Oe => {
        w() !== Oe && (w(Oe), s()(Oe))
      }),
      vimBindings: Hr(() => de()),
      disablePointerSelection: Hr(() => ne()),
      disableInitialScroll: Hr(() => Y()),
      onStateChange: Hr(() => B()),
      columns: Hr(() => we())
    }),
    Re = Oe => ze.updateSelectedToIndex(Oe),
    ke = Oe => ze.updateSelectedByGroup(Oe),
    qe = Oe => ze.updateSelectedByItem(Oe),
    $e = () => ze.getValidItems(),
    Be = ct(() => Fa(Ie, ze.props));
  var Ee = {
      updateSelectedToIndex: Re,
      updateSelectedByGroup: ke,
      updateSelectedByItem: qe,
      getValidItems: $e
    },
    He = Jt(),
    Le = gt(He);
  {
    var it = Oe => {
        var Je = KE(),
          bt = gt(Je);
        x(bt);
        var We = q(bt, 2);
        ai(We, () => o.child, () => ({
          props: y(Be)
        })), G(Oe, Je)
      },
      pt = Oe => {
        var Je = JE();
        cr(Je, () => ({
          ...y(Be)
        }));
        var bt = M(Je);
        x(bt);
        var We = q(bt, 2);
        ai(We, () => o.children ?? oa), P(Je), G(Oe, Je)
      };
    Ae(Le, Oe => {
      o.child ? Oe(it) : Oe(pt, !1)
    })
  }
  return G(_, He), Lr(Ee)
}
var e8 = me("<div><!></div>");

function t8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = At(o, "forceMount", 3, !1),
    w = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const s = Um.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), re => A(re)),
      forceMount: Hr(() => L())
    }),
    B = ct(() => Fa(s.props, w));
  var j = Jt(),
    K = gt(j);
  {
    var ee = re => {
      var de = Jt(),
        ne = gt(de);
      {
        var Y = Ie => {
            var ze = Jt(),
              Re = gt(ze);
            ai(Re, () => o.child, () => ({
              props: y(B)
            })), G(Ie, ze)
          },
          we = Ie => {
            var ze = e8();
            cr(ze, () => ({
              ...y(B)
            }));
            var Re = M(ze);
            ai(Re, () => o.children ?? oa), P(ze), G(Ie, ze)
          };
        Ae(ne, Ie => {
          o.child ? Ie(Y) : Ie(we, !1)
        })
      }
      G(re, de)
    };
    Ae(K, re => {
      s.shouldRender && re(ee)
    })
  }
  G(_, j), Lr()
}
var r8 = me("<div><!></div>");

function n8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = At(o, "value", 3, ""),
    w = At(o, "forceMount", 3, !1),
    s = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const B = Zm.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), ne => A(ne)),
      forceMount: Hr(() => w()),
      value: Hr(() => L())
    }),
    j = ct(() => Fa(s, B.props));
  var K = Jt(),
    ee = gt(K);
  {
    var re = ne => {
        var Y = Jt(),
          we = gt(Y);
        ai(we, () => o.child, () => ({
          props: y(j)
        })), G(ne, Y)
      },
      de = ne => {
        var Y = r8();
        cr(Y, () => ({
          ...y(j)
        }));
        var we = M(Y);
        ai(we, () => o.children ?? oa), P(Y), G(ne, Y)
      };
    Ae(ee, ne => {
      o.child ? ne(re) : ne(de, !1)
    })
  }
  G(_, K), Lr()
}
var i8 = me("<div><!></div>");

function a8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const w = Gm.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), re => A(re))
    }),
    s = ct(() => Fa(L, w.props));
  var B = Jt(),
    j = gt(B);
  {
    var K = re => {
        var de = Jt(),
          ne = gt(de);
        ai(ne, () => o.child, () => ({
          props: y(s)
        })), G(re, de)
      },
      ee = re => {
        var de = i8();
        cr(de, () => ({
          ...y(s)
        }));
        var ne = M(de);
        ai(ne, () => o.children ?? oa), P(de), G(re, de)
      };
    Ae(j, re => {
      o.child ? re(K) : re(ee, !1)
    })
  }
  G(_, B), Lr()
}
var o8 = me("<div><!></div>"),
  s8 = me('<div style="display: contents;"><!></div>');

function l8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const w = $m.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), re => A(re))
    }),
    s = ct(() => Fa(L, w.props));
  var B = s8(),
    j = M(B);
  {
    var K = re => {
        var de = Jt(),
          ne = gt(de);
        ai(ne, () => o.child, () => ({
          props: y(s)
        })), G(re, de)
      },
      ee = re => {
        var de = o8();
        cr(de, () => ({
          ...y(s)
        }));
        var ne = M(de);
        ai(ne, () => o.children ?? oa), P(de), G(re, de)
      };
    Ae(j, re => {
      o.child ? re(K) : re(ee, !1)
    })
  }
  P(B), G(_, B), Lr()
}
var c8 = me("<input/>");

function u8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "value", 15, ""),
    A = At(o, "autofocus", 3, !1),
    L = At(o, "id", 19, () => Ya(f)),
    w = At(o, "ref", 15, null),
    s = lr(o, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const B = Hm.create({
      id: Hr(() => L()),
      ref: Hr(() => w(), ne => w(ne)),
      value: Hr(() => x(), ne => {
        x(ne)
      }),
      autofocus: Hr(() => A() ?? !1)
    }),
    j = ct(() => Fa(s, B.props));
  var K = Jt(),
    ee = gt(K);
  {
    var re = ne => {
        var Y = Jt(),
          we = gt(Y);
        ai(we, () => o.child, () => ({
          props: y(j)
        })), G(ne, Y)
      },
      de = ne => {
        var Y = c8();
        cr(Y, () => ({
          ...y(j)
        }), void 0, void 0, void 0, void 0, !0), $h(Y, x), G(ne, Y)
      };
    Ae(ee, ne => {
      o.child ? ne(re) : ne(de, !1)
    })
  }
  G(_, K), Lr()
}
var h8 = me("<div><!></div>"),
  d8 = me('<div style="display: contents;" data-item-wrapper=""><!></div>');

function p8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = At(o, "value", 3, ""),
    w = At(o, "disabled", 3, !1),
    s = At(o, "onSelect", 3, nh),
    B = At(o, "forceMount", 3, !1),
    j = At(o, "keywords", 19, () => []),
    K = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const ee = Wm.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), Y => A(Y)),
      value: Hr(() => L()),
      disabled: Hr(() => w()),
      onSelect: Hr(() => s()),
      forceMount: Hr(() => B()),
      keywords: Hr(() => j())
    }),
    re = ct(() => Fa(K, ee.props));
  var de = Jt(),
    ne = gt(de);
  th(ne, () => ee.root.key, Y => {
    var we = d8(),
      Ie = M(we);
    {
      var ze = Re => {
        var ke = Jt(),
          qe = gt(ke);
        {
          var $e = Ee => {
              var He = Jt(),
                Le = gt(He);
              ai(Le, () => o.child, () => ({
                props: y(re)
              })), G(Ee, He)
            },
            Be = Ee => {
              var He = h8();
              cr(He, () => ({
                ...y(re)
              }));
              var Le = M(He);
              ai(Le, () => o.children ?? oa), P(He), G(Ee, He)
            };
          Ae(qe, Ee => {
            o.child ? Ee($e) : Ee(Be, !1)
          })
        }
        G(Re, ke)
      };
      Ae(Ie, Re => {
        ee.shouldRender && Re(ze)
      })
    }
    P(we), je(() => mr(we, "data-value", ee.trueValue)), G(Y, we)
  }), G(_, de), Lr()
}
var f8 = me("<div><!></div>");

function m8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const w = Ym.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), K => A(K)),
      ariaLabel: Hr(() => o["aria-label"] ?? "Suggestions...")
    }),
    s = ct(() => Fa(L, w.props));
  var B = Jt(),
    j = gt(B);
  th(j, () => w.root._commandState.search === "", K => {
    var ee = Jt(),
      re = gt(ee);
    {
      var de = Y => {
          var we = Jt(),
            Ie = gt(we);
          ai(Ie, () => o.child, () => ({
            props: y(s)
          })), G(Y, we)
        },
        ne = Y => {
          var we = f8();
          cr(we, () => ({
            ...y(s)
          }));
          var Ie = M(we);
          ai(Ie, () => o.children ?? oa), P(we), G(Y, we)
        };
      Ae(re, Y => {
        o.child ? Y(de) : Y(ne, !1)
      })
    }
    G(K, ee)
  }), G(_, B), Lr()
}
const Xv = 1,
  _8 = .9,
  g8 = .8,
  v8 = .17,
  pm = .1,
  fm = .999,
  y8 = .9999,
  x8 = .99,
  b8 = /[\\/_+.#"@[({&]/,
  w8 = /[\\/_+.#"@[({&]/g,
  T8 = /[\s-]/,
  vy = /[\s-]/g;

function Jm(_, o, f, x, A, L, w) {
  if (L === o.length) return A === _.length ? Xv : x8;
  const s = `${A},${L}`;
  if (w[s] !== void 0) return w[s];
  const B = x.charAt(L);
  let j = f.indexOf(B, A),
    K = 0,
    ee, re, de, ne;
  for (; j >= 0;) ee = Jm(_, o, f, x, j + 1, L + 1, w), ee > K && (j === A ? ee *= Xv : b8.test(_.charAt(j - 1)) ? (ee *= g8, de = _.slice(A, j - 1).match(w8), de && A > 0 && (ee *= fm ** de.length)) : T8.test(_.charAt(j - 1)) ? (ee *= _8, ne = _.slice(A, j - 1).match(vy), ne && A > 0 && (ee *= fm ** ne.length)) : (ee *= v8, A > 0 && (ee *= fm ** (j - A))), _.charAt(j) !== o.charAt(L) && (ee *= y8)), (ee < pm && f.charAt(j - 1) === x.charAt(L + 1) || x.charAt(L + 1) === x.charAt(L) && f.charAt(j - 1) !== x.charAt(L)) && (re = Jm(_, o, f, x, j + 1, L + 2, w), re * pm > ee && (ee = re * pm)), ee > K && (K = ee), j = f.indexOf(B, j + 1);
  return w[s] = K, K
}

function Yv(_) {
  return _.toLowerCase().replace(vy, " ")
}

function yy(_, o, f) {
  return _ = f && f.length > 0 ? `${`${_} ${f==null?void 0:f.join(" ")}`}` : _, Jm(_, o, Yv(_), Yv(o), 0, 0, {})
}
const S8 = 18,
  xy = 40,
  C8 = `${xy}px`,
  P8 = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");

function I8({
  containerRef: _,
  inputRef: o,
  pushPasswordManagerStrategy: f,
  isFocused: x,
  domContext: A
}) {
  let L = Qe(!1),
    w = Qe(!1),
    s = Qe(!1);

  function B() {
    const K = f.current;
    return K === "none" ? !1 : K === "increase-width" && y(L) && y(w)
  }

  function j() {
    const K = _.current,
      ee = o.current;
    if (!K || !ee || y(s) || f.current === "none") return;
    const re = K,
      de = re.getBoundingClientRect().left + re.offsetWidth,
      ne = re.getBoundingClientRect().top + re.offsetHeight / 2,
      Y = de - S8,
      we = ne;
    A.querySelectorAll(P8).length === 0 && A.getDocument().elementFromPoint(Y, we) === K || (te(L, !0), te(s, !0))
  }
  return Zr(() => {
    const K = _.current;
    if (!K || f.current === "none") return;

    function ee() {
      const ne = ly(K).innerWidth - K.getBoundingClientRect().right;
      te(w, ne >= xy)
    }
    ee();
    const re = setInterval(ee, 1e3);
    return () => {
      clearInterval(re)
    }
  }), Zr(() => {
    const K = x.current || A.getActiveElement() === o.current;
    if (f.current === "none" || !K) return;
    const ee = setTimeout(j, 0),
      re = setTimeout(j, 2e3),
      de = setTimeout(j, 5e3),
      ne = setTimeout(() => {
        te(s, !0)
      }, 6e3);
    return () => {
      clearTimeout(ee), clearTimeout(re), clearTimeout(de), clearTimeout(ne)
    }
  }), {
    get hasPwmBadge() {
      return y(L)
    },
    get willPushPwmBadge() {
      return B()
    },
    PWM_BADGE_SPACE_WIDTH: C8
  }
}
const by = cy({
    component: "pin-input",
    parts: ["root", "cell"]
  }),
  M8 = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var $a, Rc, os, Da, Ha, Fc, Mo, ss, Ds, Bc, Vp, Nh, jh, qp, Up, wy, Vh, qh, Zp, Uh;
const Z_ = class Z_ {
  constructor(o) {
    Pr(this, Up);
    Cr(this, "opts");
    Cr(this, "attachment");
    Pr(this, $a, Vv(null));
    Pr(this, Rc, Qe(!1));
    Cr(this, "inputAttachment", Xa(Xe(this, $a)));
    Pr(this, os, Vv(!1));
    Pr(this, Da, Qe(null));
    Pr(this, Ha, Qe(null));
    Pr(this, Fc, new gE(() => this.opts.value.current ?? ""));
    Pr(this, Mo, ct(() => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
    Pr(this, ss, Qe(Si({
      prev: [null, null, "none"],
      willSyntheticBlur: !1
    })));
    Pr(this, Ds);
    Pr(this, Bc);
    Cr(this, "domContext");
    Cr(this, "onkeydown", o => {
      const f = o.key;
      M8.includes(f) || o.ctrlKey || o.metaKey || f && y(Xe(this, Mo)) && !y(Xe(this, Mo)).test(f) && o.preventDefault()
    });
    Pr(this, Vp, ct(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    Pr(this, Nh, ct(() => ({
      id: this.opts.id.current,
      [by.root]: "",
      style: y(Xe(this, Vp)),
      ...this.attachment
    })));
    Pr(this, jh, ct(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    Pr(this, qp, ct(() => ({
      position: "absolute",
      inset: 0,
      width: Xe(this, Ds).willPushPwmBadge ? `calc(100% + ${Xe(this,Ds).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: Xe(this, Ds).willPushPwmBadge ? `inset(0 ${Xe(this,Ds).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    Pr(this, Vh, () => {
      var Y;
      const o = Xe(this, $a).current,
        f = this.opts.ref.current;
      if (!o || !f) return;
      if (this.domContext.getActiveElement() !== o) {
        te(Xe(this, Da), null), te(Xe(this, Ha), null);
        return
      }
      const x = o.selectionStart,
        A = o.selectionEnd,
        L = o.selectionDirection ?? "none",
        w = o.maxLength,
        s = o.value,
        B = y(Xe(this, ss)).prev;
      let j = -1,
        K = -1,
        ee;
      if (s.length !== 0 && x !== null && A !== null) {
        const we = x === A,
          Ie = x === s.length && s.length < w;
        if (we && !Ie) {
          const ze = x;
          if (ze === 0) j = 0, K = 1, ee = "forward";
          else if (ze === w) j = ze - 1, K = ze, ee = "backward";
          else if (w > 1 && s.length > 1) {
            let Re = 0;
            if (B[0] !== null && B[1] !== null) {
              ee = ze < B[0] ? "backward" : "forward";
              const ke = B[0] === B[1] && B[0] < w;
              ee === "backward" && !ke && (Re = -1)
            }
            j = Re - ze, K = Re + ze + 1
          }
        }
        j !== -1 && K !== -1 && j !== K && ((Y = Xe(this, $a).current) == null || Y.setSelectionRange(j, K, ee))
      }
      const re = j !== -1 ? j : x,
        de = K !== -1 ? K : A,
        ne = ee ?? L;
      te(Xe(this, Da), re, !0), te(Xe(this, Ha), de, !0), y(Xe(this, ss)).prev = [re, de, ne]
    });
    Cr(this, "oninput", o => {
      const f = o.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (f.length > 0 && y(Xe(this, Mo)) && !y(Xe(this, Mo)).test(f)) {
        o.preventDefault();
        return
      }
      typeof Xe(this, Fc).current == "string" && f.length < Xe(this, Fc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")), this.opts.value.current = f
    });
    Cr(this, "onfocus", o => {
      const f = Xe(this, $a).current;
      if (f) {
        const x = Math.min(f.value.length, this.opts.maxLength.current - 1),
          A = f.value.length;
        f.setSelectionRange(x, A), te(Xe(this, Da), x, !0), te(Xe(this, Ha), A, !0)
      }
      Xe(this, os).current = !0
    });
    Cr(this, "onpaste", o => {
      var K, ee, re, de;
      const f = Xe(this, $a).current;
      if (!f) return;
      const x = ne => {
          const Y = f.selectionStart === null ? void 0 : f.selectionStart,
            we = f.selectionEnd === null ? void 0 : f.selectionEnd,
            Ie = Y !== we,
            ze = this.opts.value.current;
          return (Ie ? ze.slice(0, Y) + ne + ze.slice(we) : ze.slice(0, Y) + ne + ze.slice(Y)).slice(0, this.opts.maxLength.current)
        },
        A = ne => ne.length > 0 && y(Xe(this, Mo)) && !y(Xe(this, Mo)).test(ne);
      if (!((K = this.opts.pasteTransformer) != null && K.current) && (!Xe(this, Bc).isIOS || !o.clipboardData || !f)) {
        const ne = x((ee = o.clipboardData) == null ? void 0 : ee.getData("text/plain"));
        A(ne) && o.preventDefault();
        return
      }
      const L = ((re = o.clipboardData) == null ? void 0 : re.getData("text/plain")) ?? "",
        w = (de = this.opts.pasteTransformer) != null && de.current ? this.opts.pasteTransformer.current(L) : L;
      o.preventDefault();
      const s = x(w);
      if (A(s)) return;
      f.value = s, this.opts.value.current = s;
      const B = Math.min(s.length, this.opts.maxLength.current - 1),
        j = s.length;
      f.setSelectionRange(B, j), te(Xe(this, Da), B, !0), te(Xe(this, Ha), j, !0)
    });
    Cr(this, "onmouseover", o => {
      te(Xe(this, Rc), !0)
    });
    Cr(this, "onmouseleave", o => {
      te(Xe(this, Rc), !1)
    });
    Cr(this, "onblur", o => {
      if (y(Xe(this, ss)).willSyntheticBlur) {
        y(Xe(this, ss)).willSyntheticBlur = !1;
        return
      }
      Xe(this, os).current = !1
    });
    Pr(this, qh, ct(() => {
      var o;
      return {
        id: this.opts.inputId.current,
        style: y(Xe(this, qp)),
        autocomplete: this.opts.autocomplete.current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": y(Xe(this, Da)),
        "data-pin-input-input-mse": y(Xe(this, Ha)),
        inputmode: this.opts.inputmode.current,
        pattern: (o = y(Xe(this, Mo))) == null ? void 0 : o.source,
        maxlength: this.opts.maxLength.current,
        value: this.opts.value.current,
        disabled: AE(this.opts.disabled.current),
        onpaste: this.onpaste,
        oninput: this.oninput,
        onkeydown: this.onkeydown,
        onmouseover: this.onmouseover,
        onmouseleave: this.onmouseleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.inputAttachment
      }
    }));
    Pr(this, Zp, ct(() => Array.from({
      length: this.opts.maxLength.current
    }).map((o, f) => {
      const x = Xe(this, os).current && y(Xe(this, Da)) !== null && y(Xe(this, Ha)) !== null && (y(Xe(this, Da)) === y(Xe(this, Ha)) && f === y(Xe(this, Da)) || f >= y(Xe(this, Da)) && f < y(Xe(this, Ha))),
        A = this.opts.value.current[f] !== void 0 ? this.opts.value.current[f] : null;
      return {
        char: A,
        isActive: x,
        hasFakeCaret: x && A === null
      }
    })));
    Pr(this, Uh, ct(() => ({
      cells: y(Xe(this, Zp)),
      isFocused: Xe(this, os).current,
      isHovering: y(Xe(this, Rc))
    })));
    var f;
    this.opts = o, this.attachment = Xa(this.opts.ref), this.domContext = new ME(o.ref), Hi(this, Bc, {
      value: this.opts.value,
      isIOS: typeof window < "u" && ((f = window == null ? void 0 : window.CSS) == null ? void 0 : f.supports("-webkit-touch-callout", "none"))
    }), Hi(this, Ds, I8({
      containerRef: this.opts.ref,
      inputRef: Xe(this, $a),
      isFocused: Xe(this, os),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    })), Dn(() => {
      const x = Xe(this, $a).current,
        A = this.opts.ref.current;
      if (!x || !A) return;
      Xe(this, Bc).value.current !== x.value && (this.opts.value.current = x.value), y(Xe(this, ss)).prev = [x.selectionStart, x.selectionEnd, x.selectionDirection ?? "none"];
      const L = eh(this.domContext.getDocument(), "selectionchange", Xe(this, Vh), {
        capture: !0
      });
      Xe(this, Vh).call(this), this.domContext.getActiveElement() === x && (Xe(this, os).current = !0), this.domContext.getElementById("pin-input-style") || Nr(this, Up, wy).call(this);
      const w = () => {
        A && A.style.setProperty("--bits-pin-input-root-height", `${x.clientHeight}px`)
      };
      w();
      const s = new ResizeObserver(w);
      return s.observe(x), () => {
        L(), s.disconnect()
      }
    }), xl([() => this.opts.value.current, () => Xe(this, $a).current], () => {
      A8(() => {
        const x = Xe(this, $a).current;
        if (!x) return;
        x.dispatchEvent(new Event("input"));
        const A = x.selectionStart,
          L = x.selectionEnd,
          w = x.selectionDirection ?? "none";
        A !== null && L !== null && (te(Xe(this, Da), A, !0), te(Xe(this, Ha), L, !0), y(Xe(this, ss)).prev = [A, L, w])
      }, this.domContext)
    }), Zr(() => {
      const x = this.opts.value.current,
        A = Xe(this, Fc).current,
        L = this.opts.maxLength.current,
        w = this.opts.onComplete.current;
      A !== void 0 && x !== A && A.length < L && x.length === L && w(x)
    })
  }
  static create(o) {
    return new Z_(o)
  }
  get rootProps() {
    return y(Xe(this, Nh))
  }
  set rootProps(o) {
    te(Xe(this, Nh), o)
  }
  get inputWrapperProps() {
    return y(Xe(this, jh))
  }
  set inputWrapperProps(o) {
    te(Xe(this, jh), o)
  }
  get inputProps() {
    return y(Xe(this, qh))
  }
  set inputProps(o) {
    te(Xe(this, qh), o)
  }
  get snippetProps() {
    return y(Xe(this, Uh))
  }
  set snippetProps(o) {
    te(Xe(this, Uh), o)
  }
};
$a = new WeakMap, Rc = new WeakMap, os = new WeakMap, Da = new WeakMap, Ha = new WeakMap, Fc = new WeakMap, Mo = new WeakMap, ss = new WeakMap, Ds = new WeakMap, Bc = new WeakMap, Vp = new WeakMap, Nh = new WeakMap, jh = new WeakMap, qp = new WeakMap, Up = new WeakSet, wy = function() {
  const o = this.domContext.getDocument(),
    f = o.createElement("style");
  if (f.id = "pin-input-style", o.head.appendChild(f), f.sheet) {
    const x = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    Hu(f.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"), Hu(f.sheet, `[data-pin-input-input]:autofill { ${x} }`), Hu(f.sheet, `[data-pin-input-input]:-webkit-autofill { ${x} }`), Hu(f.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), Hu(f.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
  }
}, Vh = new WeakMap, qh = new WeakMap, Zp = new WeakMap, Uh = new WeakMap;
let Qm = Z_;
var Zh;
const G_ = class G_ {
  constructor(o) {
    Cr(this, "opts");
    Cr(this, "attachment");
    Pr(this, Zh, ct(() => ({
      id: this.opts.id.current,
      [by.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
      ...this.attachment
    })));
    this.opts = o, this.attachment = Xa(this.opts.ref)
  }
  static create(o) {
    return new G_(o)
  }
  get props() {
    return y(Xe(this, Zh))
  }
  set props(o) {
    te(Xe(this, Zh), o)
  }
};
Zh = new WeakMap;
let e_ = G_;

function A8(_, o) {
  const f = o.setTimeout(_, 0),
    x = o.setTimeout(_, 10),
    A = o.setTimeout(_, 50);
  return [f, x, A]
}

function Hu(_, o) {
  try {
    _.insertRule(o)
  } catch {
    console.error("pin input could not insert CSS rule:", o)
  }
}
var k8 = me("<div><!> <div><input/></div></div>");

function E8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "inputId", 19, () => `${Ya(f)}-input`),
    L = At(o, "ref", 15, null),
    w = At(o, "maxlength", 3, 6),
    s = At(o, "textalign", 3, "left"),
    B = At(o, "inputmode", 3, "numeric"),
    j = At(o, "onComplete", 3, nh),
    K = At(o, "pushPasswordManagerStrategy", 3, "increase-width"),
    ee = At(o, "class", 3, ""),
    re = At(o, "autocomplete", 3, "one-time-code"),
    de = At(o, "disabled", 3, !1),
    ne = At(o, "value", 15, ""),
    Y = At(o, "onValueChange", 3, nh),
    we = lr(o, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
  const Ie = Qm.create({
      id: Hr(() => x()),
      ref: Hr(() => L(), He => L(He)),
      inputId: Hr(() => A()),
      autocomplete: Hr(() => re()),
      maxLength: Hr(() => w()),
      textAlign: Hr(() => s()),
      disabled: Hr(() => de()),
      inputmode: Hr(() => B()),
      pattern: Hr(() => o.pattern),
      onComplete: Hr(() => j()),
      value: Hr(() => ne(), He => {
        ne(He), Y()(He)
      }),
      pushPasswordManagerStrategy: Hr(() => K()),
      pasteTransformer: Hr(() => o.pasteTransformer)
    }),
    ze = ct(() => Fa(we, Ie.inputProps)),
    Re = ct(() => Fa(Ie.rootProps, {
      class: ee()
    })),
    ke = ct(() => Fa(Ie.inputWrapperProps, {}));
  var qe = k8();
  cr(qe, () => ({
    ...y(Re)
  }));
  var $e = M(qe);
  ai($e, () => o.children ?? oa, () => Ie.snippetProps);
  var Be = q($e, 2);
  cr(Be, () => ({
    ...y(ke)
  }));
  var Ee = M(Be);
  cr(Ee, () => ({
    ...y(ze)
  }), void 0, void 0, void 0, void 0, !0), P(Be), P(qe), G(_, qe), Lr()
}
var z8 = me("<div><!></div>");

function L8(_, o) {
  const f = _o();
  zr(o, !0);
  let x = At(o, "id", 19, () => Ya(f)),
    A = At(o, "ref", 15, null),
    L = lr(o, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
  const w = e_.create({
      id: Hr(() => x()),
      ref: Hr(() => A(), re => A(re)),
      cell: Hr(() => o.cell)
    }),
    s = ct(() => Fa(L, w.props));
  var B = Jt(),
    j = gt(B);
  {
    var K = re => {
        var de = Jt(),
          ne = gt(de);
        ai(ne, () => o.child, () => ({
          props: y(s)
        })), G(re, de)
      },
      ee = re => {
        var de = z8();
        cr(de, () => ({
          ...y(s)
        }));
        var ne = M(de);
        ai(ne, () => o.children ?? oa), P(de), G(re, de)
      };
    Ae(j, re => {
      o.child ? re(K) : re(ee, !1)
    })
  }
  G(_, B), Lr()
}

function Nc(..._) {
  return P0(Qu(_))
}

function D8(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = At(o, "value", 15, ""),
    A = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var L = Jt(),
    w = gt(L);
  {
    let s = ct(() => Nc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", o.class));
    Ti(w, () => QE, (B, j) => {
      j(B, Fs({
        "data-slot": "command",
        get class() {
          return y(s)
        }
      }, () => A, {
        get value() {
          return x()
        },
        set value(K) {
          x(K)
        },
        get ref() {
          return f()
        },
        set ref(K) {
          f(K)
        }
      }))
    })
  }
  G(_, L), Lr()
}
var R8 = Dr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');

function Bs(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = R8();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}

function F8(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Jt(),
    L = gt(A);
  {
    let w = ct(() => Nc("py-6 text-center text-sm", o.class));
    Ti(L, () => t8, (s, B) => {
      B(s, Fs({
        "data-slot": "command-empty",
        get class() {
          return y(w)
        }
      }, () => x, {
        get ref() {
          return f()
        },
        set ref(j) {
          f(j)
        }
      }))
    })
  }
  G(_, A), Lr()
}
var B8 = me("<!> <!>", 1);

function O8(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var A = Jt(),
    L = gt(A);
  {
    let w = ct(() => Nc("text-foreground overflow-hidden p-1", o.class)),
      s = ct(() => o.value ?? o.heading ?? `----${GE()}`);
    Ti(L, () => n8, (B, j) => {
      j(B, Fs({
        "data-slot": "command-group",
        get class() {
          return y(w)
        },
        get value() {
          return y(s)
        }
      }, () => x, {
        get ref() {
          return f()
        },
        set ref(K) {
          f(K)
        },
        children: (K, ee) => {
          var re = B8(),
            de = gt(re);
          {
            var ne = we => {
              var Ie = Jt(),
                ze = gt(Ie);
              Ti(ze, () => a8, (Re, ke) => {
                ke(Re, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (qe, $e) => {
                    bn();
                    var Be = ji();
                    je(() => le(Be, o.heading)), G(qe, Be)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), G(we, Ie)
            };
            Ae(de, we => {
              o.heading && we(ne)
            })
          }
          var Y = q(de, 2);
          Ti(Y, () => l8, (we, Ie) => {
            Ie(we, {
              get children() {
                return o.children
              }
            })
          }), G(K, re)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  G(_, A), Lr()
}

function N8(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Jt(),
    L = gt(A);
  {
    let w = ct(() => Nc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", o.class));
    Ti(L, () => p8, (s, B) => {
      B(s, Fs({
        "data-slot": "command-item",
        get class() {
          return y(w)
        }
      }, () => x, {
        get ref() {
          return f()
        },
        set ref(j) {
          f(j)
        }
      }))
    })
  }
  G(_, A), Lr()
}
var j8 = Dr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');

function V8(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = j8();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var q8 = me('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function U8(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = At(o, "value", 15, ""),
    A = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var L = q8(),
    w = M(L);
  V8(w, {
    class: "size-5 opacity-50"
  });
  var s = q(w, 2);
  {
    let B = ct(() => Nc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", o.class));
    Ti(s, () => u8, (j, K) => {
      K(j, Fs({
        "data-slot": "command-input",
        get class() {
          return y(B)
        }
      }, () => A, {
        get ref() {
          return f()
        },
        set ref(ee) {
          f(ee)
        },
        get value() {
          return x()
        },
        set value(ee) {
          x(ee)
        }
      }))
    })
  }
  P(L), G(_, L), Lr()
}

function Z8(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var A = Jt(),
    L = gt(A);
  {
    let w = ct(() => Nc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", o.class));
    Ti(L, () => m8, (s, B) => {
      B(s, Fs({
        "data-slot": "command-list",
        get class() {
          return y(w)
        }
      }, () => x, {
        get ref() {
          return f()
        },
        set ref(j) {
          f(j)
        }
      }))
    })
  }
  G(_, A), Lr()
}
var G8 = Dr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function $8(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = G8();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var H8 = me("<span> </span> <!>", 1),
  W8 = me('<span class="font-flag ml-0.5"> </span> ', 1),
  X8 = me('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  Y8 = me("<!> <!>", 1),
  K8 = me("<!> <!>", 1),
  J8 = me('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  Q8 = me('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function Kv(_, o) {
  zr(o, !0);
  let f = At(o, "countryId", 15, 0),
    x = At(o, "dropdownDirection", 3, "right"),
    A = Qe(null),
    L = Qe(null),
    w = Qe("");

  function s() {
    g0().then(() => {
      var Re;
      (Re = document.activeElement) == null || Re.blur(), te(w, "")
    })
  }
  var B = Q8(),
    j = M(B),
    K = M(j),
    ee = M(K);
  {
    var re = Re => {
        var ke = H8(),
          qe = gt(ke),
          $e = M(qe, !0);
        P(qe);
        var Be = q(qe, 2);
        $8(Be, {
          class: "size-3.5"
        }), je(Ee => le($e, Ee), [() => __()]), G(Re, ke)
      },
      de = Re => {
        const ke = ct(() => Ao(f()));
        var qe = W8(),
          $e = gt(qe),
          Be = M($e, !0);
        P($e);
        var Ee = q($e);
        je(() => {
          le(Be, y(ke).flag), le(Ee, ` ${y(ke).name??""}`)
        }), G(Re, qe)
      };
    Ae(ee, Re => {
      f() === 0 ? Re(re) : Re(de, !1)
    })
  }
  P(K);
  var ne = q(K, 2);
  let Y;
  var we = M(ne);
  Ti(we, () => D8, (Re, ke) => {
    ke(Re, {
      children: (qe, $e) => {
        var Be = K8(),
          Ee = gt(Be);
        Ti(Ee, () => U8, (Le, it) => {
          it(Le, {
            placeholder: "Country",
            get ref() {
              return y(A)
            },
            set ref(pt) {
              te(A, pt)
            },
            get value() {
              return y(w)
            },
            set value(pt) {
              te(w, pt, !0)
            }
          })
        });
        var He = q(Ee, 2);
        Ti(He, () => Z8, (Le, it) => {
          it(Le, {
            children: (pt, Oe) => {
              var Je = Y8(),
                bt = gt(Je);
              Ti(bt, () => F8, (Ue, Ge) => {
                Ge(Ue, {
                  children: (Ve, mt) => {
                    bn();
                    var lt = ji();
                    je(yt => le(lt, yt), [() => M5()]), G(Ve, lt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var We = q(bt, 2);
              Ti(We, () => O8, (Ue, Ge) => {
                Ge(Ue, {
                  children: (Ve, mt) => {
                    var lt = Jt(),
                      yt = gt(lt);
                    ii(yt, 17, () => ma.countries, _t => _t.id, (_t, ut) => {
                      var Ut = Jt(),
                        Lt = gt(Ut);
                      Ti(Lt, () => N8, (Ke, ot) => {
                        ot(Ke, {
                          get value() {
                            return y(ut).name
                          },
                          onSelect: () => {
                            f(y(ut).id), s()
                          },
                          children: (xt, Ct) => {
                            var wt = X8(),
                              kt = M(wt),
                              Zt = M(kt, !0);
                            P(kt);
                            var Nt = q(kt);
                            P(wt), je(() => {
                              le(Zt, y(ut).flag), le(Nt, ` ${y(ut).name??""}`)
                            }), G(xt, wt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), G(_t, Ut)
                    }), G(Ve, lt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), G(pt, Je)
            },
            $$slots: {
              default: !0
            }
          })
        }), G(qe, Be)
      },
      $$slots: {
        default: !0
      }
    })
  }), P(ne), P(j);
  var Ie = q(j, 2);
  {
    var ze = Re => {
      var ke = J8();
      ke.__click = () => {
        f(0)
      };
      var qe = M(ke);
      Bs(qe, {
        class: "size-3.5"
      }), P(ke), G(Re, ke)
    };
    Ae(Ie, Re => {
      f() != 0 && Re(ze)
    })
  }
  P(B), ko(B, Re => te(L, Re), () => y(L)), je(() => Y = Or(ne, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, Y, {
    "right-1": x() === "left"
  })), Un("focus", K, () => {
    y(A).focus()
  }), G(_, B), Lr()
}
Rn(["click"]);
var ez = Dr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function tz(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = ez();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var rz = Dr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  nz = Dr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function ah(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = gt(x);
  {
    var L = s => {
        var B = rz();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      },
      w = s => {
        var B = nz();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      };
    Ae(A, s => {
      o.filled ? s(L) : s(w, !1)
    })
  }
  G(_, x)
}
var iz = me('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  az = me('<div class="mb-2"><!></div>'),
  oz = me('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  sz = me('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  lz = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  cz = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  uz = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  hz = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  dz = me("<span> </span>"),
  pz = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  fz = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  mz = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  _z = me('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  gz = me('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  vz = me('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function yz(_, o) {
  zr(o, !0);
  const f = [];
  let x = Qe(1e3);
  const A = ct(() => y(x) <= 640);
  let L = Qe("today"),
    w = {
      regions: {
        label: OS(),
        icon: $p
      },
      countries: {
        label: VS(),
        icon: tz
      },
      players: {
        label: U0(),
        icon: ef
      },
      alliances: {
        label: Z0(),
        icon: tf
      }
    },
    s = Qe("regions"),
    B = Qe(0),
    j = Si({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    K = ct(() => {
      var Be, Ee, He;
      return y(s) === "regions" ? (Ee = (Be = j[y(s)][y(B)]) == null ? void 0 : Be[y(L)]) == null ? void 0 : Ee.entries : (He = j[y(s)][y(L)]) == null ? void 0 : He.entries
    });
  const ee = 5 * 1e3;
  Zr(() => {
    var Le;
    if (!o.open) return;
    const Be = y(L),
      Ee = y(s),
      He = y(B);
    Ee === "players" && (!j[Ee][Be] || Date.now() - j[Ee][Be].time > ee) ? Jr.leaderboardPlayers(Be).then(it => {
      j[Ee][Be] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => vr.error(it.message)) : Ee === "alliances" && (!j[Ee][Be] || Date.now() - j[Ee][Be].time > ee) ? Jr.leaderboardAlliances(Be).then(it => {
      j[Ee][Be] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => vr.error(it.message)) : Ee === "countries" && (!j[Ee][Be] || Date.now() - j[Ee][Be].time > ee) ? Jr.leaderboardCountries(Be).then(it => {
      j[Ee][Be] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => vr.error(it.message)) : Ee === "regions" && (!((Le = j[Ee][He]) != null && Le[Be]) || Date.now() - j[Ee][He][Be].time > ee) && Jr.leaderboardRegions(Be, He).then(it => {
      j[Ee][He] || (j[Ee][He] = {}), j[Ee][He][Be] = {
        time: Date.now(),
        entries: it
      }
    }).catch(it => vr.error(it.message))
  });
  var re = vz(),
    de = gt(re);
  ii(de, 21, () => Object.entries(w), ([Be, {
    label: Ee,
    icon: He
  }]) => Be, (Be, Ee) => {
    var He = ct(() => v0(y(Ee), 2));
    let Le = () => y(He)[0],
      it = () => y(He)[1].label,
      pt = () => y(He)[1].icon;
    const Oe = ct(pt);
    var Je = iz(),
      bt = M(Je);
    Ba(bt);
    var We, Ue = q(bt, 2);
    Ti(Ue, () => y(Oe), (Ve, mt) => {
      mt(Ve, {
        get this() {
          return pt()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Ge = q(Ue);
    P(Je), je(() => {
      mr(bt, "aria-label", it()), We !== (We = Le()) && (bt.value = (bt.__value = Le()) ?? ""), le(Ge, ` ${it()??""}`)
    }), h_(f, [], bt, () => (Le(), y(s)), Ve => te(s, Ve)), G(Be, Je)
  }), P(de);
  var ne = q(de, 2),
    Y = M(ne);
  T_(Y, {
    get value() {
      return y(L)
    },
    set value(Be) {
      te(L, Be, !0)
    }
  });
  var we = q(Y, 2);
  {
    var Ie = Be => {
      Kv(Be, {
        dropdownDirection: "left",
        get countryId() {
          return y(B)
        },
        set countryId(Ee) {
          te(B, Ee, !0)
        }
      })
    };
    Ae(we, Be => {
      y(s) === "regions" && !y(A) && Be(Ie)
    })
  }
  P(ne);
  var ze = q(ne, 2);
  {
    var Re = Be => {
      var Ee = az(),
        He = M(Ee);
      Kv(He, {
        get countryId() {
          return y(B)
        },
        set countryId(Le) {
          te(B, Le, !0)
        }
      }), P(Ee), G(Be, Ee)
    };
    Ae(ze, Be => {
      y(s) === "regions" && y(A) && Be(Re)
    })
  }
  var ke = q(ze, 2);
  {
    var qe = Be => {
        var Ee = oz(),
          He = M(Ee),
          Le = q(He);
        {
          var it = Oe => {
              var Je = ji();
              je(bt => le(Je, bt), [() => Qp().toLowerCase()]), G(Oe, Je)
            },
            pt = Oe => {
              var Je = Jt(),
                bt = gt(Je);
              {
                var We = Ge => {
                    var Ve = ji();
                    je(mt => le(Ve, mt), [() => y_()]), G(Ge, Ve)
                  },
                  Ue = Ge => {
                    var Ve = Jt(),
                      mt = gt(Ve);
                    {
                      var lt = yt => {
                        var _t = ji();
                        je(ut => le(_t, ut), [() => x_()]), G(yt, _t)
                      };
                      Ae(mt, yt => {
                        y(L) === "month" && yt(lt)
                      }, !0)
                    }
                    G(Ge, Ve)
                  };
                Ae(bt, Ge => {
                  y(L) === "week" ? Ge(We) : Ge(Ue, !1)
                }, !0)
              }
              G(Oe, Je)
            };
          Ae(Le, Oe => {
            y(L) === "today" ? Oe(it) : Oe(pt, !1)
          })
        }
        P(Ee), je(Oe => le(He, `${Oe??""} `), [() => v_()]), G(Be, Ee)
      },
      $e = Be => {
        var Ee = Jt(),
          He = gt(Ee);
        {
          var Le = pt => {
              var Oe = Jt(),
                Je = gt(Oe);
              {
                var bt = Ue => {
                    const Ge = ct(() => y(K));
                    var Ve = lz(),
                      mt = M(Ve),
                      lt = M(mt),
                      yt = q(M(lt)),
                      _t = M(yt, !0);
                    P(yt);
                    var ut = q(yt),
                      Ut = M(ut),
                      Lt = q(Ut, 2),
                      Ke = q(Lt),
                      ot = M(Ke);
                    ah(ot, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), P(Ke), P(ut), bn(), P(lt), P(mt);
                    var xt = q(mt);
                    ii(xt, 31, () => y(Ge), Ct => Ct.id, (Ct, wt, kt) => {
                      const Zt = ct(() => Ao(y(wt).countryId));
                      var Nt = sz(),
                        $t = M(Nt),
                        It = M($t, !0);
                      P($t);
                      var Xt = q($t),
                        Ot = M(Xt),
                        jt = M(Ot, !0);
                      P(Ot);
                      var qt = q(Ot, 2),
                        fr = M(qt),
                        Kt = q(fr),
                        _r = M(Kt);
                      P(Kt), P(qt), P(Xt);
                      var rr = q(Xt),
                        hr = M(rr, !0);
                      P(rr);
                      var nr = q(rr),
                        Et = M(nr);
                      Et.__click = () => {
                        o.onvisitclick({
                          lat: y(wt).lastLatitude,
                          lng: y(wt).lastLongitude
                        })
                      };
                      var kr = M(Et, !0);
                      P(Et), P(nr), P(Nt), je((Te, O, E) => {
                        le(It, y(kt) + 1), mr(Ot, "data-tip", y(Zt).name), le(jt, y(Zt).flag), Or(qt, 1, `font-semibold ${Te??""}`), le(fr, `${y(wt).name??""} `), le(_r, `#${y(wt).number??""}`), le(hr, O), le(kr, E)
                      }, [() => Ni(y(wt).cityId), () => y(wt).pixelsPainted.toLocaleString("en-US"), () => Lb()]), _l(Nt, () => gl, () => ({
                        duration: 200
                      })), G(Ct, Nt)
                    }), P(xt), P(Ve), je((Ct, wt, kt, Zt) => {
                      le(_t, Ct), le(Ut, `${wt??""} `), le(Lt, `${kt??""} `), mr(Ke, "data-tip", Zt)
                    }, [() => WS(), () => Mc(), () => Ac().toLowerCase(), () => tC()]), G(Ue, Ve)
                  },
                  We = Ue => {
                    var Ge = Jt(),
                      Ve = gt(Ge);
                    {
                      var mt = yt => {
                          var _t = uz(),
                            ut = M(_t),
                            Ut = M(ut),
                            Lt = q(M(Ut)),
                            Ke = M(Lt, !0);
                          P(Lt);
                          var ot = q(Lt),
                            xt = M(ot),
                            Ct = q(xt, 2),
                            wt = q(Ct),
                            kt = M(wt);
                          ah(kt, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), P(wt), P(ot), P(Ut), P(ut);
                          var Zt = q(ut);
                          ii(Zt, 31, () => y(K), Nt => Nt.id, (Nt, $t, It) => {
                            const Xt = ct(() => Ao(y($t).id) ?? {
                              name: `Pais ID: ${y($t).id}`,
                              flag: "üè≥Ô∏è",
                              code: "XX"
                            });
                            var Ot = cz(),
                              jt = M(Ot),
                              qt = M(jt, !0);
                            P(jt);
                            var fr = q(jt),
                              Kt = M(fr),
                              _r = M(Kt, !0);
                            P(Kt);
                            var rr = q(Kt, 2),
                              hr = M(rr, !0);
                            P(rr), P(fr);
                            var nr = q(fr),
                              Et = M(nr, !0);
                            P(nr), P(Ot), je((kr, Te) => {
                              le(qt, y(It) + 1), mr(Kt, "data-tip", y(Xt).name), le(_r, y(Xt).flag), Or(rr, 1, `font-semibold ${kr??""}`), le(hr, y(Xt).name), le(Et, Te)
                            }, [() => Ni(y($t).id), () => y($t).pixelsPainted.toLocaleString("en-US")]), _l(Ot, () => gl, () => ({
                              duration: 200
                            })), G(Nt, Ot)
                          }), P(Zt), P(_t), je((Nt, $t, It, Xt) => {
                            le(Ke, Nt), le(xt, `${$t??""} `), le(Ct, `${It??""} `), mr(wt, "data-tip", Xt)
                          }, [() => __(), () => Mc(), () => Ac().toLowerCase(), () => EC()]), G(yt, _t)
                        },
                        lt = yt => {
                          var _t = Jt(),
                            ut = gt(_t);
                          {
                            var Ut = Ke => {
                                const ot = ct(() => y(K));
                                var xt = fz(),
                                  Ct = M(xt),
                                  wt = M(Ct),
                                  kt = q(M(wt)),
                                  Zt = M(kt, !0);
                                P(kt);
                                var Nt = q(kt),
                                  $t = M(Nt),
                                  It = q($t, 2, !0);
                                P(Nt), P(wt), P(Ct);
                                var Xt = q(Ct);
                                ii(Xt, 31, () => y(ot), Ot => Ot.id, (Ot, jt, qt) => {
                                  const fr = ct(() => {
                                    var Tt;
                                    return ((Tt = Mt.data) == null ? void 0 : Tt.id) === y(jt).id
                                  });
                                  var Kt = pz();
                                  let _r;
                                  var rr = M(Kt),
                                    hr = M(rr, !0);
                                  P(rr);
                                  var nr = q(rr),
                                    Et = M(nr),
                                    kr = M(Et);
                                  mo(kr, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return y(jt).id
                                    },
                                    get pictureUrl() {
                                      return y(jt).picture
                                    }
                                  });
                                  var Te = q(kr, 2),
                                    O = M(Te),
                                    E = M(O),
                                    D = q(E),
                                    N = M(D);
                                  P(D), P(O);
                                  var H = q(O, 2);
                                  {
                                    var W = Tt => {
                                      const _e = ct(() => Ao(y(jt).equippedFlag));
                                      var Vt = Jt(),
                                        ur = gt(Vt);
                                      {
                                        var Ft = or => {
                                          var Vr = hz(),
                                            qr = M(Vr, !0);
                                          P(Vr), je(() => {
                                            mr(Vr, "data-tip", y(_e).name), le(qr, y(_e).flag)
                                          }), G(or, Vr)
                                        };
                                        Ae(ur, or => {
                                          y(_e) && or(Ft)
                                        })
                                      }
                                      G(Tt, Vt)
                                    };
                                    Ae(H, Tt => {
                                      y(jt).equippedFlag && Tt(W)
                                    })
                                  }
                                  var ce = q(H, 2);
                                  {
                                    var ve = Tt => {
                                      Hh(Tt, {
                                        get username() {
                                          return y(jt).discord
                                        },
                                        get id() {
                                          return y(jt).discordId
                                        }
                                      })
                                    };
                                    Ae(ce, Tt => {
                                      y(jt).discord && Tt(ve)
                                    })
                                  }
                                  var he = q(ce, 2);
                                  {
                                    var Se = Tt => {
                                      var _e = dz(),
                                        Vt = M(_e, !0);
                                      P(_e), je((ur, Ft) => {
                                        Or(_e, 1, `badge badge-sm ml-0.5 border-0 ${ur??""} ${Ft??""}`), le(Vt, y(jt).allianceName)
                                      }, [() => Wp(y(jt).allianceId), () => Ni(y(jt).allianceId)]), G(Tt, _e)
                                    };
                                    Ae(he, Tt => {
                                      "allianceName" in y(jt) && y(jt).allianceName && Tt(Se)
                                    })
                                  }
                                  P(Te), P(Et), P(nr);
                                  var Ye = q(nr),
                                    Ze = M(Ye, !0);
                                  P(Ye), P(Kt), je((Tt, _e) => {
                                    _r = Or(Kt, 1, "", null, _r, {
                                      "bg-base-200": y(fr)
                                    }), le(hr, y(qt) + 1), Or(O, 1, `font-semibold max-sm:ml-2 ${Tt??""} flex gap-1`), le(E, `${y(jt).name??""} `), le(N, `#${y(jt).id??""}`), le(Ze, _e)
                                  }, [() => Ni(y(jt).id), () => y(jt).pixelsPainted.toLocaleString("en-US")]), _l(Kt, () => gl, () => ({
                                    duration: 200
                                  })), G(Ot, Kt)
                                }), P(Xt), P(xt), je((Ot, jt, qt) => {
                                  le(Zt, Ot), le($t, `${jt??""} `), le(It, qt)
                                }, [() => d_(), () => Mc(), () => Ac().toLowerCase()]), G(Ke, xt)
                              },
                              Lt = Ke => {
                                var ot = Jt(),
                                  xt = gt(ot);
                                {
                                  var Ct = wt => {
                                    var kt = _z(),
                                      Zt = M(kt),
                                      Nt = M(Zt),
                                      $t = q(M(Nt)),
                                      It = M($t, !0);
                                    P($t);
                                    var Xt = q($t),
                                      Ot = M(Xt),
                                      jt = q(Ot, 2, !0);
                                    P(Xt), P(Nt), P(Zt);
                                    var qt = q(Zt);
                                    ii(qt, 31, () => y(K), fr => fr.id, (fr, Kt, _r) => {
                                      const rr = ct(() => {
                                        var H;
                                        return ((H = Mt.data) == null ? void 0 : H.allianceId) === y(Kt).id
                                      });
                                      var hr = mz();
                                      let nr;
                                      var Et = M(hr),
                                        kr = M(Et, !0);
                                      P(Et);
                                      var Te = q(Et),
                                        O = M(Te),
                                        E = M(O, !0);
                                      P(O), P(Te);
                                      var D = q(Te),
                                        N = M(D, !0);
                                      P(D), P(hr), je((H, W) => {
                                        nr = Or(hr, 1, "", null, nr, {
                                          "bg-base-200": y(rr)
                                        }), le(kr, y(_r) + 1), Or(O, 1, `font-semibold ${H??""}`), le(E, y(Kt).name), le(N, W)
                                      }, [() => Ni(y(Kt).id), () => y(Kt).pixelsPainted.toLocaleString("en-US")]), _l(hr, () => gl, () => ({
                                        duration: 200
                                      })), G(fr, hr)
                                    }), P(qt), P(kt), je((fr, Kt, _r) => {
                                      le(It, fr), le(Ot, `${Kt??""} `), le(jt, _r)
                                    }, [() => Kp(), () => Mc(), () => Ac().toLowerCase()]), G(wt, kt)
                                  };
                                  Ae(xt, wt => {
                                    y(s) === "alliances" && wt(Ct)
                                  }, !0)
                                }
                                G(Ke, ot)
                              };
                            Ae(ut, Ke => {
                              y(s) === "players" ? Ke(Ut) : Ke(Lt, !1)
                            }, !0)
                          }
                          G(yt, _t)
                        };
                      Ae(Ve, yt => {
                        y(s) === "countries" ? yt(mt) : yt(lt, !1)
                      }, !0)
                    }
                    G(Ue, Ge)
                  };
                Ae(Je, Ue => {
                  y(s) === "regions" ? Ue(bt) : Ue(We, !1)
                })
              }
              G(pt, Oe)
            },
            it = pt => {
              var Oe = gz();
              G(pt, Oe)
            };
          Ae(He, pt => {
            y(K) ? pt(Le) : pt(it, !1)
          }, !0)
        }
        G(Be, Ee)
      };
    Ae(ke, Be => {
      y(K) && y(K).length === 0 ? Be(qe) : Be($e, !1)
    })
  }
  Yp("innerWidth", Be => te(x, Be, !0)), G(_, re), Lr()
}
Rn(["click"]);
var xz = Dr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function Ty(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = xz();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var bz = me('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function wz(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  Dn(() => {
    const ee = re => {
      re.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", ee), () => document.removeEventListener("keydown", ee)
  });
  var x = bz(),
    A = M(x),
    L = q(M(A), 2),
    w = M(L);
  Ty(w, {
    class: "size-6"
  });
  var s = q(w, 2),
    B = M(s, !0);
  P(s), P(L);
  var j = q(L, 2),
    K = M(j);
  yz(K, {
    get onvisitclick() {
      return o.onvisitclick
    },
    get open() {
      return f()
    }
  }), P(j), P(A), bn(2), P(x), yi(x, () => ee => {
    Zr(() => {
      f() ? ee.show() : ee.close()
    })
  }), je(ee => le(B, ee), [() => m_()]), Un("close", x, () => f(!1)), G(_, x), Lr()
}
var Tz = me("<div><!></div>"),
  Sz = me('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Cz(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  Dn(() => {
    const s = B => {
      B.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", s), () => document.removeEventListener("keydown", s)
  });
  var x = Sz(),
    A = M(x),
    L = q(M(A), 2);
  {
    var w = s => {
      var B = Tz(),
        j = M(B);
      Vb(j, {}), P(B), aa(2, B, () => Wa, () => ({
        duration: 300
      })), G(s, B)
    };
    Ae(L, s => {
      f() && s(w)
    })
  }
  P(A), bn(2), P(x), yi(x, () => s => {
    Zr(() => {
      f() ? s.show() : s.close()
    })
  }), Un("close", x, () => f(!1)), G(_, x), Lr()
}
var Pz = me("<p>You don't have charges to paint. <br/> </p>");

function Iz(_, o) {
  zr(o, !1), D0();
  var f = Pz(),
    x = q(M(f), 2);
  P(f), je(A => le(x, ` Next charge in ${A??""}`), [() => Lp(Mt.cooldown ?? 0)]), G(_, f), Lr()
}
var Mz = me('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form>'),
  Az = me('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  kz = me("<dialog><div><!> <!></div> <!></dialog>");

function M_(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = At(o, "hasBackdrop", 3, !0),
    A = At(o, "hasCloseButton", 3, !0);
  var L = kz(),
    w = M(L),
    s = M(w);
  {
    var B = re => {
      var de = Mz();
      G(re, de)
    };
    Ae(s, re => {
      A() && re(B)
    })
  }
  var j = q(s, 2);
  ai(j, () => o.children ?? oa), P(w);
  var K = q(w, 2);
  {
    var ee = re => {
      var de = Az(),
        ne = M(de),
        Y = M(ne, !0);
      P(ne), P(de), je(we => le(Y, we), [() => cs()]), G(re, de)
    };
    Ae(K, re => {
      x() && re(ee)
    })
  }
  P(L), yi(L, () => re => {
    Zr(() => {
      f() ? re.show() : re.close()
    })
  }), je(() => {
    Or(L, 1, `modal ${o.dialogClass??""}`), Or(w, 1, `modal-box ${o.modalBoxClass??""}`)
  }), Un("close", L, () => f(!1)), G(_, L), Lr()
}
var Ez = me('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function zz(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = At(o, "buttonText", 3, "OK");
  M_(_, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return f()
    },
    set open(A) {
      f(A)
    },
    children: (A, L) => {
      var w = Ez(),
        s = M(w),
        B = M(s, !0);
      P(s);
      var j = q(s, 2),
        K = M(j);
      ai(K, () => o.message), P(j);
      var ee = q(j, 2);
      ee.__click = () => {
        f(!1)
      };
      var re = M(ee, !0);
      P(ee), P(w), je(() => {
        le(B, o.title), le(re, x())
      }), G(A, w)
    },
    $$slots: {
      default: !0
    }
  }), Lr()
}
Rn(["click"]);

function Lz(_) {
  const o = new Date;
  return _.getDate() === o.getDate() && _.getMonth() === o.getMonth() && _.getFullYear() === o.getFullYear() ? _.toLocaleTimeString(void 0, {
    timeStyle: "short"
  }) : _.toLocaleDateString(void 0, {
    dateStyle: "medium"
  })
}
var Dz = me('<span class="size-2 rounded-full bg-red-400"></span>'),
  Rz = me('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function Fz(_, o) {
  zr(o, !0);
  let f = At(o, "read", 15);
  var x = Rz();
  x.__click = () => {
    f(!0), o.onclick()
  };
  var A = M(x),
    L = M(A);
  ai(L, () => o.icon), P(A);
  var w = q(A, 2),
    s = M(w),
    B = M(s),
    j = M(B, !0);
  P(B);
  var K = q(B, 2),
    ee = M(K),
    re = M(ee, !0);
  P(ee);
  var de = q(ee, 2);
  {
    var ne = Ie => {
      var ze = Dz();
      G(Ie, ze)
    };
    Ae(de, Ie => {
      f() || Ie(ne)
    })
  }
  P(K), P(s);
  var Y = q(s, 2),
    we = M(Y, !0);
  P(Y), P(w), P(x), je(Ie => {
    le(j, o.title), le(re, Ie), le(we, o.message)
  }, [() => Lz(o.createdAt)]), G(_, x), Lr()
}
Rn(["click"]);
var Bz = Dr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function Oz(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Bz();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var Nz = me('<button class="btn btn-sm btn-ghost"> </button>'),
  jz = me('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  Vz = me("<!> <!>", 1),
  qz = me('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  Uz = me('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  Zz = me("<p> </p>"),
  Gz = me("<!> <!>", 1);

function $z(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(!1),
    A = Qe(void 0),
    L = Qe(void 0),
    w = Qe(!1);
  var s = Gz(),
    B = gt(s);
  M_(B, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return f()
    },
    set open(K) {
      f(K)
    },
    children: (K, ee) => {
      var re = Uz(),
        de = gt(re),
        ne = M(de),
        Y = M(ne, !0);
      P(ne);
      var we = q(ne, 2);
      {
        var Ie = Be => {
          var Ee = Nz();
          Ee.__click = async () => {
            if (Jr.postNotificationMarkReadAll(), Mt.notificiationCount = 0, y(A))
              for (const Le of y(A)) Le.read = !0
          };
          var He = M(Ee, !0);
          P(Ee), je(Le => le(He, Le), [() => NM()]), G(Be, Ee)
        };
        Ae(we, Be => {
          Mt.notificiationCount !== 0 && Be(Ie)
        })
      }
      P(de);
      var ze = q(de, 2),
        Re = M(ze);
      {
        var ke = Be => {
          var Ee = Vz(),
            He = gt(Ee);
          ii(He, 17, () => y(A), pt => pt.id, (pt, Oe, Je) => {
            var bt = Jt(),
              We = gt(bt);
            {
              var Ue = Ge => {
                {
                  const Ve = _t => {
                    Oz(_t, {
                      class: "size-5"
                    })
                  };
                  let mt = ct(() => Fv()),
                    lt = ct(() => Bv()),
                    yt = ct(() => new Date(y(Oe).createdAt));
                  Fz(Ge, {
                    get title() {
                      return y(mt)
                    },
                    get message() {
                      return y(lt)
                    },
                    get createdAt() {
                      return y(yt)
                    },
                    onclick: () => {
                      te(w, !0)
                    },
                    get read() {
                      return y(Oe).read
                    },
                    set read(_t) {
                      y(Oe).read = _t
                    },
                    icon: Ve,
                    $$slots: {
                      icon: !0
                    }
                  })
                }
              };
              Ae(We, Ge => {
                y(Oe).type === "report_feedback" && Ge(Ue)
              })
            }
            G(pt, bt)
          });
          var Le = q(He, 2);
          {
            var it = pt => {
              var Oe = jz(),
                Je = M(Oe, !0);
              P(Oe), je(bt => le(Je, bt), [() => AM()]), G(pt, Oe)
            };
            Ae(Le, pt => {
              y(A).length === 0 && !y(x) && pt(it)
            })
          }
          G(Be, Ee)
        };
        Ae(Re, Be => {
          y(A) && Be(ke)
        })
      }
      var qe = q(Re, 2);
      {
        var $e = Be => {
          var Ee = qz();
          yi(Ee, () => He => {
            const Le = new IntersectionObserver(it => {
              it[0].isIntersecting && !y(x) && (te(x, !0), Jr.getNotificationPage(y(L)).then(pt => {
                te(A, [...y(A) ?? [], ...pt.notifications], !0), te(L, pt.nextCursor, !0);
                const Oe = pt.notifications.filter(Je => !Je.read).map(Je => Je.id);
                Oe.length > 0 && (Jr.postNotificationMarkRead(Oe), Mt.notificiationCount && (Mt.notificiationCount = Math.max(0, Oe.length - Oe.length)))
              }).catch(pt => {
                vr.error(pt.message)
              }).finally(() => {
                te(x, !1)
              }))
            });
            return Le.observe(He), () => {
              Le.disconnect()
            }
          }), G(Be, Ee)
        };
        Ae(qe, Be => {
          f() && (y(A) === void 0 || y(L) !== void 0) && Be($e)
        })
      }
      P(ze), je(Be => le(Y, Be), [() => PM()]), G(K, re)
    },
    $$slots: {
      default: !0
    }
  });
  var j = q(B, 2);
  {
    const K = re => {
      var de = Zz(),
        ne = M(de);
      P(de), je((Y, we) => le(ne, `${Y??""} ${we??""}`), [() => Bv(), () => FM()]), G(re, de)
    };
    let ee = ct(() => Fv());
    zz(j, {
      get title() {
        return y(ee)
      },
      get open() {
        return y(w)
      },
      set open(re) {
        te(w, re, !0)
      },
      message: K,
      $$slots: {
        message: !0
      }
    })
  }
  G(_, s), Lr()
}
Rn(["click"]);
var Hz = me("<canvas></canvas>");

function Sy(_, o) {
  zr(o, !0);
  let f = At(o, "width", 15, 0),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    A = ct(() => Math.ceil(o.fontSize)),
    L = Qe(null);
  const w = window.devicePixelRatio ?? 1,
    s = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    B = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  Zr(() => {
    const K = y(L).getContext("2d");
    K.textBaseline = "top", K.font = `${o.weight??"normal"} ${o.fontSize}px ${o.mono?B:s}`, K.fillStyle = o.color ?? "#394e6a", K.setTransform(w, 0, 0, w, 0, 0), K.clearRect(0, 0, f(), y(A)), K.fillText(o.value, 0, 0);
    const ee = K.measureText(o.value);
    f(Math.ceil(ee.actualBoundingBoxRight)), te(A, ee.actualBoundingBoxDescent)
  });
  var j = Hz();
  cr(j, () => ({
    width: f() * w,
    height: y(A) * w,
    style: `width: ${f()??""}px; height: ${y(A)??""}px`,
    ...x
  })), ko(j, K => te(L, K), () => y(L)), G(_, j), Lr()
}
var Wz = me('<span class="w-7 text-xs"> </span>'),
  Xz = me('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'),
  Yz = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  Kz = me('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');

function Cy(_, o) {
  zr(o, !0);
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
    x = Qe(0);
  var A = Kz();
  cr(A, () => ({
    ...f,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${o.class??""}`
  }));
  var L = M(A);
  Wh(L, {
    class: "size-6"
  });
  var w = q(L, 2),
    s = M(w),
    B = q(s);
  {
    var j = re => {
      const de = ct(() => `${Math.floor(o.charges)}/${Mt.data.charges.max}`);
      var ne = Xz(),
        Y = M(ne),
        we = M(Y);
      {
        let Re = ct(() => o.disabled ? "#394e6a33" : "#ffffff");
        Sy(we, {
          weight: 600,
          fontSize: 16,
          get value() {
            return y(de)
          },
          get color() {
            return y(Re)
          },
          get width() {
            return y(x)
          },
          set width(ke) {
            te(x, ke, !0)
          }
        })
      }
      P(Y);
      var Ie = q(Y, 2);
      {
        var ze = Re => {
          var ke = Wz(),
            qe = M(ke);
          P(ke), je($e => le(qe, `(${$e??""})`), [() => Lp(Mt.cooldown)]), G(Re, ke)
        };
        Ae(Ie, Re => {
          o.charges < Mt.data.charges.max && Mt.cooldown !== void 0 && Re(ze)
        })
      }
      P(ne), je(Re => Oc(Y, `width: ${Re??""}px`), [() => (Math.floor(y(x) / 5) + 1) * 5]), G(re, ne)
    };
    Ae(B, re => {
      o.charges !== void 0 && Mt.data && re(j)
    })
  }
  P(w);
  var K = q(w, 2);
  {
    var ee = re => {
      var de = Yz();
      G(re, de)
    };
    Ae(K, re => {
      o.loading && re(ee)
    })
  }
  P(A), je(re => le(s, `${re??""} `), [() => j0()]), G(_, A), Lr()
}
const Jz = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  Qz = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  eL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  tL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class rL {
  constructor(o) {
    Cr(this, "gm");
    Cr(this, "opacity", 1);
    Cr(this, "id", `paint-preview-${Math.random()}`);
    Cr(this, "tiles", new Map);
    this.input = o, this.gm = new us(this.input.tileSize)
  }
  place([o, f], x) {
    const {
      tile: A,
      pixel: L
    } = this.gm.latLonToTileAndPixel(o, f, this.input.tileZoom), w = this.getTileKey(A[0], A[1]);
    let s = this.tiles.get(w);
    if (!s) {
      const B = this.gm.tileBoundsLatLon(A[0], A[1], this.input.tileZoom),
        j = b_(B, !0),
        K = new nL({
          coordinates: j,
          id: `${this.id}-${w}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      K.addTo(this.input.map), this.tiles.set(w, K), s = K
    }
    s.place(L[0], this.input.tileSize - L[1] - 1, x)
  }
  clear() {
    const o = this.input.map;
    for (const f of this.tiles.values()) f.removeFrom(o), f.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(o, f) {
    this.clear(), this.place(o, f)
  }
  remove([o, f]) {
    const {
      tile: x,
      pixel: A
    } = this.gm.latLonToTileAndPixel(o, f, this.input.tileZoom), L = this.getTileKey(x[0], x[1]), w = this.tiles.get(L);
    w && w.remove(A[0], this.input.tileSize - A[1] - 1)
  }
  setCanvasOpacity(o) {
    this.opacity = o;
    for (const f of this.tiles.values()) f.setOpacity(o)
  }
  getTileKey(o, f) {
    return `${o},${f}`
  }
}
class nL {
  constructor(o) {
    Cr(this, "canvas");
    Cr(this, "maps", new Set);
    this.input = o;
    const f = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = f, this.canvas.height = f
  }
  place(o, f, x) {
    var w;
    const A = ((w = ma.colors) == null ? void 0 : w[x]) ?? ma.colors[0],
      L = this.canvas.getContext("2d");
    if (L) {
      const s = L.createImageData(1, 1),
        [B, j, K] = A.rgb,
        ee = x === 0 ? 0 : 255;
      s.data[0] = B, s.data[1] = j, s.data[2] = K, s.data[3] = ee, L.putImageData(s, o, f)
    }
  }
  remove(o, f) {
    const x = this.canvas.getContext("2d");
    x && x.clearRect(o, f, 1, 1)
  }
  addTo(o) {
    const f = this.input.id;
    o.getSource(f) || o.addSource(f, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), o.getLayer(f) || (o.addLayer({
      id: f,
      type: "raster",
      source: f,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && o.moveLayer(f, this.input.beforeLayerId)), this.maps.add(o)
  }
  removeFrom(o) {
    const {
      id: f
    } = this.input;
    o.getLayer(f) && o.removeLayer(f), o.getSource(f) && o.removeSource(f), this.maps.delete(o)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(o) {
    for (const f of this.maps.values()) f.setPaintProperty(this.input.id, "raster-opacity", o)
  }
}
var iL = Dr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function aL(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = iL();
  cr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...f
  })), G(_, x)
}
var oL = Dr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function sL(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = oL();
  cr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...f
  })), G(_, x)
}
var lL = me("<div><!></div>");

function pl(_, o) {
  zr(o, !0);
  var f = lL(),
    x = M(f);
  ai(x, () => o.children ?? oa), P(f), je(() => Or(f, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${o.class??""}`)), G(_, f), Lr()
}
var cL = me('<div class="confetti svelte-av71ki"></div>'),
  uL = me("<div></div>");

function A_(_, o) {
  zr(o, !0);
  const f = At(o, "size", 3, 10),
    x = At(o, "x", 19, () => [-.5, .5]),
    A = At(o, "y", 19, () => [.25, 1]),
    L = At(o, "duration", 3, 2e3),
    w = At(o, "infinite", 3, !1),
    s = At(o, "delay", 19, () => [0, 50]),
    B = At(o, "colorRange", 19, () => [0, 360]),
    j = At(o, "colorArray", 19, () => []),
    K = At(o, "amount", 3, 50),
    ee = At(o, "iterationCount", 3, 1),
    re = At(o, "fallDistance", 3, "100px"),
    de = At(o, "rounded", 3, !1),
    ne = At(o, "cone", 3, !1),
    Y = At(o, "noGravity", 3, !1),
    we = At(o, "xSpread", 3, .15),
    Ie = At(o, "destroyOnComplete", 3, !0),
    ze = At(o, "disableForReducedMotion", 3, !1);
  let Re = Qe(!1);
  Dn(() => {
    !Ie() || w() || typeof ee() == "string" || setTimeout(() => te(Re, !0), (L() + s()[1]) * ee())
  });

  function ke(He, Le) {
    return Math.random() * (Le - He) + He
  }

  function qe() {
    return j().length ? j()[Math.round(Math.random() * (j().length - 1))] : `hsl(${Math.round(ke(B()[0],B()[1]))}, 75%, 50%)`
  }
  var $e = Jt(),
    Be = gt($e);
  {
    var Ee = He => {
      var Le = uL();
      let it;
      ii(Le, 21, () => ({
        length: K()
      }), Hp, (pt, Oe) => {
        var Je = cL();
        je((bt, We, Ue, Ge, Ve, mt, lt, yt, _t, ut, Ut) => Oc(Je, `
        --color: ${bt??""};
        --skew: ${We??""}deg,${Ue??""}deg;
        --rotation-xyz: ${Ge??""}, ${Ve??""}, ${mt??""};
        --rotation-deg: ${lt??""}deg;
        --translate-y-multiplier: ${yt??""};
        --translate-x-multiplier: ${_t??""};
        --scale: ${ut??""};
        --transition-delay: ${Ut??""}ms;
        --transition-duration: ${w()?`calc(${L()}ms * var(--scale))`:`${L()}ms`};`), [qe, () => ke(-45, 45), () => ke(-45, 45), () => ke(-10, 10), () => ke(-10, 10), () => ke(-10, 10), () => ke(0, 360), () => ke(A()[0], A()[1]), () => ke(x()[0], x()[1]), () => .1 * ke(2, 10), () => ke(s()[0], s()[1])]), G(pt, Je)
      }), P(Le), je(() => {
        it = Or(Le, 1, "confetti-holder svelte-av71ki", null, it, {
          rounded: de(),
          cone: ne(),
          "no-gravity": Y(),
          "reduced-motion": ze()
        }), Oc(Le, `
    --fall-distance: ${re()??""};
    --size: ${f()??""}px;
    --x-spread: ${1-we()};
    --transition-iteration-count: ${(w()?"infinite":ee())??""};`)
      }), G(He, Le)
    };
    Ae(Be, He => {
      y(Re) || He(Ee)
    })
  }
  G(_, $e), Lr()
}
var hL = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  dL = me('<!> <span class="text-sm">Droplets</span>', 1),
  pL = me('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  fL = me('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'),
  mL = me('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function _L(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  const x = ct(() => ma.colors[o.colorIdx]),
    A = ct(() => {
      var de;
      return ((de = Mt.data) == null ? void 0 : de.droplets) ?? 0
    });
  let L = Qe(!1);
  const w = ct(() => (y(L), Mt.hasColor(o.colorIdx)));
  Dn(() => {
    const de = ne => {
      ne.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", de), () => document.removeEventListener("keydown", de)
  });
  const s = 100,
    B = ma.products[s];
  var j = mL(),
    K = M(j),
    ee = q(M(K), 2);
  {
    var re = de => {
      var ne = fL(),
        Y = M(ne),
        we = M(Y),
        Ie = M(we);
      Dp(Ie, {
        class: "size-6"
      });
      var ze = q(Ie, 4),
        Re = M(ze);
      z0(Re, {
        get value() {
          return y(A)
        }
      }), P(ze), P(we), bn(2), P(Y);
      var ke = q(Y, 2),
        qe = M(ke),
        $e = M(qe);
      P(qe);
      var Be = q(qe, 2),
        Ee = M(Be, !0);
      P(Be);
      var He = q(Be, 2),
        Le = M(He);
      let it;
      var pt = M(Le);
      pt.__click = async () => {
        try {
          te(L, !0), await Jr.purchase({
            id: s,
            amount: 1,
            variant: o.colorIdx
          }), await Mt.refresh(), Wi.notification1.play()
        } catch (Ve) {
          vr.error(Ve.message)
        } finally {
          te(L, !1)
        }
      };
      var Oe = M(pt);
      {
        var Je = Ve => {
          var mt = hL();
          G(Ve, mt)
        };
        Ae(Oe, Ve => {
          y(L) && Ve(Je)
        })
      }
      var bt = q(Oe, 2);
      {
        var We = Ve => {
            var mt = dL(),
              lt = gt(mt);
            Xp(lt, {
              class: "size-5"
            });
            var yt = q(lt);
            bn(), je(_t => le(yt, ` ${_t??""} `), [() => B.price.toLocaleString("en-US")]), G(Ve, mt)
          },
          Ue = Ve => {
            var mt = pL(),
              lt = gt(mt);
            Dp(lt, {
              class: "size-5"
            });
            var yt = q(lt, 2),
              _t = M(yt);
            A_(_t, {}), P(yt), G(Ve, mt)
          };
        Ae(bt, Ve => {
          y(w) ? Ve(Ue, !1) : Ve(We)
        })
      }
      P(pt), P(Le);
      var Ge = q(Le, 2);
      Ge.__click = () => f(!1), P(He), P(ke), P(ne), je(Ve => {
        Oc($e, `background: rgb(${y(x).rgb[0]} ${y(x).rgb[1]} ${y(x).rgb[2]})`), mr($e, "aria-label", y(x).name), le(Ee, y(x).name), mr(Le, "data-tip", Ve), it = Or(Le, 1, "", null, it, {
          tooltip: !y(w) && y(A) < B.price
        }), pt.disabled = y(A) < B.price || y(L) || y(w)
      }, [() => Jp()]), G(de, ne)
    };
    Ae(ee, de => {
      Mt.data && de(re)
    })
  }
  P(K), bn(2), P(j), yi(j, () => de => {
    Zr(() => {
      f() ? de.show() : de.close()
    })
  }), Un("close", j, () => f(!1)), G(_, j), Lr()
}
Rn(["click"]);
var t_ = function() {
  return t_ = Object.assign || function(o) {
    for (var f, x = 1, A = arguments.length; x < A; x++) {
      f = arguments[x];
      for (var L in f) Object.prototype.hasOwnProperty.call(f, L) && (o[L] = f[L])
    }
    return o
  }, t_.apply(this, arguments)
};

function Eo(_, o, f, x) {
  function A(L) {
    return L instanceof f ? L : new f(function(w) {
      w(L)
    })
  }
  return new(f || (f = Promise))(function(L, w) {
    function s(K) {
      try {
        j(x.next(K))
      } catch (ee) {
        w(ee)
      }
    }

    function B(K) {
      try {
        j(x.throw(K))
      } catch (ee) {
        w(ee)
      }
    }

    function j(K) {
      K.done ? L(K.value) : A(K.value).then(s, B)
    }
    j((x = x.apply(_, o || [])).next())
  })
}

function zo(_, o) {
  var f = {
      label: 0,
      sent: function() {
        if (L[0] & 1) throw L[1];
        return L[1]
      },
      trys: [],
      ops: []
    },
    x, A, L, w = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return w.next = s(0), w.throw = s(1), w.return = s(2), typeof Symbol == "function" && (w[Symbol.iterator] = function() {
    return this
  }), w;

  function s(j) {
    return function(K) {
      return B([j, K])
    }
  }

  function B(j) {
    if (x) throw new TypeError("Generator is already executing.");
    for (; w && (w = 0, j[0] && (f = 0)), f;) try {
      if (x = 1, A && (L = j[0] & 2 ? A.return : j[0] ? A.throw || ((L = A.return) && L.call(A), 0) : A.next) && !(L = L.call(A, j[1])).done) return L;
      switch (A = 0, L && (j = [j[0] & 2, L.value]), j[0]) {
        case 0:
        case 1:
          L = j;
          break;
        case 4:
          return f.label++, {
            value: j[1],
            done: !1
          };
        case 5:
          f.label++, A = j[1], j = [0];
          continue;
        case 7:
          j = f.ops.pop(), f.trys.pop();
          continue;
        default:
          if (L = f.trys, !(L = L.length > 0 && L[L.length - 1]) && (j[0] === 6 || j[0] === 2)) {
            f = 0;
            continue
          }
          if (j[0] === 3 && (!L || j[1] > L[0] && j[1] < L[3])) {
            f.label = j[1];
            break
          }
          if (j[0] === 6 && f.label < L[1]) {
            f.label = L[1], L = j;
            break
          }
          if (L && f.label < L[2]) {
            f.label = L[2], f.ops.push(j);
            break
          }
          L[2] && f.ops.pop(), f.trys.pop();
          continue
      }
      j = o.call(_, f)
    } catch (K) {
      j = [6, K], A = 0
    } finally {
      x = L = 0
    }
    if (j[0] & 5) throw j[1];
    return {
      value: j[0] ? j[1] : void 0,
      done: !0
    }
  }
}

function Py(_, o, f) {
  if (f || arguments.length === 2)
    for (var x = 0, A = o.length, L; x < A; x++)(L || !(x in o)) && (L || (L = Array.prototype.slice.call(o, 0, x)), L[x] = o[x]);
  return _.concat(L || Array.prototype.slice.call(o))
}
var Iy = "4.6.2";

function Fp(_, o) {
  return new Promise(function(f) {
    return setTimeout(f, _, o)
  })
}

function gL() {
  return new Promise(function(_) {
    var o = new MessageChannel;
    o.port1.onmessage = function() {
      return _()
    }, o.port2.postMessage(null)
  })
}

function vL(_, o) {
  o === void 0 && (o = 1 / 0);
  var f = window.requestIdleCallback;
  return f ? new Promise(function(x) {
    return f.call(window, function() {
      return x()
    }, {
      timeout: o
    })
  }) : Fp(Math.min(_, o))
}

function My(_) {
  return !!_ && typeof _.then == "function"
}

function Jv(_, o) {
  try {
    var f = _();
    My(f) ? f.then(function(x) {
      return o(!0, x)
    }, function(x) {
      return o(!1, x)
    }) : o(!0, f)
  } catch (x) {
    o(!1, x)
  }
}

function Qv(_, o, f) {
  return f === void 0 && (f = 16), Eo(this, void 0, void 0, function() {
    var x, A, L, w;
    return zo(this, function(s) {
      switch (s.label) {
        case 0:
          x = Array(_.length), A = Date.now(), L = 0, s.label = 1;
        case 1:
          return L < _.length ? (x[L] = o(_[L], L), w = Date.now(), w >= A + f ? (A = w, [4, gL()]) : [3, 3]) : [3, 4];
        case 2:
          s.sent(), s.label = 3;
        case 3:
          return ++L, [3, 1];
        case 4:
          return [2, x]
      }
    })
  })
}

function oh(_) {
  return _.then(void 0, function() {}), _
}

function yL(_, o) {
  for (var f = 0, x = _.length; f < x; ++f)
    if (_[f] === o) return !0;
  return !1
}

function xL(_, o) {
  return !yL(_, o)
}

function k_(_) {
  return parseInt(_)
}

function po(_) {
  return parseFloat(_)
}

function ns(_, o) {
  return typeof _ == "number" && isNaN(_) ? o : _
}

function _a(_) {
  return _.reduce(function(o, f) {
    return o + (f ? 1 : 0)
  }, 0)
}

function Ay(_, o) {
  if (o === void 0 && (o = 1), Math.abs(o) >= 1) return Math.round(_ / o) * o;
  var f = 1 / o;
  return Math.round(_ * f) / f
}

function bL(_) {
  for (var o, f, x = "Unexpected syntax '".concat(_, "'"), A = /^\s*([a-z-]*)(.*)$/i.exec(_), L = A[1] || void 0, w = {}, s = /([.:#][\w-]+|\[.+?\])/gi, B = function(re, de) {
      w[re] = w[re] || [], w[re].push(de)
    };;) {
    var j = s.exec(A[2]);
    if (!j) break;
    var K = j[0];
    switch (K[0]) {
      case ".":
        B("class", K.slice(1));
        break;
      case "#":
        B("id", K.slice(1));
        break;
      case "[": {
        var ee = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(K);
        if (ee) B(ee[1], (f = (o = ee[4]) !== null && o !== void 0 ? o : ee[5]) !== null && f !== void 0 ? f : "");
        else throw new Error(x);
        break
      }
      default:
        throw new Error(x)
    }
  }
  return [L, w]
}

function wL(_) {
  for (var o = new Uint8Array(_.length), f = 0; f < _.length; f++) {
    var x = _.charCodeAt(f);
    if (x > 127) return new TextEncoder().encode(_);
    o[f] = x
  }
  return o
}

function ks(_, o) {
  var f = _[0] >>> 16,
    x = _[0] & 65535,
    A = _[1] >>> 16,
    L = _[1] & 65535,
    w = o[0] >>> 16,
    s = o[0] & 65535,
    B = o[1] >>> 16,
    j = o[1] & 65535,
    K = 0,
    ee = 0,
    re = 0,
    de = 0;
  de += L + j, re += de >>> 16, de &= 65535, re += A + B, ee += re >>> 16, re &= 65535, ee += x + s, K += ee >>> 16, ee &= 65535, K += f + w, K &= 65535, _[0] = K << 16 | ee, _[1] = re << 16 | de
}

function Ga(_, o) {
  var f = _[0] >>> 16,
    x = _[0] & 65535,
    A = _[1] >>> 16,
    L = _[1] & 65535,
    w = o[0] >>> 16,
    s = o[0] & 65535,
    B = o[1] >>> 16,
    j = o[1] & 65535,
    K = 0,
    ee = 0,
    re = 0,
    de = 0;
  de += L * j, re += de >>> 16, de &= 65535, re += A * j, ee += re >>> 16, re &= 65535, re += L * B, ee += re >>> 16, re &= 65535, ee += x * j, K += ee >>> 16, ee &= 65535, ee += A * B, K += ee >>> 16, ee &= 65535, ee += L * s, K += ee >>> 16, ee &= 65535, K += f * j + x * B + A * s + L * w, K &= 65535, _[0] = K << 16 | ee, _[1] = re << 16 | de
}

function Sc(_, o) {
  var f = _[0];
  o %= 64, o === 32 ? (_[0] = _[1], _[1] = f) : o < 32 ? (_[0] = f << o | _[1] >>> 32 - o, _[1] = _[1] << o | f >>> 32 - o) : (o -= 32, _[0] = _[1] << o | f >>> 32 - o, _[1] = f << o | _[1] >>> 32 - o)
}

function La(_, o) {
  o %= 64, o !== 0 && (o < 32 ? (_[0] = _[1] >>> 32 - o, _[1] = _[1] << o) : (_[0] = _[1] << o - 32, _[1] = 0))
}

function ci(_, o) {
  _[0] ^= o[0], _[1] ^= o[1]
}
var TL = [4283543511, 3981806797],
  SL = [3301882366, 444984403];

function e0(_) {
  var o = [0, _[0] >>> 1];
  ci(_, o), Ga(_, TL), o[1] = _[0] >>> 1, ci(_, o), Ga(_, SL), o[1] = _[0] >>> 1, ci(_, o)
}
var yp = [2277735313, 289559509],
  xp = [1291169091, 658871167],
  t0 = [0, 5],
  CL = [0, 1390208809],
  PL = [0, 944331445];

function IL(_, o) {
  var f = wL(_);
  o = o || 0;
  var x = [0, f.length],
    A = x[1] % 16,
    L = x[1] - A,
    w = [0, o],
    s = [0, o],
    B = [0, 0],
    j = [0, 0],
    K;
  for (K = 0; K < L; K = K + 16) B[0] = f[K + 4] | f[K + 5] << 8 | f[K + 6] << 16 | f[K + 7] << 24, B[1] = f[K] | f[K + 1] << 8 | f[K + 2] << 16 | f[K + 3] << 24, j[0] = f[K + 12] | f[K + 13] << 8 | f[K + 14] << 16 | f[K + 15] << 24, j[1] = f[K + 8] | f[K + 9] << 8 | f[K + 10] << 16 | f[K + 11] << 24, Ga(B, yp), Sc(B, 31), Ga(B, xp), ci(w, B), Sc(w, 27), ks(w, s), Ga(w, t0), ks(w, CL), Ga(j, xp), Sc(j, 33), Ga(j, yp), ci(s, j), Sc(s, 31), ks(s, w), Ga(s, t0), ks(s, PL);
  B[0] = 0, B[1] = 0, j[0] = 0, j[1] = 0;
  var ee = [0, 0];
  switch (A) {
    case 15:
      ee[1] = f[K + 14], La(ee, 48), ci(j, ee);
    case 14:
      ee[1] = f[K + 13], La(ee, 40), ci(j, ee);
    case 13:
      ee[1] = f[K + 12], La(ee, 32), ci(j, ee);
    case 12:
      ee[1] = f[K + 11], La(ee, 24), ci(j, ee);
    case 11:
      ee[1] = f[K + 10], La(ee, 16), ci(j, ee);
    case 10:
      ee[1] = f[K + 9], La(ee, 8), ci(j, ee);
    case 9:
      ee[1] = f[K + 8], ci(j, ee), Ga(j, xp), Sc(j, 33), Ga(j, yp), ci(s, j);
    case 8:
      ee[1] = f[K + 7], La(ee, 56), ci(B, ee);
    case 7:
      ee[1] = f[K + 6], La(ee, 48), ci(B, ee);
    case 6:
      ee[1] = f[K + 5], La(ee, 40), ci(B, ee);
    case 5:
      ee[1] = f[K + 4], La(ee, 32), ci(B, ee);
    case 4:
      ee[1] = f[K + 3], La(ee, 24), ci(B, ee);
    case 3:
      ee[1] = f[K + 2], La(ee, 16), ci(B, ee);
    case 2:
      ee[1] = f[K + 1], La(ee, 8), ci(B, ee);
    case 1:
      ee[1] = f[K], ci(B, ee), Ga(B, yp), Sc(B, 31), Ga(B, xp), ci(w, B)
  }
  return ci(w, x), ci(s, x), ks(w, s), ks(s, w), e0(w), e0(s), ks(w, s), ks(s, w), ("00000000" + (w[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (w[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
}

function ML(_) {
  var o;
  return t_({
    name: _.name,
    message: _.message,
    stack: (o = _.stack) === null || o === void 0 ? void 0 : o.split(`
`)
  }, _)
}

function AL(_) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(_))
}

function kL(_) {
  return typeof _ != "function"
}

function EL(_, o) {
  var f = oh(new Promise(function(x) {
    var A = Date.now();
    Jv(_.bind(null, o), function() {
      for (var L = [], w = 0; w < arguments.length; w++) L[w] = arguments[w];
      var s = Date.now() - A;
      if (!L[0]) return x(function() {
        return {
          error: L[1],
          duration: s
        }
      });
      var B = L[1];
      if (kL(B)) return x(function() {
        return {
          value: B,
          duration: s
        }
      });
      x(function() {
        return new Promise(function(j) {
          var K = Date.now();
          Jv(B, function() {
            for (var ee = [], re = 0; re < arguments.length; re++) ee[re] = arguments[re];
            var de = s + Date.now() - K;
            if (!ee[0]) return j({
              error: ee[1],
              duration: de
            });
            j({
              value: ee[1],
              duration: de
            })
          })
        })
      })
    })
  }));
  return function() {
    return f.then(function(A) {
      return A()
    })
  }
}

function zL(_, o, f, x) {
  var A = Object.keys(_).filter(function(w) {
      return xL(f, w)
    }),
    L = oh(Qv(A, function(w) {
      return EL(_[w], o)
    }, x));
  return function() {
    return Eo(this, void 0, void 0, function() {
      var s, B, j, K, ee;
      return zo(this, function(re) {
        switch (re.label) {
          case 0:
            return [4, L];
          case 1:
            return s = re.sent(), [4, Qv(s, function(de) {
              return oh(de())
            }, x)];
          case 2:
            return B = re.sent(), [4, Promise.all(B)];
          case 3:
            for (j = re.sent(), K = {}, ee = 0; ee < A.length; ++ee) K[A[ee]] = j[ee];
            return [2, K]
        }
      })
    })
  }
}

function ky() {
  var _ = window,
    o = navigator;
  return _a(["MSCSSMatrix" in _, "msSetImmediate" in _, "msIndexedDB" in _, "msMaxTouchPoints" in o, "msPointerEnabled" in o]) >= 4
}

function LL() {
  var _ = window,
    o = navigator;
  return _a(["msWriteProfilerMark" in _, "MSStream" in _, "msLaunchUri" in o, "msSaveBlob" in o]) >= 3 && !ky()
}

function Yh() {
  var _ = window,
    o = navigator;
  return _a(["webkitPersistentStorage" in o, "webkitTemporaryStorage" in o, (o.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in _, "BatteryManager" in _, "webkitMediaStream" in _, "webkitSpeechGrammar" in _]) >= 5
}

function go() {
  var _ = window,
    o = navigator;
  return _a(["ApplePayError" in _, "CSSPrimitiveValue" in _, "Counter" in _, o.vendor.indexOf("Apple") === 0, "RGBColor" in _, "WebKitMediaKeys" in _]) >= 4
}

function E_() {
  var _ = window,
    o = _.HTMLElement,
    f = _.Document;
  return _a(["safari" in _, !("ongestureend" in _), !("TouchEvent" in _), !("orientation" in _), o && !("autocapitalize" in o.prototype), f && "pointerLockElement" in f.prototype]) >= 4
}

function Kh() {
  var _ = window;
  return AL(_.print) && String(_.browser) === "[object WebPageNamespace]"
}

function Ey() {
  var _, o, f = window;
  return _a(["buildID" in navigator, "MozAppearance" in ((o = (_ = document.documentElement) === null || _ === void 0 ? void 0 : _.style) !== null && o !== void 0 ? o : {}), "onmozfullscreenchange" in f, "mozInnerScreenX" in f, "CSSMozDocumentRule" in f, "CanvasCaptureMediaStream" in f]) >= 4
}

function DL() {
  var _ = window;
  return _a([!("MediaSettingsRange" in _), "RTCEncodedAudioFrame" in _, "" + _.Intl == "[object Intl]", "" + _.Reflect == "[object Reflect]"]) >= 3
}

function RL() {
  var _ = window,
    o = _.URLPattern;
  return _a(["union" in Set.prototype, "Iterator" in _, o && "hasRegExpGroups" in o.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function FL() {
  var _ = window;
  return _a(["DOMRectList" in _, "RTCPeerConnectionIceEvent" in _, "SVGGeometryElement" in _, "ontransitioncancel" in _]) >= 3
}

function Jh() {
  var _ = window,
    o = navigator,
    f = _.CSS,
    x = _.HTMLButtonElement;
  return _a([!("getStorageUpdates" in o), x && "popover" in x.prototype, "CSSCounterStyleRule" in _, f.supports("font-size-adjust: ex-height 0.5"), f.supports("text-transform: full-width")]) >= 4
}

function BL() {
  if (navigator.platform === "iPad") return !0;
  var _ = screen,
    o = _.width / _.height;
  return _a(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, o > .65 && o < 1.53]) >= 2
}

function OL() {
  var _ = document;
  return _.fullscreenElement || _.msFullscreenElement || _.mozFullScreenElement || _.webkitFullscreenElement || null
}

function NL() {
  var _ = document;
  return (_.exitFullscreen || _.msExitFullscreen || _.mozCancelFullScreen || _.webkitExitFullscreen).call(_)
}

function z_() {
  var _ = Yh(),
    o = Ey(),
    f = window,
    x = navigator,
    A = "connection";
  return _ ? _a([!("SharedWorker" in f), x[A] && "ontypechange" in x[A], !("sinkId" in new Audio)]) >= 2 : o ? _a(["onorientationchange" in f, "orientation" in f, /android/i.test(x.appVersion)]) >= 2 : !1
}

function jL() {
  var _ = navigator,
    o = window,
    f = Audio.prototype,
    x = o.visualViewport;
  return _a(["srLatency" in f, "srChannelCount" in f, "devicePosture" in _, x && "segments" in x, "getTextInformation" in Image.prototype]) >= 3
}

function VL() {
  return ZL() ? -4 : qL()
}

function qL() {
  var _ = window,
    o = _.OfflineAudioContext || _.webkitOfflineAudioContext;
  if (!o) return -2;
  if (UL()) return -1;
  var f = 4500,
    x = 5e3,
    A = new o(1, x, 44100),
    L = A.createOscillator();
  L.type = "triangle", L.frequency.value = 1e4;
  var w = A.createDynamicsCompressor();
  w.threshold.value = -50, w.knee.value = 40, w.ratio.value = 12, w.attack.value = 0, w.release.value = .25, L.connect(w), w.connect(A.destination), L.start(0);
  var s = GL(A),
    B = s[0],
    j = s[1],
    K = oh(B.then(function(ee) {
      return $L(ee.getChannelData(0).subarray(f))
    }, function(ee) {
      if (ee.name === "timeout" || ee.name === "suspended") return -3;
      throw ee
    }));
  return function() {
    return j(), K
  }
}

function UL() {
  return go() && !E_() && !FL()
}

function ZL() {
  return go() && Jh() && Kh() || Yh() && jL() && RL()
}

function GL(_) {
  var o = 3,
    f = 500,
    x = 500,
    A = 5e3,
    L = function() {},
    w = new Promise(function(s, B) {
      var j = !1,
        K = 0,
        ee = 0;
      _.oncomplete = function(ne) {
        return s(ne.renderedBuffer)
      };
      var re = function() {
          setTimeout(function() {
            return B(r0("timeout"))
          }, Math.min(x, ee + A - Date.now()))
        },
        de = function() {
          try {
            var ne = _.startRendering();
            switch (My(ne) && oh(ne), _.state) {
              case "running":
                ee = Date.now(), j && re();
                break;
              case "suspended":
                document.hidden || K++, j && K >= o ? B(r0("suspended")) : setTimeout(de, f);
                break
            }
          } catch (Y) {
            B(Y)
          }
        };
      de(), L = function() {
        j || (j = !0, ee > 0 && re())
      }
    });
  return [w, L]
}

function $L(_) {
  for (var o = 0, f = 0; f < _.length; ++f) o += Math.abs(_[f]);
  return o
}

function r0(_) {
  var o = new Error(_);
  return o.name = _, o
}

function zy(_, o, f) {
  var x, A, L;
  return f === void 0 && (f = 50), Eo(this, void 0, void 0, function() {
    var w, s;
    return zo(this, function(B) {
      switch (B.label) {
        case 0:
          w = document, B.label = 1;
        case 1:
          return w.body ? [3, 3] : [4, Fp(f)];
        case 2:
          return B.sent(), [3, 1];
        case 3:
          s = w.createElement("iframe"), B.label = 4;
        case 4:
          return B.trys.push([4, , 10, 11]), [4, new Promise(function(j, K) {
            var ee = !1,
              re = function() {
                ee = !0, j()
              },
              de = function(we) {
                ee = !0, K(we)
              };
            s.onload = re, s.onerror = de;
            var ne = s.style;
            ne.setProperty("display", "block", "important"), ne.position = "absolute", ne.top = "0", ne.left = "0", ne.visibility = "hidden", o && "srcdoc" in s ? s.srcdoc = o : s.src = "about:blank", w.body.appendChild(s);
            var Y = function() {
              var we, Ie;
              ee || (((Ie = (we = s.contentWindow) === null || we === void 0 ? void 0 : we.document) === null || Ie === void 0 ? void 0 : Ie.readyState) === "complete" ? re() : setTimeout(Y, 10))
            };
            Y()
          })];
        case 5:
          B.sent(), B.label = 6;
        case 6:
          return !((A = (x = s.contentWindow) === null || x === void 0 ? void 0 : x.document) === null || A === void 0) && A.body ? [3, 8] : [4, Fp(f)];
        case 7:
          return B.sent(), [3, 6];
        case 8:
          return [4, _(s, s.contentWindow)];
        case 9:
          return [2, B.sent()];
        case 10:
          return (L = s.parentNode) === null || L === void 0 || L.removeChild(s), [7];
        case 11:
          return [2]
      }
    })
  })
}

function HL(_) {
  for (var o = bL(_), f = o[0], x = o[1], A = document.createElement(f ?? "div"), L = 0, w = Object.keys(x); L < w.length; L++) {
    var s = w[L],
      B = x[s].join(" ");
    s === "style" ? WL(A.style, B) : A.setAttribute(s, B)
  }
  return A
}

function WL(_, o) {
  for (var f = 0, x = o.split(";"); f < x.length; f++) {
    var A = x[f],
      L = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(A);
    if (L) {
      var w = L[1],
        s = L[2],
        B = L[4];
      _.setProperty(w, s, B || "")
    }
  }
}

function XL() {
  for (var _ = window;;) {
    var o = _.parent;
    if (!o || o === _) return !1;
    try {
      if (o.location.origin !== _.location.origin) return !0
    } catch (f) {
      if (f instanceof Error && f.name === "SecurityError") return !0;
      throw f
    }
    _ = o
  }
}
var YL = "mmMwWLliI0O&1",
  KL = "48px",
  Cc = ["monospace", "sans-serif", "serif"],
  n0 = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function JL() {
  var _ = this;
  return zy(function(o, f) {
    var x = f.document;
    return Eo(_, void 0, void 0, function() {
      var A, L, w, s, B, j, K, ee, re, de, ne, Y;
      return zo(this, function(we) {
        for (A = x.body, A.style.fontSize = KL, L = x.createElement("div"), L.style.setProperty("visibility", "hidden", "important"), w = {}, s = {}, B = function(Ie) {
            var ze = x.createElement("span"),
              Re = ze.style;
            return Re.position = "absolute", Re.top = "0", Re.left = "0", Re.fontFamily = Ie, ze.textContent = YL, L.appendChild(ze), ze
          }, j = function(Ie, ze) {
            return B("'".concat(Ie, "',").concat(ze))
          }, K = function() {
            return Cc.map(B)
          }, ee = function() {
            for (var Ie = {}, ze = function($e) {
                Ie[$e] = Cc.map(function(Be) {
                  return j($e, Be)
                })
              }, Re = 0, ke = n0; Re < ke.length; Re++) {
              var qe = ke[Re];
              ze(qe)
            }
            return Ie
          }, re = function(Ie) {
            return Cc.some(function(ze, Re) {
              return Ie[Re].offsetWidth !== w[ze] || Ie[Re].offsetHeight !== s[ze]
            })
          }, de = K(), ne = ee(), A.appendChild(L), Y = 0; Y < Cc.length; Y++) w[Cc[Y]] = de[Y].offsetWidth, s[Cc[Y]] = de[Y].offsetHeight;
        return [2, n0.filter(function(Ie) {
          return re(ne[Ie])
        })]
      })
    })
  })
}

function QL() {
  var _ = navigator.plugins;
  if (_) {
    for (var o = [], f = 0; f < _.length; ++f) {
      var x = _[f];
      if (x) {
        for (var A = [], L = 0; L < x.length; ++L) {
          var w = x[L];
          A.push({
            type: w.type,
            suffixes: w.suffixes
          })
        }
        o.push({
          name: x.name,
          description: x.description,
          mimeTypes: A
        })
      }
    }
    return o
  }
}

function eD() {
  return tD(lD())
}

function tD(_) {
  var o, f = !1,
    x, A, L = rD(),
    w = L[0],
    s = L[1];
  return nD(w, s) ? (f = iD(s), _ ? x = A = "skipped" : (o = aD(w, s), x = o[0], A = o[1])) : x = A = "unsupported", {
    winding: f,
    geometry: x,
    text: A
  }
}

function rD() {
  var _ = document.createElement("canvas");
  return _.width = 1, _.height = 1, [_, _.getContext("2d")]
}

function nD(_, o) {
  return !!(o && _.toDataURL)
}

function iD(_) {
  return _.rect(0, 0, 10, 10), _.rect(2, 2, 6, 6), !_.isPointInPath(5, 5, "evenodd")
}

function aD(_, o) {
  oD(_, o);
  var f = mm(_),
    x = mm(_);
  if (f !== x) return ["unstable", "unstable"];
  sD(_, o);
  var A = mm(_);
  return [A, f]
}

function oD(_, o) {
  _.width = 240, _.height = 60, o.textBaseline = "alphabetic", o.fillStyle = "#f60", o.fillRect(100, 1, 62, 20), o.fillStyle = "#069", o.font = '11pt "Times New Roman"';
  var f = "Cwm fjordbank gly ".concat("üòÉ");
  o.fillText(f, 2, 15), o.fillStyle = "rgba(102, 204, 0, 0.2)", o.font = "18pt Arial", o.fillText(f, 4, 45)
}

function sD(_, o) {
  _.width = 122, _.height = 110, o.globalCompositeOperation = "multiply";
  for (var f = 0, x = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; f < x.length; f++) {
    var A = x[f],
      L = A[0],
      w = A[1],
      s = A[2];
    o.fillStyle = L, o.beginPath(), o.arc(w, s, 40, 0, Math.PI * 2, !0), o.closePath(), o.fill()
  }
  o.fillStyle = "#f9c", o.arc(60, 60, 60, 0, Math.PI * 2, !0), o.arc(60, 60, 20, 0, Math.PI * 2, !0), o.fill("evenodd")
}

function mm(_) {
  return _.toDataURL()
}

function lD() {
  return go() && Jh() && Kh()
}

function cD() {
  var _ = navigator,
    o = 0,
    f;
  _.maxTouchPoints !== void 0 ? o = k_(_.maxTouchPoints) : _.msMaxTouchPoints !== void 0 && (o = _.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), f = !0
  } catch {
    f = !1
  }
  var x = "ontouchstart" in window;
  return {
    maxTouchPoints: o,
    touchEvent: f,
    touchStart: x
  }
}

function uD() {
  return navigator.oscpu
}

function hD() {
  var _ = navigator,
    o = [],
    f = _.language || _.userLanguage || _.browserLanguage || _.systemLanguage;
  if (f !== void 0 && o.push([f]), Array.isArray(_.languages)) Yh() && DL() || o.push(_.languages);
  else if (typeof _.languages == "string") {
    var x = _.languages;
    x && o.push(x.split(","))
  }
  return o
}

function dD() {
  return window.screen.colorDepth
}

function pD() {
  return ns(po(navigator.deviceMemory), void 0)
}

function fD() {
  if (!(go() && Jh() && Kh())) return mD()
}

function mD() {
  var _ = screen,
    o = function(x) {
      return ns(k_(x), null)
    },
    f = [o(_.width), o(_.height)];
  return f.sort().reverse(), f
}
var _D = 2500,
  gD = 10,
  kp, _m;

function vD() {
  if (_m === void 0) {
    var _ = function() {
      var o = r_();
      n_(o) ? _m = setTimeout(_, _D) : (kp = o, _m = void 0)
    };
    _()
  }
}

function yD() {
  var _ = this;
  return vD(),
    function() {
      return Eo(_, void 0, void 0, function() {
        var o;
        return zo(this, function(f) {
          switch (f.label) {
            case 0:
              return o = r_(), n_(o) ? kp ? [2, Py([], kp, !0)] : OL() ? [4, NL()] : [3, 2] : [3, 2];
            case 1:
              f.sent(), o = r_(), f.label = 2;
            case 2:
              return n_(o) || (kp = o), [2, o]
          }
        })
      })
    }
}

function xD() {
  var _ = this;
  if (go() && Jh() && Kh()) return function() {
    return Promise.resolve(void 0)
  };
  var o = yD();
  return function() {
    return Eo(_, void 0, void 0, function() {
      var f, x;
      return zo(this, function(A) {
        switch (A.label) {
          case 0:
            return [4, o()];
          case 1:
            return f = A.sent(), x = function(L) {
              return L === null ? null : Ay(L, gD)
            }, [2, [x(f[0]), x(f[1]), x(f[2]), x(f[3])]]
        }
      })
    })
  }
}

function r_() {
  var _ = screen;
  return [ns(po(_.availTop), null), ns(po(_.width) - po(_.availWidth) - ns(po(_.availLeft), 0), null), ns(po(_.height) - po(_.availHeight) - ns(po(_.availTop), 0), null), ns(po(_.availLeft), null)]
}

function n_(_) {
  for (var o = 0; o < 4; ++o)
    if (_[o]) return !1;
  return !0
}

function bD() {
  return ns(k_(navigator.hardwareConcurrency), void 0)
}

function wD() {
  var _, o = (_ = window.Intl) === null || _ === void 0 ? void 0 : _.DateTimeFormat;
  if (o) {
    var f = new o().resolvedOptions().timeZone;
    if (f) return f
  }
  var x = -TD();
  return "UTC".concat(x >= 0 ? "+" : "").concat(x)
}

function TD() {
  var _ = new Date().getFullYear();
  return Math.max(po(new Date(_, 0, 1).getTimezoneOffset()), po(new Date(_, 6, 1).getTimezoneOffset()))
}

function SD() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function CD() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function PD() {
  if (!(ky() || LL())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function ID() {
  return !!window.openDatabase
}

function MD() {
  return navigator.cpuClass
}

function AD() {
  var _ = navigator.platform;
  return _ === "MacIntel" && go() && !E_() ? BL() ? "iPad" : "iPhone" : _
}

function kD() {
  return navigator.vendor || ""
}

function ED() {
  for (var _ = [], o = 0, f = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; o < f.length; o++) {
    var x = f[o],
      A = window[x];
    A && typeof A == "object" && _.push(x)
  }
  return _.sort()
}

function zD() {
  var _ = document;
  try {
    _.cookie = "cookietest=1; SameSite=Strict;";
    var o = _.cookie.indexOf("cookietest=") !== -1;
    return _.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", o
  } catch {
    return !1
  }
}

function LD() {
  var _ = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', _("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", _("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", _("LnNwb25zb3JpdA=="), ".ylamainos", _("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", _("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", _("LmhlYWRlci1ibG9ja2VkLWFk"), _("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", _("I2FkXzMwMFgyNTA="), _("I2Jhbm5lcmZsb2F0MjI="), _("I2NhbXBhaWduLWJhbm5lcg=="), _("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [_("LlppX2FkX2FfSA=="), _("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", _("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), _("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", _("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", _("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", _("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), _("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), _("LmFkZ29vZ2xl"), _("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [_("YW1wLWF1dG8tYWRz"), _("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", _("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [_("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), _("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', _("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [_("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), _("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", _("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), _("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), _("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", _("I3Jla2xhbWk="), _("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), _("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), _("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [_("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", _("LndpZGdldF9wb19hZHNfd2lkZ2V0"), _("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", _("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [_("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), _("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", _("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", _("I3Jla2xhbW5pLWJveA=="), _("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", _("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [_("I2FkdmVydGVudGll"), _("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", _("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", _("LnNwb25zb3JsaW5rZ3J1ZW4="), _("I3dlcmJ1bmdza3k="), _("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), _("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [_("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", _("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [_("LnJla2xhbW9zX3RhcnBhcw=="), _("LnJla2xhbW9zX251b3JvZG9z"), _("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), _("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), _("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [_("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [_("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), _("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", _("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [_("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), _("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), _("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", _("LmFkX19tYWlu"), _("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [_("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [_("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), _("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [_("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), _("I2xpdmVyZUFkV3JhcHBlcg=="), _("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), _("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [_("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", _("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), _("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), _("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [_("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), _("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), _("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", _("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), _("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), _("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), _("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [_("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), _("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), _("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), _("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [_("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), _("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), _("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", _("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), _("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", _("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function DD(_) {
  var o = _ === void 0 ? {} : _,
    f = o.debug;
  return Eo(this, void 0, void 0, function() {
    var x, A, L, w, s, B;
    return zo(this, function(j) {
      switch (j.label) {
        case 0:
          return RD() ? (x = LD(), A = Object.keys(x), L = (B = []).concat.apply(B, A.map(function(K) {
            return x[K]
          })), [4, FD(L)]) : [2, void 0];
        case 1:
          return w = j.sent(), f && BD(x, w), s = A.filter(function(K) {
            var ee = x[K],
              re = _a(ee.map(function(de) {
                return w[de]
              }));
            return re > ee.length * .6
          }), s.sort(), [2, s]
      }
    })
  })
}

function RD() {
  return go() || z_()
}

function FD(_) {
  var o;
  return Eo(this, void 0, void 0, function() {
    var f, x, A, L, B, w, s, B;
    return zo(this, function(j) {
      switch (j.label) {
        case 0:
          for (f = document, x = f.createElement("div"), A = new Array(_.length), L = {}, i0(x), B = 0; B < _.length; ++B) w = HL(_[B]), w.tagName === "DIALOG" && w.show(), s = f.createElement("div"), i0(s), s.appendChild(w), x.appendChild(s), A[B] = w;
          j.label = 1;
        case 1:
          return f.body ? [3, 3] : [4, Fp(50)];
        case 2:
          return j.sent(), [3, 1];
        case 3:
          f.body.appendChild(x);
          try {
            for (B = 0; B < _.length; ++B) A[B].offsetParent || (L[_[B]] = !0)
          } finally {
            (o = x.parentNode) === null || o === void 0 || o.removeChild(x)
          }
          return [2, L]
      }
    })
  })
}

function i0(_) {
  _.style.setProperty("visibility", "hidden", "important"), _.style.setProperty("display", "block", "important")
}

function BD(_, o) {
  for (var f = "DOM blockers debug:\n```", x = 0, A = Object.keys(_); x < A.length; x++) {
    var L = A[x];
    f += `
`.concat(L, ":");
    for (var w = 0, s = _[L]; w < s.length; w++) {
      var B = s[w];
      f += `
  `.concat(o[B] ? "üö´" : "‚û°Ô∏è", " ").concat(B)
    }
  }
  console.log("".concat(f, "\n```"))
}

function OD() {
  for (var _ = 0, o = ["rec2020", "p3", "srgb"]; _ < o.length; _++) {
    var f = o[_];
    if (matchMedia("(color-gamut: ".concat(f, ")")).matches) return f
  }
}

function ND() {
  if (a0("inverted")) return !0;
  if (a0("none")) return !1
}

function a0(_) {
  return matchMedia("(inverted-colors: ".concat(_, ")")).matches
}

function jD() {
  if (o0("active")) return !0;
  if (o0("none")) return !1
}

function o0(_) {
  return matchMedia("(forced-colors: ".concat(_, ")")).matches
}
var VD = 100;

function qD() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var _ = 0; _ <= VD; ++_)
      if (matchMedia("(max-monochrome: ".concat(_, ")")).matches) return _;
    throw new Error("Too high value")
  }
}

function UD() {
  if (Pc("no-preference")) return 0;
  if (Pc("high") || Pc("more")) return 1;
  if (Pc("low") || Pc("less")) return -1;
  if (Pc("forced")) return 10
}

function Pc(_) {
  return matchMedia("(prefers-contrast: ".concat(_, ")")).matches
}

function ZD() {
  if (s0("reduce")) return !0;
  if (s0("no-preference")) return !1
}

function s0(_) {
  return matchMedia("(prefers-reduced-motion: ".concat(_, ")")).matches
}

function GD() {
  if (l0("reduce")) return !0;
  if (l0("no-preference")) return !1
}

function l0(_) {
  return matchMedia("(prefers-reduced-transparency: ".concat(_, ")")).matches
}

function $D() {
  if (c0("high")) return !0;
  if (c0("standard")) return !1
}

function c0(_) {
  return matchMedia("(dynamic-range: ".concat(_, ")")).matches
}
var Nn = Math,
  pa = function() {
    return 0
  };

function HD() {
  var _ = Nn.acos || pa,
    o = Nn.acosh || pa,
    f = Nn.asin || pa,
    x = Nn.asinh || pa,
    A = Nn.atanh || pa,
    L = Nn.atan || pa,
    w = Nn.sin || pa,
    s = Nn.sinh || pa,
    B = Nn.cos || pa,
    j = Nn.cosh || pa,
    K = Nn.tan || pa,
    ee = Nn.tanh || pa,
    re = Nn.exp || pa,
    de = Nn.expm1 || pa,
    ne = Nn.log1p || pa,
    Y = function(Ee) {
      return Nn.pow(Nn.PI, Ee)
    },
    we = function(Ee) {
      return Nn.log(Ee + Nn.sqrt(Ee * Ee - 1))
    },
    Ie = function(Ee) {
      return Nn.log(Ee + Nn.sqrt(Ee * Ee + 1))
    },
    ze = function(Ee) {
      return Nn.log((1 + Ee) / (1 - Ee)) / 2
    },
    Re = function(Ee) {
      return Nn.exp(Ee) - 1 / Nn.exp(Ee) / 2
    },
    ke = function(Ee) {
      return (Nn.exp(Ee) + 1 / Nn.exp(Ee)) / 2
    },
    qe = function(Ee) {
      return Nn.exp(Ee) - 1
    },
    $e = function(Ee) {
      return (Nn.exp(2 * Ee) - 1) / (Nn.exp(2 * Ee) + 1)
    },
    Be = function(Ee) {
      return Nn.log(1 + Ee)
    };
  return {
    acos: _(.12312423423423424),
    acosh: o(1e308),
    acoshPf: we(1e154),
    asin: f(.12312423423423424),
    asinh: x(1),
    asinhPf: Ie(1),
    atanh: A(.5),
    atanhPf: ze(.5),
    atan: L(.5),
    sin: w(-1e300),
    sinh: s(1),
    sinhPf: Re(1),
    cos: B(10.000000000123),
    cosh: j(1),
    coshPf: ke(1),
    tan: K(-1e300),
    tanh: ee(1),
    tanhPf: $e(1),
    exp: re(1),
    expm1: de(1),
    expm1Pf: qe(1),
    log1p: ne(10),
    log1pPf: Be(10),
    powPI: Y(-100)
  }
}
var WD = "mmMwWLliI0fiflO&1",
  gm = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function XD() {
  return YD(function(_, o) {
    for (var f = {}, x = {}, A = 0, L = Object.keys(gm); A < L.length; A++) {
      var w = L[A],
        s = gm[w],
        B = s[0],
        j = B === void 0 ? {} : B,
        K = s[1],
        ee = K === void 0 ? WD : K,
        re = _.createElement("span");
      re.textContent = ee, re.style.whiteSpace = "nowrap";
      for (var de = 0, ne = Object.keys(j); de < ne.length; de++) {
        var Y = ne[de],
          we = j[Y];
        we !== void 0 && (re.style[Y] = we)
      }
      f[w] = re, o.append(_.createElement("br"), re)
    }
    for (var Ie = 0, ze = Object.keys(gm); Ie < ze.length; Ie++) {
      var w = ze[Ie];
      x[w] = f[w].getBoundingClientRect().width
    }
    return x
  })
}

function YD(_, o) {
  return o === void 0 && (o = 4e3), zy(function(f, x) {
    var A = x.document,
      L = A.body,
      w = L.style;
    w.width = "".concat(o, "px"), w.webkitTextSizeAdjust = w.textSizeAdjust = "none", Yh() ? L.style.zoom = "".concat(1 / x.devicePixelRatio) : go() && (L.style.zoom = "reset");
    var s = A.createElement("div");
    return s.textContent = Py([], Array(o / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), L.appendChild(s), _(A, L)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function KD() {
  return navigator.pdfViewerEnabled
}

function JD() {
  var _ = new Float32Array(1),
    o = new Uint8Array(_.buffer);
  return _[0] = 1 / 0, _[0] = _[0] - _[0], o[3]
}

function QD() {
  var _ = window.ApplePaySession;
  if (typeof(_ == null ? void 0 : _.canMakePayments) != "function") return -1;
  if (eR()) return -3;
  try {
    return _.canMakePayments() ? 1 : 0
  } catch (o) {
    return tR(o)
  }
}
var eR = XL;

function tR(_) {
  if (_ instanceof Error && _.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(_.message)) return -2;
  throw _
}

function rR() {
  var _, o = document.createElement("a"),
    f = (_ = o.attributionSourceId) !== null && _ !== void 0 ? _ : o.attributionsourceid;
  return f === void 0 ? void 0 : String(f)
}
var Ly = -1,
  Dy = -2,
  nR = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  iR = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  aR = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  oR = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  Ry = "WEBGL_debug_renderer_info",
  sR = "WEBGL_polygon_mode";

function lR(_) {
  var o, f, x, A, L, w, s = _.cache,
    B = Fy(s);
  if (!B) return Ly;
  if (!Oy(B)) return Dy;
  var j = By() ? null : B.getExtension(Ry);
  return {
    version: ((o = B.getParameter(B.VERSION)) === null || o === void 0 ? void 0 : o.toString()) || "",
    vendor: ((f = B.getParameter(B.VENDOR)) === null || f === void 0 ? void 0 : f.toString()) || "",
    vendorUnmasked: j ? (x = B.getParameter(j.UNMASKED_VENDOR_WEBGL)) === null || x === void 0 ? void 0 : x.toString() : "",
    renderer: ((A = B.getParameter(B.RENDERER)) === null || A === void 0 ? void 0 : A.toString()) || "",
    rendererUnmasked: j ? (L = B.getParameter(j.UNMASKED_RENDERER_WEBGL)) === null || L === void 0 ? void 0 : L.toString() : "",
    shadingLanguageVersion: ((w = B.getParameter(B.SHADING_LANGUAGE_VERSION)) === null || w === void 0 ? void 0 : w.toString()) || ""
  }
}

function cR(_) {
  var o = _.cache,
    f = Fy(o);
  if (!f) return Ly;
  if (!Oy(f)) return Dy;
  var x = f.getSupportedExtensions(),
    A = f.getContextAttributes(),
    L = [],
    w = [],
    s = [],
    B = [],
    j = [];
  if (A)
    for (var K = 0, ee = Object.keys(A); K < ee.length; K++) {
      var re = ee[K];
      w.push("".concat(re, "=").concat(A[re]))
    }
  for (var de = u0(f), ne = 0, Y = de; ne < Y.length; ne++) {
    var we = Y[ne],
      Ie = f[we];
    s.push("".concat(we, "=").concat(Ie).concat(nR.has(Ie) ? "=".concat(f.getParameter(Ie)) : ""))
  }
  if (x)
    for (var ze = 0, Re = x; ze < Re.length; ze++) {
      var ke = Re[ze];
      if (!(ke === Ry && By() || ke === sR && dR())) {
        var qe = f.getExtension(ke);
        if (!qe) {
          L.push(ke);
          continue
        }
        for (var $e = 0, Be = u0(qe); $e < Be.length; $e++) {
          var we = Be[$e],
            Ie = qe[we];
          B.push("".concat(we, "=").concat(Ie).concat(iR.has(Ie) ? "=".concat(f.getParameter(Ie)) : ""))
        }
      }
    }
  for (var Ee = 0, He = aR; Ee < He.length; Ee++)
    for (var Le = He[Ee], it = 0, pt = oR; it < pt.length; it++) {
      var Oe = pt[it],
        Je = uR(f, Le, Oe);
      j.push("".concat(Le, ".").concat(Oe, "=").concat(Je.join(",")))
    }
  return B.sort(), s.sort(), {
    contextAttributes: w,
    parameters: s,
    shaderPrecisions: j,
    extensions: x,
    extensionParameters: B,
    unsupportedExtensions: L
  }
}

function Fy(_) {
  if (_.webgl) return _.webgl.context;
  var o = document.createElement("canvas"),
    f;
  o.addEventListener("webglCreateContextError", function() {
    return f = void 0
  });
  for (var x = 0, A = ["webgl", "experimental-webgl"]; x < A.length; x++) {
    var L = A[x];
    try {
      f = o.getContext(L)
    } catch {}
    if (f) break
  }
  return _.webgl = {
    context: f
  }, f
}

function uR(_, o, f) {
  var x = _.getShaderPrecisionFormat(_[o], _[f]);
  return x ? [x.rangeMin, x.rangeMax, x.precision] : []
}

function u0(_) {
  var o = Object.keys(_.__proto__);
  return o.filter(hR)
}

function hR(_) {
  return typeof _ == "string" && !_.match(/[^A-Z0-9_x]/)
}

function By() {
  return Ey()
}

function dR() {
  return Yh() || go()
}

function Oy(_) {
  return typeof _.getParameter == "function"
}

function pR() {
  var _ = z_() || go();
  if (!_) return -2;
  if (!window.AudioContext) return -1;
  var o = new AudioContext().baseLatency;
  return o == null ? -1 : isFinite(o) ? o : -3
}

function fR() {
  if (!window.Intl) return -1;
  var _ = window.Intl.DateTimeFormat;
  if (!_) return -2;
  var o = _().resolvedOptions().locale;
  return !o && o !== "" ? -3 : o
}
var mR = {
  fonts: JL,
  domBlockers: DD,
  fontPreferences: XD,
  audio: VL,
  screenFrame: xD,
  canvas: eD,
  osCpu: uD,
  languages: hD,
  colorDepth: dD,
  deviceMemory: pD,
  screenResolution: fD,
  hardwareConcurrency: bD,
  timezone: wD,
  sessionStorage: SD,
  localStorage: CD,
  indexedDB: PD,
  openDatabase: ID,
  cpuClass: MD,
  platform: AD,
  plugins: QL,
  touchSupport: cD,
  vendor: kD,
  vendorFlavors: ED,
  cookiesEnabled: zD,
  colorGamut: OD,
  invertedColors: ND,
  forcedColors: jD,
  monochrome: qD,
  contrast: UD,
  reducedMotion: ZD,
  reducedTransparency: GD,
  hdr: $D,
  math: HD,
  pdfViewerEnabled: KD,
  architecture: JD,
  applePay: QD,
  privateClickMeasurement: rR,
  audioBaseLatency: pR,
  dateTimeLocale: fR,
  webGlBasics: lR,
  webGlExtensions: cR
};

function _R(_) {
  return zL(mR, _, [])
}
var gR = "$ if upgrade to Pro: https://fpjs.dev/pro";

function vR(_) {
  var o = yR(_),
    f = xR(o);
  return {
    score: o,
    comment: gR.replace(/\$/g, "".concat(f))
  }
}

function yR(_) {
  if (z_()) return .4;
  if (go()) return E_() && !(Jh() && Kh()) ? .5 : .3;
  var o = "value" in _.platform ? _.platform.value : "";
  return /^Win/.test(o) ? .6 : /^Mac/.test(o) ? .5 : .7
}

function xR(_) {
  return Ay(.99 + .01 * _, 1e-4)
}

function bR(_) {
  for (var o = "", f = 0, x = Object.keys(_).sort(); f < x.length; f++) {
    var A = x[f],
      L = _[A],
      w = "error" in L ? "error" : JSON.stringify(L.value);
    o += "".concat(o ? "|" : "").concat(A.replace(/([:|\\])/g, "\\$1"), ":").concat(w)
  }
  return o
}

function Ny(_) {
  return JSON.stringify(_, function(o, f) {
    return f instanceof Error ? ML(f) : f
  }, 2)
}

function jy(_) {
  return IL(bR(_))
}

function wR(_) {
  var o, f = vR(_);
  return {
    get visitorId() {
      return o === void 0 && (o = jy(this.components)), o
    },
    set visitorId(x) {
      o = x
    },
    confidence: f,
    components: _,
    version: Iy
  }
}

function TR(_) {
  return _ === void 0 && (_ = 50), vL(_, _ * 2)
}

function SR(_, o) {
  var f = Date.now();
  return {
    get: function(x) {
      return Eo(this, void 0, void 0, function() {
        var A, L, w;
        return zo(this, function(s) {
          switch (s.label) {
            case 0:
              return A = Date.now(), [4, _()];
            case 1:
              return L = s.sent(), w = wR(L), (o || x != null && x.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(w.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(A - f, `
visitorId: `).concat(w.visitorId, `
components: `).concat(Ny(L), "\n```")), [2, w]
          }
        })
      })
    }
  }
}

function CR() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var _ = new XMLHttpRequest;
    _.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(Iy, "/npm-monitoring"), !0), _.send()
  } catch (o) {
    console.error(o)
  }
}

function PR(_) {
  var o;
  return _ === void 0 && (_ = {}), Eo(this, void 0, void 0, function() {
    var f, x, A;
    return zo(this, function(L) {
      switch (L.label) {
        case 0:
          return (!((o = _.monitoring) !== null && o !== void 0) || o) && CR(), f = _.delayFallback, x = _.debug, [4, TR(f)];
        case 1:
          return L.sent(), A = _R({
            cache: {},
            debug: x
          }), [2, SR(A, x)]
      }
    })
  })
}
var IR = {
  load: PR,
  hashComponents: jy,
  componentsToDebugString: Ny
};
let vm = null;
async function MR() {
  return vm || (vm = IR.load()), vm
}
async function Vy() {
  return (await (await MR()).get()).visitorId
}
var AR = Dr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function sh(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = AR();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var kR = Dr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function h0(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = kR();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var ER = Dr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function qy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = ER();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var zR = Dr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  LR = Dr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function Uy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = gt(x);
  {
    var L = s => {
        var B = zR();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      },
      w = s => {
        var B = LR();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      };
    Ae(A, s => {
      o.filled ? s(L) : s(w, !1)
    })
  }
  G(_, x)
}
var DR = Dr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function i_(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = DR();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var RR = Dr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function Zy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = RR();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var FR = Dr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');

function BR(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = FR();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var OR = Dr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');

function NR(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = OR();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var jR = me("<!> ", 1),
  VR = me("<!> ", 1),
  qR = me("<!> ", 1),
  UR = me('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  ZR = me("<!> ", 1),
  GR = me("<!> <!>", 1),
  $R = me('<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'),
  HR = me('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  WR = me("<div><button><!></button></div>"),
  XR = me('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function YR(_, o) {
  zr(o, !0);
  let f = At(o, "screenLocked", 15),
    x = At(o, "opaquePixelArt", 15);
  const A = ct(() => new us(o.tileSize));
  let L = Qe(1),
    w = Qe("pencil");
  const s = new Map,
    B = new Map;
  let j = Qe(0),
    K = Qe(!1),
    ee = Qe(!0),
    re = ct(() => Mt.charges ?? 0),
    de = ct(() => y(re) - y(j)),
    ne = Qe(!1),
    Y = !1,
    we = Qe(!1),
    Ie = Qe(Si([]));
  const ze = ct(() => y(w) === "pencil"),
    Re = ct(() => y(w) === "eraser"),
    ke = ct(() => y(w) === "colorpicker"),
    qe = ct(() => y(w) === "cleararea"),
    $e = ct(() => {
      var Bt, st;
      return Ra((st = (Bt = Mt) == null ? void 0 : Bt.data) == null ? void 0 : st.role, ["admin", "global_moderator", "moderator"])
    });
  let Be = Qe(!1),
    Ee = Qe(0),
    He = Qe(void 0),
    Le = Qe(void 0);
  const it = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Bt => ({
      ...ma.colors[Bt],
      idx: Bt
    })),
    pt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Bt => ({
      ...ma.colors[Bt],
      idx: Bt
    }));
  let Oe = Qe(!1);
  const Je = ct(() => y(Oe) ? it : pt),
    bt = "show-all-colors";
  Dn(() => {
    te(Oe, localStorage.getItem(bt) === "true")
  }), Zr(() => {
    localStorage.setItem(bt, y(Oe) ? "true" : "false")
  });
  const We = "selected-color";
  Dn(() => {
    const Bt = Number(localStorage.getItem(We));
    !isNaN(Bt) && Bt < ma.colors.length && Bt > 0 && te(L, Bt, !0)
  }), Zr(() => {
    localStorage.setItem(We, y(L).toString())
  });
  const Ue = new rL({
    map: o.map,
    tileSize: o.tileSize,
    tileZoom: o.tileZoom,
    beforeLayerId: o.hoverLayerId
  });
  Zr(() => {
    const Bt = x() ? 1 : 0;
    Ue.setCanvasOpacity(Bt)
  }), Zr(() => {
    x() ? Tm() : ut([...s.values()])
  });
  let Ge = !1;
  Dn(() => {
    rs(o.map.getCenter(), o.map.getZoom());
    const Bt = o.map.on("click", Mr => {
      var sn;
      o.zoom < o.tileZoom + 2 && ((sn = Mt.data) == null ? void 0 : sn.role) === "user" && o.map.easeTo({
        center: Mr.lngLat,
        zoom: 17
      });
      const nn = [Mr.lngLat.lat, Mr.lngLat.lng];
      if (y(ze)) mt([nn], y(L));
      else if (y(Re)) lt([nn]);
      else if (y(ke)) yt(nn, Mr.point);
      else if (y(qe) && (y(Ie).push(nn), mt([nn], 0), y(Ie).length >= 2)) {
        const [dn, _n] = y(Ie), [Yn, fi] = y(A).latLonToPixelsFloor(dn[0], dn[1], o.tileZoom), [fn, oi] = y(A).latLonToPixelsFloor(_n[0], _n[1], o.tileZoom), ti = Math.min(Yn, fn), xi = Math.max(Yn, fn), Ri = Math.min(fi, oi), sa = Math.max(fi, oi), Ci = [];
        for (let Vi = Ri; Vi <= sa; Vi++) {
          const wa = y(A).pixelsToLatLon(ti + .5, Vi + .5, o.tileZoom),
            ga = y(A).pixelsToLatLon(xi + .5, Vi + .5, o.tileZoom),
            Oa = st({
              lat: wa[0],
              lng: wa[1]
            }, {
              lat: ga[0],
              lng: ga[1]
            }).slice(0, y(de) - Ci.length);
          if (Ci.push(...Oa), Ci.length >= y(de)) break
        }
        mt(Ci, 0), te(Ie, [], !0), te(w, "pencil")
      }
      te(ne, !0)
    });

    function st(Mr, nn) {
      const sn = y(A).latLonToPixels(Mr.lat, Mr.lng, o.tileZoom),
        dn = nn ? y(A).latLonToPixels(nn.lat, nn.lng, o.tileZoom) : sn;
      return Fb(sn, dn).map(Yn => y(A).pixelsToLatLon(Yn[0] + .5, Yn[1] + .5, o.tileZoom))
    }

    function Me(Mr, nn) {
      const sn = st(Mr, nn);
      y(ze) ? mt(sn, y(L)) : y(Re) && lt(sn), te(ne, !0)
    }
    let ft;

    function zt(Mr) {
      const nn = o.map.unproject([Mr.clientX, Mr.clientY]);
      if (y(we)) {
        const sn = st(nn, ft);
        lt(sn)
      }(Ge || Y) && Me(nn, ft), ft = nn
    }
    window.addEventListener("mousemove", zt);
    let ar = !1;
    const br = o.map.on("touchstart", Mr => {
        if (Mr.points.length == 2) {
          f(!1), ot(), ar = !0, setTimeout(() => ar = !1, 150);
          return
        }
        f() && setTimeout(() => {
          !ar && Me(Mr.lngLat)
        }, 150), ft = Mr.lngLat
      }),
      Tr = o.map.on("touchmove", Mr => {
        f() && Me(Mr.lngLat, ft), ft = Mr.lngLat
      }),
      Dt = Mr => {
        Mr.code === "Space" && (Ge || ft && Me(ft), Ge = !0, Mr.preventDefault())
      };
    document.addEventListener("keydown", Dt);
    const Br = Mr => {
      Mr.code === "Space" && (Ge = !1, Ve = !1, y(j) === 0 && y(Re) && te(w, "pencil"))
    };
    document.addEventListener("keyup", Br);

    function Ir(Mr) {
      if (Mr.button === 2) {
        te(we, !0);
        const sn = o.map.unproject([Mr.clientX, Mr.clientY]);
        lt([
          [sn.lat, sn.lng]
        ])
      }
    }
    document.addEventListener("mousedown", Ir);

    function wr(Mr) {
      Mr.button === 2 && te(we, !1)
    }
    document.addEventListener("mouseup", wr);
    const Xr = Mr => {
      switch (Mr.code) {
        case "KeyE":
          y(j) > 0 && (y(Re) ? te(w, "pencil") : te(w, "eraser"));
          return;
        case "KeyI":
          te(w, "colorpicker");
          return;
        case "KeyC":
          y($e) && te(w, "cleararea");
          return
      }
    };
    return document.addEventListener("keypress", Xr), () => {
      Tr.unsubscribe(), br.unsubscribe(), Bt.unsubscribe(), document.removeEventListener("mousemove", zt), document.removeEventListener("keydown", Dt), document.removeEventListener("keyup", Br), document.removeEventListener("keypress", Xr), document.removeEventListener("mousedown", Ir), document.removeEventListener("mouseup", wr), Ut()
    }
  });
  let Ve = !1;

  function mt(Bt, st) {
    let Me = !1;
    const ft = st === 0;
    for (let zt of Bt) {
      const [ar, br] = zt, Tr = M0(st), {
        tile: Dt,
        pixel: Br
      } = y(A).latLonToTileAndPixel(ar, br, o.tileZoom), Ir = {
        color: Tr,
        tile: Dt,
        pixel: Br,
        season: o.season,
        colorIdx: st
      }, wr = um(Ir), Xr = s.get(wr), Mr = y(re) - s.size;
      if (!Xr && Mr < 1) {
        if (Ve && (Ge || f())) continue;
        Ve = !0, vr.info(BC());
        continue
      }
      Xr && Xr.colorIdx === st || (Wi.plop.play(), Me || o.hidePixelHover(), s.set(wr, Ir), Ue.place(zt, st), o.crosshair.place(zt), Me = !0, ft && B.set(wr, Ir))
    }
    te(j, s.size, !0), Me && !x() ? ut([...s.values()]) : Me && x() && ft && ut([...B.values()])
  }

  function lt(Bt) {
    let st = !1,
      Me = !1;
    for (let ft of Bt) {
      const [zt, ar] = ft, {
        tile: br,
        pixel: Tr
      } = y(A).latLonToTileAndPixel(zt, ar, o.tileZoom), Dt = um({
        tile: br,
        pixel: Tr,
        season: o.season
      }), Br = s.get(Dt);
      Br && (Wi.plop.play(), o.hidePixelHover(), s.delete(Dt), B.delete(Dt), Ue.remove([zt, ar]), o.crosshair.remove(ft), st = !0, Br.colorIdx === 0 && (Me = !0)), s.size === 0 && !(Ge || Y || f()) && te(w, "pencil")
    }
    te(j, s.size, !0), st && !x() ? ut([...s.values()]) : st && x() && Me && ut([...B.values()])
  }

  function yt(Bt, st) {
    const {
      tile: Me,
      pixel: ft
    } = y(A).latLonToTileAndPixel(Bt[0], Bt[1], o.tileZoom), zt = um({
      tile: Me,
      pixel: ft,
      season: o.season
    }), ar = s.get(zt);
    if (ar) {
      xt(ar.colorIdx), requestAnimationFrame(() => {
        var Br;
        (Br = document.getElementById(`color-${ar.colorIdx}`)) == null || Br.focus()
      });
      return
    }
    const br = window.devicePixelRatio,
      Tr = Math.floor(st.x * br),
      Dt = Math.floor(st.y * br);
    o.hidePixelHover(), ek(o.map, Tr, Dt).then(([Br, Ir, wr]) => {
      const Xr = Rb({
        r: Br,
        g: Ir,
        b: wr
      });
      xt(Xr), requestAnimationFrame(() => {
        var Mr;
        (Mr = document.getElementById(`color-${Xr}`)) == null || Mr.focus()
      })
    })
  }
  Rs(() => y(L), () => {
    o.clickedLatLon && !y(ne) && (y(L) === void 0 && te(L, 1), mt([o.clickedLatLon], y(L)))
  }), Zr(() => {
    const Bt = y(ee) ? .8 : 0;
    o.crosshair.setCanvasOpacity(Bt)
  });
  let _t = Qe(16.5);
  Zr(() => {
    if (y(He) && y(Le) && o.clickedLatLon) {
      const Bt = o.map.getZoom();
      if (Bt < y(_t)) {
        const [st, Me] = o.clickedLatLon, ft = y(A).latLonToPixelBoundsLatLon(st, Me, o.tileZoom), zt = w_(ft), ar = y(He) - y(Le).clientHeight, br = y(He) / 2 - ar / 2;
        o.map.flyTo({
          center: {
            lat: zt[0],
            lng: zt[1]
          },
          zoom: 17.5,
          offset: Bt > 11 ? [0, -br] : [0, 0]
        })
      }
      te(_t, o.tileZoom, !0)
    }
  }), Dn(() => {
    const Bt = () => {
      !document.hidden && (console.log("Tab visible again"), x() ? ut([...B.values()]) : ut([...s.values()]))
    };
    return document.addEventListener("visibilitychange", Bt), () => document.removeEventListener("visibilitychange", Bt)
  }), Zr(() => {
    switch (y(w)) {
      case "pencil":
        o.map.getCanvas().style.cursor = `url('${eL}') 8 8, default`, o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        o.map.getCanvas().style.cursor = `url('${Jz}') 0 16, default`, o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        o.map.getCanvas().style.cursor = `url('${Qz}') 2 14, default`, o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), Zr(() => {
    f() ? Ke() : ot()
  });
  async function ut(Bt) {
    await yb(Bt), o.refreshPixelArt()
  }
  async function Ut() {
    await Tm(), Ue.clear(), o.refreshPixelArt(), o.crosshair.clear()
  }
  async function Lt() {
    await Ut(), ot(), o.map.getCanvas().style.cursor = "default", o.map.setPaintProperty(o.hoverLayerId, "raster-opacity", .4), o.onclose()
  }

  function Ke() {
    o.map.dragPan.disable(), o.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function ot() {
    o.map.dragPan.enable(), o.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function xt(Bt) {
    return Bt >= 32 && te(Oe, !0), Mt.hasColor(Bt) ? (Wi.smallDropplet.play(), te(L, Bt, !0), te(w, "pencil"), !0) : (Wi.smallDropplet.play(), te(Be, !0), te(Ee, Bt, !0), !1)
  }
  ob(Bt => {
    Bt.type === "leave" && y(j) > 0 && Bt.cancel()
  });
  const Ct = "show-paint-more-than-one-pixel-msg";
  let wt = Qe(!1);
  Dn(() => {
    var Bt;
    te(wt, !localStorage.getItem(Ct) && (((Bt = Mt.data) == null ? void 0 : Bt.pixelsPainted) ?? 0) < 100, !0)
  }), Zr(() => {
    y(j) > 1 && (te(wt, !1), localStorage.setItem(Ct, "false"))
  });
  const kt = "lp";
  Dn(() => {
    var st;
    const Bt = localStorage.getItem(kt);
    if (Bt) try {
      const Me = JSON.parse(atob(Bt)),
        ft = (Me == null ? void 0 : Me.time) ?? 0,
        zt = 60 * 1e3;
      (Me == null ? void 0 : Me.userId) !== ((st = Mt.data) == null ? void 0 : st.id) && Date.now() - ft < 30 * zt && !Yb && (vr.error(jC()), Lt())
    } catch (Me) {
      console.error(Me)
    }
  });

  function Zt() {
    var st;
    const Bt = btoa(JSON.stringify({
      userId: (st = Mt.data) == null ? void 0 : st.id,
      time: Date.now()
    }));
    localStorage.setItem(kt, Bt)
  }
  var Nt = XR(),
    $t = gt(Nt),
    It = M($t);
  {
    var Xt = Bt => {
        pl(Bt, {
          children: (st, Me) => {
            var ft = jR(),
              zt = gt(ft);
            qy(zt, {
              class: "inline size-5"
            });
            var ar = q(zt);
            je(br => le(ar, ` ${br??""}`), [() => g3()]), G(st, ft)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Ot = Bt => {
        var st = Jt(),
          Me = gt(st);
        {
          var ft = ar => {
              pl(ar, {
                class: "not-touchscreen:hidden",
                children: (br, Tr) => {
                  var Dt = VR(),
                    Br = gt(Dt);
                  Cm(Br, {
                    class: "inline size-5"
                  });
                  var Ir = q(Br);
                  je(wr => le(Ir, ` ${wr??""}`), [() => x3()]), G(br, Dt)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            zt = ar => {
              var br = Jt(),
                Tr = gt(br);
              {
                var Dt = Ir => {
                    pl(Ir, {
                      class: "not-touchscreen:hidden",
                      children: (wr, Xr) => {
                        var Mr = qR(),
                          nn = gt(Mr);
                        h0(nn, {
                          class: "inline size-5"
                        });
                        var sn = q(nn, 1, !0);
                        je(dn => le(sn, dn), [() => T3()]), G(wr, Mr)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Br = Ir => {
                    var wr = Jt(),
                      Xr = gt(wr);
                    {
                      var Mr = sn => {
                          pl(sn, {
                            class: "touchscreen:hidden",
                            children: (dn, _n) => {
                              var Yn = UR(),
                                fi = gt(Yn);
                              Zy(fi, {
                                class: "inline size-5"
                              });
                              var fn = q(fi),
                                oi = M(fn, !0);
                              P(fn);
                              var ti = q(fn, 2),
                                xi = M(ti),
                                Ri = q(xi),
                                sa = M(Ri, !0);
                              P(Ri), P(ti);
                              var Ci = q(ti);
                              je((Vi, wa, ga, Oa) => {
                                le(oi, Vi), le(xi, `${wa??""} `), le(sa, ga), le(Ci, ` ${Oa??""}`)
                              }, [() => P3(), () => z3(), () => A3(), () => R3()]), G(dn, Yn)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        nn = sn => {
                          var dn = Jt(),
                            _n = gt(dn);
                          {
                            var Yn = fn => {
                                pl(fn, {
                                  class: "bg-warning text-warning-content animate-bounce",
                                  children: (oi, ti) => {
                                    var xi = ZR(),
                                      Ri = gt(xi);
                                    Wh(Ri, {
                                      class: "inline size-5"
                                    });
                                    var sa = q(Ri);
                                    je(Ci => le(sa, ` ${Ci??""}`), [() => O3()]), G(oi, xi)
                                  },
                                  $$slots: {
                                    default: !0
                                  }
                                })
                              },
                              fi = fn => {
                                var oi = Jt(),
                                  ti = gt(oi);
                                {
                                  var xi = Ri => {
                                    pl(Ri, {
                                      class: "bg-warning text-warning-content animate-bounce",
                                      children: (sa, Ci) => {
                                        var Vi = GR(),
                                          wa = gt(Vi);
                                        sh(wa, {
                                          class: "inline size-5"
                                        });
                                        var ga = q(wa, 2);
                                        {
                                          var Oa = Ta => {
                                              var vt = ji();
                                              je(Yt => le(vt, Yt), [() => $0()]), G(Ta, vt)
                                            },
                                            hs = Ta => {
                                              var vt = Jt(),
                                                Yt = gt(vt);
                                              {
                                                var Gr = Cn => {
                                                  var Zn = ji();
                                                  je(mi => le(Zn, mi), [() => H0()]), G(Cn, Zn)
                                                };
                                                Ae(Yt, Cn => {
                                                  y(Ie).length === 1 && Cn(Gr)
                                                }, !0)
                                              }
                                              G(Ta, vt)
                                            };
                                          Ae(ga, Ta => {
                                            y(Ie).length === 0 ? Ta(Oa) : Ta(hs, !1)
                                          })
                                        }
                                        G(sa, Vi)
                                      },
                                      $$slots: {
                                        default: !0
                                      }
                                    })
                                  };
                                  Ae(ti, Ri => {
                                    y(qe) && Ri(xi)
                                  }, !0)
                                }
                                G(fn, oi)
                              };
                            Ae(_n, fn => {
                              y(wt) ? fn(Yn) : fn(fi, !1)
                            }, !0)
                          }
                          G(sn, dn)
                        };
                      Ae(Xr, sn => {
                        y(ze) && y(j) === 0 ? sn(Mr) : sn(nn, !1)
                      }, !0)
                    }
                    G(Ir, wr)
                  };
                Ae(Tr, Ir => {
                  y(ke) ? Ir(Dt) : Ir(Br, !1)
                }, !0)
              }
              G(ar, br)
            };
          Ae(Me, ar => {
            y(Re) ? ar(ft) : ar(zt, !1)
          }, !0)
        }
        G(Bt, st)
      };
    Ae(It, Bt => {
      y(Re) && y(j) === 0 ? Bt(Xt) : Bt(Ot, !1)
    })
  }
  var jt = q(It, 2),
    qt = M(jt);
  qt.__click = () => te(ee, !y(ee));
  var fr = M(qt);
  {
    var Kt = Bt => {
        aL(Bt, {
          class: "size-4"
        })
      },
      _r = Bt => {
        sL(Bt, {
          class: "size-4"
        })
      };
    Ae(fr, Bt => {
      y(ee) ? Bt(Kt) : Bt(_r, !1)
    })
  }
  P(qt);
  var rr = q(qt, 2),
    hr = M(rr),
    nr = M(hr),
    Et = q(nr);
  Sy(Et, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${y(j)??""})`
    },
    mono: !0
  }), P(hr);
  var kr = q(hr, 2),
    Te = M(kr),
    O = M(Te);
  bn(), P(Te);
  var E = q(Te, 2);
  E.__click = () => {
    te(w, "colorpicker")
  };
  var D = M(E);
  h0(D, {
    class: "size-4.5"
  }), P(E), P(kr);
  var N = q(kr, 2),
    H = M(N);
  let W;
  H.__click = () => {
    x(!x())
  };
  var ce = M(H);
  {
    let Bt = ct(() => !x());
    Uy(ce, {
      class: "size-4.5",
      get filled() {
        return y(Bt)
      }
    })
  }
  P(H), P(N);
  var ve = q(N, 2);
  {
    var he = Bt => {
      var st = $R(),
        Me = M(st),
        ft = M(Me);
      bn(), P(Me);
      var zt = q(Me, 2);
      zt.__click = () => {
        te(w, "cleararea")
      };
      var ar = M(zt);
      sh(ar, {
        class: "size-4.5"
      }), P(zt), P(st), je(br => {
        le(ft, `${br??""} `), Or(zt, 1, ls({
          "btn btn-circle btn-sm": !0,
          "btn-ghost": !y(qe),
          "btn-primary": y(qe)
        }))
      }, [() => NI()]), G(Bt, st)
    };
    Ae(ve, Bt => {
      y($e) && Bt(he)
    })
  }
  P(rr);
  var Se = q(rr, 2);
  Se.__click = () => {
    Wi.smallPlop.play(), Lt()
  };
  var Ye = M(Se);
  Bs(Ye, {
    class: "size-4"
  }), P(Se), P(jt);
  var Ze = q(jt, 2),
    Tt = M(Ze);
  ii(Tt, 23, () => y(Je), Bt => Bt.idx, (Bt, st, Me) => {
    const ft = ct(() => {
        const [wr, Xr, Mr] = y(st).rgb;
        return {
          r: wr,
          g: Xr,
          b: Mr
        }
      }),
      zt = ct(() => y(L) === y(st).idx && y(ze)),
      ar = ct(() => y(st).idx === 0),
      br = ct(() => Mt.hasColor(y(st).idx));
    var Tr = WR(),
      Dt = M(Tr);
    Dt.__click = () => {
      xt(y(st).idx)
    };
    var Br = M(Dt);
    {
      var Ir = wr => {
        var Xr = HR(),
          Mr = gt(Xr);
        i_(Mr, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var nn = q(Mr, 2),
          sn = M(nn);
        i_(sn, {
          class: "text-base-content/80 size-4"
        }), P(nn), G(wr, Xr)
      };
      Ae(Br, wr => {
        y(br) || wr(Ir)
      })
    }
    P(Dt), P(Tr), je(() => {
      Or(Tr, 1, ls({
        tooltip: !0,
        "max-sm:h-6": y(Oe),
        "max-sm:before:translate-x-1/4": y(Me) % 8 === 0 && y(st).name.length > 7,
        "max-sm:before:-translate-x-1/4": (y(Me) - 7) % 8 === 0 && y(st).name.length > 7,
        "max-xl:before:translate-x-1/4": y(Me) % 16 === 0 && y(st).name.length > 7,
        "max-xl:before:-translate-x-1/4": (y(Me) - 15) % 16 === 0 && y(st).name.length > 7,
        "xl:before:translate-x-1/4": y(Oe) && y(Me) % 32 === 0 && y(st).name.length > 7,
        "xl:before:-translate-x-1/4": y(Oe) && (y(Me) - 31) % 32 === 0 && y(st).name.length > 7
      })), mr(Tr, "data-tip", y(st).name), Or(Dt, 1, ls({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": y(zt),
        "border-base-300": !y(zt) && y(ar),
        "border-base-content/20": !y(zt) && !y(ar),
        "max-sm:h-6 max-sm:rounded-md": y(Oe)
      })), Oc(Dt, y(ar) ? `background-image: url(${tL}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${y(ft).r} ${y(ft).g} ${y(ft).b})`), mr(Dt, "aria-label", y(st).name), mr(Dt, "id", `color-${y(st).idx??""}`)
    }), Un("focus", Dt, () => {
      y(br) && (te(L, y(st).idx, !0), te(w, "pencil"))
    }), G(Bt, Tr)
  }), P(Tt), P(Ze);
  var _e = q(Ze, 2),
    Vt = M(_e);
  Vt.__click = () => {
    te(Oe, !y(Oe))
  };
  var ur = M(Vt);
  {
    var Ft = Bt => {
        BR(Bt, {
          class: "size-5"
        })
      },
      or = Bt => {
        NR(Bt, {
          class: "size-5"
        })
      };
    Ae(ur, Bt => {
      y(Oe) ? Bt(Ft) : Bt(or, !1)
    })
  }
  P(Vt);
  var Vr = q(Vt, 2),
    qr = M(Vr);
  {
    let Bt = ct(() => y(j) > 100 ? "animate-pulse" : ""),
      st = ct(() => y(j) === 0 || y(K) || y(de) < 0);
    Cy(qr, {
      get class() {
        return y(Bt)
      },
      get charges() {
        return y(de)
      },
      get disabled() {
        return y(st)
      },
      get loading() {
        return y(K)
      },
      onclick: async () => {
        Wi.droppletAndPlop.play();
        const Me = [...s.values()];
        te(K, !0);
        try {
          const ft = await Vy();
          await Jr.paint(Me, ft), await b0(Me), Zt(), Mt.refresh(), Cp.shouldReload = !0, await Lt()
        } catch (ft) {
          vr.error(`${ft.message}`, {
            duration: 7e3
          })
        } finally {
          te(K, !1)
        }
      }
    })
  }
  P(Vr);
  var Wr = q(Vr, 2),
    rn = M(Wr),
    hn = M(rn),
    cn = M(hn);
  bn(), P(hn);
  var an = q(hn, 2);
  let ht;
  an.__click = () => {
    te(w, y(w) === "eraser" ? "pencil" : "eraser", !0)
  };
  var un = M(an);
  Cm(un, {
    class: "size-5",
    get filled() {
      return y(Re)
    }
  }), P(an), P(rn), P(Wr), P(_e), P($t), ko($t, Bt => te(Le, Bt), () => y(Le));
  var Pn = q($t, 2);
  _L(Pn, {
    get colorIdx() {
      return y(Ee)
    },
    get open() {
      return y(Be)
    },
    set open(Bt) {
      te(Be, Bt, !0)
    }
  }), je((Bt, st, Me, ft) => {
    le(nr, `${Bt??""} `), le(O, `${st??""} `), Or(E, 1, ls({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !y(ke),
      "btn-primary": y(ke)
    })), mr(N, "data-tip", Me), W = Or(H, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, W, {
      "text-primary": !x()
    }), Or(Tt, 1, ls({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": y(Oe),
      "gap-1": !y(Oe)
    })), le(cn, `${ft??""} `), ht = Or(an, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, ht, {
      "btn-primary": y(Re)
    }), an.disabled = y(j) === 0
  }, [() => V3(), () => Z3(), () => N0(), () => Bb()]), Yp("innerHeight", Bt => te(He, Bt, !0)), G(_, Nt), Lr()
}
Rn(["click"]);

function L_(..._) {
  return P0(Qu(_))
}
var KR = me("<div><!></div>");

function JR(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
  var A = KR();
  cr(A, w => ({
    class: w,
    ...x
  }), [() => L_("flex items-center", o.class)]);
  var L = M(A);
  ai(L, () => o.children ?? oa), P(A), ko(A, w => f(w), () => f()), G(_, A), Lr()
}
var QR = me('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'),
  e7 = me(" <!>", 1);

function t7(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
  var A = Jt(),
    L = gt(A);
  {
    let w = ct(() => L_("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", o.cell.isActive && "ring-base-content/40 z-10 ring-2", o.class));
    Ti(L, () => L8, (s, B) => {
      B(s, Fs({
        get cell() {
          return o.cell
        },
        get class() {
          return y(w)
        }
      }, () => x, {
        get ref() {
          return f()
        },
        set ref(j) {
          f(j)
        },
        children: (j, K) => {
          bn();
          var ee = e7(),
            re = gt(ee),
            de = q(re);
          {
            var ne = Y => {
              var we = QR();
              G(Y, we)
            };
            Ae(de, Y => {
              o.cell.hasFakeCaret && Y(ne)
            })
          }
          je(() => le(re, `${o.cell.char??""} `)), G(j, ee)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  G(_, A), Lr()
}

function r7(_, o) {
  zr(o, !0);
  let f = At(o, "ref", 15, null),
    x = At(o, "value", 15, ""),
    A = lr(o, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var L = Jt(),
    w = gt(L);
  {
    let s = ct(() => L_("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", o.class));
    Ti(w, () => E8, (B, j) => {
      j(B, Fs({
        get class() {
          return y(s)
        }
      }, () => A, {
        get ref() {
          return f()
        },
        set ref(K) {
          f(K)
        },
        get value() {
          return x()
        },
        set value(K) {
          x(K)
        }
      }))
    })
  }
  G(_, L), Lr()
}
var ym = {
    exports: {}
  },
  d0;

function n7() {
  return d0 || (d0 = 1, (function(_) {
    (function(o) {
      _.exports ? _.exports = o() : window.intlTelInput = o()
    })(() => {
      var o = (() => {
        var f = Object.defineProperty,
          x = Object.getOwnPropertyDescriptor,
          A = Object.getOwnPropertyNames,
          L = Object.prototype.hasOwnProperty,
          w = (Te, O) => {
            for (var E in O) f(Te, E, {
              get: O[E],
              enumerable: !0
            })
          },
          s = (Te, O, E, D) => {
            if (O && typeof O == "object" || typeof O == "function")
              for (let N of A(O)) !L.call(Te, N) && N !== E && f(Te, N, {
                get: () => O[N],
                enumerable: !(D = x(O, N)) || D.enumerable
              });
            return Te
          },
          B = Te => s(f({}, "__esModule", {
            value: !0
          }), Te),
          j = {};
        w(j, {
          Iti: () => rr,
          default: () => kr
        });
        var K = [
            ["af", "93", 0, null, "0"],
            ["ax", "358", 1, ["18", "4"], "0"],
            ["al", "355", 0, null, "0"],
            ["dz", "213", 0, null, "0"],
            ["as", "1", 5, ["684"], "1"],
            ["ad", "376"],
            ["ao", "244"],
            ["ai", "1", 6, ["264"], "1"],
            ["ag", "1", 7, ["268"], "1"],
            ["ar", "54", 0, null, "0"],
            ["am", "374", 0, null, "0"],
            ["aw", "297"],
            ["ac", "247"],
            ["au", "61", 0, ["4"], "0"],
            ["at", "43", 0, null, "0"],
            ["az", "994", 0, null, "0"],
            ["bs", "1", 8, ["242"], "1"],
            ["bh", "973"],
            ["bd", "880", 0, null, "0"],
            ["bb", "1", 9, ["246"], "1"],
            ["by", "375", 0, null, "8"],
            ["be", "32", 0, null, "0"],
            ["bz", "501"],
            ["bj", "229"],
            ["bm", "1", 10, ["441"], "1"],
            ["bt", "975"],
            ["bo", "591", 0, null, "0"],
            ["ba", "387", 0, null, "0"],
            ["bw", "267"],
            ["br", "55", 0, null, "0"],
            ["io", "246"],
            ["vg", "1", 11, ["284"], "1"],
            ["bn", "673"],
            ["bg", "359", 0, null, "0"],
            ["bf", "226"],
            ["bi", "257"],
            ["kh", "855", 0, null, "0"],
            ["cm", "237"],
            ["ca", "1", 1, ["204", "226", "236", "249", "250", "257", "263", "289", "306", "343", "354", "365", "367", "368", "382", "403", "416", "418", "428", "431", "437", "438", "450", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905", "942"], "1"],
            ["cv", "238"],
            ["bq", "599", 1, ["3", "4", "7"]],
            ["ky", "1", 12, ["345"], "1"],
            ["cf", "236"],
            ["td", "235"],
            ["cl", "56"],
            ["cn", "86", 0, null, "0"],
            ["cx", "61", 2, ["4", "89164"], "0"],
            ["cc", "61", 1, ["4", "89162"], "0"],
            ["co", "57", 0, null, "0"],
            ["km", "269"],
            ["cg", "242"],
            ["cd", "243", 0, null, "0"],
            ["ck", "682"],
            ["cr", "506"],
            ["ci", "225"],
            ["hr", "385", 0, null, "0"],
            ["cu", "53", 0, null, "0"],
            ["cw", "599", 0],
            ["cy", "357"],
            ["cz", "420"],
            ["dk", "45"],
            ["dj", "253"],
            ["dm", "1", 13, ["767"], "1"],
            ["do", "1", 2, ["809", "829", "849"], "1"],
            ["ec", "593", 0, null, "0"],
            ["eg", "20", 0, null, "0"],
            ["sv", "503"],
            ["gq", "240"],
            ["er", "291", 0, null, "0"],
            ["ee", "372"],
            ["sz", "268"],
            ["et", "251", 0, null, "0"],
            ["fk", "500"],
            ["fo", "298"],
            ["fj", "679"],
            ["fi", "358", 0, ["4"], "0"],
            ["fr", "33", 0, null, "0"],
            ["gf", "594", 0, null, "0"],
            ["pf", "689"],
            ["ga", "241"],
            ["gm", "220"],
            ["ge", "995", 0, null, "0"],
            ["de", "49", 0, null, "0"],
            ["gh", "233", 0, null, "0"],
            ["gi", "350"],
            ["gr", "30"],
            ["gl", "299"],
            ["gd", "1", 14, ["473"], "1"],
            ["gp", "590", 0, null, "0"],
            ["gu", "1", 15, ["671"], "1"],
            ["gt", "502"],
            ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
            ["gn", "224"],
            ["gw", "245"],
            ["gy", "592"],
            ["ht", "509"],
            ["hn", "504"],
            ["hk", "852"],
            ["hu", "36", 0, null, "06"],
            ["is", "354"],
            ["in", "91", 0, null, "0"],
            ["id", "62", 0, null, "0"],
            ["ir", "98", 0, null, "0"],
            ["iq", "964", 0, null, "0"],
            ["ie", "353", 0, null, "0"],
            ["im", "44", 2, ["1624", "74576", "7524", "7624", "7924"], "0"],
            ["il", "972", 0, null, "0"],
            ["it", "39", 0, ["3"]],
            ["jm", "1", 4, ["658", "876"], "1"],
            ["jp", "81", 0, null, "0"],
            ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"],
            ["jo", "962", 0, null, "0"],
            ["kz", "7", 1, ["33", "7"], "8"],
            ["ke", "254", 0, null, "0"],
            ["ki", "686", 0, null, "0"],
            ["xk", "383", 0, null, "0"],
            ["kw", "965"],
            ["kg", "996", 0, null, "0"],
            ["la", "856", 0, null, "0"],
            ["lv", "371"],
            ["lb", "961", 0, null, "0"],
            ["ls", "266"],
            ["lr", "231", 0, null, "0"],
            ["ly", "218", 0, null, "0"],
            ["li", "423", 0, null, "0"],
            ["lt", "370", 0, null, "0"],
            ["lu", "352"],
            ["mo", "853"],
            ["mg", "261", 0, null, "0"],
            ["mw", "265", 0, null, "0"],
            ["my", "60", 0, null, "0"],
            ["mv", "960"],
            ["ml", "223"],
            ["mt", "356"],
            ["mh", "692", 0, null, "1"],
            ["mq", "596", 0, null, "0"],
            ["mr", "222"],
            ["mu", "230"],
            ["yt", "262", 1, ["269", "639"], "0"],
            ["mx", "52"],
            ["fm", "691"],
            ["md", "373", 0, null, "0"],
            ["mc", "377", 0, null, "0"],
            ["mn", "976", 0, null, "0"],
            ["me", "382", 0, null, "0"],
            ["ms", "1", 16, ["664"], "1"],
            ["ma", "212", 0, ["6", "7"], "0"],
            ["mz", "258"],
            ["mm", "95", 0, null, "0"],
            ["na", "264", 0, null, "0"],
            ["nr", "674"],
            ["np", "977", 0, null, "0"],
            ["nl", "31", 0, null, "0"],
            ["nc", "687"],
            ["nz", "64", 0, null, "0"],
            ["ni", "505"],
            ["ne", "227"],
            ["ng", "234", 0, null, "0"],
            ["nu", "683"],
            ["nf", "672"],
            ["kp", "850", 0, null, "0"],
            ["mk", "389", 0, null, "0"],
            ["mp", "1", 17, ["670"], "1"],
            ["no", "47", 0, ["4", "9"]],
            ["om", "968"],
            ["pk", "92", 0, null, "0"],
            ["pw", "680"],
            ["ps", "970", 0, null, "0"],
            ["pa", "507"],
            ["pg", "675"],
            ["py", "595", 0, null, "0"],
            ["pe", "51", 0, null, "0"],
            ["ph", "63", 0, null, "0"],
            ["pl", "48"],
            ["pt", "351"],
            ["pr", "1", 3, ["787", "939"], "1"],
            ["qa", "974"],
            ["re", "262", 0, null, "0"],
            ["ro", "40", 0, null, "0"],
            ["ru", "7", 0, ["33"], "8"],
            ["rw", "250", 0, null, "0"],
            ["ws", "685"],
            ["sm", "378"],
            ["st", "239"],
            ["sa", "966", 0, null, "0"],
            ["sn", "221"],
            ["rs", "381", 0, null, "0"],
            ["sc", "248"],
            ["sl", "232", 0, null, "0"],
            ["sg", "65"],
            ["sx", "1", 21, ["721"], "1"],
            ["sk", "421", 0, null, "0"],
            ["si", "386", 0, null, "0"],
            ["sb", "677"],
            ["so", "252", 0, null, "0"],
            ["za", "27", 0, null, "0"],
            ["kr", "82", 0, null, "0"],
            ["ss", "211", 0, null, "0"],
            ["es", "34"],
            ["lk", "94", 0, null, "0"],
            ["bl", "590", 1, null, "0"],
            ["sh", "290"],
            ["kn", "1", 18, ["869"], "1"],
            ["lc", "1", 19, ["758"], "1"],
            ["mf", "590", 2, null, "0"],
            ["pm", "508", 0, null, "0"],
            ["vc", "1", 20, ["784"], "1"],
            ["sd", "249", 0, null, "0"],
            ["sr", "597"],
            ["sj", "47", 1, ["4", "79", "9"]],
            ["se", "46", 0, null, "0"],
            ["ch", "41", 0, null, "0"],
            ["sy", "963", 0, null, "0"],
            ["tw", "886", 0, null, "0"],
            ["tj", "992"],
            ["tz", "255", 0, null, "0"],
            ["th", "66", 0, null, "0"],
            ["tl", "670"],
            ["tg", "228"],
            ["tk", "690"],
            ["to", "676"],
            ["tt", "1", 22, ["868"], "1"],
            ["tn", "216"],
            ["tr", "90", 0, null, "0"],
            ["tm", "993", 0, null, "8"],
            ["tc", "1", 23, ["649"], "1"],
            ["tv", "688"],
            ["vi", "1", 24, ["340"], "1"],
            ["ug", "256", 0, null, "0"],
            ["ua", "380", 0, null, "0"],
            ["ae", "971", 0, null, "0"],
            ["gb", "44", 0, null, "0"],
            ["us", "1", 0, null, "1"],
            ["uy", "598", 0, null, "0"],
            ["uz", "998"],
            ["vu", "678"],
            ["va", "39", 1, ["06698", "3"]],
            ["ve", "58", 0, null, "0"],
            ["vn", "84", 0, null, "0"],
            ["wf", "681"],
            ["eh", "212", 1, ["5288", "5289", "6", "7"], "0"],
            ["ye", "967", 0, null, "0"],
            ["zm", "260", 0, null, "0"],
            ["zw", "263", 0, null, "0"]
          ],
          ee = [];
        for (const Te of K) ee.push({
          name: "",
          iso2: Te[0],
          dialCode: Te[1],
          priority: Te[2] || 0,
          areaCodes: Te[3] || null,
          nodeById: {},
          nationalPrefix: Te[4] || null,
          normalisedName: "",
          initials: "",
          dialCodePlus: ""
        });
        var re = ee,
          de = {
            ad: "Andorra",
            ae: "United Arab Emirates",
            af: "Afghanistan",
            ag: "Antigua & Barbuda",
            ai: "Anguilla",
            al: "Albania",
            am: "Armenia",
            ao: "Angola",
            ar: "Argentina",
            as: "American Samoa",
            at: "Austria",
            au: "Australia",
            aw: "Aruba",
            ax: "√Öland Islands",
            az: "Azerbaijan",
            ba: "Bosnia & Herzegovina",
            bb: "Barbados",
            bd: "Bangladesh",
            be: "Belgium",
            bf: "Burkina Faso",
            bg: "Bulgaria",
            bh: "Bahrain",
            bi: "Burundi",
            bj: "Benin",
            bl: "St. Barth√©lemy",
            bm: "Bermuda",
            bn: "Brunei",
            bo: "Bolivia",
            bq: "Caribbean Netherlands",
            br: "Brazil",
            bs: "Bahamas",
            bt: "Bhutan",
            bw: "Botswana",
            by: "Belarus",
            bz: "Belize",
            ca: "Canada",
            cc: "Cocos (Keeling) Islands",
            cd: "Congo - Kinshasa",
            cf: "Central African Republic",
            cg: "Congo - Brazzaville",
            ch: "Switzerland",
            ci: "C√¥te d‚ÄôIvoire",
            ck: "Cook Islands",
            cl: "Chile",
            cm: "Cameroon",
            cn: "China",
            co: "Colombia",
            cr: "Costa Rica",
            cu: "Cuba",
            cv: "Cape Verde",
            cw: "Cura√ßao",
            cx: "Christmas Island",
            cy: "Cyprus",
            cz: "Czechia",
            de: "Germany",
            dj: "Djibouti",
            dk: "Denmark",
            dm: "Dominica",
            do: "Dominican Republic",
            dz: "Algeria",
            ec: "Ecuador",
            ee: "Estonia",
            eg: "Egypt",
            eh: "Western Sahara",
            er: "Eritrea",
            es: "Spain",
            et: "Ethiopia",
            fi: "Finland",
            fj: "Fiji",
            fk: "Falkland Islands",
            fm: "Micronesia",
            fo: "Faroe Islands",
            fr: "France",
            ga: "Gabon",
            gb: "United Kingdom",
            gd: "Grenada",
            ge: "Georgia",
            gf: "French Guiana",
            gg: "Guernsey",
            gh: "Ghana",
            gi: "Gibraltar",
            gl: "Greenland",
            gm: "Gambia",
            gn: "Guinea",
            gp: "Guadeloupe",
            gq: "Equatorial Guinea",
            gr: "Greece",
            gt: "Guatemala",
            gu: "Guam",
            gw: "Guinea-Bissau",
            gy: "Guyana",
            hk: "Hong Kong SAR China",
            hn: "Honduras",
            hr: "Croatia",
            ht: "Haiti",
            hu: "Hungary",
            id: "Indonesia",
            ie: "Ireland",
            il: "Israel",
            im: "Isle of Man",
            in: "India",
            io: "British Indian Ocean Territory",
            iq: "Iraq",
            ir: "Iran",
            is: "Iceland",
            it: "Italy",
            je: "Jersey",
            jm: "Jamaica",
            jo: "Jordan",
            jp: "Japan",
            ke: "Kenya",
            kg: "Kyrgyzstan",
            kh: "Cambodia",
            ki: "Kiribati",
            km: "Comoros",
            kn: "St. Kitts & Nevis",
            kp: "North Korea",
            kr: "South Korea",
            kw: "Kuwait",
            ky: "Cayman Islands",
            kz: "Kazakhstan",
            la: "Laos",
            lb: "Lebanon",
            lc: "St. Lucia",
            li: "Liechtenstein",
            lk: "Sri Lanka",
            lr: "Liberia",
            ls: "Lesotho",
            lt: "Lithuania",
            lu: "Luxembourg",
            lv: "Latvia",
            ly: "Libya",
            ma: "Morocco",
            mc: "Monaco",
            md: "Moldova",
            me: "Montenegro",
            mf: "St. Martin",
            mg: "Madagascar",
            mh: "Marshall Islands",
            mk: "North Macedonia",
            ml: "Mali",
            mm: "Myanmar (Burma)",
            mn: "Mongolia",
            mo: "Macao SAR China",
            mp: "Northern Mariana Islands",
            mq: "Martinique",
            mr: "Mauritania",
            ms: "Montserrat",
            mt: "Malta",
            mu: "Mauritius",
            mv: "Maldives",
            mw: "Malawi",
            mx: "Mexico",
            my: "Malaysia",
            mz: "Mozambique",
            na: "Namibia",
            nc: "New Caledonia",
            ne: "Niger",
            nf: "Norfolk Island",
            ng: "Nigeria",
            ni: "Nicaragua",
            nl: "Netherlands",
            no: "Norway",
            np: "Nepal",
            nr: "Nauru",
            nu: "Niue",
            nz: "New Zealand",
            om: "Oman",
            pa: "Panama",
            pe: "Peru",
            pf: "French Polynesia",
            pg: "Papua New Guinea",
            ph: "Philippines",
            pk: "Pakistan",
            pl: "Poland",
            pm: "St. Pierre & Miquelon",
            pr: "Puerto Rico",
            ps: "Palestinian Territories",
            pt: "Portugal",
            pw: "Palau",
            py: "Paraguay",
            qa: "Qatar",
            re: "R√©union",
            ro: "Romania",
            rs: "Serbia",
            ru: "Russia",
            rw: "Rwanda",
            sa: "Saudi Arabia",
            sb: "Solomon Islands",
            sc: "Seychelles",
            sd: "Sudan",
            se: "Sweden",
            sg: "Singapore",
            sh: "St. Helena",
            si: "Slovenia",
            sj: "Svalbard & Jan Mayen",
            sk: "Slovakia",
            sl: "Sierra Leone",
            sm: "San Marino",
            sn: "Senegal",
            so: "Somalia",
            sr: "Suriname",
            ss: "South Sudan",
            st: "S√£o Tom√© & Pr√≠ncipe",
            sv: "El Salvador",
            sx: "Sint Maarten",
            sy: "Syria",
            sz: "Eswatini",
            tc: "Turks & Caicos Islands",
            td: "Chad",
            tg: "Togo",
            th: "Thailand",
            tj: "Tajikistan",
            tk: "Tokelau",
            tl: "Timor-Leste",
            tm: "Turkmenistan",
            tn: "Tunisia",
            to: "Tonga",
            tr: "Turkey",
            tt: "Trinidad & Tobago",
            tv: "Tuvalu",
            tw: "Taiwan",
            tz: "Tanzania",
            ua: "Ukraine",
            ug: "Uganda",
            us: "United States",
            uy: "Uruguay",
            uz: "Uzbekistan",
            va: "Vatican City",
            vc: "St. Vincent & Grenadines",
            ve: "Venezuela",
            vg: "British Virgin Islands",
            vi: "U.S. Virgin Islands",
            vn: "Vietnam",
            vu: "Vanuatu",
            wf: "Wallis & Futuna",
            ws: "Samoa",
            ye: "Yemen",
            yt: "Mayotte",
            za: "South Africa",
            zm: "Zambia",
            zw: "Zimbabwe"
          },
          ne = de,
          Y = {
            selectedCountryAriaLabel: "Change country, selected ${countryName} (${dialCode})",
            noCountrySelected: "Select country",
            countryListAriaLabel: "List of countries",
            searchPlaceholder: "Search",
            clearSearchAriaLabel: "Clear search",
            zeroSearchResults: "No results found",
            oneSearchResult: "1 result found",
            multipleSearchResults: "${count} results found",
            ac: "Ascension Island",
            xk: "Kosovo"
          },
          we = Y,
          Ie = {
            ...ne,
            ...we
          },
          ze = Ie,
          Re = {
            OPEN_COUNTRY_DROPDOWN: "open:countrydropdown",
            CLOSE_COUNTRY_DROPDOWN: "close:countrydropdown",
            COUNTRY_CHANGE: "countrychange",
            INPUT: "input"
          },
          ke = {
            HIDE: "iti__hide",
            V_HIDE: "iti__v-hide",
            ARROW_UP: "iti__arrow--up",
            GLOBE: "iti__globe",
            FLAG: "iti__flag",
            COUNTRY_ITEM: "iti__country",
            HIGHLIGHT: "iti__highlight"
          },
          qe = {
            ARROW_UP: "ArrowUp",
            ARROW_DOWN: "ArrowDown",
            SPACE: " ",
            ENTER: "Enter",
            ESC: "Escape",
            TAB: "Tab"
          },
          $e = {
            PASTE: "insertFromPaste",
            DELETE_FWD: "deleteContentForward"
          },
          Be = {
            ALPHA_UNICODE: new RegExp("\\p{L}", "u"),
            NON_PLUS_NUMERIC: /[^+0-9]/,
            NON_PLUS_NUMERIC_GLOBAL: /[^+0-9]/g,
            HIDDEN_SEARCH_CHAR: /^[a-zA-Z√Ä-√ø–∞-—è–ê-–Ø ]$/
          },
          Ee = {
            HIDDEN_SEARCH_RESET_MS: 1e3
          },
          He = {
            UNKNOWN_NUMBER_TYPE: -99,
            UNKNOWN_VALIDATION_ERROR: -99
          },
          Le = {
            SANE_SELECTED_WITH_DIAL_WIDTH: 78,
            SANE_SELECTED_NO_DIAL_WIDTH: 42,
            INPUT_PADDING_EXTRA_LEFT: 6
          },
          it = {
            NANP: "1"
          },
          pt = {
            DIAL_CODE: "44",
            MOBILE_PREFIX: "7",
            MOBILE_CORE_LENGTH: 10
          },
          Oe = {
            ISO2: "us"
          },
          Je = {
            AGGRESSIVE: "aggressive",
            POLITE: "polite"
          },
          bt = {
            AUTO: "auto"
          },
          We = {
            COUNTRY_CODE: "countryCode",
            DIAL_CODE: "dialCode"
          },
          Ue = {
            EXPANDED: "aria-expanded",
            LABEL: "aria-label",
            SELECTED: "aria-selected",
            ACTIVE_DESCENDANT: "aria-activedescendant",
            HASPOPUP: "aria-haspopup",
            CONTROLS: "aria-controls",
            HIDDEN: "aria-hidden",
            AUTOCOMPLETE: "aria-autocomplete",
            MODAL: "aria-modal"
          },
          Ge = Te => typeof window < "u" && typeof window.matchMedia == "function" && window.matchMedia(Te).matches,
          Ve = () => {
            if (typeof navigator < "u" && typeof window < "u") {
              const Te = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                O = Ge("(max-width: 500px)"),
                E = Ge("(max-height: 600px)"),
                D = Ge("(pointer: coarse)");
              return Te || O || D && E
            }
            return !1
          },
          mt = {
            allowPhonewords: !1,
            allowDropdown: !0,
            autoPlaceholder: Je.POLITE,
            containerClass: "",
            countryOrder: null,
            countrySearch: !0,
            customPlaceholder: null,
            dropdownContainer: null,
            excludeCountries: [],
            fixDropdownWidth: !0,
            formatAsYouType: !0,
            formatOnDisplay: !0,
            geoIpLookup: null,
            hiddenInput: null,
            i18n: {},
            initialCountry: "",
            loadUtils: null,
            nationalMode: !0,
            onlyCountries: [],
            placeholderNumberType: "MOBILE",
            showFlags: !0,
            separateDialCode: !1,
            strictMode: !1,
            useFullscreenPopup: Ve(),
            validationNumberTypes: ["MOBILE"]
          },
          lt = (Te, O) => {
            Te.useFullscreenPopup && (Te.fixDropdownWidth = !1), Te.onlyCountries.length === 1 && (Te.initialCountry = Te.onlyCountries[0]), Te.separateDialCode && (Te.nationalMode = !1), Te.allowDropdown && !Te.showFlags && !Te.separateDialCode && (Te.nationalMode = !1), Te.useFullscreenPopup && !Te.dropdownContainer && (Te.dropdownContainer = document.body), Te.i18n = {
              ...O,
              ...Te.i18n
            }
          },
          yt = Te => Te.replace(/\D/g, ""),
          _t = (Te = "") => Te.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(),
          ut = (Te, O) => {
            const E = _t(O),
              D = [],
              N = [],
              H = [],
              W = [],
              ce = [],
              ve = [];
            for (const Se of Te) Se.iso2 === E ? D.push(Se) : Se.normalisedName.startsWith(E) ? N.push(Se) : Se.normalisedName.includes(E) ? H.push(Se) : E === Se.dialCode || E === Se.dialCodePlus ? W.push(Se) : Se.dialCodePlus.includes(E) ? ce.push(Se) : Se.initials.includes(E) && ve.push(Se);
            const he = (Se, Ye) => Se.priority - Ye.priority;
            return [...D.sort(he), ...N.sort(he), ...H.sort(he), ...W.sort(he), ...ce.sort(he), ...ve.sort(he)]
          },
          Ut = (Te, O) => {
            const E = O.toLowerCase();
            for (const D of Te)
              if (D.name.toLowerCase().startsWith(E)) return D;
            return null
          },
          Lt = Te => Object.keys(Te).filter(O => !!Te[O]).join(" "),
          Ke = (Te, O, E) => {
            const D = document.createElement(Te);
            return O && Object.entries(O).forEach(([N, H]) => D.setAttribute(N, H)), E && E.appendChild(D), D
          },
          ot = () => `
  <svg class="iti__search-icon-svg" width="14" height="14" viewBox="0 0 24 24" focusable="false" ${Ue.HIDDEN}="true">
    <circle cx="11" cy="11" r="7" />
    <line x1="21" y1="21" x2="16.65" y2="16.65" />
  </svg>`,
          xt = Te => {
            const O = `iti-${Te}-clear-mask`;
            return `
    <svg class="iti__search-clear-svg" width="12" height="12" viewBox="0 0 16 16" ${Ue.HIDDEN}="true" focusable="false">
      <mask id="${O}" maskUnits="userSpaceOnUse">
        <rect width="16" height="16" fill="white" />
        <path d="M5.2 5.2 L10.8 10.8 M10.8 5.2 L5.2 10.8" stroke="black" stroke-linecap="round" class="iti__search-clear-x" />
      </mask>
      <circle cx="8" cy="8" r="8" class="iti__search-clear-bg" mask="url(#${O})" />
    </svg>`
          },
          Ct = class {
            constructor(Te, O, E) {
              this.highlightedItem = null, Te.dataset.intlTelInputId = E.toString(), this.telInput = Te, this.options = O, this.id = E, this.hadInitialPlaceholder = !!Te.getAttribute("placeholder"), this.isRTL = !!this.telInput.closest("[dir=rtl]"), this.options.separateDialCode && (this.originalPaddingLeft = this.telInput.style.paddingLeft)
            }
            generateMarkup(Te) {
              this.countries = Te, this._prepareTelInput();
              const O = this._createWrapperAndInsert();
              this._maybeBuildCountryContainer(O), O.appendChild(this.telInput), this._maybeUpdateInputPaddingAndReveal(), this._maybeBuildHiddenInputs(O)
            }
            _prepareTelInput() {
              var Te;
              this.telInput.classList.add("iti__tel-input"), !this.telInput.hasAttribute("autocomplete") && !((Te = this.telInput.form) != null && Te.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off")
            }
            _createWrapperAndInsert() {
              const {
                allowDropdown: Te,
                showFlags: O,
                containerClass: E,
                useFullscreenPopup: D
              } = this.options, N = Lt({
                iti: !0,
                "iti--allow-dropdown": Te,
                "iti--show-flags": O,
                "iti--inline-dropdown": !D,
                [E]: !!E
              }), H = Ke("div", {
                class: N
              });
              return this.isRTL && H.setAttribute("dir", "ltr"), this.telInput.before(H), H
            }
            _maybeBuildCountryContainer(Te) {
              const {
                allowDropdown: O,
                separateDialCode: E,
                showFlags: D
              } = this.options;
              if (O || D || E) {
                this.countryContainer = Ke("div", {
                  class: `iti__country-container ${ke.V_HIDE}`
                }, Te), O ? (this.selectedCountry = Ke("button", {
                  type: "button",
                  class: "iti__selected-country",
                  [Ue.EXPANDED]: "false",
                  [Ue.LABEL]: this.options.i18n.noCountrySelected,
                  [Ue.HASPOPUP]: "dialog",
                  [Ue.CONTROLS]: `iti-${this.id}__dropdown-content`
                }, this.countryContainer), this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = Ke("div", {
                  class: "iti__selected-country"
                }, this.countryContainer);
                const N = Ke("div", {
                  class: "iti__selected-country-primary"
                }, this.selectedCountry);
                this.selectedCountryInner = Ke("div", {
                  class: ke.FLAG
                }, N), O && (this.dropdownArrow = Ke("div", {
                  class: "iti__arrow",
                  [Ue.HIDDEN]: "true"
                }, N)), E && (this.selectedDialCode = Ke("div", {
                  class: "iti__selected-dial-code"
                }, this.selectedCountry)), O && this._buildDropdownContent()
              }
            }
            _buildDropdownContent() {
              const {
                fixDropdownWidth: Te,
                useFullscreenPopup: O,
                countrySearch: E,
                i18n: D,
                dropdownContainer: N,
                containerClass: H
              } = this.options, W = Te ? "" : "iti--flexible-dropdown-width";
              if (this.dropdownContent = Ke("div", {
                  id: `iti-${this.id}__dropdown-content`,
                  class: `iti__dropdown-content ${ke.HIDE} ${W}`,
                  role: "dialog",
                  [Ue.MODAL]: "true"
                }), this.isRTL && this.dropdownContent.setAttribute("dir", "rtl"), E && this._buildSearchUI(), this.countryList = Ke("ul", {
                  class: "iti__country-list",
                  id: `iti-${this.id}__country-listbox`,
                  role: "listbox",
                  [Ue.LABEL]: D.countryListAriaLabel
                }, this.dropdownContent), this._appendListItems(), E && this.updateSearchResultsA11yText(), N) {
                const ce = Lt({
                  iti: !0,
                  "iti--container": !0,
                  "iti--fullscreen-popup": O,
                  "iti--inline-dropdown": !O,
                  [H]: !!H
                });
                this.dropdown = Ke("div", {
                  class: ce
                }), this.dropdown.appendChild(this.dropdownContent)
              } else this.countryContainer.appendChild(this.dropdownContent)
            }
            _buildSearchUI() {
              const {
                i18n: Te
              } = this.options, O = Ke("div", {
                class: "iti__search-input-wrapper"
              }, this.dropdownContent);
              this.searchIcon = Ke("span", {
                class: "iti__search-icon",
                [Ue.HIDDEN]: "true"
              }, O), this.searchIcon.innerHTML = ot(), this.searchInput = Ke("input", {
                id: `iti-${this.id}__search-input`,
                type: "search",
                class: "iti__search-input",
                placeholder: Te.searchPlaceholder,
                role: "combobox",
                [Ue.EXPANDED]: "true",
                [Ue.LABEL]: Te.searchPlaceholder,
                [Ue.CONTROLS]: `iti-${this.id}__country-listbox`,
                [Ue.AUTOCOMPLETE]: "list",
                autocomplete: "off"
              }, O), this.searchClearButton = Ke("button", {
                type: "button",
                class: `iti__search-clear ${ke.HIDE}`,
                [Ue.LABEL]: Te.clearSearchAriaLabel,
                tabindex: "-1"
              }, O), this.searchClearButton.innerHTML = xt(this.id), this.searchResultsA11yText = Ke("span", {
                class: "iti__a11y-text"
              }, this.dropdownContent), this.searchNoResults = Ke("div", {
                class: `iti__no-results ${ke.HIDE}`,
                [Ue.HIDDEN]: "true"
              }, this.dropdownContent), this.searchNoResults.textContent = Te.zeroSearchResults
            }
            _maybeUpdateInputPaddingAndReveal() {
              this.countryContainer && (this.updateInputPadding(), this.countryContainer.classList.remove(ke.V_HIDE))
            }
            _maybeBuildHiddenInputs(Te) {
              var E, D;
              const {
                hiddenInput: O
              } = this.options;
              if (O) {
                const N = this.telInput.getAttribute("name") || "",
                  H = O(N);
                if (H.phone) {
                  const W = (E = this.telInput.form) == null ? void 0 : E.querySelector(`input[name="${H.phone}"]`);
                  W ? this.hiddenInput = W : (this.hiddenInput = Ke("input", {
                    type: "hidden",
                    name: H.phone
                  }), Te.appendChild(this.hiddenInput))
                }
                if (H.country) {
                  const W = (D = this.telInput.form) == null ? void 0 : D.querySelector(`input[name="${H.country}"]`);
                  W ? this.hiddenInputCountry = W : (this.hiddenInputCountry = Ke("input", {
                    type: "hidden",
                    name: H.country
                  }), Te.appendChild(this.hiddenInputCountry))
                }
              }
            }
            _appendListItems() {
              const Te = document.createDocumentFragment();
              for (let O = 0; O < this.countries.length; O++) {
                const E = this.countries[O],
                  D = Lt({
                    [ke.COUNTRY_ITEM]: !0,
                    [ke.HIGHLIGHT]: O === 0
                  }),
                  N = Ke("li", {
                    id: `iti-${this.id}__item-${E.iso2}`,
                    class: D,
                    tabindex: "-1",
                    role: "option",
                    [Ue.SELECTED]: "false"
                  });
                N.dataset.dialCode = E.dialCode, N.dataset.countryCode = E.iso2, E.nodeById[this.id] = N, this.options.showFlags && Ke("div", {
                  class: `${ke.FLAG} iti__${E.iso2}`
                }, N);
                const H = Ke("span", {
                  class: "iti__country-name"
                }, N);
                H.textContent = E.name;
                const W = Ke("span", {
                  class: "iti__dial-code"
                }, N);
                this.isRTL && W.setAttribute("dir", "ltr"), W.textContent = `+${E.dialCode}`, Te.appendChild(N)
              }
              this.countryList.appendChild(Te)
            }
            updateInputPadding() {
              if (this.selectedCountry) {
                const Te = this.options.separateDialCode ? Le.SANE_SELECTED_WITH_DIAL_WIDTH : Le.SANE_SELECTED_NO_DIAL_WIDTH,
                  E = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth() || Te) + Le.INPUT_PADDING_EXTRA_LEFT;
                this.telInput.style.paddingLeft = `${E}px`
              }
            }
            _getHiddenSelectedCountryWidth() {
              if (this.telInput.parentNode) {
                let Te;
                try {
                  Te = window.top.document.body
                } catch {
                  Te = document.body
                }
                const O = this.telInput.parentNode.cloneNode(!1);
                O.style.visibility = "hidden", Te.appendChild(O);
                const E = this.countryContainer.cloneNode();
                O.appendChild(E);
                const D = this.selectedCountry.cloneNode(!0);
                E.appendChild(D);
                const N = D.offsetWidth;
                return Te.removeChild(O), N
              }
              return 0
            }
            updateSearchResultsA11yText() {
              const {
                i18n: Te
              } = this.options, O = this.countryList.childElementCount;
              let E;
              O === 0 ? E = Te.zeroSearchResults : Te.searchResultsText ? E = Te.searchResultsText(O) : O === 1 ? E = Te.oneSearchResult : E = Te.multipleSearchResults.replace("${count}", O.toString()), this.searchResultsA11yText.textContent = E
            }
            scrollTo(Te) {
              const O = this.countryList,
                E = document.documentElement.scrollTop,
                D = O.offsetHeight,
                N = O.getBoundingClientRect().top + E,
                H = N + D,
                W = Te.offsetHeight,
                ce = Te.getBoundingClientRect().top + E,
                ve = ce + W,
                he = ce - N + O.scrollTop;
              if (ce < N) O.scrollTop = he;
              else if (ve > H) {
                const Se = D - W;
                O.scrollTop = he - Se
              }
            }
            highlightListItem(Te, O) {
              const E = this.highlightedItem;
              if (E && (E.classList.remove(ke.HIGHLIGHT), E.setAttribute(Ue.SELECTED, "false")), this.highlightedItem = Te, this.highlightedItem && (this.highlightedItem.classList.add(ke.HIGHLIGHT), this.highlightedItem.setAttribute(Ue.SELECTED, "true"), this.options.countrySearch)) {
                const D = this.highlightedItem.getAttribute("id") || "";
                this.searchInput.setAttribute(Ue.ACTIVE_DESCENDANT, D)
              }
              O && this.highlightedItem.focus()
            }
            filterCountries(Te) {
              this.countryList.innerHTML = "";
              let O = !0;
              for (const E of Te) {
                const D = E.nodeById[this.id];
                D && (this.countryList.appendChild(D), O && (this.highlightListItem(D, !1), O = !1))
              }
              O ? (this.highlightListItem(null, !1), this.searchNoResults && this.searchNoResults.classList.remove(ke.HIDE)) : this.searchNoResults && this.searchNoResults.classList.add(ke.HIDE), this.countryList.scrollTop = 0, this.updateSearchResultsA11yText()
            }
            destroy() {
              this.telInput.iti = void 0, delete this.telInput.dataset.intlTelInputId, this.options.separateDialCode && (this.telInput.style.paddingLeft = this.originalPaddingLeft);
              const Te = this.telInput.parentNode;
              Te.before(this.telInput), Te.remove(), this.telInput = null, this.countryContainer = null, this.selectedCountry = null, this.selectedCountryInner = null, this.selectedDialCode = null, this.dropdownArrow = null, this.dropdownContent = null, this.searchInput = null, this.searchIcon = null, this.searchClearButton = null, this.searchNoResults = null, this.searchResultsA11yText = null, this.countryList = null, this.dropdown = null, this.hiddenInput = null, this.hiddenInputCountry = null, this.highlightedItem = null;
              for (const O of this.countries) delete O.nodeById[this.id];
              this.countries = null
            }
          },
          wt = Te => {
            const {
              onlyCountries: O,
              excludeCountries: E
            } = Te;
            if (O.length) {
              const D = O.map(N => N.toLowerCase());
              return re.filter(N => D.includes(N.iso2))
            } else if (E.length) {
              const D = E.map(N => N.toLowerCase());
              return re.filter(N => !D.includes(N.iso2))
            }
            return re
          },
          kt = (Te, O) => {
            for (const E of Te) {
              const D = E.iso2.toLowerCase();
              O.i18n[D] && (E.name = O.i18n[D])
            }
          },
          Zt = (Te, O) => {
            const E = new Set;
            let D = 0;
            const N = {},
              H = (W, ce, ve) => {
                if (!W || !ce) return;
                ce.length > D && (D = ce.length), N.hasOwnProperty(ce) || (N[ce] = []);
                const he = N[ce];
                if (he.includes(W)) return;
                const Se = ve !== void 0 ? ve : he.length;
                he[Se] = W
              };
            for (const W of Te) {
              E.has(W.dialCode) || E.add(W.dialCode);
              for (let ce = 1; ce < W.dialCode.length; ce++) {
                const ve = W.dialCode.substring(0, ce);
                H(W.iso2, ve)
              }
              H(W.iso2, W.dialCode, W.priority)
            }(O.onlyCountries.length || O.excludeCountries.length) && E.forEach(W => {
              N[W] = N[W].filter(Boolean)
            });
            for (const W of Te)
              if (W.areaCodes) {
                const ce = N[W.dialCode][0];
                for (const ve of W.areaCodes) {
                  for (let he = 1; he < ve.length; he++) {
                    const Se = ve.substring(0, he),
                      Ye = W.dialCode + Se;
                    H(ce, Ye), H(W.iso2, Ye)
                  }
                  H(W.iso2, W.dialCode + ve)
                }
              } return {
              dialCodes: E,
              dialCodeMaxLen: D,
              dialCodeToIso2Map: N
            }
          },
          Nt = (Te, O) => {
            O.countryOrder && (O.countryOrder = O.countryOrder.map(E => E.toLowerCase())), Te.sort((E, D) => {
              const {
                countryOrder: N
              } = O;
              if (N) {
                const H = N.indexOf(E.iso2),
                  W = N.indexOf(D.iso2),
                  ce = H > -1,
                  ve = W > -1;
                if (ce || ve) return ce && ve ? H - W : ce ? -1 : 1
              }
              return E.name.localeCompare(D.name)
            })
          },
          $t = Te => {
            for (const O of Te) O.normalisedName = _t(O.name), O.initials = O.normalisedName.split(/[^a-z]/).map(E => E[0]).join(""), O.dialCodePlus = `+${O.dialCode}`
          },
          It = (Te, O, E, D) => {
            let N = Te;
            if (E && O) {
              O = `+${D.dialCode}`;
              const H = N[O.length] === " " || N[O.length] === "-" ? O.length + 1 : O.length;
              N = N.substring(H)
            }
            return N
          },
          Xt = (Te, O, E, D, N) => {
            const H = E ? E.formatNumberAsYouType(Te, D.iso2) : Te,
              {
                dialCode: W
              } = D;
            return N && O.charAt(0) !== "+" && H.includes(`+${W}`) ? (H.split(`+${W}`)[1] || "").trim() : H
          },
          Ot = (Te, O, E, D) => {
            if (E === 0 && !D) return 0;
            let N = 0;
            for (let H = 0; H < O.length; H++) {
              if (/[+0-9]/.test(O[H]) && N++, N === Te && !D) return H + 1;
              if (D && N === Te + 1) return H
            }
            return O.length
          },
          jt = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"],
          qt = Te => {
            const O = yt(Te);
            if (O.startsWith(it.NANP) && O.length >= 4) {
              const E = O.substring(1, 4);
              return jt.includes(E)
            }
            return !1
          };
        for (const Te of re) Te.name = ze[Te.iso2];
        var fr = 0,
          Kt = new Set(re.map(Te => Te.iso2)),
          _r = Te => Kt.has(Te),
          rr = class Gy {
            constructor(O, E = {}) {
              this.id = fr++, this.options = {
                ...mt,
                ...E
              }, lt(this.options, ze), this.ui = new Ct(O, this.options, this.id), this.isAndroid = Gy._getIsAndroid(), this.promise = this._createInitPromises(), this.countries = wt(this.options);
              const {
                dialCodes: D,
                dialCodeMaxLen: N,
                dialCodeToIso2Map: H
              } = Zt(this.countries, this.options);
              this.dialCodes = D, this.dialCodeMaxLen = N, this.dialCodeToIso2Map = H, this.countryByIso2 = new Map(this.countries.map(W => [W.iso2, W])), this._init()
            }
            static _getIsAndroid() {
              return typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1
            }
            _createInitPromises() {
              const O = new Promise((D, N) => {
                  this.resolveAutoCountryPromise = D, this.rejectAutoCountryPromise = N
                }),
                E = new Promise((D, N) => {
                  this.resolveUtilsScriptPromise = D, this.rejectUtilsScriptPromise = N
                });
              return Promise.all([O, E])
            }
            _init() {
              this.selectedCountryData = {}, this.abortController = new AbortController, this._processCountryData(), this.ui.generateMarkup(this.countries), this._setInitialState(), this._initListeners(), this._initRequests()
            }
            _processCountryData() {
              kt(this.countries, this.options), Nt(this.countries, this.options), $t(this.countries)
            }
            _setInitialState(O = !1) {
              const E = this.ui.telInput.getAttribute("value"),
                D = this.ui.telInput.value,
                H = E && E.startsWith("+") && (!D || !D.startsWith("+")) ? E : D,
                W = this._getDialCode(H),
                ce = qt(H),
                {
                  initialCountry: ve,
                  geoIpLookup: he
                } = this.options,
                Se = ve === bt.AUTO && he;
              if (W && !ce) this._updateCountryFromNumber(H);
              else if (!Se || O) {
                const Ye = ve ? ve.toLowerCase() : "";
                _r(Ye) ? this._setCountry(Ye) : W && ce ? this._setCountry(Oe.ISO2) : this._setCountry("")
              }
              H && this._updateValFromNumber(H)
            }
            _initListeners() {
              this._initTelInputListeners(), this.options.allowDropdown && this._initDropdownListeners(), (this.ui.hiddenInput || this.ui.hiddenInputCountry) && this.ui.telInput.form && this._initHiddenInputListener()
            }
            _initHiddenInputListener() {
              var E;
              const O = () => {
                this.ui.hiddenInput && (this.ui.hiddenInput.value = this.getNumber()), this.ui.hiddenInputCountry && (this.ui.hiddenInputCountry.value = this.selectedCountryData.iso2 || "")
              };
              (E = this.ui.telInput.form) == null || E.addEventListener("submit", O, {
                signal: this.abortController.signal
              })
            }
            _initDropdownListeners() {
              const O = this.abortController.signal,
                E = W => {
                  this.ui.dropdownContent.classList.contains(ke.HIDE) ? this.ui.telInput.focus() : W.preventDefault()
                },
                D = this.ui.telInput.closest("label");
              D && D.addEventListener("click", E, {
                signal: O
              });
              const N = () => {
                this.ui.dropdownContent.classList.contains(ke.HIDE) && !this.ui.telInput.disabled && !this.ui.telInput.readOnly && this._openDropdown()
              };
              this.ui.selectedCountry.addEventListener("click", N, {
                signal: O
              });
              const H = W => {
                this.ui.dropdownContent.classList.contains(ke.HIDE) && [qe.ARROW_UP, qe.ARROW_DOWN, qe.SPACE, qe.ENTER].includes(W.key) && (W.preventDefault(), W.stopPropagation(), this._openDropdown()), W.key === qe.TAB && this._closeDropdown()
              };
              this.ui.countryContainer.addEventListener("keydown", H, {
                signal: O
              })
            }
            _initRequests() {
              const {
                loadUtils: O,
                initialCountry: E,
                geoIpLookup: D
              } = this.options;
              if (O && !Et.utils) {
                const H = () => {
                  var W;
                  (W = Et.attachUtils(O)) == null || W.catch(() => {})
                };
                if (Et.documentReady()) H();
                else {
                  const W = () => {
                    H()
                  };
                  window.addEventListener("load", W, {
                    signal: this.abortController.signal
                  })
                }
              } else this.resolveUtilsScriptPromise();
              E === bt.AUTO && D && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
            }
            _loadAutoCountry() {
              Et.autoCountry ? this.handleAutoCountry() : Et.startedLoadingAutoCountry || (Et.startedLoadingAutoCountry = !0, typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup((O = "") => {
                const E = O.toLowerCase();
                _r(E) ? (Et.autoCountry = E, setTimeout(() => nr("handleAutoCountry"))) : (this._setInitialState(!0), nr("rejectAutoCountryPromise"))
              }, () => {
                this._setInitialState(!0), nr("rejectAutoCountryPromise")
              }))
            }
            _openDropdownWithPlus() {
              this._openDropdown(), this.ui.searchInput.value = "+", this._filterCountriesByQuery("")
            }
            _initTelInputListeners() {
              this._bindInputListener(), this._maybeBindKeydownListener(), this._maybeBindPasteListener()
            }
            _bindInputListener() {
              const {
                strictMode: O,
                formatAsYouType: E,
                separateDialCode: D,
                allowDropdown: N,
                countrySearch: H
              } = this.options;
              let W = !1;
              Be.ALPHA_UNICODE.test(this.ui.telInput.value) && (W = !0);
              const ce = ve => {
                if (this.isAndroid && (ve == null ? void 0 : ve.data) === "+" && D && N && H) {
                  const Ze = this.ui.telInput.selectionStart || 0,
                    Tt = this.ui.telInput.value.substring(0, Ze - 1),
                    _e = this.ui.telInput.value.substring(Ze);
                  this.ui.telInput.value = Tt + _e, this._openDropdownWithPlus();
                  return
                }
                this._updateCountryFromNumber(this.ui.telInput.value) && this._triggerCountryChange();
                const he = (ve == null ? void 0 : ve.data) && Be.NON_PLUS_NUMERIC.test(ve.data),
                  Se = (ve == null ? void 0 : ve.inputType) === $e.PASTE && this.ui.telInput.value;
                he || Se && !O ? W = !0 : Be.NON_PLUS_NUMERIC.test(this.ui.telInput.value) || (W = !1);
                const Ye = (ve == null ? void 0 : ve.detail) && ve.detail.isSetNumber;
                if (E && !W && !Ye) {
                  const Ze = this.ui.telInput.selectionStart || 0,
                    _e = this.ui.telInput.value.substring(0, Ze).replace(Be.NON_PLUS_NUMERIC_GLOBAL, "").length,
                    Vt = (ve == null ? void 0 : ve.inputType) === $e.DELETE_FWD,
                    ur = this._getFullNumber(),
                    Ft = Xt(ur, this.ui.telInput.value, Et.utils, this.selectedCountryData, this.options.separateDialCode),
                    or = Ot(_e, Ft, Ze, Vt);
                  this.ui.telInput.value = Ft, this.ui.telInput.setSelectionRange(or, or)
                }
              };
              this.ui.telInput.addEventListener("input", ce, {
                signal: this.abortController.signal
              })
            }
            _maybeBindKeydownListener() {
              const {
                strictMode: O,
                separateDialCode: E,
                allowDropdown: D,
                countrySearch: N
              } = this.options;
              if (O || E) {
                const H = W => {
                  if (W.key && W.key.length === 1 && !W.altKey && !W.ctrlKey && !W.metaKey) {
                    if (E && D && N && W.key === "+") {
                      W.preventDefault(), this._openDropdownWithPlus();
                      return
                    }
                    if (O) {
                      const ce = this.ui.telInput.value,
                        he = !ce.startsWith("+") && this.ui.telInput.selectionStart === 0 && W.key === "+",
                        Se = /^[0-9]$/.test(W.key),
                        Ye = E ? Se : he || Se,
                        Ze = ce.slice(0, this.ui.telInput.selectionStart) + W.key + ce.slice(this.ui.telInput.selectionEnd),
                        Tt = this._getFullNumber(Ze),
                        _e = Et.utils.getCoreNumber(Tt, this.selectedCountryData.iso2),
                        Vt = this.maxCoreNumberLength && _e.length > this.maxCoreNumberLength,
                        Ft = this._getNewCountryFromNumber(Tt) !== null;
                      (!Ye || Vt && !Ft && !he) && W.preventDefault()
                    }
                  }
                };
                this.ui.telInput.addEventListener("keydown", H, {
                  signal: this.abortController.signal
                })
              }
            }
            _maybeBindPasteListener() {
              if (this.options.strictMode) {
                const O = E => {
                  E.preventDefault();
                  const D = this.ui.telInput,
                    N = D.selectionStart,
                    H = D.selectionEnd,
                    W = D.value.slice(0, N),
                    ce = D.value.slice(H),
                    ve = this.selectedCountryData.iso2,
                    he = E.clipboardData.getData("text"),
                    Se = N === 0 && H > 0,
                    Ye = !D.value.startsWith("+") || Se,
                    Ze = he.replace(Be.NON_PLUS_NUMERIC_GLOBAL, ""),
                    Tt = Ze.startsWith("+"),
                    _e = Ze.replace(/\+/g, ""),
                    Vt = Tt && Ye ? `+${_e}` : _e;
                  let ur = W + Vt + ce,
                    Ft = Et.utils.getCoreNumber(ur, ve);
                  for (; Ft.length === 0 && ur.length > 0;) ur = ur.slice(0, -1), Ft = Et.utils.getCoreNumber(ur, ve);
                  if (!Ft) return;
                  if (this.maxCoreNumberLength && Ft.length > this.maxCoreNumberLength)
                    if (D.selectionEnd === D.value.length) {
                      const Vr = Ft.length - this.maxCoreNumberLength;
                      ur = ur.slice(0, ur.length - Vr)
                    } else return;
                  D.value = ur;
                  const or = N + Vt.length;
                  D.setSelectionRange(or, or), D.dispatchEvent(new InputEvent("input", {
                    bubbles: !0
                  }))
                };
                this.ui.telInput.addEventListener("paste", O, {
                  signal: this.abortController.signal
                })
              }
            }
            _cap(O) {
              const E = Number(this.ui.telInput.getAttribute("maxlength"));
              return E && O.length > E ? O.substring(0, E) : O
            }
            _trigger(O, E = {}) {
              const D = new CustomEvent(O, {
                bubbles: !0,
                cancelable: !0,
                detail: E
              });
              this.ui.telInput.dispatchEvent(D)
            }
            _openDropdown() {
              const {
                fixDropdownWidth: O,
                countrySearch: E
              } = this.options;
              if (this.dropdownAbortController = new AbortController, O && (this.ui.dropdownContent.style.width = `${this.ui.telInput.offsetWidth}px`), this.ui.dropdownContent.classList.remove(ke.HIDE), this.ui.selectedCountry.setAttribute(Ue.EXPANDED, "true"), this._setDropdownPosition(), E) {
                const D = this.ui.countryList.firstElementChild;
                D && (this.ui.highlightListItem(D, !1), this.ui.countryList.scrollTop = 0), this.ui.searchInput.focus()
              }
              this._bindDropdownListeners(), this.ui.dropdownArrow.classList.add(ke.ARROW_UP), this._trigger(Re.OPEN_COUNTRY_DROPDOWN)
            }
            _setDropdownPosition() {
              if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.ui.dropdown), !this.options.useFullscreenPopup) {
                const O = this.ui.telInput.getBoundingClientRect(),
                  E = this.ui.telInput.offsetHeight;
                if (this.options.dropdownContainer) {
                  this.ui.dropdown.style.top = `${O.top+E}px`, this.ui.dropdown.style.left = `${O.left}px`;
                  const D = () => this._closeDropdown();
                  window.addEventListener("scroll", D, {
                    signal: this.dropdownAbortController.signal
                  })
                }
              }
            }
            _bindDropdownListeners() {
              const O = this.dropdownAbortController.signal;
              this._bindDropdownMouseoverListener(O), this._bindDropdownCountryClickListener(O), this._bindDropdownClickOffListener(O), this._bindDropdownKeydownListener(O), this.options.countrySearch && this._bindDropdownSearchListeners(O)
            }
            _bindDropdownMouseoverListener(O) {
              const E = D => {
                var H;
                const N = (H = D.target) == null ? void 0 : H.closest(`.${ke.COUNTRY_ITEM}`);
                N && this.ui.highlightListItem(N, !1)
              };
              this.ui.countryList.addEventListener("mouseover", E, {
                signal: O
              })
            }
            _bindDropdownCountryClickListener(O) {
              const E = D => {
                var H;
                const N = (H = D.target) == null ? void 0 : H.closest(`.${ke.COUNTRY_ITEM}`);
                N && this._selectListItem(N)
              };
              this.ui.countryList.addEventListener("click", E, {
                signal: O
              })
            }
            _bindDropdownClickOffListener(O) {
              const E = D => {
                !!D.target.closest(`#iti-${this.id}__dropdown-content`) || this._closeDropdown()
              };
              setTimeout(() => {
                document.documentElement.addEventListener("click", E, {
                  signal: O
                })
              }, 0)
            }
            _bindDropdownKeydownListener(O) {
              let E = "",
                D = null;
              const N = H => {
                [qe.ARROW_UP, qe.ARROW_DOWN, qe.ENTER, qe.ESC].includes(H.key) && (H.preventDefault(), H.stopPropagation(), H.key === qe.ARROW_UP || H.key === qe.ARROW_DOWN ? this._handleUpDownKey(H.key) : H.key === qe.ENTER ? this._handleEnterKey() : H.key === qe.ESC && this._closeDropdown()), !this.options.countrySearch && Be.HIDDEN_SEARCH_CHAR.test(H.key) && (H.stopPropagation(), D && clearTimeout(D), E += H.key.toLowerCase(), this._searchForCountry(E), D = setTimeout(() => {
                  E = ""
                }, Ee.HIDDEN_SEARCH_RESET_MS))
              };
              document.addEventListener("keydown", N, {
                signal: O
              })
            }
            _bindDropdownSearchListeners(O) {
              const E = () => {
                const W = this.ui.searchInput.value.trim();
                this._filterCountriesByQuery(W), this.ui.searchInput.value ? this.ui.searchClearButton.classList.remove(ke.HIDE) : this.ui.searchClearButton.classList.add(ke.HIDE)
              };
              let D = null;
              const N = () => {
                D && clearTimeout(D), D = setTimeout(() => {
                  E(), D = null
                }, 100)
              };
              this.ui.searchInput.addEventListener("input", N, {
                signal: O
              });
              const H = () => {
                this.ui.searchInput.value = "", this.ui.searchInput.focus(), E()
              };
              this.ui.searchClearButton.addEventListener("click", H, {
                signal: O
              })
            }
            _searchForCountry(O) {
              const E = Ut(this.countries, O);
              if (E) {
                const D = E.nodeById[this.id];
                this.ui.highlightListItem(D, !1), this.ui.scrollTo(D)
              }
            }
            _filterCountriesByQuery(O) {
              let E;
              O === "" ? E = this.countries : E = ut(this.countries, O), this.ui.filterCountries(E)
            }
            _handleUpDownKey(O) {
              var D, N;
              let E = O === qe.ARROW_UP ? (D = this.ui.highlightedItem) == null ? void 0 : D.previousElementSibling : (N = this.ui.highlightedItem) == null ? void 0 : N.nextElementSibling;
              !E && this.ui.countryList.childElementCount > 1 && (E = O === qe.ARROW_UP ? this.ui.countryList.lastElementChild : this.ui.countryList.firstElementChild), E && (this.ui.scrollTo(E), this.ui.highlightListItem(E, !1))
            }
            _handleEnterKey() {
              this.ui.highlightedItem && this._selectListItem(this.ui.highlightedItem)
            }
            _updateValFromNumber(O) {
              let E = O;
              if (this.options.formatOnDisplay && Et.utils && this.selectedCountryData) {
                const D = this.options.nationalMode || !E.startsWith("+") && !this.options.separateDialCode,
                  {
                    NATIONAL: N,
                    INTERNATIONAL: H
                  } = Et.utils.numberFormat,
                  W = D ? N : H;
                E = Et.utils.formatNumber(E, this.selectedCountryData.iso2, W)
              }
              E = this._beforeSetNumber(E), this.ui.telInput.value = E
            }
            _updateCountryFromNumber(O) {
              const E = this._getNewCountryFromNumber(O);
              return E !== null ? this._setCountry(E) : !1
            }
            _ensureHasDialCode(O) {
              const {
                dialCode: E,
                nationalPrefix: D
              } = this.selectedCountryData;
              if (O.startsWith("+") || !E) return O;
              const W = D && O.startsWith(D) && !this.options.separateDialCode ? O.substring(1) : O;
              return `+${E}${W}`
            }
            _getNewCountryFromNumber(O) {
              const E = O.indexOf("+");
              let D = E ? O.substring(E) : O;
              const N = this.selectedCountryData.iso2,
                H = this.selectedCountryData.dialCode;
              D = this._ensureHasDialCode(D);
              const W = this._getDialCode(D, !0),
                ce = yt(D);
              if (W) {
                const ve = yt(W),
                  he = this.dialCodeToIso2Map[ve];
                if (he.length === 1) return he[0] === N ? null : he[0];
                if (!N && this.defaultCountry && he.includes(this.defaultCountry)) return this.defaultCountry;
                if (H === it.NANP && qt(ce)) return null;
                const {
                  areaCodes: Ye,
                  priority: Ze
                } = this.selectedCountryData;
                if (Ye) {
                  const Ft = Ye.map(or => `${H}${or}`);
                  for (const or of Ft)
                    if (ce.startsWith(or)) return null
                }
                const _e = Ye && !(Ze === 0) && ce.length > ve.length,
                  Vt = N && he.includes(N) && !_e,
                  ur = N === he[0];
                if (!Vt && !ur) return he[0]
              } else if (D.startsWith("+") && ce.length) {
                const ve = this.selectedCountryData.dialCode || "";
                return ve && ve.startsWith(ce) ? null : ""
              } else if ((!D || D === "+") && !N) return this.defaultCountry;
              return null
            }
            _setCountry(O) {
              const {
                separateDialCode: E,
                showFlags: D,
                i18n: N
              } = this.options, H = this.selectedCountryData.iso2 || "";
              if (this.selectedCountryData = O ? this.countryByIso2.get(O) : {}, this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), this.ui.selectedCountry) {
                const W = O && D ? `${ke.FLAG} iti__${O}` : `${ke.FLAG} ${ke.GLOBE}`;
                let ce, ve;
                if (O) {
                  const {
                    name: he,
                    dialCode: Se
                  } = this.selectedCountryData;
                  ve = he, ce = N.selectedCountryAriaLabel.replace("${countryName}", he).replace("${dialCode}", `+${Se}`)
                } else ve = N.noCountrySelected, ce = N.noCountrySelected;
                this.ui.selectedCountryInner.className = W, this.ui.selectedCountry.setAttribute("title", ve), this.ui.selectedCountry.setAttribute(Ue.LABEL, ce)
              }
              if (E) {
                const W = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                this.ui.selectedDialCode.textContent = W, this.ui.updateInputPadding()
              }
              return this._updatePlaceholder(), this._updateMaxLength(), H !== O
            }
            _updateMaxLength() {
              const {
                strictMode: O,
                placeholderNumberType: E,
                validationNumberTypes: D
              } = this.options, {
                iso2: N
              } = this.selectedCountryData;
              if (O && Et.utils)
                if (N) {
                  const H = Et.utils.numberType[E];
                  let W = Et.utils.getExampleNumber(N, !1, H, !0),
                    ce = W;
                  for (; Et.utils.isPossibleNumber(W, N, D);) ce = W, W += "0";
                  const ve = Et.utils.getCoreNumber(ce, N);
                  this.maxCoreNumberLength = ve.length, N === "by" && (this.maxCoreNumberLength = ve.length + 1)
                } else this.maxCoreNumberLength = null
            }
            _updatePlaceholder() {
              const {
                autoPlaceholder: O,
                placeholderNumberType: E,
                nationalMode: D,
                customPlaceholder: N
              } = this.options, H = O === Je.AGGRESSIVE || !this.ui.hadInitialPlaceholder && O === Je.POLITE;
              if (Et.utils && H) {
                const W = Et.utils.numberType[E];
                let ce = this.selectedCountryData.iso2 ? Et.utils.getExampleNumber(this.selectedCountryData.iso2, D, W) : "";
                ce = this._beforeSetNumber(ce), typeof N == "function" && (ce = N(ce, this.selectedCountryData)), this.ui.telInput.setAttribute("placeholder", ce)
              }
            }
            _selectListItem(O) {
              const E = O.dataset[We.COUNTRY_CODE],
                D = this._setCountry(E);
              this._closeDropdown();
              const N = O.dataset[We.DIAL_CODE];
              this._updateDialCode(N), this.options.formatOnDisplay && this._updateValFromNumber(this.ui.telInput.value), this.ui.telInput.focus(), D && this._triggerCountryChange()
            }
            _closeDropdown() {
              this.ui.dropdownContent.classList.contains(ke.HIDE) || (this.ui.dropdownContent.classList.add(ke.HIDE), this.ui.selectedCountry.setAttribute(Ue.EXPANDED, "false"), this.ui.highlightedItem && this.ui.highlightedItem.setAttribute(Ue.SELECTED, "false"), this.options.countrySearch && this.ui.searchInput.removeAttribute(Ue.ACTIVE_DESCENDANT), this.ui.dropdownArrow.classList.remove(ke.ARROW_UP), this.dropdownAbortController.abort(), this.dropdownAbortController = null, this.options.dropdownContainer && this.ui.dropdown.remove(), this._trigger(Re.CLOSE_COUNTRY_DROPDOWN))
            }
            _updateDialCode(O) {
              const E = this.ui.telInput.value,
                D = `+${O}`;
              let N;
              if (E.startsWith("+")) {
                const H = this._getDialCode(E);
                H ? N = E.replace(H, D) : N = D, this.ui.telInput.value = N
              }
            }
            _getDialCode(O, E) {
              let D = "";
              if (O.startsWith("+")) {
                let N = "",
                  H = !1;
                for (let W = 0; W < O.length; W++) {
                  const ce = O.charAt(W);
                  if (/[0-9]/.test(ce)) {
                    if (N += ce, !!!this.dialCodeToIso2Map[N]) break;
                    if (this.dialCodes.has(N)) {
                      if (D = O.substring(0, W + 1), H = !0, !E) break
                    } else E && H && (D = O.substring(0, W + 1));
                    if (N.length === this.dialCodeMaxLen) break
                  }
                }
              }
              return D
            }
            _getFullNumber(O) {
              const E = O || this.ui.telInput.value.trim(),
                {
                  dialCode: D
                } = this.selectedCountryData;
              let N;
              const H = yt(E);
              return this.options.separateDialCode && !E.startsWith("+") && D && H ? N = `+${D}` : N = "", N + E
            }
            _beforeSetNumber(O) {
              const E = this._getDialCode(O),
                D = It(O, E, this.options.separateDialCode, this.selectedCountryData);
              return this._cap(D)
            }
            _triggerCountryChange() {
              this._trigger(Re.COUNTRY_CHANGE)
            }
            handleAutoCountry() {
              this.options.initialCountry === bt.AUTO && Et.autoCountry && (this.defaultCountry = Et.autoCountry, this.selectedCountryData.iso2 || this.ui.selectedCountryInner.classList.contains(ke.GLOBE) || this.setCountry(this.defaultCountry), this.resolveAutoCountryPromise())
            }
            handleUtils() {
              Et.utils && (this.ui.telInput.value && this._updateValFromNumber(this.ui.telInput.value), this.selectedCountryData.iso2 && (this._updatePlaceholder(), this._updateMaxLength())), this.resolveUtilsScriptPromise()
            }
            destroy() {
              this.ui.telInput && (this.options.allowDropdown && this._closeDropdown(), this.abortController.abort(), this.abortController = null, this.ui.destroy(), Et.instances instanceof Map ? Et.instances.delete(this.id) : delete Et.instances[this.id])
            }
            getExtension() {
              return Et.utils ? Et.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
            }
            getNumber(O) {
              if (Et.utils) {
                const {
                  iso2: E
                } = this.selectedCountryData;
                return Et.utils.formatNumber(this._getFullNumber(), E, O)
              }
              return ""
            }
            getNumberType() {
              return Et.utils ? Et.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : He.UNKNOWN_NUMBER_TYPE
            }
            getSelectedCountryData() {
              return this.selectedCountryData
            }
            getValidationError() {
              if (Et.utils) {
                const {
                  iso2: O
                } = this.selectedCountryData;
                return Et.utils.getValidationError(this._getFullNumber(), O)
              }
              return He.UNKNOWN_VALIDATION_ERROR
            }
            isValidNumber() {
              const {
                dialCode: O,
                iso2: E
              } = this.selectedCountryData;
              if (O === pt.DIAL_CODE && Et.utils) {
                const D = this._getFullNumber(),
                  N = Et.utils.getCoreNumber(D, E);
                if (N[0] === pt.MOBILE_PREFIX && N.length !== pt.MOBILE_CORE_LENGTH) return !1
              }
              return this._validateNumber(!1)
            }
            isValidNumberPrecise() {
              return this._validateNumber(!0)
            }
            _utilsIsPossibleNumber(O) {
              return Et.utils ? Et.utils.isPossibleNumber(O, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            _validateNumber(O) {
              if (!Et.utils) return null;
              if (!this.selectedCountryData.iso2) return !1;
              const E = W => O ? this._utilsIsValidNumber(W) : this._utilsIsPossibleNumber(W),
                D = this._getFullNumber(),
                N = D.search(Be.ALPHA_UNICODE);
              if (N > -1 && !this.options.allowPhonewords) {
                const W = D.substring(0, N),
                  ce = E(W),
                  ve = E(D);
                return ce && ve
              }
              return E(D)
            }
            _utilsIsValidNumber(O) {
              return Et.utils ? Et.utils.isValidNumber(O, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            setCountry(O) {
              const E = O == null ? void 0 : O.toLowerCase();
              if (!_r(E)) throw new Error(`Invalid country code: '${E}'`);
              const D = this.selectedCountryData.iso2;
              (O && E !== D || !O && D) && (this._setCountry(E), this._updateDialCode(this.selectedCountryData.dialCode), this.options.formatOnDisplay && this._updateValFromNumber(this.ui.telInput.value), this._triggerCountryChange())
            }
            setNumber(O) {
              const E = this._updateCountryFromNumber(O);
              this._updateValFromNumber(O), E && this._triggerCountryChange(), this._trigger(Re.INPUT, {
                isSetNumber: !0
              })
            }
            setPlaceholderNumberType(O) {
              this.options.placeholderNumberType = O, this._updatePlaceholder()
            }
            setDisabled(O) {
              this.ui.telInput.disabled = O, O ? this.ui.selectedCountry.setAttribute("disabled", "true") : this.ui.selectedCountry.removeAttribute("disabled")
            }
          },
          hr = Te => {
            if (!Et.utils && !Et.startedLoadingUtilsScript) {
              let O;
              if (typeof Te == "function") try {
                O = Promise.resolve(Te())
              } catch (E) {
                return Promise.reject(E)
              } else return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof Te}`));
              return Et.startedLoadingUtilsScript = !0, O.then(E => {
                const D = E == null ? void 0 : E.default;
                if (!D || typeof D != "object") throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                return Et.utils = D, nr("handleUtils"), !0
              }).catch(E => {
                throw nr("rejectUtilsScriptPromise", E), E
              })
            }
            return null
          },
          nr = (Te, ...O) => {
            Object.values(Et.instances).forEach(E => {
              const D = E[Te];
              typeof D == "function" && D.apply(E, O)
            })
          },
          Et = Object.assign((Te, O) => {
            const E = new rr(Te, O);
            return Et.instances[E.id] = E, Te.iti = E, E
          }, {
            defaults: mt,
            documentReady: () => document.readyState === "complete",
            getCountryData: () => re,
            getInstance: Te => {
              const O = Te.dataset.intlTelInputId;
              return O ? Et.instances[O] : null
            },
            instances: {},
            attachUtils: hr,
            startedLoadingUtilsScript: !1,
            startedLoadingAutoCountry: !1,
            version: "25.12.5"
          }),
          kr = Et;
        return B(j)
      })();
      return o.default
    })
  })(ym)), ym.exports
}
var i7 = n7();
const a7 = K0(i7);
var o7 = me('<div><span class="loading loading-spinner loading-xl"></span></div>'),
  s7 = me('<span class="w-8"> </span>'),
  l7 = me('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1),
  c7 = me('<span class="w-8"> </span>'),
  u7 = me('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1),
  h7 = me('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');

function d7(_, o) {
  zr(o, !0);
  let f = Qe(!0),
    x = Qe(""),
    A = Qe(0),
    L = Qe(!1);
  const w = ct(() => y(A) > 0 || y(L));
  let s = Qe(!1),
    B = Qe(""),
    j = Qe(void 0);
  const K = ct(() => {
    var we;
    return `phone:${(we=Mt.data)==null?void 0:we.id}`
  });
  Zr(() => {
    const we = localStorage.getItem(y(K));
    we && te(x, we, !0)
  }), Dn(() => {
    Jr.getOtpCooldown().then(ze => {
      te(A, ze.cooldownMs, !0)
    }).catch(ze => {
      vr.error(ze.message)
    }).finally(() => {
      te(f, !1)
    });
    const we = 1e3,
      Ie = setInterval(() => {
        te(A, Math.max(0, y(A) - we), !0)
      }, we);
    return () => {
      clearInterval(Ie)
    }
  });
  async function ee(we) {
    try {
      te(L, !0);
      const Ie = await Jr.sendOtp(we);
      vr.info(`${UC()} ${Ie.phone}`), te(x, Ie.phone, !0), te(A, Ie.cooldownMs, !0), localStorage.setItem(y(K), y(x))
    } catch (Ie) {
      vr.error(Ie.message)
    } finally {
      te(L, !1)
    }
  }
  Zr(() => {
    y(B).length === 6 && (te(s, !0), (async () => {
      try {
        await Jr.verifyOtp(y(B)), await Mt.refresh(), vr.success($C()), localStorage.removeItem(y(K)), o.onsuccess(y(x))
      } catch (we) {
        vr.error(we.message)
      } finally {
        te(B, ""), te(s, !1)
      }
    })())
  });
  var re = h7(),
    de = M(re);
  {
    var ne = we => {
        var Ie = o7();
        G(we, Ie)
      },
      Y = we => {
        var Ie = Jt(),
          ze = gt(Ie);
        {
          var Re = qe => {
              var $e = l7(),
                Be = gt($e),
                Ee = M(Be),
                He = M(Ee, !0);
              P(Ee);
              var Le = q(Ee, 2),
                it = M(Le, !0);
              P(Le), P(Be);
              var pt = q(Be, 2),
                Oe = M(pt);
              yi(Oe, () => Ge => (te(j, a7(Ge, {
                strictMode: !0,
                initialCountry: "br",
                loadUtils: () => qb(() => import("../chunks/DpLVk5gO.js"), [], import.meta.url),
                containerClass: "w-full",
                dropdownContainer: document.body
              })), () => {
                var Ve;
                (Ve = y(j)) == null || Ve.destroy()
              }));
              var Je = q(Oe, 2),
                bt = M(Je),
                We = q(bt);
              {
                var Ue = Ge => {
                  var Ve = s7(),
                    mt = M(Ve);
                  P(Ve), je(lt => le(mt, `(${lt??""})`), [() => Lp(y(A))]), G(Ge, Ve)
                };
                Ae(We, Ge => {
                  y(A) > 0 && Ge(Ue)
                })
              }
              P(Je), P(pt), je((Ge, Ve, mt) => {
                le(He, Ge), le(it, Ve), Je.disabled = y(w), le(bt, `${mt??""} `)
              }, [() => DP(), () => BP(), () => jP()]), Un("submit", pt, async () => {
                var Ve;
                if (y(w)) return;
                if (!((Ve = y(j)) != null && Ve.isValidNumber())) {
                  vr.error(XC());
                  return
                }
                const Ge = y(j).getNumber();
                await ee(Ge)
              }), G(qe, $e)
            },
            ke = qe => {
              var $e = u7(),
                Be = gt($e),
                Ee = M(Be),
                He = M(Ee, !0);
              P(Ee);
              var Le = q(Ee, 2),
                it = M(Le);
              P(Le), P(Be);
              var pt = q(Be, 2),
                Oe = M(pt);
              {
                const lt = (yt, _t) => {
                  let ut = () => _t == null ? void 0 : _t().cells;
                  var Ut = Jt(),
                    Lt = gt(Ut);
                  Ti(Lt, () => JR, (Ke, ot) => {
                    ot(Ke, {
                      class: "border-primary",
                      children: (xt, Ct) => {
                        var wt = Jt(),
                          kt = gt(wt);
                        ii(kt, 16, ut, Zt => Zt, (Zt, Nt) => {
                          var $t = Jt(),
                            It = gt($t);
                          Ti(It, () => t7, (Xt, Ot) => {
                            Ot(Xt, {
                              get cell() {
                                return Nt
                              },
                              class: "border-base-content/20 size-11 sm:size-12"
                            })
                          }), G(Zt, $t)
                        }), G(xt, wt)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  }), G(yt, Ut)
                };
                Ti(Oe, () => r7, (yt, _t) => {
                  _t(yt, {
                    maxlength: 6,
                    class: "mx-auto w-max",
                    get disabled() {
                      return y(s)
                    },
                    get value() {
                      return y(B)
                    },
                    set value(ut) {
                      te(B, ut, !0)
                    },
                    children: lt,
                    $$slots: {
                      default: !0
                    }
                  })
                })
              }
              P(pt);
              var Je = q(pt, 2),
                bt = M(Je);
              bt.__click = async () => {
                await ee(y(x))
              };
              var We = M(bt),
                Ue = q(We);
              {
                var Ge = lt => {
                  var yt = c7(),
                    _t = M(yt);
                  P(yt), je(ut => le(_t, `(${ut??""})`), [() => Lp(y(A))]), G(lt, yt)
                };
                Ae(Ue, lt => {
                  y(A) > 0 && lt(Ge)
                })
              }
              P(bt);
              var Ve = q(bt, 2);
              Ve.__click = () => {
                te(x, "")
              };
              var mt = M(Ve, !0);
              P(Ve), P(Je), je((lt, yt, _t, ut) => {
                le(He, lt), le(it, `${yt??""} ${y(x)??""}`), bt.disabled = y(w), le(We, `${_t??""} `), le(mt, ut)
              }, [() => UP(), () => $P(), () => XP(), () => JP()]), G(qe, $e)
            };
          Ae(ze, qe => {
            y(x) ? qe(ke, !1) : qe(Re)
          }, !0)
        }
        G(we, Ie)
      };
    Ae(de, we => {
      y(f) ? we(ne) : we(Y, !1)
    })
  }
  P(re), G(_, re), Lr()
}
Rn(["click"]);
var p7 = me('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <!></div></dialog>');

function f7(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  var x = p7(),
    A = M(x),
    L = q(M(A), 2);
  {
    var w = s => {
      d7(s, {
        onsuccess: () => f(!1)
      })
    };
    Ae(L, s => {
      f() && s(w)
    })
  }
  P(A), P(x), yi(x, () => s => {
    Zr(() => {
      f() ? s.show() : s.close()
    })
  }), Un("close", x, () => f(!1)), G(_, x), Lr()
}
var m7 = me('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <div class="tooltip tooltip-top"><div class="tooltip-content translate-x-[-30%] p-2"> </div> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog>');

function _7(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(!1),
    A = Qe(""),
    L = Qe(0),
    w = Qe(!1);
  Zr(() => {
    f() && (async () => {
      try {
        te(x, !0);
        const Ee = await Jr.getUserLastAppeal();
        if (Ee === null) {
          te(w, !1), te(L, 0);
          return
        }
        const He = new Date(Ee),
          Le = 1440 * 60 * 1e3;
        Date.now() - He.getTime() < 90 * Le ? (te(w, !0), te(L, Math.ceil((He.getTime() + 90 * Le - Date.now()) / Le), !0)) : te(L, 0)
      } catch (Ee) {
        vr.error(Ee.message)
      } finally {
        te(x, !1)
      }
    })()
  });
  var s = m7(),
    B = M(s),
    j = q(M(B), 2),
    K = M(j, !0);
  P(j);
  var ee = q(j, 2),
    re = M(ee),
    de = M(re);
  Gp(de, () => rM()), P(re);
  var ne = q(re, 2),
    Y = M(ne);
  {
    let Ee = ct(() => aM()),
      He = ct(() => lM()),
      Le = ct(() => y(x) || y(w));
    T0(Y, {
      get label() {
        return y(Ee)
      },
      get placeholder() {
        return y(He)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return y(Le)
      },
      get value() {
        return y(A)
      },
      set value(it) {
        te(A, it, !0)
      }
    })
  }
  P(ne);
  var we = q(ne, 2),
    Ie = M(we);
  Ie.__click = () => {
    f(!1)
  };
  var ze = M(Ie, !0);
  P(Ie);
  var Re = q(Ie, 2),
    ke = M(Re),
    qe = M(ke, !0);
  P(ke);
  var $e = q(ke, 2),
    Be = M($e, !0);
  P($e), P(Re), P(we), P(ee), P(B), P(s), yi(s, () => Ee => {
    Zr(() => {
      f() ? Ee.show() : Ee.close()
    })
  }), je((Ee, He, Le, it) => {
    le(K, Ee), Ie.disabled = y(x), le(ze, He), le(qe, Le), $e.disabled = y(x) || y(w) || y(A).length <= 1, le(Be, it)
  }, [() => o.userData.banned ? W0() : Q4(), () => cs(), () => y(w) ? xM({
    days: y(L)
  }) : "", () => hM()]), Un("close", s, () => f(!1)), Un("submit", ee, async () => {
    try {
      te(x, !0), await Jr.submitBanAppeal(y(A)), vr.success(fM()), f(!1)
    } catch (Ee) {
      vr.error(Ee.message, {
        duration: 5e3
      })
    } finally {
      te(x, !1)
    }
  }), G(_, s), Lr()
}
Rn(["click"]);
var g7 = me("<span> </span>");

function p0(_, o) {
  zr(o, !0);
  var f = g7(),
    x = M(f, !0);
  P(f), je(() => {
    Or(f, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${o.count<10?"text-xs":"text-[10px]"} ${o.class??""}`), le(x, o.count < 10 ? o.count : "9+")
  }), G(_, f), Lr()
}
var v7 = me('<p class="text-error mt-1 text-sm"> </p>'),
  y7 = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  x7 = me('<dialog class="modal !bg-black/80"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 border-1 mt-6 w-full py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function b7(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(""),
    A = Qe(null),
    L = Qe(!1),
    w = ct(() => {
      var Ge;
      return ((Ge = Mt.data) == null ? void 0 : Ge.name) ?? ""
    });
  Zr(() => {
    f() || (te(x, ""), te(A, null))
  });
  var s = x7(),
    B = M(s),
    j = q(M(B), 2),
    K = M(j);
  wb(K, {
    class: "text-error size-5"
  });
  var ee = q(K, 2),
    re = M(ee, !0);
  P(ee), P(j);
  var de = q(j, 2),
    ne = M(de),
    Y = M(ne, !0);
  P(ne);
  var we = q(ne);
  P(de);
  var Ie = q(de, 2),
    ze = M(Ie);
  P(Ie);
  var Re = q(Ie, 2),
    ke = M(Re, !0);
  P(Re);
  var qe = q(Re, 2);
  Ba(qe);
  var $e = q(qe, 2);
  {
    var Be = Ge => {
      var Ve = v7(),
        mt = M(Ve, !0);
      P(Ve), je(() => le(mt, y(A))), G(Ge, Ve)
    };
    Ae($e, Ge => {
      y(A) && Ge(Be)
    })
  }
  var Ee = q($e, 2),
    He = M(Ee);
  He.__click = () => {
    f(!1)
  };
  var Le = M(He, !0);
  P(He);
  var it = q(He, 2);
  it.__click = async () => {
    if (y(x) !== y(w)) {
      te(A, cb(), !0);
      return
    }
    try {
      te(L, !0), await Jr.deleteMe(y(w)), vr.warning(wP()), await Mt.logout(), f(!1)
    } catch (Ge) {
      vr.error(Ge.message)
    } finally {
      te(L, !1)
    }
  };
  var pt = M(it),
    Oe = q(pt);
  {
    var Je = Ge => {
      var Ve = y7();
      G(Ge, Ve)
    };
    Ae(Oe, Ge => {
      y(L) && Ge(Je)
    })
  }
  P(it), P(Ee), P(B);
  var bt = q(B, 2),
    We = M(bt),
    Ue = M(We, !0);
  P(We), P(bt), P(s), yi(s, () => Ge => {
    Zr(() => {
      f() ? Ge.show() : Ge.close()
    })
  }), je((Ge, Ve, mt, lt, yt, _t, ut, Ut, Lt) => {
    le(re, Ge), le(Y, Ve), le(we, ` ${mt??""}`), le(ze, `${lt??""} ${yt??""}`), le(ke, y(w)), mr(qe, "placeholder", _t), le(Le, ut), it.disabled = y(L), le(pt, `${Ut??""} `), le(Ue, Lt)
  }, [() => Im(), () => a5(), () => l5(), () => v4(), () => b4(), () => S4(), () => Gh(), () => Im(), () => cs()]), Un("close", s, () => f(!1)), $h(qe, () => y(x), Ge => te(x, Ge)), G(_, s), Lr()
}
Rn(["click"]);
var w7 = me('<p class="text-base-content/80 text-sm"> </p>'),
  T7 = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  S7 = me('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function C7(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = At(o, "type", 3, "confirmation"),
    A = At(o, "buttonText", 19, () => R0()),
    L = Qe(!1);
  M_(_, {
    dialogClass: "!bg-black/80",
    get open() {
      return f()
    },
    set open(w) {
      f(w)
    },
    children: (w, s) => {
      var B = S7(),
        j = gt(B),
        K = M(j, !0);
      P(j);
      var ee = q(j, 2),
        re = M(ee, !0);
      P(ee);
      var de = q(ee, 2);
      {
        var ne = Ee => {
          var He = w7(),
            Le = M(He, !0);
          P(He), je(() => le(Le, o.subDescription)), G(Ee, He)
        };
        Ae(de, Ee => {
          o.subDescription && Ee(ne)
        })
      }
      var Y = q(de, 2),
        we = M(Y),
        Ie = M(we),
        ze = M(Ie, !0);
      P(Ie), P(we);
      var Re = q(we, 2);
      let ke;
      Re.__click = async () => {
        try {
          te(L, !0), f(await o.onConfirm())
        } finally {
          te(L, !1)
        }
      };
      var qe = M(Re),
        $e = q(qe);
      {
        var Be = Ee => {
          var He = T7();
          G(Ee, He)
        };
        Ae($e, Ee => {
          y(L) && Ee(Be)
        })
      }
      P(Re), P(Y), je(Ee => {
        le(K, o.title), le(re, o.description), le(ze, Ee), ke = Or(Re, 1, "btn relative", null, ke, {
          "btn-error": x() === "warning",
          "btn-primary": x() === "confirmation"
        }), Re.disabled = y(L), le(qe, `${A()??""} `)
      }, [() => Gh()]), G(w, B)
    },
    $$slots: {
      default: !0
    }
  }), Lr()
}
Rn(["click"]);

function P7(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  {
    let x = ct(() => C0()),
      A = ct(() => d4()),
      L = ct(() => I4());
    C7(_, {
      type: "warning",
      get title() {
        return y(x)
      },
      get description() {
        return y(A)
      },
      get subDescription() {
        return y(L)
      },
      onConfirm: async () => {
        try {
          return await Jr.deleteSessions(), vr.success(Tb()), await Mt.logout(), !0
        } catch {
          return vr.error(Sb()), !1
        }
      },
      get open() {
        return f()
      },
      set open(w) {
        f(w)
      }
    })
  }
  Lr()
}
var I7 = me('<span class="center-absolute loading loading-spinner absolute"></span>'),
  M7 = me('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  A7 = me('<span class="center-absolute loading loading-spinner absolute"></span>'),
  k7 = me('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  E7 = me('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  z7 = me('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  L7 = me('<button class="btn btn-error btn-soft"><!> </button>'),
  D7 = me('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="tooltip flex w-full flex-col gap-3 max-sm:overflow-x-hidden"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!>', 1);

function R7(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(Si(o.userData.name)),
    A = Qe(Si(o.userData.discord)),
    L = Qe(Si(o.userData.showLastPixel)),
    w = Qe(!1),
    s = Qe(void 0),
    B = Qe(!1),
    j = Qe(!1);
  const K = ub("2025-09_discord_linking");
  let ee = Qe(!!o.userData.discordId),
    re = Qe(void 0),
    de = Qe(void 0);
  Zr(() => {
    te(x, o.userData.name, !0), te(L, o.userData.showLastPixel, !0)
  }), Zr(() => {
    f() && !y(s) && Jr.getMyProfilePictures().then(qt => {
      te(s, qt, !0)
    }).catch(qt => {
      vr.error(qt.message)
    })
  });
  let ne = Qe(!1);
  async function Y(qt) {
    try {
      te(ne, !0), await Jr.changeProfilePicture(qt), await Mt.refresh()
    } finally {
      te(ne, !1)
    }
  }
  var we = D7(),
    Ie = gt(we),
    ze = M(Ie),
    Re = q(M(ze), 2),
    ke = M(Re, !0);
  P(Re);
  var qe = q(Re, 2),
    $e = M(qe),
    Be = M($e),
    Ee = M(Be),
    He = M(Ee);
  mo(He, {
    class: "size-30",
    get userId() {
      return o.userData.id
    },
    get pictureUrl() {
      return o.userData.picture
    }
  });
  var Le = q(He, 2),
    it = M(Le);
  k0(it, {
    class: "size-5"
  }), P(Le), P(Ee);
  var pt = q(Ee, 2);
  {
    var Oe = qt => {
      var fr = E7(),
        Kt = M(fr),
        _r = M(Kt, !0);
      P(Kt);
      var rr = q(Kt, 2),
        hr = M(rr);
      {
        var nr = kr => {
          var Te = M7();
          Te.__click = () => {
            Y()
          };
          var O = M(Te);
          mo(O, {
            class: "size-10 border",
            get userId() {
              return o.userData.id
            }
          });
          var E = q(O, 2);
          {
            var D = N => {
              var H = I7();
              G(N, H)
            };
            Ae(E, N => {
              y(ne) && N(D)
            })
          }
          P(Te), je(() => Te.disabled = y(ne)), G(kr, Te)
        };
        Ae(hr, kr => {
          o.userData.picture && kr(nr)
        })
      }
      var Et = q(hr, 2);
      ii(Et, 17, () => y(s), kr => kr.id, (kr, Te) => {
        var O = Jt(),
          E = gt(O);
        {
          var D = N => {
            var H = k7();
            H.__click = () => {
              Y(y(Te).id)
            };
            var W = M(H);
            mo(W, {
              class: "size-10 border",
              get userId() {
                return o.userData.id
              },
              get pictureUrl() {
                return y(Te).url
              }
            });
            var ce = q(W, 2);
            {
              var ve = he => {
                var Se = A7();
                G(he, Se)
              };
              Ae(ce, he => {
                y(ne) && he(ve)
              })
            }
            P(H), je(() => H.disabled = y(ne)), G(N, H)
          };
          Ae(E, N => {
            o.userData.picture !== y(Te).url && N(D)
          })
        }
        G(kr, O)
      }), P(rr), P(fr), je(kr => le(_r, kr), [() => Kw()]), G(qt, fr)
    };
    Ae(pt, qt => {
      var fr;
      (fr = y(s)) != null && fr.length && qt(Oe)
    })
  }
  P(Be);
  var Je = q(Be, 2),
    bt = M(Je);
  {
    let qt = ct(() => Mm()),
      fr = ct(() => Mm());
    Em(bt, {
      get label() {
        return y(qt)
      },
      get placeholder() {
        return y(fr)
      },
      min: 1,
      max: 16,
      get value() {
        return y(x)
      },
      set value(Kt) {
        te(x, Kt, !0)
      },
      get validate() {
        return y(re)
      },
      set validate(Kt) {
        te(re, Kt, !0)
      }
    })
  }
  var We = q(bt, 2);
  {
    var Ue = qt => {
        var fr = Jt(),
          Kt = gt(fr);
        {
          var _r = hr => {
              var nr = z7(),
                Et = M(nr);
              Lm(Et, {
                class: "size-4.5"
              });
              var kr = q(Et);
              P(nr), je((Te, O) => {
                mr(nr, "href", Te), le(kr, ` ${O??""}`)
              }, [() => hb("/discord/authorize"), () => _P()]), G(hr, nr)
            },
            rr = hr => {
              var nr = L7();
              nr.__click = async () => {
                try {
                  te(w, !0), await Jr.unlinkDiscord(), Mt.refresh(), vr.success(pP()), te(ee, !1)
                } catch (Te) {
                  vr.error(Te.message, {
                    duration: 5e3
                  })
                } finally {
                  te(w, !1)
                }
              };
              var Et = M(nr);
              Lm(Et, {
                class: "size-4.5"
              });
              var kr = q(Et);
              P(nr), je(Te => {
                nr.disabled = y(w), le(kr, ` ${Te??""}`)
              }, [() => {
                var Te;
                return yP({
                  username: ((Te = o.userData) == null ? void 0 : Te.discord) ?? ""
                })
              }]), G(hr, nr)
            };
          Ae(Kt, hr => {
            y(ee) ? hr(rr, !1) : hr(_r)
          })
        }
        G(qt, fr)
      },
      Ge = qt => {
        {
          let fr = ct(() => J3());
          Em(qt, {
            label: "Discord",
            get placeholder() {
              return y(fr)
            },
            max: 32,
            get value() {
              return y(A)
            },
            set value(Kt) {
              te(A, Kt, !0)
            },
            get validate() {
              return y(de)
            },
            set validate(Kt) {
              te(de, Kt, !0)
            }
          })
        }
      };
    Ae(We, qt => {
      K ? qt(Ue) : qt(Ge, !1)
    })
  }
  var Ve = q(We, 2),
    mt = M(Ve);
  Ba(mt);
  var lt = q(mt);
  P(Ve), P(Je), P($e);
  var yt = q($e, 2),
    _t = M(yt),
    ut = M(_t),
    Ut = M(ut, !0);
  P(ut);
  var Lt = q(ut, 2),
    Ke = M(Lt),
    ot = M(Ke);
  ot.__click = () => {
    te(j, !0)
  };
  var xt = M(ot, !0);
  P(ot), P(Ke);
  var Ct = q(Ke, 2),
    wt = M(Ct);
  wt.__click = () => {
    te(B, !0)
  };
  var kt = M(wt, !0);
  P(wt), P(Ct), P(Lt), P(_t);
  var Zt = q(_t, 2),
    Nt = M(Zt);
  Nt.__click = () => {
    f(!1)
  };
  var $t = M(Nt, !0);
  P(Nt);
  var It = q(Nt, 2),
    Xt = M(It, !0);
  P(It), P(Zt), P(yt), P(qe), P(ze), P(Ie), yi(Ie, () => qt => {
    Zr(() => {
      f() ? qt.show() : qt.close()
    })
  });
  var Ot = q(Ie, 2);
  b7(Ot, {
    get open() {
      return y(B)
    },
    set open(qt) {
      te(B, qt, !0)
    }
  });
  var jt = q(Ot, 2);
  P7(jt, {
    get open() {
      return y(j)
    },
    set open(qt) {
      te(j, qt, !0)
    }
  }), je((qt, fr, Kt, _r, rr, hr, nr, Et, kr) => {
    le(ke, qt), mr(Le, "data-tip", fr), mr(Je, "data-tip", Kt), le(lt, ` ${_r??""}`), le(Ut, rr), le(xt, hr), le(kt, nr), Nt.disabled = y(w), le($t, Et), It.disabled = y(w), le(Xt, kr)
  }, [() => tI(), () => Ob(), () => H4(), () => e5(), () => m4(), () => C0(), () => Im(), () => cs(), () => Db()]), Un("close", Ie, () => f(!1)), Un("submit", qe, async () => {
    var qt;
    try {
      if (!((qt = y(re)) != null && qt())) return;
      te(w, !0), await Jr.updateMe({
        name: y(x),
        showLastPixel: y(L)
      }), Mt.refresh(), vr.success(sP()), f(!1)
    } catch (fr) {
      vr.error(fr.message, {
        duration: 5e3
      })
    } finally {
      te(w, !1)
    }
  }), Eb(mt, () => y(L), qt => te(L, qt)), G(_, we), Lr()
}
Rn(["click"]);
var F7 = Dr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function B7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = F7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var O7 = Dr('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function N7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = O7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var j7 = Dr('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function V7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = j7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var q7 = Dr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function f0(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = q7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var U7 = Dr('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function Z7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = U7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var G7 = Dr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function $7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = G7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var H7 = Dr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function W7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = H7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...f
  }), void 0, void 0, void 0, "svelte-14mu38d"), G(_, x)
}
var X7 = Dr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function a_(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = X7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var Y7 = Dr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function xm(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Y7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var K7 = Dr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function J7(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = K7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var Q7 = Dr('<svg><path fill="#fff" d="m2200 1300-400 400h-400l-350 350v-350H600V200h1600z"></path><g fill="#9146ff"><path d="M500 0 0 500v1800h600v500l500-500h400l900-900V0H500zm1700 1300-400 400h-400l-350 350v-350H600V200h1600v1100z"></path><path d="M1700 550h200v600h-200zm-550 0h200v600h-200z"></path></g></svg>');

function eF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = Q7();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xml:space": "preserve",
    viewBox: "0 0 2400 2800",
    ...f
  })), G(_, x)
}
var tF = Dr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function rF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = tF();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var nF = Dr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function iF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = nF();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var aF = me('<span class="tooltip font-flag ml-0.5"> </span>'),
  oF = me('<div class="mt-1"><!></div>'),
  sF = me('<p class="w-full"> <!></p>'),
  lF = me('<p class="w-full"><!></p>'),
  cF = me('<div class=" flex items-center gap-[8px]"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  uF = me('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  hF = me("<li><button><!> </button></li>"),
  dF = me('<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'),
  pF = me('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  fF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  mF = me('<a class="btn w-full" target="_blank"><!> </a>'),
  _F = me('<a class="btn w-full" target="_blank"><!> </a>'),
  gF = me('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1),
  vF = me('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <button class="btn btn-sm btn-circle relative"><!> <!></button></div></div>  <!> <!> <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function yF(_, o) {
  zr(o, !0);
  let f = Qe(!1),
    x = Qe(!1);

  function A() {
    var re;
    (re = document.activeElement) == null || re.blur()
  }
  const L = [{
    label: "üá∫üá∏ English",
    key: "en"
  }, {
    label: "üáßüá∑ Portugu√™s",
    key: "pt"
  }];
  let w = Qe(""),
    s = Qe(void 0);
  const B = ct(() => {
    var re;
    return !!((re = o.user.data) != null && re.banned) || !!o.user.timeoutUntil
  });
  var j = Jt(),
    K = gt(j);
  {
    var ee = re => {
      var de = vF(),
        ne = gt(de),
        Y = M(ne);
      let we;
      var Ie = M(Y);
      L0(Ie, {
        get userId() {
          return o.user.data.id
        },
        get level() {
          return o.user.data.level
        },
        get pictureUrl() {
          return o.user.data.picture
        }
      });
      var ze = q(Ie, 2);
      {
        var Re = st => {
          p0(st, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return o.user.notificiationCount
            }
          })
        };
        Ae(ze, st => {
          o.user.notificiationCount && st(Re)
        })
      }
      P(Y);
      var ke = q(Y, 2),
        qe = M(ke);
      qe.__click = A;
      var $e = M(qe);
      Bs($e, {
        class: "size-5"
      }), P(qe);
      var Be = q(qe, 2),
        Ee = M(Be),
        He = M(Ee);
      mo(He, {
        get userId() {
          return o.user.data.id
        },
        get pictureUrl() {
          return o.user.data.picture
        },
        get isSuspended() {
          return y(B)
        }
      });
      var Le = q(He, 2);
      Le.__click = () => {
        te(f, !0)
      };
      var it = M(Le);
      zm(it, {
        class: "size-4"
      }), P(Le), P(Ee);
      var pt = q(Ee, 2),
        Oe = M(pt),
        Je = M(Oe),
        bt = M(Je, !0);
      P(Je);
      var We = q(Je, 2),
        Ue = M(We);
      P(We);
      var Ge = q(We, 2);
      {
        var Ve = st => {
          const Me = ct(() => Ao(o.user.data.equippedFlag));
          var ft = aF(),
            zt = M(ft, !0);
          P(ft), je(() => {
            mr(ft, "data-tip", y(Me).name), le(zt, y(Me).flag)
          }), G(st, ft)
        };
        Ae(Ge, st => {
          o.user.data.equippedFlag && st(Ve)
        })
      }
      var mt = q(Ge, 2);
      {
        var lt = st => {
          var Me = oF(),
            ft = M(Me);
          Hh(ft, {
            get username() {
              return o.user.data.discord
            },
            get id() {
              return o.user.data.discordId
            }
          }), P(Me), G(st, Me)
        };
        Ae(mt, st => {
          o.user.data.discord && st(lt)
        })
      }
      P(Oe);
      var yt = q(Oe, 2),
        _t = M(yt);
      Wh(_t, {
        class: "inline size-4"
      });
      var ut = q(_t, 2),
        Ut = M(ut),
        Lt = q(Ut),
        Ke = M(Lt, !0);
      P(Lt), P(ut), P(yt);
      var ot = q(yt, 2),
        xt = M(ot);
      B7(xt, {
        class: "inline size-4"
      });
      var Ct = q(xt, 2),
        wt = M(Ct),
        kt = M(wt);
      P(wt);
      var Zt = q(wt),
        Nt = q(Zt),
        $t = M(Nt);
      ah($t, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), P(Nt), P(Ct), P(ot), P(pt), P(Be);
      var It = q(Be, 2),
        Xt = M(It);
      {
        var Ot = st => {
          var Me = cF(),
            ft = M(Me);
          a_(ft, {
            class: "size-6 text-red-500"
          });
          var zt = q(ft, 2);
          {
            var ar = Ir => {
                var wr = sF(),
                  Xr = M(wr),
                  Mr = q(Xr);
                {
                  var nn = dn => {
                      var _n = ji();
                      je(Yn => le(_n, `(${Yn??""})`), [() => Rv({
                        reason: fb()
                      })]), G(dn, _n)
                    },
                    sn = dn => {
                      var _n = Jt(),
                        Yn = gt(_n);
                      {
                        var fi = fn => {
                          var oi = ji();
                          je(ti => le(oi, `(${ti??""})`), [() => Rv({
                            reason: mb()
                          })]), G(fn, oi)
                        };
                        Ae(Yn, fn => {
                          o.user.data.suspensionReason === "multi-accounting" && fn(fi)
                        }, !0)
                      }
                      G(dn, _n)
                    };
                  Ae(Mr, dn => {
                    o.user.data.suspensionReason === "bot" ? dn(nn) : dn(sn, !1)
                  })
                }
                P(wr), je(dn => le(Xr, `${dn??""} `), [() => db()]), G(Ir, wr)
              },
              br = Ir => {
                var wr = Jt(),
                  Xr = gt(wr);
                {
                  var Mr = nn => {
                    var sn = lF(),
                      dn = M(sn);
                    Gp(dn, () => pb({
                      until: `<span class="text-secondary font-medium text-nowrap">${o.user.timeoutUntil.toLocaleString()}</span>`
                    })), P(sn), G(nn, sn)
                  };
                  Ae(Xr, nn => {
                    o.user.timeoutUntil && nn(Mr)
                  }, !0)
                }
                G(Ir, wr)
              };
            Ae(zt, Ir => {
              var wr;
              (wr = o.user.data) != null && wr.banned ? Ir(ar) : Ir(br, !1)
            })
          }
          var Tr = q(zt, 2);
          Tr.__click = Ir => {
            var wr;
            (wr = o.onbanappeal) == null || wr.call(o)
          };
          var Dt = M(Tr);
          a_(Dt, {
            class: "size-5 text-red-500"
          });
          var Br = q(Dt, 1, !0);
          P(Tr), P(Me), je(Ir => le(Br, Ir), [() => TM()]), G(st, Me)
        };
        Ae(Xt, st => {
          y(B) && st(Ot)
        })
      }
      var jt = q(Xt, 2),
        qt = M(jt),
        fr = M(qt, !0);
      P(qt);
      var Kt = q(qt, 2),
        _r = M(Kt),
        rr = M(_r),
        hr = M(rr);
      J7(hr, {
        class: "size-4"
      }), P(rr);
      var nr = q(rr, 2);
      ii(nr, 21, () => L, Hp, (st, Me) => {
        const ft = ct(() => y(w) === y(Me).key);
        var zt = hF(),
          ar = M(zt);
        let br;
        ar.__click = () => {
          localStorage.setItem(xb, y(Me).key), te(w, y(Me).key, !0), location.reload()
        };
        var Tr = M(ar);
        {
          var Dt = Ir => {
            var wr = uF();
            G(Ir, wr)
          };
          Ae(Tr, Ir => {
            y(ft) && Ir(Dt)
          })
        }
        var Br = q(Tr);
        P(ar), P(zt), je(() => {
          br = Or(ar, 1, "font-flag relative font-medium", null, br, {
            "bg-base-200": y(ft)
          }), le(Br, ` ${y(Me).label??""}`)
        }), G(st, zt)
      }), P(nr), P(_r);
      var Et = q(_r, 2),
        kr = M(Et);
      kr.__click = () => {
        fa.muted = !fa.muted
      };
      var Te = M(kr);
      {
        var O = st => {
            rF(st, {
              class: "size-4"
            })
          },
          E = st => {
            iF(st, {
              class: "size-4"
            })
          };
        Ae(Te, st => {
          fa.muted ? st(O) : st(E, !1)
        })
      }
      P(kr), P(Et);
      var D = q(Et, 2);
      {
        var N = st => {
          var Me = dF(),
            ft = M(Me);
          ft.__click = () => {
            fa.theme = fa.theme === "dark" ? "custom-winter" : "dark"
          };
          var zt = M(ft);
          {
            var ar = Tr => {
                V7(Tr, {
                  class: "size-4"
                })
              },
              br = Tr => {
                N7(Tr, {
                  class: "size-4"
                })
              };
            Ae(zt, Tr => {
              fa.theme === "dark" ? Tr(ar) : Tr(br, !1)
            })
          }
          P(ft), P(Me), je(Tr => mr(Me, "data-tip", Tr), [() => fa.theme === "dark" ? c4() : o4()]), G(st, Me)
        };
        Ae(D, st => {
          var Me, ft;
          Ra((ft = (Me = o.user) == null ? void 0 : Me.data) == null ? void 0 : ft.role, ["admin", "moderator", "global_moderator"]) && st(N)
        })
      }
      var H = q(D, 2);
      H.__click = function(...st) {
        var Me;
        (Me = o.onnotificationclick) == null || Me.apply(this, st)
      };
      var W = M(H);
      Z7(W, {
        class: "size-4"
      });
      var ce = q(W, 2);
      {
        var ve = st => {
          p0(st, {
            class: "absolute -right-1 -top-1",
            get count() {
              return o.user.notificiationCount
            }
          })
        };
        Ae(ce, st => {
          o.user.notificiationCount && st(ve)
        })
      }
      P(H), P(Kt), P(jt);
      var he = q(jt, 2);
      {
        var Se = st => {
          var Me = pF();
          Me.__click = async () => {
            var ar;
            try {
              const br = await ((ar = y(s)) == null ? void 0 : ar.prompt());
              (br == null ? void 0 : br.outcome) === "accepted" && te(s, void 0)
            } catch (br) {
              vr.error(Nw({
                error: br.message
              }))
            }
          };
          var ft = M(Me);
          S0(ft, {
            class: "size-5"
          });
          var zt = q(ft);
          P(Me), je(ar => le(zt, ` ${ar??""}`), [() => qw()]), G(st, Me)
        };
        Ae(he, st => {
          y(s) && st(Se)
        })
      }
      var Ye = q(he, 2);
      {
        var Ze = st => {
          var Me = fF(),
            ft = M(Me);
          xm(ft, {
            class: "size-5"
          });
          var zt = q(ft);
          P(Me), je(ar => {
            mr(Me, "href", `${ui.url.origin??""}/admin/dashboard`), le(zt, ` ${ar??""}`)
          }, [() => $I()]), G(st, Me)
        };
        Ae(Ye, st => {
          var Me, ft;
          Ra((ft = (Me = o.user) == null ? void 0 : Me.data) == null ? void 0 : ft.role, ["admin"]) && st(Ze)
        })
      }
      var Tt = q(Ye, 2);
      {
        var _e = st => {
          var Me = mF(),
            ft = M(Me);
          xm(ft, {
            class: "size-5"
          });
          var zt = q(ft);
          P(Me), je(ar => {
            mr(Me, "href", `${ui.url.origin??""}/moderation`), le(zt, ` ${ar??""}`)
          }, [() => MI()]), G(st, Me)
        };
        Ae(Tt, st => {
          var Me;
          Ra((Me = o.user.data) == null ? void 0 : Me.role, ["admin", "moderator", "global_moderator"]) && st(_e)
        })
      }
      var Vt = q(Tt, 2);
      {
        var ur = st => {
          var Me = _F(),
            ft = M(Me);
          xm(ft, {
            class: "size-5"
          });
          var zt = q(ft);
          P(Me), je(ar => {
            mr(Me, "href", `${ui.url.origin??""}/appeal`), le(zt, ` ${ar??""}`)
          }, [() => gM()]), G(st, Me)
        };
        Ae(Vt, st => {
          var Me, ft;
          Ra((ft = (Me = o.user) == null ? void 0 : Me.data) == null ? void 0 : ft.role, ["admin"]) && st(ur)
        })
      }
      var Ft = q(Vt, 2),
        or = M(Ft);
      eF(or, {
        class: "size-5"
      });
      var Vr = q(or);
      P(Ft);
      var qr = q(Ft, 2),
        Wr = M(qr);
      km(Wr, {
        class: "size-5"
      }), bn(), P(qr);
      var rn = q(qr, 2),
        hn = M(rn);
      W7(hn, {
        class: "size-5"
      }), bn(), P(rn);
      var cn = q(rn, 2);
      {
        var an = st => {
          var Me = gF(),
            ft = gt(Me),
            zt = M(ft),
            ar = M(zt);
          $7(ar, {
            class: "size-5"
          });
          var br = q(ar);
          P(zt), P(ft);
          var Tr = q(ft, 2),
            Dt = M(Tr);
          ah(Dt, {
            class: "size-5"
          });
          var Br = q(Dt);
          P(Tr), je((Ir, wr, Xr) => {
            mr(ft, "action", `${sb}/payment/create-portal-session`), le(br, ` ${Ir??""}`), mr(Tr, "href", wr), le(Br, ` ${Xr??""}`)
          }, [() => Pb(), () => E0(ui.url.origin), () => G0()]), G(st, Me)
        };
        Ae(cn, st => {
          var Me;
          (Me = o.user.data) != null && Me.isCustomer && st(an)
        })
      }
      var ht = q(cn, 2);
      ht.__click = async () => {
        var st;
        try {
          te(x, !0), await o.user.logout(), A(), vr.warning(CP(), {
            icon: f0
          }), (st = o.onlogout) == null || st.call(o)
        } catch {
          vr.error(MP())
        } finally {
          te(x, !1)
        }
      };
      var un = M(ht);
      f0(un, {
        class: "size-5"
      });
      var Pn = q(un);
      P(ht), P(It), P(ke), P(ne);
      var Bt = q(ne, 2);
      R7(Bt, {
        get userData() {
          return o.user.data
        },
        get open() {
          return y(f)
        },
        set open(st) {
          te(f, st, !0)
        }
      }), je((st, Me, ft, zt, ar, br, Tr, Dt, Br, Ir, wr) => {
        we = Or(Y, 1, "btn relative size-12 p-0 shadow-md", null, we, {
          "bg-red-500": y(B)
        }), mr(Y, "title", st), mr(Je, "title", o.user.data.name), le(bt, o.user.data.name), Or(We, 1, Me), le(Ue, `#${o.user.data.id??""}`), le(Ut, `${ft??""}: `), le(Ke, zt), le(kt, `Level ${ar??""}`), le(Zt, ` (${br??""}%) `), mr(Nt, "data-tip", Tr), le(fr, Dt), mr(Et, "data-tip", Br), le(Vr, ` ${Ir??""}`), ht.disabled = y(x), le(Pn, ` ${wr??""}`)
      }, [() => Lw(), () => ls(Ni(o.user.data.id)), () => c_(), () => o.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(o.user.data.level), () => Math.floor(o.user.data.level % 1 * 100), () => H3(), () => Fw(), () => fa.muted ? CC() : wC(), () => Gw(), () => Cb()]), Un("focus", Y, () => {
        te(s, window.pwaInstallPrompt, !0)
      }), G(re, de)
    };
    Ae(K, re => {
      o.user.data && o.user.charges !== void 0 && re(ee)
    })
  }
  G(_, j), Lr()
}
Rn(["click"]);
var xF = me('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  bF = me('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  wF = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  TF = me("<span> </span>"),
  SF = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  CF = me('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  PF = me('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  IF = me('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  MF = me('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  AF = me('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function kF(_, o) {
  zr(o, !0);
  const f = [];
  let x = Qe("today"),
    A = {
      players: {
        label: U0(),
        icon: ef
      },
      alliances: {
        label: Z0(),
        icon: tf
      }
    },
    L = Qe("players"),
    w = Si({
      players: {},
      alliances: {}
    });
  const s = ct(() => w[y(L)][y(x)]);
  Zr(() => {
    if (y(s)) return;
    const Y = y(x),
      we = y(L);
    we === "players" ? Jr.leaderboardRegionPlayers(o.regionId, Y).then(Ie => {
      w[we][Y] = Ie
    }).catch(Ie => {
      vr.error(Ie.message)
    }) : we === "alliances" && Jr.leaderboardRegionAlliances(o.regionId, Y).then(Ie => {
      w[we][Y] = Ie
    }).catch(Ie => {
      vr.error(Ie.message)
    })
  });
  var B = AF(),
    j = gt(B);
  ii(j, 21, () => Object.entries(A), ([Y, {
    label: we,
    icon: Ie
  }]) => Y, (Y, we) => {
    var Ie = ct(() => v0(y(we), 2));
    let ze = () => y(Ie)[0],
      Re = () => y(Ie)[1].label,
      ke = () => y(Ie)[1].icon;
    const qe = ct(ke);
    var $e = xF(),
      Be = M($e);
    Ba(Be);
    var Ee, He = q(Be, 2);
    Ti(He, () => y(qe), (it, pt) => {
      pt(it, {
        get this() {
          return ke()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Le = q(He);
    P($e), je(() => {
      mr(Be, "aria-label", Re()), Ee !== (Ee = ze()) && (Be.value = (Be.__value = ze()) ?? ""), le(Le, ` ${Re()??""}`)
    }), h_(f, [], Be, () => (ze(), y(L)), it => te(L, it)), G(Y, $e)
  }), P(j);
  var K = q(j, 2),
    ee = M(K);
  T_(ee, {
    get value() {
      return y(x)
    },
    set value(Y) {
      te(x, Y, !0)
    }
  }), P(K);
  var re = q(K, 2);
  {
    var de = Y => {
        var we = bF(),
          Ie = M(we),
          ze = q(Ie);
        {
          var Re = qe => {
              var $e = ji();
              je(Be => le($e, Be), [() => Qp().toLowerCase()]), G(qe, $e)
            },
            ke = qe => {
              var $e = Jt(),
                Be = gt($e);
              {
                var Ee = Le => {
                    var it = ji();
                    je(pt => le(it, pt), [() => y_()]), G(Le, it)
                  },
                  He = Le => {
                    var it = Jt(),
                      pt = gt(it);
                    {
                      var Oe = Je => {
                        var bt = ji();
                        je(We => le(bt, We), [() => x_()]), G(Je, bt)
                      };
                      Ae(pt, Je => {
                        y(x) === "month" && Je(Oe)
                      }, !0)
                    }
                    G(Le, it)
                  };
                Ae(Be, Le => {
                  y(x) === "week" ? Le(Ee) : Le(He, !1)
                }, !0)
              }
              G(qe, $e)
            };
          Ae(ze, qe => {
            y(x) === "today" ? qe(Re) : qe(ke, !1)
          })
        }
        P(we), je(qe => le(Ie, `${qe??""} `), [() => v_()]), G(Y, we)
      },
      ne = Y => {
        var we = Jt(),
          Ie = gt(we);
        {
          var ze = ke => {
              var qe = Jt(),
                $e = gt(qe);
              {
                var Be = He => {
                    const Le = ct(() => y(s));
                    var it = CF(),
                      pt = M(it),
                      Oe = M(pt),
                      Je = q(M(Oe)),
                      bt = M(Je, !0);
                    P(Je);
                    var We = q(Je),
                      Ue = M(We),
                      Ge = q(Ue, 2, !0);
                    P(We), P(Oe), P(pt);
                    var Ve = q(pt);
                    ii(Ve, 31, () => y(Le), mt => mt.id, (mt, lt, yt) => {
                      const _t = ct(() => {
                        var rr;
                        return ((rr = Mt.data) == null ? void 0 : rr.id) === y(lt).id
                      });
                      var ut = SF();
                      let Ut;
                      var Lt = M(ut),
                        Ke = M(Lt, !0);
                      P(Lt);
                      var ot = q(Lt),
                        xt = M(ot),
                        Ct = M(xt);
                      mo(Ct, {
                        class: "size-10 border",
                        get userId() {
                          return y(lt).id
                        },
                        get pictureUrl() {
                          return y(lt).picture
                        }
                      });
                      var wt = q(Ct, 2),
                        kt = M(wt),
                        Zt = M(kt),
                        Nt = q(Zt),
                        $t = M(Nt);
                      P(Nt), P(kt);
                      var It = q(kt, 2);
                      {
                        var Xt = rr => {
                          const hr = ct(() => Ao(y(lt).equippedFlag));
                          var nr = wF(),
                            Et = M(nr, !0);
                          P(nr), je(() => {
                            mr(nr, "data-tip", y(hr).name), le(Et, y(hr).flag)
                          }), G(rr, nr)
                        };
                        Ae(It, rr => {
                          "equippedFlag" in y(lt) && y(lt).equippedFlag && rr(Xt)
                        })
                      }
                      var Ot = q(It, 2);
                      {
                        var jt = rr => {
                          Hh(rr, {
                            get username() {
                              return y(lt).discord
                            },
                            get id() {
                              return y(lt).discordId
                            }
                          })
                        };
                        Ae(Ot, rr => {
                          y(lt).discord && rr(jt)
                        })
                      }
                      var qt = q(Ot, 2);
                      {
                        var fr = rr => {
                          var hr = TF(),
                            nr = M(hr, !0);
                          P(hr), je((Et, kr) => {
                            Or(hr, 1, `badge badge-sm ml-0.5 border-0 ${Et??""} ${kr??""}`), le(nr, y(lt).allianceName)
                          }, [() => Wp(y(lt).allianceId), () => Ni(y(lt).allianceId)]), G(rr, hr)
                        };
                        Ae(qt, rr => {
                          "allianceName" in y(lt) && y(lt).allianceName && rr(fr)
                        })
                      }
                      P(wt), P(xt), P(ot);
                      var Kt = q(ot),
                        _r = M(Kt, !0);
                      P(Kt), P(ut), je((rr, hr) => {
                        Ut = Or(ut, 1, "", null, Ut, {
                          "bg-base-200": y(_t)
                        }), le(Ke, y(yt) + 1), Or(kt, 1, `font-semibold max-sm:ml-2 ${rr??""} flex gap-1`), le(Zt, `${y(lt).name??""} `), le($t, `#${y(lt).id??""}`), le(_r, hr)
                      }, [() => Ni(y(lt).id), () => y(lt).pixelsPainted.toLocaleString("en-US")]), _l(ut, () => gl, () => ({
                        duration: 200
                      })), G(mt, ut)
                    }), P(Ve), P(it), je((mt, lt, yt) => {
                      le(bt, mt), le(Ue, `${lt??""} `), le(Ge, yt)
                    }, [() => d_(), () => Mc(), () => Ac().toLowerCase()]), G(He, it)
                  },
                  Ee = He => {
                    var Le = Jt(),
                      it = gt(Le);
                    {
                      var pt = Oe => {
                        var Je = IF(),
                          bt = M(Je),
                          We = M(bt),
                          Ue = q(M(We)),
                          Ge = M(Ue, !0);
                        P(Ue);
                        var Ve = q(Ue),
                          mt = M(Ve),
                          lt = q(mt, 2, !0);
                        P(Ve), P(We), P(bt);
                        var yt = q(bt);
                        ii(yt, 31, () => y(s), _t => _t.id, (_t, ut, Ut) => {
                          const Lt = ct(() => {
                            var It;
                            return ((It = Mt.data) == null ? void 0 : It.allianceId) === y(ut).id
                          });
                          var Ke = PF();
                          let ot;
                          var xt = M(Ke),
                            Ct = M(xt, !0);
                          P(xt);
                          var wt = q(xt),
                            kt = M(wt),
                            Zt = M(kt, !0);
                          P(kt), P(wt);
                          var Nt = q(wt),
                            $t = M(Nt, !0);
                          P(Nt), P(Ke), je((It, Xt) => {
                            ot = Or(Ke, 1, "", null, ot, {
                              "bg-base-200": y(Lt)
                            }), le(Ct, y(Ut) + 1), Or(kt, 1, `font-semibold ${It??""}`), le(Zt, y(ut).name), le($t, Xt)
                          }, [() => Ni(y(ut).id), () => y(ut).pixelsPainted.toLocaleString("en-US")]), _l(Ke, () => gl, () => ({
                            duration: 200
                          })), G(_t, Ke)
                        }), P(yt), P(Je), je((_t, ut, Ut) => {
                          le(Ge, _t), le(mt, `${ut??""} `), le(lt, Ut)
                        }, [() => Kp(), () => Mc(), () => Ac().toLowerCase()]), G(Oe, Je)
                      };
                      Ae(it, Oe => {
                        y(L) === "alliances" && Oe(pt)
                      }, !0)
                    }
                    G(He, Le)
                  };
                Ae($e, He => {
                  y(L) === "players" ? He(Be) : He(Ee, !1)
                })
              }
              G(ke, qe)
            },
            Re = ke => {
              var qe = MF();
              G(ke, qe)
            };
          Ae(Ie, ke => {
            y(s) ? ke(ze) : ke(Re, !1)
          }, !0)
        }
        G(Y, we)
      };
    Ae(re, Y => {
      y(s) && y(s).length === 0 ? Y(de) : Y(ne, !1)
    })
  }
  G(_, B), Lr()
}
var EF = me('<div class="mt-5"><!></div>'),
  zF = me('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function LF(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15);
  const x = ct(() => Ao(o.region.countryId));
  Dn(() => {
    const Y = we => {
      we.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", Y), () => document.removeEventListener("keydown", Y)
  });
  var A = zF(),
    L = M(A),
    w = q(M(L), 2),
    s = M(w),
    B = M(s, !0);
  P(s);
  var j = q(s, 2),
    K = M(j, !0);
  P(j);
  var ee = q(j, 2),
    re = M(ee);
  P(ee), P(w);
  var de = q(w, 2);
  {
    var ne = Y => {
      var we = EF(),
        Ie = M(we);
      kF(Ie, {
        get regionId() {
          return o.region.id
        }
      }), P(we), aa(2, we, () => Wa, () => ({
        duration: 300
      })), G(Y, we)
    };
    Ae(de, Y => {
      f() && Y(ne)
    })
  }
  P(L), bn(2), P(A), yi(A, () => Y => {
    Zr(() => {
      f() ? Y.show() : Y.close()
    })
  }), je(Y => {
    Or(w, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${Y??""}`), mr(s, "data-tip", y(x).name), le(B, y(x).flag), le(K, o.region.name), le(re, `#${o.region.number??""}`)
  }, [() => Ni(o.region.cityId)]), Un("close", A, () => f(!1)), G(_, A), Lr()
}
async function DF(_) {
  const o = De();
  let f = `https://geocoding.wplace.live/v1/autocomplete?text=${encodeURIComponent(_)}${o==="pt"?"&lang=pt":""}`;
  const x = await fetch(f);
  if (!x.ok) {
    const A = await x.text();
    throw console.error(`Geocoding API error: ${A}`), new Error(_b())
  }
  return x.json()
}
var RF = me('<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'),
  FF = me('<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>');

function bm(_, o) {
  zr(o, !0);
  const f = (s, B) => {
    let j = () => B == null ? void 0 : B().name,
      K = () => B == null ? void 0 : B().label,
      ee = () => B == null ? void 0 : B().onclick;
    var re = FF(),
      de = M(re);
    de.__click = function(...$e) {
      var Be;
      (Be = ee()) == null || Be.apply(this, $e)
    };
    var ne = M(de);
    $p(ne, {
      class: "text-base-content/80 mt-0.5 size-6 min-w-6"
    });
    var Y = q(ne, 2),
      we = M(Y),
      Ie = M(we, !0);
    P(we);
    var ze = q(we, 2),
      Re = M(ze, !0);
    P(ze), P(Y), P(de);
    var ke = q(de, 2);
    {
      var qe = $e => {
        var Be = RF(),
          Ee = M(Be);
        Ee.__click = function(...Le) {
          var it;
          (it = o.onremove) == null || it.apply(this, Le)
        };
        var He = M(Ee);
        Bs(He, {
          class: "size-4"
        }), P(Ee), P(Be), G($e, Be)
      };
      Ae(ke, $e => {
        o.onremove && $e(qe)
      })
    }
    P(re), je(() => {
      le(Ie, j()), le(Re, K())
    }), G(s, re)
  };
  var x = Jt(),
    A = gt(x);
  {
    var L = s => {
        f(s, () => ({
          name: o.location.name,
          label: o.location.label,
          onclick: o.onclick
        }))
      },
      w = s => {
        var B = Jt(),
          j = gt(B);
        {
          var K = re => {
              {
                let de = ct(() => ({
                  name: o.location.name,
                  label: __(),
                  onclick: o.onclick
                }));
                f(re, () => y(de))
              }
            },
            ee = re => {
              var de = Jt(),
                ne = gt(de);
              {
                var Y = we => {
                  {
                    let Ie = ct(() => ({
                      name: `${o.location.pos.lat.toFixed(4)}, ${o.location.pos.lng.toFixed(4)}`,
                      label: X0(),
                      onclick: o.onclick
                    }));
                    f(we, () => y(Ie))
                  }
                };
                Ae(ne, we => {
                  o.location.type === "coordinates" && we(Y)
                }, !0)
              }
              G(re, de)
            };
          Ae(j, re => {
            o.location.type === "country" ? re(K) : re(ee, !1)
          }, !0)
        }
        G(s, B)
      };
    Ae(A, s => {
      o.location.type === "place" ? s(L) : s(w, !1)
    })
  }
  G(_, x), Lr()
}
Rn(["click"]);
var BF = Dr('<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function OF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = BF();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var NF = Dr('<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>');

function jF(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = NF();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var VF = me('<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'),
  qF = me('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  UF = me("<!> <!>", 1),
  ZF = me('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  GF = me('<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>', 1),
  $F = me('<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function HF(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(""),
    A = Qe(!1),
    L = Qe(!1);
  const w = new eA(() => y(x), 400);
  let s = Qe(null),
    B = Qe(void 0),
    j = Qe([]);
  const K = /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    ee = ct(() => {
      const Oe = K.exec(y(x));
      if (Oe) {
        const Je = parseFloat(Oe[1]),
          bt = parseFloat(Oe[5]);
        return {
          type: "coordinates",
          id: `coords-${Je}-${bt}`,
          pos: {
            lat: Je,
            lng: bt
          },
          zoom: o.tileZoom + 2
        }
      }
    }),
    re = "recent-locations";
  Dn(() => {
    const Oe = localStorage.getItem(re);
    if (Oe) try {
      te(j, JSON.parse(Oe))
    } catch (Je) {
      console.error("Failed to parse recent locations from localStorage", Je)
    }
  }), Zr(() => {
    w.current && DF(w.current).then(Oe => {
      te(B, Oe.features.map(Je => {
        if (Je.properties.layer === "country") return {
          type: "country",
          id: Je.properties.id,
          name: Je.properties.name,
          bbox: Je.bbox
        };
        const bt = Je.properties.label.replace(Je.properties.name + ",", "").trim();
        return {
          type: "place",
          id: Je.properties.id,
          name: Je.properties.name,
          label: bt,
          bbox: Je.bbox
        }
      })), y(A) && y(B).length > 0 && ne(y(B)[0])
    })
  }), Zr(() => {
    y(x) || te(B, void 0)
  }), Zr(() => {
    f() ? setTimeout(() => {
      y(s).focus()
    }, 50) : (te(x, ""), te(A, !1), te(B, void 0))
  });
  async function de() {
    const {
      tile: Oe,
      pixel: Je
    } = await Jr.getRandomTile(o.season), bt = new us(o.tileSize), We = Oe.x * o.tileSize + Je.x, Ue = Oe.y * o.tileSize + Je.y, [Ge, Ve] = bt.pixelsToLatLon(We, Ue, o.tileZoom), mt = {
      lat: Ge,
      lng: Ve
    }, lt = o.tileZoom + 2;
    o.map.flyTo({
      zoom: lt,
      center: mt
    }), Y({
      type: "coordinates",
      id: `coords-${Ge}-${Ve}`,
      pos: mt,
      zoom: lt
    })
  }

  function ne(Oe) {
    Oe.type === "coordinates" ? o.map.flyTo({
      zoom: Oe.zoom,
      center: Oe.pos
    }) : o.map.fitBounds([
      [Oe.bbox[0], Oe.bbox[1]],
      [Oe.bbox[2], Oe.bbox[3]]
    ], {
      padding: 40,
      duration: 1e3
    }), f(!1), te(B, void 0), Y(Oe)
  }

  function Y(Oe) {
    te(j, y(j).filter(bt => bt.id !== Oe.id)), y(j).unshift(Oe);
    const Je = 15;
    y(j).length > Je && te(j, y(j).slice(0, Je)), te(j, [...y(j)]), localStorage.setItem(re, JSON.stringify(y(j)))
  }
  var we = $F(),
    Ie = M(we),
    ze = M(Ie),
    Re = M(ze),
    ke = M(Re);
  Ba(ke), ko(ke, Oe => te(s, Oe), () => y(s));
  var qe = q(ke, 2);
  qe.__click = () => f(!1);
  var $e = M(qe);
  A0($e, {
    class: "size-5"
  }), P(qe);
  var Be = q(qe, 2);
  {
    var Ee = Oe => {
      var Je = VF();
      Je.__click = () => te(x, "");
      var bt = M(Je);
      OF(bt, {
        class: "size-4.5"
      }), P(Je), G(Oe, Je)
    };
    Ae(Be, Oe => {
      y(x) && Oe(Ee)
    })
  }
  P(Re), P(ze);
  var He = q(ze, 2),
    Le = M(He);
  {
    var it = Oe => {
        bm(Oe, {
          get location() {
            return y(ee)
          },
          onclick: () => ne(y(ee))
        })
      },
      pt = Oe => {
        var Je = Jt(),
          bt = gt(Je);
        {
          var We = Ge => {
              var Ve = UF(),
                mt = gt(Ve);
              ii(mt, 17, () => y(B), _t => _t.id, (_t, ut) => {
                bm(_t, {
                  get location() {
                    return y(ut)
                  },
                  onclick: () => ne(y(ut))
                })
              });
              var lt = q(mt, 2);
              {
                var yt = _t => {
                  var ut = qF(),
                    Ut = M(ut, !0);
                  P(ut), je(Lt => le(Ut, Lt), [() => WM()]), G(_t, ut)
                };
                Ae(lt, _t => {
                  y(B).length === 0 && _t(yt)
                })
              }
              G(Ge, Ve)
            },
            Ue = Ge => {
              var Ve = GF(),
                mt = gt(Ve),
                lt = M(mt),
                yt = M(lt, !0);
              P(lt);
              var _t = q(lt, 2);
              _t.__click = async () => {
                try {
                  await de(), f(!1)
                } catch (ot) {
                  vr.error(ot.message)
                } finally {
                  te(L, !1)
                }
              };
              var ut = M(_t);
              jF(ut, {
                class: "size-5"
              }), P(_t), P(mt);
              var Ut = q(mt, 2);
              ii(Ut, 17, () => y(j), ot => ot.id, (ot, xt) => {
                bm(ot, {
                  get location() {
                    return y(xt)
                  },
                  onclick: () => {
                    ne(y(xt))
                  },
                  onremove: () => {
                    te(j, y(j).filter(Ct => Ct.id !== y(xt).id)), localStorage.setItem(re, JSON.stringify(y(j)))
                  }
                })
              });
              var Lt = q(Ut, 2);
              {
                var Ke = ot => {
                  var xt = ZF(),
                    Ct = M(xt, !0);
                  P(xt), je(wt => le(Ct, wt), [() => KM()]), G(ot, xt)
                };
                Ae(Lt, ot => {
                  y(j).length === 0 && ot(Ke)
                })
              }
              je((ot, xt) => {
                le(yt, ot), mr(_t, "data-tip", xt), _t.disabled = y(L)
              }, [() => qM(), () => GM()]), G(Ge, Ve)
            };
          Ae(bt, Ge => {
            y(B) ? Ge(We) : Ge(Ue, !1)
          }, !0)
        }
        G(Oe, Je)
      };
    Ae(Le, Oe => {
      y(ee) ? Oe(it) : Oe(pt, !1)
    })
  }
  P(He), P(Ie), bn(2), P(we), yi(we, () => Oe => {
    Zr(() => {
      f() ? Oe.showModal() : Oe.close()
    })
  }), je(Oe => mr(ke, "placeholder", Oe), [() => F0()]), Un("close", we, () => f(!1)), Un("submit", Re, () => {
    var Oe;
    y(ee) ? ne(y(ee)) : w.pending ? te(A, !0) : (Oe = y(B)) != null && Oe.length && ne(y(B)[0])
  }), $h(ke, () => y(x), Oe => te(x, Oe)), G(_, we), Lr()
}
Rn(["click"]);
var WF = me("<!> <!>", 1),
  XF = me('<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'),
  YF = me('<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'),
  KF = me('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'),
  JF = me('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  QF = me('<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'),
  e9 = me('<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>', 1),
  t9 = me("<span> </span>"),
  r9 = me('<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'),
  n9 = me('<span class="tooltip svelte-15blegn"><!></span>'),
  i9 = me('<span class="tooltip svelte-15blegn"><!></span>'),
  a9 = me('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>', 1),
  o9 = me('<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> </td></tr>'),
  s9 = me('<div class="max-h-[27vh] overflow-y-auto svelte-15blegn"><table class="table svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'),
  l9 = me('<div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex justify-between gap-1 svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div> <div class="pb-3 svelte-15blegn"><!></div></div></div>');

function c9(_, o) {
  zr(o, !0);
  let f = Si([]),
    x = Qe(Si([])),
    A = Qe(!1),
    L = Qe(!1),
    w = Qe(!1),
    s, B, j, K;
  const ee = 15e6,
    re = new Pm,
    de = ct(() => re.size === 0 ? "none" : re.size === y(x).length ? "all" : "some");
  Dn(() => {
    Wi.droppletAndPlop.play(), s = ke();
    const We = o.map.on("click", async Ue => {
      if (f.length >= 2) {
        o.onclose();
        return
      }
      if (f.push(Ue.lngLat), qe(), Wi.plop.play(), f.length === 2) try {
        te(A, !0), te(x, await Y(f[0], f[1]), !0)
      } finally {
        te(A, !1)
      }
    });
    return () => {
      We.unsubscribe(), o.crosshair.clear(), s == null || s(), s = void 0
    }
  });

  function ne() {
    y(L) || (s == null || s(), s = void 0, o.onclose())
  }
  async function Y(We, Ue) {
    const Ge = new us(o.tileSize),
      [Ve, mt] = Ge.latLonToPixelsFloor(We.lat, We.lng, o.pixelArtZoom),
      [lt, yt] = Ge.latLonToPixelsFloor(Ue.lat, Ue.lng, o.pixelArtZoom),
      [_t, ut] = [Math.min(Ve, lt), Math.min(mt, yt)],
      [Ut, Lt] = [Math.max(Ve, lt), Math.max(mt, yt)],
      Ke = Ut - _t,
      ot = Lt - ut;
    if (Ke * ot > ee) return vr.error(`The selected area is too big. Please select an area smaller than ${ee.toLocaleString()} pixels.`), [];
    const Ct = Math.floor(_t / o.tileSize),
      wt = Math.floor(ut / o.tileSize),
      kt = Math.floor(Ut / o.tileSize),
      Zt = Math.floor(Lt / o.tileSize),
      Nt = kt - Ct + 1,
      $t = Zt - wt + 1,
      It = new Array($t).fill(0).flatMap((Kt, _r) => new Array(Nt).fill(0).map(async (rr, hr) => {
        const nr = Ct + hr,
          Et = wt + _r;
        let kr = 0,
          Te = 0,
          O = o.tileSize - 1,
          E = o.tileSize - 1;
        Et === wt && (Te = ut % o.tileSize), nr === Ct && (kr = _t % o.tileSize), Et === Zt && (E = Lt % o.tileSize), nr === kt && (O = Ut % o.tileSize);
        const ce = [nr, Et],
          ve = [kr, Te],
          he = [O, E];
        return {
          response: await Jr.getPixelAreaInfo({
            season: o.season,
            tile: ce,
            p0: ve,
            p1: he
          }),
          tile: ce,
          p0: ve,
          p1: he
        }
      })),
      Xt = await Promise.all(It),
      Ot = new Map;
    for (const {
        response: Kt,
        p0: _r,
        p1: rr,
        tile: hr
      }
      of Xt) {
      const [nr, Et] = hr, [kr, Te] = _r, [O, E] = rr, D = O - kr + 1, N = E - Te + 1;
      for (let H = 0; H < N; H++)
        for (let W = 0; W < D; W++) {
          const ce = H * D + W,
            ve = Kt.paintedBy[ce];
          let he = Ot.get(ve);
          he || (he = {
            latitudes: [],
            longitudes: []
          }, Ot.set(ve, he));
          const [Se, Ye] = Ge.pixelsToLatLon(nr * o.tileSize + (kr + W + .5), Et * o.tileSize + (Te + H + .5), o.pixelArtZoom);
          he.latitudes.push(Se), he.longitudes.push(Ye)
        }
    }
    const {
      users: jt
    } = await Jr.getMultipleUsersInfoById([...Ot.keys()]), qt = gb(jt, Kt => Kt.id), fr = [...Ot.entries()].map(([Kt, _r]) => ({
      ...qt[Kt] ?? {
        id: Kt,
        name: "Player",
        deleted: !0
      },
      painted: _r
    }));
    return fr.sort((Kt, _r) => Kt.id === 0 ? 1 : _r.id === 0 ? -1 : _r.painted.latitudes.length - Kt.painted.latitudes.length), fr
  }
  async function we({
    preserveSelection: We = !1
  } = {}) {
    if (f.length < 2) return;
    const Ue = We ? new Set([...re.keys()]) : void 0;
    try {
      te(A, !0);
      const Ge = await Y(f[0], f[1]);
      if (te(x, Ge, !0), re.clear(), We && (Ue != null && Ue.size))
        for (const Ve of Ge) Ue.has(Ve.id) && re.set(Ve.id, Ve);
      if (o.crosshair.clear(), We && (Ue != null && Ue.size))
        for (const Ve of re.values())
          for (let mt = 0; mt < Ve.painted.latitudes.length; mt++) o.crosshair.place([Ve.painted.latitudes[mt], Ve.painted.longitudes[mt]])
    } finally {
      te(A, !1)
    }
  }

  function Ie(We) {
    for (const Ue of We) ze(Ue.painted)
  }

  function ze(We) {
    for (let Ue = 0; Ue < We.latitudes.length; Ue++) o.crosshair.place([We.latitudes[Ue], We.longitudes[Ue]]);
    Wi.plop.play()
  }

  function Re(We) {
    for (let Ue = 0; Ue < We.latitudes.length; Ue++) o.crosshair.remove([We.latitudes[Ue], We.longitudes[Ue]])
  }
  Zr(() => {
    f.length, qe(), $e()
  });

  function ke() {
    const We = o.map.getContainer(),
      Ue = document.createElement("div");
    Ue.classList.add("selection-rectangle"), Ue.style.position = "absolute", Ue.style.pointerEvents = "none", Ue.style.display = "none", Ue.style.zIndex = "6", We.appendChild(Ue);
    const Ge = Ee(We, "horizontal"),
      Ve = Ee(We, "vertical");
    j = {
      horizontal: Ge,
      vertical: Ve
    };
    const mt = _t => {
        f.length >= 2 ? K = void 0 : K = {
          x: _t.point.x,
          y: _t.point.y
        }, qe(), $e()
      },
      lt = () => {
        f.length < 2 && (K = void 0), qe(), $e()
      },
      yt = () => {
        qe(), $e()
      };
    return o.map.on("mousemove", mt), We.addEventListener("mouseleave", lt), o.map.on("move", yt), o.map.on("resize", yt), B = Ue, qe(), $e(), () => {
      o.map.off("mousemove", mt), o.map.off("move", yt), o.map.off("resize", yt), We.removeEventListener("mouseleave", lt), Ue.remove(), B = void 0, K = void 0, j == null || j.horizontal.remove(), j == null || j.vertical.remove(), j = void 0
    }
  }

  function qe() {
    const We = B;
    if (!We) return;
    const Ue = new us(o.tileSize);
    let Ge, Ve, mt, lt;
    if (f.length >= 2) {
      const kt = f.map(Zt => Ue.latLonToPixelsFloor(Zt.lat, Zt.lng, o.pixelArtZoom));
      Ge = Math.min(...kt.map(([Zt]) => Zt)), Ve = Math.max(...kt.map(([Zt]) => Zt)) + 1, mt = Math.min(...kt.map(([, Zt]) => Zt)), lt = Math.max(...kt.map(([, Zt]) => Zt)) + 1
    } else if (f.length === 1 && K) {
      const [kt, Zt] = Ue.latLonToPixelsFloor(f[0].lat, f[0].lng, o.pixelArtZoom), Nt = o.map.unproject([K.x, K.y]), [$t, It] = Ue.latLonToPixelsFloor(Nt.lat, Nt.lng, o.pixelArtZoom);
      Ge = Math.min(kt, $t), Ve = Math.max(kt, $t) + 1, mt = Math.min(Zt, It), lt = Math.max(Zt, It) + 1
    } else {
      We.style.display = "none";
      return
    }
    const [yt, _t] = Ue.pixelsToLatLon(Ge, mt, o.pixelArtZoom), [ut, Ut] = Ue.pixelsToLatLon(Ve, lt, o.pixelArtZoom), Lt = o.map.project([_t, yt]), Ke = o.map.project([Ut, ut]);
    let ot = Math.min(Lt.x, Ke.x),
      xt = Math.max(Lt.x, Ke.x),
      Ct = Math.min(Lt.y, Ke.y),
      wt = Math.max(Lt.y, Ke.y);
    xt - ot < 1 && (xt = ot + 1), wt - Ct < 1 && (wt = Ct + 1), We.style.display = "block", We.style.left = `${ot}px`, We.style.top = `${Ct}px`, We.style.width = `${xt-ot}px`, We.style.height = `${wt-Ct}px`
  }

  function $e() {
    const We = j;
    if (We) {
      if (!K || f.length >= 2) {
        Be();
        return
      }
      We.horizontal.style.display = "block", We.horizontal.style.top = `${K.y}px`, We.horizontal.style.transform = "translateY(-0.5px)", We.vertical.style.display = "block", We.vertical.style.left = `${K.x}px`, We.vertical.style.transform = "translateX(-0.5px)"
    }
  }

  function Be() {
    j && (j.horizontal.style.display = "none", j.vertical.style.display = "none")
  }

  function Ee(We, Ue) {
    const Ge = document.createElement("div");
    return Ge.style.position = "absolute", Ge.style.pointerEvents = "none", Ge.style.zIndex = "5", Ge.style.display = "none", Ge.style.mixBlendMode = "difference", Ge.style.backgroundColor = "rgba(255, 255, 255, 0.9)", Ue === "horizontal" ? (Ge.style.left = "0", Ge.style.right = "0", Ge.style.height = "1px") : (Ge.style.top = "0", Ge.style.bottom = "0", Ge.style.width = "1px"), We.appendChild(Ge), Ge
  }
  async function He() {
    if (y(w) || y(A)) return;
    const We = new us(o.tileSize),
      Ue = new Map;
    for (const Ge of re.values()) {
      if (Ge.id === 0) continue;
      const {
        latitudes: Ve,
        longitudes: mt
      } = Ge.painted;
      for (let lt = 0; lt < Ve.length; lt++) {
        const {
          tile: yt,
          pixel: _t
        } = We.latLonToTileAndPixel(Ve[lt], mt[lt], o.pixelArtZoom), ut = {
          tile: yt,
          pixel: _t,
          season: o.season
        }, Ut = `${yt[0]}:${yt[1]}:${_t[0]}:${_t[1]}`;
        Ue.set(Ut, ut)
      }
    }
    if (Ue.size === 0) {
      vr.info("Select painted pixels to clear with transparent color");
      return
    }
    te(w, !0);
    try {
      Wi.droppletAndPlop.play();
      const Ge = await Vy(),
        Ve = [];
      for (const yt of Ue.values()) Ve.push({
        ...yt,
        colorIdx: 0
      });
      await Jr.paint(Ve, Ge);
      const mt = M0(0),
        lt = Ve.map(({
          tile: yt,
          pixel: _t,
          season: ut
        }) => ({
          tile: yt,
          pixel: _t,
          season: ut,
          color: mt
        }));
      await b0(lt), vr.success("Painted selected pixels with transparent color"), await we()
    } catch (Ge) {
      vr.error(Ge.message)
    } finally {
      te(w, !1)
    }
  }
  const Le = We => ({
    id: We.id,
    name: We.name,
    picture: We.picture,
    allianceId: We.allianceId ?? void 0,
    allianceName: We.allianceName ?? void 0,
    timedOut: We.timedOut,
    banned: We.banned,
    deleted: We.deleted
  });
  async function it(We, Ue) {
    try {
      te(L, !0);
      const Ge = We.filter(Lt => Lt.id !== 0);
      if (Ge.length === 0) {
        vr.info("Select at least one player");
        return
      }
      const Ve = Ge.flatMap(Lt => Lt.painted.latitudes),
        mt = Ge.flatMap(Lt => Lt.painted.longitudes);
      if (Ve.length === 0 || mt.length === 0) {
        vr.error("No pixel data available for the selected users.");
        return
      }
      const lt = Math.min(...Ve),
        yt = Math.max(...Ve),
        _t = Math.min(...mt),
        ut = Math.max(...mt);
      o.map.fitBounds([{
        lat: lt,
        lng: _t
      }, {
        lat: yt,
        lng: ut
      }], {
        padding: 100,
        duration: 0
      });
      const Ut = (async () => await C_(o.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: .8,
        type: "image/jpeg"
      }))();
      o.onmodaction({
        action: Ue,
        targets: Ge.map(Le),
        image: Ut,
        latLon: [(lt + yt) / 2, (_t + ut) / 2],
        zoom: o.map.getZoom(),
        onSuccess: async () => {
          await we({
            preserveSelection: !0
          })
        }
      })
    } catch (Ge) {
      vr.error(Ge.message)
    } finally {
      te(L, !1)
    }
  }
  var pt = Jt();
  Un("keydown", l_, We => We.code === "Escape" && ne());
  var Oe = gt(pt);
  {
    var Je = We => {
        pl(We, {
          class: "bg-warning animate-bounce",
          children: (Ue, Ge) => {
            var Ve = WF(),
              mt = gt(Ve);
            sh(mt, {
              class: "inline size-5"
            });
            var lt = q(mt, 2);
            {
              var yt = ut => {
                  var Ut = ji();
                  je(Lt => le(Ut, Lt), [() => $0()]), G(ut, Ut)
                },
                _t = ut => {
                  var Ut = Jt(),
                    Lt = gt(Ut);
                  {
                    var Ke = ot => {
                      var xt = ji();
                      je(Ct => le(xt, Ct), [() => H0()]), G(ot, xt)
                    };
                    Ae(Lt, ot => {
                      f.length === 1 && ot(Ke)
                    }, !0)
                  }
                  G(ut, Ut)
                };
              Ae(lt, ut => {
                f.length === 0 ? ut(yt) : ut(_t, !1)
              })
            }
            G(Ue, Ve)
          },
          $$slots: {
            default: !0
          }
        })
      },
      bt = We => {
        var Ue = l9(),
          Ge = M(Ue),
          Ve = M(Ge),
          mt = M(Ve),
          lt = M(mt),
          yt = M(lt);
        sh(yt, {
          class: "size-4"
        }), P(lt);
        var _t = q(lt, 4),
          ut = M(_t);
        P(_t), P(mt);
        var Ut = q(mt, 2);
        Ut.__click = ne;
        var Lt = M(Ut);
        Bs(Lt, {
          class: "size-4"
        }), P(Ut), P(Ve);
        var Ke = q(Ve, 2),
          ot = M(Ke);
        {
          var xt = wt => {
              var kt = XF();
              G(wt, kt)
            },
            Ct = wt => {
              var kt = Jt(),
                Zt = gt(kt);
              {
                var Nt = It => {
                    var Xt = YF();
                    G(It, Xt)
                  },
                  $t = It => {
                    var Xt = s9(),
                      Ot = M(Xt),
                      jt = M(Ot),
                      qt = M(jt),
                      fr = M(qt),
                      Kt = M(fr);
                    Ba(Kt), Kt.__click = H => {
                      if (y(de) === "none") {
                        const W = [];
                        for (const ce of y(x)) re.has(ce.id) || (re.set(ce.id, ce), W.push(ce));
                        W.length && Ie(W);
                        return
                      }
                      re.clear(), o.crosshair.clear()
                    }, P(fr);
                    var _r = q(fr),
                      rr = q(M(_r));
                    rr.__click = () => {
                      navigator.clipboard.writeText([...re.keys()].filter(H => H !== 0).join(", ")), vr.success("Player IDs copied to clipboard")
                    };
                    var hr = M(rr);
                    p_(hr, {
                      class: "size-3"
                    }), P(rr);
                    var nr = q(rr, 2);
                    nr.__click = () => {
                      it([...re.values()], "timeout")
                    };
                    var Et = M(nr);
                    rh(Et, {
                      class: "size-4"
                    }), P(nr);
                    var kr = q(nr, 2);
                    {
                      var Te = H => {
                        var W = KF();
                        W.__click = () => {
                          it([...re.values()], "ban")
                        };
                        var ce = M(W);
                        zp(ce, {
                          class: "size-4"
                        }), P(W), je(() => W.disabled = y(L)), G(H, W)
                      };
                      Ae(kr, H => {
                        var W;
                        Ra((W = Mt.data) == null ? void 0 : W.role, ["admin", "global_moderator"]) && H(Te)
                      })
                    }
                    P(_r);
                    var O = q(_r),
                      E = M(O);
                    {
                      var D = H => {
                        var W = QF();
                        W.__click = He;
                        var ce = M(W);
                        {
                          var ve = Se => {
                              var Ye = JF();
                              G(Se, Ye)
                            },
                            he = Se => {
                              Cm(Se, {
                                class: "size-4"
                              })
                            };
                          Ae(ce, Se => {
                            y(w) ? Se(ve) : Se(he, !1)
                          })
                        }
                        P(W), je(() => W.disabled = y(w) || y(A) || re.size === 0), G(H, W)
                      };
                      Ae(E, H => {
                        var W;
                        Ra((W = Mt.data) == null ? void 0 : W.role, ["admin", "global_moderator"]) && H(D)
                      })
                    }
                    bn(), P(O), P(qt), P(jt);
                    var N = q(jt);
                    ii(N, 23, () => y(x), H => H.id, (H, W, ce, ve) => {
                      const he = ct(() => re.has(y(W).id));
                      var Se = o9();
                      let Ye;
                      Se.__click = () => {
                        y(he) ? (re.delete(y(W).id), Re(y(W).painted)) : (re.set(y(W).id, y(W)), ze(y(W).painted))
                      };
                      var Ze = M(Se),
                        Tt = M(Ze);
                      Ba(Tt), P(Ze);
                      var _e = q(Ze),
                        Vt = M(_e);
                      {
                        var ur = qr => {
                            var Wr = e9();
                            bn(2), G(qr, Wr)
                          },
                          Ft = qr => {
                            var Wr = a9(),
                              rn = gt(Wr);
                            mo(rn, {
                              class: "size-5 border-0",
                              get userId() {
                                return y(W).id
                              },
                              get pictureUrl() {
                                return y(W).picture
                              }
                            });
                            var hn = q(rn, 2),
                              cn = M(hn),
                              an = M(cn),
                              ht = M(an, !0);
                            P(an);
                            var un = q(an, 2),
                              Pn = M(un);
                            P(un), P(cn);
                            var Bt = q(cn, 2);
                            {
                              var st = Dt => {
                                var Br = t9(),
                                  Ir = M(Br, !0);
                                P(Br), je((wr, Xr) => {
                                  Or(Br, 1, `badge badge-sm ml-0.5 border-0 ${wr??""} ${Xr??""}`, "svelte-15blegn"), le(Ir, y(W).allianceName)
                                }, [() => Wp(y(W).allianceId), () => Ni(y(W).allianceId)]), G(Dt, Br)
                              };
                              Ae(Bt, Dt => {
                                y(W).allianceId && Dt(st)
                              })
                            }
                            var Me = q(Bt, 2);
                            {
                              var ft = Dt => {
                                var Br = r9();
                                G(Dt, Br)
                              };
                              Ae(Me, Dt => {
                                y(W).deleted && Dt(ft)
                              })
                            }
                            var zt = q(Me, 2),
                              ar = M(zt);
                            {
                              var br = Dt => {
                                  var Br = n9(),
                                    Ir = M(Br);
                                  zp(Ir, {
                                    class: "text-error size-4"
                                  }), P(Br), je(wr => mr(Br, "data-tip", wr), [() => u_()]), G(Dt, Br)
                                },
                                Tr = Dt => {
                                  var Br = Jt(),
                                    Ir = gt(Br);
                                  {
                                    var wr = Xr => {
                                      var Mr = i9(),
                                        nn = M(Mr);
                                      rh(nn, {
                                        class: "text-error size-4"
                                      }), P(Mr), je(sn => mr(Mr, "data-tip", sn), [() => B0()]), G(Xr, Mr)
                                    };
                                    Ae(Ir, Xr => {
                                      y(W).timedOut && Xr(wr)
                                    }, !0)
                                  }
                                  G(Dt, Br)
                                };
                              Ae(ar, Dt => {
                                y(W).banned ? Dt(br) : Dt(Tr, !1)
                              })
                            }
                            P(zt), P(hn), je(Dt => {
                              Or(cn, 1, `font-medium ${Dt??""} flex gap-1.5`, "svelte-15blegn"), le(ht, y(W).name), le(Pn, `#${y(W).id??""}`)
                            }, [() => Ni(y(W).id)]), G(qr, Wr)
                          };
                        Ae(Vt, qr => {
                          y(W).id === 0 ? qr(ur) : qr(Ft, !1)
                        })
                      }
                      P(_e);
                      var or = q(_e),
                        Vr = M(or, !0);
                      P(or), P(Se), je(qr => {
                        Ye = Or(Se, 1, "hover:bg-base-300 cursor-pointer svelte-15blegn", null, Ye, {
                          "bg-base-200": y(he)
                        }), Av(Tt, y(he)), le(Vr, qr)
                      }, [() => y(W).painted.latitudes.length.toLocaleString()]), G(H, Se)
                    }), P(N), P(Ot), P(Xt), je(() => {
                      Av(Kt, y(de) !== "none"), Kt.indeterminate = y(de) === "some", nr.disabled = y(L)
                    }), G(It, Xt)
                  };
                Ae(Zt, It => {
                  y(x).length === 0 ? It(Nt) : It($t, !1)
                }, !0)
              }
              G(wt, kt)
            };
          Ae(ot, wt => {
            y(A) ? wt(xt) : wt(Ct, !1)
          })
        }
        P(Ke), P(Ge), P(Ue), je(wt => le(ut, `(Pixels: ${wt??""})`), [() => [...re.values()].reduce((wt, kt) => wt + kt.painted.latitudes.length, 0)]), aa(3, Ue, () => bp, () => ({
          duration: 100
        })), G(We, Ue)
      };
    Ae(Oe, We => {
      f.length < 2 ? We(Je) : We(bt, !1)
    })
  }
  G(_, pt), Lr()
}
Rn(["click"]);
const u9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAfCAYAAAAfrhY5AAAByUlEQVR4AeyV0VEDMQxEbQqgDEqhFrpg6IJaKIUyaODQ89wqimKf75LM5AOY20harbWyf3gqD/z7N3/I49/j2RfbHFg49t1qvjx/vRVgtocXuMW8GZtp+Xn9JFR+jmCvObeKcI9gHPvkrhklM3OGLMv7S4mwYfAW/Btpss4PkIzMOeQDEQr149sX4dZaCl4aonjL2yyLF1/PvGvKSQwYSp4BT7/H0zOeJSycvmzejE/t+2W9BbL5pts6wDWz2oWDJJr7rXm+iMHZTTqeJ0e8LuvPH83pN6yilvPDYYF6BGmIUZPnqdc1V1NxWZYCqPNgOCAeHYCbYZd5HiIj8bkWP4tD8/hUtdZSa/VZ6slUNYJaa1dLL2NojjAOpQbiZKwoHo3Q49QjbpojYEAEHJhx9NFtYWqum/WGXNvTrGhe8zDVijpEFKcIJ4hTTHxVHc3FtaiDej7VNJUf7XE2Ipv77RkMECtiCiI368W+nfNbW16yOVxbQCYQQENynuuoo8ccYPmZsdVdc3iEF0swGCAA61BS/x/fCvuhB0hXWDj/ejePirMlGBZhQl8w8uT0VljofzNznWpLWJGjUSVzqultYq/55pBrm3/X/BcAAP//XVoCOwAAAAZJREFUAwCtKAFOt0LgOAAAAABJRU5ErkJgggAA";
var h9 = Dr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function $y(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = h9();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var d9 = Dr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function p9(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = d9();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var f9 = Dr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  m9 = Dr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function _9(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = gt(x);
  {
    var L = s => {
        var B = f9();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      },
      w = s => {
        var B = m9();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      };
    Ae(A, s => {
      o.filled ? s(L) : s(w, !1)
    })
  }
  G(_, x)
}
var g9 = me('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'),
  v9 = me('<div class="skeleton h-5 w-16"></div>'),
  y9 = me('<div class="skeleton mt-1 h-5 w-32"></div>'),
  x9 = me('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm"><img alt="Pumpkin" class="size-5"/></div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span> </span> <span> </span></span></div></div>'),
  b9 = me('<span class="font-flag tooltip ml-0.5"> </span>'),
  w9 = me('<span class="badge badge-dash badge-sm bg-primary/20 text-primary tooltip ml-0.5 gap-1 border-0"><!> </span>'),
  T9 = me("<button><!></button>"),
  S9 = me("<span> </span> <!>", 1),
  C9 = me('<span class="tooltip"><!></span>'),
  P9 = me('<span class="tooltip"><!></span>'),
  I9 = me("<li><button><!> </button></li>"),
  M9 = me("<li><button><!> </button></li>"),
  A9 = me("<li><button><!> </button></li>"),
  k9 = me('<li><button class="text-error font-medium"><!> </button></li>'),
  E9 = me('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'),
  z9 = me('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'),
  L9 = me('<button class="btn btn-primary"><!> </button>'),
  D9 = me("<!> ", 1),
  R9 = me("<!> ", 1),
  F9 = me('<button class="btn btn-primary"><!></button>'),
  B9 = me("<button><!> </button>"),
  O9 = me('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function N9(_, o) {
  zr(o, !0);
  let f = Qe(void 0);
  const x = ct(() => new us(o.tileSize));
  let A = Qe(void 0),
    L = Qe(void 0),
    w = Qe(!1),
    s = Qe(!1);
  const B = ct(() => {
      var Ke, ot, xt;
      return !!((ot = (Ke = y(f)) == null ? void 0 : Ke.paintedBy) != null && ot.id) && ((xt = Mt.data) == null ? void 0 : xt.id) === y(f).paintedBy.id
    }),
    j = ct(() => {
      const [Ke, ot] = o.latLon ?? [0, 0], xt = y(x).latLonToPixelBoundsLatLon(Ke, ot, o.pixelArtZoom), Ct = w_(xt), {
        tile: wt,
        pixel: kt
      } = y(x).latLonToTileAndPixel(Ke, ot, o.pixelArtZoom), Zt = y(x).latLonToRegionAndPixel(Ke, ot, o.pixelArtZoom);
      return {
        bounds: xt,
        center: Ct,
        tile: wt,
        pixel: kt,
        regionPixel: Zt.pixel
      }
    });
  Zr(() => {
    Wi.plop.play(), o.crosshair.clearAndPlace(o.latLon)
  });
  let K = 0;
  const ee = ({
    pixel: Ke,
    tile: ot,
    season: xt
  }) => `s${xt}:p(${Ke[0]},${Ke[1]}):t(${ot[0]},${ot[1]})`;
  let re;
  Rs(() => [y(j), o.season], () => {
    const Ke = {
        ...y(j),
        season: o.season
      },
      ot = ee(Ke);
    if (te(f, o.pixelInfoCache.get(ot), !0), y(f) !== void 0) return;
    o.pixelInfoCache.size === 0 && (K = 0), K++, K > 6 ? (clearTimeout(re), re = setTimeout(async () => de(Ke), 500)) : de(Ke)
  });
  async function de(Ke) {
    var Ct;
    const ot = await Jr.getPixelInfo({
      ...Ke,
      isModerator: Ra((Ct = Mt.data) == null ? void 0 : Ct.role, ["admin", "global_moderator", "moderator"])
    });
    if (ot.paintedBy !== void 0) {
      const wt = ee(Ke);
      o.pixelInfoCache.set(wt, ot)
    }
    const xt = ee({
      ...y(j),
      season: o.season
    });
    return te(f, o.pixelInfoCache.get(xt), !0), ot
  }
  Dn(() => () => {
    o.crosshair.clear(), Wi.smallPlop.play()
  });
  const ne = ct(() => {
    var Ct, wt, kt, Zt, Nt;
    const Ke = [],
      ot = (wt = (Ct = Mt) == null ? void 0 : Ct.data) == null ? void 0 : wt.role;
    Ra(ot, ["admin", "global_moderator"]) && !y(B) && Ke.push("ban-user"), Ra(ot, ["admin", "global_moderator", "moderator"]) && !y(B) && Ke.push("timeout-user"), !y(B) && Mt.data && Ke.push("report-user");
    const xt = (kt = y(f)) == null ? void 0 : kt.paintedBy;
    return (xt == null ? void 0 : xt.allianceId) === ((Zt = Mt.data) == null ? void 0 : Zt.allianceId) && ((Nt = Mt.data) == null ? void 0 : Nt.allianceRole) === "admin" && Mt.data.id !== (xt == null ? void 0 : xt.id) && !y(B) && Ke.push("ban-alliance"), Ke
  });

  function Y(Ke) {
    const ot = (async () => await C_(o.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    o.onclickmodaction(y(f), ot, o.latLon, Ke)
  }
  async function we() {
    try {
      await Jr.claimEventPixel({
        ...y(j),
        season: o.season
      }), vr.success(h6({
        droplets: 2e3.toLocaleString()
      })), await de({
        ...y(j),
        season: o.season
      }), await Mt.refresh()
    } catch (Ke) {
      vr.error(Ke.message)
    }
  }
  var Ie = O9();
  Un("keypress", l_, Ke => {
    Ke.key === "Escape" && o.onclose()
  });
  var ze = M(Ie),
    Re = M(ze),
    ke = M(Re);
  ke.__click = () => {
    if (y(A) && y(L)) {
      const Ke = y(A) - y(L).clientHeight,
        ot = y(A) / 2 - Ke / 2;
      o.map.flyTo({
        center: {
          lat: y(j).center[0],
          lng: y(j).center[1]
        },
        zoom: 17.5,
        offset: [0, -ot]
      })
    }
  };
  var qe = M(ke);
  $p(qe, {
    class: "fill-primary size-5"
  }), P(ke);
  var $e = q(ke, 2),
    Be = M($e),
    Ee = M(Be);
  P(Be);
  var He = q(Be, 2);
  {
    var Le = Ke => {
        const ot = ct(() => y(f).region),
          xt = ct(() => Ao(y(ot).countryId));
        var Ct = g9();
        Ct.__click = () => o.onclickregion(y(ot));
        var wt = M(Ct),
          kt = M(wt, !0);
        P(wt);
        var Zt = q(wt, 2),
          Nt = M(Zt, !0);
        P(Zt);
        var $t = q(Zt, 2),
          It = M($t);
        P($t), P(Ct), je(Xt => {
          Or(Ct, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${Xt??""}`), mr(wt, "data-tip", y(xt).name), le(kt, y(xt).flag), le(Nt, y(ot).name), le(It, `#${y(ot).number??""}`)
        }, [() => Ni(y(ot).cityId)]), G(Ke, Ct)
      },
      it = Ke => {
        var ot = v9();
        G(Ke, ot)
      };
    Ae(He, Ke => {
      var ot;
      (ot = y(f)) != null && ot.region ? Ke(Le) : Ke(it, !1)
    })
  }
  P($e), P(Re);
  var pt = q(Re, 2);
  pt.__click = function(...Ke) {
    var ot;
    (ot = o.onclose) == null || ot.apply(this, Ke)
  };
  var Oe = M(pt);
  Bs(Oe, {
    class: "size-4"
  }), P(pt), P(ze);
  var Je = q(ze, 2),
    bt = M(Je);
  {
    var We = Ke => {
        var ot = y9();
        G(Ke, ot)
      },
      Ue = Ke => {
        var ot = Jt(),
          xt = gt(ot);
        {
          var Ct = kt => {
              var Zt = ji();
              je(Nt => le(Zt, Nt), [() => iC()]), G(kt, Zt)
            },
            wt = kt => {
              var Zt = Jt(),
                Nt = gt(Zt);
              {
                var $t = Xt => {
                    var Ot = x9(),
                      jt = M(Ot),
                      qt = M(jt);
                    P(jt);
                    var fr = q(jt, 2),
                      Kt = M(fr),
                      _r = M(Kt);
                    P(Kt), P(fr);
                    var rr = q(fr, 2),
                      hr = M(rr),
                      nr = M(hr),
                      Et = M(nr, !0);
                    P(nr);
                    var kr = q(nr, 2),
                      Te = M(kr);
                    P(kr), P(hr), P(rr), P(Ot), je((O, E) => {
                      le(qt, `${O??""}:`), mr(_r, "src", u9), le(Et, E), le(Te, `#${y(f).paintedBy.eventClaimNumber??""}`)
                    }, [() => f6(), () => r6()]), G(Xt, Ot)
                  },
                  It = Xt => {
                    const Ot = ct(() => y(f).paintedBy);
                    var jt = z9(),
                      qt = M(jt),
                      fr = M(qt);
                    P(qt);
                    var Kt = q(qt, 2),
                      _r = M(Kt);
                    mo(_r, {
                      class: "size-5 border-0",
                      get userId() {
                        return y(Ot).id
                      },
                      get pictureUrl() {
                        return y(Ot).picture
                      }
                    }), P(Kt);
                    var rr = q(Kt, 2),
                      hr = M(rr),
                      nr = M(hr),
                      Et = M(nr, !0);
                    P(nr);
                    var kr = q(nr, 2),
                      Te = M(kr);
                    P(kr), P(hr);
                    var O = q(hr, 2);
                    {
                      var E = _e => {
                        const Vt = ct(() => Ao(y(Ot).equippedFlag));
                        var ur = b9(),
                          Ft = M(ur, !0);
                        P(ur), je(() => {
                          mr(ur, "data-tip", y(Vt).name), le(Ft, y(Vt).flag)
                        }), G(_e, ur)
                      };
                      Ae(O, _e => {
                        y(Ot).equippedFlag && _e(E)
                      })
                    }
                    var D = q(O, 2);
                    {
                      var N = _e => {
                        Hh(_e, {
                          get username() {
                            return y(Ot).discord
                          },
                          get id() {
                            return y(Ot).discordId
                          }
                        })
                      };
                      Ae(D, _e => {
                        y(Ot).discord && _e(N)
                      })
                    }
                    var H = q(D, 2);
                    {
                      var W = _e => {
                        var Vt = w9(),
                          ur = M(Vt);
                        f_(ur, {
                          size: "none"
                        });
                        var Ft = q(ur);
                        P(Vt), je(() => {
                          mr(Vt, "data-tip", y(Ot).role), le(Ft, ` ${w0[y(Ot).role]??""}`)
                        }), G(_e, Vt)
                      };
                      Ae(H, _e => {
                        y(Ot).role && y(Ot).role !== "user" && _e(W)
                      })
                    }
                    var ce = q(H, 2);
                    {
                      var ve = _e => {
                        var Vt = S9(),
                          ur = gt(Vt),
                          Ft = M(ur, !0);
                        P(ur);
                        var or = q(ur, 2);
                        {
                          var Vr = qr => {
                            var Wr = T9();
                            Wr.__click = () => {
                              navigator.clipboard.writeText(y(Ot).allianceId.toString()), vr.success(g_())
                            };
                            var rn = M(Wr);
                            p_(rn, {
                              class: "size-3"
                            }), P(Wr), je((hn, cn) => {
                              Or(Wr, 1, hn), mr(Wr, "title", cn)
                            }, [() => ls(Ni(y(Ot).allianceId)), () => jb({
                              allianceId: y(Ot).allianceId
                            })]), G(qr, Wr)
                          };
                          Ae(or, qr => {
                            var Wr, rn, hn;
                            (((Wr = Mt.data) == null ? void 0 : Wr.role) === "admin" || ((rn = Mt.data) == null ? void 0 : rn.role) === "moderator" || ((hn = Mt.data) == null ? void 0 : hn.role) === "global_moderator") && qr(Vr)
                          })
                        }
                        je((qr, Wr) => {
                          Or(ur, 1, `badge badge-sm ml-0.5 border-0 ${qr??""} ${Wr??""}`), le(Ft, y(Ot).allianceName)
                        }, [() => Wp(y(Ot).allianceId), () => Ni(y(Ot).allianceId)]), G(_e, Vt)
                      };
                      Ae(ce, _e => {
                        y(Ot).allianceId && _e(ve)
                      })
                    }
                    var he = q(ce, 2);
                    {
                      var Se = _e => {
                          var Vt = C9(),
                            ur = M(Vt);
                          zp(ur, {
                            class: "text-error size-4"
                          }), P(Vt), je(Ft => mr(Vt, "data-tip", Ft), [() => u_()]), G(_e, Vt)
                        },
                        Ye = _e => {
                          var Vt = Jt(),
                            ur = gt(Vt);
                          {
                            var Ft = or => {
                              var Vr = P9(),
                                qr = M(Vr);
                              rh(qr, {
                                class: "text-error size-4"
                              }), P(Vr), je(Wr => mr(Vr, "data-tip", Wr), [() => B0()]), G(or, Vr)
                            };
                            Ae(ur, or => {
                              y(f).paintedBy.timedOut && or(Ft)
                            }, !0)
                          }
                          G(_e, Vt)
                        };
                      Ae(he, _e => {
                        y(f).paintedBy.banned ? _e(Se) : _e(Ye, !1)
                      })
                    }
                    P(rr);
                    var Ze = q(rr, 2);
                    {
                      var Tt = _e => {
                        var Vt = E9(),
                          ur = M(Vt),
                          Ft = M(ur);
                        S_(Ft, {
                          class: "size-4"
                        }), P(ur);
                        var or = q(ur, 2);
                        ii(or, 21, () => y(ne), Hp, (Vr, qr) => {
                          var Wr = Jt(),
                            rn = gt(Wr);
                          {
                            var hn = an => {
                                var ht = I9(),
                                  un = M(ht);
                                let Pn;
                                un.__click = () => {
                                  Y("report-user")
                                };
                                var Bt = M(un);
                                a_(Bt, {
                                  class: "size-5"
                                });
                                var st = q(Bt);
                                P(un), P(ht), je(Me => {
                                  Pn = Or(un, 1, "text-error py-2 font-medium", null, Pn, {
                                    "cursor-not-allowed": y(B)
                                  }), le(st, ` ${Me??""}`)
                                }, [() => Ib()]), G(an, ht)
                              },
                              cn = an => {
                                var ht = Jt(),
                                  un = gt(ht);
                                {
                                  var Pn = st => {
                                      var Me = M9(),
                                        ft = M(Me);
                                      let zt;
                                      ft.__click = () => {
                                        Y("timeout")
                                      };
                                      var ar = M(ft);
                                      rh(ar, {
                                        class: "size-5"
                                      });
                                      var br = q(ar);
                                      P(ft), P(Me), je(Tr => {
                                        zt = Or(ft, 1, "text-error font-medium", null, zt, {
                                          "cursor-not-allowed": y(B)
                                        }), le(br, ` ${Tr??""}`)
                                      }, [() => Mb()]), G(st, Me)
                                    },
                                    Bt = st => {
                                      var Me = Jt(),
                                        ft = gt(Me);
                                      {
                                        var zt = br => {
                                            var Tr = A9(),
                                              Dt = M(Tr);
                                            let Br;
                                            Dt.__click = () => {
                                              Y("ban")
                                            };
                                            var Ir = M(Dt);
                                            zp(Ir, {
                                              class: "size-5"
                                            });
                                            var wr = q(Ir);
                                            P(Dt), P(Tr), je(Xr => {
                                              Br = Or(Dt, 1, "text-error font-medium", null, Br, {
                                                "cursor-not-allowed": y(B)
                                              }), le(wr, ` ${Xr??""}`)
                                            }, [() => Ab()]), G(br, Tr)
                                          },
                                          ar = br => {
                                            var Tr = Jt(),
                                              Dt = gt(Tr);
                                            {
                                              var Br = Ir => {
                                                var wr = k9(),
                                                  Xr = M(wr);
                                                Xr.__click = async () => {
                                                  te(s, !0);
                                                  try {
                                                    await Jr.banAllianceUser(y(Ot).id), await de({
                                                      ...y(j),
                                                      season: o.season
                                                    })
                                                  } catch (sn) {
                                                    vr.error(sn.message)
                                                  } finally {
                                                    te(s, !1)
                                                  }
                                                };
                                                var Mr = M(Xr);
                                                p9(Mr, {
                                                  class: "size-5"
                                                });
                                                var nn = q(Mr);
                                                P(Xr), P(wr), je(sn => le(nn, ` ${sn??""}`), [() => q0()]), G(Ir, wr)
                                              };
                                              Ae(Dt, Ir => {
                                                y(qr) === "ban-alliance" && Ir(Br)
                                              }, !0)
                                            }
                                            G(br, Tr)
                                          };
                                        Ae(ft, br => {
                                          y(qr) === "ban-user" ? br(zt) : br(ar, !1)
                                        }, !0)
                                      }
                                      G(st, Me)
                                    };
                                  Ae(un, st => {
                                    y(qr) === "timeout-user" ? st(Pn) : st(Bt, !1)
                                  }, !0)
                                }
                                G(an, ht)
                              };
                            Ae(rn, an => {
                              y(qr) === "report-user" ? an(hn) : an(cn, !1)
                            })
                          }
                          G(Vr, Wr)
                        }), P(or), P(Vt), G(_e, Vt)
                      };
                      Ae(Ze, _e => {
                        y(ne).length > 0 && _e(Tt)
                      })
                    }
                    P(jt), je((_e, Vt) => {
                      var ur;
                      le(fr, `${_e??""}:`), Or(hr, 1, `font-medium ${Vt??""} flex gap-1.5`), le(Et, ((ur = Mt.data) == null ? void 0 : ur.id) === y(Ot).id ? Mt.data.name : y(Ot).name), le(Te, `#${y(Ot).id??""}`)
                    }, [() => sC(), () => Ni(y(Ot).id)]), G(Xt, jt)
                  };
                Ae(Nt, Xt => {
                  y(f).paintedBy.event ? Xt($t) : Xt(It, !1)
                }, !0)
              }
              G(kt, Zt)
            };
          Ae(xt, kt => {
            y(f).paintedBy.id === 0 ? kt(Ct) : kt(wt, !1)
          }, !0)
        }
        G(Ke, ot)
      };
    Ae(bt, Ke => {
      y(f) === void 0 ? Ke(We) : Ke(Ue, !1)
    })
  }
  P(Je);
  var Ge = q(Je, 2),
    Ve = M(Ge);
  {
    var mt = Ke => {
        var ot = L9();
        ot.__click = () => o.onclickpaint(o.latLon);
        var xt = M(ot);
        Wh(xt, {
          class: "size-4.5"
        });
        var Ct = q(xt);
        P(ot), je(wt => {
          ot.disabled = Mt.loading, le(Ct, ` ${wt??""}`)
        }, [() => j0()]), G(Ke, ot)
      },
      lt = Ke => {
        var ot = Jt(),
          xt = gt(ot);
        {
          var Ct = wt => {
            var kt = F9();
            kt.__click = () => we();
            var Zt = M(kt);
            {
              var Nt = It => {
                  var Xt = D9(),
                    Ot = gt(Xt);
                  Ub(Ot, {
                    class: "size-4.5"
                  });
                  var jt = q(Ot);
                  je(qt => le(jt, ` ${qt??""}`), [() => l6()]), G(It, Xt)
                },
                $t = It => {
                  var Xt = R9(),
                    Ot = gt(Xt);
                  $y(Ot, {
                    class: "size-4.5"
                  });
                  var jt = q(Ot);
                  je(qt => le(jt, ` ${qt??""}`), [() => a6()]), G(It, Xt)
                };
              Ae(Zt, It => {
                y(f).paintedBy.claimed ? It(Nt) : It($t, !1)
              })
            }
            P(kt), je(() => kt.disabled = Mt.loading || y(f).paintedBy.claimed), G(wt, kt)
          };
          Ae(xt, wt => {
            Mt.data && wt(Ct)
          }, !0)
        }
        G(Ke, ot)
      };
    Ae(Ve, Ke => {
      var ot;
      (ot = y(f)) != null && ot.paintedBy.event ? Ke(lt, !1) : Ke(mt)
    })
  }
  var yt = q(Ve, 2);
  {
    var _t = Ke => {
      const ot = ct(() => Mt.data.favoriteLocations.find(Nt => Math.abs(Nt.latitude - y(j).center[0]) < 5e-5 && Math.abs(Nt.longitude - y(j).center[1]) < 5e-5)),
        xt = ct(() => !y(ot) && Mt.data.favoriteLocations.length >= Mt.data.maxFavoriteLocations);
      var Ct = B9();
      let wt;
      Ct.__click = async () => {
        try {
          te(w, !0), y(ot) ? (await Jr.deleteFavoriteLocation(y(ot).id), vr.warning(JC())) : (await Jr.favoriteLocation(y(j).center), vr.success(tP())), Wi.smallPlop.play(), Mt.refresh()
        } catch (Nt) {
          vr.error(Nt.message)
        } finally {
          te(w, !1)
        }
      };
      var kt = M(Ct);
      {
        let Nt = ct(() => !!y(ot));
        _9(kt, {
          class: "size-4.5",
          get filled() {
            return y(Nt)
          }
        })
      }
      var Zt = q(kt);
      P(Ct), je(Nt => {
        wt = Or(Ct, 1, "btn btn-primary btn-soft", null, wt, {
          "text-yellow-400": !!y(ot)
        }), Ct.disabled = y(w) || y(xt), le(Zt, ` ${Nt??""}`)
      }, [() => y(xt) ? uC() : pC()]), G(Ke, Ct)
    };
    Ae(yt, Ke => {
      Mt.data && Ke(_t)
    })
  }
  var ut = q(yt, 2);
  ut.__click = () => o.onclickshare(z6(ui.url, {
    pos: {
      lat: y(j).center[0],
      lng: y(j).center[1]
    },
    zoom: o.zoom
  }));
  var Ut = M(ut);
  ty(Ut, {
    class: "size-4.5"
  });
  var Lt = q(Ut);
  P(ut), P(Ge), P(Ie), ko(Ie, Ke => te(L, Ke), () => y(L)), je(Ke => {
    le(Ee, `Pixel: ${y(j).regionPixel[0]??""}, ${y(j).regionPixel[1]??""}`), le(Lt, ` ${Ke??""}`)
  }, [() => _C()]), Yp("innerHeight", Ke => te(A, Ke, !0)), G(_, Ie), Lr()
}
Rn(["click"]);

function j9(_) {
  var x;
  const o = document.createElement("div");
  (x = _.parentElement) == null || x.insertBefore(o, _.nextSibling);
  const f = new IntersectionObserver(A => {
    A[0].isIntersecting ? _.classList.remove("stuck") : _.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return f.observe(o), () => {
    o.remove(), f.disconnect()
  }
}
var o_;
(_ => {
  function o() {
    let f, x;
    return {
      promise: new Promise((L, w) => {
        f = L, x = w
      }),
      resolve: f,
      reject: x
    }
  }
  _.withResolvers = o
})(o_ || (o_ = {}));
var V9 = Dr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  q9 = Dr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function U9(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = Jt(),
    A = gt(x);
  {
    var L = s => {
        var B = V9();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      },
      w = s => {
        var B = q9();
        cr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...f
        })), G(s, B)
      };
    Ae(A, s => {
      o.filled ? s(L) : s(w, !1)
    })
  }
  G(_, x)
}
var Z9 = me("<p><!></p>"),
  G9 = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  $9 = me('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'),
  H9 = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  W9 = me('<!> <span class="text-sm"> </span>', 1),
  X9 = me('<span class="text-sm"> </span>'),
  Y9 = me('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  K9 = me('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  J9 = me('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function Q9(_, o) {
  zr(o, !0);
  const f = (ke, qe = oa, $e = oa) => {
      const Be = ct(() => {
          var ut;
          return (((ut = Mt.data) == null ? void 0 : ut.droplets) ?? 0) >= s.price
        }),
        Ee = ct(() => y(j) === qe().id),
        He = ct(() => x.has(qe().id));
      var Le = K9(),
        it = M(Le),
        pt = M(it, !0);
      P(it);
      var Oe = q(it, 2),
        Je = M(Oe),
        bt = q(Je);
      {
        var We = ut => {
          var Ut = Z9(),
            Lt = M(Ut);
          ah(Lt, {
            class: "text-base-content/60 size-4.5 inline pb-0.5"
          }), P(Ut), je(Ke => {
            Or(Ut, 1, ls({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": ($e() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": $e() % 4 === 0,
              "before:-translate-x-1/3": ($e() + 1) % 2 === 0,
              "before:translate-x-1/3": $e() % 2 === 0
            })), mr(Ut, "data-tip", Ke)
          }, [() => KI()]), G(ut, Ut)
        };
        Ae(bt, ut => {
          y(He) && ut(We)
        })
      }
      P(Oe);
      var Ue = q(Oe, 2);
      {
        var Ge = ut => {
          A_(ut, {})
        };
        Ae(Ue, ut => {
          qe().id === y(K) && ut(Ge)
        })
      }
      var Ve = q(Ue, 2);
      let mt;
      var lt = M(Ve);
      {
        var yt = ut => {
            var Ut = $9();
            Ut.__click = async () => {
              if (!(y(He) && !await o.promptUserConfirmation(qe().name))) try {
                const Ct = qe().id;
                te(j, Ct, !0), await Jr.purchase({
                  id: w,
                  amount: 1,
                  variant: Ct
                }), Mt.refresh(), Wi.notification1.play();
                const wt = L.find(kt => kt.id === Ct);
                wt && (wt.owned = !0), te(K, Ct, !0)
              } catch (Ct) {
                vr.error(Ct.message)
              } finally {
                te(j, void 0)
              }
            };
            var Lt = M(Ut);
            {
              var Ke = Ct => {
                var wt = G9();
                G(Ct, wt)
              };
              Ae(Lt, Ct => {
                y(Ee) && Ct(Ke)
              })
            }
            var ot = q(Lt, 2);
            Xp(ot, {
              class: "size-4"
            });
            var xt = q(ot);
            bn(), P(Ut), je(Ct => {
              Ut.disabled = !y(Be) || y(Ee), le(xt, ` ${Ct??""} `)
            }, [() => s.price.toLocaleString("en-US")]), G(ut, Ut)
          },
          _t = ut => {
            const Ut = ct(() => {
              var $t;
              return (($t = Mt.data) == null ? void 0 : $t.equippedFlag) === qe().id
            });
            var Lt = Y9();
            let Ke;
            Lt.__click = async () => {
              try {
                te(j, qe().id, !0);
                const $t = y(Ut) ? 0 : qe().id;
                await Jr.equipFlag($t), Mt.data && (Mt.data.equippedFlag = $t), Mt.refresh()
              } catch ($t) {
                vr.error($t.message)
              } finally {
                te(j, void 0)
              }
            };
            var ot = M(Lt),
              xt = M(ot, !0);
            P(ot);
            var Ct = q(ot, 2);
            {
              var wt = $t => {
                var It = H9();
                G($t, It)
              };
              Ae(Ct, $t => {
                y(Ee) && $t(wt)
              })
            }
            var kt = q(Ct, 2);
            {
              var Zt = $t => {
                  var It = W9(),
                    Xt = gt(It);
                  Bs(Xt, {
                    class: "size-4"
                  });
                  var Ot = q(Xt, 2),
                    jt = M(Ot, !0);
                  P(Ot), je(qt => le(jt, qt), [() => x5()]), G($t, It)
                },
                Nt = $t => {
                  var It = X9(),
                    Xt = M(It, !0);
                  P(It), je(Ot => le(Xt, Ot), [() => T5()]), G($t, It)
                };
              Ae(kt, $t => {
                y(Ut) ? $t(Zt) : $t(Nt, !1)
              })
            }
            P(Lt), je($t => {
              Ke = Or(Lt, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, Ke, {
                "btn-warning": y(Ut)
              }), Lt.disabled = y(Ee), le(xt, $t)
            }, [() => g5()]), G(ut, Lt)
          };
        Ae(lt, ut => {
          qe().owned ? ut(_t, !1) : ut(yt)
        })
      }
      P(Ve), P(Le), je(ut => {
        le(pt, qe().flag), le(Je, `${qe().name??""} `), mt = Or(Ve, 1, "mt-3", null, mt, {
          tooltip: !y(Be)
        }), mr(Ve, "data-tip", ut)
      }, [() => Jp()]), G(ke, Le)
    },
    x = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    A = ma.countries.map(ke => ({
      ...ke,
      owned: Mt.flagsBitmap.get(ke.id)
    }));
  A.sort((ke, qe) => Number(qe.owned) - Number(ke.owned));
  const L = Si(A),
    w = 110,
    s = ma.products[w];
  let B = Qe(!1),
    j = Qe(void 0),
    K = Qe(void 0);
  var ee = J9(),
    re = M(ee),
    de = M(re);
  U9(de, {
    class: "size-5.5",
    filled: !0
  }), bn(2), P(re);
  var ne = q(re, 2),
    Y = M(ne, !0);
  P(ne);
  var we = q(ne, 2);
  ii(we, 23, () => L, ke => ke.id, (ke, qe, $e) => {
    var Be = Jt(),
      Ee = gt(Be);
    {
      var He = Le => {
        f(Le, () => y(qe), () => y($e))
      };
      Ae(Ee, Le => {
        (y($e) < 8 || y(B)) && Le(He)
      })
    }
    G(ke, Be)
  }), P(we);
  var Ie = q(we, 2),
    ze = M(Ie);
  ze.__click = () => {
    te(B, !y(B))
  };
  var Re = M(ze, !0);
  P(ze), P(Ie), P(ee), je(ke => {
    le(Y, ke), le(Re, y(B) ? "Show less" : "Show more")
  }, [() => f5()]), G(_, ee), Lr()
}
Rn(["click"]);
var eB = me('<p class="mt-1 text-center text-sm"> </p>'),
  tB = me('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  rB = me('<span class="loading loading-spinner center-absolute absolute"></span>'),
  nB = me('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function m0(_, o) {
  zr(o, !0);
  let f = At(o, "amount", 15, 1);
  const x = ct(() => f() * o.unitPrice),
    A = ct(() => Math.floor(o.userDroplets / o.unitPrice));
  let L = Qe(!1);
  Zr(() => {
    f() < 0 && f(0)
  });
  var w = nB(),
    s = M(w),
    B = M(s);
  ai(B, () => o.icon ?? oa), P(s);
  var j = q(s, 2),
    K = M(j, !0);
  P(j);
  var ee = q(j, 2);
  {
    var re = Le => {
      var it = eB(),
        pt = M(it, !0);
      P(it), je(() => le(pt, o.subtitle)), G(Le, it)
    };
    Ae(ee, Le => {
      o.subtitle && Le(re)
    })
  }
  var de = q(ee, 2),
    ne = M(de);
  ne.__click = () => {
    Ev(f, -1)
  };
  var Y = q(ne, 2);
  Ba(Y);
  var we = q(Y, 2);
  we.__click = () => {
    Ev(f)
  };
  var Ie = q(we, 2);
  {
    var ze = Le => {
      var it = tB();
      it.__click = () => {
        f(y(A))
      }, G(Le, it)
    };
    Ae(Ie, Le => {
      f() < y(A) && Le(ze)
    })
  }
  P(de);
  var Re = q(de, 2);
  let ke;
  var qe = M(Re);
  qe.__click = async () => {
    try {
      te(L, !0), await Jr.purchase({
        id: o.productId,
        amount: f()
      }), Wi.notification1.play(), o.onpurchasecompleted(f())
    } catch (Le) {
      vr.error(Le.message)
    } finally {
      te(L, !1)
    }
  };
  var $e = M(qe);
  {
    var Be = Le => {
      var it = rB();
      G(Le, it)
    };
    Ae($e, Le => {
      y(L) && Le(Be)
    })
  }
  var Ee = q($e, 2);
  Xp(Ee, {
    class: "size-4"
  });
  var He = q(Ee);
  bn(), P(qe), P(Re), P(w), je((Le, it, pt) => {
    le(K, Le), we.disabled = f() >= y(A), mr(Re, "data-tip", it), ke = Or(Re, 1, "", null, ke, {
      tooltip: o.userDroplets < y(x)
    }), qe.disabled = o.userDroplets < y(x) || y(L) || !f(), le(He, ` ${pt??""} `)
  }, [() => o.title(f()), () => Jp(), () => y(x).toLocaleString("en-US")]), $h(Y, f), G(_, w), Lr()
}
Rn(["click"]);
var iB = Dr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function aB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = iB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var oB = Dr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function Hy(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = oB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var sB = Dr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function lB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = sB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var cB = Dr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function uB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = cB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var hB = me('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">‚úï</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  dB = me('<span class="center-absolute absolute"><!></span>'),
  pB = me('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function fB(_, o) {
  zr(o, !0);
  let f = At(o, "open", 15),
    x = Qe(null),
    A = Qe(Si({
      name: Dv(),
      prev: 1e3,
      new: 1e5
    }));
  Dn(() => {
    const jt = qt => {
      qt.key === "Escape" && f(!1)
    };
    return document.addEventListener("keydown", jt), () => document.removeEventListener("keydown", jt)
  });
  const L = {
      id: 70,
      product: ma.products[70]
    },
    w = {
      id: 80,
      product: ma.products[80]
    },
    s = {
      product: ma.products[120]
    };
  let B = Qe(null),
    j = Qe(null),
    K = Qe("");
  async function ee(jt) {
    return y(B).showModal(), te(j, o_.withResolvers(), !0), te(K, jt, !0), y(j).promise
  }
  var re = pB(),
    de = gt(re),
    ne = M(de),
    Y = M(ne);
  {
    var we = jt => {
      var qt = hB(),
        fr = M(qt),
        Kt = M(fr),
        _r = M(Kt);
      Hy(_r, {
        class: "size-8"
      });
      var rr = q(_r, 2),
        hr = M(rr, !0);
      P(rr);
      var nr = q(rr, 2),
        Et = M(nr);
      {
        let zt = ct(() => {
          var ar;
          return ((ar = Mt.data) == null ? void 0 : ar.droplets) ?? 0
        });
        z0(Et, {
          get value() {
            return y(zt)
          }
        })
      }
      P(nr), bn(2), P(Kt), P(fr), yi(fr, () => j9);
      var kr = q(fr, 2),
        Te = M(kr),
        O = M(Te),
        E = M(O);
      aB(E, {
        class: "size-5.5",
        filled: !0
      });
      var D = q(E, 2),
        N = M(D, !0);
      P(D), P(O);
      var H = q(O, 2),
        W = M(H, !0);
      P(H);
      var ce = q(H, 2),
        ve = M(ce);
      {
        const zt = br => {
          uB(br, {
            class: "text-primary size-26"
          })
        };
        let ar = ct(() => ww());
        m0(ve, {
          get productId() {
            return L.id
          },
          title: br => yw({
            amount: L.product.items[0].amount * br
          }),
          get subtitle() {
            return y(ar)
          },
          get unitPrice() {
            return L.product.price
          },
          get userDroplets() {
            return Mt.data.droplets
          },
          onpurchasecompleted: async br => {
            var Br, Ir, wr, Xr;
            const Tr = (Ir = (Br = Mt.data) == null ? void 0 : Br.charges) == null ? void 0 : Ir.max;
            await Mt.refresh();
            const Dt = (Xr = (wr = Mt.data) == null ? void 0 : wr.charges) == null ? void 0 : Xr.max;
            Tr !== void 0 && Dt !== void 0 && (te(A, {
              name: Dv(),
              prev: Tr,
              new: Dt
            }, !0), y(x).show())
          },
          icon: zt,
          $$slots: {
            icon: !0
          }
        })
      }
      var he = q(ve, 2);
      {
        const zt = br => {
          qy(br, {
            class: "text-primary my-3 size-20"
          })
        };
        let ar = ct(() => uw());
        m0(he, {
          get productId() {
            return w.id
          },
          title: br => oT({
            amount: w.product.items[0].amount * br
          }),
          get subtitle() {
            return y(ar)
          },
          get unitPrice() {
            return w.product.price
          },
          get userDroplets() {
            return Mt.data.droplets
          },
          onpurchasecompleted: async br => {
            var Dt, Br, Ir;
            const Tr = (Br = (Dt = Mt.data) == null ? void 0 : Dt.charges) == null ? void 0 : Br.count;
            await Mt.refresh(), Tr !== void 0 && (te(A, {
              name: nT(),
              prev: Math.floor(Tr),
              new: Math.floor(Tr + w.product.items[0].amount * br)
            }, !0), (Ir = y(x)) == null || Ir.show())
          },
          icon: zt,
          $$slots: {
            icon: !0
          }
        })
      }
      P(ce), P(Te);
      var Se = q(Te, 2),
        Ye = M(Se),
        Ze = M(Ye);
      ef(Ze, {
        class: "size-5.5",
        filled: !0
      });
      var Tt = q(Ze, 2),
        _e = M(Tt, !0);
      P(Tt), P(Ye);
      var Vt = q(Ye, 2),
        ur = M(Vt),
        Ft = M(ur),
        or = M(Ft),
        Vr = M(or),
        qr = M(Vr);
      L0(qr, {
        get userId() {
          return Mt.data.id
        },
        get level() {
          return Mt.data.level
        },
        get pictureUrl() {
          return Mt.data.picture
        }
      }), P(Vr), P(or), P(Ft);
      var Wr = q(Ft, 2),
        rn = M(Wr, !0);
      P(Wr);
      var hn = q(Wr, 2),
        cn = M(hn, !0);
      P(hn);
      var an = q(hn, 2);
      let ht;
      var un = M(an),
        Pn = M(un),
        Bt = M(Pn);
      Xp(Bt, {
        class: "size-4"
      });
      var st = q(Bt);
      bn(), P(Pn), P(un), P(an), P(ur), P(Vt), P(Se);
      var Me = q(Se, 2),
        ft = M(Me);
      Q9(ft, {
        promptUserConfirmation: ee
      }), P(Me), P(kr), P(qt), je((zt, ar, br, Tr, Dt, Br, Ir, wr) => {
        le(hr, zt), le(N, ar), le(W, br), le(_e, Tr), le(rn, Dt), le(cn, Br), mr(an, "data-tip", Ir), ht = Or(an, 1, "", null, ht, {
          tooltip: Mt.data.droplets < s.product.price
        }), Pn.disabled = Mt.data.droplets < s.product.price, le(st, ` ${wr??""} `)
      }, [() => O0(), () => pw(), () => _w(), () => h5(), () => Cw(), () => Mw(), () => Jp(), () => s.product.price.toLocaleString("en-US")]), aa(2, qt, () => Wa), G(jt, qt)
    };
    Ae(Y, jt => {
      Mt.data && f() && jt(we)
    })
  }
  P(ne);
  var Ie = q(ne, 2),
    ze = M(Ie),
    Re = M(ze, !0);
  P(ze), P(Ie), P(de), yi(de, () => jt => {
    Zr(() => {
      f() ? jt.show() : jt.close()
    })
  });
  var ke = q(de, 2),
    qe = M(ke),
    $e = M(qe),
    Be = M($e),
    Ee = M(Be, !0);
  P(Be);
  var He = q(Be, 2),
    Le = M(He),
    it = M(Le),
    pt = q(it),
    Oe = M(pt);
  P(pt), P(Le);
  var Je = q(Le, 2),
    bt = M(Je);
  lB(bt, {
    class: "size-5"
  }), P(Je);
  var We = q(Je, 2),
    Ue = M(We, !0);
  P(We), P(He);
  var Ge = q(He, 2),
    Ve = M(Ge),
    mt = M(Ve),
    lt = q(mt);
  th(lt, () => y(A).new, jt => {
    var qt = dB(),
      fr = M(qt);
    A_(fr, {}), P(qt), G(jt, qt)
  }), P(Ve), P(Ge), P($e), P(qe);
  var yt = q(qe, 2),
    _t = M(yt),
    ut = M(_t, !0);
  P(_t), P(yt), P(ke), ko(ke, jt => te(x, jt), () => y(x));
  var Ut = q(ke, 2),
    Lt = M(Ut),
    Ke = M(Lt),
    ot = M(Ke, !0);
  P(Ke);
  var xt = q(Ke, 2),
    Ct = M(xt);
  Gp(Ct, () => n4({
    country: y(K)
  })), P(xt);
  var wt = q(xt, 2),
    kt = M(wt);
  kt.__click = () => {
    var jt;
    (jt = y(j)) == null || jt.resolve(!1), y(B).close()
  };
  var Zt = M(kt, !0);
  P(kt);
  var Nt = q(kt, 2);
  Nt.__click = () => {
    var jt;
    (jt = y(j)) == null || jt.resolve(!0), y(B).close()
  };
  var $t = M(Nt, !0);
  P(Nt), P(wt), P(Lt);
  var It = q(Lt, 2),
    Xt = M(It),
    Ot = M(Xt, !0);
  P(Xt), P(It), P(Ut), ko(Ut, jt => te(B, jt), () => y(B)), je((jt, qt, fr, Kt, _r, rr, hr) => {
    le(Re, jt), le(Ee, y(A).name), le(it, `${y(A).prev??""} `), le(Oe, `(+${y(A).new-y(A).prev})`), le(Ue, y(A).new), le(mt, `${qt??""} `), le(ut, fr), le(ot, Kt), le(Zt, _r), le($t, rr), le(Ot, hr)
  }, [() => cs(), () => cs(), () => cs(), () => e4(), () => Gh(), () => R0(), () => cs()]), Un("close", de, () => f(!1)), G(_, re), Lr()
}
Rn(["click"]);
var mB = Dr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function _B(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = mB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var gB = Dr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function vB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = gB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var yB = Dr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function xB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = yB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var bB = Dr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function wB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = bB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var TB = Dr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function SB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = TB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}
var CB = Dr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function PB(_, o) {
  let f = lr(o, ["$$slots", "$$events", "$$legacy"]);
  var x = CB();
  cr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...f
  })), G(_, x)
}

function wm(_) {
  const o = document.createElement("img");
  return o.src = _, new Promise((f, x) => {
    o.addEventListener("load", () => {
      f(o)
    }), o.addEventListener("error", A => {
      x(A)
    })
  })
}

function IB(_) {
  const o = document.createElement("canvas");
  o.width = _.naturalWidth, o.height = _.naturalHeight;
  const f = o.getContext("2d");
  return f == null || f.drawImage(_, 0, 0), o
}

function MB(_, o, f) {
  return _ < o ? o : _ > f ? f : _
}

function AB(_, o) {
  const f = 10 ** o;
  return Math.round(_ * f) / f
}
var kB = me('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  EB = me("<button><!></button>"),
  zB = me('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'),
  LB = me('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'),
  DB = me('<button class="btn btn-primary shadow-xl"> </button>'),
  RB = me('<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"> </a>'),
  FB = me('<span class="tooltip badge badge-secondary tooltip-left absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold">CL</span>'),
  BB = me('<div class="relative"><!> <!></div>'),
  OB = me('<button class="btn btn-square shadow-md"><!></button>'),
  NB = me('<button class="btn btn-square relative shadow-md"><!></button>'),
  jB = me('<div class="flex flex-col items-center gap-3"><!> <!> <button class="btn btn-square relative shadow-md"><!></button> <button class="btn btn-square shadow-md"><!></button></div>'),
  VB = me('<div class="flex flex-col gap-3"><button><!></button></div>'),
  qB = me('<button class="btn btn-sm btn-circle"><!></button>'),
  UB = me('<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'),
  ZB = me('<button class="btn btn-sm btn-circle"><!></button>'),
  GB = me('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
  $B = me('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'),
  HB = me('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'),
  WB = me("<span></span>"),
  XB = me('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'),
  YB = me('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'),
  KB = me('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-xl"><!></div>'),
  JB = me('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'),
  QB = me('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-1uha8ag"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function HO(_, o) {
  zr(o, !0);
  const f = cm,
    x = vb,
    A = new us(x),
    L = f - .4,
    w = E6(ui.url),
    s = w.season ?? kv,
    B = new Map;
  let j = Qe(void 0),
    K = Qe(14.5),
    ee = Qe(!1);
  const re = ct(() => {
    var vt;
    return ((vt = Mt.data) == null ? void 0 : vt.id) === 401
  });
  let de = Qe(!1),
    ne = Qe(Si(w.select && w.pos ? {
      name: "pixelSelected",
      latLon: [w.pos.lat, w.pos.lng]
    } : {
      name: "mainMenu"
    }));
  Dn(() => {
    ze().then(Gr => te(j, Gr));
    let vt = [0, 0];

    function Yt(Gr) {
      var Cn;
      if (y(j) && y(K) > f + 1) {
        const {
          lat: Zn,
          lng: mi
        } = y(j).unproject([Gr.clientX, Gr.clientY]), Gn = A.latLonToPixels(Zn, mi, f), An = Math.floor(Gn[0]), qi = Math.floor(Gn[1]);
        if (vt[0] !== An || vt[1] !== qi) {
          const yr = A.latLonToPixelBoundsLatLon(Zn, mi, f),
            dr = b_(yr, !0);
          (Cn = y(j).getSource(qe)) == null || Cn.setCoordinates(dr), vt = [An, qi]
        }
      }
    }
    return window.addEventListener("mousemove", Yt), () => {
      var Gr;
      (Gr = y(j)) == null || Gr.remove(), window.removeEventListener("mousemove", Yt), Ie && clearInterval(Ie), Tm()
    }
  }), Rs(() => [fa.theme], () => {
    if (y(j)) {
      we = !1;
      const vt = Y(fa.theme);
      y(j).setStyle(vt)
    }
  });

  function Y(vt) {
    return `https://maps.wplace.live/styles/${vt==="custom-winter"?"liberty":"fiord"}`
  }
  let we = !1,
    Ie;
  async function ze() {
    const vt = w.pos ? {
      ...w.pos,
      zoom: y(K)
    } : await x6();
    w.zoom !== void 0 && (vt.zoom = w.zoom);
    const Yt = await new Promise(Gn => {
        const An = new _p.Map({
          style: Y(fa.theme),
          center: vt,
          zoom: vt.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        An.touchZoomRotate.disableRotation(), An.on("styledata", qi => {
          we || (fa.theme === "custom-winter" && (An.setLayoutProperty("poi_transit", "visibility", "none"), An.setLayoutProperty("poi_r20", "visibility", "none"), An.setLayoutProperty("poi_r7", "visibility", "none"), An.setLayoutProperty("poi_r1", "visibility", "none"), An.setLayoutProperty("building", "visibility", "none"), An.setLayoutProperty("building-3d", "visibility", "none"), An.setLayoutProperty("landuse_pitch", "visibility", "none"), An.setLayoutProperty("landuse_hospital", "visibility", "none"), An.setLayoutProperty("landuse_school", "visibility", "none"), An.setLayoutProperty("landuse_residential", "visibility", "none"), An.setLayoutProperty("waterway_tunnel", "visibility", "none"), An.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), ke(An), He(), we = !0)
        }), An.on("style.load", () => {
          Gn(An)
        })
      }),
      Gr = ma.refreshIntervalMs;

    function Cn() {
      let Gn = y(K) > f + 1.5 ? Gr : 2.5 * Gr;
      try {
        document.visibilityState === "visible" && ke(Yt)
      } finally {
        setTimeout(Cn, Gn)
      }
    }
    Ie = setTimeout(Cn, Gr), Yt.on("load", () => {
      w.discordLinked && (vr.success(uP()), ui.url.searchParams.delete("discord-linked"), Ep(ui.url.toString())), w.twitchMigration && (vr.success(Y4()), ui.url.searchParams.delete("twitch-migration"), Ep(ui.url.toString()))
    });
    let Zn = y(K);
    Yt.on("zoom", () => {
      te(K, Yt.getZoom(), !0);
      const Gn = AB(y(K), 1);
      Gn != Zn && (y(We) && y(We).setOpacity(Ue(Zn)), Zn = Gn)
    });
    let mi = "default";
    return Yt.on("dragstart", () => {
      const Gn = Yt.getCanvas();
      mi = Gn.style.cursor, Gn.style.cursor = "move"
    }), Yt.on("dragend", () => {
      Yt.getCanvas().style.cursor = mi
    }), Yt.on("mouseout", () => {
      Le()
    }), Yt.on("click", async Gn => {
      var Tn;
      const An = Gn.lngLat.lat,
        qi = Gn.lngLat.lng,
        yr = [An, qi];
      if (y(ne).name === "paintingPixel" || y(ne).name === "selectArea") return;
      if (y(ne).name === "selectHq") {
        y(ne).hq = yr, (Tn = y(Ge)) == null || Tn.clearAndPlace(yr);
        return
      }
      const dr = Yt.getZoom();
      if (dr < L) {
        vr.info(EP());
        return
      }
      rs({
        lat: An,
        lng: qi
      }, dr), te(ne, {
        name: "pixelSelected",
        latLon: yr
      }, !0)
    }), Yt
  }
  const Re = "pixel-art-layer";

  function ke(vt) {
    const Yt = window.innerWidth,
      Gr = `${lb}/s${kv}/tiles/{x}/{y}.png`;
    if (B.clear(), !vt.style) return;
    vt.getSource(Re) ? vt.refreshTiles(Re) : vt.addSource(Re, {
      type: "raster",
      tiles: [Gr],
      minzoom: f,
      maxzoom: f,
      tileSize: Yt > 640 ? 550 : 400
    }), vt.getLayer(Re) || vt.addLayer({
      id: Re,
      type: "raster",
      source: Re,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": y(pt)
      }
    })
  }
  const qe = "pixel-hover",
    $e = 1e-5,
    Be = [
      [0, 0],
      [$e, 0],
      [$e, -$e],
      [0, -$e]
    ],
    Ee = .4;
  async function He() {
    var vt, Yt, Gr, Cn;
    if (!((vt = y(j)) != null && vt.getSource(qe))) {
      const Zn = IB(await wm(v6));
      (Yt = y(j)) == null || Yt.addSource(qe, {
        type: "canvas",
        canvas: Zn,
        coordinates: Be
      })
    }(Gr = y(j)) != null && Gr.getLayer(qe) || (Cn = y(j)) == null || Cn.addLayer({
      id: qe,
      type: "raster",
      source: qe,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": Ee
      }
    })
  }

  function Le() {
    var vt, Yt;
    (Yt = (vt = y(j)) == null ? void 0 : vt.getSource(qe)) == null || Yt.setCoordinates(Be)
  }
  let it = Qe(Si(w.opaque ?? !0)),
    pt = ct(() => y(it) ? 1 : .1);
  Zr(() => {
    var vt;
    (vt = y(j)) != null && vt.getLayer(Re) && y(j).setPaintProperty(Re, "raster-opacity", y(pt))
  });
  let Oe = Qe(void 0),
    Je = Qe(void 0),
    bt = Qe(void 0);
  Dn(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(vt => {
    vt.state === "granted" && te(bt, navigator.geolocation.watchPosition(Yt => {
      te(Oe, Yt)
    }, Yt => {
      te(Je, Yt)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    y(bt) && navigator.geolocation.clearWatch(y(bt))
  }));
  let We = Qe(void 0);
  Rs(() => [y(Oe), y(j)], () => {
    var vt, Yt;
    if (y(Oe) && y(j)) {
      const Gr = {
          lat: y(Oe).coords.latitude,
          lng: y(Oe).coords.longitude
        },
        Cn = Ue(y(K));
      if (!y(We)) {
        const Zn = document.createElement("div");
        Zn.classList.add("maplibregl-user-location-dot"), Zn.classList.add("cursor-auto"), te(We, new _p.Marker({
          element: Zn,
          opacity: Cn
        }).setLngLat(Gr).addTo(y(j)))
      }(Yt = (vt = y(We)) == null ? void 0 : vt.setLngLat(Gr)) == null || Yt.setOpacity(Cn)
    }
  });

  function Ue(vt) {
    return vt < f ? "1.0" : MB((vt - f) * .2, .5, 1).toFixed(2)
  }
  let Ge = Qe(void 0);
  Zr(() => {
    var vt;
    y(j) && ((vt = yl(() => y(Ge))) == null || vt.clear(), wm(Ov).then(Yt => {
      te(Ge, new jv({
        id: "select-crosshair",
        map: y(j),
        tileSize: x,
        zoom: f,
        img: Yt,
        markerFn: () => {
          const Gr = new _p.Marker({
            color: "#0069ff"
          });
          return Gr.addClassName("z-20"), Gr
        }
      }))
    }))
  });
  let Ve = Qe(void 0);
  Zr(() => {
    var vt;
    y(j) && ((vt = yl(() => y(Ge))) == null || vt.clear(), wm(Ov).then(Yt => {
      te(Ve, new jv({
        id: "paint-crosshair",
        map: y(j),
        tileSize: x,
        zoom: f,
        img: Yt
      }))
    }))
  });
  let mt = Qe(!1),
    lt = Qe(Si(ui.url)),
    yt = Qe(Si({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    _t = Qe(!1);
  const ut = "view-rules";
  let Ut = !1;
  Zr(() => {
    Mt.data && (!Ut && Mt.data.pixelsPainted > 1 && (localStorage.getItem(ut) || (te(_t, !0), localStorage.setItem(ut, "true"))), Ut = !0)
  });
  let Lt = Qe(!1);
  Zr(() => {
    var vt;
    te(Lt, !!((vt = Mt.data) != null && vt.needsPhoneVerification))
  });
  let Ke = Qe([]),
    ot = ct(() => y(K) < L ? "1.0" : y(K) < L + 2 ? "0.5" : "0.3");
  Zr(() => {
    var Yt;
    const vt = (Yt = Mt.data) == null ? void 0 : Yt.favoriteLocations;
    if (vt && y(j)) {
      for (const Gr of yl(() => y(Ke))) Gr.remove();
      te(Ke, vt.map(Gr => {
        const Cn = document.createElement("div");
        Cn.classList.add("text-yellow-400"), Cn.classList.add("cursor-pointer"), Cn.classList.add("z-10"), Cn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Zn = {
          lat: Gr.latitude,
          lng: Gr.longitude
        };
        return Cn.addEventListener("click", Gn => {
          Gn.stopPropagation(), xt([Gr.latitude, Gr.longitude])
        }), new _p.Marker({
          element: Cn,
          opacity: y(ot)
        }).setLngLat(Zn).addTo(y(j))
      }))
    }
  });

  function xt(vt) {
    var Gr;
    const Yt = {
      lat: vt[0],
      lng: vt[1]
    };
    (Gr = y(j)) == null || Gr.flyTo({
      center: Yt,
      zoom: Math.max(y(K), 15)
    }), rs(Yt, y(K)), te(ne, {
      name: "pixelSelected",
      latLon: [Yt.lat, Yt.lng]
    }, !0)
  }
  Zr(() => {
    if (y(ne).name === "paintingPixel")
      for (const vt of y(Ke)) vt.addClassName("hidden");
    else
      for (const vt of y(Ke)) vt.removeClassName("hidden"), vt.setOpacity(y(ot))
  });
  let Ct = Number.MAX_VALUE;
  Zr(() => {
    if (Mt.charges !== void 0 && Mt.data) {
      const vt = Mt.data.charges.max,
        Yt = Mt.charges;
      Ct < vt && Yt >= vt && Wi.notification1.play(), Ct = Mt.charges
    }
  });
  let wt = Qe(!1),
    kt = Date.now();
  Dn(() => {
    const vt = k6(),
      Yt = () => {
        var Cn;
        if (!document.hidden && Date.now() - kt > 30 * Ic.min) {
          if (vt) {
            const mi = (Cn = y(j)) == null ? void 0 : Cn.getCenter();
            mi && rs(mi, y(K)), window.location.replace(ui.url.origin)
          } else Mt.refresh();
          kt = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", Yt), () => document.removeEventListener("visibilitychange", Yt)
  }), Dn(() => {
    function vt() {
      Jr.online = !0
    }
    window.addEventListener("online", vt);

    function Yt() {
      Jr.online = !1
    }
    return window.addEventListener("offline", Yt), () => {
      window.removeEventListener("online", vt), window.removeEventListener("offline", Yt)
    }
  }), Zr(() => {
    if (!Jr.online) {
      const vt = setInterval(() => {
        Jr.health().then(() => {
          Jr.online = !0, !Mt.data && !Mt.loading && Mt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(vt)
      }
    }
  }), Dn(() => {
    if (!navigator.serviceWorker) {
      setTimeout(() => {
        console.log("Setting up service worker message listener", navigator.serviceWorker), vr.warning(g6(), {
          duration: 5e3
        })
      });
      return
    }

    function vt(Yt) {
      Yt.data.type && y(j) && ke(y(j))
    }
    return navigator.serviceWorker.addEventListener("message", vt), () => {
      navigator.serviceWorker.removeEventListener("message", vt)
    }
  });
  let Zt = Qe(!1),
    Nt = Qe("report-user"),
    $t = Qe(void 0),
    It = Qe(void 0),
    Xt = Qe(void 0),
    Ot = Qe(0),
    jt = Qe(void 0);
  Zr(() => {
    y(Zt) || (te(jt, void 0), te(It, void 0), te($t, void 0), te(Xt, void 0))
  });
  const qt = ct(() => {
    var vt;
    return Ra((vt = Mt.data) == null ? void 0 : vt.role, ["admin", "global_moderator", "moderator"])
  });
  let fr = !1,
    Kt = Qe(!1),
    _r = Qe(!1),
    rr = Qe(!1),
    hr = Qe(!1),
    nr = Qe(!1),
    Et = Qe(!1),
    kr = Qe(!!w.newUser),
    Te = Qe(!1),
    O = Qe(!!w.alliance),
    E = Qe(!1);
  const D = ct(() => y(Kt) || y(_r) || y(rr) || y(hr) || y(nr) || y(Et) || y(kr) || y(Te) || y(O) || y(E));
  var N = QB();
  Un("keypress", l_, vt => {
    if (!y(D)) switch (vt.code) {
      case "KeyC":
        if (!y(qt) || y(ne).name === "paintingPixel") return;
        te(ne, {
          name: "selectArea"
        }, !0);
        break
    }
  }), ab("1uha8ag", vt => {
    var Yt = kB();
    bn(6), nb(() => {
      ib.title = "Wplace - Paint the world"
    }), G(vt, Yt)
  });
  var H = gt(N);
  {
    const vt = yr => {
        var dr = EB();
        dr.__click = () => {
          te(it, !y(it))
        };
        var Tn = M(dr);
        {
          let gn = ct(() => !y(it));
          Uy(Tn, {
            class: "size-5",
            get filled() {
              return y(gn)
            }
          })
        }
        P(dr), je(gn => {
          mr(dr, "title", gn), Or(dr, 1, ls({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": y(it),
            "btn-primary btn-soft": !y(it)
          }))
        }, [() => N0()]), G(yr, dr)
      },
      Yt = yr => {
        var dr = LB();
        dr.__click = async () => {
          var pr;
          y(Oe) || te(Oe, await new Promise((Er, ri) => {
            navigator.geolocation.getCurrentPosition(jn => {
              Er(jn)
            }, jn => {
              ri(jn)
            })
          })), y(Oe) && (rs({
            lat: y(Oe).coords.latitude,
            lng: y(Oe).coords.longitude
          }, y(K)), (pr = y(j)) == null || pr.flyTo({
            center: {
              lat: y(Oe).coords.latitude,
              lng: y(Oe).coords.longitude
            },
            zoom: 16.5
          }))
        };
        var Tn = M(dr);
        {
          var gn = pr => {
              xB(pr, {
                class: "size-5.5 fill-blue-800"
              })
            },
            zn = pr => {
              var Er = zB(),
                ri = M(Er);
              vB(ri, {
                class: "size-5.5 fill-red-400"
              }), bn(2), P(Er), G(pr, Er)
            };
          Ae(Tn, pr => {
            y(Oe) ? pr(gn) : pr(zn, !1)
          })
        }
        P(dr), je(pr => mr(dr, "title", pr), [() => E2()]), G(yr, dr)
      };
    var W = q(M(H), 2);
    let Gr;
    var ce = M(W);
    let Cn;
    var ve = M(ce);
    {
      var he = yr => {
          var dr = DB();
          dr.__click = () => {
            var gn;
            te(hr, !0), y(j) && rs((gn = y(j)) == null ? void 0 : gn.getCenter(), y(K))
          };
          var Tn = M(dr, !0);
          P(dr), je(gn => le(Tn, gn), [() => Qb()]), G(yr, dr)
        },
        Se = yr => {
          var dr = Jt(),
            Tn = gt(dr);
          {
            var gn = zn => {
              var pr = BB(),
                Er = M(pr);
              {
                var ri = en => {
                    var Rr = RB(),
                      vn = M(Rr, !0);
                    P(Rr), je(Yr => {
                      var Ln;
                      mr(Rr, "href", ((Ln = Mt.data) == null ? void 0 : Ln.role) === "admin" ? `${ui.url.origin}/admin/dashboard` : `${ui.url.origin}/moderation`), le(vn, Yr)
                    }, [() => {
                      var Yr;
                      return w0[((Yr = Mt.data) == null ? void 0 : Yr.role) ?? "moderator"].toUpperCase()
                    }]), G(en, Rr)
                  },
                  jn = en => {
                    var Rr = Jt(),
                      vn = gt(Rr);
                    {
                      var Yr = Ln => {
                        var In = FB();
                        je(Vn => mr(In, "data-tip", Vn), [() => Z4()]), G(Ln, In)
                      };
                      Ae(vn, Ln => {
                        var In;
                        Ra((In = Mt.data) == null ? void 0 : In.role, ["community_leader"]) && Ln(Yr)
                      }, !0)
                    }
                    G(en, Rr)
                  };
                Ae(Er, en => {
                  var Rr;
                  Ra((Rr = Mt.data) == null ? void 0 : Rr.role, ["admin", "moderator", "global_moderator"]) ? en(ri) : en(jn, !1)
                })
              }
              var Sn = q(Er, 2);
              yF(Sn, {
                get user() {
                  return Mt
                },
                onlogout: () => {
                  te(ne, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  te(Kt, !0)
                },
                onnotificationclick: () => {
                  te(_r, !0)
                }
              }), P(pr), aa(3, pr, () => Wa, () => ({
                duration: 150
              })), G(zn, pr)
            };
            Ae(Tn, zn => {
              Mt.data && y(j) && y(ne).name !== "paintingPixel" && zn(gn)
            }, !0)
          }
          G(yr, dr)
        };
      Ae(ve, yr => {
        !Mt.loading && !Mt.data ? yr(he) : yr(Se, !1)
      })
    }
    var Ye = q(ve, 2);
    {
      var Ze = yr => {
          var dr = jB(),
            Tn = M(dr);
          {
            var gn = en => {
              var Rr = OB();
              Rr.__click = () => {
                var Ln;
                te(nr, !0);
                const Yr = (Ln = y(j)) == null ? void 0 : Ln.getCenter();
                Yr && rs(Yr, y(K))
              };
              var vn = M(Rr);
              Hy(vn, {
                class: "size-5"
              }), P(Rr), je(Yr => mr(Rr, "title", Yr), [() => O0()]), G(en, Rr)
            };
            Ae(Tn, en => {
              Mt.data && en(gn)
            })
          }
          var zn = q(Tn, 2);
          {
            var pr = en => {
              var Rr = NB();
              Rr.__click = () => {
                te(O, !0)
              };
              var vn = M(Rr);
              tf(vn, {
                class: "size-5"
              }), P(Rr), je(Yr => mr(Rr, "title", Yr), [() => Kp()]), G(en, Rr)
            };
            Ae(zn, en => {
              Mt.data && en(pr)
            })
          }
          var Er = q(zn, 2);
          Er.__click = () => {
            te(Et, !0)
          };
          var ri = M(Er);
          Ty(ri, {
            class: "size-5"
          }), P(Er);
          var jn = q(Er, 2);
          jn.__click = () => {
            te(rr, !0)
          };
          var Sn = M(jn);
          SB(Sn, {
            class: "size-5"
          }), P(jn), P(dr), je((en, Rr) => {
            mr(Er, "title", en), mr(jn, "title", Rr)
          }, [() => m_(), () => F0()]), aa(3, dr, () => Wa, () => ({
            duration: 150
          })), G(yr, dr)
        },
        Tt = yr => {
          var dr = Jt(),
            Tn = gt(dr);
          {
            var gn = zn => {
              var pr = VB(),
                Er = M(pr);
              let ri;
              Er.__click = () => {
                te(ee, !y(ee))
              };
              var jn = M(Er);
              {
                var Sn = Rr => {
                    i_(Rr, {
                      class: "size-5"
                    })
                  },
                  en = Rr => {
                    Dp(Rr, {
                      class: "size-5"
                    })
                  };
                Ae(jn, Rr => {
                  y(ee) ? Rr(Sn) : Rr(en, !1)
                })
              }
              P(Er), P(pr), je(Rr => {
                mr(Er, "title", Rr), ri = Or(Er, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, ri, {
                  "btn-primary": y(ee)
                })
              }, [() => y(ee) ? l2() : h2()]), aa(1, pr, () => Wa, () => ({
                delay: 150,
                duration: 150
              })), G(zn, pr)
            };
            Ae(Tn, zn => {
              y(j) && y(ne).name === "paintingPixel" && zn(gn)
            }, !0)
          }
          G(yr, dr)
        };
      Ae(Ye, yr => {
        y(j) && y(ne).name !== "paintingPixel" ? yr(Ze) : yr(Tt, !1)
      })
    }
    P(ce), P(W);
    var _e = q(W, 2);
    let Zn;
    var Vt = M(_e);
    {
      var ur = yr => {
        var dr = qB();
        dr.__click = () => {
          te(Te, !0)
        };
        var Tn = M(dr);
        _B(Tn, {
          class: "size-3.5"
        }), P(dr), je(gn => mr(dr, "title", gn), [() => f2()]), G(yr, dr)
      };
      Ae(Vt, yr => {
        y(ne).name !== "paintingPixel" && yr(ur)
      })
    }
    var Ft = q(Vt, 2),
      or = M(Ft);
    or.__click = () => {
      var yr;
      (yr = y(j)) == null || yr.zoomIn()
    };
    var Vr = q(or, 2);
    Vr.__click = () => {
      var yr;
      (yr = y(j)) == null || yr.zoomOut()
    }, P(Ft);
    var qr = q(Ft, 2);
    {
      var Wr = yr => {
        var dr = UB(),
          Tn = q(M(dr), 2);
        Tn.__click = () => {
          te(ne, {
            name: "selectArea"
          }, !0)
        };
        var gn = M(Tn);
        sh(gn, {
          class: "size-4"
        }), P(Tn), P(dr), G(yr, dr)
      };
      Ae(qr, yr => {
        y(ne).name !== "paintingPixel" && y(qt) && yr(Wr)
      })
    }
    var rn = q(qr, 2);
    {
      var hn = yr => {
        var dr = ZB(),
          Tn = M(dr);
        PB(Tn, {
          class: "size-4",
          onclick: () => {
            te(de, !y(de))
          }
        }), P(dr), je(gn => mr(dr, "title", gn), [() => Ww()]), G(yr, dr)
      };
      Ae(rn, yr => {
        y(re) && yr(hn)
      })
    }
    var cn = q(rn, 2);
    {
      var an = yr => {
        var dr = GB();
        dr.__click = () => {
          window.location.replace(ui.url.origin)
        };
        var Tn = M(dr);
        Zb(Tn, {
          class: "size-3"
        }), P(dr), je(gn => mr(dr, "title", gn), [() => $b()]), G(yr, dr)
      };
      Ae(cn, yr => {
        y(ne).name !== "paintingPixel" && yr(an)
      })
    }
    P(_e);
    var ht = q(_e, 2);
    let mi;
    var un = M(ht);
    {
      var Pn = yr => {
        var dr = $B(),
          Tn = M(dr);
        Gb(Tn, {
          class: "size-5"
        });
        var gn = q(Tn);
        P(dr), je(zn => le(gn, ` ${zn??""}`), [() => T2()]), aa(1, dr, () => Wa, () => ({
          duration: 1e3
        })), aa(2, dr, () => Wa), G(yr, dr)
      };
      Ae(un, yr => {
        Jr.online || yr(Pn)
      })
    }
    var Bt = q(un, 2);
    {
      var st = yr => {
        var dr = HB();
        dr.__click = () => {
          var zn;
          (zn = y(j)) == null || zn.flyTo({
            center: y(j).getCenter(),
            zoom: f
          })
        };
        var Tn = M(dr);
        wB(Tn, {
          class: "size-5"
        });
        var gn = q(Tn);
        P(dr), je(zn => le(gn, ` ${zn??""}`), [() => P2()]), aa(3, dr, () => Wa, () => ({
          duration: 300
        })), G(yr, dr)
      };
      Ae(Bt, yr => {
        y(K) < L && yr(st)
      })
    }
    P(ht);
    var Me = q(ht, 2);
    let Gn;
    var ft = M(Me);
    vt(ft), P(Me);
    var zt = q(Me, 2);
    let An;
    var ar = M(zt);
    {
      var br = yr => {
          Cy(yr, {
            class: "z-30",
            onclick: () => {
              var dr;
              (dr = Mt.data) != null && dr.needsPhoneVerification ? (te(Lt, !0), vr.warning(Lv())) : Mt.charges !== void 0 && Mt.charges < 1 ? vr.warning(Iz, {
                icon: rh
              }) : y(j) && Mt.data ? (Wi.smallDropplet.play(), te(ne, {
                name: "paintingPixel"
              }, !0)) : (te(hr, !0), y(j) && rs(y(j).getCenter(), y(K)))
            },
            get disabled() {
              return Mt.loading
            },
            get loading() {
              return Mt.loading
            },
            get charges() {
              return Mt.charges
            }
          })
        },
        Tr = yr => {
          var dr = WB();
          G(yr, dr)
        };
      Ae(ar, yr => {
        y(ne).name === "mainMenu" ? yr(br) : yr(Tr, !1)
      })
    }
    P(zt);
    var Dt = q(zt, 2);
    let qi;
    var Br = M(Dt);
    Yt(Br), P(Dt);
    var Ir = q(Dt, 2);
    {
      var wr = yr => {
        var dr = Jt(),
          Tn = gt(dr);
        {
          var gn = pr => {
              var Er = XB(),
                ri = M(Er),
                jn = M(ri);
              N9(jn, {
                get latLon() {
                  return y(ne).latLon
                },
                get map() {
                  return y(j)
                },
                get crosshair() {
                  return y(Ge)
                },
                get pixelInfoCache() {
                  return B
                },
                get season() {
                  return s
                },
                get tileSize() {
                  return x
                },
                get pixelArtZoom() {
                  return f
                },
                get zoom() {
                  return y(K)
                },
                get opaquePixelArt() {
                  return y(it)
                },
                onclose: () => te(ne, {
                  name: "mainMenu"
                }, !0),
                onclickshare: Sn => {
                  te(lt, Sn, !0), te(mt, !0)
                },
                onclickpaint: ([Sn, en]) => {
                  var vn, Yr, Ln;
                  if (!Mt.data) {
                    te(hr, !0);
                    return
                  }
                  if ((vn = Mt.data) != null && vn.needsPhoneVerification) {
                    te(Lt, !0), vr.warning(Lv());
                    return
                  }
                  if (Mt.charges !== void 0 && Mt.charges < 1) {
                    vr.warning(D2());
                    return
                  }
                  const Rr = w_(A.latLonToPixelBoundsLatLon(Sn, en, f));
                  (Yr = y(j)) == null || Yr.flyTo({
                    center: {
                      lat: Rr[0],
                      lon: Rr[1]
                    }
                  }), te(ne, {
                    name: "paintingPixel",
                    clickedLatLon: [Sn, en]
                  }, !0), (Ln = y(Ge)) == null || Ln.clear()
                },
                onclickregion: Sn => {
                  te(yt, Sn, !0), te(E, !0)
                },
                onclickmodaction: (Sn, en, Rr, vn) => {
                  var In, Vn, _i;
                  (In = y(j)) == null || In.setZoom(Math.max(y(K), f + 3.5));
                  const Yr = A.latLonToPixelBoundsLatLon(Rr[0], Rr[1], f);
                  if ((Vn = y(j)) == null || Vn.setCenter({
                      lat: Yr.min[0],
                      lng: (Yr.max[1] + Yr.min[1]) / 2
                    }), !(Sn != null && Sn.paintedBy)) {
                    vr.error(zv());
                    return
                  }
                  const Ln = Sn.paintedBy;
                  te($t, en, !0), te(It, [{
                    id: Ln.id,
                    name: Ln.name,
                    picture: Ln.picture,
                    allianceId: Ln.allianceId ?? void 0,
                    allianceName: Ln.allianceName ?? void 0,
                    timedOut: Ln.timedOut,
                    banned: Ln.banned
                  }], !0), te(Xt, Rr, !0), te(Ot, ((_i = y(j)) == null ? void 0 : _i.getZoom()) ?? 0, !0), te(Nt, vn, !0), te(jt, void 0), te(Zt, !0)
                }
              }), P(ri), P(Er), aa(3, ri, () => bp, () => ({
                duration: 100
              })), G(pr, Er)
            },
            zn = pr => {
              var Er = Jt(),
                ri = gt(Er);
              {
                var jn = en => {
                    var Rr = YB(),
                      vn = M(Rr),
                      Yr = M(vn);
                    YR(Yr, {
                      get map() {
                        return y(j)
                      },
                      get clickedLatLon() {
                        return y(ne).clickedLatLon
                      },
                      get tileSize() {
                        return x
                      },
                      get tileZoom() {
                        return f
                      },
                      get season() {
                        return s
                      },
                      get zoom() {
                        return y(K)
                      },
                      get crosshair() {
                        return y(Ve)
                      },
                      refreshPixelArt: () => y(j) && ke(y(j)),
                      hidePixelHover: Le,
                      hoverLayerId: qe,
                      onclose: () => {
                        te(ne, {
                          name: "mainMenu"
                        }, !0), Le()
                      },
                      get screenLocked() {
                        return y(ee)
                      },
                      set screenLocked(Ln) {
                        te(ee, Ln, !0)
                      },
                      get opaquePixelArt() {
                        return y(it)
                      },
                      set opaquePixelArt(Ln) {
                        te(it, Ln, !0)
                      }
                    }), P(vn), P(Rr), aa(3, vn, () => bp, () => ({
                      duration: 100
                    })), G(en, Rr)
                  },
                  Sn = en => {
                    var Rr = Jt(),
                      vn = gt(Rr);
                    {
                      var Yr = In => {
                          var Vn = KB(),
                            _i = M(Vn);
                          c9(_i, {
                            get map() {
                              return y(j)
                            },
                            get tileSize() {
                              return x
                            },
                            get pixelArtZoom() {
                              return cm
                            },
                            get season() {
                              return s
                            },
                            get crosshair() {
                              return y(Ve)
                            },
                            onmodaction: Ka => {
                              var Na;
                              const {
                                targets: Pi,
                                image: Fn,
                                latLon: va,
                                zoom: la,
                                action: ca,
                                onSuccess: mn
                              } = Ka;
                              if (!Pi || Pi.length === 0) {
                                vr.error(zv());
                                return
                              }
                              te($t, Fn, !0), te(It, Pi, !0), te(Xt, va, !0), te(Ot, la ?? ((Na = y(j)) == null ? void 0 : Na.getZoom()) ?? 0, !0), te(Nt, ca, !0), te(jt, {
                                onSuccess: mn
                              }, !0), te(Zt, !0)
                            },
                            onclose: () => {
                              te(ne, {
                                name: "mainMenu"
                              }, !0), Le()
                            }
                          }), P(Vn), G(In, Vn)
                        },
                        Ln = In => {
                          var Vn = Jt(),
                            _i = gt(Vn);
                          {
                            var Ka = Pi => {
                              var Fn = JB(),
                                va = M(Fn),
                                la = M(va),
                                ca = M(la),
                                mn = M(ca),
                                Na = M(mn);
                              Zy(Na, {
                                class: "inline size-4"
                              });
                              var ln = q(Na);
                              P(mn);
                              var tn = q(mn, 2);
                              tn.__click = () => {
                                te(ne, {
                                  name: "mainMenu"
                                }, !0)
                              };
                              var ds = M(tn);
                              Bs(ds, {
                                class: "size-4"
                              }), P(tn), P(ca);
                              var yn = q(ca, 2),
                                Sa = M(yn);
                              Sa.__click = async () => {
                                var ja;
                                if (y(ne).name === "selectHq") {
                                  const Va = y(ne).hq;
                                  if (Va) try {
                                    te(wt, !0), await Jr.updateAllianceHeadquarters(Va[0], Va[1]), (ja = y(Ge)) == null || ja.clear(), te(O, !0), te(ne, {
                                      name: "mainMenu"
                                    }, !0)
                                  } catch (Lo) {
                                    vr.error(Lo.message)
                                  } finally {
                                    te(wt, !1)
                                  }
                                }
                              };
                              var ea = M(Sa);
                              $y(ea, {
                                class: "size-6"
                              }), P(Sa), P(yn), P(la), P(va), P(Fn), je(ja => {
                                le(ln, ` ${ja??""}`), Sa.disabled = y(ne).hq === void 0 || y(wt)
                              }, [() => MC()]), aa(3, va, () => bp, () => ({
                                duration: 100
                              })), G(Pi, Fn)
                            };
                            Ae(_i, Pi => {
                              y(ne).name === "selectHq" && Pi(Ka)
                            }, !0)
                          }
                          G(In, Vn)
                        };
                      Ae(vn, In => {
                        y(ne).name === "selectArea" ? In(Yr) : In(Ln, !1)
                      }, !0)
                    }
                    G(en, Rr)
                  };
                Ae(ri, en => {
                  y(ne).name === "paintingPixel" && y(Ve) ? en(jn) : en(Sn, !1)
                }, !0)
              }
              G(pr, Er)
            };
          Ae(Tn, pr => {
            y(ne).name === "pixelSelected" && y(Ge) ? pr(gn) : pr(zn, !1)
          })
        }
        G(yr, dr)
      };
      Ae(Ir, yr => {
        y(j) && yr(wr)
      })
    }
    P(H), je((yr, dr) => {
      Gr = Or(W, 1, "absolute right-2 top-2 z-30", null, Gr, {
        hidden: y(de)
      }), Cn = Or(ce, 1, "flex flex-col gap-4", null, Cn, {
        "items-end": !Mt.data,
        "items-center": Mt.data
      }), Zn = Or(_e, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Zn, {
        hidden: y(de)
      }), mr(or, "title", yr), mr(Vr, "title", dr), mi = Or(ht, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, mi, {
        hidden: y(de)
      }), Gn = Or(Me, 1, "absolute bottom-3 left-3 z-30", null, Gn, {
        hidden: y(de)
      }), An = Or(zt, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, An, {
        hidden: y(de)
      }), qi = Or(Dt, 1, "absolute bottom-3 right-3 z-30", null, qi, {
        hidden: y(de)
      })
    }, [() => g2(), () => x2()])
  }
  var Xr = q(H, 2);
  Cz(Xr, {
    get open() {
      return y(hr)
    },
    set open(vt) {
      te(hr, vt, !0)
    }
  });
  var Mr = q(Xr, 2);
  fB(Mr, {
    get open() {
      return y(nr)
    },
    set open(vt) {
      te(nr, vt, !0)
    }
  });
  var nn = q(Mr, 2);
  vk(nn, {
    get open() {
      return y(kr)
    },
    set open(vt) {
      te(kr, vt, !0)
    }
  });
  var sn = q(nn, 2);
  Fk(sn, {
    get open() {
      return y(Te)
    },
    set open(vt) {
      te(Te, vt, !0)
    }
  });
  var dn = q(sn, 2);
  _k(dn, {
    get open() {
      return y(_t)
    },
    set open(vt) {
      te(_t, vt, !0)
    }
  });
  var _n = q(dn, 2);
  wz(_n, {
    onvisitclick: vt => {
      var Yt;
      (Yt = y(j)) == null || Yt.flyTo({
        center: vt,
        zoom: cm + 1
      }), rs(vt, y(K)), C6.push({
        pos: vt,
        zoom: y(K)
      }), te(Et, !1)
    },
    get open() {
      return y(Et)
    },
    set open(vt) {
      te(Et, vt, !0)
    }
  });
  var Yn = q(_n, 2);
  LF(Yn, {
    get region() {
      return y(yt)
    },
    get open() {
      return y(E)
    },
    set open(vt) {
      te(E, vt, !0)
    }
  });
  var fi = q(Yn, 2);
  Nb(fi, {
    get open() {
      return fa.dropletsDialogOpen
    },
    set open(vt) {
      fa.dropletsDialogOpen = vt
    }
  });
  var fn = q(fi, 2);
  {
    var oi = vt => {
      QA(vt, {
        onhqchange: () => {
          te(ne, {
            name: "selectHq"
          }, !0), te(O, !1)
        },
        onhqclick: Yt => {
          var Gr;
          (Gr = y(j)) == null || Gr.flyTo({
            center: Yt,
            zoom: Math.max(y(K), 15)
          }), te(ne, {
            name: "pixelSelected",
            latLon: [Yt.lat, Yt.lng]
          }, !0), te(O, !1)
        },
        onlastpixelclick: Yt => {
          var Gr;
          (Gr = y(j)) == null || Gr.flyTo({
            center: Yt,
            zoom: Math.max(y(K), 15)
          }), te(ne, {
            name: "pixelSelected",
            latLon: [Yt.lat, Yt.lng]
          }, !0), te(O, !1)
        },
        get open() {
          return y(O)
        },
        set open(Yt) {
          te(O, Yt, !0)
        }
      })
    };
    Ae(fn, vt => {
      y(j) && vt(oi)
    })
  }
  var ti = q(fn, 2);
  f7(ti, {
    get open() {
      return y(Lt)
    },
    set open(vt) {
      te(Lt, vt, !0)
    }
  });
  var xi = q(ti, 2);
  {
    var Ri = vt => {
      uk(vt, {
        get url() {
          return y(lt)
        },
        get map() {
          return y(j)
        },
        hideHover: () => {
          var Yt, Gr;
          (Yt = y(j)) == null || Yt.setPaintProperty(qe, "raster-opacity", 0), (Gr = y(Ge)) == null || Gr.setCanvasOpacity(0)
        },
        showHover: () => {
          var Yt, Gr;
          (Yt = y(j)) == null || Yt.setPaintProperty(qe, "raster-opacity", Ee), (Gr = y(Ge)) == null || Gr.setCanvasOpacity(1)
        },
        get open() {
          return y(mt)
        },
        set open(Yt) {
          te(mt, Yt, !0)
        }
      })
    };
    Ae(xi, vt => {
      y(j) && vt(Ri)
    })
  }
  var sa = q(xi, 2);
  {
    var Ci = vt => {
      kb(vt, {
        get image() {
          return y($t)
        },
        get targets() {
          return y(It)
        },
        get latLon() {
          return y(Xt)
        },
        get zoom() {
          return y(Ot)
        },
        get action() {
          return y(Nt)
        },
        onsuccess: () => {
          var Yt, Gr;
          (Gr = (Yt = y(jt)) == null ? void 0 : Yt.onSuccess) == null || Gr.call(Yt)
        },
        get open() {
          return y(Zt)
        },
        set open(Yt) {
          te(Zt, Yt, !0)
        }
      })
    };
    Ae(sa, vt => {
      y(It) && y(It).length > 0 && y($t) && y(Xt) && vt(Ci)
    })
  }
  var Vi = q(sa, 2);
  {
    var wa = vt => {
      _7(vt, {
        get userData() {
          return Mt.data
        },
        get open() {
          return y(Kt)
        },
        set open(Yt) {
          te(Kt, Yt, !0)
        }
      })
    };
    Ae(Vi, vt => {
      Mt.data && vt(wa)
    })
  }
  var ga = q(Vi, 2);
  $z(ga, {
    get open() {
      return y(_r)
    },
    set open(vt) {
      te(_r, vt, !0)
    }
  });
  var Oa = q(ga, 2);
  {
    var hs = vt => {
      HF(vt, {
        get map() {
          return y(j)
        },
        get tileSize() {
          return x
        },
        get season() {
          return s
        },
        get tileZoom() {
          return f
        },
        get open() {
          return y(rr)
        },
        set open(Yt) {
          te(rr, Yt, !0)
        }
      })
    };
    Ae(Oa, vt => {
      y(j) && vt(hs)
    })
  }
  var Ta = q(Oa, 2);
  Ae(Ta, vt => {
    y(j)
  }), G(_, N), Lr()
}
Rn(["click"]);
export {
  HO as component
};